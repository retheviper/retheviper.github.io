<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kotlin on Korean-man in Tokyo</title><link>https://retheviper.github.io/tags/kotlin/</link><description>Recent content in kotlin on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 20 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/tags/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>ifでの分岐を考える</title><link>https://retheviper.github.io/posts/kotlin-if-to-non-if/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-if-to-non-if/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post ifでの分岐を考える" />&lt;p>ほとんどの言語で、特定の条件に合致した場合にのみ実行する処理を書くには、&lt;code>if&lt;/code>のように分岐処理のための構文を使うのが当たり前のように考えられています。言語によっては構文ではなく式として扱われたり、&lt;code>switch&lt;/code>や三項演算子のような他の選択肢も存在しますが、基本的に「条件とそれに従う処理」を書く機能として本質は変わらないものですね。&lt;/p>
&lt;p>分岐処理に限った話ではありませんが、便利な道具というのは時に危険性を伴うこともあります。&lt;code>if&lt;/code>を使う場合、最初の実装ではわかりやすく簡単に目的を達成できますが、維持保守の観点からするとあまり良くない選択になるケースもありますね。たとえば条件が増えたり変わるなどコードに変更が必要となった場合は修正がすべてのケースを網羅しているかどうかがわからなくなったり、ユニットテストが困難になったりするなどが考えられます。&lt;/p>
&lt;p>なので少なくとも&lt;code>if&lt;/code>の処理をよりシンプルにしたり、もしくはデザインパターンなどで分岐の構文を使わず同じ処理ができるように改善する必要が出てくることもあるかなと思います。そうすることで、コードリーディングはより難しくなるとしても、維持保守の観点からはより良いコードになる可能性もあるでしょう。&lt;/p>
&lt;p>もちろん、完全に&lt;code>if&lt;/code>をなくするというのは不可能に近い話で、そこまでする必要もありません。道具自体に罪はなく、あくまで使い方が問題になるだけですので。ここではあくまで、&lt;code>if&lt;/code>を使ったコードをどういう風にリファクタできるか、それだけに集中したいと思います。（初心者向けな感じで）&lt;/p>
&lt;h2 id="if文の例">if文の例&lt;/h2>
&lt;p>まずは、以下の関数をご覧ください。コードと価格を渡したら、内部ではコードに合わせて元の価格から割引の値を返すというものです。極めて単純化してはいますが、ECサイトのプロモーションなどでこのような処理が存在することもあるかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (code &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Facebook&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#bd93f9">0.1&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (code &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Twitter&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#bd93f9">0.15&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (code &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Instagram&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (amount &amp;lt; &lt;span style="color:#bd93f9">1000&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>すでにどのように処理をリファクタすれば良いか、一目でわかる方もいらっしゃるかなと思いますが、ここでは色々な観点でどうコードを変えられるかを述べたいので、一つ一つ項目を挙げて説明したいと思います。&lt;/p>
&lt;h2 id="関数のリファクタ">関数のリファクタ&lt;/h2>
&lt;p>まずは関数内の処理をどう変えられるかを考えてみます。コードをより単純化して可読性を向上したり、処理の漏れをなくしたり、共通化できたり処理の単位が曖昧な場合は分離するなどいろいろな方法が考えられるはずです。&lt;/p>
&lt;h3 id="標準ライブラリ">標準ライブラリ&lt;/h3>
&lt;p>上記の関数では&lt;code>if&lt;/code>の中にさらに&lt;code>if&lt;/code>が入っている構造となっているのがわかります。このようなネストは深くなれば深くなるほど良いコードとは言えませんね。なのでまずはここから直していきましょう。&lt;/p>
&lt;p>&lt;code>if&lt;/code>のネストを一つ減らす方法として、標準ライブラリを用いた方法を考えられます。標準ライブラリでなくでも関数として分離するという選択もありますが、標準ライブラリに処理を委任することでこの関数の負担がまず減るかなと思います。&lt;/p>
&lt;p>Kotlinには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-at-least.html" target="_blank" rel="noopener"
>coerceAtLeast()&lt;/a>という関数があり、パラメータとして渡された値をミニマムとして返すという働きをします。なので、&lt;code>amount&lt;/code>が1000以下の場合は&lt;code>amount&lt;/code>自身を、それ以外は1000を返すという処理はこの関数を使うことで単純化できます。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (code &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Facebook&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#bd93f9">0.1&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (code &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Twitter&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#bd93f9">0.15&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (code &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Instagram&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> amount.coerceAtLeast(&lt;span style="color:#bd93f9">1000&lt;/span>) &lt;span style="color:#6272a4">// 閾値を超えない値となる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>単純に標準ライブラリを使用しただけですが、ネストが一つなくなりより単純なコードになりました。また、ここでの修正により閾値の修正が必要になった場合でも、1箇所だけを修正すると良いというメリットもありますね。&lt;/p>
&lt;p>他にも標準ライブラリで処理ができそうな場所は積極的に利用したり、似たような処理が繰り返されるところがあったら切り出して自前のライブラリとして分離しておくことも良い選択になるでしょう。&lt;/p>
&lt;h3 id="when">when&lt;/h3>
&lt;p>もう一つのリファクタとしては、&lt;code>if&lt;/code>を&lt;code>when&lt;/code>(他の言語の&lt;code>switch&lt;/code>)に入れ替えるという方法を考えられます。&lt;code>when&lt;/code>は結果的に同じ機能をするので、常に&lt;code>if&lt;/code>の代替として良いというわけではありません。しかし、ifの条件が一律であれば、&lt;code>when&lt;/code>を選ぶのは良い選択になる場合があります。&lt;/p>
&lt;p>先ほどの&lt;code>if&lt;/code>で分岐する条件は、あくまで&lt;code>code&lt;/code>という文字列がどのような値となっているか比較することだけですね。他には特に条件がないので、&lt;code>when&lt;/code>を用いた方がブランチを文字列だけで収めるのでより単純化つ明瞭なコードになります。たとえば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">when&lt;/span> (code) { &lt;span style="color:#6272a4">// codeの値を比較するだけの分岐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> (amount * &lt;span style="color:#bd93f9">0.1&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> (amount * &lt;span style="color:#bd93f9">0.15&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#bd93f9">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>if&lt;/code>を&lt;code>when&lt;/code>に変えただけで、全体的に短くなってより読みやすいコードになっているかと思います。このように、&lt;code>if&lt;/code>の条件文がどのようなものかをみて、&lt;code>when&lt;/code>に変えるのも場合によっては良い選択の一つになり得るかなと思います。&lt;/p>
&lt;h3 id="拡張関数">拡張関数&lt;/h3>
&lt;p>Kotlinのような言語には、拡張関数で既存のクラスにメソッドを追加する機能がありますね。同じような処理が2箇所以上繰り返されているなら関数として分離を考慮すべきで、その関数を拡張関数として定義することも場合によっては考えられます。&lt;/p>
&lt;p>ここでは&lt;code>code&lt;/code>が&lt;code>Facebook&lt;/code>か&lt;code>Twitter&lt;/code>かによる分岐がありますが、やりたいことは&lt;code>amount&lt;/code>に特定のパーセンテージをかけて返すことですね。なので、パーセンテージを求める関数を定義しておいた方が良いでしょう。&lt;/p>
&lt;p>パーセンテージを求めるのはここでしか使わないとしたら&lt;code>private&lt;/code>な関数として定義しても良いのですが、より汎用的な使い方ができるようにしたいなら、以下のような拡張関数を定義するのもありでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// パーセントを求める拡張関数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">infix&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.percentOf(amount: Int): Int = (amount * &lt;span style="color:#ff79c6">this&lt;/span> / &lt;span style="color:#bd93f9">100&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span> percentOf amount &lt;span style="color:#6272a4">// 10パーセントの値を返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">15&lt;/span> percentOf amount &lt;span style="color:#6272a4">// 15パーセントの値を返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#bd93f9">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先のほどのコードと比べ、拡張関数を定義することで処理の共通化ができたことと共に、「パーセントを計算する」という意図がコードでより明確に表れているようになっているのではないかと思います。&lt;/p>
&lt;h3 id="map">Map&lt;/h3>
&lt;p>&lt;code>if&lt;/code>や&lt;code>when&lt;/code>を使わない場合でも分岐ができる場合はあります。たとえば&lt;code>Map&lt;/code>を活用する方法ですね。&lt;code>code&lt;/code>によって違う値を掛け算したいので、&lt;code>code&lt;/code>をKeyに、掛けたい値をValueとするMapを定義しておくことです。たとえば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// コードと割引率
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> discountPercentages = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Facebook&amp;#34;&lt;/span> to &lt;span style="color:#bd93f9">10&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Twitter&amp;#34;&lt;/span> to &lt;span style="color:#bd93f9">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 割引率が定義してあったら掛け算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> discountPercentages[code]&lt;span style="color:#ff79c6">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Mapにないcodeの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#bd93f9">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法では全ての分岐を網羅することはできなくなりますね。&lt;code>code&lt;/code>の値ががMapのKeyに含まれてない場合の処理が必要となるからです。ここでクロージャを用いると&lt;code>code&lt;/code>の値が&lt;code>Instagram&lt;/code>の場合の処理もMapに含めることができます。たとえば以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Valueを(Int) -&amp;gt; Intに変える
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> discountRules = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Facebook&amp;#34;&lt;/span> to { amount: Int &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span> percentOf amount },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Twitter&amp;#34;&lt;/span> to { amount: Int &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">15&lt;/span> percentOf amount },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Instagram&amp;#34;&lt;/span> to { amount: Int &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#bd93f9">1000&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> discountRules[code]&lt;span style="color:#ff79c6">?.&lt;/span>let { &lt;span style="color:#ff79c6">it&lt;/span>(amount) } &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mapを利用する方法が条件分岐より良い方法だとは言い切れないのですが、コード別の割引率を他の関数でも参照する必要があるなど、複数の関数やクラスを跨いで共通の値を保持しておきたい場合は考えられる方法の一つになるかなと思います。この場合は、Map一つを修正するだけで全体の処理で整合性が保証されるコードになるという効果がありますね。&lt;/p>
&lt;h2 id="oop的な考え方">OOP的な考え方&lt;/h2>
&lt;p>今までは単純に関数内部の処理をどう変えていくかについて述べましたが、より高度な方法ももちろんあります。OOPの考え方として捉えると、先ほどの関数は「割引額を求める」責任がありますが、その中で「割引」の定義そのものと、その計算式まで持っていることになります。なので、責任を分離していく必要がありますね。&lt;/p>
&lt;p>この修正に処理は一見より複雑なものになっていくと感じる場合もあるかと思いますが、これはOOPに原則である&lt;a class="link" href="https://ja.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener"
>SOLID&lt;/a>を考慮したものでもあります。長期的な観点からすると、このような方法をとった方がより維持保守には向いていることになるでしょう。&lt;/p>
&lt;h3 id="interface抽出">interface抽出&lt;/h3>
&lt;p>まずは「割引ポリシー」を&lt;code>insterface&lt;/code>として分離します。この割引ポリシーを実装するクラスで実際のポリシーに従う割引額を計算するイメージです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">interface&lt;/span> &lt;span style="color:#50fa7b">DiscountPolicy&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculate&lt;/span>(amount: Int): Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> NONE: DiscountPolicy = &lt;span style="color:#ff79c6">object&lt;/span> : &lt;span style="color:#50fa7b">DiscountPolicy&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとはこの&lt;code>interface&lt;/code>を実装するクラスを、コード別に定義しておきます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">FacebookDiscountPolicy&lt;/span> : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#bd93f9">10&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">TwitterDiscountPolicy&lt;/span> : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#bd93f9">15&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">InstagramDiscountPolicy&lt;/span> : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculate&lt;/span>(amount: Int): Int = amount.coerceAtLeast(&lt;span style="color:#bd93f9">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやって割引ポリシーを定義しておくと、&lt;code>getDiscountAmount()&lt;/code>は以下のように変えられるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> discountPolicy = &lt;span style="color:#ff79c6">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> FacebookDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> TwitterDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> InstagramDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">DiscountPolicy&lt;/span>.NONE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> discountPolicy.calculate(amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="factory">Factory&lt;/h3>
&lt;p>先ほどの&lt;code>interface&lt;/code>抽出で割引ポリシー自体は分離できたものの、&lt;code>getDiscountAmount()&lt;/code>ではまだ「割引ポリシーを生成する」という責任を持っています。これもまた別の役割として分離ができるでしょう。ここは以下のように割引ポリシーを生成する&lt;code>Factory&lt;/code>を定義しておくと良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">object&lt;/span> &lt;span style="color:#50fa7b">DiscountPolicyFactory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountPolicy&lt;/span>(code: String): DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> FacebookDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> TwitterDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> InstagramDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">DiscountPolicy&lt;/span>.NONE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最終的に、&lt;code>getDiscountAmount()&lt;/code>は以下のように修正できます。&lt;code>interface&lt;/code>の抽出や&lt;code>Factory&lt;/code>の作成でコードの量は増えましたが、この関数の責任はより軽くなり、割引ポリシーの追加や修正が必要な場合でも柔軟な対応ができるようになりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> discountPolicy = &lt;span style="color:#50fa7b">DiscountFactory&lt;/span>.getDiscountPolicy(code)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> discountPolicy.calculate(amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="enum">Enum&lt;/h3>
&lt;p>割引ポリシーを生成するために&lt;code>Factory&lt;/code>を使う代わりに、&lt;code>Enum&lt;/code>を使うこともできます。先ほどの&lt;code>DiscountPolicy&lt;/code>を継承して、クラスではなく列挙定数として扱う方法です。たとえば以下のようなものが定義できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">enum&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">DiscountPolicies&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> code: String) : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FACEBOOK(&lt;span style="color:#f1fa8c">&amp;#34;Facebook&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#bd93f9">10&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TWITTER(&lt;span style="color:#f1fa8c">&amp;#34;Twitter&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#bd93f9">15&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INSTAGRAM(&lt;span style="color:#f1fa8c">&amp;#34;Instagram&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculate&lt;/span>(amount: Int): Int = amount.coerceAtLeast(&lt;span style="color:#bd93f9">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">fromCode&lt;/span>(code: String): DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> values().find { &lt;span style="color:#ff79c6">it&lt;/span>.code &lt;span style="color:#ff79c6">==&lt;/span> code } &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#50fa7b">DiscountPolicy&lt;/span>.NONE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の&lt;code>Enum&lt;/code>を利用する場合、&lt;code>getDiscountAmount()&lt;/code>は以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> discountPolicy = &lt;span style="color:#50fa7b">DiscountPolicies&lt;/span>.fromCode(code)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> discountPolicy.calculate(amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Enum&lt;/code>の場合、&lt;code>fromCode()&lt;/code>で&lt;code>code&lt;/code>による分岐そのものが必要なくなり、割引ポリシを追加したい場合でも列挙定数を追加することで拡張も容易にできるので&lt;code>Factory&lt;/code>よりも良い方法ではないかと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>最初に断っておいたように、全ての&lt;code>if&lt;/code>をなくすのは不可能に近い話で、そうする必要もありません。しかしその&lt;code>if&lt;/code>が行っている処理の本質、責任、可読性のような要素は注意深く観察する必要があり、最初は&lt;code>if&lt;/code>でとりあえず動くコードを作ったあとは他の方法で改善できるかどうか振り返ってみる必要はあるかなと思います。&lt;/p>
&lt;p>こういう自分も常に綺麗なコードを書いているわけではないのですが、たまにはこうやって初心者の気持ちで自分の書いたコードを振り返ってみるという姿勢は常に必要なのではという気持ちにもなります。良いコードを書くのは常に難しいものですね。でも、難しいことを最初にやっておいた方が後に後悔しないことにもつながるだろうと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinだけでファイルサーバを作ってみた</title><link>https://retheviper.github.io/posts/kotlin-compose-web/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-compose-web/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinだけでファイルサーバを作ってみた" />&lt;p>世の中にはさまざまなプログラミング言語があり、それぞれの特徴も明確で、言語ごとにできる・できないことも違うケースが多いですね。企業ならエンジニアの採用や費用など現実的な観点から技術選定をするので、プロジェクトにおいてどの言語を使うかは明確かつ一般的な基準があるかと思います。しかし、個人のレベルだとチームでの作業を考慮すべきでもなく、その人の好みや慣れというものから言語を選ぶ傾向があるのではないかと思います。なので、割とマイナーな言語やフレームワークを使うケースもあるでしょう。&lt;/p>
&lt;p>自分がまさにそうであって、個人的に使うために実装するアプリや自動化のスクリプトなどは、なるべくKotlinやPythonで作成しています。特にKotlinの場合、仕事でも使っているので最も慣れているからでもありますが、さまざまなフレームワークや言語自体の特徴によりサーバサイドというジャンルやJVMという環境に限らずいろいろなことにチャレンジできるのが魅力的で好きです。&lt;/p>
&lt;p>というわけで、今回もプライベートでちょっと変わった形でウェブアプリを一つ作ってみた、という話です。どこが変わっているかというと、表題にも書いてある通りですが、「Kotlin」だけでファイルサーバのアプリを実装した話となります。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>まず、どんなアプリをなぜ作ったかから述べないとですね。私の実家には、以前から使っていたWindowsのパソコンがあります。組み立てたのはおよそ8年ほど前のことで、最近は自分が実家に帰ることも少ないのであまり使われてないです。ただ、今のPC(Mac)からファイルを送ったりもらったりして使うことがあります。&lt;/p>
&lt;p>ここでファイルのやりとりには、今までMicrosoft社の&lt;a class="link" href="https://www.microsoft.com/ja-jp/microsoft-365/onedrive/online-cloud-storage" target="_blank" rel="noopener"
>OneDrive&lt;/a>を使っていました。片方で必要なファイルをOneDriveのフォルダにコピーしておくと、そのファイルがクラウドにアップロードされ、自動的に同期される方式ですね。これでも問題は全然なく安定的に使ってはいましたが、ふと思うとクラウドを経由するというステップが無駄だという気がしました。また、同期の前後でファイルをコピーしたり移動したりすることもめんどい作業になっています。&lt;/p>
&lt;p>ここで、自分でインターネット越しでファイルのやり取りができるアプリを作ってみたらどうかと思ったわけです。すでに自分が思っているような機能を提供している何らかのサービスはあるかもしれませんが、そこまで複雑なものでもないので、数日で作れるような気がしましたのでとりあえずチャレンジしてみることにしました。（SFTPというオプションもありましたが、GUIで楽にしたかったので却下です）&lt;/p>
&lt;h2 id="要件">要件&lt;/h2>
&lt;p>さて、作りたいものがあったらやることは決まっています。いつものことですが、アプリを作る前に簡単に要件を決めておきます。まず、機能的には以下のようなことができれば良いかなと思いました。&lt;/p>
&lt;ul>
&lt;li>サーバアプリを起動すると、クライアントからサーバのストレージにアクセスできる&lt;/li>
&lt;li>サーバのパスを指定したらその中身（ファイルとフォルダ）が見える&lt;/li>
&lt;li>フォルダをクリックすると表示中のパスが変わる&lt;/li>
&lt;li>ファイルをクリックするとダウンロードできる&lt;/li>
&lt;li>パスにファイルをアップロードできる&lt;/li>
&lt;/ul>
&lt;p>機能が決まったらそれを実現するための技術の番ですね。ここでは、何よりもKotlinで全て解決したい！という考えで、技術選定は全てKotlinを中心にしています。&lt;/p>
&lt;p>まずFrontendでは、ちょうどこないだ&lt;a class="link" href="https://www.jetbrains.com/lp/compose-desktop/" target="_blank" rel="noopener"
>Compose for Desktop&lt;/a>で簡単なアプリを作ったとこのブログに書いたことがありましたが、&lt;a class="link" href="https://compose-web.ui.pages.jetbrains.team/" target="_blank" rel="noopener"
>Compose for Web&lt;/a>というものもあったので、今回はこれを使ってみるとどうかなと思いました。これに関しては言語を統一したいという理由が最も大きいのですが、他にはFrontendの経験や知識があんまりないので少しでも触れてみた技術を使いたかったという理由もあります。&lt;/p>
&lt;p>Backendのフレームワークは&lt;a class="link" href="https://ktor.io/" target="_blank" rel="noopener"
>Ktor&lt;/a>にすることとしました。普段はSpringをやっているのでこちらの場合もあまり本格的な経験があるわけではありませんが、以前触れてみた感覚だとアプリの起動がはやく、実装も簡単だったので採用。また同じく、最も大きい理由はKotlin用ということです。&lt;/p>
&lt;p>大きくはこの二つで、他にも当然色々とライブラリなどが必要となるわけですが、ここは実装を進めながら必要なものがKotlin製かJetBrainsのものかを基準に選んで実装することにしました。もしくは実装において参考となるだろう公式のドキュメントに出てくるものを採用するという方針です。&lt;/p>
&lt;h2 id="frontend">Frontend&lt;/h2>
&lt;p>Frontendでは、先に述べた通りCompose for Webを使いました。やはり初めてということもあったのですが、まだ新しい技術だったり、そもそも自分がFrontendに対してあまりわかってないということもあったので最も工数がかかった部分です。ここについては、肌で感じたことを良かった点・思ったことと違った点・問題だった点という三つの軸で分けて述べていきたいと思います。&lt;/p>
&lt;h3 id="良かった点">良かった点&lt;/h3>
&lt;p>良かった点としては、やはりComposeでデスクトップアプリを作ってみた経験を活かした実装ができたというところです。Composeでは&lt;a class="link" href="https://developer.android.com/jetpack/compose/state#state-in-composables" target="_blank" rel="noopener"
>&lt;code>remember&lt;/code>と&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>&lt;/a>を組み合わせて状態を管理したり、&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Composable" target="_blank" rel="noopener"
>@Composable&lt;/a>をつけた関数の単位で画面の構成要素を分けて実装することができますが、ここでもそれは同じでした。&lt;/p>
&lt;p>なので、「指定したパスをブラウズ」する機能を実装した時、「一つ前のパスに戻る機能を追加したいな」と思ったときはそのパスを保持するために状態にパスを持たせたり、サーバから取得したパスの中身のオブジェクト（ファイルやフォルダなど）を画面に描画するためのコンポーネントを一つの&lt;code>@Composable&lt;/code>関数として定義して使ったりなどが思ったよりも簡単にできたわけです。&lt;/p>
&lt;p>他にもKotlinなのでCoroutineが簡単に使えたり、サーバサイドと同じリポジトリにソースコードを作成できるというところも良いところでした。特に後者の場合、GradleでKotlinのプラグインを&lt;code>multiplatform&lt;/code>にすることでFrontendではJavaScriptにコンパイルされ、サーバサイドではいつも通りJVMのバイトコードにコンパイルされるようにできるという点がお気に入りです。&lt;/p>
&lt;h3 id="思ったことと違った点">思ったことと違った点&lt;/h3>
&lt;p>自分の考えが甘かったのですが、Desktopとはかなり違うところがありました。何かというと、言語としてはKotlinを使うとしても、HTMLやCSSを排除することはできないという点です。ここでもやはり&lt;code>div&lt;/code>や&lt;code>form&lt;/code>のようなタグを使ったり、タグにマウスオーバ時のカーソルを変えるためにタグの&lt;code>attr&lt;/code>を変更する必要がありました。例えば、以下はファイルアップロードのコンポーネントですが、Kotlinで書いているだけで実際はHTMLをそのまま書いているような感覚です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Composable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">FileUploadForm&lt;/span>(currentPath: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Div {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Form(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action = &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$API&lt;/span>&lt;span style="color:#f1fa8c">_URL&lt;/span>&lt;span style="color:#f1fa8c">$ENPOINT&lt;/span>&lt;span style="color:#f1fa8c">_UPLOAD&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attrs = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method(&lt;span style="color:#50fa7b">FormMethod&lt;/span>.Post)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> encType(&lt;span style="color:#50fa7b">FormEncType&lt;/span>.MultipartFormData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target(&lt;span style="color:#50fa7b">FormTarget&lt;/span>.Blank)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HiddenInput {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name(&lt;span style="color:#f1fa8c">&amp;#34;target&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">value&lt;/span>(currentPath)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Input(&lt;span style="color:#50fa7b">InputType&lt;/span>.File) { name(&lt;span style="color:#f1fa8c">&amp;#34;file&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Input(&lt;span style="color:#50fa7b">InputType&lt;/span>.Submit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここは完全に他のプラットフォームでのComposeを使うというよりは、Kotlinようにラップされたクラスを提供するだけという印象が強く、やはりある程度Frontendの知識が必要となる部分ではないかと思っています。なので、&lt;a class="link" href="https://reactjs.org/" target="_blank" rel="noopener"
>React&lt;/a>や&lt;a class="link" href="https://vuejs.org/" target="_blank" rel="noopener"
>Vue.js&lt;/a>などメジャーなFrontendのフレームワークの知識がある場合にはあまりComposeを選ぶ理由はなさそうな気がしています。&lt;/p>
&lt;p>他には、いつもとは違ってKotlin/JSとKotlin/JVMが共存するプロジェクトとなっているためか、intellij上の自動補完やビルド時の挙動が少し違う感覚があります。例えば、Gradleで依存関係を変更してもすぐに反映されなかったり…&lt;/p>
&lt;h3 id="問題だった点">問題だった点&lt;/h3>
&lt;p>意外と問題になったのは、プロジェクトのビルドでした。Compose for Webでは&lt;code>index.html&lt;/code>ファイルとWebpackなどを使ってビルドされた&lt;code>js&lt;/code>ファイルを使うことになり、ビルド自体はGradleのコマンドひとつで簡単にできるものですが、どうやら内部的に&lt;a class="link" href="https://yarnpkg.com/" target="_blank" rel="noopener"
>yarn&lt;/a>などを使っているようですが、intellijで生成したプロジェクトのデフォルト設定ではビルド時にエラーが出ることが多かったです。&lt;/p>
&lt;p>調べてみると自分のようなエラーが出る場合、&lt;a class="link" href="https://github.com/Kotlin/kotlinx-datetime/issues/193" target="_blank" rel="noopener"
>ビルドできない場合はKotlinのバージョンが&lt;code>v1.6.20&lt;/code>以降だと解消される&lt;/a>らしいのですが、問題はComposeのバージョンでした。このアプリを実装した時点の最新は&lt;a class="link" href="https://github.com/JetBrains/compose-jb/releases/tag/v1.1.1" target="_blank" rel="noopener"
>v1.1.1&lt;/a>なのですが、これだと対応しているKotlinのバージョンが&lt;code>v1.6.10&lt;/code>までです。なので、自分の場合は&lt;code>v1.2.0&lt;/code>のベータ版を使ってKotlinのバージョンを&lt;code>v1.7.10&lt;/code>にしてから解消できました。これはマイナーなプロジェクトのハマりどころと言えるものかもしれないですね。&lt;/p>
&lt;p>また、HTTPクライアントとしては&lt;a class="link" href="https://ktor.io/docs/getting-started-ktor-client.html" target="_blank" rel="noopener"
>Ktor Client&lt;/a>を使っていますが、大容量のファイルをアップロードする場合を想定して&lt;code>form&lt;/code>タグでMultipartのデータを直接送るよりHTTPクライアントを使う方法を取ろうとするとうまくいかなかったです。Ktor ClientはMultiplatform対応のものなので、クライアントの宣言時に&lt;a class="link" href="https://ktor.io/docs/http-client-engines.html" target="_blank" rel="noopener"
>どのEngineを使うかを選択できる&lt;/a>のですが、Kotlin/JSで使えるEngineだと&lt;a class="link" href="https://ktor.io/docs/request.html#binary" target="_blank" rel="noopener"
>公式で紹介している内容&lt;/a>通りに実装しても&lt;code>File&lt;/code>オブジェクトを直接扱えないので送信ができませんでした。ここは今後の改善に期待するか、Websocketなどを使うなど他の方法を取る必要がありそうです。&lt;/p>
&lt;h2 id="backend">Backend&lt;/h2>
&lt;p>次にBackendですが、こちらは自分の慣れている分野で、Ktor自体については他のポストでも述べたことがあり、技術的な面の話よりはロジック面で試行錯誤をしたことを中心に述べていきたいと思います。&lt;/p>
&lt;h3 id="ファイルツリーのブラウズ">ファイルツリーのブラウズ&lt;/h3>
&lt;p>このアプリにはまずファイルをブラウズする機能があるので、クライアントで指定したパスを探索して、その中にあるコンテンツ（ファイルとフォルダ）を返す必要があります。問題は、JSONの構造をどうするかですね。ここではまず一つの方法を試してみてから判断することにしました。&lt;/p>
&lt;h4 id="全取得する">全取得する&lt;/h4>
&lt;p>最初は、以下のような形で実装をしようと思いました。パスを指定したら、その配下にある全てのフォルダをたどり、親子関係をネストで表現する形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;Documents&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;directory&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;children&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;SomeDocument.pdf&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;file&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;1391482&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;mimeType&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;application/pdf&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;Images&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;directory&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;children&amp;#34;&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようなファイルツリー返すために、サーバ側のコードは以下のようなものを使いました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ルートとなるパスを指定すると、子要素（ファイルとフォルダ）を全て取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> files = &lt;span style="color:#50fa7b">Files&lt;/span>.list(root)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#ff79c6">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#ff79c6">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// PathをJSONオブジェクトとして加工する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Path&lt;/span>.toFileTree(): FileTree {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> FileTree(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#ff79c6">this&lt;/span>.fileName.toString(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span>.isDirectory()) &lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>.fileSize(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type = &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span>.isDirectory()) &lt;span style="color:#50fa7b">FileType&lt;/span>.DIRECTORY &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#50fa7b">FileType&lt;/span>.FILE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> children = &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span>.isDirectory()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Files&lt;/span>.list(&lt;span style="color:#ff79c6">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#ff79c6">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#ff79c6">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walk-java.nio.file.Path-java.nio.file.FileVisitOption...-" target="_blank" rel="noopener"
>Files.walk()&lt;/a>を使うと、指定したパスを基準にネストされているファイルツリーを全て&lt;code>Stream&amp;lt;Path&amp;gt;&lt;/code>として取得してくれますが、それだと上記のJSONの形として加工するのが簡単ではないです。一度取得した結果をもとに、親子関係を追跡しながらJSONオブジェクトとしてまとめるにはかなり複雑な処理になるっでしょう。&lt;/p>
&lt;p>なので、ここでは&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#list-java.nio.file.Path-" target="_blank" rel="noopener"
>Files.list()&lt;/a>を使って指定したパスに含まれた要素を取得し、その要素がディレクトリの場合はさらに子要素として取得するように再帰を使って子要素を再度取得するという形としてまとめています。単純な処理ですが、効率的になりましたね。&lt;/p>
&lt;p>ただ、この方法で思った通りのファイルツリーをJSONとして返すことはできましたが、問題がありました。まず、指定したパスがルートに近くなればなるほど探索にかかる時間が長くなり、レスポンスも遅く慣ればJSONのサイズも大きくなるという問題がありました。また、JSONを受け取ったところで、Frontendで描画をするにも難点がありそうな気がしました。というわけで、この案はまず廃棄して、二つ目の方法を取ることにしました。&lt;/p>
&lt;h4 id="ネストさせない">ネストさせない&lt;/h4>
&lt;p>次に試した方法は、指定したパスのみに処理を制限することでした。何かというと、JSONオブジェクトのネストを無くして、指定したパスにどんなファイルとフォルダが含まれているかだけをリストとして返すということです。つまり、以下のような形になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;Documents&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;Images&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうなると、中のフォルダを辿る必要がなくなるのでレルポンスも早く、軽くなるわけです。最初からちゃんと考えるべきだったのですが、こちらの方がFrontendとしても実装が楽であって、さらにサブパスのフォルダにアクセスしたい場合はそのパスを再度Backendに送ればいいだけですね。コードとしては再帰を使わなくなったくらいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> files = &lt;span style="color:#50fa7b">Files&lt;/span>.list(root)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#ff79c6">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#ff79c6">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// PathをJSONオブジェクトとして加工する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Path&lt;/span>.toFileTree(): FileTree {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> FileTree(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#ff79c6">this&lt;/span>.fileName.toString(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span>.isDirectory()) &lt;span style="color:#ff79c6">null&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>.fileSize(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type = &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span>.isDirectory()) &lt;span style="color:#50fa7b">FileType&lt;/span>.DIRECTORY &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#50fa7b">FileType&lt;/span>.FILE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルアップロード">ファイルアップロード&lt;/h3>
&lt;p>ファイルアップロードについては、Mutlipartとして送られているデータをどう扱うかですが、これはKtorらしく簡単な処理で対応できました。以下のコードが実際の実装となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// router
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>post(ENPOINT_UPLOAD) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Multipartデータを受信
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> multipart = call.receiveMultipart()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ファイル保存先のパス
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> path = &lt;span style="color:#50fa7b">Path&lt;/span>.of(ROOT_DIRECTORY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> multipart.forEachPart { part &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">when&lt;/span> (part) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ルートでないパスを指定した場合は保存先を更新
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">is&lt;/span> &lt;span style="color:#50fa7b">PartData&lt;/span>.FormItem &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (part.name &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;target&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = path.resolve(part.&lt;span style="color:#ff79c6">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ファイルデータを保存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">is&lt;/span> &lt;span style="color:#50fa7b">PartData&lt;/span>.FileItem &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(&lt;span style="color:#50fa7b">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> file = &lt;span style="color:#50fa7b">Files&lt;/span>.createFile(path.resolve(part.originalFileName&lt;span style="color:#ff79c6">!!&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> part.streamProvider().use { input &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Files&lt;/span>.newOutputStream(&lt;span style="color:#ff79c6">file&lt;/span>).use { output &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input.copyTo(output)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// どちらでもない場合は一旦出力
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;Unknown part: &lt;/span>&lt;span style="color:#f1fa8c">$part&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 処理の終わったデータはdispose
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> part.dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、個人的にはストレージアクセスのある処理に対してはNIOを使いたいので、はじめは&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/nio/file/Files.html#copy-java.io.InputStream-java.nio.file.Path-java.nio.file.CopyOption...-" target="_blank" rel="noopener"
>Files.copy()&lt;/a>を使おうと思ったのですが、なぜかファイルの保存処理を以下のような作成するとうまくいかなったです。Coroutineとの相性に何か問題があるのかもしれないですので、ここは注意ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> file = &lt;span style="color:#50fa7b">Files&lt;/span>.createFile(path.resolve(part.originalFileName&lt;span style="color:#ff79c6">!!&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">Files&lt;/span>.copy(part.streamProvider(), &lt;span style="color:#ff79c6">file&lt;/span>) &lt;span style="color:#6272a4">// ファイルが保存されない
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルダウンロード">ファイルダウンロード&lt;/h3>
&lt;p>ファイルダウンロードの場合も、ロジックは特にないので、ほとんどKtorのみのコードとなっています。自分の好みでPathを使っているくらいですのでコードだけを紹介します。ひとつ注意すべきところは、アップロードする時もそうですが、ファイル名を返すときにURLパスとしてエンコードすることですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">get&lt;/span>(ENDPOINT_DOWNLOAD) {&lt;span style="color:#ff79c6">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> filepath = call.request.queryParameters[&lt;span style="color:#f1fa8c">&amp;#34;filepath&amp;#34;&lt;/span>] &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> path = &lt;span style="color:#50fa7b">FileService&lt;/span>.getFullPath(filepath) &lt;span style="color:#6272a4">// ルートディレクトリからのフルパスを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#50fa7b">Files&lt;/span>.notExists(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#50fa7b">HttpStatusCode&lt;/span>.BadRequest, &lt;span style="color:#f1fa8c">&amp;#34;File not found&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.response.header(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#50fa7b">HttpHeaders&lt;/span>.ContentDisposition,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">value&lt;/span> = &lt;span style="color:#50fa7b">ContentDisposition&lt;/span>.&lt;span style="color:#50fa7b">Attachment&lt;/span>.withParameter(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = &lt;span style="color:#50fa7b">ContentDisposition&lt;/span>.&lt;span style="color:#50fa7b">Parameters&lt;/span>.FileName,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">value&lt;/span> = path.fileName.toString().encodeURLPath()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ).toString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respondFile(path.toFile())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="注意すべきところ">注意すべきところ&lt;/h3>
&lt;p>まず、一つのプロジェクトにKotlin/JSとKotlin/JVMを両立する場合、&lt;code>dependencies&lt;/code>として記述するものに対しては&lt;code>build.gradle.kts&lt;/code>ファイルで以下のように指定することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>kotlin {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sourceSets {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Kotlin/JSの依存関係
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> jsMain &lt;span style="color:#ff79c6">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(compose.web.core)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(compose.runtime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Kotlin/JVMの依存関係
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> jvmMain &lt;span style="color:#ff79c6">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#f1fa8c">&amp;#34;io.ktor:ktor-server-core-jvm:&lt;/span>&lt;span style="color:#f1fa8c">$ktor&lt;/span>&lt;span style="color:#f1fa8c">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#f1fa8c">&amp;#34;io.ktor:ktor-server-auth-jvm:&lt;/span>&lt;span style="color:#f1fa8c">$ktor&lt;/span>&lt;span style="color:#f1fa8c">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Composeを使うためには&lt;code>plugin&lt;/code>として指定する必要があり、これがプロジェクト全体の依存関係に追加されることになっていました。なので、アプリの作りとしてはまずFrontendのComposeをビルドし、サーバを起動したらビルドしたファイルをstaticとして提供する構造になっていますが、Backendの起動にもComposeのランタイムが必要になります。このランタイムを追加してくれないと、エラーが吐き出され、Ktorが起動できなくなっています。何かKotlin/JSのみの依存関係にpluginを追加する他の方法があるかもしれませんが、とりあえずはJVMの依存関係に以下のようにランタイムを追加することで問題は解消できました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> jvmMain &lt;span style="color:#ff79c6">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#f1fa8c">&amp;#34;io.ktor:ktor-server-core-jvm:&lt;/span>&lt;span style="color:#f1fa8c">$ktor&lt;/span>&lt;span style="color:#f1fa8c">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#f1fa8c">&amp;#34;io.ktor:ktor-server-auth-jvm:&lt;/span>&lt;span style="color:#f1fa8c">$ktor&lt;/span>&lt;span style="color:#f1fa8c">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> implementation(compose.runtime) &lt;span style="color:#6272a4">// Composeランタイム
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="その他">その他&lt;/h2>
&lt;p>Kotlin/JSとKotlin/JVMを一つのプロジェクトとして扱う場合に、&lt;code>common&lt;/code>というパッケージを設けることで、コードの共有ができるのが何より嬉しかったところです。例えば、JSONオブジェクトをdata classとして定義してcommonパッケージに置くことで、FrontendとBackendの両方で同じオブジェクトを使うことができます。他にももちろんEnumやconstを共有できたりするので、実装がかなり楽でした。&lt;/p>
&lt;p>また、今回は採用しなかったのですが、Ktor Serverの場合&lt;a class="link" href="https://ktor.io/docs/type-safe-routing.html#resource_classes" target="_blank" rel="noopener"
>Type-safe Routing&lt;/a>というものに対応しているので、うまく活用できたらかなり良さそうな気がしました。これはKtor Clientでも&lt;a class="link" href="https://ktor.io/docs/type-safe-request.html#define_route" target="_blank" rel="noopener"
>Type-safe Request&lt;/a>として対応しているので、FrontendとBackend両方で使える機能です。またKtorを使う機会があったら、ぜひ使ってみたいと思っています。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>ファイルアップロードが思った通り改善できなかったので、アプリの完成はまだ少し先のことになりそうですが、かなり面白い経験となりました。Kotlinでできることは色々とあるので、また何か作ってみたいものがあればチャレンジしてみたくなります。ただ、やはりまだ成熟してない技術なので、思ってもなかったところで問題が発生したりリファレンスがあまりないという点ではまだプロダクションレベルでは使えないものかなという気がします。&lt;/p>
&lt;p>アプリ全体のコードはGitHubにて公開していますので、&lt;a class="link" href="https://github.com/retheviper/FileTransporter" target="_blank" rel="noopener"
>こちら&lt;/a>から参照できます。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinでデスクトップアプリを作ってみた</title><link>https://retheviper.github.io/posts/kotlin-compose-desktop/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-compose-desktop/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinでデスクトップアプリを作ってみた" />&lt;p>バックエンドの開発をしていると、テストの自動化では対応できない場合もありますね。理想的なシナリオとしては、ユニットテストから全てのシナリオを想定したインテグレーションテストまでを全部作成でき、開発・企画に属するものがそれらを理解しきっていることだろうとは思いますが、現実ではなかなか難しいものです。特に、サービスが成長していきながら技術的負債を解消しようとしたり、新しい機能を足したり、昔は対応できなかった改修が必要となったり、運用上のイレギュラー対応が必要となったりなどで最初の仕様は変わり続けていき、改修を行うエンジニアや運用する側でも今の状態がどうで、どう変わるべきかを判断するのは難しくなりがちなのだから、と自分は理解しています。&lt;/p>
&lt;p>なので、少なくとも今のアプリがちゃんと想定通りに動くかどうかを人の手で検証する必要が出てくるケースも十分にあり得るものです。そしてそうなった場合はどうやってテストを行うかを考える必要もありますね。テストの方法も色々あり、小さい機能単位でユニットテストを行い、最終的にはインテグレーションテストやシナリオテストまで上がっていくと良いはずですが、その全部を自動化するのが難しいケースもあるかと思います。例えばテストするためのデータのパターンを色々と用意する必要があったり、エンジニアが完全に仕様を把握してなかったりなどの場合もありますね。なので、人の手によるテスト（モンキーテスト的な）が必要となる場面も存在すると思います。&lt;/p>
&lt;p>今回はその「人の手によるテスト」を手伝うために、テストツールを作った話です。自分の扱っているシステムはマイクロサービスの一つであり、業務仕様が複雑でさまざまなパターンで機能をテストする必要がありました。なのでエンジニアとしては実装を進めながら、同時に業務仕様に詳しい人にさまざまなパターンのデータを使ってテストができるツールを作ることになったわけです。&lt;/p>
&lt;h2 id="目標と設計技術選定">目標と設計、技術選定&lt;/h2>
&lt;p>実は以前から、リポジトリにはすでにテストツールが存在していました。しかし調べたところ、作られて2年以上放置されていて、Ruby on railsという自分が全く触れたことも（興味を持ったことも）ないフレームワークで作られているという問題がありました。これだと、自分がRubyを勉強して既存のツールを改修するという手もあったかも知れませんが、以下の理由から一から作り直そうと思いました。&lt;/p>
&lt;ol>
&lt;li>KotlinエンジニアがRubyアプリをメンテするのは良くない&lt;/li>
&lt;li>ドキュメント化が進んでなく、使い方が不便&lt;/li>
&lt;/ol>
&lt;p>そう決めてからは、テストを行いたい側（企画）からの要請を受け、ツールに要求される仕様としての機能をまとめることに。テストが行えるツールという確実な目標があったので、仕様は極めて単純です。要求事項としてツールに揃うべき機能は以下のようなものでした。&lt;/p>
&lt;ul>
&lt;li>テストデータのファイルを読み込ませる&lt;/li>
&lt;li>バックエンドのアプリのAPIを呼び出す&lt;/li>
&lt;li>APIの実行結果をファイルに書き込む&lt;/li>
&lt;/ul>
&lt;p>テストツールとしては上記に挙げている要求事項を満たしているならテストツールとしては合格というわけです。しかし、実際のテストを行いたい側がまずエンジニアではなく、今後もエンジニアではない人がツールを触る可能性があります。そこまでを考慮して、以下の追加的な目標を立てました。&lt;/p>
&lt;ul>
&lt;li>環境構築をしなくても使えるようにする&lt;/li>
&lt;li>手順書がなくても使えるくらい簡単なものに仕上げる&lt;/li>
&lt;/ul>
&lt;p>ここまで決めたら、次に要求されている機能の細部を掘り下げていきます。設計書を書くほどでもないですが、土台となる設計のようなものです。&lt;/p>
&lt;ul>
&lt;li>データの読み込みと書き込み
&lt;ul>
&lt;li>ツールを使える人はSQLが使える=テーブル（表）が読める&lt;/li>
&lt;li>テーブルの形でデータの入出力ができた方がわかりやすい&lt;/li>
&lt;li>テストデータはCSVで読み込む&lt;/li>
&lt;li>API実行結果もCSVに書き込む&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>APIコールができる
&lt;ul>
&lt;li>HTTPクライアントでGET・POSTする&lt;/li>
&lt;li>APIコールにはトークンが必要
&lt;ul>
&lt;li>トークンはセキュリティ問題でソースコードに埋め込むのはNG&lt;/li>
&lt;li>しかし毎回入力するのはめんどくさい&lt;/li>
&lt;li>アプリを実行して最初はトークンを入力し、次回からはそのトークンを使い回すようにする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>本番以外の環境が対象
&lt;ul>
&lt;li>複数の環境があるのでどれかを選択できるようにする&lt;/li>
&lt;li>これも毎回入力はめんどくさい&lt;/li>
&lt;li>最初に一回だけ選択できるようにしたい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>そして自分の立てた目標を、上記の要求事項を達成できるかどうかを考えながら振り返ってみます。環境構築をしなくても使えるなら、実行可能な一つのバイナリとして提供した方が良いでしょう。また、使い方が簡単な方だと、やはりGUIを含めた方が良いですね。特にGUIを採用したら要求事項に対してもかなり良い感じで機能を完成できると思いました。&lt;/p>
&lt;p>例えばファイルの読み込みや書き込みにはパスの指定が必要で、トークンと環境の選択も入力が必要な項目で、CLIだとやはり不便です。エンジニアではない人が触るとしたら尚更ですね。Windowsユーザなら、コマンドラインも考慮しなければならないかも知れません。その反面、GUIだとファイルパスならダイアログ、トークンの入力もテキストポックス、環境の選択ならプールダウンメニューで対応できます。なので、「バイナリの実行で起動できるGUIのアプリを作る」という結論を出しています。&lt;/p>
&lt;h2 id="compose-for-desktop">Compose for Desktop&lt;/h2>
&lt;p>テストツールの仕様と技術的な要件が決まったら次は技術選定になりますがね。まずどの言語を使うかについてですが、自分以外でも同じチーム、つまりKotlinエンジニアがこれからもメンテを行うことになる可能性が高いのでKotlinにしました。Kotlinを使うことで、機能の実現で必要なライブラリの選定も楽になりますね。すでにテスト対象のバックエンドアプリで使っているHTTPクライアントがあるので、一部のコードはそのまま移植しても良いはずです。また、同じライブラリを使うことでメンテもより簡単になるでしょう。&lt;/p>
&lt;p>あとはGUIですが、今回は&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-desktop/" target="_blank" rel="noopener"
>Compose for Desktop&lt;/a>を使うことにしました。KotlinはJavaと互換性があるので、当然&lt;a class="link" href="https://ja.wikipedia.org/wiki/Swing" target="_blank" rel="noopener"
>Swing&lt;/a>や&lt;a class="link" href="https://openjfx.io/" target="_blank" rel="noopener"
>JavaFX&lt;/a>などJavaのGUIツールキットをそのまま使うという選択肢もあります。他にも&lt;a class="link" href="https://github.com/edvin/tornadofx" target="_blank" rel="noopener"
>TornadoFX&lt;/a>という選択肢があったりもしますが、今回あえてComposeを選んだのはいくつかの理由があります。&lt;/p>
&lt;p>まずは個人的にモバイルに興味があって以前から興味を持っていたので、今回本格的にこれでアプリを作ってみたいという願望もありましたが、今後もKotlinエンジニアの手でメンテが行われるとすると、やはりモバイルの経験があるか、少なくとも興味を持つ方が多いだろうという点です。Composeはまだ正式リリースされて1年ほどしか経ってない新しいものですが、最近流行っているいわゆる「宣言型」のフレームワークなので、少なくともAndroidアプリの開発ではメインストリームになる可能性が高いだろうという判断からでした。&lt;/p>
&lt;p>また、Composeはモバイルのみでなく、そもそもマルチプラットフォーム向けに開発されたものなので、Windows/Mac/Linuxの環境を問わず実行可能なバイナリをビルドできるという点でも魅力的だったです。これならテスターがどんなOSを使っていても同じ感覚でツールを使えて、&lt;/p>
&lt;p>ただ、やはり今まであまり接したことのない技術なので勉強はもちろん試行錯誤などもあったので、テストツールを作りながらこれは覚えておいた方が良いなと思ったところをいくつか挙げてみようと思います。&lt;/p>
&lt;h3 id="状態管理">状態管理&lt;/h3>
&lt;p>&lt;a class="link" href="../swift-ui-first-impression-2/" >SwiftUIのポスト&lt;/a>の時も触れた状態管理ですが、Composeでも同じくGUIを扱うことになるので、状態管理が大事となります。今回はアプリとしての画面がひとつしかないので、複数の画面にまたがって状態を管理する必要はないかなと思いましたが、それでもやはり処理を行うためにはアプリ全体で共有する状態として管理が必要なものがいくつかありました。&lt;/p>
&lt;p>ただ、上記ポストでも述べた通り、SwiftUIとComposeとは状態管理の方式が少し違います。SwiftUIでは状態がどこで使われるかによって明確に使われるアノテーションやクラスなどが変わっていたなら、Composeでは大体&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary?hl=ja#remember%28kotlin.Function0%29" target="_blank" rel="noopener"
>remember()&lt;/a>と&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState?hl=ja" target="_blank" rel="noopener"
>MutableState&lt;!-- raw HTML omitted -->&lt;/a>の組み合わせで事足りることになります。画面の構成要素の最小単位をComposeではWidgetでも使い方が同じだということは、SwiftUIと比べると定義するのは簡単ですが、使い方には少し注意が必要だなという感覚でした。&lt;/p>
&lt;p>まず、Composeでの状態は、以下のような三つの方法で定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Delegateで定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> isOn: Boolean &lt;span style="color:#ff79c6">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#ff79c6">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 直接値を書き換えできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>isOn = &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 分解宣言で定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> (isOff: Boolean, setIsOff: (Boolean) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#ff79c6">true&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 参照と更新が分離される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">if&lt;/span> (isOff) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setIsOff(&lt;span style="color:#ff79c6">!is&lt;/span>Off) &lt;span style="color:#6272a4">// toggle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// MubtableState&amp;lt;T&amp;gt;として扱う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> isNotOff: MutableState&amp;lt;Boolean&amp;gt; = remember { mutableStateOf(&lt;span style="color:#ff79c6">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ラッパーになっているので、値を更新するためにはvalueにアクセスする必要がある
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>isNotOff.&lt;span style="color:#ff79c6">value&lt;/span> = &lt;span style="color:#ff79c6">!is&lt;/span>&lt;span style="color:#50fa7b">NotOff&lt;/span>.&lt;span style="color:#ff79c6">value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでDelegateで&lt;code>var&lt;/code>として定義した場合は最も使いやすくなりますが、Intellij上ではコンパイルエラーになりがちです。なぜかというと、Delegateを使うためには&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#%28androidx.compose.runtime.MutableState%29.setValue%28kotlin.Any,kotlin.reflect.KProperty,kotlin.Any%29" target="_blank" rel="noopener"
>androidx.compose.runtime.setValue&lt;/a>と&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#%28androidx.compose.runtime.State%29.getValue%28kotlin.Any,kotlin.reflect.KProperty%29" target="_blank" rel="noopener"
>androidx.compose.runtime.getValue&lt;/a>をimportする必要がありますが、これが自動で行われないからです。最初このエラーの理由がわからなかったり、忙しい場合にいちいちimport文を書いていくが面倒だったりでかなり使わなくなるケースも多いかなという気がします。ただこれは、まだIntellijでのCompose対応が完璧ではないのが原因なので、これはいずれ解消されると期待できるでしょう。&lt;/p>
&lt;p>分解宣言で値の参照と更新を別々で使うのは、どこで使うか悩ましいケースもあるかなと思いますが、Composeの一部Widgetに状態を渡す場合に使われる場面があります。代表的なものが&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField%28kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors%29" target="_blank" rel="noopener"
>TextField&lt;/a>で、これはコードを見るとすぐにその目的がわかります。実際のコードで、以下のように使われます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> (text: String, updateText: (String) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TextField(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onValueChange = setValue, &lt;span style="color:#6272a4">// TextFieldに文字を入力するとその値でtextを更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">value&lt;/span> = text &lt;span style="color:#6272a4">// textの値をTextFieldに表示する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後に&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>として定義するケースですが、直接的な値の更新ができないので最も使い方としては不便なのですが、実際は最も多く使われるのではないかと思います。なぜかというと、アプリ全体で状態を共有するなど複数のWidgetをまたがって使う場合は、以下のようにclassの中にフィールドとして&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>を定義することになるからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// アプリ全体で共有するためにクラスに状態を定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">AppState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> isOn: MutableState&amp;lt;Boolean&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはもちろん別途&lt;a class="link" href="https://kotlinlang.org/docs/properties.html#getters-and-setters" target="_blank" rel="noopener"
>getter/setter&lt;/a>をclassに定義しておくと、中のvalueにアクセスしなくても直接プロパティにアクセスする感覚で使えます。イメージ的には以下のようなものですね。これだと状態として管理したい項目が増えれば増えるほどコードの量が増えてしまう面倒さがあるというのが短所かなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">AppState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> _isOn: MutableState&amp;lt;Boolean&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> isOn: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>() = _isOn.&lt;span style="color:#ff79c6">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">set&lt;/span>(&lt;span style="color:#ff79c6">value&lt;/span>) { _isOn.&lt;span style="color:#ff79c6">value&lt;/span> = &lt;span style="color:#ff79c6">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、Composeでの状態には定義する方法が色々あり、それぞれの特徴があるわけなのでどの場面で使うかによって適切な定義の方法を考えるのが何よりも大事だという印象です。&lt;/p>
&lt;h3 id="swingawt">Swing/AWT&lt;/h3>
&lt;p>Compose for Desktopの特徴の一つは、Swingや&lt;a class="link" href="https://en.wikipedia.org/wiki/Abstract_Window_Toolkit" target="_blank" rel="noopener"
>AWT&lt;/a>に対する互換性があるという点です。最初は&lt;a class="link" href="https://github.com/JetBrains/compose-jb/blob/master/tutorials/Tray_Notifications_MenuBar_new/README.md" target="_blank" rel="noopener"
>Macのトレイ、メニューバー、通知&lt;/a>にも対応していたので基本的な機能は全て揃っているのではないかと思いましたが、実はそうでもなく、一部の機能はSwingやAWTの機能を借りて実装することになるケースもありました。実際、私の作ったテストツールでも一部SwingとAWTの機能を使っているところがあります。&lt;/p>
&lt;p>例えばファイル選択機能がそうです。CSVを読み込むためにファイル選択のダイアログを表示したかったのですが、ComposeのWigdetではまだ対応できてないので、やむを得なくAWTの&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/FileDialog.html" target="_blank" rel="noopener"
>FileDialog&lt;/a>を使う必要がありました。以下がその実装の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 選択したファイル名を状態として保持する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> fileName &lt;span style="color:#ff79c6">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// AWTのファイル選択ダイアログを使う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>FileDialog(ComposeWindow()).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 選択できるのはCSVのみにしたい
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> setFilenameFilter { _, name &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> name.endsWith(&lt;span style="color:#f1fa8c">&amp;#34;.csv&amp;#34;&lt;/span>, ignoreCase = &lt;span style="color:#ff79c6">true&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isVisible = &lt;span style="color:#ff79c6">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ファイルが選択された場合は状態を更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (!&lt;span style="color:#ff79c6">file&lt;/span>.isNullOrBlank()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileName = &lt;span style="color:#ff79c6">file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これでも十分ではない場合もありました。フォルダのみを選択できるようにしたい場合に&lt;code>FileDialog&lt;/code>はあまり良い選択ではなかったのです。名前からそうですが、あくまでファイルの選択を想定したものであるため、フォルダのみを選択できるようにはできなかったのです。なので、フォルダのみを選択できるようにするためには、Swingの力も借りる必要があります。その場合は、以下のように実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 選択したフォルダのパスを状態として保持する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> selectedPath &lt;span style="color:#ff79c6">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Swingのファイル選択ダイアログをディレクトリのみ選択できるように設定して定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> fileChooser = JFileChooser().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dialogTitle = &lt;span style="color:#f1fa8c">&amp;#34;Choose Directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileSelectionMode = &lt;span style="color:#50fa7b">JFileChooser&lt;/span>.DIRECTORIES_ONLY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ダイアログを表示する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">if&lt;/span> (fileChooser.showOpenDialog(ComposeWindow()) &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#50fa7b">JFileChooser&lt;/span>.APPROVE_OPTION) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ダイアログで選択したパスが状態として保持しているパスと違う場合、選択したディレクトリの絶対パスを状態として更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> path = fileChooser.selectedFile.absolutePath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (selectedPath &lt;span style="color:#ff79c6">!=&lt;/span> path) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectedPath = path
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回はこの二つユースケースのみSwingやAWTが登場していませんでしたが、どんなアプリを実装するかによって他のAPIも色々と使う必要性が出てくるかも知れないという良い一例になっている気がします。まだComposeはリリースされて1年ほどしか経っていないので、今後のバージョンアップでより多彩なWidgetが追加されることに期待ですね。&lt;/p>
&lt;h3 id="ビルド">ビルド&lt;/h3>
&lt;p>Composeを選んだ理由の一つのバイナリのビルドができるという点ですが、これはかなり満足度が高かったです。&lt;code>gradle&lt;/code>を使って、コマンドひとつで実行可能なバイナリが生成されます。Macでビルドして見ると、他のアプリと同じくパッケージが生成されます。中を見ると、実行に必要なJREと依存関係のJarが含まれていて、ネイティブではなくJVM上で起動される構造になっていました。&lt;/p>
&lt;p>バイナリをビルドするときのオプションには色々なものがあり、OSの種類(Windows, Mac, Linux)によって違うアイコンを使ったり、基本的には含まれないモジュールを含むように指定したりすることができました。以下が実際のビルド時のオプションのサンプルです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>compose.desktop {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> application {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mainClass = &lt;span style="color:#f1fa8c">&amp;#34;com.testtool.MainKt&amp;#34;&lt;/span> &lt;span style="color:#6272a4">// 実行時のメインクラスを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> nativeDistributions {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> packageName = &lt;span style="color:#f1fa8c">&amp;#34;Test Tool&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> packageVersion = &lt;span style="color:#f1fa8c">&amp;#34;1.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modules(&lt;span style="color:#f1fa8c">&amp;#34;java.sql&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;java.naming&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// デフォルトでは含まれないパッケージを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> macOS {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iconFile.&lt;span style="color:#ff79c6">set&lt;/span>(project.&lt;span style="color:#ff79c6">file&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;misc/appicon/icon-mac.icns&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> windows {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iconFile.&lt;span style="color:#ff79c6">set&lt;/span>(project.&lt;span style="color:#ff79c6">file&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;misc/appicon/icon-win.ico&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ビルド時は注意が必要です。ビルドするとき、Composeでは内部的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/14/docs/specs/man/jpackage.html" target="_blank" rel="noopener"
>jpackage&lt;/a>を使うので、まずJava 15以上が必要となります。また、CPUのアーキテクチャによって違うJDKをインストールするようになっているため、ビルドするマシンと違うのアーキテクチャのCPUを使っているマシンをターゲットにすることはできません。&lt;/p>
&lt;p>つまり、自分の使用のMacだとApple Silicon用のバイナリが生成され、IntelチップのMacだとx64用のバイナリが生成されるということです。実際ComposeでApp Storeにアプリを提出した人もいるらしいのですが、Rosettaで起動できるということでIntelチップのMacを使ってビルドしているとのことでした。Universal Binaryを作りたい場合は、JDKそのものがまずUniversal Binaryとして提供されることを待つしかなさそうです。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回はデスクトップアプリの中でもかなり制限された機能と単純なロジックしかないシンプルなものを作ったので、もしこれからまたComposeを使ってさまざまな機能を持つように実装するとしたら(マルチウィンドウやダークモード対応、ナビゲーションなど)また色々と発見があるかも知れない気がしています。個人的にはかなりためになる経験で、思ったより実装もそこまで難しくなかったので、ツールの機能を拡張するか新しいツールを作ってみるチャンスがあるとしたら再度Composeを使ってみたいなと思いました。&lt;/p>
&lt;p>まだリリースされてからそう長くもなく、足りない機能や情報も多かったり競合のフレームワークが色々とあるので未来はどうなるかわからないものですが、自分のようにKotlinをメインとしているエンジニアで、GUIに興味がある方なら一度はComposeを使って見ることをお勧めしたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>data classのListをCSVにする</title><link>https://retheviper.github.io/posts/kotlin-write-csv/</link><pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-write-csv/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post data classのListをCSVにする" />&lt;p>アプリを書いていると、DBに保存した形とは違う形でデータを読み込んだり出力するケースが多いです。代表的に、多くのバックエンドアプリで採用しているREST APIがそうですね。APIの入力値と戻り値は、DBに保存されている形とは一致しないケースが多く、必要(リクエストを送信してきた側の都合)に合わせて適切にパラメータを受け取り、レスポンスを返すようになっています。そして時と場合によっては、人間が楽に読める形としてデータをまとめる必要もあります。そういった場合はExcelファイルやCSV、PDFといったいろいろなものを想定できますね。&lt;/p>
&lt;p>今回のポストも場合も人が読める形のファイルとして、特にCSVを扱う場合にKotlin側の実装をどうやっていくかに関するものです。&lt;/p>
&lt;h2 id="kotlinでcsvを扱う">KotlinでCSVを扱う&lt;/h2>
&lt;p>KotlinのCSV読み込み/書き込みのライブラリとして&lt;a class="link" href="https://github.com/doyaaaaaken/kotlin-csv/" target="_blank" rel="noopener"
>kotlin-csv&lt;/a>があり、JVMだけでなくKoltin/JSの場合でもこのライブラリを使って簡単にCSVを扱えます。更に&lt;a class="link" href="https://github.com/blackmo18/kotlin-grass" target="_blank" rel="noopener"
>kotlin-grass&lt;/a>というライブラリもあり、&lt;code>kotlin-csv&lt;/code>との組み合わせででCSVのデータを簡単にdata classのListとしてまとめることもできますね。読み込みの際に指定できるデータのフォーマットやカスタムマッピングオプションなどの機能も豊富にあり、かなり使いやすく良いライブラリとなっています。&lt;/p>
&lt;p>しかし、実は&lt;code>kotlin-csv&lt;/code>を使うときに問題が一つあります。先に述べた通りCSVにデータの出力そのものは可能なものとなっているのですが、読み込みの時にdata classへのマッピングには別のライブラリが必要であったように、data classのリストを書き込むには追加の処理が必要となります。これは、kotlin-csvの書き込み用のメソッドが以下のようになっているからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">writeAll&lt;/span>(rows: List&amp;lt;List&amp;lt;Any?&amp;gt;&amp;gt;, targetFile: File, append: Boolean = &lt;span style="color:#ff79c6">false&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">open&lt;/span>(targetFile, append) { writeRows(rows) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>rows&lt;/code>が書き込みで使うデータとなりますが、型が&lt;code>List&amp;lt;List&amp;lt;Any?&amp;gt;&amp;gt;&lt;/code>になっているので、列のデータを一つの行としてListに定義し、それをさらにListに格納することでCSVのデータ全体を定義する必要があります。これはつまり、data classのリストを書き込むためには、フィールド一つ一つを列として定義し、それらをListとしてまとめる必要があるということです。また、CSVには一般的にヘッダが含まれますが、&lt;code>List&amp;lt;List&amp;lt;Any?&amp;gt;&amp;gt;&lt;/code>の形だと最初の行にヘッダのみを定義した行は必要となることでもありますね。&lt;/p>
&lt;p>一見複雑に見えますが、&lt;a class="link" href="https://kotlinlang.org/docs/reflection.html" target="_blank" rel="noopener"
>reflection&lt;/a>を利用すると、data classのフィールド名とその値を得ることができますので、それを利用してdata classのListをこのメソッドに適した形に変えられます。これをヘッダを作る方法と、data classの値を行に変更する二つの段階で分けて説明していきます。&lt;/p>
&lt;h3 id="data-classからヘッダを作る">data classからヘッダを作る&lt;/h3>
&lt;p>まずはヘッダを作ります。ヘッダを作るには、data classからフィールドを取得し、そのフィールドの名前のみを取得するといいでしょう。&lt;code>id&lt;/code>というフィールドがあるとしたら、ヘッダもそのまま&lt;code>id&lt;/code>になるということです。フィールド名とは別の名前をつけたい場合はアノテーションを活用する方法を考えられますが、まずはフィールド名をそのまま使う方法から述べたいと思います。&lt;/p>
&lt;p>Kotlinのdata classから、フィールドを取得する方法が3つがあります。まずは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/members.html" target="_blank" rel="noopener"
>KClass.members&lt;/a>があります。ただ、これだとメソッドを含め、全てのメンバーを持ってくることになります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Data&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> id: Int, &lt;span style="color:#ff79c6">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> members = Data&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.members
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(members)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String, fun Line_2.Data.component1(): kotlin.Int, fun Line_2.Data.component2(): kotlin.String, fun Line_2.Data.copy(kotlin.Int, kotlin.String): Line_2.Data, fun Line_2.Data.equals(kotlin.Any?): kotlin.Boolean, fun Line_2.Data.hashCode(): kotlin.Int, fun Line_2.Data.toString(): kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>フィールド名が現れているのでこれも使える方法の一つではありますが、やはりdata classだと基本的に&lt;code>equals()&lt;/code>, &lt;code>hashCode()&lt;/code>, &lt;code>copy()&lt;/code>, &lt;code>toString()&lt;/code>, &lt;code>componentN()&lt;/code>のようなメソッドが
できてしまうので、これらをフィルタする必要があります。例えば、以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> memberProperties = Data&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.members.filterNot { &lt;span style="color:#ff79c6">it&lt;/span>.name.contains(&lt;span style="color:#f1fa8c">&amp;#34;component&amp;#34;&lt;/span>) &lt;span style="color:#ff79c6">||&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.name &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;copy&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.name &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;equals&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.name &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;hashCode&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.name &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;toString&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(memberProperties)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、フィルタをしなくてももっと簡単にフィールドのみを抽出できる方法もあります。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/member-properties.html" target="_blank" rel="noopener"
>memberProperties&lt;/a>を使うことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> memberProperties = Data&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.memberProperties
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(memberProperties)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法にも問題はあります。取得したフィールドの順番が、data classに定義した通りにならなく、アルファベット順になるということです。以下の例を見ると、nameとageの順で定義したフィールドが、ageとnameの順になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Person&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> name: String, &lt;span style="color:#ff79c6">val&lt;/span> age: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> memberProperties = Person&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.memberProperties
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(memberProperties) &lt;span style="color:#6272a4">// name, age順にならない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// [val Line_11.Person.age: kotlin.Int, val Line_11.Person.name: kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでどうしてもフィールドを定義した順に取得したい場合、data classのコンストラクタを使う方法があります。まずはコンストラクタを使った方法ですが、これはdata classに、自動的にコンストラクタがフィールドを定義した順番通りのパラメータを持つように生成されるということを利用した方法です。以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> parameters = Person&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.primaryConstructor&lt;span style="color:#ff79c6">!!&lt;/span>.parameters.mapNotNull { &lt;span style="color:#ff79c6">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(parameters) &lt;span style="color:#6272a4">// [name, age]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多少強引な方法ではありますが、これでフィールドとして使うフィールド名は取得できました。では、次にアノテーションを使う場合を見ていきましょう。&lt;/p>
&lt;h4 id="アノテーションを使う場合">アノテーションを使う場合&lt;/h4>
&lt;p>フィールド名をそのままヘッダとして利用したくない場合は、アノテーションを活用できます。フィールドとしてStringを持つアノテーションを定義して、ヘッダを読み取るときにそのフィールドにつけたアノテーションを取得するという方法です。例えば、以下のようなアノテーションを定義したとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Target(&lt;span style="color:#50fa7b">AnnotationTarget&lt;/span>.PROPERTY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">annotation&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">CsvHeaderName&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> value: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>アノテーションは、以下のようにdata classで使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Person&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @CsvHeaderName(&lt;span style="color:#f1fa8c">&amp;#34;名前&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @CsvHeaderName(&lt;span style="color:#f1fa8c">&amp;#34;年齢&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> age: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてこのdata classのアノテーションを取得していきます。&lt;code>memberProperties&lt;/code>でフィールドを取得した場合、そのフィールドからアノテーションの一覧(アノテーションは複数存在できるので)を取得し、そこから先に定義した&lt;code>CsvHeaderName&lt;/code>のみをフィルタします。あとはアノテーションがあるかどうかをみて、どちらの値を使うかを決めればいいですね。以下のコードが、そのサンプルです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> datas = listOf(Person(&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">20&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> headers = datas.first()&lt;span style="color:#ff79c6">!!::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.memberProperties.map { &lt;span style="color:#ff79c6">property&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name = &lt;span style="color:#ff79c6">property&lt;/span>.annotations.filterIsInstance&amp;lt;CsvHeaderName&amp;gt;().firstOrNull() &lt;span style="color:#6272a4">// アノテーションはないケースもある
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> name&lt;span style="color:#ff79c6">?.&lt;/span>&lt;span style="color:#ff79c6">value&lt;/span> &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">property&lt;/span>.name &lt;span style="color:#6272a4">// アノテーションがnullの場合は、フィールド名を使う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(headers) &lt;span style="color:#6272a4">// [年齢, 名前]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>primaryConstructor&lt;/code>のパラメータで取得した場合でも、やり方は大きく変わりません。この場合は、コンストラクタのパラメータを基準にループしながら一致するフィールドを探すという処理が追加されるだけです。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> fieldNames = seeds.first()&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.primaryConstructor&lt;span style="color:#ff79c6">!!&lt;/span>.parameters.mapNotNull { &lt;span style="color:#ff79c6">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> headers = fieldNames.mapNotNull { name &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// パラメータと一致するフィールドを対象に処理を行う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> datas.first()&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.memberProperties.find { &lt;span style="color:#ff79c6">it&lt;/span>.name &lt;span style="color:#ff79c6">==&lt;/span> name }&lt;span style="color:#ff79c6">?.&lt;/span>let { &lt;span style="color:#ff79c6">property&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> headerName = &lt;span style="color:#ff79c6">property&lt;/span>.annotations.filterIsInstance&amp;lt;CsvHeaderName&amp;gt;().firstOrNull()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headerName&lt;span style="color:#ff79c6">?.&lt;/span>&lt;span style="color:#ff79c6">value&lt;/span> &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">property&lt;/span>.name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで、ヘッダのデータはできました。次は、このヘッダに合わせて下に出力する行としてdata classをListに変換するのみですね。&lt;/p>
&lt;h3 id="data-classをlistに変える">data classをListに変える&lt;/h3>
&lt;p>ヘッダの処理で既にやっていたように、data classをListに変換する場合でも処理は大きく変わりません。違う点は、フィールドから実際のデータを取得するだけですね。ここでは、コンストラクタからパラメータを取得した場合を想定してコードを書きましょう。&lt;/p>
&lt;p>Kotlinのreflectionでフィールドの値を取得する場合はJavaと変わらなくて、取得したフィールドにdata classのインスタンスを渡すだけとなります。ただ、フィールドがnullの場合は考慮する必要があります。nullになってしまうと、その列自体がスキップされ、最終的に出力されたCSVのデータで列がずれる場合があるからです。なので、空白のStringを指定するなどで、行ごとの長さ(Listのサイズ)を合わせる必要があります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>datas.map { d &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fieldNames.mapNotNull { name &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.memberProperties.find { &lt;span style="color:#ff79c6">it&lt;/span>.name &lt;span style="color:#ff79c6">==&lt;/span> name }&lt;span style="color:#ff79c6">?.&lt;/span>let { &lt;span style="color:#ff79c6">field&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">field&lt;/span>.call(d) &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#6272a4">// フィールドの値を取得し、nullのばいは空白にする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここで時間や日付を扱う場合、フォーマッタを利用したいケースがあるかと思います。例えば、アプリの中では&lt;code>LocalTime&lt;/code>として扱っているが、CSVとしては&lt;code>HH:mm&lt;/code>のような形で出力したい場合や、&lt;code>LocalDate&lt;/code>を&lt;code>yy/MM/dd&lt;/code>にしたい場合などですね。ここでフォーマット自体は、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>を使うだけですが、問題は取得したフィールドがどの型であるかの判定です。&lt;/p>
&lt;p>Kotlinのreflectionで取得したフィールドは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property1/" target="_blank" rel="noopener"
>KProperty1&lt;/a>という型になっています。ここでどうやって元の型を取得するかが問題ですね。このクラスは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-callable/" target="_blank" rel="noopener"
>KCallable&lt;/a>というインタフェースを実装していて、ここには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-callable/return-type.html" target="_blank" rel="noopener"
>returnType&lt;/a>というプロパティがあります。これで&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-type/" target="_blank" rel="noopener"
>KType&lt;/a>というインタフェースが取得できるようになるので、これを持って判定をおこ泣くことになります。&lt;/p>
&lt;p>しかし、名前から分かるように、&lt;code>KType&lt;/code>はKotlinの型に関するインタフェースとなっています。比較したい&lt;code>LocalDate&lt;/code>や&lt;code>LocalTime&lt;/code>などのクラスはJavaのものなので、直接的な比較ができないですね。幸い、JavaのクラスでもKotlinで参照できる&lt;code>Ktype&lt;/code>として変換することはできます。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> localDateKType: KType = LocalDate&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、あとは分岐によって適切なフォーマッタを使うだけですね。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>datas.map { d &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fieldNames.mapNotNull { name &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.memberProperties.find { &lt;span style="color:#ff79c6">it&lt;/span>.name &lt;span style="color:#ff79c6">==&lt;/span> name }&lt;span style="color:#ff79c6">?.&lt;/span>let { &lt;span style="color:#ff79c6">field&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">field&lt;/span>.call(d)&lt;span style="color:#ff79c6">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">when&lt;/span> (&lt;span style="color:#ff79c6">field&lt;/span>.returnType) { &lt;span style="color:#6272a4">// タイプによる分岐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> LocalDate&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType() &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> dateFormatter.format(&lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">as&lt;/span> LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalTime&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType() &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> timeFormatter.format(&lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">as&lt;/span> LocalTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalDateTime&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType() &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> dateTimeFormatter.format(&lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">as&lt;/span> LocalDateTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここでもう一つ注意しなければならないのは、nullableなフィールドのKTypeは別のものになるということです。つまり、上記のコードでは、以下のようなdata classのフィールドは分岐処理でフォーマッタが働かなくなるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// どのフィールドもフォーマットされない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">DateTimes&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> date: LocalDate?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> time: LocalTime?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> dateTime: LocalDateTime?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合は、&lt;code>KType&lt;/code>を作るときにnullableであることを指定することで簡単に解決できます。あとは分岐で、両方チェックするようにするだけです。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>datas.map { d &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fieldNames.mapNotNull { name &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.memberProperties.find { &lt;span style="color:#ff79c6">it&lt;/span>.name &lt;span style="color:#ff79c6">==&lt;/span> name }&lt;span style="color:#ff79c6">?.&lt;/span>let { &lt;span style="color:#ff79c6">field&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">field&lt;/span>.call(d)&lt;span style="color:#ff79c6">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">when&lt;/span> (&lt;span style="color:#ff79c6">field&lt;/span>.returnType) { &lt;span style="color:#6272a4">// nullableでもnullableではない場合でも分岐でフォーマットする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> LocalDate&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType(), LocalDate&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType(nullable = &lt;span style="color:#ff79c6">true&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> dateFormatter.format(&lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">as&lt;/span> LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalTime&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType(), LocalTime&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType(nullable = &lt;span style="color:#ff79c6">true&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> timeFormatter.format(&lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">as&lt;/span> LocalTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalDateTime&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType(), LocalDateTime&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.createType(nullable = &lt;span style="color:#ff79c6">true&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> dateTimeFormatter.format(&lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">as&lt;/span> LocalDateTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは、ヘッダと、data classから取得した値のリストを結合して&lt;code>kotlin-csv&lt;/code>の&lt;code>writeAll()&lt;/code>に渡すだけですね。一つ、値は上記のコードで既に&lt;code>List&amp;lt;List&amp;lt;Any&amp;gt;&amp;gt;&lt;/code>の形となっていますが、ヘッダは&lt;code>List&amp;lt;String&amp;gt;&lt;/code>なので、ヘッダは更にListに入れる必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ヘッダ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> header = &lt;span style="color:#6272a4">// 省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 実際のデータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> rows = datas.map { &lt;span style="color:#6272a4">/** 省略 */&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>csvWriter().writeAll(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows = listOf(headers) + rows,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetFile = targetFile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでヘッダが先に行に書き込まれ、次の行からはdata classのフィールドに格納した実際の値が出力されることになりました。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>この度軽く「KotlinなんだからKotlin制のライブラリを使おう」と、軽い気持ちで採用したライブラリが想定していたものと違ったので困っていましたが、幸いJavaを使っていた時に&lt;a class="link" href="https://poi.apache.org/" target="_blank" rel="noopener"
>Apache POI&lt;/a>を使って似たような機能をするライブラリを作ってみた経験があったのでその知識を活かせたと言えます。当時はまだ駆け出しのエンジニア(今もそうと思っていますが)だったので大変苦労した思い出でもありますが、今はその経験があってこそ対処できたようなものなので大変ありがたい経験だったなと思いました。&lt;/p>
&lt;p>上記のコードに対してはちょっとしたライブラリを作ってみたので、またどこかで活用してみたいものですね。色々と改善して、のちにMaven Repositoryのようなところでも公開できるようになったらなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>SwiftUIを触ってみた〜その2〜</title><link>https://retheviper.github.io/posts/swift-ui-first-impression-2/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/swift-ui-first-impression-2/</guid><description>&lt;img src="https://retheviper.github.io/images/swift.jpg" alt="Featured image of post SwiftUIを触ってみた〜その2〜" />&lt;p>前回に続いて、今回はSwiftUIを触りながら感じたことについて述べたいと思います。自分のように、今までバックエンドの実績しかないエンジニアがGUIを作るとしたら、画面のレイアウトや色合い、画面間の繊維など「今までなかった概念」で混乱することも多いかなと思います。そしてその中でも特に難しい、うまく扱えない機能などもあるかなと思います。&lt;/p>
&lt;p>自分の場合、プロダクションレベルのコードを書いたことはないものの、以前から&lt;a class="link" href="https://reactnative.dev/" target="_blank" rel="noopener"
>React Native&lt;/a>, &lt;a class="link" href="https://flutter.dev/" target="_blank" rel="noopener"
>Flutter&lt;/a>, &lt;a class="link" href="https://developer.android.com/jetpack/compose" target="_blank" rel="noopener"
>Jetpack Compose&lt;/a>には少し触れたことがあったためSwiftUIで「画面を構成する方式」については少し理解しているつもりでした。しかし、やはりバックエンドでは存在しない機能がありました。&lt;/p>
&lt;p>今回はそのSwiftUIの話となりますが、中でも私が注目した機能もしくは概念について述べたいと思います。&lt;/p>
&lt;h2 id="swiftui">SwiftUI&lt;/h2>
&lt;p>まずは、SwiftUIそのものに対して簡単に紹介しましょう。SwiftUIはいわゆる宣言型(Declarative)UIのフレームワークで、&lt;a class="link" href="https://ja.reactjs.org/" target="_blank" rel="noopener"
>React&lt;/a>や&lt;a class="link" href="https://vuejs.org/" target="_blank" rel="noopener"
>Vue&lt;/a>などのフロントエンドからの影響が見えます。要するに、画面を構成する要素(Widget, Component, Materialなどフレームワークやライブラリによって呼び方は様々ですが)を一つのオブジェクトとして「宣言」し、それらの要素の組み合わせによって一つの画面を完成するという形になっているということです。このような宣言型UIはSwiftUIだけでなく、モバイルに限定してもReact NativeやFlutter、Jetpack Composeなど様々なフレームワークやライブラリで採択しているものでもあります。&lt;/p>
&lt;p>そして、要素の実装についてもフレームワークやライブラリによって色々と方法が分かれますが、SwiftUIでは、個別の要素はViewといい、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"
>View&lt;/a>というprotocolをstructとして実装していきます。なので、一覧を表示する画面であれば、一つの行としてデータを表示するView、その行をリストとして表示するためのView、さらに一覧の上や下にメニューを表示するViewなどが一つ一つのstructとして定義されていく形ということです。&lt;/p>
&lt;p>このような画面の作り方は、フレームワークのパラダイム・コンセプトとして決まってあるものなので、それに従って実装を進めることには私のようにバックグラウンドが全く違うエンジニアでも特に問題はないかなと思います。&lt;/p>
&lt;p>ただ、実際のアプリを作るとしましょう。画面に対してはフレームワークで提示する通り要素を実装して作ったとしたら、アプリを実行してなんらかの処理を行うためにはバックエンドを繋げるか、アプリ内でなんらかの処理を行うかなど「ロジック」とつなげる必要があるはずです。ここで常にとは言い難いのですが、バックエンドでは見慣れない概念が出てくる場合があります。「状態」というものです。&lt;/p>
&lt;h2 id="状態">状態&lt;/h2>
&lt;p>バックエンドのアプリを実装している場合は、リクエストがあり、それに対してのレスポンス（HTTPステータスのみだとしても）がある、という明確なプロセスがありますね。この一連の処理には、「途中で変化する」という概念はありません。この場合のデータは永続化されるか、処理が終了するまでの一時的な物が多いです。&lt;/p>
&lt;p>しかし、画面の世界だと話は変わってきます。多くのモバイルアプリではスライダ、ボタン、テキストボックスなどいろいろな要素で構成されてあり、それらの要素に関する状態が常に変わってくるケースもあるのです。ファイルをダウンロードしている状態を表示するためのプログレスバーがあるとしたら、単純に進行状況を見せるとしたら一つのスレッドを割り当てて処理するだけで良いでしょう。&lt;/p>
&lt;p>ここで一つ、もしダウンロードに「一時停止」のような機能があったらどうでしょうか。プロセスが進行中にボタンを押下したら止まり、再度押下したら再開されるような機能です。他にも色々と考慮すべきものはあるかと思いますが、この「停止している」「再開した」という概念をどこかに記憶しておく必要はあるでしょう。つまり、画面においてのユーザの入力に対して、なんらかの処理を実際に行うまで記憶しておくための機構が必要ということですね。&lt;/p>
&lt;p>SwiftUIでももちろん、状態を管理するためのものがあります。ただ、ユースケースで考えると画面の要素(View)一つに限って必要なものか、それとも複数の要素において必要なものか、複数の画面（アプリ全体）にかけて必要なものかという、スコープによって必要な状態は違うものになります。View一つで必要なものをアプリ全体で管理する必要もなければ、複雑になりがちだからですね。なので、ここではそのスコープ別に状態を管理するためにどんなものがあるのかについて述べていきたいと思います。&lt;/p>
&lt;h3 id="個別viewの状態">個別Viewの状態&lt;/h3>
&lt;p>まずは最も小さい単位、Viewの場合です。先に述べた、一覧の画面が良い例になりそうですね。Appleのチュートリアルでは、以下のような一覧の画面を作ることになります。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 48;
flex-basis: 117px"
>
&lt;a href="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list.png" data-size="860x1756">
&lt;img src="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list.png"
width="860"
height="1756"
srcset="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list_hu0267d8896987db251873bf1e3d824beb_440048_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list_hu0267d8896987db251873bf1e3d824beb_440048_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="List View">
&lt;/a>
&lt;figcaption>List View&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>この画面では右上のボタンを押すことで、一覧に表示するアイテムをフィルタリングできる機能があります。たとえば一部の行にハートマークがついてありますが、これは「お気に入り」を意味していて、そのお気に入りとして登録したものだけをフィルタするか、アイテムのカテゴリでフィルタするかなどの機能が入っています。&lt;/p>
&lt;p>そしてこの画面では、「フィルタするカテゴリ」や「お気に入りだけを表示する」を状態として扱っていますが、この状態は他の画面では知る必要がないデータとなっています。この場合に使えるのが、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/state" target="_blank" rel="noopener"
>@State&lt;/a>です。コードとしては、以下のようになっています。(一部省略)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 一覧画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// お気に入りだけを表示するかどうか&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">showFavoritesOnly&lt;/span> = &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// フィルタするカテゴリ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">filter&lt;/span> = FilterCategory.all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// カテゴリの種類&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">enum&lt;/span> &lt;span style="color:#50fa7b">FilterCategory&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>, CaseIterable, Identifiable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> all = &lt;span style="color:#f1fa8c">&amp;#34;ALL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> lakes = &lt;span style="color:#f1fa8c">&amp;#34;Lakes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> rivers = &lt;span style="color:#f1fa8c">&amp;#34;Rivers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> mountains = &lt;span style="color:#f1fa8c">&amp;#34;Mountains&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">id&lt;/span>: FilterCategory { &lt;span style="color:#ff79c6">self&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// アイテムにフィルタを適用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">filteredLandmarks&lt;/span>: [Landmark] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modelData.landmarks.filter { landmark &lt;span style="color:#ff79c6">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ff79c6">!&lt;/span>showFavoritesOnly &lt;span style="color:#ff79c6">||&lt;/span> landmark.isFavorite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> (filter == .all &lt;span style="color:#ff79c6">||&lt;/span> filter.rawValue == landmark.category.rawValue )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">body&lt;/span>: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NavigationView {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// アイテムの表示部&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(selection: $selectedLandmark) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(filteredLandmarks) { landmark &lt;span style="color:#ff79c6">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NavigationLink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkDetail(landmark: landmark)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkRow(landmark: landmark)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toolbar {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ToolbarItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ツールバーにフィルタを適用するためのボタンを追加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Menu {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 選択できるカテゴリ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Picker(&lt;span style="color:#f1fa8c">&amp;#34;Category&amp;#34;&lt;/span>, selection: $filter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(FilterCategory.allCases) { category &lt;span style="color:#ff79c6">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(category.rawValue).tag(category)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .pickerStyle(.inline)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// お気に入りだけを表示するかどうかのトグル&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Toggle(isOn: $showFavoritesOnly) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#f1fa8c">&amp;#34;Favorites only&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#f1fa8c">&amp;#34;heart.fill&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#f1fa8c">&amp;#34;Filter&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#f1fa8c">&amp;#34;slider.horizontal.3&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、一つのViewにおいて状態を管理するためには、&lt;code>@State&lt;/code>を使うことになります。&lt;/p>
&lt;h3 id="親子関係のviewが共有する状態">親子関係のViewが共有する状態&lt;/h3>
&lt;p>さて、一つのViewでの状態を管理することはできましたが、次に気になるのは複数のView、特に親子関係になるView間でどうやって状態を共有できるかです。たとえば先ほどの一覧画面だと、一つ一つの行がViewになっているものなのですが、&lt;/p>
&lt;p>実は、親のViewから子Viewに状態を渡すというのは、すでに先ほどのコードに表れています。「お気に入りだけを表示するかどうか」のトグルがあるのですが、ここで&lt;code>isOn&lt;/code>に親の状態を渡していますね。ただ、トグル時の挙動を&lt;code>@State&lt;/code>で定義したBooleanと結びつけるために&lt;code>isOn&lt;/code>として渡す際、&lt;code>$&lt;/code>をつけることに注目する必要があります。&lt;code>$&lt;/code>をつけることで、Booleanではなく、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/binding" target="_blank" rel="noopener"
>Binding&lt;!-- raw HTML omitted -->&lt;/a>という形でプロパティを渡すことになります。こうしてラッパーを渡すことで、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/toggle/" target="_blank" rel="noopener"
>Toggle&lt;/a>の中でも親の状態を変更できるようになります。&lt;code>Toggle&lt;/code>は確かに一覧の画面とは別のViewになりますが、押下するたびに親の状態である&lt;code>showFavoritesOnly&lt;/code>の値が変わるということです。&lt;/p>
&lt;p>後でまた関連したポストを書きたいと思いますが、Jetpack Composeでも何となく似たような形で状態の管理ができる方法があります。例えば、&lt;code>@State&lt;/code>のように簡単な状態を管理するためには以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// true/falseの状態
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> toggle: Boolean &lt;span style="color:#ff79c6">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#ff79c6">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> toggle {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;On!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toggle = &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;Off!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toggle = &lt;span style="color:#ff79c6">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のような書き方はいわゆる&lt;a class="link" href="https://kotlinlang.org/docs/delegation.html" target="_blank" rel="noopener"
>Delegation&lt;/a>によるもので、&lt;code>mutableStateOf&amp;lt;T&amp;gt;&lt;/code>が返すのは&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState" target="_blank" rel="noopener"
>MutableState&lt;!-- raw HTML omitted -->&lt;/a>ですが、&lt;code>by&lt;/code>を使うことで実際は&lt;code>Boolean&lt;/code>そのものを扱うようになります。&lt;/p>
&lt;p>そして&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>を分解し、以下のように状態と、状態を変化させる処理の処理を指定することもできます。これもまた、先ほどの&lt;code>Binding&lt;/code>のような役割をするようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// テキストの状態と値の変更
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> (content: String, onValueChange: (String) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// テキストフィールドに状態を表示し、変化があった場合は状態を変更させる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>TextField(&lt;span style="color:#ff79c6">value&lt;/span> = content, onValueChange = onValueChange)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやって他の要素に状態の変更を可能にするためには、基本的にその状態をラップしているオブジェクトを利用するという考えは、SwiftUIでもJetpack Composeでも一緒のようです。ただ、&lt;code>$&lt;/code>というキーワードを使ってラッパーにアクセスできるSwiftと、状態のオブジェクトをどうやって宣言するかを考える必要のあるKotlinの違いがまた面白いポイントです。&lt;/p>
&lt;h3 id="アプリ全体で共有する状態">アプリ全体で共有する状態&lt;/h3>
&lt;p>さて、次はもっと大きい単位としての状態について述べたいと思います。アプリの画面は色々とあり、仲には親子の関係ではない場合もあります。Appleのチュートリアルのアプリをまたの例としてあげますと、以下のように、タブが分かれている場合が代表的なものと言えるかも知れません。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 49;
flex-basis: 119px"
>
&lt;a href="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu.png" data-size="732x1466">
&lt;img src="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu.png"
width="732"
height="1466"
srcset="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu_hu9c7790eb6847b0c09531674054eff1d4_1201768_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu_hu9c7790eb6847b0c09531674054eff1d4_1201768_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Menu View">
&lt;/a>
&lt;figcaption>Menu View&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>ここで、下にある「Featured」や「List」をタッチすることにより表示される画面が変わるわけですが、この二つの画面は親子といえる関係ではありません。以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">selection&lt;/span>: Tab = .featured
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">enum&lt;/span> &lt;span style="color:#50fa7b">Tab&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> featured
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">body&lt;/span>: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// タブメニュー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TabView(selection: $selection) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Featured画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CategoryHome()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tabItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#f1fa8c">&amp;#34;Featured&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#f1fa8c">&amp;#34;star&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tag(Tab.featured)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// LandmarkList画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tabItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#f1fa8c">&amp;#34;List&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#f1fa8c">&amp;#34;list.bullet&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tag(Tab.list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要件によっては、この対等な関係にある画面間でも状態を共有する必要はあります。たとえば、ショッピングのアプリを作るとしたら、自分のアカウントの画面を開いている場合でもカートに入れている商品の情報は維持される必要がありますね。このように、現在表示している画面とは関係なく、アプリ全体で共有する状態が必要な場面があります。&lt;/p>
&lt;p>この場合は、どうしたらいいでしょうか？もちろん、起点となるViewがあるので、そこに&lt;code>@State&lt;/code>を定義しておくというのも一つの方法かも知れません。ただ、状態として管理したい項目が増えれば増えるほど複雑になりがちですね。起点のViewには複数の&lt;code>@State&lt;/code>が必要となり、画面ごとにそれらを渡す必要があります。だとすると、やはり一つのオブジェクトに状態をまとめて置いて使いまわしたいものです。&lt;/p>
&lt;p>Appleのチュートリアルでもそれを提示していて、画面間で共有するデータとしてLandmarkのデータと、ユーザのプロフィールをまとめて共有できるオブジェクトとして提供する方法があります。まずは、以下がその状態のオブジェクトのコードとなります。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">ModelData&lt;/span>: ObservableObject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">landmarks&lt;/span>: [Landmark] = load(&lt;span style="color:#f1fa8c">&amp;#34;landmarkData.json&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">profile&lt;/span> = Profile.&lt;span style="color:#ff79c6">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでアプリ内でLandmarkの情報はjsonから読み取ったものとなっていて、プロフィールはEnumとなっています。そして&lt;a class="link" href="https://developer.apple.com/documentation/combine/observableobject" target="_blank" rel="noopener"
>ObservableObject&lt;/a>というプロトコールが使われているのが見えますね。&lt;code>ObservableObject&lt;/code>を使うことで、このModelDataというクラスは変更される状態を保持し、値の変更があった場合はそれを参照する画面に通知する&lt;code>Publisher&lt;/code>として機能することになります。そしてそれぞれの状態となるプロパティについては、&lt;a class="link" href="https://developer.apple.com/documentation/combine/published" target="_blank" rel="noopener"
>@Published&lt;/a>をつけることで状態として指定することになります。&lt;/p>
&lt;p>こうして状態を保持するためのオブジェクトを定義したら、次はアプリ内でどうやって使用するかですね。チュートリアルでは、以下のようにアプリのメインとなるstructに以下のように定義しています。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>@main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarksApp&lt;/span>: App {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ModelDataを状態のオブジェクトとして宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @StateObject &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">modelData&lt;/span> = ModelData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">body&lt;/span>: some Scene {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WindowGroup {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ContentView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .environmentObject(modelData) &lt;span style="color:#6272a4">// メイン画面に状態オブジェクトを渡す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードでわかるように、アプリでは定義しておいた状態オブジェクトを&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/stateobject" target="_blank" rel="noopener"
>@StateObject&lt;/a>をつけて、メイン画面に渡すことで使うようになります。ちなみにこうやって&lt;code>View&lt;/code>として定義された画面にならどんなものでも&lt;code>environmentObject()&lt;/code>に状態オブジェクトを渡すことができるので、画面の一部だけをプレビューとして表示する場合でも、プレビューに表示する画面に状態オブジェクトを渡すことで動作を試すこともできます。例えば、先ほどのLandmarkの一覧画面のプレビューだと、以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarkList_Previews&lt;/span>: PreviewProvider {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">previews&lt;/span>: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .environmentObject(ModelData()) &lt;span style="color:#6272a4">// 状態オブジェクトを渡す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうして状態オブジェクトを画面に渡したら、中では使うだけです。&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/environmentobject" target="_blank" rel="noopener"
>@EnvironmentObject&lt;/a>というアノテーションを使って、状態を持つオブジェクトを宣言するだけで自動的にオブジェクトはDIされ、その画面で使えるようになります。また一覧の画面の話となりますが、以下のコードを見てください。&lt;code>landmarks&lt;/code>のデータを使って一覧を表示しているのがわかります。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 状態オブジェクト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @EnvironmentObject &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">modelData&lt;/span>: ModelData
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 状態オブジェクトからデータを取り出しフィルタを適用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">filteredLandmarks&lt;/span>: [Landmark] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modelData.landmarks.filter { landmark &lt;span style="color:#ff79c6">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ff79c6">!&lt;/span>showFavoritesOnly &lt;span style="color:#ff79c6">||&lt;/span> landmark.isFavorite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> (filter == .all &lt;span style="color:#ff79c6">||&lt;/span> filter.rawValue == landmark.category.rawValue )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、Jetpack Composeの場合はこのような方法ではなく、オブジェクトそのものを&lt;code>remember&lt;/code>するように使うようです。例えば以下のような形になります。そもそも要素を作成するアプローチが違うのが理由の一つなのかも知れませんね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// アプリ全体で共有する状態
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">ApplicationState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> environment: MutableState&amp;lt;Environment&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> hash: MutableState&amp;lt;String&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 状態の初期化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>@Composable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">rememberApplicationState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment: MutableState&amp;lt;Environment&amp;gt; = mutableStateOf(&lt;span style="color:#50fa7b">Environment&lt;/span>.PRODUCTION),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hash: MutableState&amp;lt;String&amp;gt; = mutableStateOf(&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): ApplicationState {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> remember(environment, hash) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationState(environment, hash)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 状態の定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> appState = rememberApplicationState()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="永続化できる状態">永続化できる状態&lt;/h3>
&lt;p>今までの状態は、アプリが実行中のみ有効なものでした。それだけでも十分な場合もありますが、場合によっては状態を永続化したい場合もあるでしょう。例えば、学習用のアプリだとしたらどこまで進行したかなどを保存しておきたいかなと思います。このような種のデータは、アプリを再起動しても変わらないことを期待しますね。&lt;/p>
&lt;p>もちろん、この場合のためにDBがあり、ネットワーク機能のあるアプリならサーバ側にデータを保存したりするでしょう。ただ、この場合は「状態」とは言えないものですね。なぜなら、状態は画面の更新を伴うものだからです。画面をタッチした回数を、画面に表示しながら同時に保存しておきたい場合は毎回DBの更新と参照で実装したくない場合もあるかなと思います。そこで使えるのが、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/appstorage" target="_blank" rel="noopener"
>@AppStorage&lt;/a>です。これを使うことで、画面の更新と永続化を同時に行うことができます。&lt;/p>
&lt;p>また、チュートリアルによると、いくつかデフォルトとして保存されているデータに関してもこのアノテーションでアクセスできるようにになっています。一覧画面に表示される「お気に入り」ボタンの例ですが、ボタンのアイコンを&lt;code>@AppStorage&lt;/code>から参照するようになっています。コードは以下です。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">FavoriteButton&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ボタンはハートのアイコンとして表示する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @AppStorage(&lt;span style="color:#f1fa8c">&amp;#34;Favorite.iconType&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">iconType&lt;/span>: IconType = .heart
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。自分の感想としては、やはり今まで自分が触れてきた分野とは全く違う概念やアプローチが多かったので、大変興味深いと思いつつ、「これであっているのか」という疑問もかなり湧いてくるような経験となっています。全く経験のない分野に足を踏み入れるのは常にそういうものなのかも知れませんが。&lt;/p>
&lt;p>ただこれで、ある程度アプリを作る場合にどうやって処理を行うべきかについての疑問の一つは解けたような気がします。本当は画面を作る分、他にも色々と新しい概念が出てきたり、画面のレイアウトやUXの観点で色々と難しいものが出てくるかも知れませんが、とにかく「動く」ものを作れそうな気はしますね。何卒自分のようにバックエンドのみを経験してきた形にとって参考できるような記事となっていればと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>SwiftUIを触ってみた〜その1〜</title><link>https://retheviper.github.io/posts/swift-ui-first-impression-1/</link><pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/swift-ui-first-impression-1/</guid><description>&lt;img src="https://retheviper.github.io/images/swift.jpg" alt="Featured image of post SwiftUIを触ってみた〜その1〜" />&lt;p>今までの自分のキャリアを振り返ってみると、仕事としての経験はバックエンドばかりで、画面側の実装にはあまり関わったことがありません。しかし、スタンドアロンのアプリを作るためには、ウェブ・モバイル・デスクトップを問わず画面が必要となるので、いつかは画面側の実装もできるようになる必要があるかなと常に思っているところです。&lt;/p>
&lt;p>画面を作るといっても、どんな分野のエンジニアとしてキャリアパスを考えているか、どのような企業で働きたいか、慣れている言語は何であるかなど色々と考慮すべき要素は多いのですが、自分の場合はKotlinに慣れているのもあり、ウェブ・モバイル・デスクトップアプリに全部対応できるという点から&lt;a class="link" href="https://www.jetbrains.com/lp/compose-mpp" target="_blank" rel="noopener"
>Jectpack Compose&lt;/a>を、また普段からMacとiPhone、iPadといったApple社の製品をよく使っている上、KotlinからのSwift入門が比較的簡単ということで&lt;a class="link" href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener"
>SwiftUI&lt;/a>を勉強したいと思っています。&lt;/p>
&lt;p>さて、言語とフレームワークを決めてからは実践ですね。&lt;a class="link" href="https://developer.apple.com/tutorials/swiftui" target="_blank" rel="noopener"
>公式のチュートリアル&lt;/a>が充実していたので、まずはこちらの方をすすめながら感じたSwiftやSwiftUIで印象的だった部分についてまとめてみたいと思います。もちろん、自分は仕事としてモバイルアプリの実装に関わったことがないのでコンテンツとしては粗末なものとなるかなと思いますが、もし自分のようにKotlinのバックグラウンドからSwiftに触れてみようと思っている方や、バックエンドのみのキャリアからGUIに初めて触れる方、もしくはKotlinとSwiftのどちらかに興味を持っている方には参考になる内容となればと思います。&lt;/p>
&lt;h2 id="swift">Swift&lt;/h2>
&lt;p>まずは言語そのものから。KotlinとSwiftはよく似ているという話を聞くことがありますが、正確に「どこが」というのはやはり触れてみる前はわからないものです。似ているという表現は共通点があるという意味なので、何に基準を置くかによって挙げられる共通点は色々と変わってくるものだからです。&lt;/p>
&lt;p>例えば、言語デザインの観点でOOP志向的で、関数型的な要素があり、GCが存在する、ということでも共通点は発見できます。もしくは、言語の使用としてキーワードや書き方の印象が似ているという意味にもなれますね。細かくは、セミコロンを使わなくて良いという点も挙げられますね。&lt;/p>
&lt;p>なので、まずは上記のチュートリアルを進行しながら、肌で感じた感覚から、Kotlinに比べたSwiftはどのようなものだったかを述べていきたいと思います。&lt;/p>
&lt;h3 id="kotlinに似ているもの">Kotlinに似ているもの&lt;/h3>
&lt;p>では、まずKotlinに似ているなと感じたところから述べていきます。似ているとしても、あくまで「肌の感触」なものなので、厳密には違う仕様になっているものも多いのですが、ここでの基準は「Kotlinでできたことをどれほど近い感覚で再現できるか」となっていますので（といっても個人的な感想ですが）、参考までに。&lt;/p>
&lt;h4 id="computed-properties">Computed properties&lt;/h4>
&lt;p>まず、プロパティの話からです。Kotlinではdata classを定義するとき、プロパティを以下のような二つの方法で定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> age: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> isAdult: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>() = age &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">18&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>age&lt;/code>はインスタンスを作成するときに固定される単純な値となりますが、&lt;code>isAdult&lt;/code>はgetterとして定義した処理(&lt;code>age&lt;/code>が18以上かどうかという)の結果を返すように定義する形ですね。このような処理を伴うプロパティは、Swiftでも同じく&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID259" target="_blank" rel="noopener"
>Computed Properties&lt;/a>を通じて定義することができました。同じような処理を行う場合、以下のように定義できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">age&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">isAdult&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">Bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> age &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">18&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだ一つしたあげてないのですが、これだけでもなんとなく「KotlinとSwiftが似ている」の意味が少しは見えてきた気がしますね。処理を伴うプロパティを扱える、という仕様がそうですが、型の定義もそうで、キーワードは少し違うけど大体似たような感覚でコードが読めるというところがそうです。&lt;/p>
&lt;p>ただ、やはり違う部分もありますね。data classに対して、SwiftはGoやRustのようにstructを使えるというところがそうかなと思います。もちろんSwiftにもClassはあるので、目的によってどれかを選ぶようになるらしいです。という面では、またなんとなくKotlinでdata classとclassを分けて使うという点と似ているような気もしますね。&lt;/p>
&lt;h4 id="extension">Extension&lt;/h4>
&lt;p>次は、拡張です。Kotlinではオブジェクトについて、そのオブジェクトの外にメソッドやプロパティを定義することができますね。これらを拡張関数や拡張プロパティと呼び、以下のように定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> Student.isUnderAge: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>() = age &amp;lt; &lt;span style="color:#bd93f9">18&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前このブログでも述べたことのある&lt;a class="link" href="https://www.amazon.co.jp/dp/B08WXCRVD2/ref=dp-kindle-redirect?_encoding=UTF8&amp;amp;btkr=1" target="_blank" rel="noopener"
>Effective Kotlin&lt;/a>で提示されている活用方法ですが、ユースケースやドメインによって違う処理が必要となった場合は、class内に全てのメソッドやプロパティをを定義するよりはこのような拡張を使って、パッケージごとに定義することでアクセス制限を設ける方法があります。&lt;/p>
&lt;p>同じようなことがSwiftでもできますが、書き方はやはり少し違いました。上記のようなプロパティをSwiftで同じ方法で実装する場合、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">extension&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">isUnderAge&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">Bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> age &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> &lt;span style="color:#bd93f9">18&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにSwiftには&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html" target="_blank" rel="noopener"
>Extension&lt;/a>が別途キーワードとして存在していて、新しくclassやstructを定義するかのような感覚で関数やプロパティを付け加えることができます。個人的な感想としてはRustの&lt;a class="link" href="https://doc.rust-jp.rs/book-ja/ch05-03-method-syntax.html" target="_blank" rel="noopener"
>メソッド&lt;/a>と似ている形で、一つの&lt;code>extension&lt;/code>の中にまとめられるところがむしろKotlinより整頓された感覚なので良さげですね。Kotlinの場合、一つのオブジェクトに対しての拡張が複数あると少し汚くも見えるので…&lt;/p>
&lt;h4 id="string-interpolation">String Interpolation&lt;/h4>
&lt;p>Javaの場合でもそうで、多くの言語では文字列と、違う変数として格納してある値を一つの文字列にまとめる場合は&lt;code>format()&lt;/code>を使うか、文字列に変換して結合するケースが多いかなと思います。Kotlinでもそのような使い方はもちろんできますが、&lt;a class="link" href="https://kotlinlang.org/docs/basic-types.html#string-templates" target="_blank" rel="noopener"
>String template&lt;/a>があるので、簡単に文字列の中で違う値を埋め込むことができます。例えば以下のようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> world = &lt;span style="color:#f1fa8c">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(&lt;span style="color:#f1fa8c">&amp;#34;Hello, &lt;/span>&lt;span style="color:#f1fa8c">$world&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Swiftでも&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID292" target="_blank" rel="noopener"
>String Interpolation&lt;/a>があるので、同じことができます。少し書き方が変わっているのですが、機能的にはほぼ一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">world&lt;/span> = &lt;span style="color:#f1fa8c">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#f1fa8c">&amp;#34;Hello, &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>world&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="arguments">Arguments&lt;/h4>
&lt;p>Kotlinでは、関数のパラメータにデフォルト値を設定することで、簡単にオーバーロードを実現でき、そのパラメータが渡されてない場合の処理にも対応できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// timesに指定した数値分、stringを標準出力する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">printHello&lt;/span>(string: String, times: Int = &lt;span style="color:#bd93f9">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(times) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;Hello, &lt;/span>&lt;span style="color:#f1fa8c">$string&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(&lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// timesに値を指定しなくても関数を呼び出せる
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、どのパラメータに値を指定したいかを明確にするときや、関数に定義されたパラメータの順番に関係なく値を指定したい場合など色々な場面で&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>Named Arguments&lt;/a>を使うことができますね。例えば&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html" target="_blank" rel="noopener"
>joinToString()&lt;/a>には&lt;code>separator&lt;/code>、&lt;code>limit&lt;/code>、&lt;code>truncated&lt;/code>など6つのパラメータがあるのですが、デフォルト値が指定されていて、Named Argumentsにより以下のような使い方が可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;D&amp;#34;&lt;/span>).joinToString(prefix = &lt;span style="color:#f1fa8c">&amp;#34;[&amp;#34;&lt;/span>, postfix = &lt;span style="color:#f1fa8c">&amp;#34;]&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Named ArgumentはKotlinにおいてはオプションで、基本的にはJava同様、関数に定義されてあるパラメータの順番に合わせて値を渡すだけでも問題ありません。しかし、Swiftではこれが逆になっていて、sturctのインスタンスを作る場合や関数を呼び出す場合は基本的にパラメータは基本的にNamed Argumentsのような形で渡す必要があります。これを&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID166" target="_blank" rel="noopener"
>Argument Label&lt;/a>と読んでいるそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">printHello&lt;/span>(string: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#f1fa8c">&amp;#34;Hello &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>string&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(string: &lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// Function Argument Labelでstringを指定&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、これもKotlinと同様、デフォルト値を指定することができ、その場合はパラメータを省略することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">printHello&lt;/span>(string: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>, times: &lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span> = &lt;span style="color:#bd93f9">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">count&lt;/span> = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">repeat&lt;/span> { &lt;span style="color:#6272a4">// Kotlinのdo-whileループ的なもの&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#f1fa8c">&amp;#34;Hello &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>string&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">while&lt;/span> (count &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> times)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(string: &lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// timesを省略している&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、アンダースコアを使うことでArgument Labelを省略できるようにもなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">printHello&lt;/span>(&lt;span style="color:#ff79c6">_&lt;/span> string: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>, times: &lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span> = &lt;span style="color:#bd93f9">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">count&lt;/span> = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">repeat&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#f1fa8c">&amp;#34;Hello &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>string&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">while&lt;/span> (count &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> times)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(&lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// stringを省略&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>関数を定義する側からしたらあまり似ていないような気もするのですが、呼び出す側としてはかなり似たような形でコードが書けるのが特徴的かなと思います。&lt;/p>
&lt;h4 id="range">Range&lt;/h4>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html#:~:text=values%20using%20the-,rangeTo%28%29,-function%20from%20the" target="_blank" rel="noopener"
>rangeTo()&lt;/a>を使って、簡単に数値の範囲を定義することができます。この関数は&lt;a class="link" href="https://kotlinlang.org/docs/keyword-reference.html#operators-and-special-symbols" target="_blank" rel="noopener"
>operator&lt;/a>として定義されているので、&lt;code>..&lt;/code>で簡単に使えます。こうやって定義したRangeでは、最小値と最大値の取得や、Listに変換するなど色々なことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Rangeの定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> min = &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> max = &lt;span style="color:#bd93f9">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> range = min&lt;span style="color:#ff79c6">..&lt;/span>max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 最小値と最大値の取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(range.start) &lt;span style="color:#6272a4">// 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(range.endInclusive) &lt;span style="color:#6272a4">// 20
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// RangeをListにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> intList = range.toList() &lt;span style="color:#6272a4">// [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Swiftでも&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID73" target="_blank" rel="noopener"
>Range Operator&lt;/a>を使って範囲を定義することができます。こちらも形は似ていて、&lt;code>...&lt;/code>となります。ドットの数がKotlinより一つ多いという点を除くと全く同じ感覚で、最小値と最大値もまた名前が違うだけでプロパティとして取得できるという点もまた一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Rangeの定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">min&lt;/span> = &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">max&lt;/span> = &lt;span style="color:#bd93f9">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">range&lt;/span> = min...max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 最小値と最大値の取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(range.lowerBound) &lt;span style="color:#6272a4">// 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(range.upperBound) &lt;span style="color:#6272a4">// 20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// RangeをArrayにする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">array&lt;/span> = &lt;span style="color:#8be9fd;font-style:italic">Array&lt;/span>(range) &lt;span style="color:#6272a4">// [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記のコードを見ると気付きにくいところですが、Range実装については両言語での扱いが少し違うところがあります。Kotlinでは&lt;code>rangeTo()&lt;/code>の戻り値が、元の値の型に合わせて&lt;code>InteRange&lt;/code>や&lt;code>LongRange&lt;/code>のようなものとなっていて、最小値と最大値をプロパティで取得する場合も&lt;code>rangeTo&lt;/code>に渡された二つの値の型と一緒です。&lt;/p>
&lt;p>しかし、Swiftの&lt;a class="link" href="https://developer.apple.com/documentation/swift/range" target="_blank" rel="noopener"
>Range&lt;/a>は&lt;code>Range&amp;lt;Bound&amp;gt;&lt;/code>という型で、当然Rangeから取得できる最小値や最大値も&lt;a class="link" href="https://developer.apple.com/documentation/swift/rangeexpression/bound/" target="_blank" rel="noopener"
>Bound&lt;/a>の型となっています。IntやLongとはまた別の型になるので、場合によっては注意して使う必要があるかも知れません。&lt;/p>
&lt;h3 id="swiftだけのもの">Swiftだけのもの&lt;/h3>
&lt;p>今まではKotlinユーザの観点から、Kotlinとどれだけ同じ感覚でコードを書けるか、ということを述べていましたが、ここからは少し間隔が違うなと思ったところを少しまとめてみようと思います。&lt;/p>
&lt;h4 id="メソッドプロパティコールでの省略">メソッド・プロパティコールでの省略&lt;/h4>
&lt;p>Kotlinでは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply()&lt;/a>のように自分自身を指しているのが明確な場合、&lt;code>this&lt;/code>を省略することができます。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> age: Int = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> studentA = Student(name = &lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>).apply { age = &lt;span style="color:#bd93f9">18&lt;/span> } &lt;span style="color:#6272a4">// Student(name=A, age=18)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、&lt;code>this&lt;/code>を使う場合か、明確に対象importしているなど特定のケースを除くとKotlinでは基本的に&lt;code>Class.method()&lt;/code>のような形でどのクラスのメンバを呼び出しているかを表記するのが原則ですね。&lt;/p>
&lt;p>しかし、Swiftの場合は少し状況が違います。もっとゆるい感じで、コンパイラを基準に対象が明確であれば、&lt;code>.method()&lt;/code>のような形で省略できるような感覚です。以下はSwiftUIのチュートリアルで提示しているコードの一部を抜粋したものですが、&lt;code>filter&lt;/code>が&lt;code>FilterCategory&lt;/code>というenumであるため、&lt;code>.all&lt;/code>という形で三項演算子の中で使われていることを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">filter&lt;/span> = FilterCategory.all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">enum&lt;/span> &lt;span style="color:#50fa7b">FilterCategory&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>, CaseIterable, Identifiable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> all = &lt;span style="color:#f1fa8c">&amp;#34;ALL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> lakes = &lt;span style="color:#f1fa8c">&amp;#34;Lakes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> rivers = &lt;span style="color:#f1fa8c">&amp;#34;Rivers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> mountains = &lt;span style="color:#f1fa8c">&amp;#34;Mountains&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">id&lt;/span>: FilterCategory { &lt;span style="color:#ff79c6">self&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">title&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">title&lt;/span> = filter == .all ? &lt;span style="color:#f1fa8c">&amp;#34;Landmarks&amp;#34;&lt;/span> : filter.rawValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> showFavoritesOnly ? &lt;span style="color:#f1fa8c">&amp;#34;Favorite &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>title&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> : title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="protocol">Protocol&lt;/h4>
&lt;p>Swiftでは&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" target="_blank" rel="noopener"
>Protocol&lt;/a>というものがあり、JavaやKotlinのinterfaceと大体同じ感覚で使えます。ここまでだとあまり差はないように思いますが、実際にはstructやclass、enumなどを定義するときには、必要に応じでprotocolを採用(adopt)する必要があるというところが体験できる違いかなと思います。&lt;/p>
&lt;p>例えば、Kotlinで一つのdata classを定義するとしたら、以下のようなメンバが自動て追加されます。&lt;/p>
&lt;ul>
&lt;li>equals()&lt;/li>
&lt;li>hashCode()&lt;/li>
&lt;li>toString()&lt;/li>
&lt;li>componentN()&lt;/li>
&lt;li>copy()&lt;/li>
&lt;/ul>
&lt;p>しかし、Swiftのstruct, class, enumなどにはこのようなメンバは基本的に追加されません。なので、必要なメンバがあればそれに関するprotocolを採用し、実装する必要があります。例えばハッシュ値が使いたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/hashable" target="_blank" rel="noopener"
>Hashable&lt;/a>、
Jsonなどに変換するためには&lt;a class="link" href="https://developer.apple.com/documentation/swift/codable" target="_blank" rel="noopener"
>Codable&lt;/a>、Listでループしたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/identifiable" target="_blank" rel="noopener"
>Identifiable&lt;/a>、enumの全ケースを網羅してループしたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/caseiterable" target="_blank" rel="noopener"
>CaseIterable&lt;/a>、同一化を比較したい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/equatable" target="_blank" rel="noopener"
>Equatable&lt;/a>を採用するなどです。&lt;/p>
&lt;p>もちろんJavaやKotlinでも必要に応じてintefaceやannotationを使う必要はありますが、SwiftだとKotlinで気軽に使える機能がstructやclassなどを定義した時点では揃ってない可能性があるので、ここは気をつけるべきところですね。&lt;/p>
&lt;h4 id="some">some&lt;/h4>
&lt;p>Swiftでは少し変わった感覚のキーワードがあるます。そのキーワードの説明するために、まずは以下のようなprotocolとstructの定義があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">protocol&lt;/span> &lt;span style="color:#50fa7b">Something&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">define&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">GoodThing&lt;/span>: Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">define&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#f1fa8c">&amp;#34;It&amp;#39;s good thing!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようなコードがある場合、変数の型宣言や関数の戻り値で少し独特なキーワードを使うことができます。&lt;code>some&lt;/code>というものです。実際使う時は、以下のようなコードとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">good&lt;/span>: some Something = GoodThing()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">returnSomething&lt;/span>() -&amp;gt; some Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> GoodThing()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これだけでは&lt;code>some&lt;/code>というキーワードが一体どんなものかわからないですね。ここでKotlinの概念を持ってくるとどうでしょうか。実は、Kotlinでもこれによく似た機能があります。&lt;code>&amp;lt;T extends Something&amp;gt;&lt;/code>です。KotlinやJavaの経験がある型ならこれで十分に何を意味しているかがしっくり来るかなと思います。&lt;/p>
&lt;p>つまり、&lt;code>some&lt;/code>はとあるprotocolを満足する何かしらのインスタンスを示すものです。Swiftではそれを満足するオブジェクトであってもprotocolを直接変数の型や関数の戻り値として定義して直接使うことはできない場合があります。その場合に&lt;code>some&lt;/code>を使うことで問題を回避できます。JavaやKotlinでinterfaceを使って、その具体的な実装は問わなく使うのと一緒だと言えます。このキーワードのおかげで、SwiftUIでは&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"
>View&lt;/a>を満足して入れば画面を構成するどんなコンポーネントとして扱えるようになります。&lt;/p>
&lt;p>ただ、interfaceを扱うのとは概念的に同じだとしても、コードを書く側の感覚としては全く違うのでここは注意しなければならないと思います。&lt;/p>
&lt;h4 id="compiler-control-statements">Compiler Control Statements&lt;/h4>
&lt;p>Swiftには&lt;a class="link" href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#ID538" target="_blank" rel="noopener"
>Compiler Control Statements&lt;/a>という仕様があり、コンパイル時の処理を指定できます。例えば、SwiftUIのチュートリアルでは一つのアプリを実装して、OSによって違う機能を実現するためにこれを利用しているケースがあります。以下がその例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// watchOSで起動する場合は、通知を使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#if&lt;/span> &lt;span style="color:#ff79c6">os&lt;/span>(&lt;span style="color:#ff79c6">watchOS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WKNotificationScene(controller: NotificationController.&lt;span style="color:#ff79c6">self&lt;/span>, category: &lt;span style="color:#f1fa8c">&amp;#34;LandmarkNear&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// macOSで起動する場合は、設定を使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#if&lt;/span> &lt;span style="color:#ff79c6">os&lt;/span>(&lt;span style="color:#ff79c6">macOS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Settings {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkSettings()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合もAndroidでアプリを実装する場合はこのような設定が必要になる場面もあるかも知れませんが、バックエンドの経験上ではコードによりコンパイラをコントロールするというケースはあまりなかったので、かなり新鮮な感覚でした。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。SwiftUIの話をするつもりが、Swiftのことだけでかなりの量になってしまったので、SwiftUIについては次のポストで述べようかなと思っています。しかし、Swiftだけでもかなり興味深いところが多かったので、やはりチュートリアルを触ってみて色々な経験ができたので良い選択をしたかなと思います。&lt;/p>
&lt;p>また、やはりKotlinとSwiftがなんとなく似ている部分があるのは感覚的には確かなので、やはりどちらかの経験があると残りの片方への入門もしやすくなるのかなという感覚はあります。これは外国語の教育（自分の専攻です）でいうスキーマ、いわゆるバックグラウンドの知識ある故のことだろうなと思うと、少しうれしくもなりますね。やはりKotlinやってよかったなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>BackendでCoroutineを使う</title><link>https://retheviper.github.io/posts/server-side-coroutine/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/server-side-coroutine/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.jpg" alt="Featured image of post BackendでCoroutineを使う" />&lt;p>Androidアプリのように、GUIを使う場合にはマルチスレッドで処理するのはもはや常識のようなものです。シングルスレッドだと何か思い処理が行われる間に画面が固まるからです。他にもプログレスバーのようにリアルタイムで変化されるコンポーネントの状態を更新したり、チャット、通知の表示などさまざまな場面でスレッドを分けて処理する必要がある場合が多いですね。&lt;/p>
&lt;p>ただ、バックエンドの処理においては少し事情が違うものです。そもそもGUIを考慮する必要がないということもありあすが、サーバでは一つのリクエストに対しての処理を「順次的に」行う場合が多いため、マルチスレッドを利用した処理の分散の利点を活かすのはなかなか難しいものです。&lt;a class="link" href="https://www.reactive-streams.org" target="_blank" rel="noopener"
>Reactive Streams&lt;/a>のようなものもありますが、これは一つのリクエストを分散するというより少ないリソースで多くのリクエストに対する処理を行うためのものなので、一つの処理を分散して効率を上げたいという場合にはあまりふさわしくないものですね。&lt;/p>
&lt;p>もちろん、だからと言ってバックエンドにおいて分散処理が全く必要ないというわけではありません。確かに一つのリクエストに対しての処理を行う中でも、処理によってスレッドを分けて性能向上を期待できる場面があります。例えば後続の処理と関係のない処理を途中に挟んでい場合では、別スレッドで処理したくなりますね。&lt;/p>
&lt;p>なので、今回は&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%AB%E3%83%BC%E3%83%81%E3%83%B3" target="_blank" rel="noopener"
>Coroutine&lt;/a>を使ったバックエンドでの処理の分散するという一例を紹介したいと思います。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="apiの呼び出しを並列化する">APIの呼び出しを並列化する&lt;/h2>
&lt;p>まず並列化で効率を上げられるケースとして、バッチ処理を考えられます。バッチ処理では、条件に当てはまるデータを複数抽出し、それぞれのデータに対して同じ処理を繰り返すことが多いですね。このように個別のデータに対しての処理が独立的に実行されるものであり、並行して走っても特に問題はないという場合は十分その処理を分散できるものです。&lt;/p>
&lt;p>仕事ではGoで作成されたサーバから定期的に日付を基準にDBから処理対象のデータを抽出し、そのデータを配列にしてループしながらKotlinで作成されたサーバのAPIを呼び出すようになっています。また、KotlinサーバでもBackendのAPIを呼び出すケースがあり、これもまたループでデータの参照を行っている状態です。サービスが成長するにつれて、処理にかかる時間によりAPI呼び出しがタイムアウトになるなどパフォーマンスの問題が出てきたので、このループの中でのAPI呼び出しを並列化することで処理にかかる時間を減らすことにします。&lt;/p>
&lt;h2 id="実装してみる">実装してみる&lt;/h2>
&lt;p>まずはCoroutineにより、ループの中でのAPIの呼び出しを実現してみます。上述したとおり、実際の仕事で使えるかどうかを検証してみたく書いたコードなので、各サーバの処理は大して変わらないものとなっています。まずループの中で互いのAPIを呼び出すような処理を書き、呼び出される側では5秒を待ってレスポンスを送るようになっています。これをCoroutineを利用して並列化していきます。&lt;/p>
&lt;h3 id="go">Go&lt;/h3>
&lt;p>まず、以下のような処理があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> callResults &lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Response []&lt;span style="color:#ff79c6">*&lt;/span>client.Response &lt;span style="color:#f1fa8c">`json:&amp;#34;response&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">CallKotlinServer&lt;/span>(c &lt;span style="color:#ff79c6">*&lt;/span>gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServer] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> results &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>callResults{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tries &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd">int&lt;/span>{&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> _, i &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">range&lt;/span> tries {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServer] before request with id: &amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> result &lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r, err &lt;span style="color:#ff79c6">:=&lt;/span> client.&lt;span style="color:#50fa7b">Post&lt;/span>(i) &lt;span style="color:#6272a4">// KotlinサーバにPOSTでリクエストを送る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> err &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> r &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = &lt;span style="color:#f1fa8c">&amp;#34;failed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = r.Result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServer] after request with id: &amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> results.Response = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(results.Response, &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>client.Response{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ID: i,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Result: result,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServer] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.&lt;span style="color:#50fa7b">JSON&lt;/span>(http.StatusOK, results)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは&lt;a class="link" href="https://gin-gonic.com" target="_blank" rel="noopener"
>Gin&lt;/a>を使ったサーバのサンプルで、handlerの部分です。この関数の中ではAPIが呼び出されると、10回のループの中でKotlinサーバにリクエストを送ります。そして帰ってきたAPI呼び出しの結果を持ってレスポンスのstructを作成して、最終的には10回の実行結果をまとめてJSONとして返す構造となっています。&lt;/p>
&lt;p>ここでKotlin側が返すレスポンスは5秒かかるため、ループの回数が多くなれば多くなるほどレスポンスが帰ってくるのも遅くなります。ログを吐くようにしているので、サーバのログを確認するとリクエストからレスポンスに50秒がかかっているのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:31 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:31 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:36 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:36 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:41 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:41 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:46 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:46 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:51 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:51 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:56 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:56 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:01 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:01 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:06 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:06 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:11 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:11 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:16 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:16 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:21 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:21 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServer&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>GIN&lt;span style="color:#ff79c6">]&lt;/span> 2022/06/05 - 18:50:21 | &lt;span style="color:#bd93f9">200&lt;/span> | 50.250251292s | 127.0.0.1 | GET &lt;span style="color:#f1fa8c">&amp;#34;/api/v1/call-kotlin-server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="goroutineで並列化する1">Goroutineで並列化する(1)&lt;/h4>
&lt;p>では、以上の処理を並列化することにします。Goには&lt;a class="link" href="https://go-tour-jp.appspot.com/concurrency/1" target="_blank" rel="noopener"
>Goroutine&lt;/a>が基本的に含まれています。使い方は単純で、実行したい関数の前に&lt;code>go&lt;/code>のキーワードをつけるだけですね。ただ、レスポンスでは10回の実行結果を待ってから返す必要があるのですが、goroutineでAPIの呼び出しをするとメインスレッドが先に終わってしまう可能性があります。&lt;/p>
&lt;p>というわけで、ループの中でのAPIの呼び出しにgoroutineを使い、さらにそのgoroutineが全て終了してから結果を返すようにします。goには&lt;code>sync&lt;/code>というパッケージに&lt;a class="link" href="https://pkg.go.dev/sync#WaitGroup" target="_blank" rel="noopener"
>WaitGroup&lt;/a>があり、goroutineの終了を待つことができるようになっています。また、goroutineをループの中で実行する場合、順番はランダムになるのでレスポンスを返す際は一度ソートをかけるようにします。以上を考慮して実装した結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">CallKotlinServerAsync&lt;/span>(c &lt;span style="color:#ff79c6">*&lt;/span>gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServerAsync] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> results &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>callResults{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tries &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd">int&lt;/span>{&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>sync.WaitGroup{} &lt;span style="color:#6272a4">// WaitGroupを定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> _, i &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">range&lt;/span> tries {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group.&lt;span style="color:#50fa7b">Add&lt;/span>(&lt;span style="color:#bd93f9">1&lt;/span>) &lt;span style="color:#6272a4">// ループごとに実行するgoroutineの数を追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">go&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i &lt;span style="color:#8be9fd">int&lt;/span>) { &lt;span style="color:#6272a4">// goroutineでAPIの呼び出す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServerAsync] before request with id: &amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> result &lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r, err &lt;span style="color:#ff79c6">:=&lt;/span> client.&lt;span style="color:#50fa7b">Post&lt;/span>(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> err &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> r &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = &lt;span style="color:#f1fa8c">&amp;#34;failed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = r.Result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServerAsync] after request with id: &amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> results.Response = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(results.Response, &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>client.Response{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ID: i,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Result: result,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group.&lt;span style="color:#50fa7b">Done&lt;/span>() &lt;span style="color:#6272a4">// waitGroupにgoroutineの終了を設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group.&lt;span style="color:#50fa7b">Wait&lt;/span>() &lt;span style="color:#6272a4">// 全てのgoroutineが終了するのを待つ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> sort.&lt;span style="color:#50fa7b">Slice&lt;/span>(results.Response, &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i, j &lt;span style="color:#8be9fd">int&lt;/span>) &lt;span style="color:#8be9fd">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> results.Response[i].ID &amp;lt; results.Response[j].ID
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServerAsync] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.&lt;span style="color:#50fa7b">JSON&lt;/span>(http.StatusOK, results)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように修正して実行した結果のログは以下のとおりです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>GIN&lt;span style="color:#ff79c6">]&lt;/span> 2022/06/05 - 18:52:35 | &lt;span style="color:#bd93f9">200&lt;/span> | 5.012657333s | 127.0.0.1 | GET &lt;span style="color:#f1fa8c">&amp;#34;/api/v1/call-kotlin-server-async&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>10回のループがほぼ同時に実行されたため、レスポンスまで5秒ほどかかっているのがわかります。そしてやはりgoroutineの実行が順番に行われてないことがわかりますね。なので、実行の順番が重要でなくても、結果は順番を守って返す必要がある時はやはりソートが必要ということがわかります。&lt;/p>
&lt;h4 id="goroutineで並列化する2">Goroutineで並列化する(2)&lt;/h4>
&lt;p>場合によっては並列化できるからって、全ての処理を同時に走らせるのは危険な時もあります。上記のコードの場合、リクエストの数は10となっていますが、もしそれより多くのリクエストが必要か、さらに重い処理のAPIを呼び出す場合はどうでしょうか。Go側はリクエストを投げるだけなので処理の負荷はあまり変わらないものですが、APIを呼び出されている側としてはかなりの負荷になるはずです。&lt;/p>
&lt;p>だとすると、やはり並列の数を制限する必要があるはずです。例えば並列の数を2にすると、リクエストは2件づつ送られるのでリクエストの全体の数がいくら増えても負荷は一定に保てます。同時に全てのリクエストを送るよりは遅くなりますが、リソースの状況を見ながら並列数を増やすだけで柔軟に対応ができるので、外部設定ファイルなどで並列数を指定できるようにするとアプリのビルドなしでも柔軟に対応ができるというメリットもありますね。&lt;/p>
&lt;p>スレッドを使う場合だと、このような処理をするためにはかなり複雑な処理を書くことになるはずです。例えば、並列数に合わせてスレッドを定義して、さらにスレッドごとに割り当てる処理を分けなければならないですね。今は10件のリクエストを想定しているので、スレッドごとに5件づつというふうにリクエストを分けるだけで対応ができますが、リクエスト数をスレッド数で割った結果を考慮してループする要素数を適宜分割するような処理をまず足す必要があります。&lt;/p>
&lt;p>しかし、実はgoroutineを使うとそのような複雑な処理をまた足す必要はないです。goroutineでは&lt;a class="link" href="https://go-tour-jp.appspot.com/concurrency/2" target="_blank" rel="noopener"
>Channel&lt;/a>を利用して、同時に実行されるgoroutineの数を指定できます。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">CallKotlinServerAsyncDual&lt;/span>(c &lt;span style="color:#ff79c6">*&lt;/span>gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServerAsyncDual] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> results &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>callResults{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tries &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd">int&lt;/span>{&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> concurrency &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#6272a4">// goroutineの同時実行数を指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> group &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>sync.WaitGroup{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> guard &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">make&lt;/span>(&lt;span style="color:#8be9fd;font-style:italic">chan&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span>{}, concurrency) &lt;span style="color:#6272a4">// 同時実行数でChannelを定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> _, i &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">range&lt;/span> tries {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group.&lt;span style="color:#50fa7b">Add&lt;/span>(&lt;span style="color:#bd93f9">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> guard &lt;span style="color:#ff79c6">&amp;lt;-&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span>{}{} &lt;span style="color:#6272a4">// Channelに実行を一つたす
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">go&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i &lt;span style="color:#8be9fd">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServerAsyncDual] before request with id: &amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> result &lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r, err &lt;span style="color:#ff79c6">:=&lt;/span> client.&lt;span style="color:#50fa7b">Post&lt;/span>(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> err &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> r &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = &lt;span style="color:#f1fa8c">&amp;#34;failed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = r.Result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServerAsyncDual] after request with id: &amp;#34;&lt;/span>, i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> results.Response = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(results.Response, &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>client.Response{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ID: i,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Result: result,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group.&lt;span style="color:#50fa7b">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;lt;-&lt;/span>guard &lt;span style="color:#6272a4">// Channelを準備させる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group.&lt;span style="color:#50fa7b">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sort.&lt;span style="color:#50fa7b">Slice&lt;/span>(results.Response, &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i, j &lt;span style="color:#8be9fd">int&lt;/span>) &lt;span style="color:#8be9fd">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> results.Response[i].ID &amp;lt; results.Response[j].ID
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#50fa7b">Print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;[CallKotlinServerAsyncDual] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.&lt;span style="color:#50fa7b">JSON&lt;/span>(http.StatusOK, results)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Channelには指定した数分だけ送信すると、Channelから値を受信するまでは新しいgoroutineの実行はブロックされます。なので、実際に実行してみると、意図通り最大2件づつのリクエストが送信されているのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:10 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:10 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:10 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:15 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:15 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:15 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:15 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:21 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:21 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:21 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:21 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:26 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:26 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:26 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:26 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:31 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:31 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:31 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:31 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:36 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:36 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:36 &lt;span style="color:#ff79c6">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>GIN&lt;span style="color:#ff79c6">]&lt;/span> 2022/06/05 - 19:56:36 | &lt;span style="color:#bd93f9">200&lt;/span> | 25.194952625s | 127.0.0.1 | GET &lt;span style="color:#f1fa8c">&amp;#34;/api/v1/call-kotlin-server-async-dual&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kotlin">Kotlin&lt;/h3>
&lt;p>まずは順次処理する場合のコードから見ていきます。基本的にGoの場合と同じ処理をKotlin側にも用意していて、特に変わったものはありません。以下がそのコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">callGoServer&lt;/span>(): List&amp;lt;CallGoServerDto&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServer] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> tries.map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServer] before request with id: &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> goServerClient.call(&lt;span style="color:#ff79c6">it&lt;/span>) &lt;span style="color:#ff79c6">?:&lt;/span> CallGoServerDto(&lt;span style="color:#ff79c6">it&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;failed&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// GoのAPIを呼び出す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> .also { result &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServer] after request with id: &lt;/span>&lt;span style="color:#f1fa8c">${result.id}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.also {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServer] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Curlで実行してみた結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:33.429 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:33.430 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:38.483 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:38.483 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:43.490 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:43.491 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:48.498 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:48.499 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:53.509 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:53.510 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:58.518 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:58.518 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:03.530 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:03.531 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:08.538 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:08.539 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:13.552 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:13.553 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:18.561 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:18.562 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:23.570 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:23.570 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServer&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こちらもGoの時と同じく、リクエストからレスポンスまで50秒ほどかかっているのがわかります。これをCoroutineを持って並列化していきましょう。&lt;/p>
&lt;h4 id="coroutineで並列化する1">Coroutineで並列化する(1)&lt;/h4>
&lt;p>Goと違って、KotlinのCoroutineは言語の基本仕様ではありません。なので、依存関係をまず追加する必要があります。ただ、公式の説明では&lt;code>coroutine-core&lt;/code>だけを追加すると対応できそうなイメージですが、SpringのようにReactive Streamが必要な場合は&lt;code>coroutine-reactor&lt;/code>を依存関係に追加する必要があります。&lt;/p>
&lt;p>依存関係を追加した上で、コードを直していきます。ここではSpring Bootを使っていて、Controllerの関数を&lt;code>suspend&lt;/code>にすることができるので、Contollerから呼び出している関数にもsuspendにしていきます。また、coroutineでの処理はスコープの指定が必要なのでループの周りを&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" target="_blank" rel="noopener"
>coroutineScope&lt;/a>で包むようにします。その後は&lt;code>map&lt;/code>関数の中で&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" target="_blank" rel="noopener"
>async&lt;/a>としてAPIの呼び出しを行い、&lt;code>map&lt;/code>した結果は&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html" target="_blank" rel="noopener"
>Deferred&lt;/a>として帰ってくるので&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/await-all.html" target="_blank" rel="noopener"
>awaitAll&lt;/a>で終了を待ちます。説明では複雑ですが、以下のコードをみるとわかりやすいかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">callGoServerAsync&lt;/span>(): List&amp;lt;CallGoServerDto&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServerAsync] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> coroutineScope { &lt;span style="color:#6272a4">// coroutineとして処理する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> tries.map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> async { &lt;span style="color:#6272a4">// 並列に実行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServerAsync] before request with id: &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> goServerClient.call(&lt;span style="color:#ff79c6">it&lt;/span>) &lt;span style="color:#ff79c6">?:&lt;/span> CallGoServerDto(&lt;span style="color:#ff79c6">it&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;failed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.awaitAll() &lt;span style="color:#6272a4">// APIの呼び出し結果を待つ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> .also {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.forEach { result &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServerAsyncDual] after request with id: &lt;/span>&lt;span style="color:#f1fa8c">${result.id}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServerAsyncDual] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、APIを呼び出している関数(&lt;code>goServerClient.call()&lt;/code>)もsuspendにしておく必要があります。ここではSpringの&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener"
>RestTemplate&lt;/a>を使い、以下のような関数を定義しておきました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> client = RestTemplate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> header = HttpHeaders().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">set&lt;/span>(&lt;span style="color:#50fa7b">HttpHeaders&lt;/span>.CONTENT_TYPE, &lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON_VALUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">call&lt;/span>(id: Int): CallGoServerDto? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> request = HttpEntity(CallGoServerRequest(id), header)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> withContext(&lt;span style="color:#50fa7b">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client.postForObject(&lt;span style="color:#f1fa8c">&amp;#34;http://localhost:8800/api/v1/some-process&amp;#34;&lt;/span>, request, CallGoServerDto&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.java)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにコードを修正して実行してみると、Goの時と同じく並列で10件のリクエストが送られているのがわかります。ただ、違う点としてはgoroutineと違って実行の順番が保証されているというところですね。この特徴があるため、Kotlinの場合はレスポンスのソートが必要ないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.934 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.939 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.939 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.939 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.940 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.940 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.940 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.941 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.941 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.941 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.941 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-1&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsync&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="coroutineで並列化する2">Coroutineで並列化する(2)&lt;/h4>
&lt;p>上記のコードもGoの時と同じく、リクエストを同時に全部送っているのは問題になる可能性があるので、同時に送信するリクエストの数を制限することにします。Goでもそうであったように、KotlinでもCoroutineの同時実行の数を制限する仕組みがあります。&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-semaphore/index.html" target="_blank" rel="noopener"
>Semaphore&lt;/a>というものです。&lt;/p>
&lt;p>Sempaphoreに数値を指定し、asyncの中でSemaphoreに指定した数で実行数を制限することで並行実行数を制限するような形です。以下がそのコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">callGoServerAsyncDual&lt;/span>(): List&amp;lt;CallGoServerDto&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServerAsyncDual] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> semaphore = Semaphore(&lt;span style="color:#bd93f9">2&lt;/span>) &lt;span style="color:#6272a4">// 同時実行数を制限するためのSempahoreの定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tries.map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> semaphore.withPermit { &lt;span style="color:#6272a4">// asyncの同時実行数をSemaphoreに指定した数値に制限
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServerAsyncDual] before request with id: &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> goServerClient.call(&lt;span style="color:#ff79c6">it&lt;/span>) &lt;span style="color:#ff79c6">?:&lt;/span> CallGoServerDto(&lt;span style="color:#ff79c6">it&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;failed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.awaitAll()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .also {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.forEach { result &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServerAsyncDual] after request with id: &lt;/span>&lt;span style="color:#f1fa8c">${result.id}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#f1fa8c">&amp;#34;[CallGoServerAsyncDual] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>書き方が少し違うだけで、Goとほぼ同じ感覚でasyncの処理を制限できるコードが出来ました。特にコンパイルエラーが出ることはないので勘違いしやすいところではないかと思います。&lt;code>async{ semaphore.withPermit{ } }&lt;/code>の順番をちゃんと守る必要がありますので注意しましょう。実行結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:50.361 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-6&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:50.365 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-6&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:50.366 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>nio-8900-exec-6&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:55.369 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:55.369 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:00.377 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:00.379 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:05.386 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:05.386 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:10.393 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-2&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:10.393 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> before request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.404 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.404 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> after request with id: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#bd93f9">60551&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>atcher-worker-8&lt;span style="color:#ff79c6">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#ff79c6">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ログを吐く場所が微妙だったのですが、リクエストを送っている時間をみると、5秒置きで2つづつを送信しているのがわかります。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>あまりCoroutineに詳しくないゆえ、もっと良い書き方はあったかなと思いますが(goroutineの実行順を決めておく、&lt;code>WaitGroup.Done()&lt;/code>は&lt;code>defer&lt;/code>で定義する、Kotlinのログ出力箇所を調整するなど)、これで簡単にAPIの呼び出しを並列化することができるというのがわかったので個人的にはかなり満足しています。Jetpack Composeを少し触りながらcoroutineに触れたことはあったものの、こうやって仕事で必要となり調査と検証をしてみたのは初めてだったのでかなりの収穫を得たと言えますね。また、各言語においての感想は以下の通りです。&lt;/p>
&lt;ul>
&lt;li>Go
&lt;ul>
&lt;li>依存関係の追加なしで使えるのはメリット&lt;/li>
&lt;li>Kotlinのようにsuspendやscopeを意識しなくていいので便利&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Kotlin
&lt;ul>
&lt;li>asyncでも実行順が保証されているのはメリット&lt;/li>
&lt;li>goroutineよりは注意点が多い&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>二つの言語を比べると一長一短があるという感覚ですが、どれも応用が難しいものではないので、すぐにプロダクションコードにも適用できそうなものが書けるのは確かに良いものという印象を受けました。これからもcoroutineを使って性能向上ができる箇所はないか、色々と試してみたくなるものです。ちなみに、この記事に載せてあるコードを全体のソースは&lt;a class="link" href="https://github.com/retheviper/AsyncServerExample" target="_blank" rel="noopener"
>こちらのリポジトリ&lt;/a>から参照できます。&lt;/p>
&lt;p>では、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>厳密にいうと、Coroutineによる処理はマルチスレッドによる並列化とは概念的には違うものですが、実装と結果の取得という面では感覚が大きく変わらないので、ConcurrencyとParallelismによる違いなどの理論的な話は割愛しています。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Kotlinのこれからを語る</title><link>https://retheviper.github.io/posts/kotlin-prospect/</link><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-prospect/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinのこれからを語る" />&lt;p>1年ほどサーバサイドKotlinを扱いながら、ふと「今のKotlinはどこまできていて、これからはどうなるんだろう」と思うようになりました。色々な観点があると思いますが、とりあえず市場においてどれほどの需要があり、展望（これからも積極的に採用され続けそう、苦戦しそうなどの）はどうかなど、いわゆるkotlinという言語の「ステータス」について自分が感じていることについて考えてみたくなったというわけです。&lt;/p>
&lt;p>最近のトレンドを見ると、一つの言語において専門家になるというよりはさまざまな言語を使いこなせる、いわゆる&lt;code>Polyglot&lt;/code>なプログラマが求められていて、常識みたいになっているとも言われているようです。確かに私自信もその経験があるかどうかは関係なく、案件によりさまざまな言語に触れるケースを多くみています。そして今は充実したドキュメントや記事をインターネットに溢れていて、UdemyやCourseraなど良質の講義を提供するサイトも色々とあるので経験がない言語だとしても入門が難しくてできないとは言えない時代になっている感覚でもあります。なので、自分が現在使っている言語がメインストリームに属してあるかどうかの問題は以前よりは重要でなくなった、といえるかも知れません。&lt;/p>
&lt;p>ただ、立場や観点によっては一つの言語に集中したい場合もあるかと思います。例えば学生や、未経験からエンジニアに転職しようとする人にいきなり二つ以上の言語を扱えるように注文するのは難しいことでしょう。エンジニアの追求する技術においてもそうです。フロントエンドエンジニアがいきなり今すぐ使う予定でもないGoやJavaのようなバックエンドで使われる言語を勉強する必要はないはずです。そして会社としては、複数の言語を扱えるエンジニアを求めるということは採用において非常に厳しい条件となるはずです。なので、依然として市場において一つの言語のステータスというのは無視できないものなのではないかと私は思っています。&lt;/p>
&lt;p>というわけで、今回は多少主観的な観点からの話になりますが、他の言語や分野で、Kotlinという言語の展望について考えてみたことを述べたいと思います。それでは、どうぞ。&lt;/p>
&lt;h2 id="vs-java">vs Java&lt;/h2>
&lt;h3 id="better-javaという捉え方">Better javaという捉え方&lt;/h3>
&lt;p>Kotlin(JVM)をJavaと比べると、コンパイル結果がバイトコードを生成するため、「Javaと互換性が完璧であり、性能もまた変わらない」というのが世間一般でいうKotlinの評価ではないかと思います。その上拡張関数やCoroutine、スコープ関数、Null安全性などさまざまな機能が揃っているので、表面上は&lt;code>better java&lt;/code>と読んでも良いのではないかと思わせる面もあります。それに、JavaのバージョンアップでJVMの改良が行われると、結局それもKotlinの改善につながることとなりますね。Javaも1.8以降は半年に1回のリリース政策によりバージョンアップが早くなっていまずが、まだアプリケーションエンジニアの立場からするとKotlinと比べ惜しいところもなくはないかなと思います。&lt;/p>
&lt;p>ここまでの話だと、Kotlinは完璧にJavaを代替できる言語であるかのように聞こえます。つまり、これからは全くJavaを使う理由はなくて、何もかもKotlinに移行するという選択肢しかないかのようにですね。しかし、業界の事情はどうなのでしょうか。&lt;/p>
&lt;p>まずJavaの歴史から考えてみましょう。Javaは長い間、「世界で最もよく使われる言語」であって、他の言語が人気を得た今でもTop 5に入るほどの人気な言語となっています&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。そしてこれが示唆するのは、単純に今の人気、つまり、「これからも使われる可能性」だけの話ではなく、「今まで使われた回数」が圧倒的に高いということも意味するという点です。今まで作られた多くのシステムやアプリケーションがJava基盤になっているので、余程のことがない限りは維持保守や機能の拡張においてJavaのエンジニアを求めることになるでしょう。&lt;/p>
&lt;p>また、こういう側面もあります。JVM言語としてJavaのメリットを活かしつつ、より発展したコードを書けるというコンセプトで登場した言語はKotlinだけではないということです。今までClojure・Scala・Groovyなどさまざまな言語が登場し、それぞれの言語がそれなりの需要や分野を確保・拡張できてはいるものの、そのうちどれも「Javaを超えた」という評価をもらってはいないのが現状かと思います。同じくKotlinの場合も、その立場が他のJVM言語と大きく変わっているとは言えないものではないでしょうか。なので、「JVM言語だ」「Javaよりモダンだ」という特徴は、少なくともKotlinが今後Javaを超えられるという根拠にはならないかと思っています。&lt;/p>
&lt;p>モバイルではAndroidの言語としてJavaよりKotlinを採用する例が多くなっているかと思いますが、これはOracleとGoogleの訴訟絡みでJavaを1.8しか使えなかったことも理由の一つかと思います。現在Javaがよく使われているWebの場合、OpenJDKのバージョンに特に法理的な問題もなく、Java 17からはOracleJDKも無償で利用できるようになったので、モバイルとはまた状況は違うのではないかと個人的には思っています。&lt;/p>
&lt;p>もちろん、上記の問題はJetbrainsでもその点は最初から認識していたため、最初からKotlinがJavaと相互運用できる言語として設計した部分はあります。なので、あくまで既存のJavaアプリケーションをKotlinでリプレイスする、というよりは、部分的な移行から新規開発で占有率を徐々に上げていくことを目標としているのではないかと思います。その戦略は十分に納得できるもので、あとは企業の方でJavaとKotlinという二つの言語を同時に運用することに抵抗がなければ、Javaを使っていた場合でも問題なくKotlinを受け入れられると思います。実際、自分の場合でもJavaからKotlinの移行は全く問題ありませんでした。&lt;/p>
&lt;h3 id="kotlinも強くなる">Kotlinも強くなる&lt;/h3>
&lt;p>最近のフレームワークやライブラリの方をみると、まだKotlinがモバイル以外の分野での認知度は劣るものの、少しづつJavaがメインストリームであった分野で採用されているケースが増えてきているような気もします。例えば、自分が仕事で使っている&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.kotlin" target="_blank" rel="noopener"
>Spring boot&lt;/a>、&lt;a class="link" href="https://github.com/FasterXML/jackson-module-kotlin" target="_blank" rel="noopener"
>Jackson&lt;/a>、&lt;a class="link" href="https://github.com/awslabs/aws-sdk-kotlin" target="_blank" rel="noopener"
>AWS SDK&lt;/a>などウェブアプリケーションで有名なものがKotlinに対応していて、他にも&lt;a class="link" href="https://www.jooq.org/doc/latest/manual/getting-started/jooq-and-kotlin/" target="_blank" rel="noopener"
>jOOQ&lt;/a>、&lt;a class="link" href="https://jooby.io/v1/doc/lang-kotlin/" target="_blank" rel="noopener"
>jooby&lt;/a>、&lt;a class="link" href="https://javalin.io/" target="_blank" rel="noopener"
>Javalin&lt;/a>のようにJavaとKotlinの両方に対応しているものも増えています。&lt;/p>
&lt;p>もしくは、Javaで存在していたライブラリをKotlin向けに調整したものもあります。例えば&lt;a class="link" href="https://tornadofx.io/" target="_blank" rel="noopener"
>TornadoFX&lt;/a>、&lt;a class="link" href="https://github.com/grpc/grpc-kotlin" target="_blank" rel="noopener"
>gRPC&lt;/a>、&lt;a class="link" href="https://github.com/ReactiveX/RxKotlin" target="_blank" rel="noopener"
>RxKotlin&lt;/a>のようなものがそうです。そして、最初からKotlin専用として設計されたものも少なくないです。&lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>Kotlin Serialization&lt;/a>、&lt;a class="link" href="https://github.com/cbeust/klaxon" target="_blank" rel="noopener"
>Klaxon&lt;/a>、&lt;a class="link" href="https://github.com/Netflix/dgs-framework" target="_blank" rel="noopener"
>DGS&lt;/a>、&lt;a class="link" href="https://www.ktorm.org/" target="_blank" rel="noopener"
>Ktorm&lt;/a>、&lt;a class="link" href="https://github.com/kotest/kotest" target="_blank" rel="noopener"
>Kotest&lt;/a>、&lt;a class="link" href="https://github.com/mockk/mockk" target="_blank" rel="noopener"
>MockK&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>、&lt;a class="link" href="https://litote.org/kmongo/" target="_blank" rel="noopener"
>KMongo&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/xodus" target="_blank" rel="noopener"
>Xodus&lt;/a>、&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>、&lt;a class="link" href="https://github.com/Kodein-Framework/Kodein-DI" target="_blank" rel="noopener"
>Kodein-DI&lt;/a>などがそうですね。なので、Javaの世界に寄生していた数年前とは違って、Kotlinだけでもウェブアプリケーションを十分構築できるレベルまできているのではないか、というのが自分の考えです。&lt;/p>
&lt;p>結論として、まだ二つの言語を比べると、Javaの方が圧倒的に規模はでかく、知名度でも上にあるのですが、Kotlinも競争できる力を身につけてきたので、これからは十分状況が変わる可能性がある、と思っています。&lt;/p>
&lt;h2 id="vs-go">vs Go&lt;/h2>
&lt;h3 id="早いの美徳">「早い」の美徳&lt;/h3>
&lt;p>仕事でGoを使っている立場からすると、Kotlinに比べGoの優越な側面はやはり「とにかく早い」ということではないかと思います。基本的にネイティブにコンパイルされる言語なのでランタイム性能も優秀なはずですが、コンパイルもビルドもとにかく早いのは確かに良いなと思いました。特に、コードの修正後にユニットテストで検証してみることが多いのですが、Kotlinのプロジェクトと比べるととにかく早いのでストレスがないですね。(Kotlinの場合は使っているウェブフレームワークがSpringで、テストケースがより多い、ビルド時にはシングルスレッドでやっているということもありますが)&lt;/p>
&lt;p>そのほかにもGitHubのパッケージをそのまま使えたり、別途ライブラリを使わなくてもstructをすぐにJSONとして扱える(&lt;code>omitempty&lt;/code>とかも便利な場面がある)なところは印象的で、かなりウェブ開発に特化されているなという印象までありました。ネイティブなのでビルドして生成されるバイナリのサイズが小さいのも良いですね。これらの特徴からして、最近トレンドとなっているサーバレスやマイクロサービスなどおいてはKotlinよりGoを採用した方が有利な面が多いかなと思います。&lt;/p>
&lt;p>まだサーバがクラウド上のVMに移行したばかりの頃は、JVMを使う言語の問題はだいたいマシンスペックの向上により無視できました。しかし、サーバレスとマイクロサービスアーキテクチャが流行りながらJVMの特徴が再び問題となってきていますね。まずサーバレスだと、JVMが完璧にロードされるまで時間がかかるる上に、さらにコールドスタートにも時間がかかります&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。また、マイクロサービスにおいては、JVMが占めるヒープメモリとストレージが増えることでインスタンスごとのコストが増えるという問題が挙げられています。&lt;/p>
&lt;h3 id="kotlin--遅い">Kotlin != 遅い&lt;/h3>
&lt;p>このような問題に対して、サーバレスだと&lt;a class="link" href="https://site.kotless.io/" target="_blank" rel="noopener"
>Kotless&lt;/a>のようなフレームワークが開発されていたり、&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>を利用してネイティブビルドができる&lt;a class="link" href="https://ja.quarkus.io/" target="_blank" rel="noopener"
>Quarkus&lt;/a>や&lt;a class="link" href="https://github.com/spring-projects-experimental/spring-native" target="_blank" rel="noopener"
>Spring Native&lt;/a>が開発されるなど、JVM言語でも最近のトレンドに合わせて改善が行われていはいます。&lt;/p>
&lt;p>ランタイム性能という面では、JITによる最適化でJVM言語でもGoには劣らないという面もありますね。ベンチマークを見ると&lt;a class="link" href="https://programming-language-benchmarks.vercel.app/go-vs-kotlin" target="_blank" rel="noopener"
>Kotlin/JVMとの比較&lt;/a>や&lt;a class="link" href="https://www.lambrospetrou.com/articles/kotlin-http4k-graalvm-native-and-golang/" target="_blank" rel="noopener"
>Kotlin/Native&lt;/a>でわかるように、Goに対してKotlinが性能で劣る部分もあれば、優位にある部分もあるのがわかります。&lt;/p>
&lt;p>また、&lt;a class="link" href="https://go.dev/blog/intro-generics" target="_blank" rel="noopener"
>Go 1.18でジェエリックが導入&lt;/a>されていますが、&lt;a class="link" href="https://planetscale.com/blog/generics-can-make-your-go-code-slower" target="_blank" rel="noopener"
>ジェネリックにより遅くなる可能性がある&lt;/a>という話もあり、これからもしGoに新しい機能が追加されるとしたら、それがコンパイル速度やランタイム性能に影響を及ぼす可能性もあるかなと思います。&lt;/p>
&lt;p>なので、KotlinとGoという二つの言語で考えると、少なくともパフォーマンスという観点だけではGoにこだわる必要はないかなと思います。しかし、アプリケーションの開発において言語を選ぶ基準はパフォーマンスだけでなく、生産性やクラウドで対応している言語、エンジニアが確保できるかなど色々な側面があるので、Goの代わりにKotlinを選んだほうが効率的だとは言えないのも事実です。自分が転職を決めた時も、サーバサイドではGoのエンジニアを募集している企業の方がKotlinより多かったのですが、単純にパフォーマンスが基準だとしたらこのようなことにはならなかったでしょう。Googleが推している言語であるとか、パフォーマンスだけでなく生産性の面でも優れているなどさまざまな理由が複合的に作用した結果だと言えるものかと思います。&lt;/p>
&lt;h3 id="それでも有利なのは">それでも有利なのは&lt;/h3>
&lt;p>あとは、そもそもの知名度の問題ですね。Kotlinにおいて、ネイティブイメージのビルドができ、性能が劣らないとしても、多くの場合はKotlinをモバイル(Android限定)用の言語だと認識しているのが一般的かなと思います。なので、このような認識がエンジニアと企業で変わらない限り、これからもGoの方がサーバサイドでは市場において優位に立つという状況がしばらくは続くのではないかと思っています。&lt;/p>
&lt;p>他にも、Goはその書きやすさからや入門のしやすさの人気もあると思いますが、それを踏まえると比較的書き方が複雑なKotlinの方が劣るのではないかという推測もできそうですね。自分にとってはKotlinの書き方が簡潔で良い感覚ですが、Goの書き方を簡潔だと思っている方もいるようです。確かに、キーワードが少なく、それらを覚えるのに労力が比較的少ないなら、よりロジックに集中した書き方ができるはずですね。Goで作られたアプリやCLIツールなどが増えているのも、そのような特徴からのものなのではないでしょうか。自分の場合は簡単なツールを作るときはPythonで書くのを好みますが、同じく気軽にコードが書ける稼働かの観点でいうと、KotlinよりGoが優れているとも言える気がします。なので、個人の趣味やサイドプロジェクトなどでよく使われ、それがまた人気につながるだろうと思うと、Goを好むエンジニアが増えるのもおかしくはないですね。&lt;/p>
&lt;h2 id="vs-rust">vs Rust&lt;/h2>
&lt;h3 id="最強の性能">最強の性能？&lt;/h3>
&lt;p>GCがないので同じネイティブでありながらもGoより性能が優秀だというRustですが、これもまたKotlinと同じく、知名度の問題で苦戦しているところがあるかなと思います。そもそもC/C++を代替するのが開発の目的でもあったため仕方ないのかもしれませんが、どちらかというとエンベデッドで使われるイメージがどうしてもあるような気がしますね。意外と&lt;a class="link" href="https://www.figma.com/" target="_blank" rel="noopener"
>Figma&lt;/a>、&lt;a class="link" href="https://1password.com/jp/" target="_blank" rel="noopener"
>1Password&lt;/a>、&lt;a class="link" href="https://discord.com/" target="_blank" rel="noopener"
>Discord&lt;/a>、&lt;a class="link" href="https://www.dropbox.com/" target="_blank" rel="noopener"
>Dropbox&lt;/a>、&lt;a class="link" href="https://www.mozilla.org/ja/" target="_blank" rel="noopener"
>Mozilla&lt;/a>、&lt;a class="link" href="https://line.me/ja/" target="_blank" rel="noopener"
>Line&lt;/a>、&lt;a class="link" href="https://www.npmjs.com/" target="_blank" rel="noopener"
>npm&lt;/a>、&lt;a class="link" href="https://www.cloudflare.com/ja-jp/" target="_blank" rel="noopener"
>Cloudflare&lt;/a>などさまざまな組織で採用されていて、&lt;a class="link" href="https://github.com/ogham/exa" target="_blank" rel="noopener"
>exa&lt;/a>、&lt;a class="link" href="https://github.com/sharkdp/bat" target="_blank" rel="noopener"
>bat&lt;/a>、&lt;a class="link" href="https://github.com/Wilfred/difftastic" target="_blank" rel="noopener"
>difftastic&lt;/a>、&lt;a class="link" href="https://github.com/ClementTsang/bottom" target="_blank" rel="noopener"
>bottom&lt;/a>などのCLIツールから&lt;a class="link" href="https://yew.rs/" target="_blank" rel="noopener"
>yew&lt;/a>、&lt;a class="link" href="https://seed-rs.org/" target="_blank" rel="noopener"
>seed&lt;/a>、&lt;a class="link" href="https://dioxuslabs.com/" target="_blank" rel="noopener"
>Dioxus&lt;/a>、&lt;a class="link" href="https://rocket.rs/" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://github.com/http-rs/tide" target="_blank" rel="noopener"
>tide&lt;/a>、&lt;a class="link" href="https://github.com/poem-web/poem" target="_blank" rel="noopener"
>poem&lt;/a>のようなGUIやウェブフレームワークなどがたくさん開発されていますが、これもまた特に調査してみないとわからないくらいです。&lt;/p>
&lt;p>さまざまなベンチマークでその性能が検証されていて、使ってみたエンジニアからも評判の高いものとなっているRustですが、やはり知名度が低いので、企業からも採用するのはかなり難しい判断になるでしょう。実際Jetbrainsの去年の設問では&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/rust/#Rust_how-do-you-use-rust" target="_blank" rel="noopener"
>Rustは趣味もしくは個人用途、サイドプロジェクトで使う&lt;/a>と答えた割合のエンジニアが多かったのを見ると、やはり企業の需要はあまりようです。ただ、逆にいうと、このようにRustに好意的なエンジニアが増え、さまざまなプロジェクトで使われ始めるといつか市場の状況も変わっていく可能性もあるということです。先ほど述べたGoのケースのように、比較的に歴史の短い若い言語でも十分その価値を立証できるのであれば市場でもメインストリームに合流できます。なので、Rustの未来はむしろ明るく、これからが期待される言語だと個人的には思っています。ただ、人気を得た後も、ウェブアプリケーションを開発するよりは今まで通りエンベデッド・システムプログラミングに特化していきそうな気がしますね。&lt;/p>
&lt;h3 id="kotlinをネイティブにしたら">Kotlinをネイティブにしたら&lt;/h3>
&lt;p>RustをKotlinとの比較をするとしたら、Kotlin/Nativeがあるので、言語自体でできることはそう変わらないものの、Rustがエンベデッドやシステムプログラミングという分野でC/C++を代替していく傾向があるのに対して、これといった成果があまり見当たらないというのが問題かなと思います。特にKotlin/NativeはLLVM基盤なので、GraalVMによるネイティブコンバイるができるウェブフレームワークが登場している今はますますそのポジションが曖昧なものになっている気もします。Object-CやC/C++とのinteropができると言われていますが、そのようなユースケースだとそもそもObject-CやC/C++といった言語を使った方が色々と有利なのではないでしょうか。もちろん、Rustには所有権のような概念があり、他の言語と比べプログラミングが難しいとされているので、Kotlin/Nativeを採用した方がコーディングは楽になるかもしれません。でも、Nativeを追求するならやはりパフォーマンスが重視される場面が多いので、そこではGCのあるKotlinが不利な気がしますね。このような面からすると、やはりKotlin/Nativeのポジショニングが難しそうな気がします。&lt;/p>
&lt;p>結論としては、Kotlin(JVM)とRustはそれぞれ特化した分野が違っていて、大きな変化がない限り互いの領域を蝕むことなく発展していきそうです。どちらかというとKotlin/Nativeが直接的なライバルになる可能性はありますが、そもそものポジショニングが曖昧なところがあるので、Nativeがどうしても必要な場面ではRustが使われる可能性が高いのではないか、という気がしています。&lt;/p>
&lt;h2 id="vs-python">vs Python&lt;/h2>
&lt;h3 id="万能ツール">万能ツール&lt;/h3>
&lt;p>ここ数年で最も人気を得ている言語の一つ、Pythonの場合は、Kotlinと比べて見るとどうでしょうか。まず自分の場合だと、日常での自動化や簡単なツールを作る場面ではPythonの方をよく使っていて、本格的なウェブアプリケーションを開発するとしたらKotlinを選ぶことが多いです。もちろん、なんでもできる言語なので大規模のアプリケーションを作るのにPythonがNGというわけではないです。実際Uber、Google、PayPal、Netflixなど有種の企業がPythonを使っていて、あの有名なInstagramのサーバサイドもPythonで書かれていると言われていますね。&lt;/p>
&lt;p>ただやはり、PythonはデータサイエンスやAIといった分野でよく使われているイメージがあり、使いやすく、そこまで性能が求められていない場面でなら良いものの、個人的にはその限界が明確であることが問題かなという気もします。本格的な業務用のアプリを開発した経験がないのであくまで印象と推測の話となりますが、Pythonをサーバサイドに取り入れている企業は大概がスタートアップであって、サービスが古くなるとインタープリター言語特有のメンテが難しくなるという問題が出てくる可能性が高いではないかと思いますね。JavaScriptの例もありますが、Pythonのタイプヒントはあくまでヒントであって、TypeScriptのようにコンパイルタイムで検出できるエラーを確実にわかるわけでもないです。あとは性能ですが、&lt;a class="link" href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener"
>GIL&lt;/a>のような問題もあります。このような問題を認識しているため、検証用のアプリ(プロトタイプ)をPythonで書いてから他の言語に移行するという例もあるのかなと思ったりしています。&lt;/p>
&lt;h3 id="pythonだけの領域でもないが">Pythonだけの領域でもないが&lt;/h3>
&lt;p>逆にKotlinでいうと、Jupyterを使えるなど&lt;a class="link" href="https://kotlinlang.org/docs/data-science-overview.html#kotlin-libraries" target="_blank" rel="noopener"
>Kotlinでもデータサイエンスに使える&lt;/a>のですが、すでにPythonが市場支配的な言語になっているところでどこまで伸びるかが問題な気がしますね。JetBrainsが主張するように、Pythonと比べ「静的型付け、Null安全性、パフォーマンス」というのは確かにKotlinが持つメリットではあるのですが、そもそものユーザ数が増える何かがないと占有率を上げるのはかなり難しくないのではないかと思います。Pythonは入門が簡単なので講座も多く、実際エンジニアではない人も使うケースが多いのですが、Kotlinはまだそのような面では弱い印象ですね。&lt;/p>
&lt;p>以上のことからして、Pythonは依然としてデータサイエンスなど元々強かった分野に対してはこれからも需要が大きく変わることはなさそうです。ウェブという分野では競合になる可能性はありますが、どちらかというとKotlinを採用した方がより安定した開発ができるので大規模なアプリの開発ではKotlin、小規模ではPythonという形になるのではないかと思います。もちろん、大規模のアプリを開発するにあたってはまたの選択肢があるのでKotlinではない他の言語が採用される可能性の方が高そうですが、あくまで二つの言語を比べた場合の話となります。&lt;/p>
&lt;h2 id="vs-javascript">vs JavaScript&lt;/h2>
&lt;h3 id="多芸多才">多芸多才&lt;/h3>
&lt;p>一つの言語でなんでもできちゃう言語が何かというと、過去はJava、少し前はPython、そして今はなんといってもJavaScriptではないかと思います。フロントエンド、バックエンド、モバイル、データサイエンスなどさまざまな分野で活躍している言語ですね。ランタイムの性能が問題となっている部分に対しても&lt;a class="link" href="https://deno.land/" target="_blank" rel="noopener"
>Deno&lt;/a>のような新しいランタイムが登場したり、V8エンジンの持続的な改善によりだんだん補完されていって、静的型付けに関してもTypeScriptの台頭によって解決されています。まさに無敵の言語のようにも見えます。&lt;/p>
&lt;p>フロントエンドにおいてはJavaScript以外は考えられない&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>というのもあり、&lt;a class="link" href="https://webassembly.org/" target="_blank" rel="noopener"
>WebAssembly&lt;/a>のような技術も発達していますが、これはまたウェブの画面描画だけでなく違う方向に向かっているような感じなので、これから何かあって(あるとは思いませんが)色々な分野で使われなくなるとしてもJavaScriptそのものが使われなくなることはないでしょう。そして同じ意味で、Kotlinがそのような分野に進出するのもかなりハードルが高いと思います。&lt;/p>
&lt;h3 id="kotlinでフロントエンド">Kotlinでフロントエンド？&lt;/h3>
&lt;p>Kotlinで言えば、Kotlin/JVMとKotlin/Native以外に3つの軸として存在しているのが&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>であり、JetBrainsの発信を見るとそこそこ力を入れている感覚ではあります。他にも、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-mpp/" target="_blank" rel="noopener"
>Compose Multiplatform&lt;/a>を通じて、モバイルだけでなくウェブやデスクトップアプリにおいてもKotlinでGUIを作成できるようになったので、なるべく自分のサイドプロジェクトなどではKotlinで完結したいと思っている私の場合はこちらも応援したいと思っています。ただ、まだモバイル以外ではそこまでメジャーではなく、新しい技術の問題(ライブラリの不足、バージョンアップによる変化が激しいなど)が考えられるのでしばらくは様子見な感じですね。あと自分のような特殊な目的がない場合は、個人でも企業側としても無理して採用すべきメリットが薄いという問題もあるかなと思います。&lt;/p>
&lt;p>バックエンドだとKotlinが競合になる可能性はまだ十分ではないかと思います。特に、今までJavaが採用されていた分野だと主にJVMの安定性や数値計算の精度など検証された安全性というものがあるので、これから言語を変えるとしたらKotlinを採用する確率が高いのではないかと思っているところですが、そのような分野だと、最初からJavaScriptによるバックエンドの採用は考えない可能性が高そうです。スタートアップのようにエンジニアの求人が難しく、使われる技術の数を減らしてなるべく工数の削減しようとするか、Pythonのようにプロトタイプのアプリを作るかなどの特殊な状況ではない限り積極的にバックエンドの言語としてJavaScriptを採用する例はあまりなさそうな気がしていて、これからもおそらくそれは大きく変化していく気はしません。ただ、自分のようにKotlinで何もかも解決したい、という方がJavaScript側にもいらっしゃるとしたら、そこはまた話が変わってくるかも知れませんね。フロントエンド、バックエンド、モバイル、デスクトップまで対応したい場合にはJavaScript以上のものがないので、その会社や個人の目的次第でJavaScriptが採用される可能性は高く、そのような状況こそKotlinは採用されない可能性が高いかなと思います。&lt;/p>
&lt;h2 id="vs-dart">vs Dart&lt;/h2>
&lt;h3 id="guiの最強者">GUIの最強者？&lt;/h3>
&lt;p>Dartの場合は、言語そのものというよりは&lt;a class="link" href="https://flutter.dev/" target="_blank" rel="noopener"
>Flutter&lt;/a>が最近熱いですね。最初はモバイルでクロスプラットフォーム開発ができるということで注目されたものですが、Dartに対してはFlutterの最大の競合は&lt;a class="link" href="https://reactnative.dev/" target="_blank" rel="noopener"
>React Native&lt;/a>だと言えるかなと思いますが、それも最近のトレンドを見ると少しづつ逆転してきているような気がします。もちろんこれはあくまでも「クロスプラットフォーム用のフレームワーク」という基準での比較であり、実際は色々と複雑な事情があるでしょう。例えば、フロントエンドエンジニアがモバイルの開発も担当していて、フロントエンドのライブラリとしてはReactを使っているなどの状況を考えると、ここでいきなりFlutterを採用する可能性は低くなるはずですので。&lt;/p>
&lt;p>自分が思うにDartの最大の問題は、その最初の意図(JavaScriptを代替するという)はともかく、言語そのものの印象が薄いということです。少しだけ触ってみた感覚では、いわゆるC-Family言語としての馴染みはあっても、特段ここが魅力的だというところはあまり感じ取れなかったです。それが今はFlutterのおかがで使用率は上がってきていますが、それ以外の分野ではどうかなという疑問がまだあります。&lt;/p>
&lt;h3 id="可能性は他にもあるかもだけど">可能性は他にもあるかもだけど&lt;/h3>
&lt;p>ただ、以前からGoogleの次世代OSである&lt;a class="link" href="https://fuchsia.dev/" target="_blank" rel="noopener"
>Fuchsia&lt;/a>ではメインの開発環境となるという噂もあり、FuchsiaそのものがどんなOSになるかはまだ不明な状態ですが、もし噂通りAndroidの次世代のOSになるとしたら、ネイティブの開発そのものがDartによるものにもなり得る可能性はありますね。もしそうなると、ChromeOSを含めレガシーの環境を捨てることになるので、公式の開発の言語にKotlinを指定した時とは比べ物にならないインパクトがあることを想定すると、なかなか想像できない事態です。&lt;/p>
&lt;p>もちろんDartもプログラミング言語なので、これからのフレームワークやライブラリの開発次第でいくらでも状況は変わる可能性があります。&lt;a class="link" href="https://github.com/yissachar/awesome-dart" target="_blank" rel="noopener"
>こちらのリポジトリ&lt;/a>を参照すると、サーバサイドのフレームワークもすでにいくつか存在しているので、自分の考えているKotlinで全てを解決する、という目標においてはむしろDartの方がやりやすい可能性がありますね。Kotlinの方だと&lt;a class="link" href="https://kotlinlang.org/lp/mobile/" target="_blank" rel="noopener"
>Kotlin/Multiiplatform Mobile&lt;/a>がありますが、これはどちらかというとビジネスロジックの共通化を目標としているものなので、結局iOSのコードを書く必要があります。もちろん、一部の企業でやっているように「UIはFlutterで、ビジネスロジックはネイティブで」ということもできるかとは思いますが、あまりメジャーなやり方にならないかなと思います。実際、Swiftの場合も&lt;a class="link" href="https://vapor.codes/" target="_blank" rel="noopener"
>Vapor&lt;/a>のようなフレームワークがあり、サーバサイドでも十分使えるということをアピールしていますが、採用しているエンジニアや企業が限りなく少ないというのを見ると、単純に「できる」だけでは十分ではなさそうですので。&lt;/p>
&lt;h3 id="モバイルでも強くなっていく">モバイルでも強くなっていく&lt;/h3>
&lt;p>特に今年開催された&lt;a class="link" href="https://io.google/2022/intl/ja/" target="_blank" rel="noopener"
>Google I/O&lt;/a>で確認できるように、Flutter 3ではさらにパフォーマンスの向上やFlutter Desktopの正式リリースなど様々な面での発展を見せていて、これからもFlutterの未来は明るく見えます。Flutterを採用している企業も増えてきているので、このような発展の恩恵を受け入れるのは結局時間の問題に過ぎない気がします。もちろん、ネイティブアプリの開発においても需要はこれからもあり得ると思いますが、クロスプラットフォームアプリでも事足りる分野が増えてくるとしたら、どちらがメインストリームになるかは目に見えるようなものですね。&lt;/p>
&lt;p>このような状況では、今の占有率においてKotlinのホームグラウンドとなっていると言っても過言ではないモバイルの分野で、Flutterの成長ぶりはある意味、Kotlinにおいては脅威のようなものではないかという気がします。なので、これからKotlinならではのメリットをより強化していく必要がありそうですね。先の述べたKotlin/Multiplatform Mobileのようなものが、その役割をしてくれるのではないかと期待しています。そのほかでも、Kotlinでできることは多いので、分野を問わない連携を強化していくと十分Kotlinを利用するメリットはこれからも出てくるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は、いつもと違って自分の考えが中心になる記事なので、色々と偏った判断があるかも知れませんが、とりあえずKotlinエンジニアとしての感想をまとめてみました。もちろん、自分の知見が足りてなく、モバイルやフロントエンド、データサイエンティスト、DevOpsエンジニアなど色々な分野で活躍されている方からしたら色々と間違っているか、的確ではない情報や判断も目立つかなとも思います。&lt;/p>
&lt;p>ただ、一人のエンジニアとして、ただの時流を淡々と見つめているよりは、目指す目標に対して使っている技術や興味のいくものに注目し、自分なりの判断をしてみるのもまた必要なものではないかという気がして、このような記事を作成することになりました。また、このような記事を作成することで、この後に色々な変化があって自分の展望がどれだけあっているか、実際と比べてみるのもまた有意義な振り返りとなりそうな気もします。&lt;/p>
&lt;p>今回はあまり情報がなく、Twitterにでもつぶやいたら良いかも知れない雑談に近いものですが、少しでもここでKotlinのことを改めて認識できたという方がいらっしゃるなら幸いです。&lt;/p>
&lt;p>では、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a class="link" href="https://spectrum.ieee.org/top-programming-languages" target="_blank" rel="noopener"
>IEEE Spectrum&lt;/a>、&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE&lt;/a>、&lt;a class="link" href="https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-programming-scripting-and-markup-languages" target="_blank" rel="noopener"
>Stack Overflow&lt;/a>、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/#Main_programming-languages" target="_blank" rel="noopener"
>Jetbrains&lt;/a>の調査結果を参照しました。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Warm(アイドルインスタンスを常に立ち上げておく)で対応できる部分ではありますが、スケールアウトするとコールドスタートが必要となる場合があり、インスタンスを立ち上げておくことでコストがかかる問題は避けられないですね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>Dartのような言語でJavaScriptを代替しようとした歴史がありますが、今は失敗していて、JavaScriptがより高度化した今はTypeScriptのようなスーパーセットやJavaScriptにトランスパイルできる言語でないとフロントエンドの言語を代替するのは難しいかと思われます。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>JVM言語経験者がGoを触る時のハマりどころ</title><link>https://retheviper.github.io/posts/jvm-to-go/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jvm-to-go/</guid><description>&lt;img src="https://retheviper.github.io/images/go.jpg" alt="Featured image of post JVM言語経験者がGoを触る時のハマりどころ" />&lt;p>JavaとPython、そして少しのJavaScriptの経験してなかった私が、転職先でGoとKotlinを触って1年が経ちました。最近のプログラミング言語は大体収斂進化している傾向があるので、一つの言語ができれば大体他の言語もできる、もしくは読めるようになると言います。&lt;/p>
&lt;p>しかし、言語が違うということは、その設計思想が違うということなので、同じ結果を期待して書いたつもりのコードが全く思い通りにならないケースもあります。理由は大きく二つ、「あの言語ではこうだったから、この言語でもそうだろう」という慣性と「これはこの言語の特別な仕様だろう」という思い込みなのではないかと思います。（実際私がそうでしたが）&lt;/p>
&lt;p>というわけで、今回はJava/Kotlinをバックグラウンドとして持つエンジニアがGoを触るときの落とし穴的な部分を一部紹介したいと思います。あくまで個人的な経験によるものなのですが、これからGoでコードを書くことになる方には少しでも参考になればと思います。&lt;/p>
&lt;h2 id="time">time&lt;/h2>
&lt;p>Goでは時間を扱うためのスタンダードライブラリとして&lt;a class="link" href="https://pkg.go.dev/time" target="_blank" rel="noopener"
>time&lt;/a>が存在していて、以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 現在時間を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>now &lt;span style="color:#ff79c6">:=&lt;/span> time.&lt;span style="color:#50fa7b">Now&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 時間を指定して取得(2022-04-01 12:30:00 +0000 UTC)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>someDay &lt;span style="color:#ff79c6">:=&lt;/span> time.&lt;span style="color:#50fa7b">Date&lt;/span>(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">12&lt;/span>, &lt;span style="color:#bd93f9">30&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, time.UTC)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java/Kotlinだとこれに対応するAPIとして&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/package-summary.html" target="_blank" rel="noopener"
>java.time&lt;/a>がありますね。Goと比べて違う点は、「時間」のみでなく、もっと細かい単位でクラスを分けているというところと言えますでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 年度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Year year &lt;span style="color:#ff79c6">=&lt;/span> Year&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">now&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 年月
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>YearMonth yearMonth &lt;span style="color:#ff79c6">=&lt;/span> YearMonth&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">now&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 年月日
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>LocalDate date &lt;span style="color:#ff79c6">=&lt;/span> LocalDate&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">now&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 時間
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>LocalDateTime time &lt;span style="color:#ff79c6">=&lt;/span> LocalDateTime&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">now&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、違う点はここだけではありません。当然ながら、言語が違うとライブラリの実装も変わってくるものなので、処理の結果も違うケースがありますね。代表的には、「月」単位の時間を扱う時、実装によってはGoでは意図通りの範囲にならないケースがあります。例えば以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">getOneMonthBefore&lt;/span>(t &lt;span style="color:#ff79c6">*&lt;/span>time.Time) time.Time {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 月に -1 を指定して返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> t.&lt;span style="color:#50fa7b">AddDate&lt;/span>(&lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#ff79c6">-&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一件なんの問題もなさそうなコードですが、一部のケースで以下のような問題が発生します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>date &lt;span style="color:#ff79c6">:=&lt;/span> time.&lt;span style="color:#50fa7b">Date&lt;/span>(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">31&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, time.UTC)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>oneMonthBefore &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#50fa7b">getOneMonthBefore&lt;/span>(&lt;span style="color:#ff79c6">&amp;amp;&lt;/span>date) &lt;span style="color:#6272a4">// 2022-03-03
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードの結果が「2月28日」でなく、「3月3日」になるのは、処理が以下のように行われるからです。&lt;/p>
&lt;ol>
&lt;li>&lt;code>2022-03-31&lt;/code>から1ヶ月前の&lt;code>2022-02-31&lt;/code>になる&lt;/li>
&lt;li>&lt;code>2022-02-31&lt;/code>という日付は存在しないので、2月の末日から日付の補正を行う&lt;/li>
&lt;li>2月の末日である28日から、31日の差分ほど日付をプラスする&lt;/li>
&lt;/ol>
&lt;p>というわけで「基準となる月より先月の日付が少ない場合」にこのような結果を得られるわけです。ただ、月末から1ヶ月前というものは、意図としては&lt;code>2022-02-28&lt;/code>を期待するはずですね。人間の思う処理と、実際のコードが算出する結果が違うというのは十分にあり得る状況ですが、&lt;a class="link" href="https://pkg.go.dev/time#Time.AddDate" target="_blank" rel="noopener"
>AddDate&lt;/a>のドキュメントでは上記のような処理になるという話は特に言及されてないので誤解する可能性もあるのかなと思います。&lt;/p>
&lt;p>また、Java/Kotlinで使っている&lt;code>LocalDate&lt;/code>の場合は期待通り&lt;code>2022-02-28&lt;/code>になるので、Java/Kotlinの経験のあるエンジニアが無意識的にこのような問題を起こすコードを書く可能性もあるかなと思います。ちなみに、&lt;code>LocalDate&lt;/code>を使ったコードがGoと違う結果になるのは、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/LocalDate.html#minusMonths-long-" target="_blank" rel="noopener"
>minusMonth()&lt;/a>では最後に以下のメソッドを呼び出すからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> LocalDate &lt;span style="color:#50fa7b">resolvePreviousValid&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> year&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> month&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> day&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">switch&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>month&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> day &lt;span style="color:#ff79c6">=&lt;/span> Math&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">min&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>day&lt;span style="color:#ff79c6">,&lt;/span> IsoChronology&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">INSTANCE&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">isLeapYear&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>year&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">?&lt;/span> &lt;span style="color:#bd93f9">29&lt;/span> &lt;span style="color:#ff79c6">:&lt;/span> &lt;span style="color:#bd93f9">28&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">4&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">9&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">11&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> day &lt;span style="color:#ff79c6">=&lt;/span> Math&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">min&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>day&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">30&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> LocalDate&lt;span style="color:#ff79c6">(&lt;/span>year&lt;span style="color:#ff79c6">,&lt;/span> month&lt;span style="color:#ff79c6">,&lt;/span> day&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、Goでも3月31日から1ヶ月前の日付が2月28日になるという処理を期待したい場合は、以下の二つの方法を考慮した方がいいかなと思います。&lt;/p>
&lt;ol>
&lt;li>LocalDateと同じく、閏年と月別の末尾を考慮した処理を足す&lt;/li>
&lt;li>&lt;code>AddDate()&lt;/code>で得られた月が基準となるtimeと同じ月である場合、先月の末日を返す&lt;/li>
&lt;/ol>
&lt;p>前者の場合は月を計算した後、上記の&lt;code>resolvePreviousValid()&lt;/code>と同じ処理を足すことで実現でき、後者の場合は、以下のように末日を取得することが可能なので参考にしてください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>date &lt;span style="color:#ff79c6">:=&lt;/span> date.&lt;span style="color:#50fa7b">AddDate&lt;/span>(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>, time.UTC) &lt;span style="color:#6272a4">// 3月0日を指定すると2月28日になる
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="map">map&lt;/h2>
&lt;p>Goで変数を宣言する方式は以下の二つがありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 型だけを宣言
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> intSlice []&lt;span style="color:#8be9fd">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 初期化と共に宣言
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>stringSlice &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">make&lt;/span>([]&lt;span style="color:#8be9fd">string&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>問題は、宣言の仕方によって要素を足す場合に問題が起こり得るということです。先にsliceの例を見ましょう。&lt;code>var&lt;/code>で宣言した場合でも&lt;code>make()&lt;/code>で初期化した場合でも&lt;a class="link" href="https://pkg.go.dev/builtin#append" target="_blank" rel="noopener"
>append&lt;/a>を使った要素の追加には問題がありません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> intSlice []&lt;span style="color:#8be9fd">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// sliceに値を追加する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>intSlice = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(intSlice, &lt;span style="color:#bd93f9">1&lt;/span>) &lt;span style="color:#6272a4">// [1]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、mapの場合は&lt;code>var&lt;/code>で宣言すると問題が起こる可能性があります。以下のコードは、nil pointerとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> stringMap &lt;span style="color:#8be9fd;font-style:italic">map&lt;/span>[&lt;span style="color:#8be9fd">string&lt;/span>]&lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stringMap[&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>] = &lt;span style="color:#f1fa8c">&amp;#34;a&amp;#34;&lt;/span> &lt;span style="color:#6272a4">// panic: assignment to entry in nil map
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは&lt;code>var&lt;/code>で宣言した変数は基本的にnilになるからですね。nilのmapに要素を追加しようとしたのでエラーが発生するのは当たり前ですが、Goland(Intellij)上では警告も表示されず、コンパイルも無事通るので実際にコードを実行するまでこのコードが動くかどうかはわかりません。むしろ、sliceを先に扱っていたなら、nilでもappendできるので「Goではこれでいいのかな」と思い込みやすいかなと思います。&lt;/p>
&lt;p>JavaやKotlinでもインスタンスを生成していないMapに対して要素を足すことはできないのですが、ここはJavaやKotlinの週間というよりは「Goの特殊性」と考えてしまうケースだと思いますので、要注意なところなのではないかと思います。&lt;/p>
&lt;h2 id="switch">switch&lt;/h2>
&lt;p>Goの&lt;a class="link" href="https://gobyexample.com/switch" target="_blank" rel="noopener"
>switch&lt;/a>はJavaとよく似ています。ただ、形が似ているだけで、決定的な違いがあります。まずはJavaのswitchから見ていきましょう。以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">switch&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;zero&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;one&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;two&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">default&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;else&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaのswitchは、&lt;code>break&lt;/code>を明示的に書かない限り、条件が一致するcaseに分岐されたとしても、その下のcaseでも流れてしますね。なので、上記のコードを実行した結果は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>two
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>else
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは&lt;code>when&lt;/code>式になり、&lt;code>break&lt;/code>なしでも条件と一致するコードブロックを実行することで処理は終了します。例えば以下のようなコードを書くとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> i = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">when&lt;/span> (i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> println(&lt;span style="color:#f1fa8c">&amp;#34;zero&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> println(&lt;span style="color:#f1fa8c">&amp;#34;one&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> println(&lt;span style="color:#f1fa8c">&amp;#34;two&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> println(&lt;span style="color:#f1fa8c">&amp;#34;else&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実行した結果はJavaと違うのがわかります。省略されているだけで、一つの枝ごとに処理が&lt;code>break&lt;/code>するからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>one
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでGoのswitchの場合はどうなるかを見ていきましょう。形上はJavaと似ていますが、結果もそうでしょうか？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>i &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">switch&lt;/span> i {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;zero&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;one&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;two&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;else&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードを実行した結果は、Kotlinと同じです。つまり、「one」と出力されるということです。これはGoのswitchもまた、Kotlinと同じく枝ごとに&lt;code>break&lt;/code>するからです。なので、Javaの場合と同じ結果が欲しい場合は、&lt;code>fallthrough&lt;/code>を追加し、次の枝に進むということを明示的に書く必要があります。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>i &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">switch&lt;/span> i {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;zero&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fallthrough&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;one&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fallthrough&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">case&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;two&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fallthrough&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;else&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの経験がある場合、スタイルが似ているのでつい挙動も同じだろうと思って&lt;code>fallthrough&lt;/code>を省略してしまうというケースもあり得るかなと思います。ここは言語が違うだけ使用も違うということなので、要注意ですね。&lt;/p>
&lt;h2 id="if">if&lt;/h2>
&lt;p>Goではif文の条件がおかしいと思われる場合、コンパイルが通りません。例えば以下の例を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> Role &lt;span style="color:#8be9fd">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">const&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemAdmin = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Operator = &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Developer = &lt;span style="color:#bd93f9">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> User &lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name &lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Role Role
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// SystemAdminかDeveloperではない場合はエラーを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">checkRunnableUser&lt;/span>(u User) &lt;span style="color:#8be9fd">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> u.Role &lt;span style="color:#ff79c6">!=&lt;/span> SystemAdmin &lt;span style="color:#ff79c6">||&lt;/span> u.Role &lt;span style="color:#ff79c6">!=&lt;/span> Developer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> errors.&lt;span style="color:#50fa7b">New&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;user is not runnable&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">Test_checkRunnableUser&lt;/span>(t &lt;span style="color:#ff79c6">*&lt;/span>testing.T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u &lt;span style="color:#ff79c6">:=&lt;/span> User{Name: &lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>, Role: Operator}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#50fa7b">checkRunnableUser&lt;/span>(u)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> err &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t.&lt;span style="color:#50fa7b">Errorf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;unexpected error: %s&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードをコンパイルしようとする場合、Goland(Intellij)では条件に警告が表示され、コンパイルすると&lt;code>suspect or: u.Role != SystemAdmin || u.Role != Developer&lt;/code>というエラーメッセージが表示されるのを確認できます。エラーメッセージでもわかるように、これはif文の条件が間違っているからですね。「UserのRoleがSystemAdminかDeveloperの場合のみ許容する」という要件を満たすためには、&lt;code>or&lt;/code>ではなく&lt;code>and&lt;/code>を使う必要があります。なので、if文の条件を以下のように修正すると意図通りに動くし、IDE上の警告やコンパイル時のエラーも発生しなくなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// SystemAdminかDeveloperではない場合はエラーを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">checkRunnableUser&lt;/span>(u User) &lt;span style="color:#8be9fd">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> u.Role &lt;span style="color:#ff79c6">!=&lt;/span> SystemAdmin &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> u.Role &lt;span style="color:#ff79c6">!=&lt;/span> Developer {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> errors.&lt;span style="color:#50fa7b">New&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;user is not runnable&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの場合だと、Intellijでは条件が怪しいという警告は表示されるものの、Kotlinと同じくコンパイル時のエラーは発生しません。なので実行はできるようになりますが、警告の出ている箇所を確認していないと実際に実行してみるまでロジックが間違えていることには気づかなくなりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">enum&lt;/span> Role &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SYSTEM_ADMIN&lt;span style="color:#ff79c6">,&lt;/span> OPERATOR&lt;span style="color:#ff79c6">,&lt;/span> DEVELOPER
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>record &lt;span style="color:#50fa7b">User&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String name&lt;span style="color:#ff79c6">,&lt;/span> Role role&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">checkRunnableUser&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>User user&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>user&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">role&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">!=&lt;/span> Role&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">SYSTEM_ADMIN&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> user&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">role&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">!=&lt;/span> Role&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">DEVELOPER&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> IllegalArgumentException&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;user is not runnable&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String&lt;span style="color:#ff79c6">[]&lt;/span> args&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkRunnableUser&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> User&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> Role&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">SYSTEM_ADMIN&lt;/span>&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、問題は同じ処理をKotlinで書いてみると、Intellijで警告が出ることもなく、コンパイルも通るということです。Javaのケースと同じくランタイムでエラーが発生するコードになりますが、警告すら表示されないのでコードを注意深く確認しないと意図通りに動作している理由が何かを見逃しやすくなっているのではないかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">enum&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Role&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> value: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemAdmin(&lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Operator(&lt;span style="color:#bd93f9">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Developer(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">User&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> name: String, &lt;span style="color:#ff79c6">val&lt;/span> role: Role)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">checkRunnableUser&lt;/span>(user: User) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (user.role &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#50fa7b">Role&lt;/span>.SystemAdmin &lt;span style="color:#ff79c6">||&lt;/span> user.role &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#50fa7b">Role&lt;/span>.Developer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> IllegalAccessException(&lt;span style="color:#f1fa8c">&amp;#34;user is not runnable&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkRunnableUser(User(name = &lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>, role = &lt;span style="color:#50fa7b">Role&lt;/span>.Operator))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルタイムでエラーを事前に検知できるという点は確かにGoのコンパイラの方が優秀かなと思います。ただ、KotlinやJavaに慣れている場合、条件がおかしいということに気づくより、「&lt;code>const&lt;/code>を使っているせいか」「switchを使うべきか」など、問題の本質に気づかないようになる可能性もあるのではないかと思います。&lt;/p>
&lt;p>これは、そもそも正しく条件を書くことが何よりも大事であることでありながら、他の言語で形成された習慣で違う言語のコードを書くと問題を起こし得るということを実例として適切ではないかと思いますね。&lt;/p>
&lt;h2 id="range-loop">Range loop&lt;/h2>
&lt;p>Goのループにはfor文しかないですが、indexを利用する伝統的な形以外でも&lt;a class="link" href="https://go.dev/tour/moretypes/16" target="_blank" rel="noopener"
>Range&lt;/a>でのループがあります。以下のような形で使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> pow = []&lt;span style="color:#8be9fd">int&lt;/span>{&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">16&lt;/span>, &lt;span style="color:#bd93f9">32&lt;/span>, &lt;span style="color:#bd93f9">64&lt;/span>, &lt;span style="color:#bd93f9">128&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> i, v &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">range&lt;/span> pow {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Printf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;2**%d = %d\n&amp;#34;&lt;/span>, i, v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じ結果を出すコードをKotlinで書くとしたら、以下のようになるかと思います。一目でわかりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// kotlin
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> pow = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">16&lt;/span>, &lt;span style="color:#bd93f9">32&lt;/span>, &lt;span style="color:#bd93f9">64&lt;/span>, &lt;span style="color:#bd93f9">128&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> ((i, v) &lt;span style="color:#ff79c6">in&lt;/span> pow.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;2**&lt;/span>&lt;span style="color:#f1fa8c">$i&lt;/span>&lt;span style="color:#f1fa8c"> = &lt;/span>&lt;span style="color:#f1fa8c">$v&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Goにはポインタがあり、Range loopでポインタを使おうとすると問題が発生するケースがあります。例えば以下の例をみましょう.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> pow = []&lt;span style="color:#8be9fd">int&lt;/span>{&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">16&lt;/span>, &lt;span style="color:#bd93f9">32&lt;/span>, &lt;span style="color:#bd93f9">64&lt;/span>, &lt;span style="color:#bd93f9">128&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 新しいスライスにpowの参照を格納
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> ppow []&lt;span style="color:#ff79c6">*&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> _, v &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">range&lt;/span> pow {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ppow = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(ppow, &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ppowの値を出力
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">for&lt;/span> i, v &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">range&lt;/span> ppow {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Printf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;2**%d = %d\n&amp;#34;&lt;/span>, i, &lt;span style="color:#ff79c6">*&lt;/span>v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>想定通りだと、&lt;code>ppow&lt;/code>にはそれぞれ&lt;code>1, 2, 4, 8, 16, 32, 64, 128&lt;/code>の参照が格納されるべきでしょう。しかし、このコードを実行してみると、実際には&lt;code>128&lt;/code>と全て同じ値となっています。Range loopないで参照している値が全部同じアドレスを参照することになるからです。&lt;/p>
&lt;p>なので、ポインタを使うスライスを用いてループの処理をする場合は、以下のように&lt;code>v&lt;/code>を再代入するか、indexによる参照で問題を回避する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> pow = []&lt;span style="color:#8be9fd">int&lt;/span>{&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">16&lt;/span>, &lt;span style="color:#bd93f9">32&lt;/span>, &lt;span style="color:#bd93f9">64&lt;/span>, &lt;span style="color:#bd93f9">128&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 新しいスライスにpowの参照を格納
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> ppow []&lt;span style="color:#ff79c6">*&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> _, v &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">range&lt;/span> pow {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> v &lt;span style="color:#ff79c6">:=&lt;/span> v &lt;span style="color:#6272a4">// ここでvの値をコピー
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ppow = &lt;span style="color:#8be9fd;font-style:italic">append&lt;/span>(ppow, &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ppowの値を出力
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">for&lt;/span> i, v &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#ff79c6">range&lt;/span> ppow {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Printf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;2**%d = %d\n&amp;#34;&lt;/span>, i, &lt;span style="color:#ff79c6">*&lt;/span>v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>うっかりRange loopを使ってしまうと、ポインタを使うスライスを用いてループの処理をする場合に問題が発生する可能性があるので、気をつけたいですね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>幾つかの例を挙げましたが、まだ自分もGoでアプリを書いた歴も短く、言語に対しての理解も深くないのでこれからも色々と問題に遭遇する可能性はあるのかなと思います。その度はまたこうやってブログに載せていきたいと思います。ブログのネタができるという面では嬉しいですが、失敗からのポストは結局自分が辛くなることなので、うれしくはないですね…&lt;/p>
&lt;p>とにかくここであげた問題は全て自分が経験したものですが、大事なのは、違う言語に挑戦するときは自分の持つバックグラウンドの知識を活かしながらも、それを偏見にしたいこと、そして先走らないことかなと思いました。Goに限らず、新しいものに触れるときは常に注意しないと、という感じですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinプログラマが見たRust</title><link>https://retheviper.github.io/posts/rust-first-impression/</link><pubDate>Sun, 27 Mar 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/rust-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/rust.jpg" alt="Featured image of post Kotlinプログラマが見たRust" />&lt;p>Rustの勉強を始めたい、と思ったのはおよそ2年前のことです。当時はJavaとPythonを主に触っていたので、パフォーマンスがクリティカルな部分では対応しきれない部分があると思い、ネイティブにコンパイルされる言語に触れてみる必要があると思いました。そしてできれば、GCのなくポインタを扱う言語でアプリを書いてみたら、本業と言えるJavaの理解もより深くなるのではないかと思った次第です。&lt;/p>
&lt;p>そこで候補として考えたのがGoとRustです。ただ、Goは世間の評価はともかく、自分の立場からすると少し追求している目標とずれているところがあるなと思いました。特に転職してからGoとKotlinという言語を並行で触っていると、良くも悪くも自分がやりたいことがなんなのかわかってきた気分にもなったのです。&lt;/p>
&lt;p>そこで、そろそろ次の候補として考えていたRustに触れてみたいと思った次第です。これもまた、世間の評価は置いといて、実際自分に合うかどうかを確認してみたくなりました。最近は色々な言語が扱える&lt;a class="link" href="https://medium.com/@guestposts_92864/what-is-a-polyglot-programmer-and-why-you-should-become-one-e5629bf720c2" target="_blank" rel="noopener"
>Polyglot Programmer&lt;/a>の時代だという概念もあり、多くのプログラミング言語が互いの良いところを吸収しながらどれも似たようなものになったという評価もありますが、私の場合は、あくまで自分に合うのは何かを探るという感覚としてRustという新しい言語を接してみたいと思っています。&lt;/p>
&lt;p>なので、今回はまずこちらの&lt;a class="link" href="https://doc.rust-jp.rs/book-ja/title-page.html" target="_blank" rel="noopener"
>The Rust Programming Language&lt;/a>を読みながら、興味深かった部分について、自分が今まで経験してみた他のプログラミング言語と比べながら感想を述べたいと思います。ドキュメントが長く、自分の理解もまだ浅いのでまずは一部だけを紹介しましょう。&lt;/p>
&lt;h2 id="loop">Loop&lt;/h2>
&lt;p>Rustでは伝統の&lt;code>for&lt;/code>と&lt;code>while&lt;/code>以外にも、ループの条件を指定しない(無限ループ)&lt;code>loop&lt;/code>というのがありました。特定の条件でループを終了したい場合のみ、&lt;code>break&lt;/code>することで終了できます。例えば以下のような形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他の言語だと、普通は&lt;code>while(true)&lt;/code>のような形が多いかと思います。例えばPythonは以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span> true:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4"># do something&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinやJavaでも事情は変わりません。以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">true&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合だと、拡張関数があるので&lt;code>loop&lt;/code>というものを定義したらどうかと思いましたが、そうするとコンパイラ上でループだと認識されないので、&lt;code>break&lt;/code>を書くとコンパイルエラーとなります。なので以下のように拡張関数と作ることはできませんでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">test&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loop {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span> &lt;span style="color:#6272a4">// コンパイルエラー
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">loop&lt;/span>(doSomething: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span>(&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doSomething()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合は、&lt;code>for&lt;/code>に条件式を書かないことでシンプルな無限ループを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的に&lt;code>while(true)&lt;/code>や条件式を指定しない&lt;code>for&lt;/code>は、慣習でしかなく、直感的な理解を招くものではないと思いますので、&lt;code>loop&lt;/code>というキーワードを設けた方がコードの可読性という面ではよりわかり安いものなのではないかと思いました。細かい部分ではありますが、一回仕様としてとして決まるとなかなか変更できないものなので、どんなキーワードを使うかを決めるということも言語の設計においては大事だという気がします。&lt;/p>
&lt;h2 id="array">Array&lt;/h2>
&lt;p>Rustでは配列のindexを基準に一部を抽出するとき、以下のような書き方をします。参照(&lt;code>&amp;amp;&lt;/code>)を利用して定義する必要があって、標準出力する形も少し独特ですね。また、indexを指定して切り出したものは「所有権のない別のデータ型」として定義されています。ここで切り抜いた配列の一部を、Rustでは&lt;code>slice&lt;/code>と呼んでいるらしいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> arr &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> slice &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&lt;/span>arr[&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">..&lt;/span>&lt;span style="color:#bd93f9">3&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println!(&lt;span style="color:#f1fa8c">&amp;#34;{:?}&amp;#34;&lt;/span>, slice); &lt;span style="color:#6272a4">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pythonでもかなり似たような感じでコードが書けます。以下は上記と同じ挙動をするコードの例です。ただ、ここで切り抜いた&lt;code>slice&lt;/code>のデータ型は同じく&lt;code>list&lt;/code>になるというのがRustとの違いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">list&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">slice&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">list&lt;/span>[&lt;span style="color:#bd93f9">1&lt;/span>:&lt;span style="color:#bd93f9">3&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(&lt;span style="color:#8be9fd;font-style:italic">slice&lt;/span>) &lt;span style="color:#6272a4"># [1, 2]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合は、&lt;a class="link" href="https://kotlinlang.org/docs/collections-overview.html#list" target="_blank" rel="noopener"
>List&lt;/a>の関数に&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html" target="_blank" rel="noopener"
>Range&lt;/a>オブジェクトを渡すことで同じことができます。少し問題になるのは、Kotlin特有の&lt;code>Range&lt;/code>の書き方がどのような範囲を示すのか覚えてないとその範囲が分かりづらいということです。幸い、ここはIntellij Idea 2021.3のアップデートで&lt;a class="link" href="https://blog.jetbrains.com/idea/2021/10/intellij-idea-2021-3-eap-5/#inline_hints_for_ranges" target="_blank" rel="noopener"
>ヒントを表示&lt;/a>してくれるようになったので、これ以前のバージョンを使っている場合はアップデートした方が良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(&lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> subList = list.slice((&lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">2&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(subList) &lt;span style="color:#6272a4">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> subListUntil = list.slice((&lt;span style="color:#bd93f9">1&lt;/span> until &lt;span style="color:#bd93f9">3&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(subListUntil) &lt;span style="color:#6272a4">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの場合は、インデックスの範囲を&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/List.html#subList-int-int-" target="_blank" rel="noopener"
>List.subList()&lt;/a>に渡すことで同じことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Integer&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> list &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">4&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Integer&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> subList &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">subList&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>subList&lt;span style="color:#ff79c6">);&lt;/span> &lt;span style="color:#6272a4">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合は、Pythonと全く同じ方法で定義ができますね。また、配列からインデックスの範囲を指定して切り取ったviewを&lt;code>slice&lt;/code>と呼ぶのはRustと一緒です。ただ、Goのsliceはarrayと違って、可変長ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>arr &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd">int&lt;/span>{&lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slice &lt;span style="color:#ff79c6">:=&lt;/span> arr[&lt;span style="color:#bd93f9">1&lt;/span>:&lt;span style="color:#bd93f9">3&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(slice) &lt;span style="color:#6272a4">// [1 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="immutability">Immutability&lt;/h2>
&lt;p>Rustでの変数の宣言は基本的に&lt;code>let&lt;/code>一つで、不変になります。もちろん可変できる変数を定義するのは不可能ではなくて、以下のように&lt;code>mut&lt;/code>キーワードを使うことで値を再代入することはできます。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fn&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#ff79c6">mut&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#f1fa8c">&amp;#34;The value of x is: {}&amp;#34;&lt;/span>, x); &lt;span style="color:#6272a4">// The value of x is: 5
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#f1fa8c">&amp;#34;The value of x is: {}&amp;#34;&lt;/span>, x); &lt;span style="color:#6272a4">// The value of x is: 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他のプログラミング言語だと、変数の宣言時にその変数の可変性をあらかじめキーワードで表現するようになっているケースが多いかと思います。もしくは、基本的に変数は可変で、不変にしたい場合にだけ特別なキーワードを使うとかですね。しかし、Rustでは変数は基本的にimmutableであるというのが特徴的です。GCのない言語として、メモリの安全性を確保するための工夫がここで現れていると言っていいでしょうか。&lt;/p>
&lt;p>もちろん、Pythonのように変数の宣言と再代入の区別が付かないケースもありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;The value of x is: &lt;/span>&lt;span style="color:#f1fa8c">{}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>format(x)) &lt;span style="color:#6272a4"># The value of x is: 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;The value of x is: &lt;/span>&lt;span style="color:#f1fa8c">{}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>format(x)) &lt;span style="color:#6272a4"># The value of x is: 6&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合は不変だと&lt;code>val&lt;/code>、可変だと&lt;code>var&lt;/code>で宣言するようになっていますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> x = &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x = &lt;span style="color:#bd93f9">5&lt;/span> &lt;span style="color:#6272a4">// コンパイルエラー
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> y = &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>y = &lt;span style="color:#bd93f9">7&lt;/span> &lt;span style="color:#6272a4">// OK
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの場合は、Rustと逆です。&lt;code>final&lt;/code>をつけない場合、基本的に再代入ができる構造ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span> &lt;span style="color:#6272a4">// OK
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> y &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>y &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">7&lt;/span> &lt;span style="color:#6272a4">// コンパイルエラー
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合は、変数をimmutableにできる方法はないようですね。なので、再代入は自由ですが、逆にJavaの&lt;code>final&lt;/code>のようなキーワードが欲しい気分にもなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x = &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(x) &lt;span style="color:#6272a4">// 6
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="shadowing">Shadowing&lt;/h2>
&lt;p>これは全く予想できなかった部分ですが、Rustのドキュメントには変数にシャドーイングを使えると紹介されています。&lt;code>mut&lt;/code>キーワードをつけると再代入は可能なので、それで良いのではという気もしますが、変数を不変にしながら、違うデータ型として定義し直す場合などに使えるという説明でした。&lt;/p>
&lt;p>Rustではシャドーイングを使って以下のようなコードを作成できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fn&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> x &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>; &lt;span style="color:#6272a4">// 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> x &lt;span style="color:#ff79c6">=&lt;/span> x &lt;span style="color:#ff79c6">*&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>; &lt;span style="color:#6272a4">// 12
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#f1fa8c">&amp;#34;The value of x is: {}&amp;#34;&lt;/span>, x); &lt;span style="color:#6272a4">// The value of x is: 12
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pythonの場合も似たようなことができます。同じ挙動をするコードを以下のように書くと、問題なく動きます。変数の宣言と再代入が厳密に区別されない故のことかと思いますが、形的にはRustと全く一緒と言えますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#ff79c6">=&lt;/span> x &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#ff79c6">=&lt;/span> x &lt;span style="color:#ff79c6">*&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;The value of x is: &lt;/span>&lt;span style="color:#f1fa8c">{}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>format(x)) &lt;span style="color:#6272a4"># The value of x is: 12&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合、シャドーイングは一部の場合のみ可能です。関数の引数と、その関数で宣言している変数名が一致する場合ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">shadow&lt;/span>(&lt;span style="color:#ff79c6">value&lt;/span>: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> value = &lt;span style="color:#ff79c6">value&lt;/span> + &lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#6272a4">// Name shadowed: value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> println(&lt;span style="color:#ff79c6">value&lt;/span>) &lt;span style="color:#6272a4">// valの方が出力される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaでは、シャドーイングができないです。ただ、以下のような形は可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Clazz&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> value &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">setValue&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> value&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">value&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> value&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合、少し複雑になります。以下の例をみると、&lt;code>x&lt;/code>の宣言と代入を2回していますが、スコープが分かれてあるから可能なことです。Kotlinのケースと似ているとも言えますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;Before the decision block, x:&amp;#34;&lt;/span>, x) &lt;span style="color:#6272a4">// Before the decision block, x: 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">true&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x&lt;span style="color:#ff79c6">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;After the decision block, x:&amp;#34;&lt;/span>, x) &lt;span style="color:#6272a4">// After the decision block, x: 0
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、以下のようにif文での&lt;code>x&lt;/code>に対して再代入することで挙動が変わります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;Before the decision block, x:&amp;#34;&lt;/span>, x) &lt;span style="color:#6272a4">// Before the decision block, x: 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">true&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x&lt;span style="color:#ff79c6">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;After the decision block, x:&amp;#34;&lt;/span>, x) &lt;span style="color:#6272a4">// After the decision block, x: 2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように他の言語だとなるべく使わないように誘導しているシャドーイングですが、Rustでは一つの機能として紹介しているのが面白いところでした。これもまた、後述する「所有権」というものと強く関係しているような気がします。&lt;/p>
&lt;h2 id="ownership">Ownership&lt;/h2>
&lt;p>他の言語と比べたときに、Rustならではの特徴と言えるものは所有権ではないでしょうか。今まで私はGCのない言語を触ってみたことがないので、これはかなり興味深い概念でした。例えばKotlinの場合はNativeでコンパイルする場合、&lt;a class="link" href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-native-memory-management-update/#kn-gc" target="_blank" rel="noopener"
>参照カウント&lt;/a>を使うと言われています。JavaやPython, Goの場合はGCが働いて参照されていないオブジェクトが占めているメモリを解放することになりますね。&lt;/p>
&lt;p>しかし、Rustでは定数、不動小数点数、論理値、文字というスカラー型を除いた全ての参照型に関しては「一度使われたらメモリは解放される」「スコープを外れたら解放される」という原則を持っているようです。参照型とスカラー型という区分はJavaのプリミティブ型と参照型の関係を思い出させるところがありますね。より積極的かつ攻撃的なメモリ解放が行われるという違いはありますが。&lt;/p>
&lt;p>基本的には一回使った変数に対しては2回使えなかったり、値の変更ができないかと思った方が良い、ということかなと思いますが、他にも色々と興味深いものがありました。&lt;/p>
&lt;h3 id="move">Move&lt;/h3>
&lt;p>所有権と関係する概念で、ムーブがあります。変数とデータが実際どうやって相互作用するかによるものらしいです。早速下のコードを見ていきましょう。なんの問題もなさそうなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> s1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> s2 &lt;span style="color:#ff79c6">=&lt;/span> s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println!(&lt;span style="color:#f1fa8c">&amp;#34;s1 = {}, s2 = {}&amp;#34;&lt;/span>, s1, s2); &lt;span style="color:#6272a4">// s1 = hello, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記の&lt;code>String literal&lt;/code>を&lt;code>String&lt;/code>に変えたら問題が起こります。以下のコードを見ましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> s1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>::from(&lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> s2 &lt;span style="color:#ff79c6">=&lt;/span> s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println!(&lt;span style="color:#f1fa8c">&amp;#34;{}, world!&amp;#34;&lt;/span>, s1);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、コンパイルしようとすると以下のようなエラーが発生します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>error&lt;span style="color:#ff79c6">[&lt;/span>E0382&lt;span style="color:#ff79c6">]&lt;/span>: use of moved value: &lt;span style="color:#f1fa8c">`&lt;/span>s1&lt;span style="color:#f1fa8c">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:4:27
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">3&lt;/span> | &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">s2&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | -- value moved here
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">4&lt;/span> | println!&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;{}, world!&amp;#34;&lt;/span>, s1&lt;span style="color:#ff79c6">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^ value used here after move
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">=&lt;/span> note: move occurs because &lt;span style="color:#f1fa8c">`&lt;/span>s1&lt;span style="color:#f1fa8c">`&lt;/span> has &lt;span style="color:#8be9fd;font-style:italic">type&lt;/span> &lt;span style="color:#f1fa8c">`&lt;/span>std::string::String&lt;span style="color:#f1fa8c">`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>which does not implement the &lt;span style="color:#f1fa8c">`&lt;/span>Copy&lt;span style="color:#f1fa8c">`&lt;/span> trait
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、&lt;code>s1&lt;/code>のデータが&lt;code>s2&lt;/code>に移動したのでもう使えないということです。なので、二つの変数に同じデータを保証したい場合は、明示的に値をコピーする必要があります。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> s1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>::from(&lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> s2 &lt;span style="color:#ff79c6">=&lt;/span> s1.clone();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println!(&lt;span style="color:#f1fa8c">&amp;#34;s1 = {}, s2 = {}&amp;#34;&lt;/span>, s1, s2); &lt;span style="color:#6272a4">// s1 = hello, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なぜこうなっているかというと、Rustでは変数がスコープの外に移動するときにメモリの解放が起こりますが、ここで複数の変数が同じポインタを使っている場合は二重解放が起こる危険があるからと説明されています。また、&lt;code>String literal&lt;/code>と違って&lt;code>String&lt;/code>はimmutableではないので、s1の再代入でs2のデータまで変わってしまうという問題を防ぐための意図もあるような気がします。&lt;/p>
&lt;p>実際このような代入が問題となる言語のケースもありますね。例えばPythonの方を見ましょう。二つの変数が同じポインタを使っているので、再代入で両方とも値が変更されたのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>s1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s2 &lt;span style="color:#ff79c6">=&lt;/span> s1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;s1 = &lt;/span>&lt;span style="color:#f1fa8c">{}&lt;/span>&lt;span style="color:#f1fa8c">, s2 = &lt;/span>&lt;span style="color:#f1fa8c">{}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>format(s1, s1)) &lt;span style="color:#6272a4"># s1 = hello, s2 = hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;s1 = &lt;/span>&lt;span style="color:#f1fa8c">{}&lt;/span>&lt;span style="color:#f1fa8c">, s2 = &lt;/span>&lt;span style="color:#f1fa8c">{}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>format(s1, s1)) &lt;span style="color:#6272a4"># s1 = world, s2 = world&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JavaではStringをimmutableとして扱っているため、s1の値を再代入してもs2に影響はありません。KotlinもJVMの場合は、基本的にJVMのバイトコードを生成するためか同じ挙動をします。以下をご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> s1 = &lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> s2 = s1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(&lt;span style="color:#f1fa8c">&amp;#34;s1 = &lt;/span>&lt;span style="color:#f1fa8c">$s1&lt;/span>&lt;span style="color:#f1fa8c">, s2 = &lt;/span>&lt;span style="color:#f1fa8c">$s2&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// s1 = hello, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s1 = &lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(&lt;span style="color:#f1fa8c">&amp;#34;s1 = &lt;/span>&lt;span style="color:#f1fa8c">$s1&lt;/span>&lt;span style="color:#f1fa8c">, s2 = &lt;/span>&lt;span style="color:#f1fa8c">$s2&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// s1 = world, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの場合も前述した通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>var s1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var s2 &lt;span style="color:#ff79c6">=&lt;/span> s1&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;s1 = %s, s2 = %s&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> s1&lt;span style="color:#ff79c6">,&lt;/span> s2&lt;span style="color:#ff79c6">));&lt;/span> &lt;span style="color:#6272a4">// s1 = hello, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;s1 = %s, s2 = %s&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> s1&lt;span style="color:#ff79c6">,&lt;/span> s2&lt;span style="color:#ff79c6">));&lt;/span> &lt;span style="color:#6272a4">// s1 = world, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goでも変数はimmutableとして定義できませんが、この再代入により値が変わる可能性があるものに対しては安全性を担保されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>s1 &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s2 &lt;span style="color:#ff79c6">:=&lt;/span> s1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(fmt.&lt;span style="color:#50fa7b">Sprintf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;s1 = %s, s2 = %s&amp;#34;&lt;/span>, s1, s2)) &lt;span style="color:#6272a4">// s1 = hello, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s1 = &lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(fmt.&lt;span style="color:#50fa7b">Sprintf&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;s1 = %s, s2 = %s&amp;#34;&lt;/span>, s1, s2)) &lt;span style="color:#6272a4">// s1 = world, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Rustで明示的にコピーをしない場合はデータそのものが移動してしまうというのは確かにコーディング時には気を使わないといけないものですが、幸いコンパイルタイムで確認できる問題であり、他の言語を扱うときには思わぬ挙動をする可能性がある習慣を矯正してくれる可能性もあるかなと思うと、良い仕様ではなイカという気もしますね。&lt;/p>
&lt;h2 id="closure">Closure&lt;/h2>
&lt;p>Rustではclosureを関数内の関数として定義することももちろん可能ですが、&lt;code>|val| val + x&lt;/code>の形式で書きます。他の言語でlambdaと呼ばわれているものですね。多少は独特な書き方な気もしますが、型の省略が可能なのが他の言語と比べ便利なものな気がします。もちろん型の明示的な表記もできるので、以下のような使い方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fn&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// i32の引数を必要とする場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> closure_annotated &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">|&lt;/span>i: &lt;span style="color:#8be9fd">i32&lt;/span>&lt;span style="color:#ff79c6">|&lt;/span> -&amp;gt; &lt;span style="color:#8be9fd">i32&lt;/span> { i &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> closure_inferred &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">|&lt;/span>i &lt;span style="color:#ff79c6">|&lt;/span> i &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span> ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#f1fa8c">&amp;#34;closure_annotated: {}&amp;#34;&lt;/span>, closure_annotated(i)); &lt;span style="color:#6272a4">// closure_annotated: 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> println!(&lt;span style="color:#f1fa8c">&amp;#34;closure_inferred: {}&amp;#34;&lt;/span>, closure_inferred(i)); &lt;span style="color:#6272a4">// closure_inferred: 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 引数がない場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> one &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#f1fa8c">&amp;#34;closure returning one: {}&amp;#34;&lt;/span>, one()); &lt;span style="color:#6272a4">// closure returning one: 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pythonの場合は以下のように書くことができますね。もちろん、関数の中に関数を定義することもできますが、lambdaを使った方がが便利なのかなと思います。ただ、&lt;a class="link" href="https://docs.python.org/3/library/typing.html" target="_blank" rel="noopener"
>3.5から型ヒントを使える&lt;/a>ようになっていて、コンパイルタイムで確実にエラーをチェックしたい場合は明示的に型を書いたほうが良さげな気はします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>closure &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">lambda&lt;/span> x : x &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(closure(&lt;span style="color:#bd93f9">1&lt;/span>)) &lt;span style="color:#ff79c6">//&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでも簡単に定義はできるものですが、少なくとも引数の型は書く必要があります。もしくは、変数に型を指定することが必要ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> closure = { x: Int &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> x + &lt;span style="color:#bd93f9">1&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(closure(&lt;span style="color:#bd93f9">1&lt;/span>)) &lt;span style="color:#6272a4">// 2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaではメソッド内にメソッドを定義することができなく、1.8から追加された&lt;code>Functional Interface&lt;/code>を使う必要があります。また10からは&lt;code>var&lt;/code>で型推論を使えるようになりましたが、Functional Interfaceをvarとして宣言するのはできないという制約があります。他の言語と比べると最も制約が多いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Function&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Integer&lt;span style="color:#ff79c6">,&lt;/span> Integer&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> closure &lt;span style="color:#ff79c6">=&lt;/span> i &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> i &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>closure&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">apply&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">));&lt;/span> &lt;span style="color:#6272a4">// 2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合は関数内に関数を定義するのは不可能ではないものの、他の言語のlambdaのような書き方はできず、匿名関数として定義ができます。また型を明示する必要があるので、名前を除いて完全な関数を定義して変数に代入しているようなものになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>closure &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(x &lt;span style="color:#8be9fd">int&lt;/span>) &lt;span style="color:#8be9fd">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> x &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#50fa7b">closure&lt;/span>(&lt;span style="color:#bd93f9">1&lt;/span>)) &lt;span style="color:#6272a4">// 2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、closureにおいてRustの特徴はもう一つあります。closureを引数とする関数を定義するときの書き方です。closureに対してgenericを使って、whereというキーワードで関数の中にclosureを書いていくような形です。他の言語だとclosureが引数でも書き方は大きく変わらないのですが、Rustでは全く違う形になっているのが興味深いですね。例えば以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Fというclosureを引数とする関数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fn&lt;/span> &lt;span style="color:#50fa7b">apply_to_3&lt;/span>&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>F&lt;span style="color:#ff79c6">&amp;gt;&lt;/span>(f: &lt;span style="color:#50fa7b">F&lt;/span>) -&amp;gt; &lt;span style="color:#8be9fd">i32&lt;/span> &lt;span style="color:#50fa7b">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Fはi32を受け取ってi32を返すclosure
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> F: &lt;span style="color:#8be9fd;font-style:italic">Fn&lt;/span>(&lt;span style="color:#8be9fd">i32&lt;/span>) -&amp;gt; &lt;span style="color:#8be9fd">i32&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fn&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> double &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">|&lt;/span>x&lt;span style="color:#ff79c6">|&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#f1fa8c">&amp;#34;3 doubled: {}&amp;#34;&lt;/span>, apply_to_3(double)); &lt;span style="color:#6272a4">// 3 doubled: 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>まだドキュメントの半分の読んでなく、実際に何かしらのアプリを作ってみたわけでもないので今回のポストだけでは十分ではないというのは十分承知のつもりですが、久々に違う言語を学びながら、色々と興味深いところが多かったのでひとまず感想を書いてみました。&lt;/p>
&lt;p>噂ではRustのコンパイラは優秀で、そのコンパイラの指示通りにアプリを組むだけでのかなり勉強になる瞬間が多いというのと、言語自体の設計が良いという話だったので、これからも勉強しながら気づいたことや感じたこと、学んだことについてブログにまとめていきたいと思います。今回のポストだけでの企画として終わらせたくないので、今年はこれで頑張っていきたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Effective Kotlinを読む</title><link>https://retheviper.github.io/posts/effective-kotlin/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/effective-kotlin/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Effective Kotlinを読む" />&lt;p>今回は久々に本を読んだのでそれに関する感想を少し書こうと思います。転職前は主にJavaを扱っていたため、&lt;a class="link" href="https://www.amazon.co.jp/Effective-Java-%E7%AC%AC3%E7%89%88-%E3%82%B8%E3%83%A7%E3%82%B7%E3%83%A5%E3%82%A2%E3%83%BB%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF-ebook/dp/B099922DML/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=1OT3QRYCGG9BB&amp;amp;keywords=Effective&amp;#43;Java&amp;amp;qid=1645265607&amp;amp;sprefix=effective&amp;#43;kotlin%2Caps%2C753&amp;amp;sr=8-1" target="_blank" rel="noopener"
>Effective Java&lt;/a>を読み自分の書いたコードを振り返って見たことがありました。転職後はKotlinという違う言語を触るようになったものの、やはりJVMで動く言語であり、現在使っているフレームワークもSpringから変わってないので基本的には同じ観点でコードを作成すると良いのかなと思っていました。しかし、Kotlinに触れてから1年が経った今、やはり言語が違うとコードを作成するときの週間も一度は見直す必要があるのではないかと思っています。&lt;/p>
&lt;p>そこで、ちょうど&lt;a class="link" href="https://www.amazon.co.jp/Effective-Kotlin-Best-practices-English-ebook/dp/B08WXCRVD2/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=2HVT6TZYJL65A&amp;amp;keywords=effective&amp;#43;kotlin&amp;amp;qid=1645264802&amp;amp;sprefix=effective&amp;#43;kotli%2Caps%2C230&amp;amp;sr=8-1" target="_blank" rel="noopener"
>Effective Kotlin&lt;/a>という本を発見したので早速読んでみました。そして今回のポストではその内容について色々と書こうと思います。&lt;/p>
&lt;p>ちなみに、この本自体は出版されて少し経つので、ネット上でもたまにその内容やPDFの資料などを発見することあができました。例えば、この本で「可読性」のチャプタに関しての話は[こちらのブログ]の方によく整理されてあるので、参考にしてください。&lt;/p>
&lt;h2 id="全体的な印象">全体的な印象&lt;/h2>
&lt;p>個人的に&lt;code>Effective Java&lt;/code>は上級者向けの本で、ある程度Javaでアプリを書いたこと経験のある人でないと理解が難しいところが多かったかなと思います。例えば、「&lt;code>try-finally&lt;/code>を
&lt;code>try-with-resource&lt;/code>に代替した方がいい」とか、「&lt;code>Stream&lt;/code>で副作用のない関数を書く方法」などが紹介されていますが、これらはやはりある程度Javaという言語の設計と仕様に対する基盤知識を必要とするものですね。&lt;/p>
&lt;p>それに比べ、&lt;code>Effective Kotlin&lt;/code>には初心者向けの内容も結構あります。例えば、そもそものオブジェクト志向が何かのような内容がありました。ただそれだけではどう思っても&lt;code>Effective Java&lt;/code>を意識したような題名が意味をなくすと判断したからか（前書きでも&lt;code>Effective Java&lt;/code>を言及しています）他には「ベストプラクティス」として書かれているものも多いです。&lt;/p>
&lt;p>そして当たり前ながら、Kotlinにおいても有効なことは&lt;code>Effective Java&lt;/code>と重なっているような部分もあります。例えば、オブジェクトのインスタンスを作るときはfactory methodを書いた方が良いとかがそうですね。&lt;/p>
&lt;p>ただ、Kotlinのバージョンアップの速さに追いついてないと感じるところがあったり（これは出版物の限界でもありますが）、上級者向けの内容は多少十分ではない感覚でしたので、どちらかというとジュニア向けの感覚ではあります。&lt;/p>
&lt;h2 id="興味深い">興味深い&lt;/h2>
&lt;p>ジュニア向けといいつつ、自分もまだジュニア（の気持ち）であるため、興味深いと思ったところもありました。ここでその一部を紹介したいと思います。&lt;/p>
&lt;h3 id="single-responsibility-principle">Single responsibility principle&lt;/h3>
&lt;p>いわゆる&lt;a class="link" href="https://ja.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener"
>SOLID&lt;/a>に触れるパートです。Kotlinでは拡張関数を用いることで、単一責任の原則を守れるという主張をしていました。まず以下のようなケースがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">isPassing&lt;/span>(): Boolean =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calculatePointsFromPassedCourses() &amp;gt; &lt;span style="color:#bd93f9">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">qualifiesForScholarship&lt;/span>(): Boolean =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calculatePointsFromPassedCourses() &amp;gt; &lt;span style="color:#bd93f9">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculatePointsFromPassedCourses&lt;/span>(): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>isPassing()&lt;/code>は&lt;code>accreditations&lt;/code>というモジュールで、&lt;code>qualifiesForScholarship()&lt;/code>は&lt;code>scholarship&lt;/code>というモジュールで使われるとします。そしたら、&lt;code>Student&lt;/code>というクラスがこれらの関数を持つのは単一責任としてどうか、ということですね。&lt;/p>
&lt;p>なので、モジュール別にこれらの関数を拡張関数として定義することが良いとのことでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// scholarship module
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>.qualifiesForScholarship(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// accreditations module
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>.calculatePointsFromPassedCourses(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしくは&lt;code>calculatePointsFromPassedCourses()&lt;/code>を外に出す方法を考えられるでしょう。しかし、この場合はこれらの二つのメソッド専用のprivateメソッドとしてつかえません。なので、&lt;/p>
&lt;ol>
&lt;li>どのモジュールでも使える共通関数を作っておく&lt;/li>
&lt;li>department別にhelper関数を作っておく&lt;/li>
&lt;/ol>
&lt;p>とかの方法も考えられます。&lt;/p>
&lt;p>確かに、よく考えると拡張関数の良いところは「interfaceの実装ややスーパークラスの継承なし」でも簡単に処理を追加できるということなので、このような使い方をするのがユースケース別に処理を分けられて良さげな気がします。特に拡張関数を使うと、関数を配置するパッケージと可視性の制御が効くというところが個人的には新しい発見でした。&lt;/p>
&lt;h3 id="consider-defining-a-dsl-for-complex-object-creation">Consider defining a DSL for complex object creation&lt;/h3>
&lt;p>オブジェクトの作成時の複雑な処理はDSLを使いましょう、というパートです。Kotlinですでに提供している例としたら、HTMLがありますね。以下のような形で定義することになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>body {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> div {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a(&lt;span style="color:#f1fa8c">&amp;#34;https://kotlinlang.org&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target = &lt;span style="color:#50fa7b">ATarget&lt;/span>.blank
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +&lt;span style="color:#f1fa8c">&amp;#34;google&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +&lt;span style="color:#f1fa8c">&amp;#34;Some content&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>確かにKtorのようなフレームワークでもよく使われている物なので、ある程度需要はあるのかなという気がしました。Kotlinだと高階関数を作るのが難しくはないので、十分挑戦できるところでもありますね。&lt;/p>
&lt;p>ただ、DSL特有の書き方を確立し、その書き方をエンジニアに共有することや最初の設計と維持管理が難しそうな気がするので、アプリの縮小が求められる今のご時世に果たして合うかとうかは少し疑問ののころところでした。&lt;/p>
&lt;p>個人的に何かのライブラリやフレームワークを作るとしたら、挑戦してみたいなと思いました。&lt;/p>
&lt;h2 id="まあそうだよねって思ったところ">まあそうだよねって思ったところ&lt;/h2>
&lt;p>なんとなくそうではないかと思っていたところを（もしくはどこかで聞いて理論的な部分は忘れたけど、無意識的のうちに習慣化されていた部分を）文として親切に整理してくれているようなパートもありました。なのでもう一度自分の考えを再確認できたといえるところでしょうか。&lt;/p>
&lt;h3 id="do-not-repeat-common-algorithms">Do not repeat common algorithms&lt;/h3>
&lt;p>「スタンダードライブラリで解決できる一般的なアルゴリズムを自前のコードで書くな」というパートです。理由は以下の通りです。&lt;/p>
&lt;ol>
&lt;li>呼び出しの方がコードを書くより時間が短くかかる&lt;/li>
&lt;li>わかりやすい名前になっている&lt;/li>
&lt;li>コードがわかりやすくなる&lt;/li>
&lt;li>最適化が効く&lt;/li>
&lt;/ol>
&lt;p>私自身もなるべくスタンダートライブラリを活用した方が良いと思っていたので、ここはすぐに納得できました。自分で書いた処理が果たして最適化されたものかどうかもわからないし、業務使用以外のロジックを触るのは避けたいという理由でした。&lt;/p>
&lt;p>この本では、以下のようなコードを上げています。自前のロジックを書いた場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> percent = &lt;span style="color:#ff79c6">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &amp;gt; &lt;span style="color:#bd93f9">100&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &amp;lt; &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-in.html" target="_blank" rel="noopener"
>coerceIn()&lt;/a>を使うことでシンプルにできます。以下がその例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> percent = number.coerceIn(&lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">100&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinには特にスタンダードラリブラリに良い関数が多いので、自前のロジックを書くよりは一度どんなAPIがあるのかを確認した方が良いケースが個人的には多かった気がします。そしてそれが納得できる理由が書いてあってよかったと思います。&lt;/p>
&lt;h3 id="implementing-your-own-utils">Implementing your own utils&lt;/h3>
&lt;p>スタンダードライブラリで解消できる問題以外で、プロジェクトに必要な共通の処理はユーティリティ関数として作っておきましょうってパートです。ユーティリティはクラスでなく、拡張関数として作ったら以下のようなメリットがあるらしいです。&lt;/p>
&lt;ul>
&lt;li>関数は状態を持たないので副作用がない&lt;/li>
&lt;li>トップレベル関数と比べると型が決まっているので使い勝手がいい&lt;/li>
&lt;li>引数よりはクラスについた形が直観的&lt;/li>
&lt;li>オブジェクトに関数をまとめるより必要な機能を探しやすい&lt;/li>
&lt;li>特定のクラスに従属されるので親クラスのものか、子クラスのものか悩まない&lt;/li>
&lt;/ul>
&lt;p>確かにJavaを使っていた時は、私もいわゆるSingleton Patternでユーティリティクラスを作ったり、DIして使えるクラスを定義しておいて、staticメソッドを書いていました。Kotlinだと、ユーティリティクラスなしでも特定のクラスに関数を追加することができるのでより使い勝手がよくなります。&lt;/p>
&lt;p>例えば、同じことをするとしても、拡張関数で書く場合とユーティリティクラスを作る場合のコードは以下のような違いがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 拡張関数を使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> isEmptyByExtension = &lt;span style="color:#f1fa8c">&amp;#34;Text&amp;#34;&lt;/span>.isEmpty()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ユーティリティクラスを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> isEmptyByUtilClass = &lt;span style="color:#50fa7b">TextUtils&lt;/span>.isEmpty(&lt;span style="color:#f1fa8c">&amp;#34;Text&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ユーティリティクラスを使う場合はまず、「どのユーティリティクラスの関数を使うか」を考えなければならないです。それに比べ、拡張関数はIDEでも自動補完ですぐ欲しい関数を見つけることができるので、より直観的なものになっていますね。&lt;/p>
&lt;p>他にも具体的なクラスにのみ追加ができたりするので、より安全な使い方ができるというのも良いところですね。色々と拡張関数は使い道が多いなという、再発見ができたと言えるところでしょうか。&lt;/p>
&lt;h3 id="builder-pattern">Builder pattern&lt;/h3>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>named arguments&lt;/a>が使えて、Builderパターンがいらないというパートです。KotlinでもBuilderパターンを使うことが技術的に不可能ではないが、named parameterを使った方が良い理由としては以下が挙げられています。&lt;/p>
&lt;ul>
&lt;li>より短い&lt;/li>
&lt;li>より綺麗&lt;/li>
&lt;li>使い方がシンプル&lt;/li>
&lt;li>スレッドセーフ&lt;/li>
&lt;/ul>
&lt;p>私自身も、Javaで使っていたのでKotlinでもBuilderパターンが必要かなと思ったことがありますが、いらないという結論を出しています。上記で挙げた理由ももちろん妥当ですが、Builderパターンだとインスタンスを生成するときに必須パラメータが揃っているかどうかを判断するのが難しくなるという理由からでした。&lt;/p>
&lt;p>例えば本に出てくるBuilderパターンの例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Pizza&lt;/span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">constructor&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> size: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> cheese: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> olives: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> bacon: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Builder&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> size: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> cheese: Int = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> olives: Int = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> bacon: Int = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">setCheese&lt;/span>(&lt;span style="color:#ff79c6">value&lt;/span>: Int): Builder = apply { cheese = &lt;span style="color:#ff79c6">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">setOlives&lt;/span>(&lt;span style="color:#ff79c6">value&lt;/span>: Int): Builder = apply { olives = &lt;span style="color:#ff79c6">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">setBacon&lt;/span>(&lt;span style="color:#ff79c6">value&lt;/span>: Int): Builder = apply { bacon = &lt;span style="color:#ff79c6">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">build&lt;/span>() = Pizza(size, cheese, olives, bacon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このBuilderは以下のような使い方ができると思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> villagePizza = &lt;span style="color:#50fa7b">Pizza&lt;/span>.Builder(&lt;span style="color:#f1fa8c">&amp;#34;L&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setCheese(&lt;span style="color:#bd93f9">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setOlives(&lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setBacon(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし以下の場合でもビルドはできますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> villagePizza = &lt;span style="color:#50fa7b">Pizza&lt;/span>.Builder(&lt;span style="color:#f1fa8c">&amp;#34;L&amp;#34;&lt;/span>).build()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もし&lt;code>cheese&lt;/code>、&lt;code>olives&lt;/code>、&lt;code>bacon&lt;/code>が&lt;code>0&lt;/code>を許容しない作りになっていると、これを修正するのは大変なことになるでしょう。もしくは、パラメータが複雑な作りのオブジェクトだったらデフォルト値を設定するか、強制null check(&lt;code>!!&lt;/code>)などを入れるか…より複雑になるだけですね。&lt;/p>
&lt;p>しかし、named parameterを使うと簡単に解決できる問題です。デフォルト値を指定しない&lt;code>val&lt;/code>だったら、それが必須項目であるということもわかりやすいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> myFavorite = Pizza(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#f1fa8c">&amp;#34;L&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cheese = &lt;span style="color:#bd93f9">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> olives = &lt;span style="color:#bd93f9">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bacon = &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="consider-factory-functions-instead-of-constructors">Consider factory functions instead of constructors&lt;/h3>
&lt;p>Javaでも最近は色々とfactory functionを導入していて、簡単にimmutableなオブジェクトを作りやすくなりました。Kotlinでもコンストラクタの作成や、named parameterによるインスタンスの生成が色々と便利ではあるものの、それでもfactory functionが良いケースがあるというパートです。理由は以下の通りです。&lt;/p>
&lt;ul>
&lt;li>関数には名前があるので、どうやってオブジェクトが生成されるかわかる
&lt;ul>
&lt;li>&lt;code>ArrayList(3)&lt;/code>よりは&lt;code>ArrayList.withSize(3)&lt;/code>がわかりやすい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>戻り値としてサブタイプのオブジェクトを指定できる
&lt;ul>
&lt;li>具体的な実装を時と場合によって違う形にすることができる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>呼び出されるたび新しいオブジェクトを作るわけではない
&lt;ul>
&lt;li>&lt;code>Connections.createOrNull()&lt;/code>のようにnullを返すこともできる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>まだ存在しないオブジェクトを提供できる
&lt;ul>
&lt;li>プロキシなしで動くようなオブジェクトを作るなどで応用できる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>オブジェクトの外に作ることで可視性を制御できる&lt;/li>
&lt;li>&lt;code>inline&lt;/code>にできるので、&lt;a class="link" href="https://kotlinlang.org/docs/inline-functions.html#reified-type-parameters" target="_blank" rel="noopener"
>reified&lt;/a>にもできる&lt;/li>
&lt;li>インスタンスを作るのが複雑なオブジェクトの手間を省く&lt;/li>
&lt;li>スーパークラスやプライマリコンストラクタを呼び出さずにインスタンスを生成できる&lt;/li>
&lt;/ul>
&lt;p>こちらも読みながらなるほどと納得しました。特に私の場合でも、Service層のDTOとController層のResponseなどのオブジェクト間のマッピングではfactory functionを導入してコードを再使用性を高められたと思っていたので、良い判断だったなと今は思っています。&lt;/p>
&lt;p>他に、factory functionを作る方法としても以下のようなものが提示されてありました。一般的にはcompanion object内に定義しておくことが多いかと思いますが、他の方法も必要であれば考慮したいものですね。&lt;/p>
&lt;h4 id="companion-object">companion object&lt;/h4>
&lt;p>Javaのstaticメソッドのようなパターン。最もわかりやすいですね。以下のような形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyLinkedList&lt;/span>&amp;lt;T&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> head: T,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> tail: MyLinkedList&amp;lt;T&amp;gt;?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">of&lt;/span>(&lt;span style="color:#ff79c6">vararg&lt;/span> elements: T): MyLinkedList&amp;lt;T&amp;gt;? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Usage
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> list = &lt;span style="color:#50fa7b">MyLinkedList&lt;/span>.of(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>factory functionは大体以下の規則を持って命名されるという説明もありました。&lt;/p>
&lt;h5 id="from">from&lt;/h5>
&lt;p>一つのパラメータを渡し、タイプを変える時（自分自身のインスタンスを返す）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> date: Date = &lt;span style="color:#50fa7b">Date&lt;/span>.from(instant)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="of">of&lt;/h5>
&lt;p>複数のパタメータを渡し、それを束ねたタイプに変換するとき&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> faceCards: Set&amp;lt;Rank&amp;gt; = &lt;span style="color:#50fa7b">EnumSet&lt;/span>.of(JACK, QUEEN, KING)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="valueof">valueOf&lt;/h5>
&lt;p>&lt;code>of&lt;/code>の冗長な形&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> prime: BigInteger = &lt;span style="color:#50fa7b">BigInteger&lt;/span>.valueOf(&lt;span style="color:#50fa7b">Integer&lt;/span>.MAX_VALUE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="instance--getinstance">instance / getInstance&lt;/h5>
&lt;p>Singletonのインスタンス取得（パラメータが同じだと常に同じインスタンスが帰ってくる）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> luke: StackWalker = &lt;span style="color:#50fa7b">StackWalker&lt;/span>.getInstance(options)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="createinstance--newinstance">createInstance / newInstance&lt;/h5>
&lt;p>instance / getInstanceは似ているが、常に新しいインスタンスを返す&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> newArray = &lt;span style="color:#50fa7b">Array&lt;/span>.newInstance(classObject, arrayLen)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="gettype">getType&lt;/h5>
&lt;p>instance / getInstanceと似ているが、違うタイプのインスタンスを返すとき&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> fs: FileStore = &lt;span style="color:#50fa7b">Files&lt;/span>.getFileStore(path)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="newtype">newType&lt;/h5>
&lt;p>createInstance / newInstanceに似ているが、違うタイプのインスタンスを返す時&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> br: BufferedReader = &lt;span style="color:#50fa7b">Files&lt;/span>.newBufferedReader(path)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="extension">extension&lt;/h4>
&lt;p>クラスにからのcompanion objectを定義しておいて、外部から拡張関数でfactory functionを付ける形です。元のクラスをいじらなくても良くなるし、パッケージと可視性の制御など拡張関数の持つ特徴を活用できますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">interface&lt;/span> &lt;span style="color:#50fa7b">Tool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> { &lt;span style="color:#6272a4">/*...*/&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Tool&lt;/span>.&lt;span style="color:#50fa7b">Companion&lt;/span>.createBigTool( &lt;span style="color:#6272a4">/*...*/&lt;/span> ): BigTool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="top-level">top-level&lt;/h4>
&lt;p>スタンダードライブラリに含まれている、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html" target="_blank" rel="noopener"
>listOf()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/set-of.html" target="_blank" rel="noopener"
>setOf()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-of.html" target="_blank" rel="noopener"
>mapOf()&lt;/a>のようなものです。&lt;/p>
&lt;p>よく使うタイプに関しては使い勝手がいいので便利なものの、IDEの自動補完などに現れたら混乱するケースもあるので命名は慎重にする必要がある、とのことでした。&lt;/p>
&lt;h4 id="fake-constructor">fake constructor&lt;/h4>
&lt;p>Pascal Caseを使って、関数をコンストラクタに見せかけるものです。Kotlinのスタンダードライブラリとしては、以下のようなものがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#bd93f9">4&lt;/span>) { &lt;span style="color:#f1fa8c">&amp;#34;User&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> } &lt;span style="color:#6272a4">// [User0, User1, User2, User3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは実際は以下のような関数ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">init&lt;/span>: (index: Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): List&amp;lt;T&amp;gt; = MutableList(size, &lt;span style="color:#ff79c6">init&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">MutableList&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">init&lt;/span>: (index: Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> list = ArrayList&amp;lt;T&amp;gt;(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(size) { index &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> list.add(&lt;span style="color:#ff79c6">init&lt;/span>(index)) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはinterfaceに対してコンストラクタを作る必要があったり、&lt;code>reified&lt;/code>タイプの引数が必要な時に考慮できるものらしいです。&lt;/p>
&lt;p>他にもfake constructorを作る方法があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Tree&lt;/span>&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">operator&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">invoke&lt;/span>(size: Int, generator: (Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): Tree&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Usage
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Tree(&lt;span style="color:#bd93f9">10&lt;/span>) { &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この場合constructor referenceではコードが複雑になる問題があるらしいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> f: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#ff79c6">::&lt;/span>Tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Fake Constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> d: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#ff79c6">::&lt;/span>Tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Invoke in companion object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> g: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#50fa7b">Tree&lt;/span>.Companion&lt;span style="color:#ff79c6">::&lt;/span>invoke
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なのでfake constructorを使うとしたら、関数として定義したほうがよさそうです。&lt;/p>
&lt;h4 id="factory-class">factory class&lt;/h4>
&lt;p>別途Factoryというクラスを置いてインスタンスを返すようにする方法ですね。Javaではinterfaceでそのようなことをするケースがありますが（&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/List.html#of%28E%29" target="_blank" rel="noopener"
>List.of()&lt;/a>みたいな）、Kotlinでも良いのか？という疑問が湧きました。結論から言いますと、「factoryクラスは状態を持つことが可能」なため、場合によっては考慮しても良いとのことです。これは思ったより活用できそうな可能性がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> surname: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">StudentsFactory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> nextId = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">next&lt;/span>(name: String, surname: String) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student(nextId&lt;span style="color:#ff79c6">++&lt;/span>, name, surname)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> factory = StudentsFactory()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> s1 = factory.next(&lt;span style="color:#f1fa8c">&amp;#34;Marcin&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Moskala&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(s1) &lt;span style="color:#6272a4">// Student(id=0, name=Marcin, Surname=Moskala)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> s2 = factory.next(&lt;span style="color:#f1fa8c">&amp;#34;Igor&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Wojda&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(s2) &lt;span style="color:#6272a4">// Student(id=1, name=Igor, Surname=Wojda)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>ざっくりなまとめとなりますが、以上が私のこの本で得られた知識への感想となります。新しい発見もあり、自分の習慣が間違ってなかったということを人の説明で補ってもらったような気にもなり、かなり興味深かったです。&lt;/p>
&lt;p>ただやはり、Kotlinがまだ新しい言語であり、いろいろなパラダイムを吸収しているためか、&lt;code>Effective Java&lt;/code>のようなレベルの高い作法に対する議論は少し足りてないような気がしていて、そこは多少残念に思います。まあ、こう思うようになったということ自体が、少しは自分が成長した証拠でもあるかなという生意気な想像もしてみるのですが。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinでデータの逆転グルーピング</title><link>https://retheviper.github.io/posts/kotlin-reverse-groupping/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-reverse-groupping/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinでデータの逆転グルーピング" />&lt;p>DBを設計する時と、最終的にアプリで活用するデータの形は大きく変わるケースがあります。特に後から機能を付け加えるとそうなりますね。もちろん正規化などを通じてより効率的にデータを保存する方法を考える必要のあるDBと、データをいかに加工して使うかを工夫するアプリの違いによるものもありますが、アプリの改修が続くと同じデータでも活用する箇所や表現の仕方が変わってくるからでもあるかなと思います。&lt;/p>
&lt;p>そういうわけで、今回はそのようなケースで一つ活用できる方法をご紹介したいと思います。アルゴリズムというわけでもありませんし、より効率的な方法はあるかなと思いますが、応用すれば結構色々な場所で使えそうな方法ではないかと思います。&lt;/p>
&lt;h2 id="シナリオ">シナリオ&lt;/h2>
&lt;p>例えば以下のようなシナリオがあるとします。&lt;/p>
&lt;ol>
&lt;li>社員はA、Bという二つの部署に配属される&lt;/li>
&lt;li>社員が部署に配属される日付はそれぞれ&lt;/li>
&lt;/ol>
&lt;p>この場合、データの作りには色々な観点があるかと思いますが、まず部署の配属日を基準にデータを作るとしたら、部署の種類、配属日とその日付に配属となった社員のリストを持つような形になるかと思います。Kotlinのコードとして表現するとしたら以下のような形ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">enum&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">DepartmentType&lt;/span> { A, B }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Department&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> departmentType: DepartmentType,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> date: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> employers: List&amp;lt;Employer&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Employer&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> id: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで社員の3人がいて、それぞれ部署Aと部署Bに配属された日付が違うケースがあるとしましょう。データとしては、以下のようなものです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>社員番号&lt;/th>
&lt;th>部署A配属&lt;/th>
&lt;th>部署B配属&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上記のデータを持って、先ほどの部署のデータを実際のリストとして作るとしたら以下のようになるかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> departments = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#50fa7b">DepartmentType&lt;/span>.A,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#50fa7b">LocalDate&lt;/span>.of(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Department&lt;/span>.Employer(id = &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Department&lt;/span>.Employer(id = &lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#50fa7b">DepartmentType&lt;/span>.A,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#50fa7b">LocalDate&lt;/span>.of(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Department&lt;/span>.Employer(id = &lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#50fa7b">DepartmentType&lt;/span>.B,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#50fa7b">LocalDate&lt;/span>.of(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Department&lt;/span>.Employer(id = &lt;span style="color:#bd93f9">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#50fa7b">DepartmentType&lt;/span>.B,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#50fa7b">LocalDate&lt;/span>.of(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Department&lt;/span>.Employer(id = &lt;span style="color:#bd93f9">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Department&lt;/span>.Employer(id = &lt;span style="color:#bd93f9">3&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、これを社員を基準に、それぞれの部署に配属された日付をデータとして加工するにはどうしたら良いでしょうか。社員番号と部署に配属となった日付の二つを持つような形です。例えば、コードで表現すると以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">JoinedDates&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> employerId: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> departmentA: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> departmentB: LocalDate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、やりたいことは先ほどの&lt;code>departments&lt;/code>を、最終的に以下のようなデータにしたいということですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> JoinedDates(employerId=EmployerId(value=1), departmentA=2022-01-01, departmentB=2022-01-01),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> JoinedDates(employerId=EmployerId(value=2), departmentA=2022-01-01, departmentB=2022-02-01),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> JoinedDates(employerId=EmployerId(value=3), departmentA=2022-02-01, departmentB=2022-02-01)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>データの整列の基準がひっくり返されるので、どうしたら良いかと悩ましくなる場面です。今回は、これを解決した自分の方法を紹介したいと思います。&lt;/p>
&lt;h2 id="ロジック">ロジック&lt;/h2>
&lt;p>Departmentを基準に考えるとEmployerのデータが複数になりますが、これを逆転させて、Employerを基準に複数のDepartmentを持つという形に加工したいというのが今回の要件です。だとすると、考えられるロジックは以下がポイントかなと思います。&lt;/p>
&lt;ol>
&lt;li>EmployerのID単位でまとめる&lt;/li>
&lt;li>EmployerごとにDepartmentをType別に分けた配列を持たせる&lt;/li>
&lt;/ol>
&lt;p>まずはネスとしているEmployerのリストに入り、そのIDを抽出する必要がありますね。このIDは重複させたくないので、MapのKeyにしておくと良さげです。&lt;/p>
&lt;p>あとは、そのMapにEmployerのIDがKeyとして存在するかどうかで以下の処理をすると良いでしょう。&lt;/p>
&lt;ol>
&lt;li>Keyが存在しない場合は、新しくDepartmentのタイプとその日付をinsert&lt;/li>
&lt;li>Keyが存在する場合は、そのvalueを取り出してDepartmentのタイプと日付を追加&lt;/li>
&lt;/ol>
&lt;p>なので、一回DepartmentのListをMapに変換して、さらにJoinedDatesのListに変換することとなります。ちょうど上記の分岐については、&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#compute-K-java.util.function.BiFunction-" target="_blank" rel="noopener"
>compute()&lt;/a>を活用するとできるので、中間データとしてのMapがどんな形になるかを考えると良いかなと思います。&lt;/p>
&lt;p>私の場合はMapの方がデータを取りやすいので、最終的には以下のような処理となりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;Department&amp;gt;.toJoinedDates(): List&amp;lt;JoinedDates&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 中間データ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> tempMap = mutableMapOf&amp;lt;Int, Map&amp;lt;DepartmentType, LocalDate&amp;gt;&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>.forEach { department &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Departmentのタイプとその日付のPair
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> departmentJoined = department.departmentType to department.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> department.employers.forEach { employer &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// EmployerのIDがKeyとして存在したら足して、なかったらMapを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> tempMap.compute(employer.id) { _, &lt;span style="color:#ff79c6">value&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">value&lt;/span>&lt;span style="color:#ff79c6">?.&lt;/span>let { &lt;span style="color:#ff79c6">value&lt;/span> + departmentJoined } &lt;span style="color:#ff79c6">?:&lt;/span> mapOf(departmentJoined)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 中間データをJoinedDatesのListに変えて返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> tempMap.map { (id, department) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JoinedDates(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employerId = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentA = department.getValue(&lt;span style="color:#50fa7b">DepartmentType&lt;/span>.A),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentB = department.getValue(&lt;span style="color:#50fa7b">DepartmentType&lt;/span>.B)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="共通ロジック化">共通ロジック化&lt;/h2>
&lt;p>ジェネリックを使ったclassとして上記のロジックを一部分離すれば、似たようなケースで色々使い回せるのではないかと思いましたので、以下のようなコードも書いてみました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Aggregator&lt;/span>&amp;lt;T, K, V, R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> tempMap = mutableMapOf&amp;lt;T, Map&amp;lt;K, V&amp;gt;&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// データの追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">add&lt;/span>(key: T, &lt;span style="color:#ff79c6">value&lt;/span>: Pair&amp;lt;K, V&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tempMap.compute(key) { _, existingValue &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> existingValue&lt;span style="color:#ff79c6">?.&lt;/span>let { existingValue + &lt;span style="color:#ff79c6">value&lt;/span> } &lt;span style="color:#ff79c6">?:&lt;/span> mapOf(&lt;span style="color:#ff79c6">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 指定したListとして取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getList&lt;/span>(transfer: (T, Map&amp;lt;K, V&amp;gt;) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R): List&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> tempMap.map { transfer(&lt;span style="color:#ff79c6">it&lt;/span>.key, &lt;span style="color:#ff79c6">it&lt;/span>.&lt;span style="color:#ff79c6">value&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これの場合は以下のような使い方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> aggregator = Aggregator&amp;lt;Int, DepartmentType, LocalDate, JoinedDates&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// データの追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>departments.forEach { a &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.employers.forEach { b &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aggregator.add(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = b.id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">value&lt;/span> = a.departmentType to a.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Listの結果を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> joinedDates = aggregator.getList { id, joinedDate &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JoinedDates(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employerId = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentA = joinedDate.getValue(&lt;span style="color:#50fa7b">DepartmentType&lt;/span>.A),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentB = joinedDate.getValue(&lt;span style="color:#50fa7b">DepartmentType&lt;/span>.B)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>汎用性はあるものの、呼び出し元のコードが増えたり、指定している型の意味や意図がよくわからないので適切なKDocやコメントがないと少しわかりにくいところがデメリットかも知れませんね。ただ大事なのは中間データの型と&lt;code>compute()&lt;/code>による分岐処理なので、そこだけをうまく取り出して他でも応用できるかなと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>サーバサイドKoltinだと、多くの場合にデータを&lt;code>List&lt;/code>として扱うのが普通かなと思いますが、場合によっては&lt;code>Map&lt;/code>を使うのもロジックを書いていく中では良い選択になるかと思います。特に、今回紹介した&lt;code>compute()&lt;/code>以外でも、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-or-put.html" target="_blank" rel="noopener"
>getOrPut()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/get-or-default.html" target="_blank" rel="noopener"
>getOrDefault()&lt;/a>などの機能が便利なので色々と活用できる場面が多いかなと思います。この処理は&lt;a class="link" href="../exposed-mapping-record-to-object" >前回のポスト&lt;/a>でも似たようなものを紹介したことがありますので、興味のある方はそちらも参考にしてください。&lt;/p>
&lt;p>プログラミング言語が提供するスタンダードライブラリは色々と見逃しやすいところがあるかなと思いますが、よくドキュメントや自動補完で一覧に登場する関数に注目すると、こういう風に必要なものがいきなり現れることもあるかと思います。まだ私もKotlinを触って1年ほどしか経ってないひよこなものなので、これからもどんどん新しい発見があると嬉しいなと思いますね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>個人的な2022年のロードマップ</title><link>https://retheviper.github.io/posts/my-roadmap-in-2022/</link><pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/my-roadmap-in-2022/</guid><description>&lt;img src="https://retheviper.github.io/images/map.jpg" alt="Featured image of post 個人的な2022年のロードマップ" />&lt;p>このブログを書き始めてから、今年で4年目となります。振り返ってみるとブログを書き始めた頃はSEとして主にSIerの基盤チームの仕事をしていたので、インフラやライブラリを含めさまざまな技術に触れることが多かったのですが、去年に転職をして本格的に業務系エンジニアとしてバックエンドを担当することになり触れる技術や興味などにも変化があったかなと思います。なので、今回は振り返りを兼ねて今年のロードマップに関して少し述べたいと思います。&lt;/p>
&lt;p>過去分のポストを振り返ってみると最初は主にJava、Spring、Linux、Jenkinsなどに関するものが多かったのですが、最近はやはりKotlinで使えるさまざまなフレームワークなどに興味が移っている感覚です。基本的にJavaでもKotlinでもJVM言語であることは同じなのでできることや分野は大差なく、転職してからも使っているフレームワークはSpringなのですが、Kotlinの開発元であるJetBrains社がいろいろなフレームワークを開発しているのもあり自然にそれらに興味を持つようになっていますね。&lt;/p>
&lt;h2 id="sophomore-jinxを克服する">Sophomore jinxを克服する&lt;/h2>
&lt;p>Sophomore jinxは日本語で「2年目のジンクス」といわれている言葉です。大学2年目になると新入生だった頃と比べ、成績が下がり熱意が消えるというということを指す言葉らしいです。これの意味を拡張して、1年目に新人王などに選ばれた選手がその次の年からは成績が悪化したり、人気の映画の続編が面白くなかったりする場合など最初より何か劣化した場合を指すことになっているとか。&lt;/p>
&lt;p>自分の場合はエンジニアになってから4年目になるのですが、確かに2年目からは1年目の時と比べ熱意はなくなっている気がします。だからと言って新しい技術に興味がなくなったり、プログラミング自体が飽きたという訳ではありませんが、前はやりたいことがあったらずっとモニタと睨めっこしながら徹夜でコードを書いたりしていたのに、今はとてもそういう気にならないというのが違うところですね。年を取ったためかとも思いますが、&lt;/p>
&lt;p>これについては自己分析とやりたいこと、そしてできることを冷静に整理して少しづつでも何か成果物を出せるようにしないと思っています。去年もそうでしたが、このようなポストを書くのはそのためでもあります。計画しているもの全てを成せるとは思いませんが、多くの目標の一部でも達成した方が最初から少ない数の目標を立てるよりは良いのかなという気がしています。なので、まずは「やるかどうかわからないけどアンテナは張っておく」という感覚でいろいろな技術に目を通しておこうかなと思っています。&lt;/p>
&lt;h2 id="frontend">Frontend&lt;/h2>
&lt;p>私はJavaScriptとTypeScriptの基礎を研修やUdemyの講座で学んだくらいのレベルで、フロントエンドの仕事をあまりやることがなかったです。しかし、昨今のウェブアプリの開発においてのトレンドをみるとやはりフロントエンドの技術を一つは学んでおいた方が良さげな気もしますし、バックエンドの役割を吸収しているような気配すらするなという気がしますね。何より、エンドユーザにとって画面のないアプリは想像できないので、今まで自分が使うためのAPIやライブラリ、コマンドラインアプリだけでなく本格的にGUIを活用した何かを作ってみるべき時が来たかなと思っています。&lt;/p>
&lt;p>何よりフロントエンドの場合、数年前はいろいろなライブラリとフレームワークが存在してどれを使った方がいいか全くわからない状況でしたが、最近は3強だといわれていた中でもAngularを抜いたReactとVueのみが生き残り、さらにそれらを基盤にしたフレームワークが登場するなど、そろそろ技術の成熟期と言ってもいい時代になったのではないかと思いますので、React基盤の&lt;a class="link" href="https://nextjs.org" target="_blank" rel="noopener"
>Next.js&lt;/a>か、Vue基盤の&lt;a class="link" href="https://nuxtjs.org" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>のどちらかを選べばよい時期なのではと思います。私自身も今年はそのうちのどちらかに触れてみたいなと思っています。&lt;/p>
&lt;p>せっかくなので&lt;a class="link" href="https://nestjs.com" target="_blank" rel="noopener"
>NestJS&lt;/a>のようなJavaScript用のサーバサイドフレームワークにも触れてみるのは良いかも知れませんが、サーバサイドというバックグラウンドがある自分にとってはまずはフロントエンドのみでちょうどよいチャレンジかなと思ったりもします。後述しますが、バックエンドではまた別に触ってみたいものもありますのでなおさらですね。&lt;/p>
&lt;h2 id="quarkus">Quarkus&lt;/h2>
&lt;p>個人的にはSpringを長く使っていたので、新しいフレームワークを使ってみたいという願望があります。一つのフレームワークに慣れると、それを使い続けるのも選択肢としては悪くないと思いますが、新しい技術にはメリットもデメリットもあるものなので、少なくとも触れてみる必要はあるかなと思います。なので去年は&lt;a class="link" href="https://quarkus.io" target="_blank" rel="noopener"
>Quarkus&lt;/a>と&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>Ktor&lt;/a>の二つを触ってみました。&lt;/p>
&lt;p>個人的にはJetBrainsのプロダクトに信用を持っていて、Kotlin向けという点でもKtorは悪くなかったと思ったのですが、機能が不十分であるところや、アーキテクチャで悩ましいところがあるという面で躊躇しています。一方でQuarkusはネイティブにコンパイルでき、Springのライブラリを一部そのまま使えたり、そもそもSpringとあまり変わらない感覚でコードをサクサク書けそうなイメージなので本格的に使用してみたいと思っています。最大の問題はやはり、ネイティブの場合ビルドにかなり時間がかかるということですが、これはCIとの連携をうまくやっていくしかないかも知れませんね。&lt;/p>
&lt;h2 id="fastapi">FastAPI&lt;/h2>
&lt;p>いきなりPythonになりますが、&lt;a class="link" href="https://fastapi.tiangolo.com" target="_blank" rel="noopener"
>FastAPI&lt;/a>にも触れてみたいと思っています。以前から違う分野に転職をするとしてもバックエンドはやり続く可能性が高いと思い、いろいろな言語とフレームワークを触ってみたいと思っていました。その候補としては&lt;a class="link" href="https://expressjs.com/ja" target="_blank" rel="noopener"
>Express&lt;/a>、&lt;a class="link" href="https://rocket.rs" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://vapor.codes" target="_blank" rel="noopener"
>Vapor&lt;/a>などがあって、これらを全部触ってみた後、最も自分の好みに合ったものをプライベートで使い続けようと思っていたのです。&lt;/p>
&lt;p>そんな中、Pythonは普段もたまに簡単な自動化のスクリプトを作るなどの目的で使っているので、&lt;a class="link" href="https://www.djangoproject.com" target="_blank" rel="noopener"
>Django&lt;/a>を触ってみようかと思っていたところ、最近はFastAPIで爆速の開発ができるという話を聞いて興味を持つようになりました。今もKotlinとSpringで開発はできますが、シンプルなプロジェクトならこういった軽いオプションが一つあっても悪くなさそうな気がします。インタープリタ言語なので起動も早く、&lt;a class="link" href="https://www.techempower.com/benchmarks" target="_blank" rel="noopener"
>Techempowerのベンチマーク&lt;/a>でも意外と悪くないパフォーマンスを見せてくれているのも魅力的ですが、&lt;a class="link" href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener"
>Swagger&lt;/a>と&lt;a class="link" href="https://github.com/Redocly/redoc" target="_blank" rel="noopener"
>ReDoc&lt;/a>によるドキュメンテーションが自動で行われるというところがかなり良さげです。なんでもサクッと作れそうな感じがしますね。&lt;/p>
&lt;p>また、直接使わないとしてもコードが綺麗で勉強になる噂を聞いているので、少なくとも一度はコードを読んでみたくなります。&lt;/p>
&lt;h2 id="swiftui-and-jetpack-compose">SwiftUI and Jetpack Compose&lt;/h2>
&lt;p>個人的に本当にやりたかった分野は、GUIを持つアプリを作り上げることです。エンジニアという職業を持つ前から作ったのも&lt;a class="link" href="https://openjfx.io" target="_blank" rel="noopener"
>JavaFX&lt;/a>によるデスクトップアプリでしたので。最近はJavaScriptだけでも&lt;a class="link" href="https://www.electronjs.org" target="_blank" rel="noopener"
>Electron&lt;/a>や&lt;a class="link" href="https://reactnative.dev" target="_blank" rel="noopener"
>React Native&lt;/a>などを使ってなんでもできるという時代にはなっていますが、せっかくJavaとKotlinができるようになったので、ネイティブアプリを作ってみた方が良さそうな気がします。&lt;/p>
&lt;p>以前&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>が発表されてまもない時期に、一度React Nativeと一緒にチュートリアルだけ触れてみたことがあるのですが、当時にもFlutterのいわゆる「宣言型GUI」というものに魅力を感じていたのでこれからモバイルをやるとしたらFlutterかなと悩んでいました。最近はモバイルだけでなく、デスクトップアプリやウェブアプリまで作れるようになったのでなおさらでしたね。&lt;/p>
&lt;p>しかし、&lt;a class="link" href="https://developer.apple.com/xcode/swiftui" target="_blank" rel="noopener"
>SwiftUI&lt;/a>と&lt;a class="link" href="https://developer.android.com/jetpack/compose?hl=ja" target="_blank" rel="noopener"
>Jetpack Compose&lt;/a>というものが登場してからは完全にこちらに傾きました。どうしても同時にマルチプラットフォームアプリが開発できるという面ではFlutterが有利だとは思いますが、それと似たような感覚でネイティブのUIが作れられるようになったのでもう悩む必要がないかなという気がします。&lt;/p>
&lt;p>特に、SwiftUIだとMac用のデスクトップアプリを作ることもできますが、Jetpack Composeならデスクトップアプリだけでなくウェブアプリも作ることができて、さらに&lt;a class="link" href="https://kotlinlang.org/docs/kmm-getting-started.html" target="_blank" rel="noopener"
>Kotlin Multiplatform Mobile&lt;/a>を使うとビジネスロジックの共有ができるようになるのでこちらの方が自分の場合にはより合うのではないかという気がしています。自分に合うというのは、私がめんどくさがり屋なので一つの言語で全てを解決したいという願望を持っているというだけの話ですが…とにかく一度使ってみて、よかったらフロントエンドでもJetpack Composeを使ってみるのはありかなと思っています。&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>という選択肢もありますが、こちらはまた次の機会で。&lt;/p>
&lt;p>ただこれらのデメリットは、やはりどれもまだ完成されてない技術ということですね。分野を問わず新しい技術のジレンマでもありますが、新技術がどれだけ良くてもそれだけでは完全ではない（もしくはかなり不便）という場面が出てくる可能性があるので、当面は少し様子を見ながらシンプルなアプリを作ってみることから初めてみようと思います。Flutterという良い先例があるので、良さげな機能はすぐに吸収してくれるという期待もあります。&lt;/p>
&lt;h2 id="oracle-cloud">Oracle Cloud&lt;/h2>
&lt;p>他のクラウドと比べかなり後発したためか、無料プランでもメモリ1GBのVMインスタンスを二つも提供するという破格の政策で知られたOracle Clouですが、2021年からはさらに選べるVMインスタンスにARM（&lt;a class="link" href="https://www.oracle.com/jp/cloud/compute/arm" target="_blank" rel="noopener"
>Ampere A1&lt;/a>というオプションを追加しています。&lt;/p>
&lt;p>Ampereが既存のAMDやIntel製CPUを使うインスタンスと比べて目立つのはやはり性能です。ARMだと互換性の問題がありx86と比べ利用率が下がると思ったためか、無料プランでも4つのOCPU、24GBのメモリという良い性能のインスタンスを提供しています。無料のインスタンスを2つまで作ることができるので、2つのOCPUと12GBのメモリという構成を2つのインスタンスに分けて指定することもできます。&lt;/p>
&lt;p>個人的には既存の無料で使えるインスタンスが1つのOCPU、1GBのメモリというオプションだったので、Javaアプリのビルドなどヘビーな作業には向いてないのが惜しいところでした。なので&lt;a class="link" href="https://mattermost.com" target="_blank" rel="noopener"
>Mattermost&lt;/a>のサーバとして使うなど軽い感じでしか使い道がなかったのですが、Ampereの導入でCI用サーバなどに使える道もできたかなと思います。Oracle Cloudのホームページで紹介していること以外でも、他の&lt;a class="link" href="https://jiuyu.medium.com/oracle-cloud-ampere-a1-cpu-benchmarks-6464ef43593d" target="_blank" rel="noopener"
>ベンチマーク&lt;/a>を参照するとCPU性能は期待しても良さそうな気がします。無料でOracle DBも提供されているのでそちらを使うか、それともVMインスタンスを一つDB用に使うか、GCPやAWSの無料サービスと組み合わせて使うとかでも色々できそうな気がします。&lt;/p>
&lt;p>ただ、やはり互換性が気になっていたのですが、個人的にはApple Silicon搭載Macを使ってみながら「意外と悪くない」という結論に至っています。プログラミング言語などはすでにARM対応済みのものが多く、サーバで使うとしたら&lt;a class="link" href="https://www.ffmpeg.org" target="_blank" rel="noopener"
>FFmpeg&lt;/a>、&lt;a class="link" href="https://imagemagick.org/index.php" target="_blank" rel="noopener"
>ImageMagick&lt;/a>、&lt;a class="link" href="http://www.graphicsmagick.org" target="_blank" rel="noopener"
>GraphicsMagick&lt;/a>などを使うケースもあるかなと思いますが、どれもARMバージョンをインストールもしくはビルドできるので特に問題はなさそうです。&lt;/p>
&lt;p>他に問題なら、今の所VMインスタンスを作ろうとしてもハードウェアが十分ではないのか、2つのOCPU以上のスペックでは作れないというのが問題ですね。時間が解決してくれる問題かも知れませんが、いつになったらインスタンスを自由に作れるかわからないというのは確かに問題と言えるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>意欲がないといいつつ、これだけやってみたいものが多いというのはまだ自分がエンジニアとして気持ちが死んでいるわけではないからよかったなと思わせます。本当は意欲がないというより「面倒臭いだけ」と訂正するべきかもですね…&lt;/p>
&lt;p>というわけで、色々とやりたいことだけを並べてみましたが、今年はそろそろ何か実際使えるアプリを作り出すのを第一の目標にしたいと思っています。何か作ってみるだけでも間違いなく良い経験、良い経歴になるはずなので。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで和暦を使う</title><link>https://retheviper.github.io/posts/kotlin-japanese-era/</link><pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-japanese-era/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで和暦を使う" />&lt;p>帳票などで、たまに和暦を処理する必要な時がありますね。例えば元号を表記するとか、和暦の年度を表記するなどの場合があるかと思います。Kotlin(JVM)の場合、西暦だとJavaのAPIの&lt;code>Date&lt;/code>や&lt;code>LocalDate&lt;/code>などのAPIを使うと簡単ですが、和暦が必要となるのはごく一部のケースなので方法がなかなか分かりづらいかと思います。なので、今回はKotlinで和暦を扱う方法について少しまとめてみました。&lt;/p>
&lt;h2 id="japanseera--japanesedate">JapanseEra / JapaneseDate&lt;/h2>
&lt;p>Javaでは、1.8から和暦で日付を扱える&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseDate.html" target="_blank" rel="noopener"
>JapaneseDate&lt;/a>及び元号を扱える&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseEra.html" target="_blank" rel="noopener"
>JapaneseEra&lt;/a>というAPIを提供しています。なので&lt;code>JapaneseDate&lt;/code>のインスタンスを作り、そこから&lt;code>JapaneseEra&lt;/code>を取得することで簡単に元号の情報を取得できるようになります。実際の使い方は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 現在日付のJapaneseDateを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> japaneseDate = &lt;span style="color:#50fa7b">JapaneseDate&lt;/span>.now()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// JapaneseEraの取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> japaneseEra = japaneseDate.era
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>JapaneseDate&lt;/code>の場合、&lt;code>LocalDate&lt;/code>と同じく&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/chrono/ChronoLocalDate.html" target="_blank" rel="noopener"
>ChronoLocalDate&lt;/a>を継承しているのでインスタンスを作成する方法はそう変わりません。なので、以下のようなこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// LocalDateをJapaneseDateに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> japaneseDateFromLocalDate = &lt;span style="color:#50fa7b">JapaneseDate&lt;/span>.from(&lt;span style="color:#50fa7b">LocalDate&lt;/span>.now())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 特定の日付を指定してJapaneseDate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> japaneseDateFromSpecificDate = &lt;span style="color:#50fa7b">JapaneseDate&lt;/span>.of(&lt;span style="color:#bd93f9">2000&lt;/span>, &lt;span style="color:#bd93f9">12&lt;/span>, &lt;span style="color:#bd93f9">31&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="元号を日本語で表記する">元号を日本語で表記する&lt;/h2>
&lt;p>和暦を扱う場合にやりたいことは大きく二つかと思います。一つは、元号を文字列として扱うこと、そしてもう一つは、和暦での年度を数字として扱うことです。まずは、元号を文字列として取得できる方法について説明します。&lt;/p>
&lt;p>まず上記で紹介した通り、&lt;code>JapaneseDate&lt;/code>のインスタンスを取得した上で、さらにそのオブジェクトが保持している&lt;code>JapaneseEra&lt;/code>を取得する必要があります。その後、&lt;code>JapaneseEra.getDisplayName()&lt;/code>という関数に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/TextStyle.html" target="_blank" rel="noopener"
>TextStyle&lt;/a>と&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/Locale.html" target="_blank" rel="noopener"
>Locale&lt;/a>を指定して文字列を取得することができます。前者は文字の出力型を指定する列挙型定数で、後者は言語の指定と思ってください。&lt;/p>
&lt;p>&lt;code>TextStyle&lt;/code>の場合、以下のような値があります。他の言語だと指定したものによって出力がかなり変わってくるかも知れませんが、日本語の場合は&lt;code>FULL&lt;/code>と&lt;code>NARROW&lt;/code>だけで十分ではないかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>定数&lt;/th>
&lt;th>出力例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>FULL&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>FULL_STANDALONE&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>NARROW&lt;/code>&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>NARROW_STANDALONE&lt;/code>&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SHORT&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SHORT_STANDALONE&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>Locale&lt;/code>の場合、&lt;code>Locale.JAPAN&lt;/code>や&lt;code>Locale.JAPANESE&lt;/code>のどちらを指定しても結果は同じです。ただ、実装としては以下のようになるのでなるべく&lt;code>Locale.JAPAN&lt;/code>を使った方が良さそうです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Locale&lt;/th>
&lt;th>作られるBaseLocaleの設定&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>JAPAN&lt;/code>&lt;/td>
&lt;td>&lt;code>language = ja, region = JP&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>JAPANESE&lt;/code>&lt;/td>
&lt;td>&lt;code>language = ja&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以下はこれらの定数を渡して元号を文字列として取得する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> today = &lt;span style="color:#50fa7b">JapaneseDate&lt;/span>.now()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> era = today.era
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 元号を漢字で取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> eraName = era.getDisplayName(&lt;span style="color:#50fa7b">TextStyle&lt;/span>.FULL, &lt;span style="color:#50fa7b">Locale&lt;/span>.JAPAN) &lt;span style="color:#6272a4">// 令和
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元号だけでなく、年度までも合わせて表記したい場合もあるかと思います。その場合に使えるものは&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>です。これも&lt;code>JapaneseDate&lt;/code>が実質&lt;code>LocalDate&lt;/code>と同じく&lt;code>ChronoLocalDate&lt;/code>を継承しているから可能なことですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 日付を日本語で表記する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> formatter = &lt;span style="color:#50fa7b">DateTimeFormatter&lt;/span>.ofPattern(&lt;span style="color:#f1fa8c">&amp;#34;Gy年&amp;#34;&lt;/span>, &lt;span style="color:#50fa7b">Locale&lt;/span>.JAPAN)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> todayString = formatter.format(&lt;span style="color:#50fa7b">JapaneseDate&lt;/span>.now()) &lt;span style="color:#6272a4">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしJava 1.8以前のバージョンを使うなどで&lt;code>LocalDate&lt;/code>や&lt;code>JapaneseDate&lt;/code>が使えなく、&lt;code>java.util.Date&lt;/code>の方を使うしかない場合は、以下のような方法で年号と年度の取得が可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> format = SimpleDateFormat(&lt;span style="color:#f1fa8c">&amp;#34;Gy年&amp;#34;&lt;/span>, Locale(&lt;span style="color:#f1fa8c">&amp;#34;Ja&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;JP&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;JP&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> year = format.format(Date()) &lt;span style="color:#6272a4">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>java.util.Date&lt;/code>を使う場合は、&lt;code>Locale&lt;/code>に第3引数の&lt;code>variant&lt;/code>まで指定する必要があるので、既存の列挙型として定義されたものは使えません。&lt;/p>
&lt;p>また、&lt;code>Locale.ENGLISH&lt;/code>などに設定すると、&lt;code>JapaenseDate&lt;/code>を使っている場合でも取得した結果は&lt;code>AD2021年12月5日&lt;/code>になります。&lt;/p>
&lt;h3 id="合字で表記する">合字で表記する&lt;/h3>
&lt;p>年号については、Unicodeで合字を取得して使いたい場合もあるかと思います。その場合は、以下のようにUnicodeのMapなどを定義しておいて取得するのが良いかと思います。拡張関数などを定義するのも良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> eraUnicodeMap = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">JapaneseEra&lt;/span>.MEIJI to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u337e&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#6272a4">// ㍾
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#50fa7b">JapaneseEra&lt;/span>.TAISHO to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u337d&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#6272a4">// ㍽
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#50fa7b">JapaneseEra&lt;/span>.SHOWA to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u337c&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#6272a4">// ㍼
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#50fa7b">JapaneseEra&lt;/span>.HEISEI to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u337b&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#6272a4">// ㍻
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#50fa7b">JapaneseEra&lt;/span>.REIWA to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u32ff&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &lt;span style="color:#6272a4">// ㋿
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> era = &lt;span style="color:#50fa7b">JapaneseDate&lt;/span>.now().era
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 元号を合字で取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> eraUnicode = eraUnicodeMap[era] &lt;span style="color:#6272a4">// ㋿
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のサンプルでは&lt;code>JapaneseEra&lt;/code>が列挙型なのでそのままキーとしていますが、&lt;code>JapaneseEra&lt;/code>は数値としての情報も持っているのでそちらを使う方法もあるでしょう。それぞれの値に対する数値は以下の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>JapaneseEra&lt;/th>
&lt;th>数値&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MEIJI&lt;/td>
&lt;td>-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TAISHO&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SHOWA&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HEISEI&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>REIWA&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>2021年から2022年の3月の場合は令和3年なので、&lt;code>JapaneseEra.REIWA.value&lt;/code>の値が年度だと勘違いされやすいかなと思います。実際の年度の情報は&lt;code>JapaneseDate&lt;/code>の方にあるので注意しましょう。&lt;/p>
&lt;h2 id="年度を数字で表示する">年度を数字で表示する&lt;/h2>
&lt;p>&lt;code>JapaneseEra&lt;/code>は元号を得るために使う列挙型定数のクラスなので、これ自体は&lt;code>JapaneseDate&lt;/code>の日付情報を持っていません。なので参照できる情報は、あくまでも元となる&lt;code>JapaneseDate&lt;/code>が属した元号の情報のみです。&lt;/p>
&lt;p>なので数値としての年度は、列挙型の&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/temporal/ChronoField.html" target="_blank" rel="noopener"
>ChronoField&lt;/a>を&lt;code>JapaneseDate.get()&lt;/code>に渡して取得する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> today = &lt;span style="color:#50fa7b">JapaneseDate&lt;/span>.of(&lt;span style="color:#bd93f9">2010&lt;/span>, &lt;span style="color:#bd93f9">12&lt;/span>, &lt;span style="color:#bd93f9">31&lt;/span>) &lt;span style="color:#6272a4">// 平成22年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 年度をIntとして取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> year = today.&lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#50fa7b">ChronoField&lt;/span>.YEAR) &lt;span style="color:#6272a4">// 2010
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> yearOfHeisei = today.&lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#50fa7b">ChronoField&lt;/span>.YEAR_OF_ERA) &lt;span style="color:#6272a4">// 22
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは&lt;code>JapaneseDate&lt;/code>が&lt;code>LocalDate&lt;/code>と違って、直接&lt;code>year&lt;/code>をgetterで取得できないからです。実際オブジェクトの中を覗いてみると、&lt;code>LocalDate&lt;/code>は年月日をintとshortのフィールドとして保持していることに対して、&lt;code>JapaneseDate&lt;/code>は&lt;code>LocalDate&lt;/code>とint型の&lt;code>yearOfEra&lt;/code>を持っていて、&lt;code>get(ChronoField.YEAR_OF_ERA)&lt;/code>を通じてはじめて&lt;code>yearOfEra&lt;/code>を取得できることになります。getterを用意していないのはおそらく&lt;code>LocalDate&lt;/code>と&lt;code>yearOfEra&lt;/code>という二つの概念があるからなのではないかと思います。もちろん、Kotlinなのでこれは簡単に拡張関数を書くことでgetterを作ることはできますね。&lt;/p>
&lt;p>また、日付のオブジェクトとして&lt;code>LocalDate&lt;/code>を使っている場合は場合は&lt;code>ChronoField.YEAR_OF_ERA&lt;/code>を渡しても西暦の年度が返ってくるので、和暦を使うために&lt;code>JapaneseDate&lt;/code>を使っているかどうかをまず確認しましょう。&lt;/p>
&lt;h3 id="年度を2桁の文字で表示する">年度を2桁の文字で表示する&lt;/h3>
&lt;p>厳密に言って和暦とは関係のないことですが、年度を取得して使う場合、一貫して先端に「0」のついた2桁の文字列として扱いたい場合もあるかと思います。&lt;code>JapaneseDate&lt;/code>を通じて年度を取得した場合は&lt;code>Int&lt;/code>型になるので、1〜9の間は1桁の数字となるわけですが、これを01〜09に表示したい場合は以下の方法が使えます。&lt;/p>
&lt;h4 id="decimalformatを利用する">DecimalFormatを利用する&lt;/h4>
&lt;p>一つは、JavaのAPIである&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/text/DecimalFormat.html" target="_blank" rel="noopener"
>DecimalFormat&lt;/a>を使うことです。小数点の範囲などをわかりやすく指定できるので個人的には好むやり方です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> today = &lt;span style="color:#50fa7b">JapaneseDate&lt;/span>.now() &lt;span style="color:#6272a4">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 数字を表示するためのフォーマットを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> decimalFormat = DecimalFormat(&lt;span style="color:#f1fa8c">&amp;#34;00&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> year = decimalFormat.format(today) &lt;span style="color:#6272a4">// 03
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="stringformatを利用する">String.formatを利用する&lt;/h4>
&lt;p>もう一つの方法は、Kotlinのスタンダードライブラリの機能である&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/format.html" target="_blank" rel="noopener"
>String.format()&lt;/a>を使うことです。性能注視なら、こちらの方法が良いかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> today = &lt;span style="color:#50fa7b">JapaneseDate&lt;/span>.now() &lt;span style="color:#6272a4">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 数字を表示するためのフォーマットを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> year = &lt;span style="color:#f1fa8c">&amp;#34;%02d&amp;#34;&lt;/span>.format(today) &lt;span style="color:#6272a4">// 03
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="番外kotlinx-datetime">番外：kotlinx-datetime&lt;/h2>
&lt;p>Kotlinには元々日付や時間を扱うAPIがなかったのですが、2020年から&lt;a class="link" href="https://github.com/Kotlin/kotlinx-datetime" target="_blank" rel="noopener"
>kotlinx-datetime&lt;/a>を提供しています。なのでKotlin/JSやKotlin/Nativeなど、JVM上で動かない場合でも日付を扱える公式のAPIができたわけですが、いくつかの懸念があるのでこれを導入するには検討が必要かと思います。&lt;/p>
&lt;h3 id="pre-releaseの段階">Pre-releaseの段階&lt;/h3>
&lt;p>&lt;code>kotlinx-datetime&lt;/code>はまだpre-releaseの段階で、2021年10月に&lt;code>v0.3.1&lt;/code>がリリースされています。なので色々とバグがあったり、思い通りにならない可能性があります。また、開発途中のものなので仕方ありませんが、現時点で提供している機能も&lt;code>java.time&lt;/code>のAPIに比べて少なく、簡単に年号の計算などができるわけではありません。今は必要最低限の機能だけを提供していると思って良いでしょう。&lt;/p>
&lt;h3 id="マルチプラットフォーム向け">マルチプラットフォーム向け&lt;/h3>
&lt;p>Kotlinのスタンダードライブラリ、及び&lt;code>kotlinx&lt;/code>として提供されるライブラリはマルチプラットホームを考慮した実装となっているため、プラットホームが違っても同じ使い方ができるというメリットがありますが、かえってデメリットになる場合もあります。実際、&lt;code>kotlinx-datetime&lt;/code>のJVMの実装は内部的に&lt;code>jata.time&lt;/code>のAPIに依存しているため、JVMだけを使う場合はあえて導入する必要がないともいえます。&lt;/p>
&lt;p>また、プラットフォームごとに実装が違うということはどこかで予期せぬ例外が発生したり、期待した結果にならないケースも発生しえる、ということにもなるかと思います。&lt;/p>
&lt;h2 id="javatimeの懸念">java.timeの懸念&lt;/h2>
&lt;p>&lt;code>JapaneseEra&lt;/code>では明治以前（慶応など）の元号は使えませんが、おそらくその理由は和暦でグレゴリウス暦が使われたのは明治からだったという歴史的な背景があるのではないかと思います。また、&lt;code>JapaneseDate&lt;/code>でも明治6年(西暦1873年1月1日)以前の日付を指定すると以下のように例外が発生します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Exception in thread &lt;span style="color:#f1fa8c">&amp;#34;main&amp;#34;&lt;/span> java.time.DateTimeException: JapaneseDate before Meiji &lt;span style="color:#bd93f9">6&lt;/span> is not supported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at java.base/java.time.chrono.JapaneseDate.&amp;lt;init&amp;gt;&lt;span style="color:#ff79c6">(&lt;/span>JapaneseDate.java:333&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at java.base/java.time.chrono.JapaneseDate.of&lt;span style="color:#ff79c6">(&lt;/span>JapaneseDate.java:257&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、単純に帳票を作るなどのケースでなく、歴史的な研究のための日付計算ではここで紹介した方法は使えないケースもあるかと思います。&lt;/p>
&lt;p>また、JDKのバージョンなどの問題があるためか、&lt;code>JapaneseEra.REIWA&lt;/code>の取得ができなく、エラーとなるケースがあるので注意する必要があります。この場合でも&lt;code>value&lt;/code>の値の取得は問題ないので、少し可読性は低下しながら分岐などの判定に定数をそのまま使うのは避けたほうが良さそうです。（正確な理由はわかりませんが…）&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。少し興味本位で調べ始めたもののまとめではありますが、本業の方で実際に必要な処理でもあり、これをどうやって拡張関数として落とせるかということも考えられる良い機会となったかなと思っています。&lt;/p>
&lt;p>また、JavaのAPIに関しては&lt;a class="link" href="https://qiita.com/yamadamn/items/56e7370bae2ceaec55d5" target="_blank" rel="noopener"
>Javaバージョン別の改元(新元号)対応まとめ&lt;/a>という良い記事があったので、興味のある方はご一読ください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその３</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-3/</link><pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-3/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinの隠されたコストーその３" />&lt;p>Kotlinの隠されたコスト、その最後の記事となります。今までの記事もかなり興味深かったですが、今回はさらにKotlinならではの機能に触れているので、Kotlinそのものに対する理解も含めてみる必要があり、さらに深い内容となっているかと思います。&lt;/p>
&lt;p>今回のアジェンダは、「委譲プロパティ」と「rangeを使ったループ」になります。この記事は&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-3-3bf6e0dbf0a4" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 3&lt;/a>の内容を要約したものです。&lt;/p>
&lt;h2 id="委譲プロパティ">委譲プロパティ&lt;/h2>
&lt;p>&lt;a class="link" href="https://kotlinlang.org/docs/delegated-properties.html" target="_blank" rel="noopener"
>委譲プロパティ&lt;/a>とは、&lt;code>getter&lt;/code>と&lt;code>setter&lt;/code>が&lt;code>委譲(delegate)&lt;/code>というオブジェクトによって実装された&lt;a class="link" href="https://kotlinlang.org/docs/properties.html" target="_blank" rel="noopener"
>プロパティ&lt;/a>を指します。これによって再利用可能なカスタムプロパティを作ることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> p: String &lt;span style="color:#ff79c6">by&lt;/span> Delegate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>委譲オブジェクトはプロパティの設定と読み込みのため&lt;code>getValue()&lt;/code>と&lt;code>setValue()&lt;/code>を実装する必要があります。そしてこれらの関数はプロパティのメタデータ（プロパティ名）とオブジェクトのインスタンスを引数として必要とします。&lt;/p>
&lt;p>クラスが委譲プロパティとして定義されると、コンパイラは下記のようなコードを生成します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Example&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @NotNull
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Delegate p$delegate &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Delegate&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// $FF: 生成されたフィールド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> KProperty&lt;span style="color:#ff79c6">[]&lt;/span> $$delegatedProperties &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> KProperty&lt;span style="color:#ff79c6">[]{(&lt;/span>KProperty&lt;span style="color:#ff79c6">)&lt;/span>Reflection&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">mutableProperty1&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> MutablePropertyReference1Impl&lt;span style="color:#ff79c6">(&lt;/span>Reflection&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getOrCreateKotlinClass&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Example&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;p&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;getP()Ljava/lang/String;&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">))};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @NotNull
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String &lt;span style="color:#50fa7b">getP&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">p$delegate&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getValue&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> $$delegatedProperties&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">setP&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>@NotNull String var1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">checkParameterIsNotNull&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>var1&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;lt;set-?&amp;gt;&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">p$delegate&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">setValue&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> $$delegatedProperties&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">],&lt;/span> var1&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一部staticプロパティのメタデータがクラスに追加されます。そして毎回値の設定と読み込みが発生するたびにコンストラクタによる初期化が起こります。&lt;/p>
&lt;h3 id="委譲インスタンス">委譲インスタンス&lt;/h3>
&lt;p>上記サンプルでは新しい委譲のインスタンスがプロパティの実装のため生成されています。委譲がstatefulの場合にこのようになります。たとえはローカルで計算されたプロパティを使うなどの場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">StringDelegate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> cache: String? = &lt;span style="color:#ff79c6">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">operator&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getValue&lt;/span>(thisRef: Any?, &lt;span style="color:#ff79c6">property&lt;/span>: KProperty&amp;lt;*&amp;gt;): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> result = cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (result &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = someOperation()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>またコンストラクタに追加のパラメータが渡されると、新しい委譲のインスタンスが必要となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> nameView &lt;span style="color:#ff79c6">by&lt;/span> BindViewDelegate&amp;lt;TextView&amp;gt;(&lt;span style="color:#50fa7b">R&lt;/span>.id.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>statelessであり、すでに渡されたオブジェクトのインスタンスとプロパティ名を保ちたいだけなら委譲クラスに&lt;code>object&lt;/code>をつけてsingletonにする方法があります。たとえば下記のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">object&lt;/span> &lt;span style="color:#50fa7b">FragmentDelegate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">operator&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getValue&lt;/span>(thisRef: Activity, &lt;span style="color:#ff79c6">property&lt;/span>: KProperty&amp;lt;*&amp;gt;): Fragment? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> thisRef.fragmentManager.findFragmentByTag(&lt;span style="color:#ff79c6">property&lt;/span>.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また既存のオブジェクトを拡張して委譲することもできます。つまり、&lt;code>getValue()&lt;/code>や&lt;code>setValue()&lt;/code>を拡張関数として定義することもできるということです。Kotlinではすでに&lt;code>Map&lt;/code>と&lt;code>MutableMap&lt;/code>に拡張関数として委譲するパターンを使っています。（プロパティ名をキーで使っています）&lt;/p>
&lt;p>もし一つのクラス内でローカルの委譲インスタンスに複数のプロパティを保持して再利用したいなら、そのクラスのコンストラクタでインスタンスを初期化しましょう。&lt;/p>
&lt;p>Kotlin 1.1以降、&lt;a class="link" href="https://kotlinlang.org/docs/delegated-properties.html#local-delegated-properties" target="_blank" rel="noopener"
>関数内のローカル変数を委譲プロパティにする&lt;/a>こともできます。この場合、委譲は後で初期化できます。&lt;/p>
&lt;p>クラスに定義された委譲プロパティごとにオーバーヘッドとメタデータの追加が発生するのでなるべくプロパティを再利用できるようにした方が良いでしょう。また、定義したい項目が多い場合に、果たして委譲プロパティが良い選択肢であるかを考慮すべきです。&lt;/p>
&lt;h3 id="ジェネリック委譲">ジェネリック委譲&lt;/h3>
&lt;p>委譲関数はジェネリックでも定義できます。なので委譲クラスをさまざまな型のプロパティとして定義することもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> maxDelay: Long &lt;span style="color:#ff79c6">by&lt;/span> SharedPreferencesDelegate&amp;lt;Long&amp;gt;()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記のようにprimitiveをジェネリック委譲を使う場合、&lt;code>boxing&lt;/code>と&lt;code>unboxing&lt;/code>が値の指定と読み込みで発生することに注意する必要があります。これはプロパティがnon-nullの場合でも起こることです。&lt;/p>
&lt;p>なのでnon-nullなprimitive型の委譲プロパティを定義する場合はジェネリックで定義を避けたほうが良いです。&lt;/p>
&lt;h3 id="スタンダード委譲lazy">スタンダード委譲（lazy()）&lt;/h3>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" target="_blank" rel="noopener"
>Delegates.notNull()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html" target="_blank" rel="noopener"
>Delegates.observable()&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html" target="_blank" rel="noopener"
>lazy()&lt;/a>のような委譲のための標準機能が存在しています。&lt;/p>
&lt;p>&lt;code>lazy()&lt;/code>は読み込み専用の委譲プロパティのための関数です。初めて読み込みが発生する際、プロパティを初期化するた目にlambdaを指定できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> dateFormat: DateFormat &lt;span style="color:#ff79c6">by&lt;/span> lazy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SimpleDateFormat(&lt;span style="color:#f1fa8c">&amp;#34;dd-MM-yyyy&amp;#34;&lt;/span>, &lt;span style="color:#50fa7b">Locale&lt;/span>.getDefault())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはその値が実際に読み込まれるまで高いコストの初期化を遅延させるという、パフォーマンスと可読性の側面で優れた方法です。&lt;/p>
&lt;p>ただ、&lt;code>lazy()&lt;/code>はinline関数ではなく、引数として渡されたlambdaは別の&lt;code>Function&lt;/code>クラスとしてコンパイルされ、戻り値の委譲オブジェクトもまたinline化されないことには注意する必要があります。&lt;/p>
&lt;p>そして&lt;code>lazy()&lt;/code>関数で見逃しやすいのは&lt;code>mode&lt;/code>という引数で戻り値の委譲タイプを決められるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">lazy&lt;/span>(initializer: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): Lazy&amp;lt;T&amp;gt; = SynchronizedLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">lazy&lt;/span>(mode: LazyThreadSafetyMode, initializer: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): Lazy&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">when&lt;/span> (mode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">LazyThreadSafetyMode&lt;/span>.SYNCHRONIZED &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> SynchronizedLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">LazyThreadSafetyMode&lt;/span>.PUBLICATION &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> SafePublicationLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">LazyThreadSafetyMode&lt;/span>.NONE &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> UnsafeLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mode&lt;/code>を指定していない場合、デフォルトとしては&lt;code>LazyThreadSafetyMode.SYNCHRONIZED&lt;/code>が使われますが、これは複数のスレッドで初期化ブロックが安全に実行されることを保証するためにコストの高い&lt;code>double-checked lock&lt;/code>を行います。&lt;/p>
&lt;p>シングルスレッドしかプロパティに対するアクセスがないというのがわかっているなら、無駄なロックは下げた方がいいでしょう。こういう場合は&lt;code>LazyThreadSafetyMode.NONE&lt;/code>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> dateFormat: DateFormat &lt;span style="color:#ff79c6">by&lt;/span> lazy(&lt;span style="color:#50fa7b">LazyThreadSafetyMode&lt;/span>.NONE) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SimpleDateFormat(&lt;span style="color:#f1fa8c">&amp;#34;dd-MM-yyyy&amp;#34;&lt;/span>, &lt;span style="color:#50fa7b">Locale&lt;/span>.getDefault())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ranges">Ranges&lt;/h2>
&lt;p>&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html" target="_blank" rel="noopener"
>Ranges&lt;/a>で限定された範囲の値のセットを定義できます。この値は&lt;code>Comparable&lt;/code>なものならなんでも指定できますね。そして、この表現式を使うと&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-closed-range/" target="_blank" rel="noopener"
>ClosedRange&lt;/a>というインタフェースの実装ができることになります。&lt;/p>
&lt;h3 id="包含テスト">包含テスト&lt;/h3>
&lt;p>rangeを使って範囲内に特定の値が含まれているかどうかを&lt;code>in&lt;/code>や&lt;code>!in&lt;/code>を使って検知することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rangeはnon-nullなprimitive型（&lt;code>Int&lt;/code>, &lt;code>Long&lt;/code>, &lt;code>Byte&lt;/code>, &lt;code>Short&lt;/code>, &lt;code>Float&lt;/code>, &lt;code>Double&lt;/code>, &lt;code>Char&lt;/code>）に対する最適化が行われるので、コンパイルされた結果は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> i &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、オーバーヘッドや追加オブジェクトの割り当てなどは起こらないです。しかし、primitiveではない場合はどうでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (name &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Alfred&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">..&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Alicia&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlin 1.1.50以前はコンパイル時に&lt;code>ClosedRange&lt;/code>オブジェクトが常に生成されました。しかし、1.1.50からは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span>(name.compareTo(&lt;span style="color:#f1fa8c">&amp;#34;Alfred&amp;#34;&lt;/span>) &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(name.compareTo(&lt;span style="color:#f1fa8c">&amp;#34;Alicia&amp;#34;&lt;/span>) &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">System&lt;/span>.&lt;span style="color:#ff79c6">out&lt;/span>.println(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rangeはまた、&lt;code>when&lt;/code>の条件式でも使えます。&lt;code>if-else&lt;/code>より可読性が良くなりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> message = &lt;span style="color:#ff79c6">when&lt;/span> (statusCode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">200.&lt;/span>.&lt;span style="color:#bd93f9">299&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;OK&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">300.&lt;/span>.&lt;span style="color:#bd93f9">399&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Find it somewhere else&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Oops&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、rangeを使う場合、特定の値が含まれているかどうかをチェックするとき、指定された範囲とそれを使うコードの間に間があるとコストがかかることになります。たとえば以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> myRange &lt;span style="color:#ff79c6">get&lt;/span>() = &lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">rangeTest&lt;/span>(i: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> myRange) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はコンパイルすると&lt;code>IntRange&lt;/code>オブジェクトが追加されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> IntRange &lt;span style="color:#50fa7b">getMyRange&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> IntRange&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">rangeTest&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getMyRange&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">contains&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">))&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはプロパティのgetterを&lt;code>inline&lt;/code>として定義しても同じです。なのでなるべくrangeが使われるテストの方に直接書くことでオブジェクトが追加されない要因した方が良いです。また、primitiveではないオブジェクトを使う場合は定数として定義し、&lt;code>ClosedRange&lt;/code>のインスタンスを再利用する方法があります。&lt;/p>
&lt;h3 id="forループ">forループ&lt;/h3>
&lt;p>&lt;code>Float&lt;/code>と&lt;code>Double&lt;/code>を除いたprimitive型の範囲をループで使うのも良い選択です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルされた結果にはオーバーヘッドが発生しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">byte&lt;/span> var2 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">11&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span> i &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> var2&lt;span style="color:#ff79c6">;&lt;/span> &lt;span style="color:#ff79c6">++&lt;/span>i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>逆順にループしたい場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/down-to.html" target="_blank" rel="noopener"
>downTo()&lt;/a>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span> downTo &lt;span style="color:#bd93f9">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これにもまた、オーバーヘッドは発生しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">byte&lt;/span> var1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">true&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i &lt;span style="color:#ff79c6">==&lt;/span> var1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">--&lt;/span>i&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/until.html" target="_blank" rel="noopener"
>until&lt;/a>を使って特定の値未満にループするのも良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> until size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前は少しコストがかかることになりましたが、Kotlin 1.1.4以降は以下のようなコードが生成されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> var2 &lt;span style="color:#ff79c6">=&lt;/span> size&lt;span style="color:#ff79c6">;&lt;/span> i &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> var2&lt;span style="color:#ff79c6">;&lt;/span> &lt;span style="color:#ff79c6">++&lt;/span>i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、そのほかは最適化があまり効いてないケースもあります。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/reversed.html" target="_blank" rel="noopener"
>reversed()&lt;/a>を使う例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> (&lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>).reversed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルされたコードがあまり綺麗とは言えません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>IntProgression var10000 = &lt;span style="color:#50fa7b">RangesKt&lt;/span>.reversed((IntProgression)(new IntRange(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int i = var10000.getFirst();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int var3 = var10000.getLast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int var4 = var10000.getStep();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span>(var4 &amp;gt; &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(i &amp;gt; var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span>(i &amp;lt; var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span>(&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">System&lt;/span>.&lt;span style="color:#ff79c6">out&lt;/span>.println(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(i &lt;span style="color:#ff79c6">==&lt;/span> var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#ff79c6">+=&lt;/span> var4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>IntRange&lt;/code>オブジェクトが範囲を再定義するため生成され、さらに&lt;code>IntProgression&lt;/code>オブジェクトが逆順に要素を整列するために生成されます。&lt;/p>
&lt;p>&lt;code>progression&lt;/code>を作るのに二つ以上の関数が使われていると、二つ以上のオブジェクトを作るようなオーバーヘッドが発生することになります。&lt;/p>
&lt;p>上記のルールは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/step.html" target="_blank" rel="noopener"
>step()&lt;/a>を使う場合も同じで、&lt;code>step 1&lt;/code>を指定しても状況は変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span> step &lt;span style="color:#bd93f9">2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに、生成されたコードで最後の値を読み込む時、&lt;code>IntProgression&lt;/code>オブジェクトの最後の要素と&lt;code>step()&lt;/code>で指定した範囲を考慮して追加の処理が行われます。上記のサンプルだと最後の要素は&lt;code>9&lt;/code>です。&lt;/p>
&lt;p>なので、&lt;code>for&lt;/code>を利用したループをするときはなるべく&lt;code>..&lt;/code>、&lt;code>downTo()&lt;/code>、&lt;code>until()&lt;/code>を利用してオーバーヘッドを避けた方が良いでしょう。&lt;/p>
&lt;h3 id="foreachループ">forEachループ&lt;/h3>
&lt;p>&lt;code>for&lt;/code>ループの代わりに、rangeに対してinline拡張関数の&lt;code>forEach()&lt;/code>を使う場合も結果はあまり変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>).forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#ff79c6">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、&lt;code>forEach()&lt;/code>は&lt;code>Iterable&lt;/code>に対してのみ最適化されてないです。これはつまり、iteratorを生成する必要があるということを意味します。なので、コンパイルされると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Iterable $receiver$iv &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>Iterable&lt;span style="color:#ff79c6">)(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> IntRange&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span>&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Iterator var1 &lt;span style="color:#ff79c6">=&lt;/span> $receiver$iv&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">iterator&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>var1&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">hasNext&lt;/span>&lt;span style="color:#ff79c6">())&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> element$iv &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">((&lt;/span>IntIterator&lt;span style="color:#ff79c6">)&lt;/span>var1&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">nextInt&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>element$iv&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは今までのサンプルよりもコストのかかるものです。&lt;code>IntRange&lt;/code>オブジェクトを生成するだけでなく、&lt;code>IntIterator&lt;/code>オブジェクトも生成しているからです。primitiveではない場合はさらにコストがかかるでしょう。&lt;/p>
&lt;p>なので、rangeを使ったループが必要な場合は&lt;code>forEach()&lt;/code>より&lt;code>for&lt;/code>ループを使ってオーバーヘッドを減らした方が良いです。&lt;/p>
&lt;h3 id="collectionインデックスループ">collectionインデックスループ&lt;/h3>
&lt;p>Kotlinのスタンダードライブラリは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/indices.html" target="_blank" rel="noopener"
>indices&lt;/a>という拡張プロパティで配列と&lt;code>Collection&lt;/code>のインテックスを提供します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> list.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(list[i])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>indices&lt;/code>のコンパイルされた結果は良い最適化を見せてくれます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List list &lt;span style="color:#ff79c6">=&lt;/span> CollectionsKt&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">listOf&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> String&lt;span style="color:#ff79c6">[]{&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">});&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> var2 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">((&lt;/span>Collection&lt;span style="color:#ff79c6">)&lt;/span>list&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">size&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span> i &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> var2&lt;span style="color:#ff79c6">;&lt;/span> &lt;span style="color:#ff79c6">++&lt;/span>i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object var3 &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">get&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>var3&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>IntRange&lt;/code>オブジェクトが作られてないです。では、自前で実装してみるとどうなるのでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> SparseArray&amp;lt;*&amp;gt;.indices: IntRange
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>() = &lt;span style="color:#bd93f9">0&lt;/span> until size()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">printValues&lt;/span>(map: SparseArray&amp;lt;String&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> map.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(map.valueAt(i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>拡張プロパティとして定義してコンパイルすると、あまり効率的ではないコードになっていることがわかります。&lt;code>IntRange&lt;/code>オブジェクトが作られてます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> static &lt;span style="color:#ff79c6">final&lt;/span> void printValues(@NotNull SparseArray map) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Intrinsics&lt;/span>.checkParameterIsNotNull(map, &lt;span style="color:#f1fa8c">&amp;#34;map&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IntRange var10000 = &lt;span style="color:#50fa7b">RangesKt&lt;/span>.until(&lt;span style="color:#bd93f9">0&lt;/span>, map.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int i = var10000.getFirst();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int var2 = var10000.getLast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(i &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span>(&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object $&lt;span style="color:#ff79c6">receiver&lt;/span>$iv = map.valueAt(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">System&lt;/span>.&lt;span style="color:#ff79c6">out&lt;/span>.println($&lt;span style="color:#ff79c6">receiver&lt;/span>$iv);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(i &lt;span style="color:#ff79c6">==&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">++&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合は代わりに&lt;code>until()&lt;/code>と&lt;code>for&lt;/code>ループを使った方が良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">printValues&lt;/span>(map: SparseArray&amp;lt;String&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> until map.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(map.valueAt(i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。個人的にはあまり委譲プロパティを使ったことがなく、そもそもの理解を兼ねてかなり勉強になりました。また、rangeに関しても、Javaでの習慣でテストクラスのフィールドとして定義していろいろな関数で使い回していましたが、まさかそれがよりコストのかかることだとは思ってなかったので少しショックでした。&lt;/p>
&lt;p>また、改めてKotlinで提供している機能とAPIに対して正しく理解する必要があると思いました。そして&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%83%E3%82%AB%E3%83%A0%E3%81%AE%E5%89%83%E5%88%80" target="_blank" rel="noopener"
>オッカムの剃刀&lt;/a>でも話しているように、なるべくシンプルなロジックとコードを追求する必要があるとも思いましたね。intellijのメニューのうち、&lt;code>Tools &amp;gt; Kotlin &amp;gt; Show Kotlin Bytecode&lt;/code> でいつでもJavaのコードにdecomplieされたコードを確認できるので、最新だとどのように変換されるのかを確認してみながらコードを最適化を行なった方が良いかも知れません。&lt;/p>
&lt;p>今月はいつもの、自分の経験や仮説を紹介するようなポストでなく、ほぼ翻訳のみになってしまいましたが、私自身としてはかなり貴重な知識を得られたと思っています。またの機会で何か良いものがあったら、是非とも紹介させていただきたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその２</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-2/</link><pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-2/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinの隠されたコストーその２" />&lt;p>今回はまたKotlinの隠されたコストに対するポストです。今となってはあまり気にすることはないかも知れませんし（検証は必要そうですが、バージョンアップごとにコンパイラが生成するコードを追うのは大変そうですね…）、極限のチューニングをするよりもマシンスペックを上げた方がよい時代になったとはいうものの、この記事で紹介していることをコーディングの習慣として身につけておくと良いかなと思います。&lt;/p>
&lt;p>前回は高階関数とLambda、そしてcompanion objectに関する記事を紹介しました。今回はローカル関数、Null安定性、Varargsに隠されたKotlinのコストについて述べます。この記事は&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-2-324a4a50b70" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 2&lt;/a>の内容を要約したものです。&lt;/p>
&lt;h2 id="ローカル関数">ローカル関数&lt;/h2>
&lt;p>関数内に定義した関数を「ローカル関数」と言います。これらローカル関数は、アウター関数（ローカル関数が定義された関数）の範囲にアクセスできます。例えば以下だと、&lt;code>sumSquare&lt;/code>で&lt;code>someMath&lt;/code>のパラメータにアクセスしているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">someMath&lt;/span>(a: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">sumSquare&lt;/span>(b: Int) = (a + b) * (a + b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> sumSquare(&lt;span style="color:#bd93f9">1&lt;/span>) + sumSquare(&lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ローカル関数は基本的にLambdaと似ていますが、他に制限があります。ローカル関数そのものと、ローカル関数を含む関数もまた&lt;code>inline&lt;/code>として定義できません。なので関数の呼び出しにかかるコストを避ける方法がありません。&lt;/p>
&lt;p>コンパイルされたローカル関数は&lt;code>Function&lt;/code>オブジェクトに変わります。なので前回の記事で述べた「インライン化してないLambda」と同じ問題を持っています。上記のコードをJavaのコードで表すと以下のような形になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">someMath&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> a&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Function1 sumSquare$ &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Function1&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// $FF: 生成されたメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#6272a4">// $FF: ブリッジメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> Object &lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Object var1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Integer&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">valueOf&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(((&lt;/span>Number&lt;span style="color:#ff79c6">)&lt;/span>var1&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">intValue&lt;/span>&lt;span style="color:#ff79c6">()));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> b&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>a &lt;span style="color:#ff79c6">+&lt;/span> b&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>a &lt;span style="color:#ff79c6">+&lt;/span> b&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> sumSquare$&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> sumSquare$&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">2&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Lambdaと比べ一つ性能が劣化されない点があります。関数のインスタンスが呼び出し元からわかるので、ジェネリックなインタフェースを使わず、匿名クラスになりメソッドが直接呼び出されます。これは外の関数からローカル関数を呼び出す際に、&lt;code>casting&lt;/code>や&lt;code>boxing&lt;/code>が発生しないということを意味します。実際のBytecodeを見ると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ICONST_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKEVIRTUAL be/myapplication/MyClassKt$someMath$1.invoke (I)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ICONST_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKEVIRTUAL be/myapplication/MyClassKt$someMath$1.invoke (I)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IADD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IRETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでメソッドが2回呼び出されていますが、メソッドの引数も戻り値も&lt;code>int&lt;/code>型になっていて、&lt;code>boxing&lt;/code>と&lt;code>unboxing&lt;/code>がないのを確認できます。&lt;/p>
&lt;p>ただ、依然としてメソッドが呼び出されるたびに&lt;code>Function&lt;/code>オブジェクトのインスタンスを生成していますが、ローカル関数をvalue caputeなしのものに代替することでこの問題は回避できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">someMath&lt;/span>(a: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">sumSquare&lt;/span>(a: Int, b: Int) = (a + b) * (a + b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> sumSquare(a, &lt;span style="color:#bd93f9">1&lt;/span>) + sumSquare(a, &lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにすることで、&lt;code>Function&lt;/code>オブジェクトのインスタンスは再利用できるようなものになります。こうすることで既存のprivate関数に比べ、ローカル関数のデメリットは追加のクラス（メソッドを含む）を生成するということだけになります。&lt;/p>
&lt;p>ローカル関数はprivate関数の代替として、アウター関数の変数にアクセスできるというメリットがあります。ただこれによって&lt;code>Function&lt;/code>オブジェクトを生成するというコストがかかりますので、non-capturingにする工夫が必要です。&lt;/p>
&lt;h2 id="null安全性">Null安全性&lt;/h2>
&lt;p>Kotlinの最も良い機能の一つは明視的にnullになり得る型とそうでない型を区別できるということです。これによってコンパイラがランタイムで予期せぬ&lt;code>NullPointerException&lt;/code>を投げるのを防止できます。&lt;/p>
&lt;h3 id="non-nullパラメータのランタイムでのチェック">Non-nullパラメータのランタイムでのチェック&lt;/h3>
&lt;p>例えば以下のような関数があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">sayHello&lt;/span>(who: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;Hello &lt;/span>&lt;span style="color:#f1fa8c">$who&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはJavaのコードで以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">sayHello&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>@NotNull String who&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">checkParameterIsNotNull&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>who&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;who&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String var1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> who&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>var1&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>@NotNull&lt;/code>アノテーションが追加され、Java側にnullが渡されてはいけないということを知らせています。&lt;/p>
&lt;p>しかし、アノテーションは呼び出し側にnull safetyを強制するものではありません。なのでstaticメソッドを呼び出してパラメータをもう一度確認しています。この関数は&lt;code>IllegalArgumentException&lt;/code>を投げて呼び出し元の修正を簡単にします。&lt;/p>
&lt;p>publicな関数には常にnon-nullなパラメータに対して&lt;code>Intrinsics.checkParameterIsNotNull()&lt;/code>でのチェックがが追加されますが、privateな関数に対しては追加されません。なぜなら、Kotlinクラスはnull safeであることをコンパイラが保証するからです。&lt;/p>
&lt;p>このNullチェックによるパフォーマンスへの影響は無視しても良いほどでテストにも有用ですが、ビルド時にもっと時間がかかる原因になります。これに対してはコンパイラのオプションに&lt;code>-Xno-param-assertions&lt;/code>を追加するか、&lt;a class="link" href="https://www.guardsquare.com/proguard" target="_blank" rel="noopener"
>ProGuard&lt;/a>のルールに以下の設定を追加することでランタイムNullチェックをなくすことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>assumenosideeffects &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">kotlin&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">jvm&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">internal&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">Intrinsics&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">checkParameterIsNotNull&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>java&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">lang&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">Object&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> java&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">lang&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">String&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ上記のルールを追加する場合、AndroidのProGuardのOptimization設定が有効になっているかのチェックがまず必要です。この設定はデフォルトでは無効になっています。&lt;/p>
&lt;h3 id="nullable-primitive型">Nullable primitive型&lt;/h3>
&lt;p>まず先に覚えておくべきことは、nullableで宣言したprimitive型は常にJavaの&lt;code>int&lt;/code>や&lt;code>float&lt;/code>などの代わりに&lt;code>Integer&lt;/code>、&lt;code>Float&lt;/code>といった&lt;code>boxed reference&lt;/code>型が使われるので追加のコストが発生するということです。&lt;/p>
&lt;p>&lt;a class="link" href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/autoboxing.html" target="_blank" rel="noopener"
>autoboxing&lt;/a>とnull-safetyを無視するのでJavaでは&lt;code>Integer&lt;/code>でも&lt;code>int&lt;/code>でもコードはあまり変わらないJavaに対して、Kotlinだとnullableに対して安全なコードを書くように強制しているので、non-nullの方を使った方が良いというのが明確にわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">add&lt;/span>(a: Int, b: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> a + b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">add&lt;/span>(a: Int?, b: Int?): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> (a &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) + (b &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、なるべくコードの可読性と性能を考慮してnon-nullの方を選んだ方が良いです。&lt;/p>
&lt;h3 id="配列">配列&lt;/h3>
&lt;p>Kotlinには、以下の3通りの配列があります。&lt;/p>
&lt;ul>
&lt;li>&lt;code>IntArray&lt;/code>、&lt;code>FloatArray&lt;/code>のようなもの：primitive型の配列。&lt;code>int[]&lt;/code>、&lt;code>float[]&lt;/code>のような型にコンパイルされる。&lt;/li>
&lt;li>&lt;code>Array&amp;lt;T&amp;gt;&lt;/code>：non-nullオブジェクトの型が指定された配列。primitiveに対して&lt;code>boxing&lt;/code>が起こりえる。&lt;/li>
&lt;li>&lt;code>Array&amp;lt;T?&amp;gt;&lt;/code>：nullableオブジェクトの型が指定された配列。明確に&lt;code>boxing&lt;/code>が起こる。&lt;/li>
&lt;/ul>
&lt;p>もしnon-nullなprimitive型の配列が必要な場合は、なるべく&lt;code>Array&amp;lt;Int&amp;gt;&lt;/code>の代わりに&lt;code>IntArray&lt;/code>を使いましょう。&lt;/p>
&lt;h2 id="varargs">Varargs&lt;/h2>
&lt;p>KotlinではJavaとは書き方が少し違いますが、&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#variable-number-of-arguments-varargs" target="_blank" rel="noopener"
>可変長引数&lt;/a>を定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">printDouble&lt;/span>(&lt;span style="color:#ff79c6">vararg&lt;/span> values: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values.forEach { println(&lt;span style="color:#ff79c6">it&lt;/span> * &lt;span style="color:#bd93f9">2&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaと同じく、&lt;code>vararg&lt;/code>はコンパイルされると指定した型の配列になります。そして上記の関数は以下のように、３つの方法で呼び出すことができます。&lt;/p>
&lt;h3 id="複数のパラメータを渡す">複数のパラメータを渡す&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>printDouble(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinのコンパイラはこれを新しい配列の生成と初期化に変えます。これはJavaと一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>printDouble(new int[]{&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはつまり新しい配列を作るためのオーバヘッドがあるということです。ただJavaと変わらないやり方です。&lt;/p>
&lt;h3 id="配列を渡す">配列を渡す&lt;/h3>
&lt;p>Javaでは配列をそのまま渡すことができますが、Kotlinだとそれができず、&lt;code>spread operator&lt;/code>を使う必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> values = intArrayOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(*values)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaでは配列の参照が&lt;code>as-is&lt;/code>として関数に渡され、新しい配列の割り当ては起こりません。しかし、Kotlinの&lt;code>spread operator&lt;/code>は以下のようなことをします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">[]&lt;/span> values &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">[]{&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble&lt;span style="color:#ff79c6">(&lt;/span>Arrays&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">copyOf&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>values&lt;span style="color:#ff79c6">,&lt;/span> values&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">length&lt;/span>&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列のコピーが関数に渡されるので、より安全なコードといえます。呼び出し側には影響なしで、配列を修正できますので。しかしメモリを追加的に消費してしまいます。&lt;/p>
&lt;h3 id="配列と他の引数を混ぜて渡す">配列と他の引数を混ぜて渡す&lt;/h3>
&lt;p>&lt;code>spread operator&lt;/code>の良い点は、配列と他の引数を混ぜて渡すこともできるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> values = intArrayOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(&lt;span style="color:#bd93f9">0&lt;/span>, *values, &lt;span style="color:#bd93f9">42&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はどうコンパイルされるか気になりませんか？結果はかなり面白いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">[]&lt;/span> values &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">[]{&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IntSpreadBuilder var10000 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> IntSpreadBuilder&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">add&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">addSpread&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>values&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">add&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">42&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble&lt;span style="color:#ff79c6">(&lt;/span>var10000&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toArray&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列を新しく生成するだけでなく、一時的なビルダオブジェクトを使って配列の最終的なサイズを計算しています。なので配列を渡す時よりもコストは追加されます。&lt;/p>
&lt;p>なので、呼び出される回数の多くパフォーマンスが重要なコードに対してはなるべく可変長引数より実際の配列をパラメータとして使った方が良いです。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。個人的にprivate関数をよく使うので、よりスコープを制限できるという面でローカル関数を積極的に使いたいと思っていましたが、ここでも隠されたコストがあるというというのは興味深かったです。primitive型についてはJavaがそうだったので、なんとなく&lt;code>boxing&lt;/code>が起こるんじゃないかなと思っていたものの、nullableに対してのみそうだというのも面白かったですね。逆に、primitiveのままになるnon-null型に対してはどうやってチェックが走るのだろうという新しい疑問もありました。（例えば&lt;code>int&lt;/code>だとデフォルト値の&lt;code>0&lt;/code>が常に割り当てられるので）&lt;/p>
&lt;p>あと、配列の場合はJavaでも&lt;code>IntStream&lt;/code>、&lt;code>DoubleStream&lt;/code>などがあったのでなんとなくすぐ理解ができましたが、まさか&lt;code>varargs&lt;/code>で渡したパラメータに対して色々とコストが追加されるとは思わなかったです。そもそもあまり配列を使わないので、可変長引数を使う場面もなかったのですが…よく使わないものほど重要なことを忘れやすそうなので、これは覚えておかないとですね。色々と勉強になりました。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその１</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-1/</link><pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-1/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinの隠されたコストーその１" />&lt;p>Kotlinは便利ですが、何が便利かというと代表的に挙げられるものがたくさんのシンタクスシュガーではないかと思います。同じJVM言語のJavaと比べ、多くの場合でコード量が劇的に減るのが嬉しいという評価も多いものですね。しかし、この便利さの裏には隠されたコスト（性能面での）があるという話があります。今回はそれについて説明している良い記事を見つけたので、共有したいと思います。ただ、翻訳よりは要約に近いものなので、そこはご了承ください。&lt;/p>
&lt;p>ちなみにここで紹介している記事（&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 1&lt;/a>）は、2017年に作成された（Kotlinがまだ1.1だったころ）ので、1.5にまでバージョンアップを成している今からすると、コンパイラの改善などで少し状況が違うケースもあるかと思いますが、述べている内容のレベルが高いので一度は目を通してみても良いかなと思います。また、記事で紹介しているKotlinのBytecodeに対しても、直接最近のKotlinが生成しているコードと比較してみるのも面白いかもですね。&lt;/p>
&lt;p>また、今回紹介している記事は&lt;code>Part 1&lt;/code>ですが、そのほかにも&lt;code>Part 2&lt;/code>や&lt;code>Part 3&lt;/code>の記事がありますので、今後も順次紹介させていただきたいと思います。では、まず&lt;code>Lambda表現式とcompanion object&lt;/code>編を、どうぞ。&lt;/p>
&lt;h2 id="高階関数とlambda表現式">高階関数とLambda表現式&lt;/h2>
&lt;p>例えば以下のような関数を定義しておいたとしましょう。渡されたパラメータをDBのトランザクションの中で実行し、実行結果の行数を返すものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">transaction&lt;/span>(db: Database, body: (Database) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.beginTransaction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> result = body(db)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.setTransactionSuccessful()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.endTransaction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数は、Lambdaを渡して以下のように使えますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> deletedRows = transaction(db) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.delete(“Customers”, &lt;span style="color:#ff79c6">null&lt;/span>, &lt;span style="color:#ff79c6">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinはJava 1.6のJVMから使えますが、Java 1.6のJVMではLambdaに対応していないのです。なので、Kotlinはその互換性を維持するためにLambda（匿名関数も）を&lt;code>Function&lt;/code>というオブジェクトを生成することで対応しています。&lt;/p>
&lt;h3 id="functionオブジェクト">Functionオブジェクト&lt;/h3>
&lt;p>では、実際コンパイルされたLambda（body）がJavaのコードとしてはどうなっているかをみていきましょう。（ここでは、Intellij/Android Studioの&lt;code>Show Kotlin Bytecode&lt;/code>の&lt;code>Decompile&lt;/code>機能を使っています）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">MyClass$myMethod$1&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">implements&lt;/span> Function1 &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// $FF: 生成されたメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#6272a4">// $FF: ブリッジメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> Object &lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Object var1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Integer&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">valueOf&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">((&lt;/span>Database&lt;span style="color:#ff79c6">)&lt;/span>var1&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>@NotNull Database it&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">checkParameterIsNotNull&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>it&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;it&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> it&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">delete&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Customers&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを見るとわかりますが、Lambda（匿名関数）を使う場合、コンパイルされた結果としては基本的に3、4個のメソッドが追加で生成されるということになります。ここで追加された&lt;code>Function&lt;/code>オブジェクトのインスタンスは、必要な時にだけ生成されます。正確には、以下のような動作をします。&lt;/p>
&lt;ul>
&lt;li>value captureがある場合、毎回パラメータが渡されるたび&lt;code>Function&lt;/code>のインスタンスが生成され、GCの対象になる&lt;/li>
&lt;li>value captureがない場合、&lt;code>Function&lt;/code>はSingletonとしてインスタンスが生成され再利用できる&lt;/li>
&lt;/ul>
&lt;p>先ほどのコードでは、value captureがないため、Lambdaの呼び出し元は以下のようなコードとしてコンパイルされます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">transaction&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>db&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>Function1&lt;span style="color:#ff79c6">)&lt;/span>MyClass$myMethod$1&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">INSTANCE&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、value captureのある高階関数を繰り返し呼び出す場合はGCによる性能の低下を考えれます。&lt;/p>
&lt;h3 id="boxingオーバーヘッド">Boxingオーバーヘッド&lt;/h3>
&lt;p>Lambdaに対応しているJava 1.8以降のバージョンでは、&lt;code>Function&lt;/code>インタフェースを複数提供していることでなるべくboxing/unboxingを避けようとしています。しかし、Kotlinでコンパイルされた場合はgenericを利用しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/** 引数を一つ受け取る関数 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">interface&lt;/span> &lt;span style="color:#50fa7b">Function1&lt;/span>&amp;lt;&lt;span style="color:#ff79c6">in&lt;/span> P1, &lt;span style="color:#ff79c6">out&lt;/span> R&amp;gt; : Function&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/** 引数を受け取り関数を実行する */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">operator&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">invoke&lt;/span>(p1: P1): R
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらをみてわかるのは、高階関数でパラメータとして渡された関数を呼び出す時に、その関数にprimitiveタイプの値が存在する場合（パラメータ、もしくは戻り値）boxing/unboxingが起こるということです。先ほどのコンパイルされたLambdaにおいて、戻り値が&lt;code>Integer&lt;/code>としてboxingされたのを確認できましたね。&lt;/p>
&lt;p>primitiveタイプを使用するLambdaをパラメータとしてとる高階関数は、参照回数が少なければあまり意識しなくてもよいコストになりますが、そうでない場合は性能に影響があると推定できます。&lt;/p>
&lt;h3 id="inline関数">Inline関数&lt;/h3>
&lt;p>幸い、Kotlinでは&lt;code>inline&lt;/code>と言うキーワドを提供しています。これを使うと高階関数をインライン化できますね。インライン化されると呼び出し元のコードに&lt;code>Function&lt;/code>の中身を直接含ませてコンパイルします。なので、インライン化された場合は以下のような面で性能の向上を考えられます。&lt;/p>
&lt;ul>
&lt;li>Functionオブジェクトのインスタンスが生成されない&lt;/li>
&lt;li>primitiveタイプを使う関数に対してboxing/unboxingが起こらない&lt;/li>
&lt;li>メソッドカウントが増えない（Androidの場合、アプリが参照できるメソッドの数字に制限がある）&lt;/li>
&lt;li>関数の呼び出しが増えない（CPU依存が高く、呼び出される頻度の高いコードのパフォーマンスの改善を期待できる）&lt;/li>
&lt;/ul>
&lt;p>インライン化された場合のコードを確認してみましょう。&lt;code>transaction&lt;/code>関数が消え、&lt;code>db.delete&lt;/code>を直接呼び出しているのがわかります。また、戻り値の&lt;code>result&lt;/code>もWrapperクラスからprimitiveタイプになっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>db&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">beginTransaction&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">try&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> result$iv &lt;span style="color:#ff79c6">=&lt;/span> db&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">delete&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Customers&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">setTransactionSuccessful&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">finally&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">endTransaction&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、&lt;code>inline&lt;/code>キーワードを使うときは以下のことを考慮しなければならないです。&lt;/p>
&lt;ul>
&lt;li>インライン関数は自分自身を直接呼び出したり、他のインライン関数から呼び出せない&lt;/li>
&lt;li>クラスに定義されたpublicなインライン関数はそのクラスのpublic関数とフィールドのみアクセスできる&lt;/li>
&lt;li>コンパイルされたコードが大きくなる（繰り返し参照される場合はより大きくなる）&lt;/li>
&lt;/ul>
&lt;p>なるべく高階関数をインライン化し、必要であれば長いコードブロックをインラインではない関数に写した方がいいです。また、性能が大事なところでは呼び出された関数をインライン化することも考えられます。&lt;/p>
&lt;h2 id="companion-object">Companion object&lt;/h2>
&lt;p>Kotlinではクラスがstaticなフィールドやメソッドを定義できません。その代わりに&lt;code>companion object&lt;/code>を使うことになっていますね。&lt;/p>
&lt;h3 id="クラスのprivateフィールドをcompanion-objectからアクセスする">クラスのprivateフィールドをcompanion objectからアクセスする&lt;/h3>
&lt;p>以下のような例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">constructor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> hello = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">newInstance&lt;/span>() = MyClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードがコンパイスされると、&lt;code>companion object&lt;/code>はSingletonクラスになります。なので、クラスのprivateフィールドに外部クラスからアクセスできるようにする必要があり、コンパイラが&lt;code>getter&lt;/code>、&lt;code>setter&lt;/code>を追加で生成することになるということです。生成されたメソッドは&lt;code>companion object&lt;/code>から参照されることになります。以下を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass.access$getHello$p (Lbe/myapplication/MyClass;)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ISTORE 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaだとこれを避けるためにアクセス制限を&lt;code>package&lt;/code>単位にすることができましたが、Kotlinではそのようなキーワードがないですね。&lt;code>public&lt;/code>や&lt;code>internal&lt;/code>を使う場合も&lt;code>getter&lt;/code>と&lt;code>setter&lt;/code>は基本的に生成されます。また、これらのメソッドはinstanceメソッドであり、staticメソッドよりもコストが高いですね。なので、最適化のためフィールドのアクセス制限を変えるということは避けた方が良いです。&lt;/p>
&lt;p>もし&lt;code>companion object&lt;/code>からクラスのフィールドに頻繁なアクセスが発生するとしたら、この隠れているメソッドの呼び出しを避けるためにフィールドの値をキャッシュするという方法も考慮できます。&lt;/p>
&lt;h3 id="companion-objectの定数にアクセスする">Companion objectの定数にアクセスする&lt;/h3>
&lt;p>Kotlinでは、クラス内のstaticな定数は&lt;code>companion object&lt;/code>の中に定義するのが一般的です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> TAG = &lt;span style="color:#f1fa8c">&amp;#34;TAG&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(TAG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見シンプルで良さげなコードですが、Kotlin 1.2.40以前の場合だとかなり裏のコードは汚くなっています。&lt;/p>
&lt;h4 id="kotlin-1240以前の場合">Kotlin 1.2.40以前の場合&lt;/h4>
&lt;p>&lt;code>companion object&lt;/code>に定義されたprivateな定数にアクセスする場合、上記のようなこと（&lt;code>getter&lt;/code>を利用する）が起こります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GETSTATIC be/myapplication/MyClass.Companion : Lbe/myapplication/MyClass$Companion;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass$Companion.access$getTAG$p (Lbe/myapplication/MyClass$Companion;)Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ASTORE 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>問題はこれだけではありません。生成されたメソッドは実際の値を返すわけでなく、instanceメソッドとして生成された&lt;code>getter&lt;/code>を呼び出すことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESPECIAL be/myapplication/MyClass$Companion.getTAG ()Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>定数が&lt;code>public&lt;/code>になっている場合はダイレクトにアクセスできるようになりますが、依然として&lt;code>getter&lt;/code>メソッドを通して値にアクセスことになります。&lt;/p>
&lt;p>そして定数の値を格納するために、Kotlinコンパイラは&lt;code>companion object&lt;/code>ではなく、それを持つクラスの方に&lt;code>private static final&lt;/code>フィールドを生成します。さらに&lt;code>companion object&lt;/code>からこのフィールドにアクセスするため、またのメソッドを生成することとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass.access$getTAG$cp()Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こういう長い道のりで、やっと値を読み込むことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GETSTATIC be/myapplication/MyClass.TAG : Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まとめると、Kotlin 1.2.40以前のバージョンを使っている場合は以下のようになります。&lt;/p>
&lt;ul>
&lt;li>&lt;code>companion object&lt;/code>から静的メソッドを呼び出す
&lt;ul>
&lt;li>&lt;code>companion object&lt;/code>からinstanceメソッドを呼び出す
&lt;ul>
&lt;li>クラスのstaticメソッドを呼び出す
&lt;ul>
&lt;li>staticフィールドから値を読み込む&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>これをJavaのコードで表現すると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String TAG &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;TAG&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Companion companion &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Companion&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 生成されるメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String &lt;span style="color:#50fa7b">access$getTAG$cp&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> TAG&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Companion&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String &lt;span style="color:#50fa7b">getTAG&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> MyClass&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">access$getTAG$cp&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 生成されるメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String &lt;span style="color:#50fa7b">access$getTAG$p&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Companion c&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> c&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getTAG&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">helloWorld&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Companion&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">access$getTAG$p&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>companion&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>よりコストの低いBytecodeを生成することも可能ですが、それは簡単ではないです。&lt;/p>
&lt;p>まず&lt;code>const&lt;/code>キーワードを使ってコンパイルタイム定数を定義することでメソッドの呼び出しをなくすことができます。しかし、KotlinではprimitiveかStringに対してのみ可能な方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> TAG = &lt;span style="color:#f1fa8c">&amp;#34;TAG&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(TAG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または&lt;code>@JvmField&lt;/code>を使ってJavaのアプローチを取る方法を考えられます。こうすることで&lt;code>getter&lt;/code>や&lt;code>setter&lt;/code>が生成されず、フィールドに直接アクセスができるようになります。ただ、&lt;code>@Jvm&lt;/code>系のアノテーションはJavaとの互換性のためのものであるのでこれが果たして良い方法かどうかを考えた方が良いでしょう。そして&lt;code>public&lt;/code>なフィールドのみ可能な方法です。&lt;/p>
&lt;p>Androidの開発の場合だと、&lt;code>Parcelable&lt;/code>オブジェクトを自前で実装する場合のみ有効な方法に思われます。例えば以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span>() : Parcelable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @JvmField
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> CREATOR = creator { MyClass(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">constructor&lt;/span>(parcel: Parcel) : &lt;span style="color:#ff79c6">this&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">writeToParcel&lt;/span>(dest: Parcel, flags: Int) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">describeContents&lt;/span>() = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後の方法として、&lt;a class="link" href="https://developer.android.com/studio/build/shrink-code" target="_blank" rel="noopener"
>ProGuard&lt;/a>やR8のようなツールを使ってBytecodeの最適化を狙うという方法があるでしょう。&lt;/p>
&lt;h4 id="kotlin-1240以降の場合">Kotlin 1.2.40以降の場合&lt;/h4>
&lt;p>Kotlinn 1.2.40からは、&lt;code>companion object&lt;/code>に定義された値はメインクラスの方に格納されるということには変わりがありませんが、メソッドの生成と呼び出しなしで直接アクセスができるようになりました。これをJavaのコードとして表現すると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String TAG &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;TAG&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Companion companion &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Companion&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Companion&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">helloWorld&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>TAG&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、上記のように&lt;code>companion object&lt;/code>にメソッドが一つもない場合は、ProGuardやR8によるツールと使うとクラス自体が消えることで最適化されます。&lt;/p>
&lt;p>ただ、&lt;code>companion object&lt;/code>に定義さえたメソッドの場合はコストが少しかかります。フィールドがメインクラスの方に格納されてあるため、&lt;code>companion object&lt;/code>に定義されたprivateフィールドにアクセスするためには依然として生成されたメソッドを経由することになります。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は人の書いた記事を読んだだけですが、かなり勉強になる内容でした。特に私個人としては、intellijを使っていると何を基準に&lt;code>inline&lt;/code>キーワードを使った方がいいという警告が出るのか悩ましい場面がありましたが、それが少し理解できました。&lt;code>companion object&lt;/code>に関する話も、今は問題が解決されたものの、何も考えず「定数だから&lt;code>companion object&lt;/code>だな」と思っていた自分を反省することになりましたね。そしてこの後の記事でも面白い内容が色々と出てくるので、またの機会でぜひ紹介したいと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>色々な言語でやってみた（ソート編）</title><link>https://retheviper.github.io/posts/languages-comparsion-sorting/</link><pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/languages-comparsion-sorting/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.jpg" alt="Featured image of post 色々な言語でやってみた（ソート編）" />&lt;p>今はどんなプログラミング言語を選んでもできることはあまり違わなく、まさに好みで選んでもいいと思えるくらいの時代となっていると思います。特に、&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>のようなトランスパイラーやFlutterのようなフレームワークも続々と登場している時代なので、こういう傾向はこれからもどんどん加速していくのではないかと思います。&lt;/p>
&lt;p>しかしそのような変化がある一方で、今現在はプログラマに一人が扱えるプログラミング言語の数に対する要求も増えいている状況ではないかと思います。実際の業務ではさまざまな理由で使われる言語が決まっていて、自分が今まで触ったことのないものでも使えるようになる必要があり、一人のエンジニアが固定されたポジションでなく、さまざまな分野にかけて実装を行うケースもありますしね。いわゆる&lt;a class="link" href="https://en.wikipedia.org/wiki/Polyglot_%28computing%29" target="_blank" rel="noopener"
>Polyglot&lt;/a>の時代とも言えます。&lt;/p>
&lt;p>なので、少なくともいろいろな言語の特徴を把握しておくということが大事になっているのではないかと思います。そして、そのような必要によるものでなくても、自分が普段接してない言語のコンセプトに触れてみることで、メインとなる言語への理解が深まることもあるのではないのかなと思ったりもします。これはどんな言語でもできることはあまり変わらないということともある意味通じているのですが、他の言語のコンセプトを受け入れた新しいAPIや機能を導入したり、そのようなライブラリが登場する場合もあるので。&lt;/p>
&lt;p>さて、前置きが長くなりましたが、ということで、これからはたまにとある操作をするときにいろいろな言語ではどうやってできるのか、そしてそうした場合の特徴などを簡単に比べてみたいと思います。今回は、配列のソートになります。&lt;/p>
&lt;h2 id="javascript">JavaScript&lt;/h2>
&lt;p>JavaScriptでは&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener"
>Array.prototype.sort()&lt;/a>で配列のソートができます。なので、以下のようなコードを使えます。シンプルですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> a.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、元の配列の値は変更せず、新しくソートされた配列を作りたい場合は以下の方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> b &lt;span style="color:#ff79c6">=&lt;/span> [...a].sort() &lt;span style="color:#6272a4">// aをコピーしてソート
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> console.log(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここで気づいた方もいらっしゃると思いますが、ソートされた値が期待通りにはなっていません。本当なら、&lt;code>1, 22, 44, 300, 5000&lt;/code>になるのが普通でしょう。ここで昇順に値をソートしたい場合は、ソートの方法を自前で作成する必要があります。例えば以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> a.sort((a, b) =&amp;gt; a &lt;span style="color:#ff79c6">-&lt;/span> b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>sort()&lt;/code>では、引数として渡す&lt;code>compareFunction&lt;/code>（引数が二つ、戻り値はnumber）の戻り値の結果によって、以下のことが起こります。&lt;/p>
&lt;ul>
&lt;li>0より小さいと、aのインデックスをbの先に置く&lt;/li>
&lt;li>0だと、aとbは変更しない&lt;/li>
&lt;li>0より大きいと、bのインデックスをaの先に置く&lt;/li>
&lt;/ul>
&lt;p>これはJavaをやっていた方だと、&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener"
>Comparator&lt;/a>と同じだなとすぐわかる内容ですね。アロー関数の形もJavaのLambdaに似ているので、あまり違和感なく適応できるかと思います。かなりシンプルなのですが、number型の配列に対しては自前の&lt;code>compareFunction&lt;/code>が必要となるということは大事なので、気を付ける必要はあるでしょう。&lt;/p>
&lt;p>配列のインデックスを反転したい場合は、&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener"
>Array.prototype.reverse()&lt;/a>を使うだけで良いです。この場合はnumberの配列でも自前の&lt;code>compareFunction&lt;/code>が必要ないので、便利ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> a.reverse()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#bd93f9">5000&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="java">Java&lt;/h2>
&lt;p>では、次にJavaの方も見ていきましょう。先に述べた通り、&lt;code>Comparator&lt;/code>を使うと簡単にソートの方法を実装できるので、基本的には同じです。ただ、Javaの場合だとそもそも&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#sort-java.util.Comparator-" target="_blank" rel="noopener"
>List.sort()&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Collections.html#sort-java.util.List-" target="_blank" rel="noopener"
>Collections.sort()&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Arrays.html#sort-int:A-" target="_blank" rel="noopener"
>Arrays.sort()&lt;/a>、[Stream.sorted()]など方法が色々あり、ソートしたいCollectionやArrayなどが&lt;code>Immutable&lt;/code>であるかどうか、&lt;code>Comparator&lt;/code>や&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener"
>Comparable&lt;/a>を自前で実装するか、それともスタンダードライブラリに用意されてあるものを使うかなどのさまざまな選択肢も考慮する必要があるということですね。&lt;/p>
&lt;p>色々な選択肢がある中で、もっとも簡単なのは、&lt;code>Collections.sort()&lt;/code>や&lt;code>Arrays.sort()&lt;/code>を使う方法かなと思います。これを使う場合、primitive型やStringのListは短いコードでソートができるという（そして標準機能という）メリットがありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ArrayList&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;()&lt;/span> &lt;span style="color:#ff79c6">{{&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add &lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> &lt;span style="color:#ff79c6">}};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> Collections&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">sort&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、&lt;code>List.sort()&lt;/code>が簡単です。&lt;code>Comparator&lt;/code>を引数として渡す必要がありますが、昇順・降順でソートしたい場合は既に用意されてあるメソッドを呼び出すだけですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ArrayList&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;()&lt;/span> &lt;span style="color:#ff79c6">{{&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add &lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> &lt;span style="color:#ff79c6">}};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> a&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">sort&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Comparator&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">naturalOrder&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに&lt;code>Comparator&lt;/code>で使える既定のソート方法は以下があります。&lt;/p>
&lt;ul>
&lt;li>昇順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#naturalOrder--" target="_blank" rel="noopener"
>naturalOrder()&lt;/a>&lt;/li>
&lt;li>降順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#reverseOrder--" target="_blank" rel="noopener"
>reverseOrder()&lt;/a>&lt;/li>
&lt;li>逆順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#reversed--" target="_blank" rel="noopener"
>reversed()&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>また、&lt;code>Comparator&lt;/code>は、&lt;code>Collections.sort()&lt;/code>の引数としても使えます。なので、降順にソートしたい場合は以下のようなコードを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ArrayList&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;()&lt;/span> &lt;span style="color:#ff79c6">{{&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add &lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> &lt;span style="color:#ff79c6">}};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> Collections&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">sort&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">,&lt;/span> Comparator&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">reverseOrder&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、元のListの値を変更せず、新しくソートされた結果を取得したい場合は、元のListをコピーする方法もありますが、もう一つの方法として&lt;code>Stream&lt;/code>を使う方法を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var b &lt;span style="color:#ff79c6">=&lt;/span> a&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">sorted&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Stream&lt;/code>でソートする場合でも、&lt;code>Comparator&lt;/code>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var b &lt;span style="color:#ff79c6">=&lt;/span> a&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">sorted&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Comparator&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">reverseOrder&lt;/span>&lt;span style="color:#ff79c6">()).&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、DTOのListをソートしたい場合は、DTOが&lt;code>Comparable&lt;/code>を継承するという方法も考えられますが、多くの場合はソート時の条件が明確にわかる&lt;code>Comparator&lt;/code>を実装したいいかなと思います。汎用性や柔軟性を考えても、&lt;code>Comparable&lt;/code>の場合、条件が変わるとクラスを修正する必要があるので、&lt;code>Comparator&lt;/code>を使った方が無難かなと思います。&lt;/p>
&lt;p>Arrayの場合、&lt;code>Arrays.sort()&lt;/code>を利用してソートできる（もちろん&lt;code>Comparator&lt;/code>も使えます）上に、ListやStreamに変換することもできるので上記の方法をそのまま使えます。なので選択肢はもっと多いわけですが、便利な（好みに合う）方法を選ぶといいかなと思います。個人的には&lt;code>Arrays.sort()&lt;/code>に&lt;code>Comparator&lt;/code>を渡した方が可読性という面で良さそうな気がします。&lt;/p>
&lt;h2 id="kotlin">Kotlin&lt;/h2>
&lt;p>Sytax Sugarをたくさん提供しているKotlinらしく、選べるソートのオプションがたくさんあります。なので、少しまとめてみました。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Orderの種類&lt;/th>
&lt;th>ソート結果&lt;/th>
&lt;th>fun&lt;/th>
&lt;th>備考&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Natural&lt;/td>
&lt;td>呼び出し元&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort.html" target="_blank" rel="noopener"
>Array/MutableList.sort()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-descending.html" target="_blank" rel="noopener"
>Array/MutableList.sortDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reverse.html" target="_blank" rel="noopener"
>Array/MutableList.reverse()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Array&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array.html" target="_blank" rel="noopener"
>Array.sortedArray()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array-descending.html" target="_blank" rel="noopener"
>Array.sortedArrayDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reversed-array.html" target="_blank" rel="noopener"
>Array.reveredArray()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted.html" target="_blank" rel="noopener"
>Array/List.sorted()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-descending.html" target="_blank" rel="noopener"
>Array/List.sortedDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/as-reversed.html" target="_blank" rel="noopener"
>List/MutableList.asRevered()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Custom&lt;/td>
&lt;td>呼び出し元&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-by.html" target="_blank" rel="noopener"
>Array/MutableList.sortBy()&lt;/a>&lt;/td>
&lt;td>昇順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-by-descending.html" target="_blank" rel="noopener"
>Array/MutableList.sortByDescending()&lt;/a>&lt;/td>
&lt;td>降順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by.html" target="_blank" rel="noopener"
>Array/Iterable.sortedBy()&lt;/a>&lt;/td>
&lt;td>昇順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by-descending.html" target="_blank" rel="noopener"
>Array/Iterable.sortedByDescending()&lt;/a>&lt;/td>
&lt;td>降順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Array&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array-with.html" target="_blank" rel="noopener"
>Array.sortedArrayWith()&lt;/a>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/" target="_blank" rel="noopener"
>Comparator&lt;/a>必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-with.html" target="_blank" rel="noopener"
>Array/Iterable.sortedWith()&lt;/a>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/" target="_blank" rel="noopener"
>Comparator&lt;/a>必要&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>かなり多い選択肢があるように見えますが、こうやって表としてまとめてみるとまぁまぁわかりそうな気はします。自前の比較処理を書く必要があるか、ソートした結果が元の配列かどうか、そしてArrayになるかListになるかなどいくつかの基準で分けられるということが分かれば大体どれを使った方がいいか悩む必要はないかなと思います。&lt;/p>
&lt;p>なので、まずやりたいことを明確にした上で、どのAPIを使うかを選んで書くだけです。以下はListから、ソートされた新しいListを作成する例です。それぞれ昇順と降順の場合となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> a = listOf(&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> b = a.sorted()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[1, 22, 44, 300, 5000]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> c = a.sortedDescending()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[5000, 300, 44, 22, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、data classの配列をソートしたい場合は&lt;code>sortBy&lt;/code>や&lt;code>sortedBy&lt;/code>を使えます。ここで引数に必要なのは&lt;code>(T) -&amp;gt; R&lt;/code>型のselectorですが、単純にどれを基準にソートするかを指定すれば良いだけですので実装は簡単です。以下の例を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Data&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> number: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> a = listOf(Data(&lt;span style="color:#bd93f9">22&lt;/span>), Data(&lt;span style="color:#bd93f9">1&lt;/span>), Data(&lt;span style="color:#bd93f9">44&lt;/span>), Data(&lt;span style="color:#bd93f9">300&lt;/span>), Data(&lt;span style="color:#bd93f9">5000&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> b = a.sortedBy { &lt;span style="color:#ff79c6">it&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[Data(number=1), Data(number=22), Data(number=44), Data(number=300), Data(number=5000)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> c = a.sortedByDescending { &lt;span style="color:#ff79c6">it&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[Data(number=5000), Data(number=300), Data(number=44), Data(number=22), Data(number=1)]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、より複雑な比較の条件を指定したい場合はJavaの場合と同じく、&lt;code>Comparator&lt;/code>を実装すると良いでしょう。やはりJavaと似ているようで、より単純化した（そしてそのせいで選択肢は増えた）感覚ですね。&lt;/p>
&lt;h2 id="swift">Swift&lt;/h2>
&lt;p>Swiftでは、シンプルに元のCollectionをソートするかソートされた新しいCollectionを作るかの選択肢しかないようです。あまり変わったことはないですが、元のCollectionをソートする場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">1&lt;/span>&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">a&lt;/span> = [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a: [&lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span>] = &lt;span style="color:#bd93f9">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">0&lt;/span>] = &lt;span style="color:#bd93f9">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">1&lt;/span>] = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">2&lt;/span>] = &lt;span style="color:#bd93f9">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">3&lt;/span>] = &lt;span style="color:#bd93f9">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">4&lt;/span>] = &lt;span style="color:#bd93f9">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">2&lt;/span>&amp;gt; a.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">3&lt;/span>&amp;gt; print(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして新しいCollectionを作成したい場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">1&lt;/span>&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">a&lt;/span> = [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a: [&lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span>] = &lt;span style="color:#bd93f9">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">0&lt;/span>] = &lt;span style="color:#bd93f9">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">1&lt;/span>] = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">2&lt;/span>] = &lt;span style="color:#bd93f9">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">3&lt;/span>] = &lt;span style="color:#bd93f9">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">4&lt;/span>] = &lt;span style="color:#bd93f9">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">2&lt;/span>&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">b&lt;/span> = a.sorted()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b: [&lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span>] = &lt;span style="color:#bd93f9">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">0&lt;/span>] = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">1&lt;/span>] = &lt;span style="color:#bd93f9">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">2&lt;/span>] = &lt;span style="color:#bd93f9">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">3&lt;/span>] = &lt;span style="color:#bd93f9">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">4&lt;/span>] = &lt;span style="color:#bd93f9">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">3&lt;/span>&amp;gt; print(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Swiftのソートが独特なのはどうやってソートするか、その方法を指定する時です。&lt;a class="link" href="https://developer.apple.com/documentation/swift/array/2296801-sort" target="_blank" rel="noopener"
>sort()&lt;/a>でも&lt;a class="link" href="https://developer.apple.com/documentation/swift/array/2296815-sorted" target="_blank" rel="noopener"
>sorted()&lt;/a>でも引数として&lt;code>areInIncreasingOrder&lt;/code>という関数を渡すことができるようになっていますが、JavaScriptやJava、Kotlinで使われていた&lt;code>compareFunction&lt;/code>や&lt;code>Comparator&lt;/code>の戻り値が数字であったことに対して、&lt;code>areInIncreasingOrder&lt;/code>はpredicate型として戻り値がBoolになっています。なので以下のような形でソートの方法を指定可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">students&lt;/span>: Set = [&lt;span style="color:#f1fa8c">&amp;#34;Kofi&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Abena&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Peter&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Kweku&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Akosua&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">descendingStudents&lt;/span> = students.sorted(by: &lt;span style="color:#ff79c6">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(descendingStudents) &lt;span style="color:#6272a4">// &amp;#34;[&amp;#34;Peter&amp;#34;, &amp;#34;Kweku&amp;#34;, &amp;#34;Kofi&amp;#34;, &amp;#34;Akosua&amp;#34;, &amp;#34;Abena&amp;#34;]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、classのフィールドを基準にソートしたい場合は以下の方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">Data&lt;/span> { &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">number&lt;/span> = &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">datas&lt;/span> = [Data(number: &lt;span style="color:#bd93f9">1&lt;/span>), Data(number: &lt;span style="color:#bd93f9">3&lt;/span>), Data(number: &lt;span style="color:#bd93f9">4&lt;/span>), Data(number: &lt;span style="color:#bd93f9">2&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">descending&lt;/span> = datas.sorted { &lt;span style="color:#8be9fd;font-style:italic">$0&lt;/span>.number &lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$1&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dump(descending)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> descending: [Data] = 4 values {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> [0] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> number = 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> [1] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> number = 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> [2] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> number = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> [3] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> number = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="go">Go&lt;/h2>
&lt;p>Goにはジェネリックがないからか、&lt;a class="link" href="https://pkg.go.dev/sort" target="_blank" rel="noopener"
>sort&lt;/a>というパッケージに、sliceの種類によってソート用のfuncが色々と用意されています。例えば以下のようなものがあります。&lt;/p>
&lt;ul>
&lt;li>func Float64s(x []float64)&lt;/li>
&lt;li>func Ints(x []int)&lt;/li>
&lt;li>func Strings(x []string)&lt;/li>
&lt;/ul>
&lt;p>なので、structのsliceではい場合はこれらの中でどれかを選んでソートすることになりますね。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd">int&lt;/span>{&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort.&lt;span style="color:#50fa7b">Ints&lt;/span>(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(a) &lt;span style="color:#6272a4">// [1 22 44 300 5000]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>structの場合は、以下のような方法が使えます。ソートの基準がまた&lt;code>bool&lt;/code>になっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>people &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name &lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Age &lt;span style="color:#8be9fd">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Gopher&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">55&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Vera&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">24&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort.&lt;span style="color:#50fa7b">Slice&lt;/span>(people, &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i, j &lt;span style="color:#8be9fd">int&lt;/span>) &lt;span style="color:#8be9fd">bool&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> people[i].Name &amp;lt; people[j].Name })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(people) &lt;span style="color:#6272a4">// [{Alice 55} {Bob 75} {Gopher 7} {Vera 24}]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>面白いのは、Goのソートには&lt;a class="link" href="https://pkg.go.dev/sort#SliceStable" target="_blank" rel="noopener"
>sort.SliceStable()&lt;/a>というものが別に存在しているということです。これは&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%AE%89%E5%AE%9A%E3%82%BD%E3%83%BC%E3%83%88" target="_blank" rel="noopener"
>安定ソート&lt;/a>を行うもので、その定義に関してはWikiでは以下のように述べています。&lt;/p>
&lt;blockquote>
&lt;p>同等なデータのソート前の順序が、ソート後も保存されるものをいう。つまり、ソート途中の各状態において、常に順位の位置関係を保っていることをいう。&lt;/p>
&lt;/blockquote>
&lt;p>つまり、安定ソートの場合、ソートの基準となる値が同等の要素間の元の位置関係（インデックス）が保証されるということですね。その結果が実際どうなるのかを見てみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>people &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name &lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Age &lt;span style="color:#8be9fd">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Elizabeth&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Colin&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Elizabeth&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort.&lt;span style="color:#50fa7b">SliceStable&lt;/span>(people, &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i, j &lt;span style="color:#8be9fd">int&lt;/span>) &lt;span style="color:#8be9fd">bool&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> people[i].Age &amp;lt; people[j].Age })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(people) &lt;span style="color:#6272a4">// [{Alice 25} {Bob 25} {Colin 25} {Elizabeth 25} {Alice 75} {Alice 75} {Bob 75} {Elizabeth 75}]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードの実行結果でわかるように、&lt;code>Alice 25&lt;/code>、&lt;code>Bob 25&lt;/code>、&lt;code>Colin 25&lt;/code>、&lt;code>Elizabeth 25&lt;/code>と&lt;code>Alice 75&lt;/code>, &lt;code>Bob 75&lt;/code>, &lt;code>Elizabeth 75&lt;/code>の元の順が維持されたままソートされたのがわかります。ここでもし&lt;code>sort.Slice()&lt;/code>を使うと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>sort.&lt;span style="color:#50fa7b">Slice&lt;/span>(people, &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i, j &lt;span style="color:#8be9fd">int&lt;/span>) &lt;span style="color:#8be9fd">bool&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> people[i].Name &amp;lt; people[j].Name })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(people) &lt;span style="color:#6272a4">// [{Alice 25} {Alice 75} {Alice 75} {Bob 75} {Bob 25} {Colin 25} {Elizabeth 75} {Elizabeth 25}]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安定ソートはそうでないソートに比べ性能が劣る可能性が高いので（元のインデックスをまで考慮しているので）、一つの値を基準にソートしても問題ない場合は&lt;code>sort.Slice()&lt;/code>でも十分な気がしますが、そうでない場合は安定ソートを考慮する必要がありそうですね。&lt;/p>
&lt;h2 id="python">Python&lt;/h2>
&lt;p>Pythonでは&lt;a class="link" href="https://docs.python.org/3/library/stdtypes.html#list.sort" target="_blank" rel="noopener"
>list.sort()&lt;/a>か、&lt;a class="link" href="https://docs.python.org/3/library/functions.html#sorted" target="_blank" rel="noopener"
>sorted()&lt;/a>を使えます。他の言語でも大体同じだったので命名だけでも推測が可能かと思いますが、前者は元のlistをソートするもので、後者は新しいlistを作り出すものです。&lt;/p>
&lt;p>まず&lt;code>list.sort()&lt;/code>は、以下のように使えます。他の言語とあまり変わらないですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a&lt;span style="color:#ff79c6">.&lt;/span>sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>それに対して、&lt;code>sorted()&lt;/code>は以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> b &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">sorted&lt;/span>(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、これらの関数では&lt;code>key&lt;/code>や&lt;code>reverse&lt;/code>のようなパラメータを指定することで、どれを基準にソートするか、逆順にソートするかなどを指定できます。Pythonらしいシンプルさですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">def&lt;/span> __init__(self, number):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#ff79c6">.&lt;/span>number &lt;span style="color:#ff79c6">=&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">def&lt;/span> __repr__(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">repr&lt;/span>((self&lt;span style="color:#ff79c6">.&lt;/span>number))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datas &lt;span style="color:#ff79c6">=&lt;/span> [Data(&lt;span style="color:#bd93f9">1&lt;/span>), Data(&lt;span style="color:#bd93f9">3&lt;/span>), Data(&lt;span style="color:#bd93f9">2&lt;/span>), Data(&lt;span style="color:#bd93f9">4&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datas&lt;span style="color:#ff79c6">.&lt;/span>sort(key&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">lambda&lt;/span> data: data&lt;span style="color:#ff79c6">.&lt;/span>number) &lt;span style="color:#6272a4"># [1, 2, 3, 4]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">sorted&lt;/span>(datas, key&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">lambda&lt;/span> data: data&lt;span style="color:#ff79c6">.&lt;/span>number, reverse&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">True&lt;/span>) &lt;span style="color:#6272a4"># [4, 3, 2, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="番外stable-sort">番外：Stable sort&lt;/h2>
&lt;p>Goのソート方法の中で少し安定ソートの話が出ましたが、ここで比較した他の言語だとGoのように安定ソートとそうでないソートのどれを使うかという選択肢がなかったので、それぞれの言語での安定ソートはどうやって扱われているのかを表にしてみました。以下をご覧ください。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>言語&lt;/th>
&lt;th>stable&lt;/th>
&lt;th>non-stable&lt;/th>
&lt;th>備考&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Go&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>funcによって選べられる&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Java&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>Streamはnon-stable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>JavaScript&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>ブラウザのバージョンによる&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Python&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kotlin&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>SequenceでもStable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Swift&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>&lt;code>stableを保証できない&lt;/code>と表現&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>多くの言語が安定ソートに対応していますが、少しづつ仕様が違う場合がありました。例えばJavaの場合、Streamによるソートは安定ソートではないため、安定ソートの結果を保証したい場合は既にソートされたCollectionを使うことをおすすめしています。Kotlinの場合はStreamに似たSequenceを使う場合でも、&lt;code>stateful&lt;/code>なためか、安定ソートに対応していました。&lt;/p>
&lt;p>また、JavaScriptの場合はブラウザのバージョンによって違いますが、最新のブラウザを使っている場合は大抵安定ソートに対応していました。ただ、JavaScirptを使った案件の場合はIEも対象ブラウザとして考慮される場合があるのですが、IEだと安定ソートに対応していないので確認が必要かなと思います。&lt;/p>
&lt;p>Swiftの場合はまだソート時のデフォルト値をstableにするかどうかを検討している中で、APIとしてもGoのようにstableとそうでないものを分離するかどうかを検討しているらしいです。またどのアルゴリズムを使うかについて議論しているらしく、しばらくは安定ソートを期待できないかと思います。&lt;/p>
&lt;p>KotlinとPythonはどの場合でも安定ソートとなるので、悩み事が一つ減るのが嬉しいですね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は色々な言語のソートについて調べてみましたが、いかがでしたか。一度ソートしたデータはその後の要素に対するアクセスが早くなるので、チューニングの観点からは必要なものかと思います。そしてこうやって色々な言語のソートのAPIを調べてみると、その言語の設計思想や発展の過程のようなものが少し見えるようで面白く、勉強にもなりますね。個人的にはあまり意識してなかった安定ソートがかなり勉強になりました。&lt;/p>
&lt;p>これからもこうやって色々な言語の使用やAPI、同じことをする場合の各言語による違いなどを比べてみたいと思います。時間と体力が十分であればの話ではありますが…！&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Quarkusを触ってみた</title><link>https://retheviper.github.io/posts/quarkus-first-impression/</link><pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/quarkus-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/quarkus.jpg" alt="Featured image of post Quarkusを触ってみた" />&lt;p>Spring MVCは良いフレームワークではありますが、最近流行りの&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9" target="_blank" rel="noopener"
>マイクロサービス&lt;/a>には向いてないという批判もあります。理由としては、アプリの起動時間が遅い、サイズが大きい、メモリの使用量が多いなどの問題が挙げられていますね。アプリの起動速度が遅い場合は、変更があった場合の素早い反映が期待できません。アプリのサイズが大きいのとメモリ使用量が多いとインスタンスが増えれば増えるほどコストが高くなるということになりますね。また、これはマイクロサービスだけの話でもないです。サーバレスアプリで、あえてJavaScirptやPythonのようなインタプリタ言語を採用しているのも同じ理由があってこそですね。&lt;/p>
&lt;p>では、これらの問題はどうやって回避できるのでしょうか。そもそもの問題から考えると、全てが全てSpringに局限する問題でもないはずです。他のフレームワークに比べてSpringの起動時間が決して早いとは言えなかったり、メモリの使用量が多いという問題があるのは確かですが、JVMをベースにしている言語を使う限り、ある程度は仕方ない問題にも見えます。JVM言語においてはそのアプリの起動時間、サイズ、メモリ使用量のどれにもJVMが占める割合を含めて考える必要があるからですね。&lt;/p>
&lt;p>ただ、これらの問題を解決できる方法が全くないわけでもありません。今回紹介するのが、その答えとして開発されている&lt;a class="link" href="https://quarkus.io" target="_blank" rel="noopener"
>Quarkus&lt;/a>です。&lt;/p>
&lt;h2 id="quarkusとは">Quarkusとは&lt;/h2>
&lt;p>Quarkusは、&lt;a class="link" href="https://www.redhat.com/ja/technologies/linux-platforms/enterprise-linux" target="_blank" rel="noopener"
>RHEL&lt;/a>で有名なRed Hatが作ったJava用のウェブフレームワークです。公式ホームページの説明が何よりも正確だと思いますので、以下の文を確認してください。&lt;/p>
&lt;blockquote>
&lt;p>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.&lt;/p>
&lt;/blockquote>
&lt;p>Javaのアプリを&lt;code>Kubernetes Native&lt;/code>として作成できる、というのがこのフレームワークの正体性です。Javaと説明していますが、もちろんKotlinのような他のJVM言語も使えるので、そのような言語を使っている場合でも導入を考えられます。&lt;/p>
&lt;p>ここで&lt;code>Kubernetes Native&lt;/code>という言葉が気になりますが、これは単純にコンテナを作ることに特化されている、という表現ではないと思います。Spring Boot 2.3から導入された&lt;a class="link" href="https://spring.io/blog/2020/08/14/creating-efficient-docker-images-with-spring-boot-2-3" target="_blank" rel="noopener"
>Docker Image作成機能&lt;/a>があり、Googleが提供している&lt;a class="link" href="https://github.com/GoogleContainerTools/jib" target="_blank" rel="noopener"
>Jib&lt;/a>のようなライブラリでいくらでもJavaアプリケーションをコンテナ化することができますし、そのほかにもコンテナを作る方法はいくらでもあります。なので、ここで&lt;code>Kubernetes Native&lt;/code>という表現をあえて使っているのは、Kubernetesに特化したものとして設計されているということを意味すると思った方が自然でしょう。&lt;/p>
&lt;p>では、一体何を持って&lt;code>Kubernetes Native&lt;/code>と言えるのでしょう。インフラストラクチャの観点でいう&lt;code>Kubernetes Native&lt;/code>は、Kubernetesだけで完結するアーキテクチャを指しているようです。Kubernetesで完結するということは、それに合わせて最適化しているということと同じ意味合いでしょう。アプリケーションの観点からしてもそれは大きく違わないはずです。まず、Quarkusでは以下のような特徴があると紹介されています。&lt;/p>
&lt;ul>
&lt;li>Nativeコンパイルができる&lt;/li>
&lt;li>起動速度が速い&lt;/li>
&lt;li>メモリ使用量が少ない&lt;/li>
&lt;/ul>
&lt;p>Nativeコンパイルができるということは、JVMを使用する必要がなくなるということなので、先に挙げた三つの問題を全部解消できます。だとすると、マイクロサービスやサーバレスのみでなく、コンテナ単位でのデプロイでもかなり有利になりますね。そして、JVMを使った場合でも他のフレームワークに比べて起動速度とメモリ使用量で優位にあると言われているので、これが本当だとNativeコンパイルしない場合でも十分メリットがあると思われます。&lt;/p>
&lt;h2 id="実際触ってみると">実際触ってみると&lt;/h2>
&lt;p>特徴として挙げられているもの全てが魅力的ではありますが、実際そのフレームワークを使ってみないとわからないこともあります。なので、ちょっとしたサンプルを作り触ってみました感想について少し述べたいと思います。&lt;/p>
&lt;h3 id="起動速度">起動速度&lt;/h3>
&lt;h4 id="spring-bootの場合">Spring Bootの場合&lt;/h4>
&lt;p>Springの起動速度は、DIしているクラスによって大きく異なるので、ここでは&lt;a class="link" href="https://start.spring.io" target="_blank" rel="noopener"
>Spring initializr&lt;/a>から以下の項目のみ設定したアプリケーションを使って起動してみました。&lt;/p>
&lt;ul>
&lt;li>Project: Gradle&lt;/li>
&lt;li>Language: Kotlin&lt;/li>
&lt;li>Spring Boot: 2.5.5&lt;/li>
&lt;li>Packaging: War&lt;/li>
&lt;li>Java: 11&lt;/li>
&lt;li>Dependencies: なし&lt;/li>
&lt;/ul>
&lt;p>そしてローカルでは、Oracle JDK 17を使って起動しています。気のせいかも知れませんが、Java 11を使っていた時より起動が早いような気がしますね。とりわけ、上記通りの設定を済ましたアプリを起動してみると、以下のような結果となりました。（ローカルマシンの情報は消しています）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> . ____ _ __ _ _
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /&lt;span style="color:#f1fa8c">\\&lt;/span> / ___&lt;span style="color:#f1fa8c">&amp;#39;_ __ _ _(_)_ __ __ _ \ \ \ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">( ( )\___ | &amp;#39;&lt;/span>_ | &lt;span style="color:#f1fa8c">&amp;#39;_| | &amp;#39;&lt;/span>_ &lt;span style="color:#f1fa8c">\/&lt;/span> _&lt;span style="color:#f1fa8c">`&lt;/span> | &lt;span style="color:#f1fa8c">\ \ \ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#f1fa8c">\\&lt;/span>/ ___&lt;span style="color:#ff79c6">)&lt;/span>| |_&lt;span style="color:#ff79c6">)&lt;/span>| | | | | &lt;span style="color:#ff79c6">||&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>_| | &lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39; |____| .__|_| |_|_| |_\__, | / / / /
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> =========|_|==============|___/=/_/_/_/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> :: Spring Boot :: (v2.5.5)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:21.472 INFO 48844 --- [ main] com.example.demo.DemoApplicationKt : Starting DemoApplicationKt using Java 17 on Local.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:21.475 INFO 48844 --- [ main] com.example.demo.DemoApplicationKt : No active profile set, falling back to default profiles: default
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.058 INFO 48844 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.067 INFO 48844 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.068 INFO 48844 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.53]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.117 INFO 48844 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.118 INFO 48844 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 607 ms
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.335 INFO 48844 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &amp;#39;&lt;/span>&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-17 19:10:22.342 INFO &lt;span style="color:#bd93f9">48844&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span> main&lt;span style="color:#ff79c6">]&lt;/span> com.example.demo.DemoApplicationKt : Started DemoApplicationKt in 1.129 seconds &lt;span style="color:#ff79c6">(&lt;/span>JVM running &lt;span style="color:#ff79c6">for&lt;/span> 1.396&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JVMの起動に1.396秒、アプリの起動に1.129秒がかかっていますね。何も依存関係がないので、おそらくこれが自分のマシンでは最速の起動時間と言えるのではないかと思います。これが実際の業務用のアプリとなると、アプリの起動だけで10秒以上かかることもあリますね。一回の起動では10秒でもあまり問題になることはありませんが、ローカルでのテストではテストごとにアプリが起動するような&lt;/p>
&lt;h4 id="quarkus-nativeの場合">Quarkus Nativeの場合&lt;/h4>
&lt;p>では、Quarkusの場合を見ていきたいと思います。まずNativeコンパイルができるというので、&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>を利用してビルドしてみました。実際のビルドはGradleのタスクとして実行できて（固有のパラメータは必要ですが）、簡単です。そしてそれを実行してみた結果が以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>__ ____ __ _____ ___ __ ____ ______
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --/ __ &lt;span style="color:#f1fa8c">\/&lt;/span> / / / _ | / _ &lt;span style="color:#f1fa8c">\/&lt;/span> //_/ / / / __/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -/ /_/ / /_/ / __ |/ , _/ ,&amp;lt; / /_/ /&lt;span style="color:#f1fa8c">\ \ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&lt;span style="color:#f1fa8c">\_&lt;/span>__&lt;span style="color:#f1fa8c">\_\_&lt;/span>___/_/ |_/_/|_/_/|_|&lt;span style="color:#f1fa8c">\_&lt;/span>___/___/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,395 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> quarkus-sample 1.0.0-SNAPSHOT native &lt;span style="color:#ff79c6">(&lt;/span>powered by Quarkus 2.3.0.Final&lt;span style="color:#ff79c6">)&lt;/span> started in 0.018s. Listening on: http://0.0.0.0:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,397 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> Profile prod activated.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,397 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> Installed features: &lt;span style="color:#ff79c6">[&lt;/span>cdi, config-yaml, kotlin, resteasy-reactive, resteasy-reactive-jackson, smallrye-context-propagation, vertx&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>0.018秒がかかっています。ビルドしたプロジェクトの構造が単純であるのもありますが、それでもこの起動速度は確かに速いですね。これなら確かにマイクロサービスだけでなく、リクエストの多いサーバレスアプリケーションでも十分使えると思います。&lt;/p>
&lt;h4 id="quarkus-jvmの場合">Quarkus JVMの場合&lt;/h4>
&lt;p>Springの場合と同じく、Oracle JDK 17を利用して起動してみました。Quarkusには開発モードというものがあり、サーバを起動したまま修正ができるのですが、ここではあえてJarを作って起動しています。余談ですが、Springでは依存関係を全部含む場合はwarになりますが、Quarkusではuber-jarと言っているのが面白いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>__ ____ __ _____ ___ __ ____ ______
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --/ __ &lt;span style="color:#f1fa8c">\/&lt;/span> / / / _ | / _ &lt;span style="color:#f1fa8c">\/&lt;/span> //_/ / / / __/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -/ /_/ / /_/ / __ |/ , _/ ,&amp;lt; / /_/ /&lt;span style="color:#f1fa8c">\ \ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&lt;span style="color:#f1fa8c">\_&lt;/span>__&lt;span style="color:#f1fa8c">\_\_&lt;/span>___/_/ |_/_/|_/_/|_|&lt;span style="color:#f1fa8c">\_&lt;/span>___/___/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,897 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> quarkus-sample 1.0.0-SNAPSHOT on JVM &lt;span style="color:#ff79c6">(&lt;/span>powered by Quarkus 2.3.0.Final&lt;span style="color:#ff79c6">)&lt;/span> started in 0.761s. Listening on: http://0.0.0.0:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,905 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> Profile prod activated.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,906 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> Installed features: &lt;span style="color:#ff79c6">[&lt;/span>cdi, config-yaml, kotlin, resteasy-reactive, resteasy-reactive-jackson, smallrye-context-propagation, vertx&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回は0.761秒がかかりました。Nativeと比べると確かに数十倍も遅くなっていますが、それでもSpringと比べ速い方ですね。&lt;/p>
&lt;p>こうやってアプリの起動が速くなると、ローカルで開発するときもユニットテストが早くなるので即座で確認ができるというメリットもあるかと思います。特にSpringで[RestTemplate]や&lt;a class="link" href="https://spring.pleiades.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/reactive/server/WebTestClient.html" target="_blank" rel="noopener"
>WebTestClient&lt;/a>などを使ったテストケースを書くとテストごとにアプリを起動することになるので、テストケースが増えれば増えるほどかかる時間が多いのが辛いものですね。なので、起動が速いと同じようなテストをQuarkusで書いてもかなり時間が節約できそうです。&lt;/p>
&lt;h3 id="springからの移行が簡単">Springからの移行が簡単&lt;/h3>
&lt;p>最初あまり意識してなかった部分ですが、Quarkusの良い点の一つは、Springからの移行が簡単ということです。アプリを新規に開発するときや既存のアプリのフレームワークを変更する場合には、技術選定において色々と考慮すべきものや観点があると思いますが、その中でいくつかを取り上げると「いかに工数を減らせるか」、「エンジニアを募集しやすいか」などがあるのはないかと思います。こういう観点からすると、現在のエンジニアにとって全く新しい技術だったり、業界であまり使われてない技術だったりすると会社としてもエンジニアとしても大変でしょう。こういう問題があるので、企業にとって新しい技術の導入は難しくなっていると思います。&lt;/p>
&lt;p>なので、新しい技術でありながらも業界でよく使われているものと似ているという点は、エンジニアの学習コストを減らせるのでかなりのメリットと言えるでしょう。では、実際のコードを観ながら、SpringのコードをQuarkusに移行するとした場合はどうなるかを見ていきたいと思います。&lt;/p>
&lt;h4 id="springの場合">Springの場合&lt;/h4>
&lt;p>まず、クエリパラメータにIDを渡し、Personというレコードのデータを取得するAPIがあるとしましょう。Springなら、以下のようなコードになるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@RestController
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@RequestMapping(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonController&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GetMapping
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#50fa7b">PresonResponse&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonService&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> repository.findById(id).let { &lt;span style="color:#50fa7b">PersonDto&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="ktorの場合">Ktorの場合&lt;/h4>
&lt;p>Quarkusのコードを見る前に、まず同じコードをこのブログでも紹介したことのある&lt;a class="link" href="https://ktor.io/" target="_blank" rel="noopener"
>Ktor&lt;/a>で書くとどうなるかをまず見ていきたいと思います。これでSpringと全く違うフレームワークを選ぶという場合の比較ができるでしょう。&lt;/p>
&lt;p>Ktorもよいフレームワークではありますが、フレームワークそのものの設計思想はSpringと異なるので、既存のアプリを移行するとしたら色々と考慮すべきものが多いです。例えば、基本的にDIに対応していないのでライブラリを別途導入する必要がありますね。&lt;/p>
&lt;p>以下は、上記のSpringと同じAPIを、DIライブラリとして&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>を導入して実装したKtorの例です。かなり違う構造になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// DIの設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> personModule = module {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single { PersonService(&lt;span style="color:#ff79c6">get&lt;/span>()) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single { PersonRepository() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Koinをアプリにインストール
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> install(Koin) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modules(personModule)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ルーティングをモジュール化して設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> configureRouting()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ルータにControllerを登録
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Application&lt;/span>.configureRouting() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> personController()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Route&lt;/span>.personController() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Serviceのインジェクション
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PersonService &lt;span style="color:#ff79c6">by&lt;/span> inject()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/person&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#50fa7b">PresonResponse&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Service
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonService&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> repository.findById(id).let { &lt;span style="color:#50fa7b">PersonDto&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="quarkusの場合">Quarkusの場合&lt;/h4>
&lt;p>では、続いてQuarkusでAPIを作成した場合のコードを見ていきましょう。QuarkusでAPIを作成する方法は&lt;a class="link" href="https://resteasy.github.io" target="_blank" rel="noopener"
>RESTEasy&lt;/a>と&lt;a class="link" href="https://quarkus.io/guides/reactive-routes" target="_blank" rel="noopener"
>Reactive Routes&lt;/a>の二つのパターンがありますが、どちらを使った場合でもアプリの作成そのものに大きい違いはないので、ここではRESTEasyを使った実装を紹介したいと思います。まずは以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Path(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonController&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GET
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#50fa7b">PresonResponse&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@ApplicationScoped
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonService&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> repository.findById(id).let { &lt;span style="color:#50fa7b">PersonDto&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Springのコードど比較して、使っているアノテーションの種類が違うだけで、ほぼ同じ感覚で実装ができるのがわかります。なので、Ktorの場合のようにアーキテクチャを考え直す必要もなく、移行も簡単になるわけですね。また、RESTEasyを使う場合、ReactiveのAPIを作りやすいというメリットもあります。Reactiveだと&lt;a class="link" href="https://smallrye.io/smallrye-mutiny/" target="_blank" rel="noopener"
>Mutiny&lt;/a>を使うことになりますが、Uni/Multiの概念がMono/Fluxと1:1対応していると思って良いので、Spring WebFluxや他のReactive Streamを触ったことのある方ならすぐに適応できそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Path(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonController&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GET
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): Uni&amp;lt;PersonResponse&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#50fa7b">Uni&lt;/span>.createFrom().item(service.getPerson(id).let { &lt;span style="color:#50fa7b">PresonResponse&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KtorやSpring WebFluxのRouter Functionのような書き方もそれなりの良い点はあるかと思いますが、やはりSpring MVCのような書き方に慣れている人も多いだろうし、そのような書き方で特に問題になることもないので、新しいフレームワークだとしてもこのように既存のものと同じような感覚でコードを書けるというのもそのフレームワークを選択しやすくする一つのセールズポイントになるのではないかと思います。例えば&lt;a class="link" href="https://nestjs.com/" target="_blank" rel="noopener"
>NestJS&lt;/a>のように、JavaScript用のフレームワークでもSpring MVCに似たようなコードを書けるのですが、おそらくこれもまたSpringを触った経験のあるエンジニアにアピールするためでしょう。&lt;/p>
&lt;p>こういう面からすると、すでにSpringの経験があるエンジニアならすぐにQuarkusに移行できて、既存のSpringプロジェクトも簡単に移行できそうなので良さそうです。&lt;/p>
&lt;h2 id="懸念">懸念&lt;/h2>
&lt;p>Quarkusを実際触ってみて、最も良いと思われたのは上記の通りですが、Nativeでアプリをビルドしながら、いくつかの懸念もあると感じました。例えば以下のようなものがあります。&lt;/p>
&lt;h3 id="nativeのビルドは遅い">Nativeのビルドは遅い&lt;/h3>
&lt;p>Nativeで起動速度が早くなるのは確かに良いところですが、問題はビルド自体は遅いということです。当然ながら、Nativeとしてビルドするということは、最初から全てのコードをマシンコードとしてコンパイルするということを意味します。JVM用のバイトコードはどの環境でも同じですが、マシンコードはそうではないので、そのプラットフォームに合わせたコードを生成するのに時間がかかるのは当然のことですね。例えば、ローカルでテストに使ったプロジェクトをNativeイメージとしてビルドした場合は以下のような時間がかかりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ./gradlew build -Dquarkus.package.type&lt;span style="color:#ff79c6">=&lt;/span>native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; Task :quarkusBuild
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>building quarkus jar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> classlist: 2,311.58 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>cap&lt;span style="color:#ff79c6">)&lt;/span>: 3,597.91 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> setup: 5,450.32 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>19:22:21,827 INFO &lt;span style="color:#ff79c6">[&lt;/span>org.jbo.threads&lt;span style="color:#ff79c6">]&lt;/span> JBoss Threads version 3.4.2.Final
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>clinit&lt;span style="color:#ff79c6">)&lt;/span>: 779.71 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>typeflow&lt;span style="color:#ff79c6">)&lt;/span>: 14,308.32 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>objects&lt;span style="color:#ff79c6">)&lt;/span>: 16,140.38 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>features&lt;span style="color:#ff79c6">)&lt;/span>: 1,145.40 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> analysis: 33,857.15 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> universe: 1,718.32 ms, 5.14 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>parse&lt;span style="color:#ff79c6">)&lt;/span>: 2,635.36 ms, 5.14 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>inline&lt;span style="color:#ff79c6">)&lt;/span>: 7,363.76 ms, 5.99 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>compile&lt;span style="color:#ff79c6">)&lt;/span>: 26,314.40 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> compile: 40,954.87 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> image: 10,493.47 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> write: 2,111.59 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>total&lt;span style="color:#ff79c6">]&lt;/span>: 97,207.01 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BUILD SUCCESSFUL in 1m 43s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CIでビルドを行っていたり、頻繁にアプリの修正とデプロイが必要な場合にこれでかなりボトルネックになる可能性もあるかと思います。マシンパワーが十分か、デプロイまでの時間があまり気にならない場合は問題にならないと思いますが、起動速度が大事であるなら、その分ビルドに時間がかかると結局は同等のトレードオフになるだけですね。こういう場合はJarとしてビルドする時間や、他のフレームワークを使ってビルド〜起動までにかかる時間を測定してから判断した方が良いかなと思います。&lt;/p>
&lt;h3 id="ピークパフォーマンス">ピークパフォーマンス&lt;/h3>
&lt;p>一般的にCやC++のような言語と比べ、Java(JVM言語)は性能で劣るという話は常識のように受け入れられています。しかし、全ての状況においてそういうわけでもありません。適切なアルゴリズム、アプリケーションのデザインなど言語そのものとは無関係と言えることが理由な場合もありますが、言語の特性を考えてもそういうケースがあるということです。なぜなら、CやC++のようなネイティブコードを生成する言語と、JVM言語のコンパイラの特性が違うからです。&lt;/p>
&lt;p>仮想マシンを挟み、バイトコードをマシンコードにもう一度変換する必要があるJVM言語と比べ、最初からマシンコードを生成する言語の方が性能が優秀であることは当然です。実際それは数値としても表れていて、Javaが登場した当時には性能問題で色々と批判を受けていたらしいですね。今はJavaが比較的性能が大事であるサーバサイドアプリケーションを作成する場合によく採用されていますが、これも「ハードウェアの発展がある」からと言われるケースも多いです。&lt;/p>
&lt;p>ただ、全ての場合においてJVMを挟むアプリケーションがNativeより遅いわけでもありません。なぜなら、コンパイルには「最初から全てコンパイルしておく」&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E4%BA%8B%E5%89%8D%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9" target="_blank" rel="noopener"
>AOT&lt;/a>だけでなく、「必要に応じてコンパイルする」&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%AE%9F%E8%A1%8C%E6%99%82%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9" target="_blank" rel="noopener"
>JIT&lt;/a>の方式もあるからです。&lt;/p>
&lt;p>JVMではJITによりバイトコードの分析と最適化を行い、マシンコードを生成することでより良い性能のコーどを作り出すと言われています。ここで最適化とは、利用頻度の高いメソッドや定数などを含めてオーバヘッドを減らすことを含みます。このような最適化が行われたコードをマシンコードに変換するとしたら、当然性能がより良くなることを期待できますね。ただ、ITは全ての場合に動作してくれるわけでもありません。コンパイルには時間とマシンパワーが必要なので、一度しか利用されないコードをいちいちマシンコードに変換するのは無駄なことですね。なので、JITでコンパイルされるコードは、そのコードの利用頻度により決定されます。よくJavaのマイクロベンチマークで使われている&lt;a class="link" href="https://github.com/openjdk/jmh" target="_blank" rel="noopener"
>JMH&lt;/a>でテストを行うとき、事前にウォーミングアップをおこなっているのも、JITによる最適化でベンチマークの精度を上げるための工夫です。&lt;/p>
&lt;h4 id="検証してみると">検証してみると&lt;/h4>
&lt;p>実際NativeかJVMかによってどれくらいランタイム性能が違うのか気になったので、ループで10万件のデータを作って返すだけのServiceを作成して処理時間を計測してみました。ここでControllerの戻り値に&lt;a class="link" href="https://smallrye.io/smallrye-mutiny/getting-started/creating-multis" target="_blank" rel="noopener"
>Multi&lt;/a>を使ったせいか、APIが呼び出されるたびにレスポンスまでの時間が大きく変化していたので、測定しているのはリクエストからレスポンスまでの時間より「forループによるデータの生成にかかった時間」を計測していると理解してください。&lt;/p>
&lt;p>NativeビルドとJarの実行に使ったのはどれもGraalVM CE 21.3.0(OpenJDK 11)で、処理時間の測定はKotlinの&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.system/measure-time-millis.html" target="_blank" rel="noopener"
>measureTimeMillis&lt;/a>で取得した値をログに吐くという方法を使っています。&lt;/p>
&lt;p>まずNativeで起動した場合の結果です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:14,061 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-6&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">89&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:15,630 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-1&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">52&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:17,079 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-15&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">106&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:18,174 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-5&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">49&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:19,523 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-11&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">50&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:20,468 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-4&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">50&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:21,739 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-7&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">124&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:23,113 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-12&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">53&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:24,073 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-13&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">49&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:25,308 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-2&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">53&lt;/span> ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、以下がJVMで起動した場合の結果です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:32,240 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-8&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">163&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:35,057 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-6&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">33&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:39,418 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-11&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">40&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:42,211 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-3&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">25&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:44,149 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-10&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">38&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:46,283 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-2&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">24&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:48,262 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-20&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">22&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:49,854 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-12&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">26&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:51,552 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-23&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">23&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:52,967 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-7&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">51&lt;/span> ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>やはりJITが関与しているせいか、JVMでは最初の実行で時間がかかっていて、その次から大幅に処理速度が早くなっているのがわかります。GraalVMのコンパイラのバージョンアップでさらにパフォーマンスが向上する可能性はあると思われますが、それはJVMの場合でも同じなので、どうしてもランタイムのピークパフォーマンスが大事な場合はJVMの利用を考慮しても良いかなと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>本当はメモリ使用量などをより正確に測る必要があると思いますが、それに関してはすでに&lt;a class="link" href="https://medium.com/swlh/springboot-vs-quarkus-a-real-life-experiment-be70c021634e" target="_blank" rel="noopener"
>記事があったので&lt;/a>、ここでは割愛します。結論から言いますと、確かにメモリ使用量はヒープを含めQuarkusの方が少ないですが、CPU使用量の最大値とLatencyにおいてはSpring Bootの方が優れているのを確認しました。ただ、ここはQuarkusの方が歴史が短いためであるということもありそうですね。&lt;/p>
&lt;p>とりあえず触ってみた感覚では、確かにKubernetes nativeと言えるだけのものではあると思われます。Nativeビルドしてみると、Jarと比べアプリのサイズ自体は大きくなるものの（倍ほど）、JDKがいらなくなるというのも良いですね。JDKのサイズはAdoptOpenJDKを基準におよそ300MBくらいです。インスタンスが一つの場合だとしたらあまり問題になりそうではないですが、もしインスタンスが増えるとしたらJDKだけでも必要なストレージのサイズが乗数で増えることになるので、Nativeにしたくもなるかなと思います。&lt;/p>
&lt;p>そのほかにも、さまざまなライブラリやフレームワークの組み合わせができるし、Spring Securityなどをそのまま用いることができるのも魅力的です。Springの経験のあるエンジニアなら誰でもすぐに慣れそうなので、会社の立場からも他のフレームワークを使う場合に比べ比較的エンジニアの募集に負担がなくなるのでは、と思ったりもします。&lt;/p>
&lt;p>Spring WebFluxやKtorもよかったのですが、また新しい強者が現れてどれを使うか悩ましい時代になりましたね。本当は&lt;a class="link" href="https://rocket.rs/" target="_blank" rel="noopener"
>Rocket&lt;/a>も触ってみたいんですが、果たして今年内にできるかどうか…&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Java 17は何が変わったか</title><link>https://retheviper.github.io/posts/java-enter-to-17/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-enter-to-17/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Java 17は何が変わったか" />&lt;p>今月は新しいLTSバージョンであるJava 17のリリースがありました。まだJava 1.8を使っている案件も多いかなと思いますが、Java 1.8は2022年まで、Java 11は2023年までのサポートとなるので、いずれにせよJava 17に移行する必要はあるかなと思います。特にJava 9からモジュールが導入されたため、8からの移行はかなり大変だったらしいですが、11から移行する場合はそれほどでもないと言われているので、今からでも17では何が変わっているか、目を通しておくのもそう悪くはないでしょう。&lt;/p>
&lt;p>現時点では&lt;a class="link" href="https://adoptium.net" target="_blank" rel="noopener"
>Eclipse Temurin&lt;/a>(旧AdoptOpenJDK)、&lt;a class="link" href="https://www.azul.com/downloads/" target="_blank" rel="noopener"
>Zulu&lt;/a>などの有名JDKはほとんどが17のリリースを完了しているか、対応の最中にありますね。また、&lt;a class="link" href="https://www.itmedia.co.jp/news/articles/2109/15/news147.html" target="_blank" rel="noopener"
>Oracle JDK 17は無料に&lt;/a>なったので、こちらを選ぶもの悪くない選択肢の一つかも知れません。&lt;/p>
&lt;p>また、こういう無料化やJDKの多様化のみでなく、GoogleとOracleの訴訟の件もGoogleの勝利で終わったので、AndroidでもJava 17を使える可能性ができた以上、これからJava 17を使える場面は増えてくるかも知れません。実際、まだ遠い話ではあります、Springを使う場合、2022年の&lt;a class="link" href="https://spring.io/blog/2021/09/02/a-java-17-and-jakarta-ee-9-baseline-for-spring-framework-6" target="_blank" rel="noopener"
>Spring 6はJava 17がベースラインとなる&lt;/a>らしいですね。なので、Java 11は採択されてなかった現場でも、サポート期間などを考慮して17に転換する可能性はあると思います。&lt;/p>
&lt;p>というわけで、今回はそんなJava 17では何が変わったかを述べていきますが、大きく分けて新しい予約語の追加、新しい書き方など言語スペックとして変わったものと、新しく追加されたAPIという二つの観点でその変化を辿っていきたいと思います。案件によってはJava 1.8から17に移行するケースもあるかと思いますが、9〜11までの間にあった変更事項や新しいAPIなどはこのブログでも扱っていて、他でも参考にできるサイトが多いと思いますので、今回は8~11までの変化については割愛し、11〜17の間の変化だけを扱うことにさせてください。&lt;/p>
&lt;h2 id="言語スペック">言語スペック&lt;/h2>
&lt;h3 id="new-macos-rendering-pipeline-17">New macOS Rendering Pipeline (17)&lt;/h3>
&lt;p>macOSでは長い間、SwingなどJavaの2Dレンダリングに&lt;a class="link" href="https://www.opengl.org/" target="_blank" rel="noopener"
>OpenGL&lt;/a>を使っていましたが、新しい&lt;a class="link" href="https://developer.apple.com/metal/" target="_blank" rel="noopener"
>Metal framework&lt;/a>を導入しながら、10.14からOpenGLは&lt;code>deprecated&lt;/code>となりました。&lt;/p>
&lt;p>従ってJava側でも、Metalを利用する新しいグラフィック・レンダリング・パイプラインを実装するという&lt;a class="link" href="https://openjdk.java.net/projects/lanai/" target="_blank" rel="noopener"
>Project Lanai&lt;/a>が進められていましたが、17から&lt;a class="link" href="https://openjdk.java.net/jeps/382" target="_blank" rel="noopener"
>New macOS Rendering Pipeline&lt;/a>という名で導入されました。JavaであまりGUIを使うことないのでは？と思いがちかと思いますが、intellijのようなJavaベースのIDEでも画面描画で性能向上があるという噂です。ただ、intellijでは基本的に&lt;a class="link" href="https://confluence.jetbrains.com/display/JBR/JetBrains&amp;#43;Runtime" target="_blank" rel="noopener"
>Jetbrains Runtime&lt;/a>を使っていて、現時点ではそれがJava 17に対応していないので少し待つ必要はあります。&lt;/p>
&lt;h3 id="macosaarch64-port-17">macOS/AArch64 Port (17)&lt;/h3>
&lt;p>17からはM1など、&lt;a class="link" href="https://openjdk.java.net/jeps/391" target="_blank" rel="noopener"
>Apple Siliconを搭載した新しいMacに対応&lt;/a>しました。&lt;a class="link" href="https://www.azul.com/downloads/" target="_blank" rel="noopener"
>Zulu&lt;/a>などの他のJDKでは独自に対応してるケースもありましたが、OpenJDK(OracleJDK)で対応したことで、これをベースとする&lt;a class="link" href="https://adoptium.net/" target="_blank" rel="noopener"
>Eclipse Temurin&lt;/a>や&lt;a class="link" href="https://www.microsoft.com/openjdk" target="_blank" rel="noopener"
>Microsoft Build of OpenJDK&lt;/a>のような他のJDKでも自然にARMベースMacでネイティブとして使えるということになると思います。&lt;/p>
&lt;h3 id="record-17">Record (17)&lt;/h3>
&lt;p>14からPreviewとして導入された&lt;code>Record&lt;/code>が、17ではstableになり正式に導入されました。指定したフィールドを&lt;code>private final&lt;/code>にして、コンストラクタ、&lt;code>getter&lt;/code>、&lt;code>toString&lt;/code>、&lt;code>hashcode&lt;/code>、&lt;code>equals&lt;/code>などを自動生成してくれるものです。最初は&lt;code>Lombok&lt;/code>の&lt;a class="link" href="https://projectlombok.org/features/Data" target="_blank" rel="noopener"
>@Data&lt;/a>のようなものかと思いきや、実際は&lt;a class="link" href="https://projectlombok.org/features/Value" target="_blank" rel="noopener"
>@Value&lt;/a>に近いものになっていますね。値はコンストラクタでしか渡せなくて、後から変更はできなくなります。こういうところは、フィールドを&lt;code>val&lt;/code>として指定したKotlinの&lt;code>data class&lt;/code>に近い感覚でもあります。なので、実際の使用例を見ると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Recordの定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>record &lt;span style="color:#50fa7b">MyRecord&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String name&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> number&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インスタンスの作成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>MyRecord myRecord &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> MyRecord&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;my record&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// フィールドの取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>String myRecordsName &lt;span style="color:#ff79c6">=&lt;/span> myRecord&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">name&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> myRecordsNumber &lt;span style="color:#ff79c6">=&lt;/span> myRecord&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">number&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>Named Arguments&lt;/a>に対応しているのですが、Javaではまだそのような機能がないので、&lt;code>Record&lt;/code>だとフィールドが多くなるとどれがどれだかわからなくなりそうな気はします。これに対してKotlin側で&lt;code>Record&lt;/code>を使う場合、何らかのラッパークラスを作って対応するなどの方法は考えられますね。もしくは普通に&lt;code>setter&lt;/code>をもつDTOを定義するか、builderパターンを利用する方が良いでしょう。&lt;/p>
&lt;p>また、&lt;code>Record&lt;/code>では&lt;code>getter&lt;/code>名もフィールド名そのままになるという特徴もありますが、自動生成されるコンストラクタをカスタマイズするときも少し書き方が違うという特徴があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>record &lt;span style="color:#50fa7b">MyRecord&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String name&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> number&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// コンストラクタにバリデーションをつける例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> MyRecord &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>name&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">isBlank&lt;/span>&lt;span style="color:#ff79c6">())&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> IllegalArgumentException&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、&lt;code>Record&lt;/code>として定義しても実際は&lt;code>Class&lt;/code>が作られることになるので、以下のようなこともできます。&lt;/p>
&lt;ul>
&lt;li>コンストラクタを追加する&lt;/li>
&lt;li>&lt;code>getter&lt;/code>をオーバライドする&lt;/li>
&lt;li>インナークラスとして&lt;code>Record&lt;/code>を定義する&lt;/li>
&lt;li>インターフェイスを実装する&lt;/li>
&lt;/ul>
&lt;p>また、&lt;code>Reflection&lt;/code>でもクラスが&lt;code>Record&lt;/code>であるかどうかを判定する&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Class.html#isRecord%28%29" target="_blank" rel="noopener"
>isRecord&lt;/a>も追加されています。&lt;/p>
&lt;h3 id="text-blocks-15">Text Blocks (15)&lt;/h3>
&lt;p>Javaでは長い間、HTMLやJSON、SQLなどをリテラルとして使うためにはエスケープや文字列の結合などを使う必要がありました。これはあまり可読性という面でよくなく、コードの修正も難しくなる問題がありましたね。例えば、HTMLを表現するとしたら以下のようなことをしていたかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String html &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;lt;html&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34; &amp;lt;body&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34; &amp;lt;h1&amp;gt;This is Java&amp;#39;s new Text block!&amp;lt;/h1&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34; &amp;lt;/body&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;lt;/html&amp;gt;\n&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String query &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;SELECT \&amp;#34;EMP_ID\&amp;#34;, \&amp;#34;LAST_NAME\&amp;#34; FROM \&amp;#34;EMPLOYEE_TB\&amp;#34;\n&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;WHERE \&amp;#34;CITY\&amp;#34; = &amp;#39;INDIANAPOLIS&amp;#39;\n&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;ORDER BY \&amp;#34;EMP_ID\&amp;#34;, \&amp;#34;LAST_NAME\&amp;#34;;\n&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>幸い、15から&lt;a class="link" href="https://openjdk.java.net/jeps/378" target="_blank" rel="noopener"
>Text Blocks&lt;/a>が導入され、他の言語のように簡単かつ可読性の高い文字列を定義することができるようになりました。これを使うとエスケープを意識しなくて良いので、複数行でなくても色々な分野で有効活用できそうですね。&lt;code>Text Blocks&lt;/code>を使って上記のコードを変えると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String html &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> &amp;lt;html&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> &amp;lt;body&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> &amp;lt;h1&amp;gt;This is Java&amp;#39;s new Text block!&amp;lt;/h1&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> &amp;lt;/body&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> &amp;lt;/html&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String query &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> SELECT &amp;#34;&lt;/span>EMP_ID&lt;span style="color:#f1fa8c">&amp;#34;, &amp;#34;&lt;/span>LAST_NAME&lt;span style="color:#f1fa8c">&amp;#34; FROM &amp;#34;&lt;/span>EMPLOYEE_TB&lt;span style="color:#f1fa8c">&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> WHERE &amp;#34;&lt;/span>CITY&lt;span style="color:#f1fa8c">&amp;#34; = &amp;#39;INDIANAPOLIS&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> ORDER BY &amp;#34;&lt;/span>EMP_ID&lt;span style="color:#f1fa8c">&amp;#34;, &amp;#34;&lt;/span>LAST_NAME&lt;span style="color:#f1fa8c">&amp;#34;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは全く同じ書き方で同じことができるので、ここでは割愛します。&lt;/p>
&lt;h3 id="sealed-class-17">Sealed Class (17)&lt;/h3>
&lt;p>JDK 15からPreviewで導入された&lt;a class="link" href="https://openjdk.java.net/jeps/409" target="_blank" rel="noopener"
>sealed classes&lt;/a>が、Stableとなりました。&lt;code>class&lt;/code>や&lt;code>interface&lt;/code>を&lt;code>sealed&lt;/code>にすれば、それを拡張・実装できるクラスやインターフェイスを限定できるようになります。こうすることで、ライブラリなどで勝手に拡張して欲しくないクラスやインターフェイスを守ることができますね。また、将来的には&lt;code>sealed&lt;/code>として定義されてあるクラスの子クラスを&lt;code>switch&lt;/code>の&lt;code>case&lt;/code>に指定するときは全部のケースが指定されているかどうかをコンパイラがチェックするようにするとかの話もあるようです。以下は、&lt;code>sealed&lt;/code>クラスが&lt;code>permits&lt;/code>キーワードを使って継承できるクラスを指定する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">abstract&lt;/span> sealed &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Shape&lt;/span> permits Circle&lt;span style="color:#ff79c6">,&lt;/span> Rectangle&lt;span style="color:#ff79c6">,&lt;/span> Square&lt;span style="color:#ff79c6">,&lt;/span> WeirdShape &lt;span style="color:#ff79c6">{&lt;/span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでも&lt;a class="link" href="https://kotlinlang.org/docs/sealed-classes.html" target="_blank" rel="noopener"
>Sealed Classes&lt;/a>は存在していますが、&lt;code>interface&lt;/code>を&lt;code>sealed&lt;/code>にするためには1.5以降を使う必要があって、拡張・実装できるクラスやインターフェイスを指定するわけではなく、コンパイルされたモジュール以外で&lt;code>sealed&lt;/code>として定義されているクラスやインターフェイスを拡張・実装できない仕様となっています。なので書き方的には、以下のようになります。より簡単ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">sealed&lt;/span> &lt;span style="color:#ff79c6">interface&lt;/span> &lt;span style="color:#50fa7b">Error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">sealed&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">IOError&lt;/span>(): Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">FileReadError&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> f: File): IOError()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">DatabaseError&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> source: DataSource): IOError()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">object&lt;/span> &lt;span style="color:#50fa7b">RuntimeError&lt;/span> : Error
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、Javaの場合は&lt;code>Record&lt;/code>と同じく、このクラスが&lt;code>sealed&lt;/code>であるかどうかを判定する&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Class.html#isSealed%28%29" target="_blank" rel="noopener"
>isSealed&lt;/a>が追加されています。&lt;/p>
&lt;h3 id="switch-expressions-14">Switch Expressions (14)&lt;/h3>
&lt;p>Java 12からPreviewで&lt;a class="link" href="https://openjdk.java.net/jeps/361" target="_blank" rel="noopener"
>Switch Expressions&lt;/a>が導入され、14からはStableになっています。従来の&lt;code>switch&lt;/code>を改善したもので、以下のようなことができるようになりました。&lt;/p>
&lt;ul>
&lt;li>&lt;code>case&lt;/code>をまとめて指定できる&lt;/li>
&lt;li>&lt;code>case&lt;/code>の処理をラムダのような書き方で記述できる&lt;/li>
&lt;li>&lt;code>case&lt;/code>の処理を戻り値にして、&lt;code>switch&lt;/code>を式として使える&lt;/li>
&lt;/ul>
&lt;p>例えば、&lt;code>day&lt;/code>というenumの値を見て、int値を返すメソッドを実装するとしましょう。従来の方法では以下のようになるはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> numLetters&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">switch&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>day&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> MONDAY&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> FRIDAY&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> SUNDAY&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> TUESDAY&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">7&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> THURSDAY&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> SATURDAY&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">8&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> WEDNESDAY&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">9&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">default&lt;/span>&lt;span style="color:#ff79c6">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> IllegalStateException&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Wat: &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> day&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の処理は新しい&lt;code>switch&lt;/code>では以下のように書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> numLetters &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">switch&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>day&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> MONDAY&lt;span style="color:#ff79c6">,&lt;/span> FRIDAY&lt;span style="color:#ff79c6">,&lt;/span> SUNDAY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> TUESDAY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">7&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> THURSDAY&lt;span style="color:#ff79c6">,&lt;/span> SATURDAY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">8&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> WEDNESDAY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">9&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinだと以下のようになるはずですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> numLetters = &lt;span style="color:#ff79c6">when&lt;/span> (day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Day&lt;/span>.MONDAY, &lt;span style="color:#50fa7b">Day&lt;/span>.FRIDAY, &lt;span style="color:#50fa7b">Day&lt;/span>.SUNDAY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Day&lt;/span>.TUESDAY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Day&lt;/span>.THURSDAY, &lt;span style="color:#50fa7b">Day&lt;/span>.SATURDAY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Day&lt;/span>.WEDNESDAY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>when&lt;/code>だとargumentなしでも使えて分岐を条件文によるものにすることもできるなどの特徴もあるので、使い勝手はJavaの&lt;code>switch&lt;/code>よりいいかなと思います。ただ、Javaでもバージョンアップと共に後述する機能も追加されてあるので、今後Kotlinのように色々と改良が行われる可能性はあるかと思いますね。&lt;/p>
&lt;h3 id="pattern-matching-for-instanceof-16--switch-17">Pattern Matching for instanceof (16) / switch (17)&lt;/h3>
&lt;p>Java 14からは、&lt;a class="link" href="https://openjdk.java.net/jeps/394" target="_blank" rel="noopener"
>Pattern Matching for instanceof&lt;/a>が導入され、16ではStableになりましt。今までは&lt;code>instanceof&lt;/code>を使ってオブジェクトのインスタンスの種類を判定した後、そのインスタンスの種類にあった処理を行うには以下のようにキャストが必要でしたね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> String &lt;span style="color:#50fa7b">formatter&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Object o&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String formatted &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;unknown&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>o &lt;span style="color:#ff79c6">instanceof&lt;/span> Integer&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#ff79c6">=&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;int %d&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>Integer&lt;span style="color:#ff79c6">)&lt;/span> i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一度どれのインスタンスかわかった上でさらにキャストをする必要はあるのはだるいし、ミスをしたら例外の原因にもなり得る問題がありますね。なので、&lt;code>Pattern Matching&lt;/code>を利用して、キャストをなくすことができるようになりました。&lt;code>instanceof&lt;/code>を使った条件文の中に、キャストする変数名を指定しておくと、&lt;code>if&lt;/code>分の中でそのまま自動にキャストされた変数を使えるようになります。なので、以下のようなことができるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> String &lt;span style="color:#50fa7b">formatter&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Object o&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String formatted &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;unknown&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>o &lt;span style="color:#ff79c6">instanceof&lt;/span> Integer i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#ff79c6">=&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;int %d&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>o &lt;span style="color:#ff79c6">instanceof&lt;/span> Long l&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#ff79c6">=&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;long %d&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> l&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>o &lt;span style="color:#ff79c6">instanceof&lt;/span> Double d&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#ff79c6">=&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;double %f&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> d&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>o &lt;span style="color:#ff79c6">instanceof&lt;/span> String s&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#ff79c6">=&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;String %s&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> s&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> formatted&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに、17からはPreviewとして&lt;a class="link" href="https://openjdk.java.net/jeps/406" target="_blank" rel="noopener"
>Pattern Matching for switch&lt;/a>が導入されています。これを使うと、&lt;code>instanceof&lt;/code>なしで、&lt;code>switch&lt;/code>文を使ったよりシンプルな処理を書けるようになります。これを先に紹介した&lt;code>Switch Expressions&lt;/code>と組み合わせることで、上記の処理は以下に変えることが可能になります。かなりシンプルになったのがわかりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> String &lt;span style="color:#50fa7b">formatterPatternSwitch&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Object o&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">switch&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>o&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> Integer i &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;int %d&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> Long l &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;long %d&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> l&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> Double d &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;double %f&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> d&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> String s &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;String %s&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> s&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">default&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> o&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toString&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="packaging-tool-16">Packaging Tool (16)&lt;/h3>
&lt;p>実行できるバイナリを生成する&lt;a class="link" href="https://openjdk.java.net/jeps/392" target="_blank" rel="noopener"
>Packaging Tool&lt;/a>が導入されています。これを使うと、Java runtimeとライブラリ、それぞれのOSにあった実行ファイルが一つのパッケージになる機能です。Java runtimeが含まれるということはOSのJavaのバージョンに関係なく実行できるものになるという意味なので、Javaのバージョンを固定したり、複数のアプリでそれぞれ違うバージョンのJavaを使って起動したい場合は役立つ機能かも知れません。&lt;/p>
&lt;h2 id="api">API&lt;/h2>
&lt;p>Java 17からは、APIドキュメントから、新しく追加されたAPIの一覧だけを見られるタブができたということです。今回は11以降に追加されたもののみですが、今後新しいLTSバージョンがリリースすると、17以降のものをこちらから確認できそうですね。新しいAPIの一覧は&lt;a class="link" href="https://download.java.net/java/early_access/jdk17/docs/api/new-list.html" target="_blank" rel="noopener"
>こちら&lt;/a>から確認できます。&lt;/p>
&lt;p>ここで全てのAPIの詳細まで探るのは難しいと思いますので、個人的に興味深いと思ったのを一部紹介したいと思います。&lt;/p>
&lt;h3 id="serial-14">@Serial (14)&lt;/h3>
&lt;p>&lt;code>java.io&lt;/code>パッケージに、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serial.html" target="_blank" rel="noopener"
>Serial&lt;/a>というアノテーションが追加されました。これは&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html" target="_blank" rel="noopener"
>Serializable&lt;/a>を実装したクラスで、そのシリアライズのメカニズムを&lt;code>@Override&lt;/code>するような機能のようです。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">SerializableClass&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">implements&lt;/span> Serializable &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Serial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> ObjectStreamField&lt;span style="color:#ff79c6">[]&lt;/span> serialPersistentFields&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Serial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">long&lt;/span> serialVersionUID&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Serial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">writeObject&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>ObjectOutputStream stream&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> IOException &lt;span style="color:#ff79c6">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Serial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">readObject&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>ObjectInputStream stream&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> IOException&lt;span style="color:#ff79c6">,&lt;/span> ClassNotFoundException &lt;span style="color:#ff79c6">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Serial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">readObjectNoData&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> ObjectStreamException &lt;span style="color:#ff79c6">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Serial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object &lt;span style="color:#50fa7b">writeReplace&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> ObjectStreamException &lt;span style="color:#ff79c6">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Serial
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object &lt;span style="color:#50fa7b">readResolve&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> ObjectStreamException &lt;span style="color:#ff79c6">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このアノテーションをつけることで、コンパイルタイムでエラーをキャッチできるのも特徴的です。例えば、このアノテーションを以下のようなクラスのメンバに使う場合はコンパイルエラーとなります。&lt;/p>
&lt;ul>
&lt;li>Serializableを実装してないクラス&lt;/li>
&lt;li>Enumのように、Serializeの効果がないクラス&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Externalizable.html" target="_blank" rel="noopener"
>Externalizable&lt;/a>を継承しているクラス&lt;/li>
&lt;/ul>
&lt;p>このようなアノテーションが追加されたことによって、JacksonやGsonなどのライブラリの実装にも何か影響があるかも知れません。&lt;/p>
&lt;h3 id="string">String&lt;/h3>
&lt;p>同じ文字列だとしても、Javaでは&lt;code>java.lang.String&lt;/code>、Kotlinでは&lt;code>kotlin.text.String&lt;/code>を使うことになるので、Kotlinを使う場合はあまりJavaのAPIを使うことはないかと思います（また、JavaでのString関連のAPIは、Kotlinだと&lt;code>deprecated&lt;/code>になるケースが多いです）。なので、ここでは新しいAPIと、Kotlinで同じような処理をするために使える方法を中心に紹介します。&lt;/p>
&lt;h4 id="formatted-15">formatted (15)&lt;/h4>
&lt;p>Javaでは&lt;code>String.format()&lt;/code>をで文字列をフォーマットとして使うことができました。多くの場合、文字列は&lt;code>+&lt;/code>を使うよりフォーマットを使った方が性能が良いと言われていて、よく使っていたものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;formatted string&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 15以前
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>String formattedString &lt;span style="color:#ff79c6">=&lt;/span> String&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">format&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;this is %s&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> name&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 15以降
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>String newFormattedString &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;this is %s&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">formatted&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>name&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Koltinだと&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/format.html" target="_blank" rel="noopener"
>String.format&lt;/a>と&lt;a class="link" href="https://kotlinlang.org/docs/basic-syntax.html#string-templates" target="_blank" rel="noopener"
>String Templates&lt;/a>が使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> name = &lt;span style="color:#f1fa8c">&amp;#34;formatted string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Format
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> formattedString = &lt;span style="color:#f1fa8c">&amp;#34;this is %s&amp;#34;&lt;/span>.format(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// String Template
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> templateString = &lt;span style="color:#f1fa8c">&amp;#34;this is &lt;/span>&lt;span style="color:#f1fa8c">$name&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="indent-12">indent (12)&lt;/h4>
&lt;p>&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#indent%28int%29" target="_blank" rel="noopener"
>indent&lt;/a>では、対象の文字列に引数で指定した分のwhite spaceを入れます。引数が&lt;code>int&lt;/code>型なので、負数を渡すことでwhite spaceを減らすこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String nonIndent &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデントを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>String indented10 &lt;span style="color:#ff79c6">=&lt;/span> nonIndent&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">indent&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">10&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> &lt;span style="color:#6272a4">// &amp;#34; A&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデントを削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>String indented5 &lt;span style="color:#ff79c6">=&lt;/span> indented10&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">indent&lt;/span>&lt;span style="color:#ff79c6">(-&lt;/span>&lt;span style="color:#bd93f9">5&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> &lt;span style="color:#6272a4">// &amp;#34; A&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合は、インデントを追加するための&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/prepend-indent.html" target="_blank" rel="noopener"
>prependIndent&lt;/a>や代替するするための&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/replace-indent.html" target="_blank" rel="noopener"
>replaceIndent&lt;/a>などがあり、渡すパラメータも文字列となるのでJavaのものとは少し使い方が違います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> nonIndent = &lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデントを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> prepended = nonIndent.prependIndent(&lt;span style="color:#f1fa8c">&amp;#34; &amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// &amp;#34; A&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデントを代替（なかった場合は追加）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> replaced = prepended.replaceIndent(&lt;span style="color:#f1fa8c">&amp;#34;|||||&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// &amp;#34;|||||A&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="stripindent-15">stripIndent (15)&lt;/h4>
&lt;p>&lt;code>Text Block&lt;/code>で複数行の文字列を扱う場合、ソースコード上の可読性の都合で任意のインデントを入れたら実際のデータとしては扱いづらい場合もあるはずです。ここでインデントを削除するためののものが&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#stripIndent%28%29" target="_blank" rel="noopener"
>stringIndent&lt;/a>です。&lt;/p>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html" target="_blank" rel="noopener"
>trimIndent&lt;/a>が同じ役割をしています。&lt;/p>
&lt;h4 id="transform-12">transform (12)&lt;/h4>
&lt;p>文字列に対して&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener"
>Function&lt;/a>を実行するという単純なAPIです。&lt;code>replace&lt;/code>では不可能な、条件による処理などが必要なときに使えそうです。実装を見ると極めて単純です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#ff79c6">&amp;lt;&lt;/span>R&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> R &lt;span style="color:#50fa7b">transform&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Function&lt;span style="color:#ff79c6">&amp;lt;?&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">super&lt;/span> String&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">?&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">extends&lt;/span> R&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> f&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> f&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">apply&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは文字列でも&lt;code>map&lt;/code>・&lt;code>filter&lt;/code>・&lt;code>reduce&lt;/code>のような高階関数が使えるのでこれらを使うこともできますね。もしくは以下のような拡張関数を定義することで同じことができるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">R&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">String&lt;/span>.transform(f: (String) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R): R = f(&lt;span style="color:#ff79c6">this&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="translateescapes-15">translateEscapes (15)&lt;/h4>
&lt;p>エスケープになっている一部の文字をリテラルに変えてくれる機能です。こちらはコードを見た方が理解が早いかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;this\\nis\\nmutli\\nline&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String escapeTranslated &lt;span style="color:#ff79c6">=&lt;/span> string&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">translateEscapes&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#6272a4">// &amp;#34;this\nis\nmutli\nline&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前は&lt;code>Matcher&lt;/code>と正規式を組み合わせるなど独自の処理を書くか、ライブラリに依存していたと思いますので、こういうのができると嬉しいですね。変換されるエスケープ文字は以下の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Escape&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Translation&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>\b&lt;/code>&lt;/td>
&lt;td>backspace&lt;/td>
&lt;td>U+0008&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\t&lt;/code>&lt;/td>
&lt;td>horizontal tab&lt;/td>
&lt;td>U+0009&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\n&lt;/code>&lt;/td>
&lt;td>line feed&lt;/td>
&lt;td>U+000A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\f&lt;/code>&lt;/td>
&lt;td>form feed&lt;/td>
&lt;td>U+000C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\r&lt;/code>&lt;/td>
&lt;td>carriage return&lt;/td>
&lt;td>U+000D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\s&lt;/code>&lt;/td>
&lt;td>space&lt;/td>
&lt;td>U+0020&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\&amp;quot;&lt;/code>&lt;/td>
&lt;td>double quote&lt;/td>
&lt;td>U+0022&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\'&lt;/code>&lt;/td>
&lt;td>single quote&lt;/td>
&lt;td>U+0027&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\\&lt;/code>&lt;/td>
&lt;td>backslash&lt;/td>
&lt;td>U+005C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\0 - \377&lt;/code>&lt;/td>
&lt;td>octal escape&lt;/td>
&lt;td>code point equivalents&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\&amp;lt;line-terminator&amp;gt;&lt;/code>&lt;/td>
&lt;td>continuation&lt;/td>
&lt;td>discard&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Kotlinでは似たようなAPIがないので、必要なら独自の処理を書いた方が良さそうです。（ライブラリは知らず…）&lt;/p>
&lt;h3 id="mapentrycopyof-17">Map.Entry.copyOf (17)&lt;/h3>
&lt;p>&lt;code>Map.Entry&lt;/code>のコピーを作成します。コピーしたエントリは元のMapとは何の関係もないデータとなります。以下のようなサンプルコードを&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.Entry.html" target="_blank" rel="noopener"
>公式ドキュメント&lt;/a>から提示していますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>var entries &lt;span style="color:#ff79c6">=&lt;/span> map&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">entrySet&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">map&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Map&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">Entry&lt;/span>&lt;span style="color:#ff79c6">::&lt;/span>copyOf&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに&lt;code>Map&lt;/code>そのもののコピーは、10から追加された&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html#copyOf%28java.util.Map%29" target="_blank" rel="noopener"
>copyOf&lt;/a>でできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>var copiedMap &lt;span style="color:#ff79c6">=&lt;/span> Map&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">copyOf&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>map&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinだと、&lt;code>Entry&lt;/code>のコピーは以下のようにできます。型は&lt;code>List&amp;lt;MutableMap.MutableEntry&amp;lt;K, V&amp;gt;&amp;gt;&lt;/code>となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Map.Entryを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> entriesJava = map.entries.map { &lt;span style="color:#50fa7b">Map&lt;/span>.&lt;span style="color:#50fa7b">Entry&lt;/span>.copyOf(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// KotlinのMap.Entryを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> entriesKotlin = map.entries.toSet()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、Kotlinでの&lt;code>Map&lt;/code>のコピー方法は以下のようにできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> copiedMap = map.toMap()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="stream">Stream&lt;/h3>
&lt;h4 id="mapmulti-16">mapMulti (16)&lt;/h4>
&lt;p>16からStreamに&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html#mapMulti%28java.util.function.BiConsumer%29" target="_blank" rel="noopener"
>mapMulti&lt;/a>というメソッドが追加されました。基本的には「Streamの要素に1:Nの変換を適用して結果をStreamを返す」という処理なので、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html#flatMap%28java.util.function.Function%29" target="_blank" rel="noopener"
>flatMap&lt;/a>に似ていますが、以下のケースでは&lt;code>flatMap&lt;/code>を使う場合より良いと言われています。&lt;/p>
&lt;ul>
&lt;li>要素を減らす場合&lt;/li>
&lt;li>要素をStreamに変換するのが難しい場合&lt;/li>
&lt;/ul>
&lt;p>まずはオブジェクトがネストされているCollectionに対して&lt;code>flatMap&lt;/code>を使う場合を考えてみましょう。要素を減らすケースでは、&lt;code>flatMap&lt;/code>でまず全ての要素を展開し、&lt;code>filter&lt;/code>を使って条件に合う要素だけを取る必要があります。ここで要素を展開するには、全ての要素を&lt;code>Stream&lt;/code>に変換しなければならないので、全ての要素のグループに対して&lt;code>Stream&lt;/code>のインスタンスを作ることになります。また、オブジェクトがネストしている場合は、その個別の要素に対してどうやって&lt;code>Stream&lt;/code>に変換するか、処理の中で定義する必要があります。&lt;/p>
&lt;p>問題は&lt;code>Stream&lt;/code>のインスタンスを毎回作るためオーバヘッドが発生することにもなるし、要素がさまざまな型のオブジェクトである場合は&lt;code>Stream&lt;/code>に変換する処理を書くのも大変ということです。例えば以下のようなListがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Object&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> numbers &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">2L&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">4&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5L&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">7L&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span> &lt;span style="color:#bd93f9">8L&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このListから、&lt;code>Integer&lt;/code>のみを抽出して別のListにしたい場合はどうしたら良いでしょうか。まず&lt;code>flatMap&lt;/code>を使うとしたら、以下のような処理を書くことになるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Integer&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> integers &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">flatMap&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span> &lt;span style="color:#6272a4">// 要素をStreamに変換する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> it &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>it &lt;span style="color:#ff79c6">instanceof&lt;/span> Iterable&lt;span style="color:#ff79c6">&amp;lt;?&amp;gt;&lt;/span> l&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> StreamSupport&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>l&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">spliterator&lt;/span>&lt;span style="color:#ff79c6">(),&lt;/span> &lt;span style="color:#ff79c6">false&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Stream&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>it&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">})&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">filter&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>it &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> it &lt;span style="color:#ff79c6">instanceof&lt;/span> Integer&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#6272a4">// Integerのみを取る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">map&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>it &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>Integer&lt;span style="color:#ff79c6">)&lt;/span> it&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#6272a4">// ObjectからIntegerへキャスト
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを&lt;code>mapMulti&lt;/code>を使って処理する場合は以下のようになります。よりシンプルになりましたね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">MultiMapper&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">expandIterable&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Object e&lt;span style="color:#ff79c6">,&lt;/span> Consumer&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Integer&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> c&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>e &lt;span style="color:#ff79c6">instanceof&lt;/span> Iterable&lt;span style="color:#ff79c6">&amp;lt;?&amp;gt;&lt;/span> i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">forEach&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>ie &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> expandIterable&lt;span style="color:#ff79c6">(&lt;/span>ie&lt;span style="color:#ff79c6">,&lt;/span> c&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>e &lt;span style="color:#ff79c6">instanceof&lt;/span> Integer i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">accept&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Integer&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> integers &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">mapMulti&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>MultiMapper&lt;span style="color:#ff79c6">::&lt;/span>expandIterable&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/new-list.html#:~:text=java.util.stream.Stream.mapMultiToInt%28BiConsumer%3C%3F%20super%20T%2C%20%3F%20super%20IntConsumer%3E%29" target="_blank" rel="noopener"
>mapMultiToInt&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/new-list.html#:~:text=java.util.stream.Stream.mapMultiToLong%28BiConsumer%3C%3F%20super%20T%2C%20%3F%20super%20LongConsumer%3E%29" target="_blank" rel="noopener"
>mapMultiToLong&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/new-list.html#:~:text=java.util.stream.Stream.mapMultiToDouble%28BiConsumer%3C%3F%20super%20T%2C%20%3F%20super%20DoubleConsumer%3E%29" target="_blank" rel="noopener"
>mapMultiToDouble&lt;/a>などのメソッドも追加されていますので、数字を扱う場合はこちらを使った方が便利でしょう。例えば、上記の&lt;code>mapMulti&lt;/code>を&lt;code>mapMultiToInt&lt;/code>で書く場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">MultiMapper&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">expandIterable&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Object e&lt;span style="color:#ff79c6">,&lt;/span> IntConsumer c&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>e &lt;span style="color:#ff79c6">instanceof&lt;/span> Iterable&lt;span style="color:#ff79c6">&amp;lt;?&amp;gt;&lt;/span> i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">forEach&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>ie &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> expandIterable&lt;span style="color:#ff79c6">(&lt;/span>ie&lt;span style="color:#ff79c6">,&lt;/span> c&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>e &lt;span style="color:#ff79c6">instanceof&lt;/span> Integer i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">accept&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Integer&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> integers &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">mapMultiToInt&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>MultiMapper&lt;span style="color:#ff79c6">::&lt;/span>expandIterable&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">boxed&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mapMultiToInt&lt;/code>の戻り値は&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/IntStream.html" target="_blank" rel="noopener"
>IntStream&lt;/a>なので、&lt;code>Stream&amp;lt;Integer&amp;gt;&lt;/code>に変換するために&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/IntStream.html#boxed%28%29" target="_blank" rel="noopener"
>boxed&lt;/a>を呼び出し、&lt;code>Consumer&lt;/code>が&lt;code>IntConsumer&lt;/code>に変わり、&lt;code>mapMulti&lt;/code>の型指定が変わるなど少しの違いがあります。&lt;/p>
&lt;p>Kotlinではそもそも&lt;code>flatMap&lt;/code>を&lt;code>Stream&lt;/code>として扱わないので、そもそもの処理を違う観点から考える必要があります。幸い、KotlinのCollectionには色々なAPIがあるので、そこまで難しくはないです。例えば、オブジェクトのインスタンスを基準に要素を集約したい場合は以下のようなコードを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(listOf(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;B&amp;#39;&lt;/span>), &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>, setOf(&lt;span style="color:#f1fa8c">&amp;#34;D&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#39;E&amp;#39;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;F&amp;#34;&lt;/span>), listOf(&lt;span style="color:#f1fa8c">&amp;#39;G&amp;#39;&lt;/span>), &lt;span style="color:#f1fa8c">&amp;#39;H&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> result: List&amp;lt;String&amp;gt; = list.flatMap {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">is&lt;/span> Iterable&amp;lt;*&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.filterIsInstance&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listOf(&lt;span style="color:#ff79c6">it&lt;/span>).filterIsInstance&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#6272a4">// [A, C, D, F]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Javaでは&lt;code>List.of(1, 2L)&lt;/code>でListを作成した場合、1はint、2LはLongとして扱われますが、Kotlinでは&lt;code>listOf(1, 2L)&lt;/code>が&lt;code>List&amp;lt;Long&amp;gt;&lt;/code>となってしまうので、そもそもの型に注意する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2L&lt;/span>), &lt;span style="color:#bd93f9">3&lt;/span>, setOf(&lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5L&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>), listOf(&lt;span style="color:#bd93f9">7L&lt;/span>), &lt;span style="color:#bd93f9">8L&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> result = list.flatMap {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">is&lt;/span> Iterable&amp;lt;*&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.filterIsInstance&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listOf(&lt;span style="color:#ff79c6">it&lt;/span>).filterIsInstance&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#6272a4">// [3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="tolist16">toList(16)&lt;/h4>
&lt;p>Streamの終端処理として使用頻度の高い「Listに集計する」をシンタックス・シュガーとして作ったような感覚のメソッドです。ここはKotlinの機能をJavaが受け入れたような気もしますね。処理の結果として生成されるListは&lt;code>Unmodifiable&lt;/code>です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> list &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;a&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;c&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;D&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 旧
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> upper &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">map&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String&lt;span style="color:#ff79c6">::&lt;/span>toUpperCase&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toUnmodifiableList&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 新
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> lower &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">map&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String&lt;span style="color:#ff79c6">::&lt;/span>toLowerCase&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは基本的にCollectionで高階関数を呼び出した結果が&lt;code>Unmodifiable&lt;/code>なListになるのですが、&lt;code>stream&lt;/code>に変換して使うこともできるので、場合によっては便利なのかも知れませんね。&lt;/p>
&lt;h3 id="collectorsteeing-12">Collectors.teeing (12)&lt;/h3>
&lt;p>Collectorsに、二つの&lt;code>Collector&lt;/code>を結合する&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html#teeing%28java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction%29" target="_blank" rel="noopener"
>teeing&lt;/a>というメソッドが追加されました。ちなみに&lt;code>Tee&lt;/code>は二つの水道管を接続して一つにしてくれる「T字継手」の意味を持つらしいです。引数に二つの&lt;code>Collector&lt;/code>と、それを結合する処理の&lt;code>BiFunction&lt;/code>を指定する形となっています。&lt;/p>
&lt;p>例えば以下のような&lt;code>Stream&lt;/code>があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>record &lt;span style="color:#50fa7b">Member&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String name&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#8be9fd">boolean&lt;/span> enabled&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* Member[name=Member1, enabled=false],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* Member[name=Member2, enabled=true],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* Member[name=Member3, enabled=false],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* Member[name=Member4, enabled=true],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Member&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> members &lt;span style="color:#ff79c6">=&lt;/span> IntStream&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">rangeClosed&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">4&lt;/span>&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">mapToObj&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>it &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Member&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Member&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> it&lt;span style="color:#ff79c6">,&lt;/span> it &lt;span style="color:#ff79c6">%&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを&lt;code>teeing&lt;/code>を使って、&lt;code>Member&lt;/code>の&lt;code>enabled&lt;/code>を基準に二つのListに分けるとしたら以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* Member[name=Member2, enabled=true],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* Member[name=Member4, enabled=true]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* ],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* Member[name=Member1, enabled=false],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* Member[name=Member3, enabled=false]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">* ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Member&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#ff79c6">=&lt;/span> members&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">teeing&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">filtering&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Member&lt;span style="color:#ff79c6">::&lt;/span>enabled&lt;span style="color:#ff79c6">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">filtering&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Predicate&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">not&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Member&lt;span style="color:#ff79c6">::&lt;/span>enabled&lt;span style="color:#ff79c6">),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">(&lt;/span>list1&lt;span style="color:#ff79c6">,&lt;/span> list2&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>list1&lt;span style="color:#ff79c6">,&lt;/span> list2&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinではそもそも&lt;code>collect&lt;/code>する必要がないので、&lt;code>Collection&lt;/code>の高階関数を使った処理をした方が良いでしょう。（Javaでもそうした方がわかりやすいような…）&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがだったでしょうか。さすがに全ての変更事項を整理するのは難しかったので、目立っている変化だけをいくつか取り上げてみましたが、それでもかなりの量ですね。ただ確かなのは、Java 17が11よりもさらにモダンな言語になったバージョンであるので、Javaを使っている案件なら十分導入する価値がありそうです。また、Java 15からは11に比べてG1GCの改良による&lt;a class="link" href="https://www.optaplanner.org/blog/2021/01/26/HowMuchFasterIsJava15.html" target="_blank" rel="noopener"
>性能向上もあった&lt;/a>ようですので、性能という面でも良いですね。&lt;/p>
&lt;p>Kotlinを使っている場合でも、APIだけを見るとあまりメリットはないかも知れませんが、JVMを使っている限り性能向上などの恩恵を受けることはできると思われるので、導入を考慮しても良いかなと思います。また次のLTSでは色々と面白いAPIが続々と登場するかも知れませんしね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その三〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-3/</link><pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-3/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その三〜" />&lt;p>JavaからKotlinに移行したものの立場から言うと、Kotlinはスタンダードライブラリだけでも色々な関数を提供しているので、Javaに比べてかなり生産性が上がるといえますが、逆にいまいち関数の有効な使い方がわからなかったり、どうやって処理を書いたら「Kotlinらしい」かわからない場合もあるかと思います。なのでもう3回目のポストになりますが、今回もKotlinで色々とコードを書いてみて、そのうち良さそうなものをいくつか共有します。&lt;/p>
&lt;h2 id="listの要素をスワップ">Listの要素をスワップ&lt;/h2>
&lt;p>Listの要素の順番を変える方法はソートなどを含め色々とありますが、二つの要素をスワップ（インデックスを交換）したい場合もあるかと思います。こういう時に活用できる拡張関数を考えてみました。&lt;/p>
&lt;h3 id="インデックスがわかる場合">インデックスがわかる場合&lt;/h3>
&lt;p>スワップしたい要素のインデックスがわかる場合は、そのインデックスを交換すればいいだけですね。ここでインデックスの交換は、二つの変数の値をスワップすることと変わらないです。変数の値を交換するのは伝統的には以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> a = &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> b = &lt;span style="color:#bd93f9">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> c = a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b = c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もう少しKotlinらしい方法では、&lt;code>also&lt;/code>を用いたものがあります。その方法だと、必要な処理は以下のようにもっとシンプルになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> a = &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> b = &lt;span style="color:#bd93f9">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = b.also { b = a }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これと同じく、Listの要素をスワップする処理を拡張関数で書くとしたらと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;T&amp;gt;.swapByIndex(indexFrom: Int, indexTo: Int): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toMutableList().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>[indexFrom] = &lt;span style="color:#ff79c6">this&lt;/span>[indexTo].also { &lt;span style="color:#ff79c6">this&lt;/span>[indexTo] = &lt;span style="color:#ff79c6">this&lt;/span>[indexFrom] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.toList()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="インデックスがわからない場合">インデックスがわからない場合&lt;/h3>
&lt;p>スワップしたい要素のインデックスがわからない場合もありますが、これも結局インデックスを持って値をスワップすることになるので、まずインデックスを抽出する処理だけを足せば良いかなと思います。&lt;/p>
&lt;p>インデックスを取得する方法は、要素を渡して取得する&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index-of.html" target="_blank" rel="noopener"
>indexOf&lt;/a>とPredicateを渡して取得する&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index-of-first.html" target="_blank" rel="noopener"
>indexOfFirst&lt;/a>があるので、これらを活用することにします。あとはこれらの方法で取得したインデックスを、先に実装しておいた拡張関数に渡すだけで良いです。例えば以下のような実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// indexOf(element)を使うケース
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;T&amp;gt;.swapByElement(from: T, to: T): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swapByIndex(indexOf(from), indexOf(to))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// indexOfFirst(predicate)を使うケース
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;T&amp;gt;.swapByCondition(from: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Boolean, to: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Boolean): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swapByIndex(indexOfFirst { from(&lt;span style="color:#ff79c6">it&lt;/span>) }, indexOfFirst { to(&lt;span style="color:#ff79c6">it&lt;/span>) })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="時間を数字に">時間を数字に&lt;/h2>
&lt;p>&lt;code>java.time&lt;/code>パッケージの&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>のようなオブジェクトは、コード上で時間を扱うには便利ですが、ファイルに書き込むなどでフォーマットを変更する必要がある時もあります。つまり、&lt;code>yyyy-MM-dd&lt;/code>ではなく&lt;code>yyyyMMddhhmmss&lt;/code>のような形にしたい場合があるということです。こういうときは、簡単にInt型に変更できる拡張関数を書いておくと便利でしょう。例えば以下のようなものを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">LocalDate&lt;/span>.toInt(): Int = &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$year$monthValue$dayOfMonth&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> date = &lt;span style="color:#50fa7b">LocalDate&lt;/span>.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">12&lt;/span>, &lt;span style="color:#bd93f9">31&lt;/span>) &lt;span style="color:#6272a4">// 2021-12-31
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(date.toInt()) &lt;span style="color:#6272a4">// 20211231
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうする場合、以下のように月や日付が一桁のものになってしまうケースもあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> date = &lt;span style="color:#50fa7b">LocalDate&lt;/span>.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>) &lt;span style="color:#6272a4">// 2021-09-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(date.toInt()) &lt;span style="color:#6272a4">// 202191
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この問題を解決するには、まず月や日付を二桁の文字列に変える必要がありますね。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">LocalDate&lt;/span>.toInt(): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$year${monthValue.toString().padStart(2, &amp;#39;0&amp;#39;)}${dayOfMonth.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> date = &lt;span style="color:#50fa7b">LocalDate&lt;/span>.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>) &lt;span style="color:#6272a4">// 2021-09-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(date.toInt()) &lt;span style="color:#6272a4">// 20210901
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これでも完璧とはいえません。&lt;code>LocalDate&lt;/code>のみでなく&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>, &lt;code>YearMonth&lt;/code>など、&lt;code>java.time&lt;/code>パッケージに属する他のオブジェクトも使いたい場合には、全てのオブジェクトに対して同じような拡張関数を書く必要があるからです。&lt;/p>
&lt;p>幸い、&lt;code>LocalDate&lt;/code>、&lt;code>LocalDateTime&lt;/code>、&lt;code>YearMonth&lt;/code>は共通的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/temporal/Temporal.html" target="_blank" rel="noopener"
>Temporal&lt;/a>というインタフェースを継承しているので、&lt;code>Temporal&lt;/code>に拡張関数を追加することで問題は解決できます。&lt;/p>
&lt;p>そしてこれらの実装クラスで扱っている時間の範囲はオブジェクトごとに違うので、実装も変える必要がありますね。これらのオブジェクトはどれも時間を数字として表現しているので、まず&lt;code>toString&lt;/code>で文字列に変換した後、数字だけを抽出することです。&lt;code>String&lt;/code>は&lt;code>CharSequence&lt;/code>を継承しているので、&lt;code>filter&lt;/code>で数字だけを抽出すると良いでしょう。そうすると、以下のような方法が使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Temporal&lt;/span>.toDigit(): Long = toString().filter { &lt;span style="color:#ff79c6">it&lt;/span>.isDigit() }.toLong()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> yearMonth = &lt;span style="color:#50fa7b">YearMonth&lt;/span>.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>) &lt;span style="color:#6272a4">// 2021-08
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(yearMonth.toDigit()) &lt;span style="color:#6272a4">// 202108
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> dateTime = &lt;span style="color:#50fa7b">LocalDateTime&lt;/span>.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>) &lt;span style="color:#6272a4">// 2021-10-02T10:10:10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(dateTime.toDigit()) &lt;span style="color:#6272a4">// 20211002101010
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Stringのフォーマットで数字に変換する場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int.html" target="_blank" rel="noopener"
>toInt&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-long.html" target="_blank" rel="noopener"
>toLong&lt;/a>でループが一回発生するだけですが、CharSequenceとして扱う場合はループが2回発生するという違いがあるので性能的には前者が良いはずですが、時間を扱うくらいではそこまでループは長くないので気にするほどではないかと思います。&lt;/p>
&lt;h2 id="要素の一部を合算">要素の一部を合算&lt;/h2>
&lt;p>Listの値を一つに集約したい（合算値を出したい）場合があります。&lt;code>sum&lt;/code>を使っても良いですが、これはそもそも要素が数字ではないと難しいですね。例えば要素が以下のようなクラスとなっているケースはどうしたら良いでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Data&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> amount: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> price: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="合算したい値が一つの場合">合算したい値が一つの場合&lt;/h3>
&lt;p>合算したい値が一つだけの場合は、&lt;code>sumOf&lt;/code>で合算したい値だけを指定すれば良いです。以下は、&lt;code>Data&lt;/code>クラスの&lt;code>amount&lt;/code>だけを合算したい場合に使える方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(Data(&lt;span style="color:#f1fa8c">&amp;#34;data1&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>, &lt;span style="color:#bd93f9">100&lt;/span>), Data(&lt;span style="color:#f1fa8c">&amp;#34;data2&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">20&lt;/span>, &lt;span style="color:#bd93f9">200&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> totalAmount = list.sumOf { &lt;span style="color:#ff79c6">it&lt;/span>.amount }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="合算したい値が複数の場合">合算したい値が複数の場合&lt;/h3>
&lt;p>ここで&lt;code>amount&lt;/code>のみでなく、&lt;code>price&lt;/code>も合算したい場合はどうすれば良いでしょう。同じく&lt;code>sumOf&lt;/code>を&lt;code>price&lt;/code>にも使うことで実装はできますが、同じListに対してループが2回も発生するのあまり効率的ではありません。こういうときは、素直にそれぞれの合算値を変数として宣言しておいて&lt;code>forEach&lt;/code>ループの中で値を足していく方が効率が良いでしょう。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> totalAmount = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> totalPrice = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> totalAmount &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> totalPrice &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.price
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もう一つの方法は、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold.html" target="_blank" rel="noopener"
>fold&lt;/a>を使う方法です。&lt;code>fold&lt;/code>は&lt;code>reduce&lt;/code>と似たようなもので、初期値(initial)を指定できるという違いがありますが、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reduce-to.html" target="_blank" rel="noopener"
>reduceTo&lt;/a>のようにこの初期値の型はListの要素とは違うものに指定できます。そして関数を実行した結果はinitialと同じ型になるので、これを応用すると&lt;code>Data&lt;/code>のリストを二つの値(&lt;code>Pair&lt;/code>)に&lt;code>reduce&lt;/code>することもできます。例えば上記の処理は&lt;code>fold&lt;/code>を使うと以下のようにワンライナで実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> (totalAmount, totalPrice) = list.fold(&lt;span style="color:#bd93f9">0&lt;/span> to &lt;span style="color:#bd93f9">0&lt;/span>) { acc, &lt;span style="color:#ff79c6">value&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (acc.first + &lt;span style="color:#ff79c6">value&lt;/span>.amount) to (acc.second + &lt;span style="color:#ff79c6">value&lt;/span>.price)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>fold&lt;/code>を使う場合、合算したい値が三つある場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-triple/" target="_blank" rel="noopener"
>Triple&lt;/a>を使うこともできますし、さらに値が多い場合は専用のクラスを作ることで対応もできるかと思います。ただ、こうする場合、合算した値を&lt;code>val&lt;/code>として宣言できるというメリットはありますが、ループごとにインスタンスが作成されるので合算したい項目が増えれば増えるほど性能的にはあまり良くない可能性が高いので場合によって適切なものを選ぶ必要がありそうですね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがだったでしょうか。私はずっとJavaでコードを書いていたので、完全にKotlinに転向した今でもついJavaらしいコードを書いてしまうのではないか、と思う時があります。元を辿ると、「Javaらしいコード」や「Kotlinらしいコード」がそもそも何であるかを考えなければならないとは思いますが、それでも、確かに言語が違うとその言語に合わせて自分のコーディングスタイルも変化する必要はあるのではないかと思います。そうすることで、より良いコードが書けるようになりそうな気がしていますので。&lt;/p>
&lt;p>というわけで、これからもKotlinならではの、Kotlinに特化したコードを書くための工夫はこれからも続きます。特に今月はJava 17もリリースされたので、新しいAPIの一覧を眺めてKotlinではどう活用できるか考えてみたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>WebFluxのFunctional Enpointに対する小考察</title><link>https://retheviper.github.io/posts/spring-webflux-dividing-router-and-handler/</link><pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-webflux-dividing-router-and-handler/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.jpg" alt="Featured image of post WebFluxのFunctional Enpointに対する小考察" />&lt;p>前回、&lt;a class="link" href="../spring-webflux-router/" >WebFluxではFunctional Endpointを使うべきか&lt;/a>というポストを書いたことがありますが、今回は&lt;code>Controller&lt;/code>/&lt;code>Service&lt;/code>と&lt;code>Router&lt;/code>/&lt;code>Handler&lt;/code>のパターン間の比較ではなく、&lt;code>Functional Endpoint&lt;/code>を使う場合に、どんな形で実装をしていくべきかについて少し考えたことを述べようと思います。&lt;/p>
&lt;p>実際の業務でWebFluxを使っているわけではないので、さまざまなパターンがあるかなとは思いますが、この&lt;code>Functional Endpoint&lt;/code>を使う場合に考慮すべきものが、&lt;code>Router Function&lt;/code>(以下&lt;code>Router&lt;/code>)と&lt;code>Handler Function&lt;/code>(以下&lt;code>Handler&lt;/code>)をどう分けるかについての問題かと思います。&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>は概念的には別のものではありますが、実装としては一つのクラスにまとめでもアプリは問題なく動くので、フレームワークの仕様や思想というよりかは、アプリのアーキテクチャに関する内容に近いますね。&lt;/p>
&lt;p>なので、今回は&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>を分けた場合と分けない場合について、いくつかの観点から考えてみたいと思います。&lt;/p>
&lt;h2 id="routerとhandlerは分離するべきか">RouterとHandlerは分離するべきか&lt;/h2>
&lt;p>Spring MVCの場合、&lt;code>Controller&lt;/code>と&lt;code>Service&lt;/code>を明確に分けるのが常識のようになっています。アーキテクチャとしてもそうですが、フレームワークの思想（デザインの観点）としてもそうですね。&lt;/p>
&lt;p>こういう前例があるので、同じくSpring Frameworkに属するWebFluxの場合でも、&lt;code>Functional Endpoint&lt;/code>という新しい概念を導入するとしても、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>を分ける必要があると思いがちかなと思います。一見、&lt;code>Controller ≒ Router, Service ≒ Handler&lt;/code>という対応関係が成立するようにも見えて、ネットで検索できるサンプルコードも多くがそのような構造で書かれています。&lt;/p>
&lt;p>しかし、実際のアプリを&lt;code>Functional Endpoint&lt;/code>を持って書くとしたら、いくつか考えなければならないことがあると思います。例えば、そもそも&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>はそれぞれ&lt;code>Controller&lt;/code>と&lt;code>Service&lt;/code>に一対一の対応関係であるという前提は確かであるか？もしそうでなければ、あえてMVCのパターンに合わせる必要があるのか？実装においてはどう影響するのか？などがあるかと思います。なので、今回はこれらの観点から&lt;code>Functional Endpoint&lt;/code>について述べていきます。&lt;/p>
&lt;h2 id="対応関係について">対応関係について&lt;/h2>
&lt;p>Springの&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-fn-overview" target="_blank" rel="noopener"
>公式ドキュメント&lt;/a>では、WebFluxの&lt;code>Functional Endpoint&lt;/code>の紹介において以下のようなサンプルコードを提示しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository = &lt;span style="color:#ff79c6">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> handler = PersonHandler(repository)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> route = coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accept(APPLICATION_JSON).nest {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/person/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>getPerson)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/person&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>listPeople)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POST(&lt;span style="color:#f1fa8c">&amp;#34;/person&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>createPerson)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonHandler&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">listPeople&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createPerson&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>公式のサンプルとして&lt;code>Handler&lt;/code>が別のクラスになっているのを見ると、やはり&lt;code>Controller ≒ Router, Service ≒ Handler&lt;/code>という対応関係が成立するようにも見えます。&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html" target="_blank" rel="noopener"
>@RestController&lt;/a>や&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html" target="_blank" rel="noopener"
>@Service&lt;/a>と違って、&lt;code>@Router&lt;/code>や&lt;code>@Handler&lt;/code>というアノテーションは存在しないことに注目する必要があります。これはつまり、Springというフレームワークの思想としては&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>を必ず分ける必要はない、ということを意味しているのではないでしょうか。&lt;/p>
&lt;p>なので、少なくともアプリケーションのアーキテクチャという観点からして&lt;code>Controller ≒ Router, Service ≒ Handler&lt;/code>という対応関係が成立する、という結論を出すのは難しいのではないかと思います。&lt;/p>
&lt;p>では、実際&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>をあえてアノテーションを使ってDIをするとしたら、どうなるのでしょうか。サンプルとしては、以下のような形が一般的かなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Configuration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonRouter&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> handler: PersonHandler) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Bean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">route&lt;/span>(): RouterFunction&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accept(APPLICATION_JSON).nest {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/person/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>getPerson)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/person&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>listPeople)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POST(&lt;span style="color:#f1fa8c">&amp;#34;/person&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>createPerson)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonHandler&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">listPeople&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createPerson&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>クラスそのものを&lt;code>@Component&lt;/code>として登録する必要がある&lt;code>Contoller&lt;/code>に対して、&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/RouterFunction.html" target="_blank" rel="noopener"
>RouterFunction&lt;/a>は&lt;code>Functional Interface&lt;/code>なのでそれを実装したメソッドを&lt;code>@Bean&lt;/code>として登録する必要があります。そしてSpringで&lt;code>@Bean&lt;/code>をアプリケーションに登録するのは一般的に&lt;code>@Congifuration&lt;/code>が担当するので自然にRouterのアノテーションもそうなります。&lt;code>Handler&lt;/code>は普通に&lt;code>@Component&lt;/code>として登録することになりますね。&lt;/p>
&lt;p>こうなった場合、クラスやその実装を見て&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>を分離しているのはわかりますが、アノテーションだけだと違和感を感じられますね。実装は簡単なのでそれぞれに対応するアノテーションを作るのが難しいわけでもないようですが、なぜこのような構造になっているのでしょうか。&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-programming-models" target="_blank" rel="noopener"
>公式のドキュメント&lt;/a>では、以下のような説明があります。&lt;/p>
&lt;blockquote>
&lt;p>The big difference with annotated controllers is that the application is in charge of request handling from start to finish versus declaring intent through annotations and being called back.&lt;/p>
&lt;/blockquote>
&lt;p>つまり、「アノテーションをつけたContoller」と「Functional Endpoint」の違いは、前者が「アノテーションでコールバックと意図を表す」に対して、後者は「リクエストのハンドリングを開始から終了まで担当する」ということです。プログラミングモデルとしてこのような観点の差があるので、アノテーションがないのは当たり前なのかもしれません。そして結果的に、&lt;code>Controller ≒ Router, Service ≒ Handler&lt;/code>という対応関係は、少なくともプログラミングモデルという観点では当てはならないと考えられます。&lt;/p>
&lt;h2 id="責任の分散という側面で">責任の分散という側面で&lt;/h2>
&lt;p>アノテーションの実装を見ると、&lt;code>@Controller&lt;/code>と&lt;code>@Service&lt;/code>を分けているのがフレームワークのアーキテクチャや思想によるものであることがより明確になります。それぞれのアノテーションの実装は、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>@Target&lt;span style="color:#ff79c6">(&lt;/span>value&lt;span style="color:#ff79c6">=&lt;/span>TYPE&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Retention&lt;span style="color:#ff79c6">(&lt;/span>value&lt;span style="color:#ff79c6">=&lt;/span>RUNTIME&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Documented
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> @interface Controller
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Target&lt;span style="color:#ff79c6">(&lt;/span>value&lt;span style="color:#ff79c6">=&lt;/span>TYPE&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Retention&lt;span style="color:#ff79c6">(&lt;/span>value&lt;span style="color:#ff79c6">=&lt;/span>RUNTIME&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Documented
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> @interface Service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>両方とも実装が同じであるので、極端的にいうと&lt;code>Controller&lt;/code>に&lt;code>@Service&lt;/code>をつけても機能的には同一ということになります。そして&lt;code>@Service&lt;/code>では、以下のようなコメントでこのアノテーションが存在する理由をあくまで「デザインパターンに基盤を置いている」ことを明示しています。&lt;/p>
&lt;blockquote>
&lt;p>Indicates that an annotated class is a &amp;ldquo;Service&amp;rdquo;, originally defined by Domain-Driven Design (Evans, 2003) as &amp;ldquo;an operation offered as an interface that stands alone in the model, with no encapsulated state.&amp;rdquo;
May also indicate that a class is a &amp;ldquo;Business Service Facade&amp;rdquo; (in the Core J2EE patterns sense), or something similar. This annotation is a general-purpose stereotype and individual teams may narrow their semantics and use as appropriate.&lt;/p>
&lt;/blockquote>
&lt;p>なので、アプリケーションデザインの観点からすると&lt;code>Controller&lt;/code>はリクエストを受信、レスポンスを返す、エンドポイントを&lt;code>Service&lt;/code>につなぐという義務だけを持ち、&lt;code>Service&lt;/code>はビジネスロジックを処理する義務を持つと考えられます。同じ観点から考えると、アノテーションはないものの、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>もまた同じ義務を持つように書くこともできるでしょう。&lt;/p>
&lt;p>ただ、問題は「リクエストのハンドリングを開始から終了まで担当する」という定義です。先程のサンプルコードをよく見ると、Handlerのメソッドはどれも&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerRequest.html" target="_blank" rel="noopener"
>ServerRequest&lt;/a>を引数として、戻り値は&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerResponse.html" target="_blank" rel="noopener"
>ServerResponse&lt;/a>になっています。これはつまり、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>をあえて別のクラスとして分割するとしても、リクエストとレスポンスまでを&lt;code>Handler&lt;/code>で処理することを意味します。&lt;/p>
&lt;p>ここで「&lt;code>Controller&lt;/code>/&lt;code>Service&lt;/code>の場合と同じく、&lt;code>Handler&lt;/code>の引数と戻り値だけを変えて良いのでは？」と考えられます。しかし、それこそフレームワークの思想に反することです。&lt;code>ServerRequest&lt;/code>と&lt;code>ServerResponse&lt;/code>のJavaDocでは、以下の通り「&lt;code>ServerRequest&lt;/code>と&lt;code>ServerResponse&lt;/code>は&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/HandlerFunction.html" target="_blank" rel="noopener"
>HandlerFunction&lt;/a>でハンドリングする」ことを明示しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Represents a server-side HTTP request, as handled by a {@code HandlerFunction}.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * &amp;lt;p&amp;gt;Access to headers and body is offered by {@link Headers} and
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * {@link #body(BodyExtractor)}, respectively.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @author Arjen Poutsma
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @author Sebastien Deleuze
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @since 5.0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">interface&lt;/span> &lt;span style="color:#50fa7b">ServerRequest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Represents a typed server-side HTTP response, as returned
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * by a {@linkplain HandlerFunction handler function} or
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * {@linkplain HandlerFilterFunction filter function}.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @author Arjen Poutsma
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @author Juergen Hoeller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @author Sebastien Deleuze
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * @since 5.0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">interface&lt;/span> &lt;span style="color:#50fa7b">ServerResponse&lt;/span> {
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のことでわかるように、WebFluxでは&lt;code>ServerRequest&lt;/code>と&lt;code>ServerResponse&lt;/code>は&lt;code>HandlerFunction&lt;/code>で扱うようにデザインされています。なので、既存の&lt;code>Service&lt;/code>のように、&lt;code>Handler&lt;/code>がビジネスロジック「のみ」を扱うというのはそれが実装として可能かどうか以前の問題になるのです。&lt;/p>
&lt;p>ただ、「責任の分散」という観点からして、責任によってクラスを分けるという発想は間違っているわけではないですね。なのでビジネスロジックを担当するクラスを&lt;code>Handler&lt;/code>と分離して運用するケースは考えられますが、必ずしもクラスを分ける基準が&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>である必要はないのではないかと思われます。&lt;/p>
&lt;h2 id="テストの観点で">テストの観点で&lt;/h2>
&lt;p>JavaでJUnitなどを用いてユニットテストを作る場合、テスト自体はユースケース単位で作成しますが、それらのテストはクラス単位でまとめるというケースが多いかなと思います。なので同じ観点でユニットテストを書く場合、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>が分けられているとしたら当然ユニットテストもその単位で分けられるでしょう。&lt;/p>
&lt;p>ただ、こうする場合の問題は、テスト自体があまり意味を持たなくなる可能性があるということです。まず&lt;code>Router&lt;/code>は単純にエンドポイントと&lt;code>Handler&lt;/code>をつなぐ役割しか持たなくなるので、そのテストも「想定通りの&lt;code>HadlerFunction&lt;/code>を呼び出しているのか」に限るものになります。そして&lt;code>Handler&lt;/code>の場合、&lt;code>ServerRequest&lt;/code>を受信して&lt;code>ServerResponse&lt;/code>を発するので、テストが非常に難しくなるという問題があります。&lt;/p>
&lt;p>なぜ&lt;code>ServerRequest&lt;/code>を受信して&lt;code>ServerResponse&lt;/code>を発するのが問題になるかというと、&lt;code>ServerRequest&lt;/code>のインスタンスを生成するのが難しく、&lt;code>ServerResponse&lt;/code>の場合でもレスポンスボディーを抽出するのが難しいからです。なので、&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/reactive/server/WebTestClient.html" target="_blank" rel="noopener"
>WebTestClient&lt;/a>で行うことになるかと思いますが、&lt;code>WebTestClient&lt;/code>を使う場合はエンドポイントとHTTPメソッドなどを利用して実際のAPIを呼び出すことになるので、結果的に&lt;code>Handler&lt;/code>のテストをするつもりが&lt;code>Router&lt;/code>のテストまでふくむしかないということになります。こうするとクラス単位でテストケースをまとめることが難しいだけでなく、&lt;code>Router&lt;/code>のみのテストも実質的には意味をなくすということになります。&lt;/p>
&lt;h2 id="ではどうすればいいか">ではどうすればいいか&lt;/h2>
&lt;p>今まで論じた3つの観点からすると、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>は別のクラスにする理由もあまりなく、むしろ別クラスに色々と問題が生じるように見えます。しかし、これが必ずしもエンドポイントに対するルーティングとビジネスロジックを分離する必要はない、ということではないかと思います。先に述べた通り、クラスを分ける基準を&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>にしないだけで良いかなと思います。例えば、以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Configuration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonRouter&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Bean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">route&lt;/span>(): RouterFunction&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/person/{id}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">ServerResponse&lt;/span>.ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.findById(&lt;span style="color:#ff79c6">it&lt;/span>.pathVariable(&lt;span style="color:#f1fa8c">&amp;#34;id&amp;#34;&lt;/span>).toLong())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { record &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PersonDto(record.id, record.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ).awaitSingle()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Handler&lt;/code>で、&lt;code>Body&lt;/code>を作る箇所以外はビジネスロジックと言えるものがあまりありません。なので、ここでは&lt;code>Body&lt;/code>だけを分離して別のクラス（&lt;code>Service&lt;/code>）に一任しても良さそうです。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Configuration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonRouter&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Bean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">route&lt;/span>(): RouterFunction&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/person/{id}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">ServerResponse&lt;/span>.ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(service.getPersonById(&lt;span style="color:#ff79c6">it&lt;/span>.pathVariable(&lt;span style="color:#f1fa8c">&amp;#34;id&amp;#34;&lt;/span>).toLong()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .awaitSingle()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonService&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPersonById&lt;/span>(id: Long): Mono&amp;lt;PersonDto&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.findById(id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { PersonDto(&lt;span style="color:#ff79c6">it&lt;/span>.id, &lt;span style="color:#ff79c6">it&lt;/span>.name) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうすると、&lt;code>Router&lt;/code>から直接&lt;code>Repository&lt;/code>にアクセスこともなくなり、今まで挙げていたさまざまな問題も解消できるようになりますね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>ここで提示した方法でビジネスロジックを分けるのは可能だとして、その方法をとった場合に残る疑問はあります。これは果たして&lt;code>Functional&lt;/code>なのか？&lt;code>Functional Endpoint&lt;/code>は&lt;code>Lambda-based&lt;/code>と説明されてあるが、&lt;code>Lambda&lt;/code>が使われないので設計意図とは違う形になってないか？そもそもSpring MVCとは違うコンセプトのフレームワークなので既存とは違うアプローチが必要なのでは？などなど。&lt;/p>
&lt;p>これらの問題を判断するのはなかなか難しいですが、個人的には新しい技術だからといって常に新しい方法論を適用するということは難しく、既存の良い体系があるのならそれに従うのもそう間違っていることとは思いません。Springの公式ドキュメントでは「すでに問題なく動いているSpring MVCアプリケーションにあえてWebFluxを導入する必要はない(If you have a Spring MVC application that works fine, there is no need to change)」と述べていますが、これと同じく、既存の検証されてあるアーキテクチャがあるのならばそれをそのまま適用するもの悪くないのではと思います。まぁ、そもそもWebFluxを導入するところでMVCパターンを使うとしたらこういうことを気にする理由すら無くなるのですが…むしろこのようなプログラミングモデルが増えていくと今後は新しいアーキテクチャが生まれそうな気もしますね。今回のポストを書きながらはそういういうものを感じました。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KtorでRole-based Authorizationを実装する</title><link>https://retheviper.github.io/posts/ktor-role-based-authorization/</link><pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ktor-role-based-authorization/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.jpg" alt="Featured image of post KtorでRole-based Authorizationを実装する" />&lt;p>前回、Ktorを紹介しながら、Ktorにはまだ&lt;code>Role-based Authorization&lt;/code>に対応してないので、自前でそのような機能を実装する必要がある、と述べました。Ktorはまだ歴史が短く、SpringやDjango、Railsのように幅広く使われているフレームワークでもないので、おそらく他に比べ実のアプリケーションを作るにあたっては必要な機能が十分でない可能性がありますね。なので、こうやって必要な機能がない場合は直接その機能を実装するしかないです。&lt;/p>
&lt;p>幸い、Ktorでは機能を&lt;a class="link" href="https://ktor.io/docs/plugins.html" target="_blank" rel="noopener"
>Plugin&lt;/a>といい、モジュール単位で追加できるため、必要な機能を実装するのもそのPluginを作ることでできるようになります。ただ、モジュールを利用するということは、機能単位の管理がやりやすくなるものの、そのモジュールはどうやって機能するか、また、どういうお作法が必要となるかを知る必要がありますね。&lt;/p>
&lt;p>今回はネット上に公開されてある&lt;a class="link" href="https://medium.com/@shrikantjagtap99/role-based-authorization-feature-in-ktor-web-framework-in-kotlin-dda88262a86a" target="_blank" rel="noopener"
>記事&lt;/a>を参考にしながら、KtorのRole-based Authorizationを&lt;code>Plugin&lt;/code>として実装してみました。そこで、今回のポストではこういう自作の&lt;code>Plugin&lt;/code>がどうやってKtorの機能として動作するか、どうやって実装するのかについて述べたいと思います。&lt;/p>
&lt;h2 id="role-based-authorizationとは">Role-based Authorizationとは&lt;/h2>
&lt;p>まずは、そもそも&lt;code>Role-based Authorization&lt;/code>とは何か、からですね。これは、ウェブアプリケーションでよく言われている「認可」の方式のうち、ユーザの&lt;code>Role&lt;/code>（役割）に基づいて、APIの実行を制御するものです。例えばECサイトの場合、商品に対して問い合わせをするのは認証されたユーザなら誰でもできるべきですが、「お知らせを書く」や「商品の在庫数を変更する」などの機能はその権限を持つユーザ（Admin）に限定すべきですね。なので、ここで「一般ユーザ」と「管理者」などの&lt;code>Role&lt;/code>を設け、APIに対してのリクエストが発生した際にその&lt;code>Role&lt;/code>をまず確認し、その権限のあるユーザのみがAPIを実行できるようにする、というのが&lt;code>Role-based Authorization&lt;/code>の基本的な概念です。&lt;/p>
&lt;p>これを実現するために既存のアプリに導入する必要のあるものは、大きく分けて&lt;code>Role&lt;/code>の概念と、それを元にリクエストをフィルタリングする機構の二つです。前者の場合はどんなロールがあり、どういう形でユーザに紐付けるかを考えればいいだけなので、テーブルやカラムを追加して既存のユーザの情報と紐づけるだけですみます。しかし、後者はまずフレームワークでどうやってリクエストをフィルタするか、まずその構造から理解する必要がありますね。なんので、まずはKtorでリクエストを扱う方法に対して紹介したいと思います。&lt;/p>
&lt;h2 id="pipelineとfeature">PipelineとFeature&lt;/h2>
&lt;p>Ktorの特徴のうち、最も重要と言えるものは、&lt;a class="link" href="https://ktor.io/docs/pipelines.html" target="_blank" rel="noopener"
>Pipeline&lt;/a>の概念です。この&lt;code>Pipeline&lt;/code>に対して、公式では以下のように説明しています。&lt;/p>
&lt;blockquote>
&lt;p>The pipeline is a structure containing a sequence of functions (blocks/lambdas) that are called one after another, distributed in phases topologically ordered, with the ability to mutate the sequence and to call the remaining functions in the pipeline and then return to current block.&lt;/p>
&lt;/blockquote>
&lt;p>この説明だけでは理解が難しいものですが、要するに、Ktorにおいての処理の単位のことを指していると言ってもよいものです。&lt;code>Pipeline&lt;/code>ではAPIのコールからレスポンスまで一連の流れとしての処理を定義することができます。なので&lt;code>Pipeline&lt;/code>として実現されている代表的な機能は&lt;code>Router&lt;/code>、リクエストに対してのハンドリングを定義する機能（Springの&lt;code>Controller&lt;/code>に対応するもの）となります。&lt;/p>
&lt;p>また、&lt;code>Pipeline&lt;/code>は拡張できるものなので、その形式に合わせて新しい&lt;code>Pipeline&lt;/code>を実装することでモジュール(公式の表現では&lt;code>Plugin&lt;/code>)を実現するのもできます。これらのモジュールを実装し、アプリケーションにインストールすることで、そのモジュールの機能を利用できるようになるのがKtorの特徴です。例えば、kotlin公式のJSON Mapperである&lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>kotlinx.serialization&lt;/a>をアプリケーションに追加するためには以下のようなコードを書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Application&lt;/span>.main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(ContentNegotiation) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> json()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで呼び出している&lt;code>install&lt;/code>関数の実装を見ると、以下のようになっています。&lt;code>feature&lt;/code>(モジュール)と、そのモジュールの設定となる&lt;code>configure&lt;/code>が引数になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">P&lt;/span> : &lt;span style="color:#50fa7b">Pipeline&lt;/span>&amp;lt;*, &lt;span style="color:#50fa7b">ApplicationCall&lt;/span>&amp;gt;, &lt;span style="color:#50fa7b">B&lt;/span> : &lt;span style="color:#50fa7b">Any&lt;/span>, &lt;span style="color:#50fa7b">F&lt;/span> : &lt;span style="color:#50fa7b">Any&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">P&lt;/span>.install(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> feature: ApplicationFeature&amp;lt;P, B, F&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configure: &lt;span style="color:#50fa7b">B&lt;/span>.() &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit = {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): F
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先ほどの&lt;code>kotlinx.serialization&lt;/code>をインストールするために使っていたコードでは、&lt;code>feature&lt;/code>として&lt;code>ContentNegotiation&lt;/code>を渡し、その設定として&lt;code>json&lt;/code>を使うという設定をしているのだなという推測ができますね。実際、&lt;code>ContentNegotiation&lt;/code>の実装は、以下のような形となっています。一部のコードは省略していますが、クラスの中には&lt;code>Configuration&lt;/code>というクラスと、&lt;code>ApplicationFeature&lt;/code>を継承した&lt;code>companion object&lt;/code>を中に持っているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">ContentNegotiation&lt;/span> &lt;span style="color:#ff79c6">internal&lt;/span> &lt;span style="color:#ff79c6">constructor&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> registrations: List&amp;lt;ConverterRegistration&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> acceptContributors: List&amp;lt;AcceptHeaderContributor&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> checkAcceptHeaderCompliance: Boolean = &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Configuration type for [ContentNegotiation] feature
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Configuration&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> * Implementation of an [ApplicationFeature] for the [ContentNegotiation]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> Feature : ApplicationFeature&amp;lt;ApplicationCallPipeline, Configuration, ContentNegotiation&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の実装でわかるように、&lt;code>Pipeline&lt;/code>として機能するためにはモジュールの設定のための&lt;code>Configuration&lt;/code>というクラスと、モジュールとして機能するための&lt;code>ApplicationFeature&lt;/code>を継承した&lt;code>companion object&lt;/code>が必要であることがわかります。なので、この構造を持ったクラスを定義できれば、自作のモジュールをアプリケーションに実装できるということがわかりますね。&lt;/p>
&lt;h2 id="pluginの実装">Pluginの実装&lt;/h2>
&lt;p>では、実際に&lt;code>Pipeline&lt;/code>として、リクエストに対する認可を判定する機能を作るとしましょう。まずはロールを定義します。&lt;code>enum&lt;/code>が良さそうですね。ここではシンプルに管理者と一般ユーザの2種を作ってみます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">enum&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Role&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> value: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ADMIN(&lt;span style="color:#f1fa8c">&amp;#34;ADMIN&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> USER(&lt;span style="color:#f1fa8c">&amp;#34;USER&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのロールは、テーブルなどで管理する必要もありますが、ログイン中のユーザ情報から取得する必要もありますね。認可のためには、ログイン中のユーザにとあるロールが与えられているかどうかの確認が必要となるからです。なので、&lt;code>io.ktor.auth.Principal&lt;/code>を継承したユーザの情報もクラスとして作り、ログインに成功した時はこのクラスにユーザのロールを格納することにします（方法は認可とは関係ないのでここでは割愛させてください）。以下はユーザの情報を格納するための簡単な例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">UserPrincipal&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> username: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> roles: Set&amp;lt;Role&amp;gt; = emptySet()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : Principal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、ロールでアクセスを制限する関数を作ります。&lt;code>Router&lt;/code>のエンドポイントに、どのロールの場合にアクセスできるかを指定するようなイメージです。例えば以下のような形で使えたらいいかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Application&lt;/span>.main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 管理者のみアクセスできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> withRole(&lt;span style="color:#50fa7b">Role&lt;/span>.ADMIN) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;/admin&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#f1fa8c">&amp;#34;This is admin page&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 一般ユーザがアクセスできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> withRole(&lt;span style="color:#50fa7b">Role&lt;/span>.USER) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;/user&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#f1fa8c">&amp;#34;This is user page&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Router&lt;/code>の使い方でわかるように、&lt;code>Pipeline&lt;/code>でのコードブロック（関数）はネストが可能なのでこのように一つのレイヤーを挟むのも可能です。ここで追加した&lt;code>withRole&lt;/code>という関数でロールを確認し、APIにアクセスできるかどうかを判定するようにしたら良いでしょう。&lt;/p>
&lt;h3 id="authorizedrotueselectorの実装">AuthorizedRotueSelectorの実装&lt;/h3>
&lt;p>まずは&lt;code>RouteSelector&lt;/code>を実装します。これは、&lt;code>routing&lt;/code>の中にこれから作る認可の関数がネストできるようにするためのものです。もっともシンプルな実装は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">AuthorizedRouteSelector&lt;/span>() : RouteSelector() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">evaluate&lt;/span>(context: RoutingResolveContext, segmentIndex: Int) = &lt;span style="color:#50fa7b">RouteSelectorEvaluation&lt;/span>.Constant
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="child-routeの実装">child routeの実装&lt;/h3>
&lt;p>先に実装した&lt;code>AuthorizedRouteSelector&lt;/code>を利用して、実際に&lt;code>child route&lt;/code>として機能する関数を作ります。この&lt;code>child route&lt;/code>は&lt;code>Router&lt;/code>の下にネストすることになるので、&lt;code>Route&lt;/code>の拡張関数を作ることにします。引数としては判定のためのロールと、その下にネストするエンドポイントの関数を設定できるようにすれば良いでしょう。実装は以下のようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Route&lt;/span>.withRole(&lt;span style="color:#ff79c6">val&lt;/span> role: Role, build: &lt;span style="color:#50fa7b">Route&lt;/span>.() &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit): Route {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> authorizedRoute = createChild(AuthorizedRouteSelector())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> application.feature(RoleBaseAuthorizer).interceptPipeline(&lt;span style="color:#ff79c6">this&lt;/span>, role)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> authorizedRoute
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで実装しているものは、まず&lt;code>AuthorizedRouteSelector&lt;/code>で&lt;code>child route&lt;/code>を作り、その後&lt;code>Pipeline&lt;/code>をインターセプトして、ユーザが指定したロールに該当するかどうかを判定します。問題なければ&lt;code>build&lt;/code>を実行させますが、これがネストしている&lt;code>child route&lt;/code>になります。最後に、エンドポイントをネストできるように先ほど作成した&lt;code>child route&lt;/code>のインスタンスを返します。&lt;/p>
&lt;p>&lt;code>Pipeline&lt;/code>をインターセプトする時に呼び出している&lt;code>RoleBaseAuthorizer&lt;/code>は、別途クラスとして作ることにします。これを&lt;code>Feature&lt;/code>として作ることになります。&lt;/p>
&lt;h3 id="認可処理のモジュールの実装">認可処理のモジュールの実装&lt;/h3>
&lt;p>では、本格的に認可の処理を担当するモジュール（&lt;code>Feature&lt;/code>）を実装することにします。先に述べた通り、&lt;code>Configuration&lt;/code>と&lt;code>Feature&lt;/code>を内部に持ったクラスを作ります。ここで&lt;code>Configuration&lt;/code>は、ログイン中のユーザからどうやってロールの情報を取得するかの設定ができるクラスにします。こうすることで、以下のようなことが可能になるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Application&lt;/span>.main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// RoleBaseAuthorizerをFeatureとしてインストール
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> install(RoleBaseAuthorizer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ログイン中のユーザの情報からロールを取得する方法をConfigurationとして指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> getRoles { (&lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">as&lt;/span> UserPrincipal).roles }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Configuration&lt;/code>では、ログイン中のユーザ情報となる&lt;code>UserPrincipal&lt;/code>から&lt;code>roles&lt;/code>を取得する、という関数を渡します。これを持って、&lt;code>RoleBaseAuthorizer&lt;/code>では&lt;code>withRole&lt;/code>関数で指定したロールとユーザのロールを比較するようにします。&lt;/p>
&lt;p>認可のモジュールの設定方法のイメージができたので、次に&lt;code>RoleBaseAuthorizer&lt;/code>を実装します。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">RoleBaseAuthorizer&lt;/span>(config: Configuration) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Configuration&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> userRoles: (Principal) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Set&amp;lt;Role&amp;gt; = { emptySet() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ログイン中のユーザの情報からロールの取得方法をセット
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getRoles&lt;/span>(roles: (Principal) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Set&amp;lt;Role&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userRoles = roles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> getRoles = config.userRoles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">interceptPipeline&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pipeline: ApplicationCallPipeline,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> role: Role
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Pipelineの位置付け
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> pipeline.insertPhaseAfter(&lt;span style="color:#50fa7b">ApplicationCallPipeline&lt;/span>.Features, &lt;span style="color:#50fa7b">Authentication&lt;/span>.ChallengePhase)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pipeline.insertPhaseAfter(&lt;span style="color:#50fa7b">Authentication&lt;/span>.ChallengePhase, AuthorizationPhase)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// インターセプト時の処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> pipeline.intercept(AuthorizationPhase) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ログイン中のユーザの情報を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> principal = call.authentication.principal&amp;lt;UserPrincipal&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> AuthorizationException(&lt;span style="color:#f1fa8c">&amp;#34;Missing principal&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ユーザ情報からロールを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> roles = getRoles(principal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (roles.none { role }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ログイン中のユーザのロールに、アクセス可能なロールが含まれてない場合の処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> Feature : ApplicationFeature&amp;lt;ApplicationCallPipeline, Configuration, RoleBaseAuthorizer&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> key = AttributeKey&amp;lt;RoleBaseAuthorizer&amp;gt;(&lt;span style="color:#f1fa8c">&amp;#34;RoleBaseAuthorizer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> AuthorizationPhase = PipelinePhase(&lt;span style="color:#f1fa8c">&amp;#34;Authorization&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">install&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pipeline: ApplicationCallPipeline,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configure: &lt;span style="color:#50fa7b">Configuration&lt;/span>.() &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ): RoleBasedAuthorization {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> configuration = Configuration().apply(configure)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> RoleBaseAuthorizer(configuration)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先に説明した通り、&lt;code>Configuration&lt;/code>ではユーザのロール情報を取得する関数を設定し、保存します。そして&lt;code>interceptPipeline&lt;/code>では、その関数を持って&lt;code>Pipeline&lt;/code>をインターセプトし、ロールの検証を行うようにします。&lt;/p>
&lt;p>また、&lt;code>interceptPipeline&lt;/code>では、引数として渡された&lt;code>Pipeline&lt;/code>の位置付けを設定する必要があります。上記のコードでは、「認証の後」に位置付けしています。その後のロジックは、色々な方法があると思いますので、ここでは割愛させていただきます。&lt;/p>
&lt;p>他に、&lt;code>Feature&lt;/code>の場合は、&lt;code>RoleBaseAuthorizer&lt;/code>が独立したモジュールとして使える設定を行います。単純に名前をつけてインスタンスを返すような、お作法的なものですね。&lt;/p>
&lt;p>ここまでの実装が終わったら、一通り認可に関するモジュールの作成は終わります。ただ、&lt;code>interceptPipeline&lt;/code>の処理としてユーザのロールが、APIにアクセスできない場合の処理として考えられることは二つほどあります。&lt;/p>
&lt;h4 id="レスポンスを返して終了">レスポンスを返して終了&lt;/h4>
&lt;p>まず考えられる方法は、適当なレスポンスを返し、そこで処理を終了させることです。この場合、以下のように実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (roles.none { role }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// レスポンスを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> call.respond(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status = &lt;span style="color:#50fa7b">HttpStatusCode&lt;/span>.Forbidden,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message = &lt;span style="color:#f1fa8c">&amp;#34;permission not granted: &lt;/span>&lt;span style="color:#f1fa8c">$role&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Pipelineの終了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> finish()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで注意すべきことは、レスポンスを返すだけで&lt;code>Pipeline&lt;/code>は終わらないということです。レスポンスを返し処理を止めたい場合は必ず&lt;code>finish()&lt;/code>を呼び出して、&lt;code>Pipeline&lt;/code>を終了させましょう。&lt;/p>
&lt;h4 id="exceptionを投げる">Exceptionを投げる&lt;/h4>
&lt;p>もう一つの方法は、例外を投げる方法ですね。例えば以下のようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 認可されてない場合の例外
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">AuthorizationException&lt;/span>(&lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> message: String) : Exception(message)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (roles.none { role }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> AuthorizationException(&lt;span style="color:#f1fa8c">&amp;#34;permission not granted: &lt;/span>&lt;span style="color:#f1fa8c">$role&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例外を投げる場合は、当然&lt;code>Pipeline&lt;/code>の処理が止まることになりますが、アプリケーションのログでも例外になるのであまり良くないですね。幸い、KtorにもSpringの&lt;code>ExceptionHandler&lt;/code>のような機能があるので、それを活用したら適切な例外のハンドリングが可能になります。例えば以下のようなことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 認可されてない場合のレスポンス
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">AuthFailedResponse&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> reason: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 例外のハンドリング
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>install(StatusPages) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exception&amp;lt;Throwable&amp;gt; { cause &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">when&lt;/span> (cause) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 認可の場合の処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">is&lt;/span> AuthorizationException &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status = &lt;span style="color:#50fa7b">HttpStatusCode&lt;/span>.Forbidden,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message = AuthFailedResponse(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason = cause.message
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでアプリケーションのログも綺麗になりますし、他の例外処理に対しても&lt;code>when&lt;/code>の分岐を増やすだけで対応ができるようになります。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>最初に思っていたことよりも膨大な内容を扱うことになったので、いつもより説明が大雑把な気もしますが、これで&lt;code>Pipeline&lt;/code>とそれを応用した自作モジュールの実装についての説明は一通りできたかなと思います。なので、これを応用すれば、他のモジュールを追加するのもそう難しくなさそうな気がしますね。深堀すると色々また出そうな気がしますが、それについては機会があればまた今度のポストのネタにしましょう。（正直あまり詳しくありませんので…）&lt;/p>
&lt;p>個人的には、このようにRole-based Authorizationの機能を作りながら知った。一連の処理を&lt;code>Pipeline&lt;/code>という単位で扱うという概念ががかなり新鮮で、良いと思いました。処理に対してのインターセプトはSpringでもできるのですが、処理の流れ自体を一つの単位として扱えるならより色々なことができそうな気もしますね。まだKtorに触れたばかりなので、詳しいことはもっと時間をかけてゆっくり調べる必要がありそうですが。&lt;/p>
&lt;p>確かなのは、Ktorはかなり魅力的なフレームワークであるということです。最初はSpringなど、既存の有名なフレームワークと比べ色々と機能が足りない認証だったのですが、こうやって簡単にモジュールを作れるとしたら意外と問題ないかもしれない、という気がします。もちろんそれでも、プロダクションレベルのものを作るにはまだ色々と検証が必要そうな認証はありますが。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>ExposedでOneToManyをどうマッピングするか</title><link>https://retheviper.github.io/posts/exposed-mapping-record-to-object/</link><pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/exposed-mapping-record-to-object/</guid><description>&lt;img src="https://retheviper.github.io/images/exposed.jpg" alt="Featured image of post ExposedでOneToManyをどうマッピングするか" />&lt;p>DBのテーブルとして、1:Nのリレーションは珍しいものではありません。例えば、ECサイトで会員登録をし、複数の配送先を設定できるようにするとしたら、この会員情報のテーブルに配送先のカラムを追加するよりは、配送先のテーブルを分離して別に管理した方がデータの持ち方としては合理的で安全なはずです。そして分離した配送先のテーブルは、会員情報のテーブルとN:1の関係になるのが一般的でしょう。&lt;/p>
&lt;p>ただ、データの持ち方が優先的なDBと、そのデータを処理して形にするアプリケーションでは事情が違いますね。例えば上記の通り、一つの会員情報のレコードに対して複数の配送先のレコードが存在し得る場合、SQLでデータを表現すると、以下のような形になるはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>|-----------|-------------|-----------------|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| member.id | member.name | mailing.address |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-----------|-------------|-----------------|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 1 | John | Tokyo |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 1 | John | New York |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 1 | John | Beijing |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 2 | Simpson | Osaka |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 2 | Simpson | Nagoya |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-----------|-------------|-----------------|
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかしアプリケーションではこのような形でデータを扱うことはあまりないですね。一つのレコードに対して複数のレコードが含まれるということは、Kotlinだと以下のように表現するのが一般的かと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Member&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> mailingAdress: List&amp;lt;String&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして普通は、このようなオブジェクトをJSONの形にしてREST APIのレスポンスとして使う場合が多いですね。なので、先程のレコードをJSONにした場合は以下のようになるはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;members&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#bd93f9">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;mailingAddress&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Tokyo&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;New York&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Beijing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#bd93f9">2&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;Simpson&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;mailingAddress&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Osaka&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;Nagoya&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで問題は、オブジェクトをJSONに変えることはそう難しくないのですが（&lt;a class="link" href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener"
>Jackson&lt;/a>, &lt;a class="link" href="https://github.com/google/gson" target="_blank" rel="noopener"
>Gson&lt;/a>, &lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>Kotlin Serialization&lt;/a>のようなライブラリがすでにありますし）&lt;/p>
&lt;p>では、このような場合、DBから取得したレコードをどうやってオブジェクトにマッピングしたら良いのでしょう。JPAのようなORMを使う場合、クラスにテーブル間の関係を表すフィールドとアノテーションを適切に使うことでレコードへのマッピングは自動に行われますが、&lt;a class="link" href="https://www.jooq.org" target="_blank" rel="noopener"
>jOOQ&lt;/a>や&lt;a class="link" href="https://querydsl.com" target="_blank" rel="noopener"
>Querydsl&lt;/a>, &lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>, &lt;a class="link" href="https://www.ktorm.org" target="_blank" rel="noopener"
>Ktorm&lt;/a>のようなORMで、DSLを使ってSQLを書く場合はデータのマッピングを手動で行う必要があります。そして取得したデータは行の配列という形になるので、どうマッピングしたら（効率が）いいかは少し悩ましいところです。&lt;/p>
&lt;p>なので、今回はExposedのDSLを使って取得したOne to Manyのレコードを、コード上でどうやってオブジェクトにマッピングするかについて考えたことを述べたいとお思います。&lt;/p>
&lt;h2 id="テーブルごとにselectする">テーブルごとにSelectする&lt;/h2>
&lt;p>もっとも簡単な方法は、そもそもレコードの取得時に個別のテーブルに対してSelectしてからマッピングすることですね。個別のテーブルに対してクエリを発行するので、書き方としては明瞭になるというメリットもあります。例えば、以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// まずはMemberテーブルをSelectし、オブジェクトにマッピングする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> member = &lt;span style="color:#50fa7b">Member&lt;/span>.select { &lt;span style="color:#50fa7b">Member&lt;/span>.id eq id }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .first()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemberDto(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = row[&lt;span style="color:#50fa7b">Member&lt;/span>.id].&lt;span style="color:#ff79c6">value&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = row[&lt;span style="color:#50fa7b">Member&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> role = listOf(row[&lt;span style="color:#50fa7b">Mailing&lt;/span>.role])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// MailingテーブルをSelectし、リストにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> mailingAddress = Mailing
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .select { &lt;span style="color:#50fa7b">Mailing&lt;/span>.memberId eq member.id }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Mailing&lt;/span>.address] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// オブジェクトのコピーを作り配送先のデータをマッピング
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> member.copy(mailingAddress = mailingAddress)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もっとも簡単で、コードとしてもわかりやすい方法ではありますが、トランザクションの観点からするとあまりよくない方法ですね。Exposedでは、&lt;code>transaction&lt;/code>ブロックに包むことでトランザクションの単位を制御できるものの、一回で済ませるクエリの発行が複数になるという問題があります。ここではMemberテーブルを照会するたびにMailingテーブルも照会することになるので1回のクエリが追加されているだけですが、もしMemberテーブルに1:Nの関係となっているテーブルが増えれば増えるほどクエリの発行数も増えることになるでしょう。そして今回は一つのレコードに対してのコードとなっていますが、照会対象のMemberテーブルのレコードが増えれば増えるほど発行されるクエリの数も多くなります。&lt;/p>
&lt;p>また、オブジェクトのインスタンスを作っておいて、わざわあコピーするというのもあまり効率が良いとは言えません。これもまたクエリの数が増える問題と同じく、照会対象のレコードが増えれば増えるほど生成されるオブジェクトのインスタンスも増えることになるという訳ですね。なので、全く性能や効率を考えてないコードと言えます。&lt;/p>
&lt;h2 id="joinしてマッピングする">joinしてマッピングする&lt;/h2>
&lt;p>関係のあるデータを複数のテーブルを跨いで取得するには、やはり&lt;code>join&lt;/code>が効率的でしょう。これならまず発行されるクエリの数は個別のテーブルに対してSelectする時に比べ、劇的に減ります。アルゴリズムでよく使われる表現の&lt;a class="link" href="https://vmm.dev/ja/cci/cci-0.md" target="_blank" rel="noopener"
>Big O記法&lt;/a>で表現すると、前者は&lt;code>O(N^2)&lt;/code>であり、これは&lt;code>O(1)&lt;/code>と表現できるはずです。&lt;/p>
&lt;p>ならばデータを取得する際に、クエリとしては&lt;code>join&lt;/code>を使うのが理想的なのはわかりますが、問題はそうやって取得したデータをどう加工するかです。先に述べましたが、取得したデータのうち重複するものがあるからですね。そしてこれが重複しているかどうかはクエリを実行した結果を取得して、確認するまではわかりません。&lt;/p>
&lt;p>ここで考えられる方法は三つほどありますので、一つづつ紹介していきます。&lt;/p>
&lt;h3 id="reduce">reduce&lt;/h3>
&lt;p>まずはクエリの結果として取得した行を、それぞれオブジェクトにマッピングした後、&lt;code>reduce&lt;/code>でまとめる方法です。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Member&lt;/span>.leftJoin(Mailing)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .select { (&lt;span style="color:#50fa7b">Member&lt;/span>.id eq id) and (&lt;span style="color:#50fa7b">Mailing&lt;/span>.memberId eq &lt;span style="color:#50fa7b">Member&lt;/span>.id) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// とりあえずオブジェクトにマッピングする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> MemberDto(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Member&lt;/span>.id].&lt;span style="color:#ff79c6">value&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Member&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailingAddress = listOf(&lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Mailing&lt;/span>.address])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.reduce { acc, memberDto &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// オブジェクトを一つに集約させる（mailingAddressは累計）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> acc.copy(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailingAddress = acc.mailingAddress + memberDto.mailingAddress
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このやり方で考えられる問題は、まず行数分のオブジェクトのインスタンスが作られるということです。このクエリとして取得しようとしているMemberのレコードは一つのみですが、そのレコードに紐づくMailingのレコードが多ければ多いほど件数は増え、当然生成されるオブジェクトの数も多くなります。また、マッピングだけでなく、&lt;code>reduce&lt;/code>でもオブジェクトをコピーしているので、やはり行数分のオブジェクトが生成されていると考えられます。オブジェクトのインスタンス数は行数x2になる訳ですね。&lt;/p>
&lt;p>そしてもう一つの問題は、Memberのレコードを複数取得する場合、全部一つのオブジェクトにまとまってしまうという問題がありますね。なので、このやり方だと一つのレコードを取得する場合のみしか適応できなくなります。&lt;/p>
&lt;h3 id="groupby">groupBy&lt;/h3>
&lt;p>取得したレコードを、一度Mapに変換するとどうでしょうか。KotlinのCollectionには&lt;code>groupBy&lt;/code>というメソッドがあり、keyとvalueのマッピング方法を指定すると、一つのkeyに&lt;code>List&lt;/code>形式のvalueになります。Mapなので、keyでMemberのオブジェクトをマッピングしておいて、valueとしてはMailingのレコードをまとめておくと良いでしょう。keyは同じものだと上書きされるので、取得したいMemberのレコードが複数の場合でも問題ないはずです。コードでは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Member&lt;/span>.leftJoin(Mailing)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .select { (&lt;span style="color:#50fa7b">Member&lt;/span>.id eq id) and (&lt;span style="color:#50fa7b">Mailing&lt;/span>.memberId eq &lt;span style="color:#50fa7b">Member&lt;/span>.id) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// keyはMemberオブジェクトのマッピング、valueではMailingのレコードを集約
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> .groupBy({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemberDto(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Member&lt;/span>.id].&lt;span style="color:#ff79c6">value&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Member&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, { &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Mailing&lt;/span>.address] })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// keyのオブジェクトにMailingのレコードを設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> .map { (key, &lt;span style="color:#ff79c6">value&lt;/span>) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key.copy(mailingAddress = &lt;span style="color:#ff79c6">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この方法だと、今まで照会した他の方法で考えられる問題をだいぶ解消できそうな気がしますね。ただ、気になるのは、&lt;code>groupBy&lt;/code>の引数がLambdaであることです。引数として関数を渡すということは、ループしながらその関数を実行することになるという意味なので、&lt;code>reduce&lt;/code>の時と同じ量のインスタンスが作られる可能性がありそうですね。なので、&lt;code>groupBy&lt;/code>の実装を見ていきたいと思います。中のコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">K&lt;/span>, &lt;span style="color:#50fa7b">V&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Iterable&lt;/span>&amp;lt;T&amp;gt;.groupBy(keySelector: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> K, valueTransform: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> V): Map&amp;lt;K, List&amp;lt;V&amp;gt;&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> groupByTo(LinkedHashMap&amp;lt;K, MutableList&amp;lt;V&amp;gt;&amp;gt;(), keySelector, valueTransform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>groupBy&lt;/code>の実装では、&lt;code>groupByTo&lt;/code>という関数に自分の引数と、作られるMapのインスタンスを渡しているだけですね。では、さらに&lt;code>groupByTo&lt;/code>の中身を見ていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">K&lt;/span>, &lt;span style="color:#50fa7b">V&lt;/span>, &lt;span style="color:#50fa7b">M&lt;/span> : &lt;span style="color:#50fa7b">MutableMap&lt;/span>&amp;lt;&lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#50fa7b">K&lt;/span>, &lt;span style="color:#50fa7b">MutableList&lt;/span>&amp;lt;&lt;span style="color:#50fa7b">V&lt;/span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#50fa7b">Iterable&lt;/span>&amp;lt;T&amp;gt;.groupByTo(destination: M, keySelector: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> K, valueTransform: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> V): M {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (element &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> key = keySelector(element)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> list = destination.getOrPut(key) { ArrayList&amp;lt;V&amp;gt;() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list.add(valueTransform(element))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで確かになっていることは、やはり最初のCollectionの要素数分、&lt;code>keySelector&lt;/code>と&lt;code>valueTransform&lt;/code>を実行しているということです。Mapに変えることになるので、&lt;code>reduce&lt;/code>の時とは違ってMemberレコードがいくつあっても一つに集約されるような事態は起こらないと考えられますが、依然としてオブジェクトのインスタンスが複数できてしまうという問題はあります。なので、また他の方法を探してみましょう。&lt;/p>
&lt;h3 id="map">Map&lt;/h3>
&lt;p>最後に考えられるのは、Selectした行をMapにまとめるのではなく、外部にMapを宣言し、それを利用することです。Mapには、&lt;code>compute&lt;/code>という関数があり、引数として渡したkeyに対してどんな処理をするか（どんなvalueを作って入れるか）を指定できます。例えば、指定したkeyに対してvalueが存在しない場合は要素として追加し、存在する場合はそのvalueを変えるなどの処理ができるようになります。なので、これをうまく使うとインスタンスの生成問題を解決できる気がしますね。&lt;/p>
&lt;p>トランザクションとは関係のないMapをまず宣言し、Selectしたデータに対して&lt;code>compute&lt;/code>を実行することにします。&lt;code>compute&lt;/code>では指定したkey（Memberのidなど）がMapの中にない場合にMemberのインスタンスを作成するようにして、すでにある場合はそのオブジェクトにMailingのデータを追加するようにすれば良いでしょう。そしてループが終わったらMapのvalueのみを取得すると良いですね。&lt;/p>
&lt;p>以上のことを、コードで表すと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// オブジェクトをまとめるためのMap（keyはMember.id）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> helperMap = mutableMapOf&amp;lt;Int, MemberDto&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Member&lt;/span>.leftJoin(Mailing)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .select {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#50fa7b">Member&lt;/span>.id eq id) and (&lt;span style="color:#50fa7b">Mailing&lt;/span>.memberId eq &lt;span style="color:#50fa7b">Mailing&lt;/span>.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> helperMap.compute(&lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Member&lt;/span>.id].&lt;span style="color:#ff79c6">value&lt;/span>) { key, &lt;span style="color:#ff79c6">value&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// valueがnullではない場合、コピーしてmailingAddressを累計
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">value&lt;/span>&lt;span style="color:#ff79c6">?.&lt;/span>copy(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailingAddress = &lt;span style="color:#ff79c6">value&lt;/span>.mailingAddress + &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Mailing&lt;/span>.address]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// valueがnullの場合はインスタンスを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> ) &lt;span style="color:#ff79c6">?:&lt;/span> MemberDto(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = key,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Member&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailingAddress = listOf(&lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">Mailing&lt;/span>.address])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// valueをListに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> helperMap.map { &lt;span style="color:#ff79c6">it&lt;/span>.&lt;span style="color:#ff79c6">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>いかがでしょうか。これで重複するデータなく、インスタンスの作成も最低限に抑えることができたかと思います。もちろん、mailingAddressを追加するたびにコピーが発生するという問題はありますが、ここは専用のsetterなどを作っておくことで回避できると思います。&lt;/p>
&lt;p>一つ注意しなくてはならないのは、ここで使っているMapをフィールドとして宣言したりするとデータの整合性やアプリケーションのメモリ使用量に響くということです。なので必ずメソッドの中でのみMapのインスタンスが作成されるようにする必要があります。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>DSLを使ってクエリを直接作成する場合、JPAのようなORMの問題とされているN+1(必ず連関しているテーブルもjoinしてくる)のような問題を回避できますが、直接オブジェクトへのマッピングも書かなくてはならないという短所がありますね。個人的にクエリを書くのは楽しくないですが、クエリをコードとして管理でき、必要なクエリだけを書けるというところでDSLの方が良い点もあると思います。テーブルの構造や処理によってはORMが勝手にクエリもマッピングもしてくれるのが楽ではありますが。&lt;/p>
&lt;p>ただ、ORMでどうやってデータを取得するかの問題だけでなく、ここで扱った「重複するデータをどう違う形のデータに加工するか」の問題は、必ずしもDBからレコードを取得する場合のみのことに限らないので（例えば他のAPIを読んだ結果としてもそんなデータはあり得ますね）、色々方法を考えておく必要はありそうです。今の時点ではMapを利用した方法がもっとも良さそうな気がしますが、他にもっと効率的な方法があるかも知れませんしね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Ktorを触ってみた</title><link>https://retheviper.github.io/posts/ktor-first-impression/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ktor-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.jpg" alt="Featured image of post Ktorを触ってみた" />&lt;p>サーバサイド言語としてのKotlinは普及しつつありますが、Kotlinを使う場合でもウェブフレームワークとして使われるのはやはりSpringが多いかと思います。理由としては会社ごとの事情というものもあるはずですが、一般的な理由としてはJavaエンジニアにとってKotlinは馴染みやすい物であっても、フレームワークの場合はそうでなく、Springほど検証されたフレームワークはないからということからでしょう。いまだにStrutsを使っていて、Springに移行しようとするところもありますしね。&lt;/p>
&lt;p>KotlinはJavaと完璧（に近い）互換性があるので、Javaで書かれてあるアプリをそのままKotlinに移行しても大した問題はありません。Javaより生産性が高い上にSpringだけでなくJackson、Apache POI、JUnit、Jacocoなどの数多くのライブラリをそのまま使えるのは確かにメリットであって、企業側としてKotlinの導入を検討する理由は確かにそこにあると思います。Javaエンジニアはその数が多いので、エンジニアを募集し安くなるというところもメリットの一つと言えるでしょう。&lt;/p>
&lt;p>ただ、Kotlinを使う場合に長期的にはKotlinで書かれたライブラリやフレームワークを導入することを検討した方が良いかもしれません。コンパイルした結果として生成されるByte codeがJavaと全く一緒だとしても、そもそものソースコードが違う言語なので、使う側のコード（クライアントコード）としては不便なところがあったり、Kotlinに最適化されてない場合もある可能性があるからです。また、KotlinはJVMだけでなく、ネイティブにコンパイルすることもできるので、ネイティブなアプリを作りたい場合はJavaに依存しないAPIを選ぶ必要があるでしょう。&lt;/p>
&lt;p>ということで、今回はJetBrains制のウェブフレームワーク、Ktorと、Ktorと一緒に使えるORMのExposedを少し触ってみて、Springと比べながら紹介したいと思います。&lt;/p>
&lt;h2 id="ktor">Ktor&lt;/h2>
&lt;p>Ktorは、JetBrainsで開発しているマイクロサービス向けの軽量ウェブフレームワークです。&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>公式ホームページ&lt;/a>の紹介にも色々書いてありますが、特にSpringと比べて以下の特徴があるかと思います。&lt;/p>
&lt;h3 id="軽量">軽量&lt;/h3>
&lt;p>Springも軽量とは言われているものの、起動が遅いので、実装する側としてはあまり軽量だという感覚はないです。Springで書かれたアプリケーションの起動が遅いのは、起動時にさまざまなアノテーションを読み込み、DIや設定などを完璧に終わらせているというフレームワークそのもののアーキテクチャに起因しているのではないかと思います。なのでDIされるオブジェクトをLate initにするなどで起動速度を短縮させるテクニックなどが知られていますね。&lt;/p>
&lt;p>しかし、Ktorは起動がかなり早いです。同一規模のアプリをSpringとKtorの両方で作成してベンチマークした訳ではないので正確な数値に関しては割愛しますが、体験だと数倍は早いですね。例えば、In memoryタイプのH2と基本的なCRUDを実装したSpring WebFluxアプリケーションの場合、自分のPCで起動に2.7秒ほどかかりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-07-18 15:08:25.150 INFO &lt;span style="color:#bd93f9">29047&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span>main&lt;span style="color:#ff79c6">]&lt;/span> c.r.s.SpringWebfluxSampleApplicationKt : Started SpringWebfluxSampleApplicationKt in 2.754 seconds &lt;span style="color:#ff79c6">(&lt;/span>JVM running &lt;span style="color:#ff79c6">for&lt;/span> 3.088&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じ構成でKtorのアプリを実装した場合、起動には1秒もかからなかったです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-07-18 15:09:29.683 &lt;span style="color:#ff79c6">[&lt;/span>main&lt;span style="color:#ff79c6">]&lt;/span> INFO ktor.application - Application started in 0.747 seconds.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはおそらく基本的にDIをしなく、アノテーションをあまり使わない（Reflectionを使わない）構造やKtorそのものはREST APIを作成するための必要最低限の機能だけを揃っているのが理由かと思われます。&lt;/p>
&lt;p>アプリの起動が早いというのは、テストにかかる時間を短縮させられるという面でもメリットといえますが、サーバレスなアプリにも適しているということにもなるでしょう。私もAWSのLambdaやAzureのFunctionsなどを触った経験がありますが、この場合にJavaやKotlinの使用を考慮したことはありません。サーバレスの場合、アプリが常に稼働中ではないので、リクエストが発生したたびにアプリを起動しなければならないです。なので起動の遅いSpringはそもそもの考慮対象にならなかったですね。Ktorを使う場合は起動速度が大幅に短縮できるので、JVMの起動速度が許されるというならば、サーバレスアーキテクチャで導入を検討できるレベルになっていると思います。&lt;/p>
&lt;h3 id="拡張可能">拡張可能&lt;/h3>
&lt;p>Ktorが軽量であることとも繋がる話ですが、必要な機能があればプラグイン（モジュール）を追加したり、自分で実装する必要はあります。コードとしては、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> embeddedServer(Netty, port = &lt;span style="color:#bd93f9">8080&lt;/span>, host = &lt;span style="color:#f1fa8c">&amp;#34;127.0.0.1&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(CORS)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(Compression)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(Sessions) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cookie&amp;lt;MyCookie&amp;gt;(&lt;span style="color:#f1fa8c">&amp;#34;MY_COOKIE&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(ContentNegotiation) { &lt;span style="color:#6272a4">// kotlinx.serialization
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> json()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.start(wait = &lt;span style="color:#ff79c6">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、Ktorの導入直後はモジュールの管理や開発のスピード感という側面ではマイナスになる部分もあるかなと思います。特にまだSpring Securityでは基本的に提供している&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%AD%E3%83%BC%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B9%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E5%88%B6%E5%BE%A1" target="_blank" rel="noopener"
>Role-Based Authorization&lt;/a>などの機能が公式プラグインとして提供されてないので自前の処理を書くしかないという部分もあります。個人的には、モジュール化そのものは慣れたらメリットになる可能性の方が高いと思いますが、導入初期としてはSpringに比べ不利なところなのではないかと思います。&lt;/p>
&lt;p>特にKtorはDIに対応していなく、JetBrains公式のモジュールもないので、DIをするためには&lt;a class="link" href="https://github.com/IVIanuu/injekt" target="_blank" rel="noopener"
>Injekt&lt;/a>, &lt;a class="link" href="https://kodein.org/Kodein-DI/?6.3/ktor" target="_blank" rel="noopener"
>Kodein&lt;/a>, &lt;a class="link" href="https://insert-koin.io" target="_blank" rel="noopener"
>Koin&lt;/a>などをディペンデンシーとして追加する必要があります。ただ、アーキテクチャによってはDIが必要なく、&lt;code>object&lt;/code>で代替することもできると思いますので、どんなアーキテクチャにするかはよく考えて決める必要があるかなと思います。&lt;/p>
&lt;h3 id="coroutine対応">Coroutine対応&lt;/h3>
&lt;p>Spring WebFluxもそうでしたが、最近は多くのウェブフレームワークに非同期・ノンブロッキング対応が行われていますね。PaaSが普及され簡単にインフラの構築ができ、ハードウェアが安くなった今でもソフトウェアで性能を改善できる箇所があるならそれは十分価値があると思っています。だとすると、非同期・ノンブロッキング対応のフレームワークを導入するということも良い選択ではないかと思います。&lt;/p>
&lt;p>Ktorではルーティングの実装として、&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/-route/index.html" target="_blank" rel="noopener"
>Route&lt;/a>の&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/route.html" target="_blank" rel="noopener"
>route&lt;/a>、もしくは&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/get.html" target="_blank" rel="noopener"
>get&lt;/a>, &lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/post.html" target="_blank" rel="noopener"
>post&lt;/a>, &lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/put.html" target="_blank" rel="noopener"
>put&lt;/a>, &lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/delete.html" target="_blank" rel="noopener"
>delete&lt;/a>などのfunctionを呼び出すことになります。これはSpring WebFluxのRouter/Hanlder Functionとよく似ていますね。コードで表すと、以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;/hello&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respondText(&lt;span style="color:#f1fa8c">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてこのHttpメソッドごとの関数のbodyを実装することになりますが、これが基本的に&lt;code>suspend&lt;/code>となっています。これはつまり、実装する側で特に意識しなくてもコードは非同期になるということですね。Spring WebFluxの場合も、Coroutineを使うと簡単に実装ができましたが、&lt;code>suspend&lt;/code>すら意識しなくて良いというところはKtorならではのメリットなのではという気がします。&lt;/p>
&lt;h3 id="テスト">テスト&lt;/h3>
&lt;p>&lt;code>ktor-server-test-host&lt;/code>や&lt;code>kotlin-test&lt;/code>、JUnitなどを使ってテストが可能です。Springでもユニットテストは色々な書き方があるかと思いますが、よりKotlinらしき書き方になっているだけで、基本的にテストの仕方が大きく変わったりはしません。例えば、&lt;code>Get&lt;/code>をのレスポンスをテストするためには以下のようなコードを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withTestApplication(Application&lt;span style="color:#ff79c6">::&lt;/span>module) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handleRequest(&lt;span style="color:#50fa7b">HttpMethod&lt;/span>.Get, &lt;span style="color:#f1fa8c">&amp;#34;api/v1/web/members/&lt;/span>&lt;span style="color:#f1fa8c">$id&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assertEquals(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">actual&lt;/span> = response.status(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expected = &lt;span style="color:#50fa7b">HttpStatusCode&lt;/span>.OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assertEquals(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">actual&lt;/span> = response.content,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expected = &lt;span style="color:#50fa7b">Json&lt;/span>.encodeToString(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemberResponse(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userId = userId,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exposed">Exposed&lt;/h2>
&lt;p>Ktorで使える、Kotlinで書かれたORMは代表的に&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>があります。Javaの&lt;a class="link" href="https://www.jooq.org" target="_blank" rel="noopener"
>jOOQ&lt;/a>がそうであったように、SQL DSLを使うことでクエリをコードで書くような感覚で（実施はDSLを解釈してSQLは自動生成されますが）使えるというところが良いです。例えば、Userというテーブルからレコードを取得する場合のコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> userInUsa: List&amp;lt;User&amp;gt; = transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">UserTable&lt;/span>.select {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">UserTable&lt;/span>.deleted eq &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">UserTable&lt;/span>.id],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">UserTable&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> country = &lt;span style="color:#ff79c6">it&lt;/span>[&lt;span style="color:#50fa7b">UserTable&lt;/span>.country]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.filter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.country = &lt;span style="color:#50fa7b">Country&lt;/span>.USA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、ExposedでははDAOパターンも使えるので、DAOパターンでクエリを書くとしたら以下のようなことができます。JPAやR2DBCと似たような感覚で使えそうですね。(デメリットもおそらく同じかと思いますが)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> userInGermany: List&amp;lt;User&amp;gt; = transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">User&lt;/span>.find { (&lt;span style="color:#50fa7b">UserTable&lt;/span>.country eq &lt;span style="color:#50fa7b">Country&lt;/span>.GERMANY) and (&lt;span style="color:#50fa7b">UserTable&lt;/span>.deleted eq &lt;span style="color:#ff79c6">false&lt;/span>)}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、Exposedの特徴は、テーブルをコードとして定義することでDBに反映させることができるということです。今まで&lt;a class="link" href="https://www.liquibase.org" target="_blank" rel="noopener"
>Liquibase&lt;/a>や&lt;a class="link" href="https://flywaydb.org" target="_blank" rel="noopener"
>Flyway&lt;/a>でDBの形状管理をやっていたことが多かったのですが、個人的に実際のDBとアプリケーションのテーブル定義に乖離があるケースを考えるとこうやってコードの中に定義した方が、データのオーナーという観点からもかなり良いのではないかと思います。特に、頻繁なテーブル定義の修正があったり、マイクロサービスが多いケースではかなり開発が便利になるのではないかと思います。&lt;/p>
&lt;p>Exposedのテーブル定義は、以下のようにできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">object&lt;/span> &lt;span style="color:#50fa7b">Member&lt;/span> : IntIdTable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> userId: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#f1fa8c">&amp;#34;user_id&amp;#34;&lt;/span>, length = &lt;span style="color:#bd93f9">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#f1fa8c">&amp;#34;name&amp;#34;&lt;/span>, length = &lt;span style="color:#bd93f9">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> password: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#f1fa8c">&amp;#34;password&amp;#34;&lt;/span>, length = &lt;span style="color:#bd93f9">255&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> deleted: Column&amp;lt;Boolean&amp;gt; = bool(&lt;span style="color:#f1fa8c">&amp;#34;deleted&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> createdBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#f1fa8c">&amp;#34;created_by&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> createdDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#f1fa8c">&amp;#34;created_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> lastModifiedBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#f1fa8c">&amp;#34;last_modified_by&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> lastModifiedDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#f1fa8c">&amp;#34;last_modified_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして実際発行されるSQLは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">CREATE&lt;/span> &lt;span style="color:#ff79c6">TABLE&lt;/span> &lt;span style="color:#ff79c6">IF&lt;/span> &lt;span style="color:#ff79c6">NOT&lt;/span> &lt;span style="color:#ff79c6">EXISTS&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;MEMBER&amp;#34;&lt;/span> (ID &lt;span style="color:#8be9fd;font-style:italic">INT&lt;/span> AUTO_INCREMENT &lt;span style="color:#ff79c6">PRIMARY&lt;/span> &lt;span style="color:#ff79c6">KEY&lt;/span>, DELETED &lt;span style="color:#8be9fd;font-style:italic">BOOLEAN&lt;/span> &lt;span style="color:#ff79c6">NOT&lt;/span> &lt;span style="color:#ff79c6">NULL&lt;/span>, CREATED_BY &lt;span style="color:#8be9fd;font-style:italic">VARCHAR&lt;/span>(&lt;span style="color:#bd93f9">16&lt;/span>) &lt;span style="color:#ff79c6">NOT&lt;/span> &lt;span style="color:#ff79c6">NULL&lt;/span>, CREATED_DATE DATETIME(&lt;span style="color:#bd93f9">9&lt;/span>) &lt;span style="color:#ff79c6">NOT&lt;/span> &lt;span style="color:#ff79c6">NULL&lt;/span>, LAST_MODIFIED_BY &lt;span style="color:#8be9fd;font-style:italic">VARCHAR&lt;/span>(&lt;span style="color:#bd93f9">16&lt;/span>) &lt;span style="color:#ff79c6">NOT&lt;/span> &lt;span style="color:#ff79c6">NULL&lt;/span>, LAST_MODIFIED_DATE DATETIME(&lt;span style="color:#bd93f9">9&lt;/span>) &lt;span style="color:#ff79c6">NOT&lt;/span> &lt;span style="color:#ff79c6">NULL&lt;/span>, USER_ID &lt;span style="color:#8be9fd;font-style:italic">VARCHAR&lt;/span>(&lt;span style="color:#bd93f9">16&lt;/span>) &lt;span style="color:#ff79c6">NOT&lt;/span> &lt;span style="color:#ff79c6">NULL&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;NAME&amp;#34;&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">VARCHAR&lt;/span>(&lt;span style="color:#bd93f9">16&lt;/span>) &lt;span style="color:#ff79c6">NOT&lt;/span> &lt;span style="color:#ff79c6">NULL&lt;/span>, PASSWORD &lt;span style="color:#8be9fd;font-style:italic">VARCHAR&lt;/span>(&lt;span style="color:#bd93f9">255&lt;/span>) &lt;span style="color:#ff79c6">NOT&lt;/span> &lt;span style="color:#ff79c6">NULL&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで、JPAやR2DBCの場合、Auditableクラスを定義して、エンティティがそれを継承することでカラムを共有したり、Spring Securityに連携することができましたが、Exposedでも似たようなことができました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">abstract&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Audit&lt;/span> : IntIdTable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> deleted: Column&amp;lt;Boolean&amp;gt; = bool(&lt;span style="color:#f1fa8c">&amp;#34;deleted&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> createdBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#f1fa8c">&amp;#34;created_by&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> createdDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#f1fa8c">&amp;#34;created_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> lastModifiedBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#f1fa8c">&amp;#34;last_modified_by&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> lastModifiedDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#f1fa8c">&amp;#34;last_modified_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">object&lt;/span> &lt;span style="color:#50fa7b">Member&lt;/span> : Audit() { &lt;span style="color:#6272a4">// Auditのカラムも含めてテーブルが作成される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> userId: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#f1fa8c">&amp;#34;user_id&amp;#34;&lt;/span>, length = &lt;span style="color:#bd93f9">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#f1fa8c">&amp;#34;name&amp;#34;&lt;/span>, length = &lt;span style="color:#bd93f9">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> password: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#f1fa8c">&amp;#34;password&amp;#34;&lt;/span>, length = &lt;span style="color:#bd93f9">255&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MyBatisなどに慣れている場合は少し適応に時間が必要かもしれませんが、基本的にはテーブルの定義を除くとほぼSQLの発行をKotlinのコードで書くことになるという感覚なので、便利になるかと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>以上で、簡単なCRUDアプリをKtor + Exposedで実装してみた後の感想と紹介を少し書いてみました。まとめると、かなりサクサクコードを書けて性能も良いので、マイクロサービスに特化している構成ではないかと思いました。また、冒頭に述べた通り、ピュアなKotlin制のフレームワークであることも良いですね。Ktorの紹介でもKotlin Multiplatformに基づいていてどのプラットフォームにもアプリをデプロイできると強調していますので、色々なところで活用ができるかと思います。&lt;/p>
&lt;p>まだSpringと他のJavaライブラリに比べ足りないモジュールや機能もありますが、Exposed以外でも&lt;a class="link" href="https://www.ktorm.org" target="_blank" rel="noopener"
>Ktorm&lt;/a>のようなORMがあるなどKotlin制のライブラリの開発も進めていて、IntellijでもKtorのサポートは強力なので今後も発展を期待できそうであります。個人的にまだ仕事で使うことには無理があっても、自作アプリなどを作りたい時は導入をぜひ検討したいと思いました。Kotlinでできることがだんだん増えてきていて、嬉しいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その二〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-2/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-2/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その二〜" />&lt;p>&lt;a class="link" href="../kotlin-code-in-my-style-1" >前回&lt;/a>に続いて、今回も簡単にKotlinで色々書いてみましたのでその紹介となります。Kotlinではスタンダードライブラリや言語仕様として提供している機能がかなり多いので、これらを使いこなすだけでも生産性やコードのクォリティが大幅に上がるのではないかと思います。なので、今回もJava的な書き方を、Kotlinではどんな方法で効率よく実現できるかを中心に紹介したいと思います。&lt;/p>
&lt;p>もちろんKotlinでは基本的にJavaの書き方でも全く問題なく動くコードを書けますが、Kotlinならではのコードに変えた方がより簡単で短いコードを書ける場合が多く、色々と手間を省けることができるので（そして大抵の場合、スタンダードライブラリの実装の方が自分の書いたコードよりクォリティ高いような…）こういう工夫はする価値が十分にあるのではないかと思います。&lt;/p>
&lt;p>なので、今回は自分が調べたKotlinの小技を少し紹介したいと思います。&lt;/p>
&lt;h2 id="sequentialなデータを作成する">Sequentialなデータを作成する&lt;/h2>
&lt;p>よくユニットテストなどでテスト用データを作成して使う場合がありますね。こういう時に必要となるデータの種類は色々とあるかと思いますが、複数のレコードを番号をつけて順番に揃えた感じのものを作りたい場合もあると思います。例えばData01、Data02、Data03…といったデータを作りたい場合ですね。&lt;/p>
&lt;p>この場合は、ループでデータを作り、Listにまとめるというのが一般的ではないかと思います。例えば以下のような例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// テスト用データを作成する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createTestDatas&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// テスト用データのリスト
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> testDatas = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 10件のデータを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> until &lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testDatas.add(&lt;span style="color:#f1fa8c">&amp;#34;テスト&lt;/span>&lt;span style="color:#f1fa8c">$i&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// read-onlyに変換して返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> testDatas.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、どちらかというとこれはJavaのやり方に近いので、まずはこれをベースに、Kotlinらしきコードではどうやって同じことができるかを考えてみたいと思います。&lt;/p>
&lt;h3 id="repeat">repeat&lt;/h3>
&lt;p>まず考えられる方法は、ループの単純化ですね。サイズが10のリストを作りたいということは、ループが10回であることなので、それに相応しい関数を使います。例えば&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html" target="_blank" rel="noopener"
>repeat&lt;/a>がありますね。&lt;code>repeat&lt;/code>を使うと、スコープ内のパラメータとしてインデックスが渡されるので、簡単に&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createTestDatas&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> testDatas = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 10回繰り返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> repeat(&lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testDatas.add(&lt;span style="color:#f1fa8c">&amp;#34;テスト&lt;/span>&lt;span style="color:#f1fa8c">$i&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> testDatas.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に考えたいのは、&lt;code>MutableList&lt;/code>を&lt;code>Immutable&lt;/code>に変えることです。テストで使うデータとしては問題ない場合はありますが、変更する必要のないデータをそのまま&lt;code>Mutable&lt;/code>にしておくのはあまり良い選択ではありませんね。なので、データの作成を最初から&lt;code>List&lt;/code>にできる方法を取りたいものです。&lt;/p>
&lt;p>ここでは二つの道があって、最初からサイズを指定した&lt;code>List&lt;/code>を宣言するか、ループの範囲、つまり&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html#range" target="_blank" rel="noopener"
>Range&lt;/a>を指定する方法があります。&lt;/p>
&lt;h3 id="list">List&lt;/h3>
&lt;p>まずはサイズを指定した&lt;code>List&lt;/code>を作る方法からみていきましょう。インスタンスの作成時に、サイズと要素に対してのイニシャライザを引数として渡すことで簡単に指定したサイズ分の要素を作ることができます。例えば、上で紹介したコードは&lt;code>List&lt;/code>を使うことで以下のように変えることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createTestDatasByList&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(&lt;span style="color:#bd93f9">10&lt;/span>) { &lt;span style="color:#f1fa8c">&amp;#34;テスト&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この方法は、実は先に紹介した方法と根本的に違うものではありません。実装としては、以下のようになっているので、Syntax sugarとして使えるということがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@SinceKotlin(&lt;span style="color:#f1fa8c">&amp;#34;1.1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@kotlin.&lt;span style="color:#ff79c6">internal&lt;/span>.InlineOnly
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>(size: Int, &lt;span style="color:#ff79c6">init&lt;/span>: (index: Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): List&amp;lt;T&amp;gt; = MutableList(size, &lt;span style="color:#ff79c6">init&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@SinceKotlin(&lt;span style="color:#f1fa8c">&amp;#34;1.1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@kotlin.&lt;span style="color:#ff79c6">internal&lt;/span>.InlineOnly
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">MutableList&lt;/span>(size: Int, &lt;span style="color:#ff79c6">init&lt;/span>: (index: Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> list = ArrayList&amp;lt;T&amp;gt;(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(size) { index &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> list.add(&lt;span style="color:#ff79c6">init&lt;/span>(index)) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも&lt;code>List&lt;/code>を使う場合は、&lt;code>itnit&lt;/code>としてどんな関数を渡すかによって、&lt;code>step&lt;/code>の設定などができるのも便利ですね。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#bd93f9">5&lt;/span>) { &lt;span style="color:#f1fa8c">&amp;#34;Test&lt;/span>&lt;span style="color:#f1fa8c">${ it * 2 }&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// [Test0, Test2, Test4, Test6, Test8]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#bd93f9">5&lt;/span>) { (&lt;span style="color:#ff79c6">it&lt;/span> * &lt;span style="color:#bd93f9">2&lt;/span>).let { index &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$index&lt;/span>&lt;span style="color:#f1fa8c"> は偶数&amp;#34;&lt;/span> } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// [0 は偶数, 2 は偶数, 4 は偶数, 6 は偶数, 8 は偶数]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、結果的に作られる&lt;code>List&lt;/code>のインスタンスは&lt;code>MutableList&lt;/code>なので、生成したデータをread-onlyにしたい場合はまたこれを&lt;code>toList()&lt;/code>などで変換する必要があるという問題があります。&lt;/p>
&lt;h3 id="range">Range&lt;/h3>
&lt;p>では、もう一つの方法をまた試してみましょう。Kotlinでは数字の範囲を指定することだけで簡単に&lt;code>Range&lt;/code>オブジェクトを作成することができます。&lt;code>Range&lt;/code>を使う場合、上記のコードは以下のように変えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Rangeを使ってテストデータを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createTestDatasByRange&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#bd93f9">0.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>).map { &lt;span style="color:#f1fa8c">&amp;#34;テスト%it&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>List&lt;/code>の時とは違って、&lt;code>Range&lt;/code>には&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-int-range" target="_blank" rel="noopener"
>IntRange&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-long-range" target="_blank" rel="noopener"
>LongRange&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-char-range" target="_blank" rel="noopener"
>CharRange&lt;/a>などがあり、引数の数字や文字を調整することで簡単にアレンジができるということも良いです。&lt;/p>
&lt;p>また、一般的に性能は&lt;code>List&lt;/code>より&lt;code>Range&lt;/code>の方が良いようです。以下のようなコードでベンチマークした際、大抵&lt;code>Range&lt;/code>の方が&lt;code>List&lt;/code>の倍ぐらい早いのを確認できました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> kotlin.system.measureTimeMillis
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Person&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> name: String, &lt;span style="color:#ff79c6">val&lt;/span> Num: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark { list() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark { range() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">benchmark&lt;/span>(function: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(measureTimeMillis { function() })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">list&lt;/span>() =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(&lt;span style="color:#bd93f9">200000&lt;/span>) { Person(&lt;span style="color:#f1fa8c">&amp;#34;person&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">range&lt;/span>(): List&amp;lt;Person&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#bd93f9">0.&lt;/span>.&lt;span style="color:#bd93f9">200000&lt;/span>).map { Person(&lt;span style="color:#f1fa8c">&amp;#34;person&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一つ気にしなくてはならないのは、&lt;code>Range&lt;/code>の場合は基本的に値が1づつ増加することになっているので、&lt;code>for&lt;/code>や&lt;code>List&lt;/code>のような&lt;code>step&lt;/code>の条件が使えません。なので場合によってどちらを使うかは考える必要があります。&lt;/p>
&lt;h2 id="check">Check&lt;/h2>
&lt;p>Validationなどで、パラメータの値を確認しなければならない場合があります。Kotlinでは&lt;code>Nullable&lt;/code>オブジェクトとそうでないオブジェクトが分けられているので、Javaと違って引数に&lt;code>null&lt;/code>が渡される場合はコンパイルエラーとなりますが、ビジネスロジックによってはそれ以外のことをチェックする必要もあり、自前のチェックをコードで書くしかないです。&lt;/p>
&lt;p>まず、お馴染みのJavaのやり方を踏襲してみると、以下のようなコードを書くことができるでしょう。関数の引数と、その戻り値のチェックが含まれている例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: String): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (parameter.isBlank()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#f1fa8c">&amp;#34;文字列が空です&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> result = someRepository.find(parameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (result &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> IllegalStateException(&lt;span style="color:#f1fa8c">&amp;#34;結果がnullです&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで少し違う言語の例をみていきたいと思います。Kotlinとよく似ていると言われているSwiftの場合、ここで&lt;a class="link" href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#grammar_if-statement" target="_blank" rel="noopener"
>Guard Statement&lt;/a>を使うのが一般的のようです。チェックのための表現が存在することで、ビジネスロジックとチェックが分離されるのが良いですね。Swiftをあまり触ったことがないので良い例にはなっていないかも知れませんが、イメージ的には以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>) &lt;span style="color:#ff79c6">throws&lt;/span> -&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">guard&lt;/span> &lt;span style="color:#ff79c6">!&lt;/span>parameter.isEmpty &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> ValidationError.invalidArgument
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">guard&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">result&lt;/span> = someRepository.find(parameter) &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> ValidationError.notFound
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じく、Kotlinでもチェックのための表現とビジネスロジックが分離できれば、コードの意味がより明確になるはずです。Kotlinではどうやってそれを実現できるのでしょうか。例えば以下のようなことを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: String?): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> checkedParameter = requireNotNull(parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;文字列がnullです&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> result = someRepository.find(checkedParameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> checkNotNull(result) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;結果がnullです&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require-not-null.html" target="_blank" rel="noopener"
>requireNotNull&lt;/a>は、渡された引数が&lt;code>null&lt;/code>である場合は&lt;code>IllegalArgumentException&lt;/code>を投げ、そうでない場合は引数を&lt;code>non-null&lt;/code>タイプとして返します、明確に&lt;code>null&lt;/code>チェックをしていることが解るだけでなく、以降チェックがいらないので便利です。また、&lt;code>lazy message&lt;/code>として&lt;code>IllegalArgumentException&lt;/code>が発生した時のメッセージを指定できるのも良いですね。&lt;/p>
&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html" target="_blank" rel="noopener"
>checkNotNull&lt;/a>の場合も機能的には&lt;code>requireNotNull&lt;/code>と変わらないですが、&lt;code>null&lt;/code>の場合に投げる例外が&lt;code>IllegalStateException&lt;/code>となります。なので、用途に合わせてこの二つを分けて使えますね。&lt;/p>
&lt;p>他に使えるものとしては&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html" target="_blank" rel="noopener"
>require&lt;/a>があります。こちらは条件式を渡すことで、&lt;code>null&lt;/code>チェック以外のこともできます。なので、以下のコードのように、&lt;code>Int&lt;/code>型のデータに対して範囲をチェックするということもできるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> require(parameter &amp;gt; &lt;span style="color:#bd93f9">100&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$parameterは大きすぎます&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、&lt;a class="link" href="https://kotlinlang.org/docs/null-safety.html#elvis-operator" target="_blank" rel="noopener"
>Elvis operator&lt;/a>を使う方法もありますね。この場合は、&lt;code>null&lt;/code>の場合にただ例外を投げるだけでなく、代替となる処理を書くことができますので色々と活用できる余地があります。例えば以下のようなことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: String?): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> checkedParameter = parameter &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> result = someRepository.find(checkedParameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> CustomException(&lt;span style="color:#f1fa8c">&amp;#34;結果がnullです&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="listの分割">Listの分割&lt;/h2>
&lt;p>とある条件と一致するデータをListから抽出したい場合は、&lt;code>filter&lt;/code>のようなoperationを使うことでできます。しかし、条件が二つだとどうすればいいでしょうか。正確には、一つのリストに対して、指定した条件に一致する要素とそうでない要素の二つのリストに分離したい場合です。&lt;/p>
&lt;p>こういう場合はとりあえず下記のように2回ループさせる方法があると思いますが、これはあまり効率がよくないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> origin = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 奇数を抽出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> odd = origin.filter { &lt;span style="color:#ff79c6">it&lt;/span> % &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 偶数を抽出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> even = origin.filter { &lt;span style="color:#ff79c6">it&lt;/span> % &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ループを減らすためには、あらかじめ宣言したリストに対してループの中で分岐処理を行うという方法があるでしょう。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> origin = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 奇数と偶数のリストを宣言しておく
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> odd = mutableListOf&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> even = mutableListOf&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ループ処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>origin.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">it&lt;/span> % &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd.add(&lt;span style="color:#ff79c6">it&lt;/span>) &lt;span style="color:#6272a4">// 奇数のリストに追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even.add(&lt;span style="color:#ff79c6">it&lt;/span>) &lt;span style="color:#6272a4">// 偶数のリストに追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>幸い、この状況にぴったりな方法をKotlinのスタンダードライブラリが提供しています。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html" target="_blank" rel="noopener"
>partition&lt;/a>というoperationです。このopreationを使うと、元のリストの要素を条件に一致するものとそうでないもので分割してくれます。&lt;/p>
&lt;p>また、&lt;code>partition&lt;/code>戻り値は&lt;code>Pair&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;/code>なので、&lt;a class="link" href="https://kotlinlang.org/docs/destructuring-declarations.html" target="_blank" rel="noopener"
>destructuring-declaration&lt;/a>と組み合わせることでかなり短いコードになります。実際のコードは以下のようになるりますが、かなりスマートですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> origin = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> (odd, even) = origin.partition { &lt;span style="color:#ff79c6">it&lt;/span> % &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> } &lt;span style="color:#6272a4">// 条件に一致するものと一致しないものでリストを分離
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>Kotlinは便利ではありますが、言語自体が提供する便利さ（機能）が多いゆえに、APIの使い方を正しく活用できるかどうかでコードのクォリティが左右される部分が他の言語と比べ多いような気がしています。さらにバージョンアップも早く、次々と機能が追加されるのでキャッチアップも大事ですね。&lt;/p>
&lt;p>でも確かに一つづつKotlinでできることを工夫するうちに、色々とできることが増えていく気もしていますね。研究すればするほど力になる言語を使うということは嬉しいことです。ということで、これからもKotlinで書いてみたシリーズは続きます。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Sequenceは常にいいか</title><link>https://retheviper.github.io/posts/kotlin-collection-and-sequence/</link><pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-collection-and-sequence/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Sequenceは常にいいか" />&lt;p>とある処理を書く方法が色々ある場合は、どれを選んだ方がもっとも良いかと悩ましくなります。こういう場合は、コードの読みやすさやコードの長さ、予想される問題のようなさまざまな観点からそれぞれの方式を比較してどれを選ぶか判断することになりますね。ただ、このような観点から判断するのは多くの場合「書き方が全く違う」場合に有効であって、そもそも似たようなコードを書くことになる場合は他の観点からも考える必要があります。ほんの少しだけ違うから、見た目だけでは違いがわからない場合。こういう時はそのAPIの内部、メカニズムからちゃんと考えて選ぶ必要がありますね。&lt;/p>
&lt;p>そういう意味で、今回はKotlinのCollectionの処理に使える方法の二つ、「Collectionのoperation直接使う」場合と「Sequenceに変換してから処理する」場合の違いに関して述べたいと思います。&lt;/p>
&lt;h2 id="処理方式の違い">処理方式の違い&lt;/h2>
&lt;p>Javaでは、Collectionの要素を持って処理をする方法は色々とありますが、大きく分けて1.8以前の方法(&lt;code>for&lt;/code>や&lt;code>while&lt;/code>などを利用したループ)と1.8以降の方法(&lt;code>Stream&lt;/code>を使った方法)があると言ってもいいのではないかと思います。この二つの方法はそもそもベースとなっているパラダイムそのものが違うので、コードを書くスタイルから大きく違います。例えば同じ処理をしたい場合でも、以下のコードで確認できるように、見た目が完全に違います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// forループの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">filterEven&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Integer&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> list &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">4&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">7&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">8&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">9&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> result &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ArrayList&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>Integer i &lt;span style="color:#ff79c6">:&lt;/span> list&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>i &lt;span style="color:#ff79c6">%&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">add&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toString&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>result&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">size&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Streamを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">filterEvenStream&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">4&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">6&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">7&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">8&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">9&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">filter&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> i &lt;span style="color:#ff79c6">%&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">map&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> i&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toString&lt;/span>&lt;span style="color:#ff79c6">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">limit&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Streamを使った処理の場合はoperationを積み重ねて行く形をしていますが、これは現代の関数型プログラミングに対応している言語ならどれも持っているAPIといえます。例えばKotlin, 公式的には呼び方が色々あるようですが、一部では&lt;code>Functional function&lt;/code>という名で呼ばれているようで、今回はこの操作方式、Functional functionについて述べたいと思います。&lt;/p>
&lt;p>KotlinではCollectionでもこのようなopreationがあり、Kotlin版のStreamとも言える&lt;a class="link" href="https://kotlinlang.org/docs/sequences.html" target="_blank" rel="noopener"
>Sequence&lt;/a>でも同様の操作できるようになっています。また、JavaのStreamをそのまま使うこともできるので、Functional functionを使った処理は三つがあるといえますね。それぞれの使い方もあまり変わりません。なので以下のようなコードで同じ処理ができますが、それが帰って悩ましくなるところでもあります。「どれを使ったらいい？」とですね。例えば同じ処理をしたい場合でも、Kotlinでは以下のように色々な方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Collectionの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">filterEven&lt;/span>(): List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>).filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }.map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }.take(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Sequenceを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">filterEvenSequence&lt;/span>: List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>).asSequence().filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }.map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }.take(&lt;span style="color:#bd93f9">3&lt;/span>).toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// JavaのStream APIを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">filterEvenStream&lt;/span>(): List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>).stream().filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }.map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }.limit(&lt;span style="color:#bd93f9">3&lt;/span>).collect(&lt;span style="color:#50fa7b">Collectors&lt;/span>.toList())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは見た目ではあまり違いがわからないですね。処理やロジックが大きく変わる訳でもありません。使い方があまり変わらなく、結果としても同じようなものを期待できるとしたら、やはり次に気にすべきは「性能」ではないかと思います。特にCollectionよりもSequenceの方がより性能がいいという話もありますので、それならなるべくSequenceを使った方が絶対良いはずですね。&lt;/p>
&lt;p>しかし、それを事実と受け止めるとしたら、いくつかの疑問が残ります。常にSequenceの方が性能で有利だとしたら、なぜCollectionからFunctional functionを呼び出す時は内部でSequenceに変換するようにするのでなく、わざわざ&lt;code>asSequence()&lt;/code>を呼び出して明示的な変換をさせるのでしょうか？もしくはなぜCollectionでもFunctional functionを呼び出せるようにしているのでしょうか？これはつまり、SequenceがCollectionよりも性能がよくなるのは「とある条件下に限る」ということではないでしょうか。なので、今回は主に性能の観点から、CollectionとSequenceの違いについて述べましょう。&lt;/p>
&lt;h3 id="lazy-evaluation">Lazy evaluation&lt;/h3>
&lt;p>KotlinのSequenceは、元々JavaのStreamと同じ名前になる予定だったそうです。これはただの偶然ではなく、実際の処理もStreamに似ているからです。何が似ているかというと、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1" target="_blank" rel="noopener"
>Lazy evaluation&lt;/a>という概念です。これは簡単に言いますと、「なるべく処理を遅延させる = 必要とされるまでは処理をしない」ということですね。そして多くの場合、Sequenceを使うとこのLazy evaluationのおかげで性能がよくなるという話があります。これはつまり、Sequenceは処理を遅延することでCollectionより良い性能を期待できる、ということになるでしょう。&lt;/p>
&lt;p>しかし、単純に処理を遅延させることががなぜ性能を向上させる事になるのか、すぐに納得は行きません。まず、ループ処理の中で「必要によって処理をするかどうかを決定する」という概念がピンと来ないですね。我々が認識しているループ処理とは、対象となるデータモデルの全要素を巡回しながら処理をするという意味ですので。&lt;/p>
&lt;p>だからSequenceを使った方が性能がよくなると言っても、パフォーマンスはさまざまな要素によって劣化も向上もするものなので、その話だけを信じて全ての処理をSequenceに変えるということは危ないです。そもそもSequenceがそんなに良いものであれば、全てのIterableなオブジェクトをなぜSequenceとして処理しないか、という疑問も湧いてきますね。なので、まずはCollectionとSequenceでFunctional functionがどう違うか、コードどそれを実行した結果で説明したいと思います。&lt;/p>
&lt;h4 id="eager-evaluationのcollection">Eager evaluationのCollection&lt;/h4>
&lt;p>CollectionでのFunctional functionは、Eager evalutionと言われています。これはLazy evaluationの逆で、必要とされてなくてもとりあえず処理を行っておくということです。こうする場合期待できることは、メモリ上にすでに処理の結果が残っていて、複数回呼ばれた場合はそのキャッシュを使うことができるということですね。&lt;/p>
&lt;p>Eager evaluationだと、Functional functionが呼ばれるたび、その全要素に対しての処理をまず行うことになります。例えば、以下のような処理を書いたとしましょう。&lt;code>onEach()&lt;/code>は処理の流れを視覚化するためのものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;Found even: &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;Now &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c"> is String&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .take(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c"> has taken&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを実行した結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">2&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">4&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">6&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">8&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">10&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">4&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">6&lt;/span> has taken
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、CollectionでのFunctional functionでは以下のような順で処理します。&lt;/p>
&lt;ol>
&lt;li>Listからfilterのpredicateに当てはまる要素を探し、その結果でListを作る&lt;/li>
&lt;li>filterされたListの要素をmapし、その結果でListを作る&lt;/li>
&lt;li>mapされたListの要素からtakeする&lt;/li>
&lt;/ol>
&lt;p>これを絵で表現すると以下の通りです。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 262;
flex-basis: 630px"
>
&lt;a href="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing.png" data-size="990x377">
&lt;img src="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing.png"
width="990"
height="377"
srcset="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing_hu8247a2d18d26f289432d35b2d30aabb1_33214_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing_hu8247a2d18d26f289432d35b2d30aabb1_33214_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Kotlin List Processing">
&lt;/a>
&lt;figcaption>Kotlin List Processing&lt;/figcaption>
&lt;/figure>
&lt;em>出典：Kotlin公式ドキュメント - &lt;a class="link" href="https://kotlinlang.org/docs/sequences.html#iterable" target="_blank" rel="noopener"
>Sequences&lt;/a>&lt;/em>&lt;/p>
&lt;h5 id="collectionのopreation">Collectionのopreation&lt;/h5>
&lt;p>Collectionでの処理は上記の通りですが、実装としてはどうでしょうか。ここではCollectionでの&lt;code>map()&lt;/code>のコードを見ていきたいと思います。コードとしては以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">R&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Iterable&lt;/span>&amp;lt;T&amp;gt;.map(transform: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R): List&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> mapTo(ArrayList&amp;lt;R&amp;gt;(collectionSizeOrDefault(&lt;span style="color:#bd93f9">10&lt;/span>)), transform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mapTo()&lt;/code>という関数に、元のCollectionのサイズで新しくインスタンスを作成した&lt;code>ArrayList&lt;/code>とLambdaを渡しています。ちなみに&lt;code>collectionSizeOrDefault()&lt;/code>という関数は、以下のような実装となっています。Collectionである場合はそのサイズを、そうでない場合（Sequenceなど）はデフォルトとして10のサイズを持つListになるということがわかりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">internal&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Iterable&lt;/span>&amp;lt;T&amp;gt;.collectionSizeOrDefault(default: Int): Int = &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span> &lt;span style="color:#ff79c6">is&lt;/span> Collection&amp;lt;*&amp;gt;) &lt;span style="color:#ff79c6">this&lt;/span>.size &lt;span style="color:#ff79c6">else&lt;/span> default
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>mapTo()&lt;/code>という関数の中では、元のCollectionをループしながら新しいListにLambdaの実行結果を追加するという実装となっています。実際のコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">R&lt;/span>, &lt;span style="color:#50fa7b">C&lt;/span> : &lt;span style="color:#50fa7b">MutableCollection&lt;/span>&amp;lt;&lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#50fa7b">R&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#50fa7b">Iterable&lt;/span>&amp;lt;T&amp;gt;.mapTo(destination: C, transform: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R): C {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (item &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destination.add(transform(item))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、一つのFunctional functionが呼ばれるたびにListに対するループが発生し、さらに新しいListを作ることになるということです。なので上記のサンプルコードの場合だとループは6回、Listの作成は4回であるといえます。&lt;code>onEach()&lt;/code>を除外するとしてもループは3回なので、かなり多い印象ですね。&lt;/p>
&lt;p>ここで考えられるものは、「Sequenceの方が性能がいい」という話は、Sequenceを使った場合にこのようなループ回数やListの作成を減らせられるということになるのではないか、ということですね。Sequenceではどんな処理をしていて、実際にこのようなループやListを作る回数などを減らしているということでしょうか。同じ処理を書いた場合にSequenceではどのようなことが起きるかを見ていきましょう。&lt;/p>
&lt;h4 id="lazy-evaluationのsequence">Lazy evaluationのSequence&lt;/h4>
&lt;p>Collectionは、&lt;code>asSequence()&lt;/code>を呼び出すことで簡単にSequenceによる処理に変換することができます。ただ、このコードを実際に走らせるためにはJavaのStreamと同じく終端処理が必要となるのがポイントです。これも「必要とされるまでは実際の処理を行わない」Lazy evaluationの特徴といえます。例えば以下のようなコードを書いたとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .asSequence() &lt;span style="color:#6272a4">// Sequenceに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> .filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;Found even: &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;Now &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c"> is String&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .take(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c"> has taken&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList() &lt;span style="color:#6272a4">// Collectionに再変換（終端処理で処理を走らせる）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを実行した結果は以下の通りです。Collectionの場合と結果は同じであるものの、処理の順番が変わっていることを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">2&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">4&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">4&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">6&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">6&lt;/span> has taken
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、そもそも8と10に対しての処理は行われてないということです。これはCollectionで全要素に対して一つのFunctional functionの処理が終わったあと、次のFunctional functionが実行される構造に対して、Sequenceは一つの要素に対しての全ての処理が終わったあと次の要素に対して同じ処理を繰り返しているということです。言葉で表現すると複雑ですが、以下のような順になっているということです。&lt;/p>
&lt;ol>
&lt;li>Listの要素にfilterを当てる&lt;/li>
&lt;li>要素がfilterのpredicateに当てはまるものなら次の処理に移行する&lt;/li>
&lt;li>filterされた要素をmapする&lt;/li>
&lt;li>mapされた要素をtakeする&lt;/li>
&lt;li>次の要素に対して同じ処理を繰り返す&lt;/li>
&lt;/ol>
&lt;p>これを絵で表現すると以下の通りです。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 231;
flex-basis: 556px"
>
&lt;a href="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing.png" data-size="990x427">
&lt;img src="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing.png"
width="990"
height="427"
srcset="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing_huad9a91ec7000e356fa550a56d0b6e8a9_37351_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing_huad9a91ec7000e356fa550a56d0b6e8a9_37351_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Kotlin Sequence Processing">
&lt;/a>
&lt;figcaption>Kotlin Sequence Processing&lt;/figcaption>
&lt;/figure>
&lt;em>出典：Kotlin公式ドキュメント - &lt;a class="link" href="https://kotlinlang.org/docs/sequences.html#sequence" target="_blank" rel="noopener"
>Sequences&lt;/a>&lt;/em>&lt;/p>
&lt;p>処理の順番や仕組みが違うので、Collectionの時とは実装もかなり違うだろうと予想ができますね。では、こちらの実装を見ていきましょう。&lt;/p>
&lt;h5 id="sequenceでのoperation">Sequenceでのoperation&lt;/h5>
&lt;p>Collectionと同じく、Sequenceの&lt;code>map()&lt;/code>の実装を覗いてみましょう。先程のコードでSequenceの&lt;code>map()&lt;/code>は中間処理であり、新しいCollectionを作り出すわけではないということはわかりました。実装を見ると、以下のようになっていて、処理結果が反映されたSequenceを返しているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">R&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.map(transform: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R): Sequence&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> TransformingSequence(&lt;span style="color:#ff79c6">this&lt;/span>, transform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、内部で&lt;code>TransformingSequence&lt;/code>という新しいSequenceのインスタンスを作成しているのがわかりますね。このクラスの実装は以下の通りです。ここでループごとにLambdaの実行が行われていますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">internal&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">TransformingSequence&lt;/span>&amp;lt;T, R&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">constructor&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> sequence: Sequence&amp;lt;T&amp;gt;, &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> transformer: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R) : Sequence&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">iterator&lt;/span>(): Iterator&amp;lt;R&amp;gt; = &lt;span style="color:#ff79c6">object&lt;/span> : &lt;span style="color:#50fa7b">Iterator&lt;/span>&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> iterator = sequence.iterator()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">next&lt;/span>(): R {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> transformer(iterator.next())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">hasNext&lt;/span>(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> iterator.hasNext()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">internal&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">E&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">flatten&lt;/span>(iterator: (R) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Iterator&amp;lt;E&amp;gt;): Sequence&amp;lt;E&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> FlatteningSequence&amp;lt;T, R, E&amp;gt;(sequence, transformer, iterator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のコードの実行結果と実装でわかるように、Sequenceを使う場合は一つの要素を単位として処理を行っていくので、CollectionでFunctional functionを使う場合に発生し得る不要な処理(毎回Listを生成する、前要素に対してmapを行うなど)を減らせると期待できます。なので元のCollectionが大きい場合やoperationが多い場合はSequenceの方がより良いように見えます。&lt;/p>
&lt;p>ただ、性能の観点で考えると、CollectionとSequenceの違いはもう一つ考慮すべきところがあります。それはデータ構造の違いです。&lt;/p>
&lt;h2 id="stateless">Stateless&lt;/h2>
&lt;p>JavaのStreamでもそうでしたが、Sequenceは状態(State)を持たないのが特徴です。ここで状態を持たないということは、持っている要素の数や順番などに対しての情報がないということを意味します。なぜかというと、SequenceがIteratorに基づいているものだからです。そしてそれが原因で、処理の種類によってCollectionよりも性能は劣る可能性もまたあります。&lt;/p>
&lt;p>先に使っていたサンプルコードを持って考えてみましょう。サンプルコードでは、Sequenceの終端処理としてListを返すために&lt;code>toList()&lt;/code>を呼び出していました。これは、「状態を持たない」ものから「状態を持つ」ものに変換することですね。簡単なやり方としては、MutableなListを作って、全要素を一つづつ&lt;code>add()&lt;/code>していく方法があるでしょう。実際はどうでしょうか？まずは&lt;code>toList()&lt;/code>のコードをみてみましょう。以下がその実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.toList(): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>.toMutableList().optimizeReadOnlyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まずMutableなListに変換して、さらに読み込み専用（Immutable）のListに変換しているように見えます。さらにMutable Listに変えているところの実装をみてみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.toMutableList(): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> toCollection(ArrayList&amp;lt;T&amp;gt;())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ArrayListのインスタンスを作って、それを&lt;code>toCollection()&lt;/code>に渡していますね。ここで&lt;code>toCollection()&lt;/code>はSequenceをCollectionに帰る時の共通処理で、型を指定にするため引数にListを渡しているようです。さらに&lt;code>toCollection()&lt;/code>の実装をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">C&lt;/span> : &lt;span style="color:#50fa7b">MutableCollection&lt;/span>&amp;lt;&lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#50fa7b">T&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.toCollection(destination: C): C {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (item &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destination.add(item)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここまでたどり着いてわかったのは、やはりSequenceの要素を一つ一つListの中に入れているということですね。ただ、単純な処理ではありますが、ここでは「Listに要素を足していく」ということ自体に注目する必要があります。&lt;/p>
&lt;p>先に述べた通り、Sequenceは自分が持つ要素の数をわからないので、Listのインスタンスを作る時はサイズを「仮定」して処理するしかないです。そして基本的にMutableなListでは、現在のサイズよりも多くの要素を追加する必要がある時、内部のArrayより大きいサイズのArrayを新しく作り、そこに要素をコピーしていくことを繰り返します。そしてこれを全要素が揃うまで繰り返していきますね。ということは、Sequenceの要素が多ければ多いほどArrayのインタンス作成とコピーが多くなるということになります。&lt;/p>
&lt;p>そしてコピーが全部終わった場合、実際の要素数よりArrayのサイズが大きい場合もありますね。その場合、メモリを無駄に使うだけでなく、実際のサイズもわからなくなるので、サイズを要素数に合わせて再調整する必要があります。&lt;code>toList()&lt;/code>の実装で最後に&lt;code>optimizeReadOnlyList()&lt;/code>を呼び出しているのは、おそらくその理由でしょう。&lt;code>optimizeReadOnlyList()&lt;/code>の実装は以下の通りです。やはりサイズを再調整していますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">internal&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;T&amp;gt;.optimizeReadOnlyList() = &lt;span style="color:#ff79c6">when&lt;/span> (size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> listOf(&lt;span style="color:#ff79c6">this&lt;/span>[&lt;span style="color:#bd93f9">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでわかるように、Sequenceを使って処理したあと、Collectionにまとめるなら要素数が多ければ多いほどCollectionよりも性能が劣化する可能性は確かに存在します。CollectionでFunctional functionを呼び出す際にListを作るとしても、すでに要素数はわかっているので、Listのサイズが合わないためのArrayの生成とコピーの処理は不要ですね。なのでCollectionとSequenceのどちらを選ぶかの問題はFunctional functionを呼び出す回数や処理の種類だけでなく、要素の数まで考える必要がありそうです。&lt;/p>
&lt;p>ただ、要素数が多い場合でも、終端処理の種類によってはSequenceの方が有利になる可能性もなくはないです。例えば&lt;code>forEach()&lt;/code>や&lt;code>onEach()&lt;/code>など、個別の要素に対して処理を行うだけの場合は依然としてSequenceの方で良い性能を期待できるでしょう。&lt;/p>
&lt;p>要素数が多い場合に性能に影響する処理としてもう一つ考えられるのは、Sequenceを使う場合でも呼び出せるFunctional functionの中で明らかに「状態を必要とする」ものがあるということです。例えば以下の一覧のようなものです。&lt;/p>
&lt;ul>
&lt;li>どんな要素が含まれているかわかる必要がある
&lt;ul>
&lt;li>&lt;code>distinct()&lt;/code>&lt;/li>
&lt;li>&lt;code>average()&lt;/code>&lt;/li>
&lt;li>&lt;code>min()&lt;/code>&lt;/li>
&lt;li>&lt;code>max()&lt;/code>&lt;/li>
&lt;li>&lt;code>take()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要素の順番をわかる必要がある
&lt;ul>
&lt;li>&lt;code>indexOf()&lt;/code>&lt;/li>
&lt;li>&lt;code>mapIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>flatMapIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>elementAt()&lt;/code>&lt;/li>
&lt;li>&lt;code>filterIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>foldIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>forEachIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>reduceIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>scanIndexed()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>これらの処理をSequenceではどうしているのでしょうか。まずはその実装を覗いてみる必要がありそうですね。ここでは&lt;code>sort()&lt;/code>の方をみていきたいと思います。実装は以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span> : &lt;span style="color:#50fa7b">Comparable&lt;/span>&amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.sorted(): Sequence&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> : &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">iterator&lt;/span>(): Iterator&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> sortedList = &lt;span style="color:#ff79c6">this&lt;/span>@sorted.toMutableList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sortedList.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> sortedList.iterator()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>単純ですが、Sequenceを一度Listに変換してsortした後、またSequenceに変えて返していますね。ここでListに変えるために呼び出している関数は&lt;code>toMutableList()&lt;/code>なので、結局&lt;code>toList()&lt;/code>を呼び出す場合と同じようなことが起きるということです。なので、状態を必要とする操作の場合は要素数が多ければ多いほど性能はCollectionより劣化しやすい、ということがわかります。&lt;/p>
&lt;p>ただ、逆に状態が必要にならない場合は、Collectionと違って中間結果のListを作成しなくなるので、依然としてSequenceが良い性能を見せるだろうと思えます。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>だいぶ話が長くなりましたが、性能の観点でどれを選ぶべきか、という話の結論としては、「どんな処理をするか」によるということになりますね。簡単に整理すると、以下のようになるかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>条件&lt;/th>
&lt;th>おすすめ&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>処理が複雑&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>処理した結果としてCollectionが必要&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ループするだけ&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>処理に状態が必要&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>要素数が多い&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>要素数が少ない&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>もちろんこれらの条件が複数ある場合も十分考えられるので、必要な処理が何かをよく考えてどちらを使うかを慎重に考える必要がありそうです。多くの場合とりあえずCollectionを使うという方針だとしても特に問題はなさそうな気はしますが…&lt;/p>
&lt;p>この度はKotlinにおいてのSequenceを紹介しましたが、実はイラストを含めてわかりやすく説明している&lt;a class="link" href="https://typealias.com/guides/when-to-use-sequences" target="_blank" rel="noopener"
>いつSequenceを使うべきか&lt;/a>という良い記事があるので、Sequenceについてより深く理解したい方にはこちらを参考した方が良さそうな気がします。&lt;/p>
&lt;p>また、ここではKotlinのAPIでの処理のみを紹介しましたが、JavaのStreamを使う場合、Sequenceと違って&lt;code>parallelStream()&lt;/code>を呼び出すことができます。なので並列で処理しても良い場合には、CollectionとSequenceのみでなく、Streamを使うことを検討するのもありですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>WebFluxではFunctional Enpointを使うべきか</title><link>https://retheviper.github.io/posts/spring-webflux-router/</link><pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-webflux-router/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.jpg" alt="Featured image of post WebFluxではFunctional Enpointを使うべきか" />&lt;p>以前、&lt;a class="link" href="../spring-webflux/" >Spring WebFluxに関するポストを書いたこと&lt;/a>があって、そこで少しだけMVCパターン(&lt;code>Controller&lt;/code>/&lt;code>Service&lt;/code>)と&lt;code>Functional Endpoint&lt;/code>(&lt;code>Router&lt;/code>/&lt;code>Handler&lt;/code>)に関して触れました。結論だけ先に述べますと、Functional Endpointの導入はMVCパターンは長く使われている良いパターンでありますが、性能や関数型プログラミングには適してないのという問題があるので、それを改善するためのものだといえます。&lt;/p>
&lt;p>さて、その説明だけだと、Spring WebFluxを使う際にはなるべくFunctional Endpointを使うべきな気もします。しかし、実際はどうでしょうか？例えば、従来のSpring MVCと同じくController/Serviceを使う場合は本当にRouter/Handlerを使う時と比べ性能が劣るのか？また、Functional Endpointを使う際に考慮すべき、「MVCパターンにはなかった問題」はないか？といったことを考えられます。&lt;/p>
&lt;p>なので、今回はその二つのパターンを用いて、Spring WebFluxによるサーバサイドアプリケーションを実装するときに考えたいことを少しまとめてみました。&lt;/p>
&lt;h2 id="プログラミングのパラダイムとして">プログラミングのパラダイムとして&lt;/h2>
&lt;p>SpringのMVCパターンは、アノテーションによるメタプログラミングとオブジェクト指向といった昔ながらの考え方に基づいたパラダイムに近いといえます。もちろん、AOPやDIといったSpring Framework特有の特徴はありますが、&lt;a class="link" href="https://www.reactive-streams.org" target="_blank" rel="noopener"
>Reactive Streams&lt;/a>の実現体である&lt;code>Mono&lt;/code>/&lt;code>Flux&lt;/code>で書かれたWebFluxのコードと比べたら、まだ伝統的な書き方に近いという感覚はありますね。&lt;/p>
&lt;p>ここでオブジェクト指向と関数型のうち、どれが良いかという議論はしません。また、Javaは元々オブジェクト指向の言語としてデザインされましたが、1.8以降はFunctional Interfaceの導入である程度関数型プログラミングができるようになりましたし、Kotlinでもそれは大きく変わらないことです。なので、Spring MVCとSpring WebFluxのうちどれかを選ぶということがコードをオブジェクト指向として書くか、関数型として書くかという結論にもなりません。&lt;/p>
&lt;p>しかし、Spring WebFluxでは、MVCパターンとFunctional Endpointのどれかを選べるという点からして、どちらかのパラダイムに寄せた書き方はできるというのも事実です。ここでどれを取るかを判断するには、コードを書く人同士の合意がもっとも重要なのではないかと思います。なぜかというと、結局プログラミングのパラダイムというものは何よりもプログラミングの「効率」のために発展してきたからです。&lt;/p>
&lt;p>なので、ここでの判断基準は「如何に読みやすいか」「如何に早く成果を出せるか」など、実利的なものとなるべきでしょう。例えば、すでにサービスとして機能しているアプリケーションの同時実行性能を向上させたい場合は、MVCパターンとして書いた方がすぐにサービスを立ち上げられるので良いと思ったら、それで理由は十分かと思います。もしくは、すでにFunctional Endpointに慣れているプログラマが多い場合は積極的にそれを導入するとかですね。つまり、私の観点からすると、プログラミングのパラダイムは実務者の立場からすると効率により選択するべきものではないかと思います。&lt;/p>
&lt;p>では、Contorller/ServiceのパターンとRouter/Handlerのパターンの実際はどう違うのかを、コードを通じて見ていきたいと思います。&lt;/p>
&lt;h3 id="mvcパターンで書く場合">MVCパターンで書く場合&lt;/h3>
&lt;p>Spring WebFluxのMVCパターン、つまりContoller/Serviceのパターンは、その名の通り既存のSpring MVCと比べあまり変わらない感覚で書くことができます。なので、例えば以下のようなコードを書くとしたら、これだけではSpring MVCとの違いがあまりわからないくらいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@RestController
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">HelloController&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: HelloService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GetMapping(&lt;span style="color:#f1fa8c">&amp;#34;/hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">hello&lt;/span>(): ResponseEntity =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResponseEntity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(service.getHello())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">HelloService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getHello&lt;/span>(): String = &lt;span style="color:#f1fa8c">&amp;#34;Hello Spring WebFlux&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Spring WebFluxでは、DB接続を含め完全なノンブロッキングを実現するためには[R2DBC]のようなノンブロッキング対応のAPIを使う必要があります。これはつまり、&lt;code>Reactive Stream&lt;/code>を使う必要があるとのことであって、必然的にその実現体であるMono/Fluxを使う必要があるということです。&lt;/p>
&lt;p>なので、とりあえずRepositoryからMono/Fluxを取得し、Reactive Stream固有の書き方に合わせてコードを書いていくしかないということになります。問題は、Reactive Streamはその名前から普通にJavaのStreamの感覚で扱えば良い印象ですが、実際の処理はそう簡単じゃないということです。例えば、JPAやMyBatisのような既存のブロッキングベースのAPIを使う場合は、Serviceのメソッドでは以下のようなコードを書くことになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ユーザIDでユーザ情報とメール送信履歴を取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMemberWithMailRecord&lt;/span>(memberId: Int): MemberWithMailRecord {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ユーザ情報を取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> member = memberRepository.getMember(id = memberId) &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ユーザが作成したメール送信履歴を取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> mailRecord = mailRecordRepository.getMailRecord(memberId = memberId) &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ユーザ情報とメール送信履歴を合わせて返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = member,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = mailRecord
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Mono/Fluxを返すAPIを使う場合は、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMemberWithMailRecord&lt;/span>(memberId: Int): Mono&amp;lt;MemberWithMailRecord&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memberRepository.getMember(id = memberId)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(&lt;span style="color:#50fa7b">Mono&lt;/span>.error(RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .zipWith(mailRecordRepository.getMailRecord(memberId = memberId).switchIfEmpty(&lt;span style="color:#50fa7b">Mono&lt;/span>.error(RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = &lt;span style="color:#ff79c6">it&lt;/span>.t1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = &lt;span style="color:#ff79c6">it&lt;/span>.t2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>やっていることは同じでも、果たしてこれが書きやすく、読みやすいコードであるかどうかは悩ましいですね。他にもFluxで取得したデータをListに変えたい場合、取得したMonoのデータでさらにMonoを取得したい場合など、より複雑な処理が必要な場面ではますます書き方は複雑になります。&lt;/p>
&lt;p>幸い、Kotlinには&lt;a class="link" href="https://kotlinlang.org/docs/coroutines-overview.html" target="_blank" rel="noopener"
>Coroutines&lt;/a>があるので、このような複雑な書き方をより簡単に書くことはできます。Corutinesを適用したら、Mono/Fluxを使う場合でも上記のコードは以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMemberWithMailRecord&lt;/span>(memberId: Int): MemberWithMailRecord {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> member = memberRepository.getMember(id = memberId).awaitFirstOrNull() &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> mailRecord = mailRecordRepository.getMailRecord(memberId = memberId).awaitFirstOrNull() &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = member,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = mailRecord
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Coroutinesを使う場合はスコープの指定が必要となるのが一般的ですが、実際はControllerのメソッドまでを&lt;code>suspend&lt;/code>として定義しておくと良いみたいです。ただ、既存のプロジェクトをSpring MVCからWebFluxに移行する場合にこうやって多くの処理をsuspendメソッドにすると、ユニットテストの方を直すのが大変になる可能性もあるのでそこは要注意です。&lt;/p>
&lt;h3 id="functional-endpointで書く場合">Functional Endpointで書く場合&lt;/h3>
&lt;p>続いて、Functional Endpontを使う場合のコードです。MVCパターンの問題としてアノテーションがあげられていますが、Router/Handlerでもアノテーションを使うことはできますし、アプリケーションのアーキテクチャによっては必然的にクラスを分けてアノテーションで管理することになるのが一般的かなと思います。なので、そのようなケースではRouterを&lt;code>@Bean&lt;/code>として登録したり、Handlerも&lt;code>@Component&lt;/code>として定義する場合もあります。そういう場合は、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Configuration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">HelloRouter&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> handler: HelloHanlder) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Bean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">hello&lt;/span>(): router {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/hello&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>getHello)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">HelloHandler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getHello&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServerResponse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(&lt;span style="color:#50fa7b">Mono&lt;/span>.Just(&lt;span style="color:#f1fa8c">&amp;#34;Hello Spring WebFlux&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Functional Endpointを使う場合の特徴は、RouterはあくまでエンドポイントとHandlerをつなぐ役割をするだけなので、Handlerで&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerRequest.html" target="_blank" rel="noopener"
>ServerRequest&lt;/a>を受け取り&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerResponse.html" target="_blank" rel="noopener"
>ServerResponse&lt;/a>を返す処理までを書くことになるということです。MVCパターンではRestControllerの戻り値としてResponseEntityや自分で定義したクラスを自由に指定でるし、Serviceではビジネスロジックだけを担当するパターンが多いのを考えるとかなり独特であるといえます。&lt;/p>
&lt;p>このようにServerRequestとServerResponseを使うため、HandlerはServiceと比べビジネスロジック部分が一回層が深くなった形になります。ServerResponseのbodyでロジックを書いて、それを返す形ですね。例えば以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServerResponse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(memberRepository.getMember(id = request.PathVariable(&lt;span style="color:#f1fa8c">&amp;#34;id&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(&lt;span style="color:#50fa7b">Mono&lt;/span>.error(RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .zipWith(mailRecordRepository.getMailRecord(memberId = request.PathVariable(&lt;span style="color:#f1fa8c">&amp;#34;id&amp;#34;&lt;/span>)).switchIfEmpty(&lt;span style="color:#50fa7b">Mono&lt;/span>.error(RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = &lt;span style="color:#ff79c6">it&lt;/span>.t1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = &lt;span style="color:#ff79c6">it&lt;/span>.t2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合でもでもCoroutinesを使うことはもちろんできます。Corutinesを使う場合は、以下のような書き方ができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> member = memberRepository.getMember(id = memberId).awaitFirstOrNull() &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> mailRecord = mailRecordRepository.getMailRecord(memberId = memberId).awaitFirstOrNull() &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> RuntimeException(&lt;span style="color:#f1fa8c">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> ServerResponse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .bodyValueAndAwait(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Mono&lt;/span>.just(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = &lt;span style="color:#ff79c6">it&lt;/span>.t1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = &lt;span style="color:#ff79c6">it&lt;/span>.t2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="性能">性能&lt;/h2>
&lt;p>MVCパターンの問題としてあげられるものの一つとして、アノテーションがあります。アノテーションを使うということは、必然的にリフレクションを使うことになるので、自然に性能の低下にもつながるという話ですね。これだけみると、WebFluxではMVCパターンよりもFunctional Endpointを使ったほうが性能でも有利であるように見えます。しかし実際はどうでしょうか？&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-programming-models" target="_blank" rel="noopener"
>Springの公式ドキュメント&lt;/a>では、Functional Enddpointのことを&lt;code>lightweight(軽量)&lt;/code>とは表現しているものの、それ以外に性能がどうという話は一切述べてないです。多くの場合、性能の比較はSpring MVCとSpring WebFluxを対象としていて、WebFluxでのMVCパターンとFunctional Endpointのケースはあまり探せませんでした。なので、ここでは簡単にベンチマークを行うことで二つのパターンでの性能の違いを検証してみました。&lt;/p>
&lt;p>ベンチマークツールとしては、Jmeterを使うこともできましたが、短いコマンドで測定ができるのもあり、今回は&lt;a class="link" href="https://httpd.apache.org/docs/2.4/en/programs/ab.html" target="_blank" rel="noopener"
>Apache HTTP server benchmarking tool&lt;/a>を使ってテストを実施しています。&lt;/p>
&lt;h3 id="使ったコード">使ったコード&lt;/h3>
&lt;p>性能測定として知りたいのは「実装パターンで性能が変わるか」ということなので、あえてDB接続は排除しました。比較のために作ったサンプルアプリケーションでは、単純にデータを生成する共通のロジックと、それを返すだけのContoller/Service, Router/Hanlderのセットで構成されています。&lt;/p>
&lt;h4 id="共通">共通&lt;/h4>
&lt;p>データを生成するロジックそのものは共通で、単純にループでListを生成するようにしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 固定値のデータを生成し返すクラス
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">object&lt;/span> &lt;span style="color:#50fa7b">DataCreationUtil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 1970年1月1日から2021年12月31日まで
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> data: List&amp;lt;Person&amp;gt; = (&lt;span style="color:#bd93f9">0.&lt;/span>.&lt;span style="color:#bd93f9">18992&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Person(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#ff79c6">it&lt;/span>.toLong(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#f1fa8c">&amp;#34;Person&lt;/span>&lt;span style="color:#f1fa8c">${it}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> birth = &lt;span style="color:#50fa7b">LocalDate&lt;/span>.ofEpochDay(&lt;span style="color:#ff79c6">it&lt;/span>.toLong()),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> joined = &lt;span style="color:#50fa7b">LocalDate&lt;/span>.ofEpochDay(&lt;span style="color:#ff79c6">it&lt;/span>.toLong() + &lt;span style="color:#bd93f9">10000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 生成されるデータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Person&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> id: Long,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> birth: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> joined: LocalDate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="controllerserviceの実装">Controller/Serviceの実装&lt;/h4>
&lt;p>MVCパターンについてはコードだけでも十分わかると思いますので、説明は割愛します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@RestController
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PerformanceTestController&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PerformanceTestService
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GetMapping(&lt;span style="color:#f1fa8c">&amp;#34;/performance-controller&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getData&lt;/span>(): ResponseEntity&amp;lt;List&amp;lt;Person&amp;gt;&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResponseEntity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(service.getData())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PerformanceTestService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getData&lt;/span>(): List&amp;lt;Person&amp;gt; = service.getData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="routerhandlerの実装">Router/Handlerの実装&lt;/h4>
&lt;p>Functional Endpointでは、MVCパターンと比べ処理と言えるものは全部Handlerの方に書かれてある、という違いがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Configuration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PerformanceTestRouter&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> handler: PerformanceTestHandler) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Bean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">route&lt;/span>() = router {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/performance-router&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>getData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PerformanceTestHandler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getData&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServerResponse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(&lt;span style="color:#50fa7b">Flux&lt;/span>.fromIterable(&lt;span style="color:#50fa7b">DataCreationUtil&lt;/span>.&lt;span style="color:#ff79c6">data&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="テスト結果">テスト結果&lt;/h3>
&lt;p>テストは以下のような条件で実施しました。&lt;/p>
&lt;ul>
&lt;li>ユーザ数は5000, ユーザごとのリクエストは50に設定&lt;/li>
&lt;li>ワームアップ時間を考慮して、パターンごとにテストを分ける
&lt;ul>
&lt;li>サーバの再起動後にテストを実施&lt;/li>
&lt;li>テストは10回ループ&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>実際に使ったスクリプトは以下のようなものです。サーバの起動後にこれを実行し、10回のループが終わったら再起動後にFunctional Endpointのテストを実施しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> i in &lt;span style="color:#ff79c6">{&lt;/span>1..10&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ab -n &lt;span style="color:#bd93f9">5000&lt;/span> -c &lt;span style="color:#bd93f9">50&lt;/span> http://localhost:8080/performance-controller
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうやってもやはりテスト結果では周回ごとに偏差があったので、ここでは中間値に当てはまる結果を紹介します。その結果は、以下の通りになりますが、あらかじめ結論だけ先に言いますとMVCパターンでもFunctional Endpointでもその性能の違いというものは「誤差範囲以内」と表現しても良いかなと思います。&lt;/p>
&lt;h4 id="controllerserviceの結果">Controller/Serviceの結果&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Server Software:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Server Hostname: localhost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Server Port: &lt;span style="color:#bd93f9">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Document Path: /performance-controller
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Document Length: &lt;span style="color:#bd93f9">1440242&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Concurrency Level: &lt;span style="color:#bd93f9">50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time taken &lt;span style="color:#ff79c6">for&lt;/span> tests: 24.989 seconds
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Complete requests: &lt;span style="color:#bd93f9">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Failed requests: &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total transferred: &lt;span style="color:#bd93f9">7201590000&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HTML transferred: &lt;span style="color:#bd93f9">7201210000&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Requests per second: 200.09 &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#6272a4">#/sec] (mean)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time per request: 249.892 &lt;span style="color:#ff79c6">[&lt;/span>ms&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>mean&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time per request: 4.998 &lt;span style="color:#ff79c6">[&lt;/span>ms&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>mean, across all concurrent requests&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Transfer rate: 281433.26 &lt;span style="color:#ff79c6">[&lt;/span>Kbytes/sec&lt;span style="color:#ff79c6">]&lt;/span> received
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection Times &lt;span style="color:#ff79c6">(&lt;/span>ms&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min mean&lt;span style="color:#ff79c6">[&lt;/span>+/-sd&lt;span style="color:#ff79c6">]&lt;/span> median max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connect: &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span> 1.4 &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#bd93f9">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Processing: &lt;span style="color:#bd93f9">29&lt;/span> &lt;span style="color:#bd93f9">248&lt;/span> 79.8 &lt;span style="color:#bd93f9">242&lt;/span> &lt;span style="color:#bd93f9">516&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Waiting: &lt;span style="color:#bd93f9">24&lt;/span> &lt;span style="color:#bd93f9">192&lt;/span> 60.8 &lt;span style="color:#bd93f9">185&lt;/span> &lt;span style="color:#bd93f9">442&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total: &lt;span style="color:#bd93f9">29&lt;/span> &lt;span style="color:#bd93f9">249&lt;/span> 79.4 &lt;span style="color:#bd93f9">243&lt;/span> &lt;span style="color:#bd93f9">516&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Percentage of the requests served within a certain &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>ms&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 50% &lt;span style="color:#bd93f9">243&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 66% &lt;span style="color:#bd93f9">275&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 75% &lt;span style="color:#bd93f9">295&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 80% &lt;span style="color:#bd93f9">309&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 90% &lt;span style="color:#bd93f9">354&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 95% &lt;span style="color:#bd93f9">394&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 98% &lt;span style="color:#bd93f9">430&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 99% &lt;span style="color:#bd93f9">449&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100% &lt;span style="color:#bd93f9">516&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>longest request&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="routerhandlerの結果">Router/Handlerの結果&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Server Software:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Server Hostname: localhost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Server Port: &lt;span style="color:#bd93f9">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Document Path: /performance-router
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Document Length: &lt;span style="color:#bd93f9">1440257&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Concurrency Level: &lt;span style="color:#bd93f9">50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time taken &lt;span style="color:#ff79c6">for&lt;/span> tests: 25.541 seconds
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Complete requests: &lt;span style="color:#bd93f9">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Failed requests: &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total transferred: &lt;span style="color:#bd93f9">7201775000&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HTML transferred: &lt;span style="color:#bd93f9">7201285000&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Requests per second: 195.76 &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#6272a4">#/sec] (mean)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time per request: 255.410 &lt;span style="color:#ff79c6">[&lt;/span>ms&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>mean&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time per request: 5.108 &lt;span style="color:#ff79c6">[&lt;/span>ms&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>mean, across all concurrent requests&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Transfer rate: 275360.22 &lt;span style="color:#ff79c6">[&lt;/span>Kbytes/sec&lt;span style="color:#ff79c6">]&lt;/span> received
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection Times &lt;span style="color:#ff79c6">(&lt;/span>ms&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min mean&lt;span style="color:#ff79c6">[&lt;/span>+/-sd&lt;span style="color:#ff79c6">]&lt;/span> median max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connect: &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span> 3.2 &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#bd93f9">151&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Processing: &lt;span style="color:#bd93f9">33&lt;/span> &lt;span style="color:#bd93f9">253&lt;/span> 80.4 &lt;span style="color:#bd93f9">246&lt;/span> &lt;span style="color:#bd93f9">612&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Waiting: &lt;span style="color:#bd93f9">28&lt;/span> &lt;span style="color:#bd93f9">194&lt;/span> 59.8 &lt;span style="color:#bd93f9">184&lt;/span> &lt;span style="color:#bd93f9">475&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total: &lt;span style="color:#bd93f9">39&lt;/span> &lt;span style="color:#bd93f9">254&lt;/span> 80.0 &lt;span style="color:#bd93f9">247&lt;/span> &lt;span style="color:#bd93f9">613&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Percentage of the requests served within a certain &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>ms&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 50% &lt;span style="color:#bd93f9">247&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 66% &lt;span style="color:#bd93f9">286&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 75% &lt;span style="color:#bd93f9">302&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 80% &lt;span style="color:#bd93f9">312&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 90% &lt;span style="color:#bd93f9">361&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 95% &lt;span style="color:#bd93f9">398&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 98% &lt;span style="color:#bd93f9">441&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 99% &lt;span style="color:#bd93f9">459&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100% &lt;span style="color:#bd93f9">613&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>longest request&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ドキュメンテーション">ドキュメンテーション&lt;/h2>
&lt;p>次にドキュメンテーションの観点からすると、Functional Endpointはまだ導入するには早い気がします。ここでいうドキュメンテーションは、JavaDocやKdocのようなコメントのことではなく、最近よく使われる&lt;a class="link" href="https://swagger.io" target="_blank" rel="noopener"
>Swagger&lt;/a>のことを指します。&lt;/p>
&lt;p>最近は&lt;a class="link" href="http://springfox.github.io/springfox" target="_blank" rel="noopener"
>SpringFox&lt;/a>などを使うと簡単にAPIのドキュメンテーションが可能ですが、Functional Endpointだとそう簡単にはできません。すでに理由がわかる方もいらっしゃるかと思いますが、Routerには引数としてエンドポイントとHandlerの処理を渡しているだけで、Handlerは引数がServerRequest、戻り値はServerResponseに固定されてあるのが理由です。&lt;/p>
&lt;p>もちろん、ServerRequestとServerResponseを使う場合でもそれを自分の欲しいデータとして扱うことはできます。例えば、リクエストからパラメータを取る方法は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Path Variableで渡されたIDを持ってユーザ情報を取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Path Variableを取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> id = request.pathVariable(&lt;span style="color:#f1fa8c">&amp;#34;id&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Request Bodyで渡されたデータを元に新しいユーザを作成する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">suspend&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createMember&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Request Bodyをクラスにマッピングする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> form = request.bodyToMono(MemberCreateForm&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>.java).awaitFirst()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、SpringFoxのように自動でAPIのドキュメンテーションを行ってくれるような便利なAPIは、おそらくリフレクションを使っています。なので、Handlerで実際はどんな処理が行われているかを判断するのは難しいでしょう。&lt;/p>
&lt;p>幸い、この問題はSpringの開発者も認識しているようで、&lt;a class="link" href="https://springdoc.org" target="_blank" rel="noopener"
>springdoc-openapi&lt;/a>を使うとFunctional EndpointでもAPIのドキュメンテーションは可能になります。ただ、この場合でも現時点ではやはり問題があります。なぜなら、これはAPIのドキュメンテーションを自動化するものではなく、「ドキュメンテーションのための手段を提供する」だけだからです。なので、以下のように、RouterやHandlerに関して一つ一つアノテーションを指定する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Bean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@RouterOperations(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">value&lt;/span> =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> RouterOperation(
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> path = &amp;#34;/api/v1/members&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> beanClass = MemberHandler::class,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> beanMethod = &amp;#34;listMember&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> method = [RequestMethod.GET]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterOperation(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = &lt;span style="color:#f1fa8c">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanClass = MemberHandler&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanMethod = &lt;span style="color:#f1fa8c">&amp;#34;getMember&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method = [&lt;span style="color:#50fa7b">RequestMethod&lt;/span>.GET],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterOperation(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = &lt;span style="color:#f1fa8c">&amp;#34;/api/v1/members&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanClass = MemberHandler&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanMethod = &lt;span style="color:#f1fa8c">&amp;#34;createMember&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method = [&lt;span style="color:#50fa7b">RequestMethod&lt;/span>.POST],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterOperation(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = &lt;span style="color:#f1fa8c">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanClass = MemberHandler&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanMethod = &lt;span style="color:#f1fa8c">&amp;#34;updateMember&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method = [&lt;span style="color:#50fa7b">RequestMethod&lt;/span>.PUT],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterOperation(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = &lt;span style="color:#f1fa8c">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanClass = MemberHandler&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanMethod = &lt;span style="color:#f1fa8c">&amp;#34;deleteMember&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method = [&lt;span style="color:#50fa7b">RequestMethod&lt;/span>.DELETE],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">routeMember&lt;/span>() = coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/members&amp;#34;&lt;/span>) { handler.listMember() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>getMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POST(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/members&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>createMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUT(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>updateMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DELETE(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#ff79c6">::&lt;/span>deleteMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ご覧の通り、ドキュメンテーションのためのアノテーションが実際のコードよりも長くなっています。Functional EndpointでもSwaggerを利用できる手段ができたのは良いことですが、MVCパターンと比べやはり不便ではありますね。なので、ドキュメンテーションが大事であるなら、まだFunctional Pointを使うべきではないかも知れません。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は、Spring WebFluxのMVCパターン及びFunctional Endpointをコードの書き方、性能、ドキュメンテーションという観点から比較してみました。Spring WebFluxも発表されたのが2017年なので、もう今年で5年目になりますが、まだまだMVCパターンに比べては色々と補完すべき点が多い印象です。自分の場合はWebFluxのメインコンセプトであるノンブロッキングや関数型プログラミングを活かすためにはやはりFunctional Endpointを選んだ方が良さそうな気はしていますが、まだあえてそうする必要はないのではないか、という感覚です。特にエンタプライズのアプリケーションを書くことになるとますますそうでしょう。もちろん、そもそもWebFluxそのものを導入すべきかということから考える必要がありますが。&lt;/p>
&lt;p>それでも、やはりFunctional Endpointという実装方式には色々と可能性があると思います。Spring WebFluxでなくても、最近のウェブフレームワークでは多く採用されているものですからね。例えばTechEmpowerの&lt;a class="link" href="https://www.techempower.com/benchmarks" target="_blank" rel="noopener"
>ベンチマーク&lt;/a>でJavaのフレームワークのうちではもっとも性能がよかった&lt;a class="link" href="https://jooby.io" target="_blank" rel="noopener"
>jooby&lt;/a>でもMVCパターンとFunctional Endpointとよく似たScript Routeパターンに対応していますし、JetBrainsで開発しているKotlin用のウェブフレームワークである&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>Ktor&lt;/a>ではMVCパターンなしで、同じくFunctional Endpointとよく似たRoutingにのみ対応しています。なので、他にも&lt;a class="link" href="https://expressjs.com/ja" target="_blank" rel="noopener"
>Express&lt;/a>や&lt;a class="link" href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener"
>Gin&lt;/a>のようなフレームワークでも似たようなAPIの実装方法を提供しているので、余裕があったら個人的に試してみて慣れるのも良い勉強になるかも知れません。また、関数型プログラミングはこれからも幅広く使われそうなので、これを持って練習してみるのも良いかも知れませんね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinのString実装を覗く〜whitespace編〜</title><link>https://retheviper.github.io/posts/kotlin-whitespace/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-whitespace/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinのString実装を覗く〜whitespace編〜" />&lt;p>Kotlin(JVM)は、コンパイルした結果がJVMのバイトコードになります。Javaで書かれたライブラリをそのままKotlinで利用できるのはそのためですね。これはKotliのライブラリに対しても同じなので、スタンダードライブラリを覗くとJavaの機能に依存しているところも少なくないです。&lt;/p>
&lt;p>ただ、KotlinがコンパイルしたらJVMのバイトコードになるということは、単純にKotlinが「書き方が違うJava」であるという意味ではないです。これはKotlinがJavaと言語スペックが違うという点もありますが、JVMだけでなく、JavaScriptやネイティブコードにコンパイルされることも想定してデザインされているので、スタンダードライブラリスタンダードライブラリはプラットフォームに合わせて違う実装になっています。そしてJVMだとしてもJavaのAPIをそのまま利用しているわけではありません。&lt;/p>
&lt;p>Kotlinのこういう構造は、内部のソースコードを見るとはっきりします。スタンダードライブラリの一部メソッドやクラスには&lt;code>expect&lt;/code>と&lt;code>actual&lt;/code>というキーワードが使われていますが、これらはJavaのinheritanceと似ているようなものです。Javaでは&lt;code>interface&lt;/code>で定義したメソッドを、それを継承したクラスで&lt;code>override&lt;/code>で実装して使うことになりますね。同じく、Kotlinでは&lt;code>expect&lt;/code>として定義された機能をプラットフォームに合わせて&lt;code>actual&lt;/code>で実装しているわけです。&lt;/p>
&lt;p>また、KotlinのスタンダードライブラリはJavaと一見同じようなものに見えるとしても、実際は違うケースもあります。&lt;code>actual&lt;/code>によって実装されたコードがKotlinに合わせて、書かれているからですね。なので、Kotlinのスタンダードライブラリに対しては「Javaと同じだろう」という認識をするのは危険な可能性もあります。&lt;/p>
&lt;p>今回はそういうことで、文字列のwhitespaceに関しての機能を、スタンダードライブラリのソースコードを中心に見ていきたいと思います。&lt;/p>
&lt;h2 id="whitespaceの判定">whitespaceの判定&lt;/h2>
&lt;p>とある文字列が意味のある(有効な)データであるかどうかを判定する方法の一つは、その文字列がただの空白であるかどうかを判定することです。つまり、そもそもなんのデータもなかったり、whitespaceだけでないかというチェックをするということですね。&lt;/p>
&lt;p>こういう場合の判定はKotlinのスタンダードライブラリで簡単に行うことができます。KotlinではStringのメソッドとして基本的に以下の二つを提供しています。&lt;/p>
&lt;ul>
&lt;li>&lt;code>isEmpty()&lt;/code>&lt;/li>
&lt;li>&lt;code>isBlank()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Java 11以降でもこれらと同名のメソッドが存在しているので、一見そのままの感覚で良さそうにも見えます。しかし、Kotlinではこれらのメソッドがまず&lt;code>kotlin.text.Strings&lt;/code>から呼ばれるものとされています。JavaのAPIをそのまま使っているわけではないので、処理も違う可能性があるという推測ができますね。&lt;/p>
&lt;p>ここで前者の場合、文字列が単純になんのデータも持ってないかどうかに対する判定をおこないます。実際のソースコードを見ると、文字列の長さだけをチェックしているのを確認できます。&lt;/p>
&lt;p>ちなみにJavaでは&lt;code>String&lt;/code>は&lt;code>CharSequence&lt;/code>を継承していますが、Kotlinとしてもライブラリは違えどそういう継承関係は一緒です。なので、Kotlinでは&lt;code>String&lt;/code>のメンバーでありながらも&lt;code>CharSequence&lt;/code>の関数として書かれています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">CharSequence&lt;/span>.isEmpty(): Boolean = length &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>後者の場合は、文字列にwhitespaceまで含めているのかを判定します。以下のコードを見ると、何をやっているかが明確でしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">actual&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">CharSequence&lt;/span>.isBlank(): Boolean = length &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> indices.all { &lt;span style="color:#ff79c6">this&lt;/span>[&lt;span style="color:#ff79c6">it&lt;/span>].isWhitespace() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>isBlank()&lt;/code>で呼び出している&lt;code>isWhitespace()&lt;/code>は、以下のような実装となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">actual&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Char&lt;/span>.isWhitespace(): Boolean = &lt;span style="color:#50fa7b">Character&lt;/span>.isWhitespace(&lt;span style="color:#ff79c6">this&lt;/span>) &lt;span style="color:#ff79c6">||&lt;/span> &lt;span style="color:#50fa7b">Character&lt;/span>.isSpaceChar(&lt;span style="color:#ff79c6">this&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの&lt;code>Char.isWhitespace()&lt;/code>は最終的に&lt;code>Character.isWhitespace()&lt;/code>と&lt;code>Character.isSpaceChar()&lt;/code>を使って判定することになります。前者の場合はUnicodeのwhitespaceに当てはまるか、後者の場合はUnicodeのspace(改行コードなど)に当てはまるかを判定するJavaのAPIです。ここでわかるように、特集なケースでなければなるべく&lt;code>isEmpty()&lt;/code>を使った方が文字列をチェックする時に良いでしょう。&lt;/p>
&lt;h2 id="whitespaceの削除">whitespaceの削除&lt;/h2>
&lt;p>文字列が単純に意味のあるデータを持っているかどうかを判定するには、前述通り&lt;code>isEmpty()&lt;/code>を使うと良いですが、文字列にwhitespaceだけでなく、意味のあるデータも混在する場合もありますね。こういう時は前後のwhitespaceを取り除きたくなります。&lt;/p>
&lt;p>Javaでは、文字列の前後のwhitespaceを消去する方法として&lt;code>trim()&lt;/code>と&lt;code>strip()&lt;/code>がありました。前者は昔ながらのもので、全角のwhitespaceを検知できなく、性能の問題もあるのでJava 11以降は後者を使うことが推奨されています。&lt;/p>
&lt;p>ただ、Kotlinの場合は少し都合が違います。Kotlinでは基本的に&lt;code>trim()&lt;/code>だけを使うことになります。まずは&lt;code>trim()&lt;/code>の実装をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">String&lt;/span>.trim(): String = (&lt;span style="color:#ff79c6">this&lt;/span> &lt;span style="color:#ff79c6">as&lt;/span> CharSequence).trim().toString()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まず&lt;code>String&lt;/code>としては、&lt;code>CharSequence&lt;/code>にアップキャストしてその&lt;code>trim()&lt;/code>を呼び出すことにしています。そのあとは単純に&lt;code>toString()&lt;/code>で返すだけですね。&lt;/p>
&lt;p>続いて、&lt;code>String&lt;/code>で呼ばれている&lt;code>CharSequence&lt;/code>側の&lt;code>trim()&lt;/code>をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">CharSequence&lt;/span>.trim(): CharSequence = trim(Char&lt;span style="color:#ff79c6">::&lt;/span>isWhitespace)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでは、オーバロードした他の&lt;code>trim()&lt;/code>に&lt;code>isWhitespace()&lt;/code>をメソッドレファレンスとして渡しているのがわかります。&lt;code>Boolean&lt;/code>が戻り値なので、引数は&lt;code>Predicate&lt;/code>であると推測できますね。続けて、こちらで呼び出している&lt;code>trim(predicate)&lt;/code>の方を確認します。こちらのコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">CharSequence&lt;/span>.trim(predicate: (Char) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Boolean): CharSequence {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> startIndex = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> endIndex = length - &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> startFound = &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span> (startIndex &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> endIndex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> index = &lt;span style="color:#ff79c6">if&lt;/span> (!startFound) startIndex &lt;span style="color:#ff79c6">else&lt;/span> endIndex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> match = predicate(&lt;span style="color:#ff79c6">this&lt;/span>[index])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (!startFound) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (!match)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startFound = &lt;span style="color:#ff79c6">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startIndex &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (!match)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endIndex &lt;span style="color:#ff79c6">-=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> subSequence(startIndex, endIndex + &lt;span style="color:#bd93f9">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここまできてやっと実際の処理がでました。&lt;code>CharSequence&lt;/code>をループしながら左(start)から右の方にwhitespaceを探し、初めてwhitespaceでない文字を見つけたら右(end)から左の方にループしながら繰り返すという処理ですね。意外と単純ですが、効率的な処理です。&lt;/p>
&lt;p>そしてその処理での判断基準が&lt;code>isWhitespace()&lt;/code>になっているわけですが、先に確認している通りこちらは最終的にJavaのAPIを呼ぶことになっているので、&lt;code>trim()&lt;/code>でも十分Unicodeに定義されてあるwhitespaceやspaceまでを削除してくれると推論できます。なので、Javaとは違ってあえて&lt;code>strip()&lt;/code>を使う必要はなさそうです。&lt;/p>
&lt;p>また、&lt;code>trim()&lt;/code>は文字列の前後のwhitespaceを削除しますが、場合によっては前方のみ、後方のみで分けて使いたい場合もあるかも知れません。その時は、以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> string = &lt;span style="color:#f1fa8c">&amp;#34; string &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 左のみtrim
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.trimStart()) &lt;span style="color:#6272a4">// &amp;#34;string &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 右のみtrim
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.trimEnd()) &lt;span style="color:#6272a4">// &amp;#34; string&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのメソッドは引数として&lt;code>Predicate&lt;/code>を渡すこともできるので、他の条件を自前で書く必要がある場合にはそちらを使えますね。&lt;/p>
&lt;p>他にも、whitespaceではない、前後の特定の文字(prefix、suffix)を削除してたい場合は以下のメソッドが提供されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> string = &lt;span style="color:#f1fa8c">&amp;#34;--hello--&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// prefixのみ削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.removePrefix(&lt;span style="color:#f1fa8c">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#6272a4">// &amp;#34;hello--&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// suffixのみ削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.removeSuffix(&lt;span style="color:#f1fa8c">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#6272a4">// &amp;#34;--hello&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 前後を削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.removeSurrounding(&lt;span style="color:#f1fa8c">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#6272a4">// &amp;#34;hello&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="改行を削除">改行を削除&lt;/h3>
&lt;p>改行が文字列の前後に入っていれば&lt;code>trim()&lt;/code>で十分ですが、文字列の中に改行が含まれていて、それを変えたい場合もありますね。例えばJSONをログに一行で出力したいだったり、以下のようなMulitiline Stringを一行にまとめたい場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> string = &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> Hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> World
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Intellijだと自動的に&lt;code>trimIndent()&lt;/code>をつけてくれますが、これはあくまでインデントに関与するものであって、中の改行まではtrimしてくれないです。こういう場合は、KotlinでもJavaでも対応するメソッドは特にないので、自分で処理を書くしかないですね。例えば、以下のようなコードが使えるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">String&lt;/span>.stripLine() = replace(&lt;span style="color:#50fa7b">System&lt;/span>.lineSeparator(), &lt;span style="color:#f1fa8c">&amp;#34; &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Javaでも13から&lt;a class="link" href="https://openjdk.java.net/jeps/355" target="_blank" rel="noopener"
>Text Block&lt;/a>が導入されているので、今後はJavaのAPIの方で上記のようなメソッドが追加されることを期待できるかも知れません。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>最初に&lt;code>expect&lt;/code>と&lt;code>actual&lt;/code>の話をしましたが、これらのキーワードは&lt;a class="link" href="https://kotlinlang.org/docs/multiplatform.html" target="_blank" rel="noopener"
>Kotlin Multiplatform&lt;/a>でもっとも重要な概念です。Kotlinで書いたコードをさまざまなプラットフォームで共有できるようにすることを目的としているので、こういう構造になっているのは自然ですね。なので、Kotlin/JVMだけでなく、他のことを試したい方にはとりあえず理解しておく必要があるキーワードだと思います。ちょっと独特なだけで、実体は単純なので、理解は簡単でしょう。&lt;/p>
&lt;p>また、KotlinのStringに関しては、&lt;a class="link" href="https://youtu.be/n4WBip822A8" target="_blank" rel="noopener"
>JetBrains公式YouTubeチャンネルの動画&lt;/a>で簡単に説明しているので、Kotlinで開発をしている方なら一度は参考にした方が良いかも知れません。&lt;/p>
&lt;p>他に、&lt;code>strip()&lt;/code>をあえて使う必要はないと言いましたが、実際Kotlinの最新バージョンである1.5.0でも&lt;code>strip()&lt;/code>は&lt;code>deprecated&lt;/code>になっていて、以下のようなコメントがついているので、次のバージョンで正式対応するまでは使わない方が良いですね。&lt;/p>
&lt;blockquote>
&lt;p>&amp;lsquo;strip(): String!&amp;rsquo; is deprecated. This member is not fully supported by Kotlin compiler, so it may be absent or have different signature in next major version&lt;/p>
&lt;/blockquote>
&lt;p>こういうケースでもわかるように、KotlinがJavaと100%互換性があると言い切れない側面もあるのではと思います。なので、JavaからKotlinに移行した場合(実際のコードであれ、開発者自身のスキルであれ)には、一度注意深くスタンダードライブラリの説明を読む必要があるかも知れません。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>年月を扱ってみる</title><link>https://retheviper.github.io/posts/kotlin-year-month/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-year-month/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post 年月を扱ってみる" />&lt;p>Kotlin(Java)では、&lt;code>java.time&lt;/code>パッケージのクラスで日付や時間を処理することができます。例えば&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/LocalDateTime.html" target="_blank" rel="noopener"
>LocalDateTime&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/LocalDate.html" target="_blank" rel="noopener"
>LocalDate&lt;/a>などがありますね。サーバサイドではこれらのクラスを使ってDBに日付や時間を入力したり、認証用のトークンの有効期間を設定したりの処理ができるようになります。他にも&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/time/Period.html" target="_blank" rel="noopener"
>Period&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" target="_blank" rel="noopener"
>Duration&lt;/a>があって、「期間」を扱うこともできますね。&lt;/p>
&lt;p>ただ、「年月」という単位を扱いたい場合はどうしたらいいでしょうか。例えば、口座の入出金明細などを照会する時に、「2月から4月まで」という風に期間を設定するケースなどがあるとしたら、いらない「日」や「時間」まで含めるのはあまり効率的でなく、場合によってはバグの原因になるかも知れません。こういった場合は確かな「年月」としてデータを扱うか、数字として表現するかなどどちらかの方法を考える必要があるでしょう。&lt;/p>
&lt;p>ということで、今回はこの年月を扱う方法について少し述べたいと思います。&lt;/p>
&lt;h2 id="年月を年と月に">年月を年と月に&lt;/h2>
&lt;p>年月を扱うということは、つまり、いつでも「年」と「月」という二つのデータとして分離できるようにしたいということにもなりますね。ここでは二つの方法で、「年月」を「年」と「月」の二つに分けて扱う方法について説明します。&lt;/p>
&lt;h3 id="yearmonthとして">YearMonthとして&lt;/h3>
&lt;p>&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>では、基本的に&lt;a class="link" href="https://www.iso.org/iso-8601-date-and-time-format.html" target="_blank" rel="noopener"
>ISO-8601&lt;/a>形式で日付を扱うことができます。もちろん、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>を使って他の形式を指定することもできますが、扱うデータの形が違うだけで、本質的には「年月日」が基本となりますね。&lt;/p>
&lt;p>&lt;code>ISO-8601&lt;/code>の「年月日」形式で日付を扱っているということは、つまり、SpringでREST APIを作っている場合、リクエストの値が&lt;code>ISO-8601&lt;/code>の形式を守っていれば&lt;code>LocalDateTime&lt;/code>や&lt;code>LocalDate&lt;/code>形式に自動変換されるということでもあります。例えば以下のようなリクエストのJSONがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;date&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;2021-04-01&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Spring側では以下のようなコードで、リクエストのdateを&lt;code>LocalDate&lt;/code>に変換することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// リクエストボディ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">DateRequest&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> id: Int, &lt;span style="color:#ff79c6">val&lt;/span> date: LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// コントローラ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>@PostMapping(&lt;span style="color:#f1fa8c">&amp;#34;/date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">date&lt;/span>(@RequestBody request: DateRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして全く同じやり方で、&lt;code>LocalDate&lt;/code>を&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/YearMonth.html" target="_blank" rel="noopener"
>YearMonth&lt;/a>に変えることで年月に対応することができます。例えば以下のようなリクエストがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;yearMonth&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;2021-04&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>yearMonth&lt;/code>を&lt;code>YearMonth&lt;/code>に変えるだけです。以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// リクエストボディ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">YearMonthRequest&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> id: Int, &lt;span style="color:#ff79c6">val&lt;/span> yearMonth: YearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// コントローラ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>@PostMapping(&lt;span style="color:#f1fa8c">&amp;#34;/year-month&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">yearMonth&lt;/span>(@RequestBody request: YearMonthRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>YearMonth&lt;/code>を使うことのメリットは、&lt;code>LocalDateTime&lt;/code>や&lt;code>LocalDate&lt;/code>と同じく&lt;code>java.time&lt;/code>パッケージに属するオブジェクトなので、それらと互換性があり、相互変換が自由ということでもあります。例えば以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> yearMonth = &lt;span style="color:#50fa7b">YearMonth&lt;/span>.now() &lt;span style="color:#6272a4">// 現在の年月を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2021&lt;/span>-&lt;span style="color:#bd93f9">04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> localDate = yearMonth.atDay(&lt;span style="color:#bd93f9">1&lt;/span>) &lt;span style="color:#6272a4">// 年月に日を指定してLocalDateにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&amp;gt;&amp;gt;&amp;gt; println(localDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2021&lt;/span>-&lt;span style="color:#bd93f9">04&lt;/span>-&lt;span style="color:#bd93f9">01&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>YearMonth&lt;/code>は時間に関する便利なメソッドを多く提供しているので、単純に数値としての年月を扱うだけでなく、色々な要件に合わせて日付関連の処理が必要な場合に便利かも知れません。例えば以下のような機能が提供されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> yearMonth = &lt;span style="color:#50fa7b">YearMonth&lt;/span>.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2021&lt;/span>-&lt;span style="color:#bd93f9">05&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getYear()) &lt;span style="color:#6272a4">// 年を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#bd93f9">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getMonth()) &lt;span style="color:#6272a4">// 月(Enum)を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>MAY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getMonthValue()) &lt;span style="color:#6272a4">// 月(数字)を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.isLeapYear()) &lt;span style="color:#6272a4">// うるう年であるかどうか
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.atEndOfMonth()) &lt;span style="color:#6272a4">// 月の最後の日(LocalDate)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#bd93f9">2021&lt;/span>-&lt;span style="color:#bd93f9">05&lt;/span>-&lt;span style="color:#bd93f9">31&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数字として">数字として&lt;/h3>
&lt;p>&lt;code>YearMonth&lt;/code>で受け取って処理した方がもっとも綺麗な方法に見えますが、状況によっては素直に&lt;code>Int&lt;/code>型で受け取った方が良い(もしくはそうするしかない)ケースもあるはずです。例えば以下のようなリクエストが送らられて来るようなケースですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;yearMonth&amp;#34;&lt;/span>: &lt;span style="color:#bd93f9">202104&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そもそも&lt;code>year&lt;/code>と&lt;code>month&lt;/code>のように別の項目になっていたとしたらもっとやりやすいのですが、このように年月が一つの&lt;code>Int&lt;/code>型のデータとして送られてくる場合は自分で年と月を抽出する処理を作るしかないですね。例えば以下のようなextension functionを書くことができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 年を抽出する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.extractYear(): Int = &lt;span style="color:#ff79c6">this&lt;/span> / &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 月を抽出する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.extractMonth(): Int = &lt;span style="color:#ff79c6">this&lt;/span> % &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実際のコードを動かしてみると、ちゃんと意図通り動くのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.extractYear(): Int = &lt;span style="color:#ff79c6">this&lt;/span> / &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#bd93f9">202104.&lt;/span>extractYear()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res4: kotlin.Int = &lt;span style="color:#bd93f9">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.extractMonth(): Int = &lt;span style="color:#ff79c6">this&lt;/span> % &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#bd93f9">202104.&lt;/span>extractMonth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res6: kotlin.Int = &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、パラメータとして渡されたものはただの&lt;code>Int&lt;/code>型なので、期待した通りの値ではない可能性もあるという問題があります。常に&lt;code>YYYYMM&lt;/code>という形でデータが送られてくるかどうかをチェックする必要がありますね。&lt;/p>
&lt;p>そういう場合に、上記のコードだとリクエストの&lt;code>yearMonth&lt;/code>が正しい年月の形式になっているかどうかがわかりません。なので、正規式を用いたバリデーションチェックを挟むことにしたらより安全になるでしょう。例えば、以下のようなコードを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.toYearMonth(): Pair&amp;lt;Int, Int&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (Regex(&lt;span style="color:#f1fa8c">&amp;#34;^(19|20)&lt;/span>&lt;span style="color:#f1fa8c">\\&lt;/span>&lt;span style="color:#f1fa8c">d{2}(0[1-9]|1[012])&amp;#34;&lt;/span>).matches(&lt;span style="color:#ff79c6">this&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span> / &lt;span style="color:#bd93f9">100&lt;/span> to &lt;span style="color:#ff79c6">this&lt;/span> % &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#f1fa8c">&amp;#34;cannot convert&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数は、以下のような使い方ができます。簡単に使えるのでいい感じですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> (year, month) = &lt;span style="color:#bd93f9">202104.&lt;/span>toYearMonth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(year)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(month)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元の値を二つの&lt;code>Int&lt;/code>に分けるために戻り値として&lt;code>Pair&lt;/code>を使いましたが、場合によっては&lt;code>YearMonth&lt;/code>の方が良いかも知れません。そういう場合は、以下のようなコードが使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.toYearMonth(): YearMonth =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (Regex(&lt;span style="color:#f1fa8c">&amp;#34;^(19|20)&lt;/span>&lt;span style="color:#f1fa8c">\\&lt;/span>&lt;span style="color:#f1fa8c">d{2}(0[1-9]|1[012])&amp;#34;&lt;/span>).matches(&lt;span style="color:#ff79c6">this&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YearMonth(&lt;span style="color:#ff79c6">this&lt;/span> / &lt;span style="color:#bd93f9">100&lt;/span>, &lt;span style="color:#ff79c6">this&lt;/span> % &lt;span style="color:#bd93f9">100&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#f1fa8c">&amp;#34;cannot convert&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="年と月を年月に">年と月を年月に&lt;/h2>
&lt;p>さて、今回は逆に「年」と「月」を繋げて「年月」にする場合の処理を考えてみましょう。二つの&lt;code>Int&lt;/code>を合わせて、一つの&lt;code>Int&lt;/code>(YYYYMM)にする形です。ここでまず考えられる方法は二つです。&lt;code>YearMonth&lt;/code>を使った方法と、文字列に変換してから処理するという方法です。&lt;/p>
&lt;h3 id="yearmonthで">YearMonthで&lt;/h3>
&lt;p>まず&lt;code>YearMonth&lt;/code>を利用する場合は、年と月をそのまま引数として渡した後、&lt;code>Int&lt;/code>に変換すれば良いですね。ただ、&lt;code>YearMonth&lt;/code>は基本的に&lt;code>ISO-8601&lt;/code>形式なので、2021年4月だと&lt;code>2021-04&lt;/code>となるので&lt;code>Int&lt;/code>へ変換ができません。なので、まず&lt;code>String&lt;/code>に変えてから、&lt;code>-&lt;/code>を消して&lt;code>Int&lt;/code>に変換することにします。以上の処理は、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">toYearMonth&lt;/span>(year: Int, month: Int): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">YearMonth&lt;/span>.of(year, month).toString().replace(&lt;span style="color:#f1fa8c">&amp;#34;-&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>).toInt()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="文字列で">文字列で&lt;/h3>
&lt;p>文字列で処理する場合は、単純に&lt;a class="link" href="https://kotlinlang.org/docs/basic-types.html#string-templates" target="_blank" rel="noopener"
>String templates&lt;/a>を使うことでも可能ですが、注意したいのは、月は1~12という範囲を持つので、単純にtemplateで年と月を繋げると&lt;code>20214&lt;/code>のような形になり得る可能性もあるということですね。なので、&lt;code>padStart()&lt;/code>を利用して、月が1~9の場合は先頭に&lt;code>0&lt;/code>をつけるようにします。そのあとは&lt;code>Int&lt;/code>に変換するだけですね。これは以下のようなコードになリます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">toYearMonth&lt;/span>(year: Int, month: Int): Int = &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${year}${month.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらの方法は、引数が二つなので、&lt;code>infix&lt;/code>として定義することもできます(好みの問題かと思いますが)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">infix&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.toYearMonthWith(month: Int): Int = &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${this}${month.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#bd93f9">2021&lt;/span> toYearMonthWith &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res10: kotlin.Int = &lt;span style="color:#bd93f9">202105&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがだったでしょうか。あまり難しいコードではなかったので、あえて記事にまでする必要があったのか、という気もしましたが、個人的には&lt;code>YearMonth&lt;/code>というクラスの存在を初めて知ったのもあり、Kotlinならではのコード(extension function)を書いてみたく試したことを共有したいと思った次第です。もしKotlinやJavaで年月を扱う必要がある方には、少しでも役に立てるといいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinでZIP圧縮してみる</title><link>https://retheviper.github.io/posts/kotlin-zip-files/</link><pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-zip-files/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinでZIP圧縮してみる" />&lt;p>サーバサイドの機能を作っていると、ファイルダウンロード機能が必要な時があります。ただ、ストレージに保存されてあるファイルをそのまま返すということだけでなく、場合によってはファイルを生成してそのまま返したり、複数のファイルをまとめて転送する必要もありますね。&lt;/p>
&lt;p>リクエストごとに一つのファイルをダウンロードさせるとしたら、実装はそう難しくないものですが、複数のファイルをダウンロードさせるという場合は少し複雑になりますね。ファイルを一つにまとめて送るとしたら、ZIPに圧縮した方が良いでしょう。幸い、Javaでは基本的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/zip/ZipOutputStream.html" target="_blank" rel="noopener"
>ZipOutputStream&lt;/a>というAPIを提供しているので、エントリに圧縮対象のファイルを追加したあとZIPファイルを出力だけで良いです。&lt;/p>
&lt;p>ただ、単純にファイルが複数だるだけでなく、ディレクトリが多重にネストされてあったりする場合は、ディレクトリ構造を維持しつつそのまま圧縮するとかの追加的な処理が必要となります。そして場合によっては含めたくないファイルがあるケースもあったりしますね。そしてなるべくファイルの数に関係なく(ファイルが一つであれ、ディレクトリであれ)一つの機能で済ませたいものです。なので、今回はそのようなユースケースに合わせた簡単なメソッドを作る方法を、JavaのコードからKotlinへ移行していく過程を簡単に紹介したいと思います。&lt;/p>
&lt;p>今回紹介しますコードは、はBaeldungの&lt;a class="link" href="https://www.baeldung.com/java-compress-and-uncompress" target="_blank" rel="noopener"
>JavaでZipを圧縮する方法&lt;/a>に関する記事に紹介されてあるものをベースにしています。&lt;/p>
&lt;h2 id="java">Java&lt;/h2>
&lt;p>まずJavaのコードを見ていきましょう。上記の記事には、以下のようなコードが紹介されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">ZipDirectory&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String&lt;span style="color:#ff79c6">[]&lt;/span> args&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> IOException &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String sourceFile &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;zipTest&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileOutputStream fos &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> FileOutputStream&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;dirCompressed.zip&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipOutputStream zipOut &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ZipOutputStream&lt;span style="color:#ff79c6">(&lt;/span>fos&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File fileToZip &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> File&lt;span style="color:#ff79c6">(&lt;/span>sourceFile&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile&lt;span style="color:#ff79c6">(&lt;/span>fileToZip&lt;span style="color:#ff79c6">,&lt;/span> fileToZip&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getName&lt;/span>&lt;span style="color:#ff79c6">(),&lt;/span> zipOut&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">close&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fos&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">close&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">zipFile&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>File fileToZip&lt;span style="color:#ff79c6">,&lt;/span> String fileName&lt;span style="color:#ff79c6">,&lt;/span> ZipOutputStream zipOut&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> IOException &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>fileToZip&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">isHidden&lt;/span>&lt;span style="color:#ff79c6">())&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>fileToZip&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">isDirectory&lt;/span>&lt;span style="color:#ff79c6">())&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>fileName&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">endsWith&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">))&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">putNextEntry&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> ZipEntry&lt;span style="color:#ff79c6">(&lt;/span>fileName&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">closeEntry&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">putNextEntry&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> ZipEntry&lt;span style="color:#ff79c6">(&lt;/span>fileName &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">closeEntry&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File&lt;span style="color:#ff79c6">[]&lt;/span> children &lt;span style="color:#ff79c6">=&lt;/span> fileToZip&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">listFiles&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>File childFile &lt;span style="color:#ff79c6">:&lt;/span> children&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile&lt;span style="color:#ff79c6">(&lt;/span>childFile&lt;span style="color:#ff79c6">,&lt;/span> fileName &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> childFile&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getName&lt;/span>&lt;span style="color:#ff79c6">(),&lt;/span> zipOut&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileInputStream fis &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> FileInputStream&lt;span style="color:#ff79c6">(&lt;/span>fileToZip&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipEntry zipEntry &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ZipEntry&lt;span style="color:#ff79c6">(&lt;/span>fileName&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">putNextEntry&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>zipEntry&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">byte&lt;/span>&lt;span style="color:#ff79c6">[]&lt;/span> bytes &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> &lt;span style="color:#8be9fd">byte&lt;/span>&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">1024&lt;/span>&lt;span style="color:#ff79c6">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> length&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span> &lt;span style="color:#ff79c6">((&lt;/span>length &lt;span style="color:#ff79c6">=&lt;/span> fis&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">read&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>bytes&lt;span style="color:#ff79c6">))&lt;/span> &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">write&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>bytes&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> length&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fis&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">close&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>zipFile&lt;/code>メソッドをみると、引数の&lt;code>fileToZip&lt;/code>にZIPで圧縮したいファイルやディレクトリのパスを指定して、&lt;code>fileName&lt;/code>にはファイルもしくはディレクトリ名、&lt;code>zipOut&lt;/code>には圧縮後のZIPのファイル名を指定するようになっています。&lt;/p>
&lt;p>そして実装としては、指定したファイルやディレクトリに&lt;code>hidden&lt;/code>属性がある場合は圧縮しなく、圧縮元のファイルがディレクトリである場合は中のファイルを全部ZIPに含ませるという処理が含まれてありますね。対象のファイルとディレクトリを全部エントリに追加した後は、圧縮元を読み込んでZipOutputStreamに書き込むという処理となっています。これをKotlinのコードに変えてみましょう。&lt;/p>
&lt;h2 id="kotlinのコードに変えてみる">Kotlinのコードに変えてみる&lt;/h2>
&lt;p>JavaのコードをKotlinのコードに変えるのはそう難しくありません。Intellijの場合、すでにJavaのコードを貼り付けると自動でKotlinのコードの変換してくれる機能を搭載していますので。ただ、それだけでは十分ではないですね。簡単に変換ができるとしても、それが本当に&lt;code>Kotlinらしいコード&lt;/code>になっているとはいえない場合があります。&lt;/p>
&lt;p>そして、処理自体もより単純に、もしくは読みやすいコードにする方法もあるはずですね。上記のJavaコードをまずKotlinに変えて、色々改善したいところを含めて変えていきます。&lt;/p>
&lt;h3 id="kotlinらしいコードに変える">Kotlinらしいコードに変える&lt;/h3>
&lt;p>Intellij 2021.1を基準に、Javaのコードをそのまま貼り付けると以下のようなコードに自動変換されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Throws(IOException&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">zipFile&lt;/span>(fileToZip: File, fileName: String, zipOut: ZipOutputStream) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (fileToZip.isHidden) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (fileToZip.isDirectory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (fileName.endsWith(&lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(ZipEntry(fileName))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(ZipEntry(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$fileName&lt;/span>&lt;span style="color:#f1fa8c">/&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> children = fileToZip.listFiles()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (childFile &lt;span style="color:#ff79c6">in&lt;/span> children) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile(childFile, fileName + &lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span> + childFile.name, zipOut)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> fis = FileInputStream(fileToZip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> zipEntry = ZipEntry(fileName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(zipEntry)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> bytes = ByteArray(&lt;span style="color:#bd93f9">1024&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> length: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span> (fis.read(bytes).also { length = &lt;span style="color:#ff79c6">it&lt;/span> } &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.write(bytes, &lt;span style="color:#bd93f9">0&lt;/span>, length)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fis.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでもっとKotlinらしいコードに変えたい部分は、&lt;code>InputStream&lt;/code>や&lt;code>OutputStream&lt;/code>の使い方です。Javaでも&lt;code>try-with-resource&lt;/code>があって、Kotlinには&lt;code>use()&lt;/code>があるのでそちらを使った方が&lt;code>close&lt;/code>よりも良い気がします。&lt;/p>
&lt;p>また、&lt;code>if&lt;/code>は&lt;code>when&lt;/code>に変えたり、&lt;code>for&lt;/code>を&lt;code>forEach()&lt;/code>に変えたりなどでよりやりたいことを明確にすることができるようにも見えます。個人的にはスコープをあえて分けたほうが責任が明確になり、処理を追うときに混乱しないのでなるべくスコープ関数やCollection専用のオペレーションを積極的に使用して処理の単位を分けられるところはきちんと分けたいと思います。Javaのやり方をとっても処理としては全く問題がありませんが、せっかくなのでKotlinならではのコードを描きたいものです。&lt;/p>
&lt;p>あえてIOExceptionを投げるという表示をしておくというのも、ランタイム時の例外の処理を強制してないKotlinには相応しくないのではないかという気もするので、アノテーションは削除することとします。&lt;/p>
&lt;h3 id="ioからnioに変える">IOからNIOに変える&lt;/h3>
&lt;p>NIOに関しては以前のポストで何回か言及したことがありますが、サーバのように頻繁かつ同時実行数が多いケースは積極的に採用した方が良いと思います。また、Java 1.8以降から追加されたメソッドでかなり便利に使える機能が多いので、IOをNIOに変えるだけでコードの量をかなり減らせる可能性もあります。&lt;/p>
&lt;p>特にディレクトリを指定した場合、そのディレクトリの子要素を循環するにはNIOの&lt;code>Files&lt;/code>が提供する機能が強力なので、今回はそれを積極活用することにします。&lt;/p>
&lt;h3 id="シグニチャーを変える">シグニチャーを変える&lt;/h3>
&lt;p>上記のメソッドでは、三つの引数を取っていますが、実際に必要なのは圧縮元のパスと、圧縮先のパスのみですね。ZipOutputStreamを呼び出し元で渡す理由は特になく、むしろこのメソッドを利用する度に定義する必要があるので不便ですね。そして、メソッドの中で単純にエントリを追加していて、呼び出し元とオブジェクトに対する処理の職務を分担するという構造もあまりよくないかと思います。なので、ZipOutputStreamの生成と使用はメソッドの中で完結するように変えることにします。&lt;/p>
&lt;p>こうすることで、メソッドの外側(呼び出し元)での使い方はもっと簡単になりますし、圧縮元のデータを読み込む際に使う&lt;code>InputStream&lt;/code>は中で閉じているのに引数の&lt;code>OutputStream&lt;/code>は外で閉じるという複雑な状況は避けられます。&lt;/p>
&lt;h3 id="再帰を無くす">再帰を無くす&lt;/h3>
&lt;p>圧縮元のパスがディレクトリである場合は、さらにネストされたディレクトリやファイルもまとめて圧縮するために再帰を使うようになっています。再帰はアルゴリズムとしては重要ではあるものの、処理が全部終わるまでメモリに全データと処理を詰めておくので処理の効率という面ではあまりよくない場合もありますね。やりたいのは単純に&lt;code>hidden&lt;/code>属性を持つファイルやディレクトリを除外すること、そしてそれ以外のファイルやディレクトリは全部ZipOutputStreamのエントリに入れたいという単純な事です。&lt;/p>
&lt;p>幸い、NIOを使うことでディレクトリの子要素を全部取得することができますし、取得した子要素は&lt;code>Stream&amp;lt;Path&amp;gt;&lt;/code>として取得できるので、&lt;code>filter()&lt;/code>や&lt;code>forEach()&lt;/code>のようなメソッドが使えます。これで十分、再帰を使わずに目的を達成できそうですね。&lt;/p>
&lt;h2 id="完成したコード">完成したコード&lt;/h2>
&lt;p>以上のことを反映し、修正したコードは以下の通りになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">object&lt;/span> &lt;span style="color:#50fa7b">ZipService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">archive&lt;/span>(source: Path, target: Path): Unit =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipOutputStream(&lt;span style="color:#50fa7b">Files&lt;/span>.newOutputStream(target)).use { zos &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Files&lt;/span>.walk(source)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { &lt;span style="color:#50fa7b">Files&lt;/span>.isHidden(&lt;span style="color:#ff79c6">it&lt;/span>).not() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#50fa7b">Files&lt;/span>.isDirectory(&lt;span style="color:#ff79c6">it&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.putNextEntry(ZipEntry(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">/&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.putNextEntry(ZipEntry(&lt;span style="color:#ff79c6">it&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#50fa7b">Files&lt;/span>.copy(&lt;span style="color:#ff79c6">it&lt;/span>, zos)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>簡単に説明しますと、&lt;code>object&lt;/code>として宣言したSingletonクラスにおくことでどこでも活用できるユーティリティクラスにして、メソッドのシグニチャはより単純なものにしました。引数の&lt;code>source&lt;/code>には圧縮元のファイルやディレクトリを、&lt;code>target&lt;/code>には圧縮先のZIPファイルを指定する事になっています。ZipOutputStreamはメソッドの中で生成して、&lt;code>use()&lt;/code>を使って自動にクローズされるようにしています。&lt;/p>
&lt;p>まず優先的に&lt;code>Files.walk()&lt;/code>を使って子要素を全部取得するようにしています。取得した子要素は&lt;code>filter()&lt;/code>で&lt;code>hidden&lt;/code>でない場合を選別しているので、分岐は無くなりますね。また、子要素がディレクトリである場合ディレクトリ名であることを表すために&lt;code>/&lt;/code>をつけて&lt;code>ZipEntry&lt;/code>を追加とクローズします。子要素がファイルの場合は&lt;code>ZipEntry&lt;/code>の追加とコンテンツのコピーを行います。これでより短く、単純なコードの出来上がりです。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>&lt;code>Kotlinらしいコード&lt;/code>と述べましたが、上記のコードはあくまで&lt;code>Kotlin/JVM&lt;/code>でのみ有効ですね。なのでもし&lt;code>Kotlin/Native&lt;/code>や&lt;code>Kotlin/JS&lt;/code>などで使うには、別の方法を探す必要があるはずです。また、&lt;code>Files.walk()&lt;/code>はJava 1.8から追加されたメソッドなので、1.7の場合は&lt;code>Files.walkFileTree()&lt;/code>を、その以前なら仕方なくNIOではない別の方法を使う必要があると思います。&lt;/p>
&lt;p>なので、&lt;code>Kotlin/JVM&lt;/code>(Java 1.8以上)ではこれが最善なのかも知れませんが、また色々と研究の余地はありそうですね。こうやってJavaのAPIをKotlinの作法で切り替えていくのも、それなりに価値のあることではないかと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その一〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-1/</link><pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-1/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その一〜" />&lt;p>こないだはGoに関するポストを作成しましたが、やはり本業はKotlinなので、Kotlinに関しても何かわかったことや閃いたことなどあれば、順次に書いていこうと思っています。今回はKotlinでAPIを作りながら、業務での要件をどんなコードで満たしたかを簡単に説明させていただきたいと思います。&lt;/p>
&lt;p>サーバサイドエンジニアをやっていると、要求される機能を以下に実現している方法がどんなものあれ(GraphQL、REST API、マイクロサービスみたいな技術やアーキテクチャの観点の以前の話として)、業務としてはある程度パターン化しているように感じることがあります。こういう場合には、コードよりもロジックが大事であるかのように見える場合もありますね。でも逆に、むしろ似たようなロジックが多いので、より良いコードを書くために工夫できる余地もまた多いのではないか、とも思います。&lt;/p>
&lt;p>正直自分はアルゴリズムに強いわけでもないので、効率的なコードを書くとしたら限界はあるだろうなという気はしています。とりあえず動くコードを書いて、それをリファクタリングしながら少しづつ整える感じのことしかできないのかも知れません。&lt;/p>
&lt;p>しかし、そんな自分にも良いコードを書くためにできることが全くないわけでもないと思います。例えば、Javaでコードを書くときは、参照の問題などからなるべく&lt;code>final&lt;/code>をつけてオブジェクトを&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%9F%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB" target="_blank" rel="noopener"
>immutable&lt;/a>にするようにと教わりましたが、実際は&lt;a class="link" href="https://www.baeldung.com/java-final-performance?__s=m4suw1p9x2sbizbhxrew" target="_blank" rel="noopener"
>ベンチマークで比較した結果&lt;/a>でもわかるように、性能の改善にも繋がっています。また、JavaでもKotlinでも色々と便利なAPIを提供していて、バージョンアップの度にまた新しいAPIが追加されるので、それらの用途と使い方をよく理解した上で、積極的に使用するだけでも読みやすく、性能も良いコードを書くことができます。&lt;/p>
&lt;p>ということで、今回はKotlinのAPIを使って書いていたコードを一部紹介したいと思います。&lt;/p>
&lt;h2 id="リストのグループ化">リストのグループ化&lt;/h2>
&lt;p>DBに商品情報テーブルがあって、さらに商品属性テーブル、生産地や販売店テーブルなどがある場合に、業務によっては「販売店ごとにどんな商品が販売されているかを確認したい」とか、「特定の商品属性に当てはまる商品だけみたい」とかのケースがあるはずですね。&lt;/p>
&lt;p>そういった場合、APIとしてはテーブルから取得したデータを、特定のカラムを基準にまとめたもの返す必要があります。これをコードに書くとしたら&lt;code>List&lt;/code>で取得したデータを、中の一つの属性をキーに&lt;code>Map&lt;/code>にまとめて返すということになりますね。Javaだと、以下のような形になるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBのデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>User&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> list &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">new&lt;/span> User&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">20&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;USA&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Programmer&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">new&lt;/span> User&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;James&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">30&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Canada&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Sales&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">new&lt;/span> User&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Jack&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">35&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;UK&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Programmer&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// UserのJobを基準にまとめる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Map&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">,&lt;/span> List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Pair&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&lt;/span> map &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">groupingBy&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>User&lt;span style="color:#ff79c6">::&lt;/span>getJob&lt;span style="color:#ff79c6">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">mapping&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>user &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Pair&lt;span style="color:#ff79c6">(&lt;/span>user&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getAge&lt;/span>&lt;span style="color:#ff79c6">(),&lt;/span> user&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getName&lt;/span>&lt;span style="color:#ff79c6">()),&lt;/span> Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">())));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// {James=[Pair(first=30, second=Sales)], John=[Pair(first=20, second=Programmer), Pair(first=35, second=Writer)]}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@AllArgsConstructor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">User&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> String name&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> age&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> String address&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> String job&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@AllArgsConstructor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Pair&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> Object first&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> Object second&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinでもJavaのAPIをそのまま使うことができるので、上記の&lt;code>Stream&lt;/code>と&lt;code>Collector&lt;/code>を使って同じことはできます。ただ、せっかく違う言語と使っているわけなので、できればKotlinが提供するAPIを活用して同じことをしたいものです。&lt;/p>
&lt;p>KotlinはCollectionで提供する機能だけでも&lt;code>Stream&lt;/code>と&lt;code>Collector&lt;/code>を組み合わせたものと似たような処理ができる場合が多いので、JavaのAPIに対応した機能があるかどうかを探すだけで事足りるケースが多いです。ということは、上記の処理でキモになっている&lt;code>Collectors.groupingBy()&lt;/code>と&lt;code>Collectors.mapping()&lt;/code>と似たようなものがあればいいというわけですが、&lt;code>groupBy()&lt;/code>でそれらの処理をまとめることができます。なので、上記のコードをKotlinで変えると、以下のようになります。色々とスッキリしますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">20&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;USA&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Programmer&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;James&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">30&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Canada&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Sales&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;Jack&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">35&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;UK&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Programmer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Jobを基準にMap&amp;lt;String, List&amp;lt;Pair&amp;lt;Int, String&amp;gt;&amp;gt;&amp;gt;にまとめる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> map = list.groupBy({ &lt;span style="color:#ff79c6">it&lt;/span>.job }, { &lt;span style="color:#ff79c6">it&lt;/span>.age to &lt;span style="color:#ff79c6">it&lt;/span>.name })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// {Programmer=[(20, John), (35, Jack)], Sales=[(30, James)]}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">User&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> age: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> address: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> job: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mapのvalueだけを変える">Mapのvalueだけを変える&lt;/h2>
&lt;p>上記の処理に加えて、もっと条件がつく場合もあるかと思います。例えば、金額計算とかの例があるとします。従業員が案件ごとに賃金をもらうということになっていて、案件はコードで管理されている場合、賃金を払う側としては同じ案件に対しては合算した金額のみが知りたいとかのケースもあるでしょう。こういう場合には、従業員ごとにデータをまとめた上で、さらにその人が担当した案件のリスト野中で重複するものがあれば、金額だけを合算するようにする必要がありますね。&lt;/p>
&lt;p>こういう場合は、グルーピングの段階からそういう処理を入れるのがもっとも効率的ではあるとは思いますが、スレッドの問題もあるので(生成中のMapの中を巡回するという)、実際のコードに書くとするとかなり複雑になる可能性もあります。なのでここではまず、&lt;code>List&lt;/code>を&lt;code>Map&lt;/code>にまとめた結果を持ってさらに処理を加えるという形を取ります。&lt;/p>
&lt;p>Kotlinの&lt;code>Map&lt;/code>には、&lt;code>map()&lt;/code>以外にも&lt;code>mapKeys()&lt;/code>や&lt;code>mapValues()&lt;/code>のような関数があって、必要な部分だけをマッピングできます。今回は&lt;code>value&lt;/code>だけを変えたいので、&lt;code>mapValues()&lt;/code>を使った方が無駄がなく、コードを読む側としても意図が明確になって良いと思います。&lt;code>mapValues()&lt;/code>を使ってさらにマッピングを行うコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">User&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> name: String, &lt;span style="color:#ff79c6">val&lt;/span> id: Int, &lt;span style="color:#ff79c6">val&lt;/span> amount: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">1000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">4000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// nameでまとめた後、重複するidを一つにまとめる(amountを合算)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> map = list.groupBy({ &lt;span style="color:#ff79c6">it&lt;/span>.name }, { &lt;span style="color:#ff79c6">it&lt;/span>.id to &lt;span style="color:#ff79c6">it&lt;/span>.amount })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .mapValues {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// idでグルーピング
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.&lt;span style="color:#ff79c6">value&lt;/span>.groupBy { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.first }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// keyはそのまま、valueだけを合算する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> .map { map &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> map.key to map.&lt;span style="color:#ff79c6">value&lt;/span>.sumBy { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.second } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// {A=[(1, 3000), (2, 4000)], B=[(3, 5000)]}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>List&lt;/code>を&lt;code>Map&lt;/code>にまとめるもう一つの方法は、&lt;code>groupingBy()&lt;/code>があります。この関数を使うと、Collectionが&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-grouping" target="_blank" rel="noopener"
>Grouping&lt;/a>というオブジェクトに変わって、&lt;code>aggregate()&lt;/code>・&lt;code>reduce()&lt;/code>・&lt;code>fold()&lt;/code>・&lt;code>eachCount()&lt;/code>のような関数を使うことで後続の処理ができます。上記のコードを&lt;code>Grouping&lt;/code>を使ったものに変えるとしたら、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Groupingのaggregateを利用してMapに変えた後から、valueの処理を行う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> map = list.groupingBy { &lt;span style="color:#ff79c6">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .aggregate { _, accumulator: MutableList&amp;lt;Pair&amp;lt;Int, Int&amp;gt;&amp;gt;?, element, first &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 新しいキーなら、MutableListを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (first)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutableListOf(element.id to element.amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// そうではない場合は、存在するListに要素を追加する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accumulator&lt;span style="color:#ff79c6">?.&lt;/span>apply { add(element.id to element.amount) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.mapValues {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.&lt;span style="color:#ff79c6">value&lt;/span>&lt;span style="color:#ff79c6">?.&lt;/span>groupBy { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.first }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">?.&lt;/span>map { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.key to pair.&lt;span style="color:#ff79c6">value&lt;/span>.sumBy { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.second } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見、&lt;code>groupingBy()&lt;/code>の方が複雑にも見えますが、&lt;code>accumulator&lt;/code>を使ってマッピングした値を積み重ねることができるので、場合によっては考慮する価値があるかもですね。&lt;/p>
&lt;h2 id="mapを使ったキャッシュ">Mapを使ったキャッシュ&lt;/h2>
&lt;p>DBの参照が頻繁であり、なお参照されるデータそのものは更新される頻度が高くない場合は、アプリケーション内にキャッシュして置くのが良いケースもたまにありますね。こういう場合には、パラメータをキーとして持つ&lt;code>Map&lt;/code>を宣言しておいて、そのキーがない場合だけDBにアクセスする(そして&lt;code>Map&lt;/code>に追加する)という形にすれば良いでしょう。Javaでは1.8から&lt;code>computeIfAbsent()&lt;/code>というメソッドを提供しているので、簡単に実装ができます。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> list &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// キャッシュのMap
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Map&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">,&lt;/span> Boolean&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> map &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ConcurrentHashMap&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// パラメータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>String element &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// キャッシュにパラメータがない場合はDBデータを参照して、追加した後に返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Boolean exists &lt;span style="color:#ff79c6">=&lt;/span> map&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">computeIfAbsent&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>element&lt;span style="color:#ff79c6">,&lt;/span> key &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">contains&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>element&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Method Referenceを使った例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>exists &lt;span style="color:#ff79c6">=&lt;/span> map&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">computeIfAbsent&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>element&lt;span style="color:#ff79c6">,&lt;/span> list&lt;span style="color:#ff79c6">::&lt;/span>contains&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaで提供する機能なので、もちろんKotlinでも全く同じ形で実装できます。ただ、Kotlinの仕様上&lt;code>compute&lt;/code>のコードが&lt;a class="link" href="https://kotlinlang.org/docs/lambdas.html#instantiating-a-function-type" target="_blank" rel="noopener"
>LambdaかMethod Referenceかによって書き方が違う&lt;/a>ので、そこだけ注意する必要があります。これはKotlin自体の仕様によるものですが、Javaの書き方に慣れていると最初はなかなかわかりにくいところかも知れません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// キャッシュのMap
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> map = ConcurrentHashMap&amp;lt;String, Boolean&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// パラメータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> element = &lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Lambdaの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> exists = map.computeIfAbsent(element) { list.contains(element) } &lt;span style="color:#6272a4">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Method Referenceの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>exists = map.computeIfAbsent(element, list&lt;span style="color:#ff79c6">::&lt;/span>contains)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、似たような機能をするメソッドとして&lt;code>putIfAbsent()&lt;/code>がありますが、&lt;code>computIfAbsent()&lt;/code>の場合&lt;code>Map&lt;/code>にキーがなかった場合にだけ後続の処理が行われるに対して、&lt;code>putIfAbsent()&lt;/code>はキーがあるかないかに関係なく処理が走ってしまうという違いがあるらしいです。なのでキャッシュとして使う場合は、&lt;code>computeIfAbsent()&lt;/code>を使った方が良いでしょう。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>自分が書いたコードをいくつか紹介しましたが、いかがだったでしょうか。まだKotlinに移行したばかりなので色々とわからないことが多く、本当はもっとスマートな方法があるのかも知れませんが、自分的には、こうやって実際の業務の要件に合わせて違う言語とコードを比べながら、APIのソースをみたりで自分なりにどうやって書くかを考えてみるのは意味のあることで、楽しいとも思います。&lt;/p>
&lt;p>というわけで、これからもKotlinでの書き方に対する研究はこれからも続きます。そろそろGoでも簡単なAPIでも作ってみたりで勉強をしないとやばそうな気もしていますが…まぁ、なんとかなるでしょう。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>JavaプログラマーがみたGo</title><link>https://retheviper.github.io/posts/go-first-impression/</link><pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/go-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/go.jpg" alt="Featured image of post JavaプログラマーがみたGo" />&lt;p>このブログのポストとしてはいきなりですが、転職してからは仕事の都合上Goも少し触ることとなりました。以前からGoかRustに触れてみたいなとは思っていたのものの、いざ全く触れてみたことのない言語で書かれてあるアプリを修正するようなことになると少し怖くもなります。なので、少しでもGoのことを知っておくべきではありますね。というわけで、今回はGoに少し触れてみて感じたことを、Javaプログラマーの観点から述べてみたいと思います。&lt;/p>
&lt;p>Goの特徴は、色々とあると思いますが、正直GCがあって、VMがない言語だという特徴は、実際はあまり肌で感じる違いではないです。VMがないから、ある言語よりは早いだろうなというとしか言えませんね。&lt;/p>
&lt;p>実際その言語を持ってコードを書くという仕事をしている身からしては、そのような特徴よりも、コードを書く場面で気にしなければならないことの方に注目したいものです。まずは自分が今まで触れてきた言語とはどう違うかですね。例えば、ループや条件などを書くときはどうなのか、今までの習慣通りコードを書いても問題ないだろうか、注意すべきところは何かなど。今回はそのような観点から本当の少しだけGoに触れてみた感想を書いていきたいと思います。&lt;/p>
&lt;h2 id="考え方を変える必要があるかも">考え方を変える必要があるかも&lt;/h2>
&lt;p>Goに少し触れてみて考えたことは、もっとも基本的な部分でもJavaを書くときとはかなり違うアプローチが必要ではないかということでした。私の場合はJava意外にPython、JavaScript、TypeScript、Kotlinに触れてみたことがあるのですが、JavaScriptやTypeScriptはJavaの書き方とそう変わらない感覚で書くことができて、Kotlinも基本はJavaを簡略化した感覚でコードが書けます。Pythonがかなり違うのですが、どちらかというと書きたいコードを文法の制約なしで書けるという感覚に近いので、文法の差が気にならないものでした。&lt;/p>
&lt;p>しかし、Goの場合は少しわけが違います。Javaと比べ、書き方が少し違うだけでなく、機能レベルで違いがあるからです。機能レベルで違うということは、単純にJavaのコードを少し変更したくらいのコードを書くことはあまりよくないということになると思います。なので、そもそもの考え方を変える必要があるのではないかと思いました。そういう観点から感じたGoの印象は、以下の通りです。&lt;/p>
&lt;h3 id="似ているようで似ていない">似ているようで、似ていない&lt;/h3>
&lt;p>まず目立つのは、文法です。もちろん、大枠はいわゆるCファミリープログラミング言語とそう変わらないですが、Javaと比較すると文法の構造以外の部分でかなり変わった部分があります。例えば、&lt;code>Walrus Operator&lt;/code>とも呼ばれる&lt;a class="link" href="https://docs.python.org/ja/3/whatsnew/3.8.html#assignment-expressions" target="_blank" rel="noopener"
>Pythonの代入式&lt;/a>に似たような表現があったり、if文の条件式を括弧なしで書けたり、importを文字列で書いたり、クラスや&lt;code>public&lt;/code>・&lt;code>private&lt;/code>のようなキーワードが無かったりの違いがあるので、コードを書くときの感覚が違うだけでなく、パッケージ構造やアプリケーションのアーキテクチャ設計のレベルで今まで自分が経験していたJavaやKotlinとは違うアプローチが必要ではないかと思えるくらいです。&lt;/p>
&lt;p>色々と違う点を述べましたが、単純にコードを持って比較してみましょう。例えば、以下のようなコードがあるとしましょう。数字に関する計算を担当するクラスがあって、中には渡された引数が奇数か偶数かを判別して、結果を標準出力する形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">package&lt;/span> simple.math&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> Class Calculator &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">judge&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> number&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">boolean&lt;/span> result &lt;span style="color:#ff79c6">=&lt;/span> number &lt;span style="color:#ff79c6">%&lt;/span>&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>result&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>number &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;は偶数です&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>number &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;は奇数です&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをGoのコードに変えてみます。例えば以下のようになると思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">package&lt;/span> simple.math
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">Judge&lt;/span>(number &lt;span style="color:#8be9fd">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> condition &lt;span style="color:#ff79c6">:=&lt;/span> number &lt;span style="color:#ff79c6">%&lt;/span> &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> condition {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(number, &lt;span style="color:#f1fa8c">&amp;#34;は偶数です&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(number,&lt;span style="color:#f1fa8c">&amp;#34;は奇数です&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見あまり変わらないように見えるかも知れませんが、細かいところが違うので注意しなければならないところがあります。いくらIDEの性能がよくなったとはいえ、その言語の仕様と全く違うようなコードを書いてしまっては、正しいコードを提示してくれませんので。例えばインポートは複数になると、以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;math&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pythonの場合も一行でimportをまとめたり、&lt;code>from&lt;/code>と&lt;code>as&lt;/code>でAliasを指定するようなことができたりもします。しかし、Goで根本的に違うのは、GoそのものがMavenやGradleのようなパッケージ管理もできるので、インポートにgithubのパッケージを描くこともできるということです。例えば以下のようなコードで、Goのウェブフレームワークである&lt;a class="link" href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener"
>Gin&lt;/a>をインポートすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;github.com/gin-gonic/gin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、変数を&lt;code>:=&lt;/code>を使って宣言する場合は、関数内でのみ可能であるので、パッケージレベルで宣言する場合は普通に&lt;code>var&lt;/code>を使う必要があるという仕様も理解する必要があったりします。そしてそれに対して、関数の引数としては&lt;code>var&lt;/code>宣言がいらなく、型を宣言する必要があります。どんな場合でも(初期化とともに&lt;code>var&lt;/code>を使うことは最近のJavaでも可能になりましたが)変数の型を書く必要のあるJavaとは大きく違うところですね。こういう細かい違いがあるので、Goの作法に対する理解なしでJavaの感覚のままコードを書くのは大変なことになるかも知れません。&lt;/p>
&lt;h3 id="大文字には機能がある">大文字には機能がある&lt;/h3>
&lt;p>会社ごとにルールは違うかと思いますが、今までの自分が経験では、言語がJavaであれJavaScriptであれ以下のようなルールで書く場合が多かったです。&lt;/p>
&lt;ul>
&lt;li>クラス、インタフェース名はPascalCase&lt;/li>
&lt;li>フィールド、メソッド、変数、引数はcamelCase&lt;/li>
&lt;/ul>
&lt;p>たまにPythonでコードを書く場合はsnake_caseだったり、URLはkebab-caseだったりもしたのですが、プライベートでも多くの場合このルールに従ってコードを書いています。そしてこれはあくまで人間が定めたルールなので、守らなくても&lt;/p>
&lt;p>しかし、GoではPascalCaseかcamelCaseかによって意味が変わる部分があります。正確には頭が大文字か小文字かによる違いですね。&lt;code>public&lt;/code>と&lt;code>private&lt;/code>の代わりになってくるのが、この仕様です。簡単に説明すると、&lt;code>他のパッケージからも参照できる&lt;/code>のは大文字から始まるフィールドや関数であり、そうでない場合は小文字から始まるものということです。&lt;/p>
&lt;p>例えば以下をみてください。&lt;a class="link" href="https://tour.golang.org" target="_blank" rel="noopener"
>A Tour of Go&lt;/a>で提示しているコードです。ここでは&lt;code>math&lt;/code>パッケージをインポートして、あらかじめ定義されてある&lt;code>π&lt;/code>を標準出力している例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;math&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(math.pi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、なんの問題もないかのように見えますが、実行すると以下のようなエラーメッセージが出力されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./prog.go:9:14: cannot refer to unexported name math.pi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはつまり、外部から参照できないということですね。なので、正しいコードに変えると&lt;code>main&lt;/code>関数を以下のように直す必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(math.Pi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先端が大文字であり、外部から参照できるように定義された名前のことを&lt;a class="link" href="https://go-tour-jp.appspot.com/basics/3" target="_blank" rel="noopener"
>Exported Names&lt;/a>というらしいです。Goにはクラスがないので、パッケージをインポートして、そのパッケージ内に存在する&lt;code>.go&lt;/code>ファイルの中に&lt;code>Export Names&lt;/code>で定義された項目のみを参照することになります。なのでクラスを作って、そのクラスのインスタンスを生成し、小文字から始まるフィールドやメソッドを呼ぶというJavaの作法とは感覚が大きく違いますね。&lt;/p>
&lt;h2 id="ポインターの存在">ポインターの存在&lt;/h2>
&lt;p>プログラマーだと誰もが知っていることだと思いますが、ポインターがあるかどうかの問題は、コードを各感覚にかなりの影響を与えるようなものです。JavaやKotlinなど、ポインターがない言語ではクラスやメソッド間にただ、GoにはGCがあるので、CやC++のようなメモリー問題はないかとも思いますが、とにかく直接使ってみないとわからないところですね。&lt;/p>
&lt;p>もちろん、Javaでも&lt;code>public static&lt;/code>で宣言したり、Springだと&lt;code>Autowired&lt;/code>アノテーションをつけることでどこでもアクセスできるオブジェクトを作ることは可能です。Kotlinだと&lt;code>companion object&lt;/code>という、クラスに似たようなものをまず定義する必要がありますが、呼び出し元としてはJavaとあまり変わらないコードになりますね。&lt;/p>
&lt;p>しかし、こう言った&lt;code>static&lt;/code>なものは、JavaやKotlinだと&lt;code>定数&lt;/code>として使われるのが一般的です。&lt;code>Autowired&lt;/code>でも&lt;code>Singletone&lt;/code>と使い方はあまり変わらず、固定値を格納するか、常に同じ動作(&lt;code>冪等&lt;/code>に違い)をすることを期待するのが一般的ですね。それに比べ、ポインターはやはりその値を直接書き換えたりすることを期待する場合もあるので、やはり違うものです。&lt;/p>
&lt;p>まだ私はポインターを本格的に扱う言語に触れてみたことがなく、Goでもポインターを活用するようなコードは書いたことがあまりないので、ここで言えるのは上記で述べた内容だけですが、私と同じくポインターのない言語の経験しかない方にはやはり慣れるまで時間がかかるのではないかと思います。試行錯誤もかなりありそうですね。&lt;/p>
&lt;h2 id="例外処理が独特">例外処理が独特&lt;/h2>
&lt;p>Goで書かれてあるコードをみて、何が一番目立つかというと、例外処理の部分ではないかと思います。私が経験したことのある言語(Java、Python、JavaScript、TypeScript、Kotlin)では、例外処理のために&lt;code>try-catch&lt;/code>ブロックという仕様がありました。言語ごとに少しづつ違うところはありましたが、基本的に例外が発生しうる場所をそのブロックで囲んでから処理する、という発想自体は変わりがありません。例えば以下のようなコードで例外を処理することが一般的でしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String&lt;span style="color:#ff79c6">[]&lt;/span> args&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> result &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">try&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#ff79c6">=&lt;/span> divide&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">catch&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>Exception e&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>e &lt;span style="color:#ff79c6">instanceof&lt;/span> ArithmeticException&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;0で分けません&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>result&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">divide&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> numerator&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> denominator&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> numerator &lt;span style="color:#ff79c6">/&lt;/span> denominator&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Goではそのような機能はありません。代わりに、どんな関数でも戻り値として&lt;code>期待する値&lt;/code>と&lt;code>発生したエラー&lt;/code>を定義し、呼び出し元では関数の実行結果としてエラーが発生したを確認して、エラーが発生していたら(エラーが&lt;code>nil&lt;/code>ではない場合)にそのエラーの対応をする、ということが一般的な作法のようです。言葉で説明すると難しいので、実際のコードをみていきましょう。上記のコードをGoの作法に合わせて書き直すと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result, err &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#50fa7b">divide&lt;/span>(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> err &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(result)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">divide&lt;/span>(numerator &lt;span style="color:#8be9fd">int32&lt;/span>, denominator &lt;span style="color:#8be9fd">int32&lt;/span>) (&lt;span style="color:#8be9fd">int32&lt;/span>, &lt;span style="color:#8be9fd">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (denominator &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> numerator &lt;span style="color:#ff79c6">/&lt;/span> denominator, &lt;span style="color:#ff79c6">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>, errors.&lt;span style="color:#50fa7b">New&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;0で分けません&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、関数ではエラーが発生した場合にそれをそのまま返し(上記のコードでは、あえてエラーを作っていますが)、呼び出し元ではエラーがあったかどうかを確認して分岐します。こうすることで「エラーが発生した場所が明確になる」メリットがあるらしいです。確かに、&lt;code>try-catch&lt;/code>ブロックが囲んでいるコードが多ければ多いほど、例外が発生し得るコードがどれなのかわからなくなる場合もありますね。例外を処理するための機能が、例外を起こさないコードと混り、わけがわからなくなります。そういう観点からすると、Goのアプローチはエラーとロジックを分離できるというメリットがあると言えるでしょう。&lt;/p>
&lt;p>ただ、Goの作法では関数を呼び出す度に後続でエラーチェックが入るので、毎回同じ様なコードを書く場合があるのは少し違和感があります。例えば以下のようなコードを見かけるのですが、皆さんはどう思われるのでしょうか。もっとスマートな方法があって、自分が知らないだけなのかも知れませんが…&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// いくつかの関数を呼び出して処理をする関数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>() (&lt;span style="color:#8be9fd">string&lt;/span>, &lt;span style="color:#8be9fd">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 関数1を呼び出す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> result1, err1 &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#50fa7b">someFunction1&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 関数1でエラーが発生した場合はエラーを返却する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> err1 &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 関数1でエラーが発生していない場合は関数2を呼び出す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> result2, err2 &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#50fa7b">someFunction2&lt;/span>(result1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 関数2でエラーが発生した場合はエラーを返却する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> err2 &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 関数2でエラーが発生していない場合は関数2を呼び出す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> result3, err3 &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#50fa7b">someFunction3&lt;/span>(result2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 関数3でエラーが発生した場合はエラーを返却する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> err3 &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 関数3でエラーが発生していない場合は関数2を呼び出す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> result4, err4 &lt;span style="color:#ff79c6">:=&lt;/span> &lt;span style="color:#50fa7b">someFunction4&lt;/span>(result3)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 関数4でエラーが発生した場合はエラーを返却する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> err4 &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#ff79c6">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...続く
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="コンパイラーが厳しい">コンパイラーが厳しい&lt;/h2>
&lt;p>コンパイルエラーが発生した場合はIDEで知らせてくれるので気にすることはあまりないかと思いがちですが、意外と気になるのはコンパイラーの厳しさです。個人的には&lt;code>jShell&lt;/code>の様なインタラクティブツールを使ってよくコードの検証をするのですが、GoにはそれがないのでVimで書いたコードをターミナルで動かしてみたり、&lt;a class="link" href="https://play.golang.org/" target="_blank" rel="noopener"
>The Go Playground&lt;/a>を使ってみています。そしてこういう方法ではIDEの様なサポートをあまり期待できませんので、コンバイルエラーになることが多かったです。&lt;/p>
&lt;p>ただ、コンパイルエラーといっても色々な原因がありますが、Goは特に他の言語と比べてもかなり厳しいのではないかと思います。例えば以下の様なコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ターミナルやThe Go Playgroundでこれを実行すると、以下の様なエラーメッセージが出ます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./prog.go:4:2: imported and not used: &lt;span style="color:#f1fa8c">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インポートしたパッケージが使われていないというエラーですね。さらに、以下の様なコードを実行したとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> result &lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;this is test program&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードを実行した結果は、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./prog.go:8:9: result declared but not used
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回は&lt;code>result&lt;/code>という変数が使われてないというエラーです。この様に、Goでは使われてないインポートや変数などがあればエラーとなるので、他の言語と比べ厳しい方と言えますね。なので、プラグインなしのVimを使って修正するなどの場合には十分に気をつける必要がありますね。IDEでも少しはめんどくさいかも知れません。(リンティングと同時に使われてないパッケージや変数を削除してくれるとかの設定をすれば良いかもですが)&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>他にも細かい違いはまだまだ山ほどありますが、今の時点で言えるものはこのくらいです。ここで述べた、Javaプログラマーの観点からみたGoの特徴というものは、実は「慣れれば問題ない」だけなのかも知れません。しかし、「慣れる」ということは、「すでに慣れている」ものがあったらまたなかなか難しいものにもなりますね。&lt;/p>
&lt;p>例えば、人間の言語でいうと、同じ系列のドイツ語の話者が英語を学ぶのは簡単と言われていますが、それは二つの言語がよく似ているからですね。逆に&lt;a class="link" href="https://www.businessinsider.com/the-hardest-languages-to-learn-2014-5" target="_blank" rel="noopener"
>英語が母国語である人には中国語・日本語のような言語がもっとも難しい言語らしい&lt;/a>のですが、これは語彙、文字、文章構造の全てが違うのが原因だそうです。プログラミング言語も本質は人間の言語を模倣しているものなので、新しい言語を学ぶ際には、それが自分の母国語と言える言語と似ていれば似ているほど学びやすく、そうでない場合は難しく感じるものではないかと思います。そういう観点からすると、JavaからGoへの移行は、簡単そうで難しそうな側面があるかなという気がします。&lt;/p>
&lt;p>もちろん、世の中には元Javaプログラマーでも、Goの方が簡単だった！という方もたくさんいらっしゃるかと思います。ただ自分がついていけないだけなのかも…ですが。&lt;/p></description></item><item><title>JavaプログラマーがみたKotlin〜その二〜</title><link>https://retheviper.github.io/posts/kotlin-basics/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-basics/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post JavaプログラマーがみたKotlin〜その二〜" />&lt;p>この度は、転職することとなり、仕事で使われる言語もJavaからKotlinに変わることになりました。個人的にKotlinで簡単なSpring WebFluxプロジェクトを作ってみたことはあり、もともとJavaプログラマがKotlinへ移行するのは難しいことではないと言われてはいるものの、やはり仕事で使われる言語が変わるというのはかなりのチャレンジではあると思います。なので、今まではJavaに関してのポストを主に載せていたのですが、これからはKotlinに関してのポストを増やしていきたいと思います。&lt;/p>
&lt;p>まず、よく知られているように、KotlinはJavaと完璧な互換性を持つものです。それはJVM言語であり、コンパイルしたらJavaと同じくバイトコードになるからですね。ただ、だからと言って「Javaの感覚で」コードを書くということは、Kotlinという「違う言語」に移行する意味を無くす行為な気がします。なぜなら、Kotlinは触れば触るほどJavaとは根本的に違う考え方で設計されている言語だということが伝わってくるからです。最初はJavaの冗長さ(Verbose)を減らすことが第一の目標ではないかという印象を受けましたが、本格的に勉強を始めるとそれだけではないような気がしているのです。&lt;/p>
&lt;p>今回のポストは、&lt;a class="link" href="https://www.coursera.org" target="_blank" rel="noopener"
>Coursera&lt;/a>の&lt;a class="link" href="https://www.coursera.org/learn/kotlin-for-java-developers" target="_blank" rel="noopener"
>Kotlin for Java Developers&lt;/a>の講義の内容に基づいて作成されました。&lt;/p>
&lt;h2 id="冗長さを減らすということ">冗長さを減らすということ&lt;/h2>
&lt;p>Javaは今でも良い言語であり、多くの言語が発表されエンタープライズレベルで使われるようになった今でも、幅広い分野で使われていますね。Javaが依然としてよく使われる言語であることは、&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE index&lt;/a>やJetBrainsの&lt;a class="link" href="https://www.jetbrains.com/lp/devecosystem-2020" target="_blank" rel="noopener"
>The State of Developer Ecosystem&lt;/a>、Stackoverflowの&lt;a class="link" href="https://insights.stackoverflow.com/survey/2020" target="_blank" rel="noopener"
>Developer Survey&lt;/a>からも読み取れることです。&lt;/p>
&lt;p>ただ、Javaが依然として人気の言語だとしても、それは圧倒的にJavaが他の言語に比べ優秀だとか、使いやすい言語であるという意味ではないでしょう。どの言語でもそうであると思いますが、Javaでよく指摘されている問題の一つは、「冗長すぎる」というところです。数多くのライブラリがあり、MavenやGradleのような優秀なビルドツールを使えながらも、やはり言語の仕様は変わってないですからね。Java 9からはこの問題を解消するため、他の言語から影響を受けたような機能を多く導入していますが(例えば、&lt;a class="link" href="https://blogs.oracle.com/javamagazine/pattern-matching-for-instanceof-in-java-14" target="_blank" rel="noopener"
>instanceofのパターンマッチング&lt;/a>や&lt;a class="link" href="https://blogs.oracle.com/javamagazine/records-come-to-java" target="_blank" rel="noopener"
>record&lt;/a>など)、言語そのものの設計思想が変わるというよりは「違う言語の特徴をJavaに合わせた仕様で導入する」ことに近いので、根本的な変化とは言えないものです。なので今まで書かれている冗長なコードは残るもので、またこれからも使われることになるはずです。&lt;/p>
&lt;h3 id="コードが短くなる">コードが短くなる&lt;/h3>
&lt;p>冗長さを減らすということは、簡単にいうと「より短いコードで、同じ結果を得る」と定義できるでしょう。そういう観点からすると、KotlinはJavaの冗長さを減らすために工夫した痕跡が言語の仕様から感じ取れるようなものです。例えば以下のようなコードがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">updateWeather&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> degrees&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String description&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Color color&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>degrees &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;cold&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#ff79c6">=&lt;/span> BLUE&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>degrees &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> &lt;span style="color:#bd93f9">25&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;mild&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#ff79c6">=&lt;/span> ORANGE&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;hot&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#ff79c6">=&lt;/span> RED&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをKotlinで書き換えると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> (description, color) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (degrees &amp;lt; &lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;cold&amp;#34;&lt;/span>, BLUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (degrees &amp;lt; &lt;span style="color:#bd93f9">25&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;mild&amp;#34;&lt;/span>, ORANGE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;hot&amp;#34;&lt;/span>, RED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まず二つの変数を、戻り値が&lt;code>Pair&lt;/code>のオブジェクトの表現式でより短くできることがわかります。そしてこのコードは、&lt;code>when&lt;/code>句を使ってより短い形で変えることもできます。その結果が以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> (description, color) = &lt;span style="color:#ff79c6">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#bd93f9">10&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;cold&amp;#34;&lt;/span>, BLUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#bd93f9">25&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;mild&amp;#34;&lt;/span>, ORANGE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;hot&amp;#34;&lt;/span>, RED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに&lt;code>Pair&lt;/code>は、&lt;code>to&lt;/code>を使うことでもっと簡単に表現することもできます。そうすると、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> (description, color) = &lt;span style="color:#ff79c6">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#bd93f9">10&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;cold&amp;#34;&lt;/span> to BLUE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#bd93f9">25&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;mild&amp;#34;&lt;/span> to ORANGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;hot&amp;#34;&lt;/span> to RED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最初のJavaのコードと比べ、かなり簡単かつ明瞭なコードになっているのがわかります。他の言語を使っていた人だとしても、一瞬ですぐに何をしているのかがわかって、より短く効率なコードになっているのがわかりますね。こういうところこそ、KotlinがJavaの冗長さ−無駄を減らすことに力を入れている部分ではないかと思います。&lt;/p>
&lt;h3 id="コードを簡単に書ける">コードを簡単に書ける&lt;/h3>
&lt;p>自分は最初、Kotlinの文法を簡単にみながら&lt;code>switch&lt;/code>がここでは&lt;code>when&lt;/code>に変わって、&lt;code>case&lt;/code>を書く必要がないんだな、くらいの印象しか受けてなかったです。しかし、よくよく見ると、他にもJavaと違うところが良く見えます。ここで読み取れるものは、例えばさっきのコードだと以下がありますね。&lt;/p>
&lt;ul>
&lt;li>&lt;code>when&lt;/code>句が表現式として使える&lt;/li>
&lt;li>&lt;code>when&lt;/code>句の条件の対象は条件式の中のみで良い&lt;/li>
&lt;li>表現式の中で複数の値を戻り値として定義し、それを&lt;/li>
&lt;li>&lt;code>to&lt;/code>で二つのオブジェクトを&lt;code>Pair&lt;/code>にまとめることができる&lt;/li>
&lt;/ul>
&lt;p>他にも、Javaの&lt;code>switch&lt;/code>に比べKotlinの&lt;code>when&lt;/code>句は以下のよう活用ができるというところもあります。オブジェクトの比較がより簡単ですね。例えば以下のようなコードで、簡単に二つのオブジェクトに対しても比較が可能になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">mix&lt;/span>(c1: Color, c2: Color) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">when&lt;/span> (setOf(c1, c2)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(RED, YELLOW) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> ORANGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(YELLOW, BLUE) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> GREEN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(BLUE, VIOLET) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> INDIGO
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> Exception(&lt;span style="color:#f1fa8c">&amp;#34;Dirty Color&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをあえてJavaのコードで書くとしたら、おそらく以下のようになるでしょう。個人的に、たくさんの&lt;code>else if&lt;/code>はあまり読みやすいコードではなく、書く立場としても綺麗ではないと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> Color &lt;span style="color:#50fa7b">mix&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Color c1&lt;span style="color:#ff79c6">,&lt;/span> Color c2&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>c1 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">RED&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">YELLOW&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">ORANGE&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>c1 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">YELLOW&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">BLUE&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">GREEN&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>c1 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">BLUE&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">VIOLET&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">INDIGO&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> RuntimeException&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Dirty Color&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、KotlinではJavaと同じことをするとしても、短いだけでなく、より簡単にコードをかけるということですね。もちろん、別のメソッドを作ったり、&lt;code>Comparable&lt;/code>なオブジェクトを作ったり、&lt;code>Comparator&lt;/code>クラスを実装することでJavaでも似たようなことはできるかも知れません。しかし、そこまでしたいかというと微妙ですね。&lt;/p>
&lt;p>もちろん、Java 12からはKotlinの&lt;code>when&lt;/code>に近い感覚でコードを書くこともできるようになっています。表現式としても使えて、複数の条件を指定することができ、&lt;code>Lambda&lt;/code>の感覚で書けるということも良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>var result &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">switch&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>month&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> JANUARY&lt;span style="color:#ff79c6">,&lt;/span> JUNE&lt;span style="color:#ff79c6">,&lt;/span> JULY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">3&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> FEBRUARY&lt;span style="color:#ff79c6">,&lt;/span> SEPTEMBER&lt;span style="color:#ff79c6">,&lt;/span> OCTOBER&lt;span style="color:#ff79c6">,&lt;/span> NOVEMBER&lt;span style="color:#ff79c6">,&lt;/span> DECEMBER &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> MARCH&lt;span style="color:#ff79c6">,&lt;/span> MAY&lt;span style="color:#ff79c6">,&lt;/span> APRIL&lt;span style="color:#ff79c6">,&lt;/span> AUGUST &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> monthLength &lt;span style="color:#ff79c6">=&lt;/span> month&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toString&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">length&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> yield monthLength &lt;span style="color:#ff79c6">*&lt;/span> &lt;span style="color:#bd93f9">4&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">default&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような変化を見ると、この「冗長さを減らす」という面では、Javaもまたバージョンアップとともに新機能を次々と導入してきているので、Kotlinの魅力が半減しているように見えるかも知れません。しかし、Kotlinではもっと重要なポイントがまた一つあります。言語自体の拡張性です。&lt;/p>
&lt;h2 id="拡張ができるということ">拡張ができるということ&lt;/h2>
&lt;p>言語自体の拡張性と言いましたが、簡単にいうと、以前にも紹介したことのある拡張関数、つまり&lt;code>extension&lt;/code>のことです。Kotlinの仕様としてもこれは大きい部分として紹介されているものですね。これをよく使うと、ただ「継承しなくてもそのクラスにメソッドを追加できる」だけでなく、&lt;code>infix&lt;/code>と組み合わせることでまるで予約後であるように使うことができます。&lt;/p>
&lt;p>実際、&lt;a class="link" href="https://www.coursera.org/learn/kotlin-for-java-developers" target="_blank" rel="noopener"
>Kotlin for Java Developers&lt;/a>のコーディング問題では、&lt;code>infix&lt;/code>で書かれた以下の拡張関数を持って結果の確認を行っていると言われています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">infix&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">T&lt;/span>.eq(other: T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> other) println(&lt;span style="color:#f1fa8c">&amp;#34;OK&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> println(&lt;span style="color:#f1fa8c">&amp;#34;Error: &lt;/span>&lt;span style="color:#f1fa8c">$this&lt;/span>&lt;span style="color:#f1fa8c"> != &lt;/span>&lt;span style="color:#f1fa8c">$other&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>infix&lt;/code>を使うと、以下のようなコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&amp;#34;ABC&amp;#34;&lt;/span> eq &lt;span style="color:#f1fa8c">&amp;#34;ABC&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような特徴があるということは、使う側からしても便利ですが、これから言語そのもののバージョンアップにしたがってより便利な機能が追加され安いことにもなっていると思います。例えば先ほどの&lt;code>Pair&lt;/code>オブジェクトを作る&lt;code>to&lt;/code>が、このように&lt;code>infix&lt;/code>関数として作られているものです。これからもこういった便利な機能が追加され、追加しやすくなるのは確かに開発のコストの削減をという面でも良いことですね。&lt;/p>
&lt;h2 id="もう十分便利であること">もう十分便利であること&lt;/h2>
&lt;p>冗長さを減らし、拡張性がある言語だという特徴は、おそらくKotlinを作っているJetBrainsにとっても十分有効な特徴であるかと思います。Kotlinのスタンダードライブラリを見ると、すでに便利な関数が多く存在しています。例えば、簡単なループでは以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 一般的なfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">for&lt;/span> (element &lt;span style="color:#ff79c6">in&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(element)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデックスを含むfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">for&lt;/span> ((index, element) &lt;span style="color:#ff79c6">in&lt;/span> list.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$index&lt;/span>&lt;span style="color:#f1fa8c">: &lt;/span>&lt;span style="color:#f1fa8c">$element&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデックスのみのfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">for&lt;/span> (index &lt;span style="color:#ff79c6">in&lt;/span> list.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(index)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前もJavaのfor文の性能についてのポストで簡単に述べたことがありますが、そこではJavaならインデックスが必要な場合は伝統的なfor文を使い、そうではない場合は一般的に拡張for文を使った方がいいという結論をJMHでのベンチマークで出していました。しかし、こうやってすでに言語から便利な方法を提供していると、性能を気にすることなく便利な方法を取れるという面でも魅力的です。&lt;/p>
&lt;p>そして、forEachでもインデックスが必要であるなら、&lt;code>forEachIndexed&lt;/code>を使えるという良い点もあります。例えば、以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 一般的なforEach文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>list.forEach(&lt;span style="color:#ff79c6">::&lt;/span>println)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデックスを含むforEach文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>list.forEachIndexed { index, element &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> println(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$index&lt;/span>&lt;span style="color:#f1fa8c">: &lt;/span>&lt;span style="color:#f1fa8c">$element&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インデックスを簡単に取得できるということは、ループ対象のオブジェクトが持つ全インデックスを取得したい場合に、あえて&lt;code>0&lt;/code>のような、マジックナンバーにありえる数値を指定する必要がないというところでも良いですね。Javaだと毎回、static finalなフィールドとして宣言したり、別の定数として管理したりするケースが多いので…&lt;/p>
&lt;p>他にも、正規表現なしでも文字に関して簡単にチェックできる関数が事前に提供されているとか(&lt;code>Char.isLetter()&lt;/code>や&lt;code>Char.isDigit()&lt;/code>など)、&lt;code>Map&lt;/code>には&lt;code>Pair&lt;/code>で要素を入れることができるとか、iterableなオブジェクトからStream APIのような操作がすぐできるなど、確かにJavaに比べ「悩む必要がない」のが魅力的と思います。まぁ、人によってはこれはデメリットと認識する可能性もあるのでは、といは思いますが…&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>色々とKotlinの特徴・メリットについて述べましたが、こういう自分もまだ実際に業務でKotlinを使っているわけではないので、まだまだ表面的な知識のみに止まっていると思います。しかし、ここで紹介したことだけでも、Kotlinの魅力は感じ取れるのではないかと思います。&lt;/p>
&lt;p>言語自体も魅力的なのですが、他にもKotlinを扱うことで得られるメリットは多いです。例えば、JetBrainsが開発しているので、Intellijとの相性が良いこと。JVM言語でありJavaとの互換性があるので、Javaの発展をそのまま吸収できるということ。NativeやJavaScriptへのコンパイルもできるということ。他の言語も十分魅力的なポイントはありますが、Javaプログラマーであるなら、一度Kotlinに触れてみる価値はあると信じています。皆さんもまだKotlinに触れたことがないのであれば、この度ぜひ軽い気持ちで挑戦してみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Scope Functionはどう使うか</title><link>https://retheviper.github.io/posts/kotlin-scope-function/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-scope-function/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Scope Functionはどう使うか" />&lt;p>KotlinがJavaと区別される特徴といえば色々あるとは思いますが、そのうちの一つとしてあげられるものが&lt;code>Scope Function&lt;/code>ではないかと思います。以前のポストでも簡単に触れたことがありますが、これらのビルトイン関数たちは確かに上手く使うと、Javaより簡潔なコードを書くばかりでなく、より作成者の意図が伝わりやすい、強力な武器になり得るのではないかと思います。しかしながら、やはり他の言語と比べて新しい概念のものであるので、どの場面で使った方が良いか、どう使ったらいいかという、いわゆるBest Practiceがどんなものであるか悩ましくもなりますね。&lt;/p>
&lt;p>おそらくこう思っているのは自分だけでなく、ネットから検索してみるとScope Functionに関しての多くの記事を見つけることができますが、大抵が個別の関数の使い方の紹介に過ぎないような気がしています。なので、具体的にこれらの関数はなんのためのものであり、それぞれどう使い分けるか、またどの場面で使うべきかというのが気になっていたところです。調べてみたところ、公式のドキュメントやいくつかのブログの記事などに情報があったので、これらをまとめて整理してみました。&lt;/p>
&lt;h2 id="そもそもscope-functionって">そもそもScope Functionって？&lt;/h2>
&lt;p>最初にScope Functionを言及しましたが、これは一体なんでしょう。まずはなぜこれらの関数にこんな名前がつけられたのかを知る必要がありそうです。&lt;a class="link" href="https://kotlinlang.org/docs/reference/scope-functions.html" target="_blank" rel="noopener"
>公式の説明&lt;/a>だと、以下のように述べています。&lt;/p>
&lt;blockquote>
&lt;p>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions.&lt;/p>
&lt;/blockquote>
&lt;p>要するに、特定のオブジェクトに範囲(Scope)を限定し、Lambdaで書かれた関数を実行させたい場合に使えるもののようです。もちろん、これは全く新しい形の関数ではありません。形(コードの書き方)としては、オブジェクトの関数を呼び出しているだけのように見えるだけですね。しかし、コードをみてみると、コードブロックで警戒を作ることでより&lt;code>特定のオブジェクト&lt;/code>に限った処理であることが視覚的に、明確になります。例えば、以下のようなコードはどれもやっていることは同じですが、コードも読む側からすると処理を適用させる&lt;code>範囲&lt;/code>は後者の方が明確になりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Scope Functionなしのコード
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> john = Person(&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">20&lt;/span>, &lt;span style="color:#50fa7b">Gender&lt;/span>.Male)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>john.doWarmingUp()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>john.startToRun()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Scope Functionのletを使った場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> john = Person(&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">20&lt;/span>, &lt;span style="color:#50fa7b">Gender&lt;/span>.Male).let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.doWarmingUp()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.startToRun()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="どう違う">どう違う？&lt;/h2>
&lt;p>上述した通り、コードの範囲を限定することで、処理の範囲が明確になるのが分かりました。しかし、これでScope Functionを使う準備は整ったかというと、そうでもないです。実はそれ以外でも考えなければならないところがあるのです。なぜなら、Scope Functionには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" target="_blank" rel="noopener"
>with&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="_blank" rel="noopener"
>let&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="_blank" rel="noopener"
>run&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html" target="_blank" rel="noopener"
>also&lt;/a>の5つの関数が存在するからです。複数の関数が存在していることは、時と場合によって違う関数を選ぶ必要があるということでしょう。&lt;/p>
&lt;p>では、これらの関数は他と何が違うのでしょう。まず、考えられるのは仕様です。Scope Functionは、内部的には渡したLambdaを実行してその結果を返すこととなっています。だとすると、仕様としてはLambdaで扱うオブジェクトと戻り値の差だけとなります。Scope Functionには処理の対象となるオブジェクト(レシーバーと言います)と、Lambdaをまずパラメータとして渡すようになります。ここで渡したレシーバーへのアクセスをどう書くかと、処理後の戻り値がどうなるかがこの5つのScope Functionでそれぞれ違います。これをテーブルとして表すと、以下のようになります。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>関数名&lt;/th>
&lt;th>レシーバーのアクセス&lt;/th>
&lt;th>戻り値&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>with&lt;/td>
&lt;td>this&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>let&lt;/td>
&lt;td>it&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>apply&lt;/td>
&lt;td>this&lt;/td>
&lt;td>T&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>run&lt;/td>
&lt;td>this&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>also&lt;/td>
&lt;td>it&lt;/td>
&lt;td>T&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>また、withを除いた他の4つの関数たちは、&lt;a class="link" href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener"
>Extension Function&lt;/a>でもあるという特徴があります。 Extension Functionは何か？というと、簡単に、既定のクラスに関数を追加することです。Javaだとクラスの継承やラッパークラスの作成、オーバーライドなどで実現できる機能ですが、Kotlinでは簡単に定義できます。&lt;/p>
&lt;p>「Scope FunctionなのにExtension Functionでもあると？」と思うかも知れませんが、理由は簡単です。クラスの作成時に関数として定義してなくても、もともとそのクラスにあったかのように呼べる関数だから、ということです。どのオブジェクトでも、宣言しなくてもwithを除いたScope Functionをあらかじめ宣言しておいたかのように使うことができます。&lt;/p>
&lt;h3 id="参考itとthis">参考：itとthis&lt;/h3>
&lt;p>&lt;code>it&lt;/code>は、パラメータが一つのみのLambdaで使われるものです。例えばJavaだと、パラメータが一つだとしても、&lt;a class="link" href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener"
>Method Reference&lt;/a>を使わない限り以下のように書く必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> names &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;john&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;jack&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Predicateの引数は一つだけだが、
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Optional&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> filtered &lt;span style="color:#ff79c6">=&lt;/span> names&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">filter&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>name &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;john&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">equals&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>name&lt;span style="color:#ff79c6">)).&lt;/span>&lt;span style="color:#50fa7b">findFirst&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは、同じ状況だとパタメータを省略して単純に&lt;code>it&lt;/code>として表現することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> names: List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#f1fa8c">&amp;#34;john&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;jack&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// itでの省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> filtered = names.first { &lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;o&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>結局、&lt;code>this&lt;/code>と同じではないか？と思いがちですが、&lt;code>it&lt;/code>はLambdaのぱらめーたにスコープが限定されて、&lt;code>this&lt;/code>のスコープはローカルでもグローバルでもなれるという点が違います。なぜなら、&lt;code>this&lt;/code>はレシーバーそのものを指していて、パラメータがない場合はLambdaのスコープの外を指すことになるからです。つまり、パラメータのないLambdaではitを使えないですが、thisは使えるということになります。&lt;/p>
&lt;h2 id="いつ使う">いつ使う?&lt;/h2>
&lt;p>では、Scope Functionに5つの関数があり、それぞれどう違うかがわかったので、次はそれぞれをどう使い分けるか知りたいですね。さまざまな意見があったので、(自分の)納得の行くもので整理してみました。&lt;/p>
&lt;h3 id="with">with&lt;/h3>
&lt;p>&lt;code>with&lt;/code>はExtension Functionではないので、オブジェクトをパラメータとして受け取る一般的な関数として使えます。このような特徴があるので、複数のオブジェクトで同じような処理を行う必要があるときに使えます。例えばforループの中で、わざとメソッドを分離したくない(命名がめんどくさいとか…)の場合に使えるでしょう。また、やはりScope Functionなので、処理の範囲を明確に区分するためにも使えそうですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (name &lt;span style="color:#ff79c6">in&lt;/span> names) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with(name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> rev = &lt;span style="color:#ff79c6">this&lt;/span>.reversed()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reversedName.add(rev)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="let">let&lt;/h3>
&lt;p>オブジェクトをトリガーにして、そのオブジェクトを持って何かの処理を行いたい場合に使うものです。&lt;code>let&lt;/code>の意味通り、そのオブジェクトを持って何かをするというイメージですね。また、戻り値も最後の結果となるので、それを持ってまた何かができそうです。また、&lt;a class="link" href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls" target="_blank" rel="noopener"
>Safe Call&lt;/a>な使い方ができるため、Nullではない場合のみの動作として指定することも可能です。なのでNullになり得るオブジェクトでは、&lt;code>let&lt;/code>を使った方が良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> name: String? = &lt;span style="color:#ff79c6">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#ff79c6">?.&lt;/span>let { println(&lt;span style="color:#f1fa8c">&amp;#34;name is not null&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="apply">apply&lt;/h3>
&lt;p>Lambdaでレシーバーの関数を使わず、レシーバーそのものを返却する場合に使います。つまり、レシーバーのプロパティに新しい値を入れる場合のことです。代表的にはオブジェクトの初期化がありますね。もちろん初期化だけなら、コンストラクタを呼ぶだけで十分ではないかと思われますが、同じオブジェクトの値を入れ替える(例えばConfigurationクラスなど)場合に役立つらしいです。例えば以下のような場合を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (devMode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeConfig().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#f1fa8c">&amp;#34;devMode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="run">run&lt;/h3>
&lt;p>他の4つの関数で事足りるので、なるべくこれは使わないように、という話が多いです。確かに、runはノーマルな関数としても使えるので(&lt;code>run {}&lt;/code>)、&lt;code>with&lt;/code>との違いがいまいちわからない感覚ではありますね。あえて使う場合は、オブジェクトの値をオーバーライドする時だそうです。でも、これも&lt;code>let&lt;/code>でできるので、あえて使う必要はなさそうです。多くのケースで、これは推奨されてませんでした。&lt;/p>
&lt;p>ただ、一部ではオブジェクトの初期化として使うと便利と言ってました。確かに&lt;code>this&lt;/code>を使うので、少しながら&lt;code>it&lt;/code>を使う&lt;code>let&lt;/code>よりコードが短くなり得るというメリットはありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// runを使うばあい
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> result1 = server.run {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port = &lt;span style="color:#bd93f9">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;/members:&lt;/span>&lt;span style="color:#f1fa8c">$port&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// letを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> result2 = server.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.port = &lt;span style="color:#bd93f9">8081&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;/members:&lt;/span>&lt;span style="color:#f1fa8c">${it.port}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="also">also&lt;/h3>
&lt;p>オブジェクトがトリガーとなり、そのオブジェクトとは関係のない別の処理を行います。なので、元のオブジェクトがNullであっても、そのオブジェクトが呼ばれた時点でなんらかの処理を行うことができます。これを応用すると、条件分岐(三項演算子)のように使うことも可能です。例えば、こんな感じですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> name: String? = &lt;span style="color:#ff79c6">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#ff79c6">?.&lt;/span>let { println(&lt;span style="color:#f1fa8c">&amp;#34;name is not null&amp;#34;&lt;/span>) } &lt;span style="color:#ff79c6">?:&lt;/span> also { println(&lt;span style="color:#f1fa8c">&amp;#34;name is null&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="まとめ">まとめ&lt;/h3>
&lt;p>&lt;a class="link" href="https://medium.com/@brijesh1794/kotlin-standard-library-let-run-also-apply-with-bb08473d29fd" target="_blank" rel="noopener"
>Kotlin Standard Library (let, run also, apply, with)&lt;/a>では、5つのScope Functionのどれを使うか判断する基準を、フローチャートとして提示しています。以下は、そのフローチャートを簡単に翻訳したものです。どれを使うか悩ましい時は、こういう基準でコードを書いても良さそうですね。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 289;
flex-basis: 694px"
>
&lt;a href="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function.png" data-size="3483x1203">
&lt;img src="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function.png"
width="3483"
height="1203"
srcset="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function_huab2beb07c4d5efa7f99c84d4bdefc40b_237742_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function_huab2beb07c4d5efa7f99c84d4bdefc40b_237742_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Kotlin Select Scope Function">
&lt;/a>
&lt;figcaption>Kotlin Select Scope Function&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="応用">応用&lt;/h2>
&lt;p>Scope Functionが戻り値としてレシーバーそのものを返すというのは、すなわちBuilderパターンとして使えるという意味でもあります。なので、適切な組み合わせで、Scope Functionによるメソッドチェーンもできます。これをよく活用すると、かなり関数型的な感覚でコードを書くことができるでしょう。以下は、その例の一つです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// letの連鎖
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> three: Int = &lt;span style="color:#f1fa8c">&amp;#34; abc &amp;#34;&lt;/span>.let { &lt;span style="color:#ff79c6">it&lt;/span>.trim() }.let { &lt;span style="color:#ff79c6">it&lt;/span>.length }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// alsoの連鎖
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> jack: Person = Person(&lt;span style="color:#f1fa8c">&amp;#34;Jack&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">30&lt;/span>, &lt;span style="color:#50fa7b">Gender&lt;/span>.MALE).also { println(&lt;span style="color:#ff79c6">it&lt;/span>.name) }.also { &lt;span style="color:#ff79c6">it&lt;/span>.doWarmingUp() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>実は、このようなKotlinの機能は、そう新しいものでもありません。なぜなら、同じJVM言語であり、同じく機能する&lt;code>with()&lt;/code>のような関数を提供している&lt;a class="link" href="http://groovy-lang.org" target="_blank" rel="noopener"
>Groovy&lt;/a>があるからです。自分の中では&lt;a class="link" href="http://spockframework.org" target="_blank" rel="noopener"
>Spock&lt;/a>かGradleのイメージしかないのですが…&lt;/p>
&lt;p>ただ、このようにKotlinが提供する機能は「新しくはないけど、快適」という感覚を確かに伝えてくれているような気がします。なのでJavaプログラマーがKotlinに転向していく数も増えているのでしょう。最近は特にPythonやJavaScriptのような言語が人気を得ているところですが(Kotlinは&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE&lt;/a>の順位からだと見えもしないし…)、もっと性能と安定性、そして快適な開発のバランスを持ちたいと思う人にはぜひおすすめしたい言語です。なのでもっと、Kotlinの魅力をより多くの人(自分を含め)にわかった欲しいところです。今回のポストで少しはそれが伝わると幸いですね。&lt;/p>
&lt;p>では、また!&lt;/p></description></item><item><title>JavaプログラマーがみたKotlin</title><link>https://retheviper.github.io/posts/kotlin-first-impression/</link><pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post JavaプログラマーがみたKotlin" />&lt;p>KotlinがAndroidの公式言語になってからもだいぶ長い時間が経ちましたが、まだまだWebアプリケーションの業界ではサーバサイド言語としてはJavaを使う企業も多く(自分の場合がそうです)、モバイル業界でもJavaを使うところが多いようです。Javaも9以降はアジャイル開発でバージョンアップにスピードを出していて、いわゆるモダンな言語の特徴を吸収していってますが、そもそもの言語のデザインが古いし、互換性のために昔ながらの名残を捨てられてないところもあるので根本から違う哲学でデザインされた言語とはかなり違うはずです。また、JVMを利用しない&lt;a class="link" href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener"
>Kotlin Native&lt;/a>も発表されているので、今後Javaよりも活躍できる場面が多いかも知れないなーという気がしたりもします。(&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>は使われることあるのかな…)&lt;/p>
&lt;p>取りまとめ、まだ正式の研修とかを受けたわけでなく、あくまでSpring WebFluxを使って簡単なアプリを作ってみるついでに使ってみただけなので、よくわかってない部分も多いかと思いますが、今まで触れてみた感想をJavaプログラマーの観点から簡単に紹介したいと思います。&lt;/p>
&lt;h2 id="これがよかった">これがよかった&lt;/h2>
&lt;p>まずは使ってみてよかったところから。結論からとなりますが、良いと思ったところはおおよそイメージ通り(期待してた通り)という感覚です。&lt;/p>
&lt;h3 id="やはりモダンな感じ">やはりモダンな感じ&lt;/h3>
&lt;p>Kotlinで書いたコードを見ると、モダンな言語だとやはりこんなものかなという感覚ではあります。モダンな言語が何か、という定義から必要になるのではという気もしますが、例えばSwift、Kotlin、Goみたいなものですね。あまり他の言語に詳しいわけではないのですが、これらの言語はなんとなくPythonに似ているような気がします。例えば&lt;code>var&lt;/code>、&lt;code>fun&lt;/code>のように基本文法で略語をよく使っていたり、型の指定はコロンの後につけたり、セミコロンがなかったり、&lt;code>in&lt;/code>や&lt;code>Range&lt;/code>、&lt;code>is&lt;/code>があるなどの共通点があったりしますので。他には、言語の使用ではないけど、一般的にはGetter/Setterを使わずフィールドに直接アクセスするところですかね。(おかげでLombokを使う必要がないのも便利ではあります)&lt;/p>
&lt;p>ただ、そんなモダンな感覚でありながらも、やはりKotlinはJavaよりな感覚ではあります。厳格なJavaをよりゆるくしただけの感覚といえばいいでしょうか。例えばPythonだと&lt;code>elif&lt;/code>なのですが、Kotlinでは&lt;code>else if&lt;/code>だったりしますので。JVM言語という理由だけでなく、基本文法からしてもJavaプログラマーならすぐに適応できる言語でもあります。例えばforループにラベルをつけることができたりします。&lt;/p>
&lt;p>あえてJavaとの比較をするとしたら、やはり冗長さを省けただけでなく、Javaという言語のデザインを根本的に変えようとしている気もしていました。例えばNullや、Mutableを扱う方式がそうです。Kotlinでは基本的に変数はNullになれなくて、Nullになれるオブジェクトは最初からそうであると宣言する必要があり、Nullになれるオブジェクトを扱う時もSafe Callを強制することでNullに対してはコンパイラレベルではできるだけサポートしている感覚です(おそらくこれはモダンな言語だと全部がそうですが)。そしてCollectionなどを宣言する時も、あえてMutableという宣言をしない限りは基本的にImmutableなオブジェクトが生成されます。これだけでもJavaでもっともよく見つかるNPEをよく避けられる気がしてしまいます。いちいち宣言して、コールもクエスチョンマークをつける必要があるのは面倒臭いことな気もしますが、コンパイルエラーの方がランタイムエラーよりはずっとマシだというのは我々みんなが知っていることではないでしょうか。&lt;/p>
&lt;p>あとは、個人的にPythonで使ってみてよかったなと思った機能がKotlinにもあってよかったです。例えばMultiple Return(複数の戻り値)だったり、Named argument(名前付き引数)があります。前者は特に、Pair/Tripleという型で明確な戻り値を提示できるのが素晴らしいと思います。こういうところはモダンながらも、Javaの持つ安定性もしくは丈夫さを捨ててなかったなという印象を与えてくれました。&lt;/p>
&lt;p>ただ、これらのメリットは最近のJavaもかなり近づいている状態ではあります。(まだ少し遅い感はありますが)&lt;/p>
&lt;h3 id="クラスファイルではない">クラス=ファイルではない&lt;/h3>
&lt;p>Javaの場合は、一つのファイルには一つのクラスというのが常識のようになっています。もちろんInner Classを書く場合もありますが、それだと名前とおりクラスの中に含まれたものになるので、インスタンスを生成するときに複雑だったりしますね。でもKotlinだと、純粋なクラスを一つのファイルに複数書くことができます。&lt;/p>
&lt;p>なので、似たようなクラスを一つのファイルの中に集めておくことができますね。例えばDTO、DAO、Entityなど似たようなクラスが複数損際するパターンでは、一つのファイルの中にそれらを集めておいた方がパッケージの中が複雑にならないような気がします。実際、Kotlinを試しながら好みの領域の話かも知れませんが。&lt;/p>
&lt;p>どちらかを選択できる自由があるというのが、必ずしも良いこととは言い切れませんが、ファイル内にクラスを複数書くかどうかはキメの問題であって実装時のコーディングスタイルに影響を与えるものではないので(今時importを直接書く人もいないだろうし…)、良い点として挙げられるのではないか、と思います。&lt;/p>
&lt;h3 id="拡張関数で自由に関数を追加できる">拡張関数で自由に関数を追加できる&lt;/h3>
&lt;p>Javaのデメリットとしてよく挙げられているのが、冗長すぎる(verbose)ということです。いわゆるBoilerplateなコードを毎回書かなくてはならないというのは、生産性の面からもよくないです。Javaにこういう面があるので、さまざまなデザインパターンが発達したり、IDEでコードを自動生成してくれたり、Lombokのようにコードの量を減らしてくれるライブラリが人気だったりしますね。自分が開発に参加したフレームワークの開発の案件も、結局は冗長化するコードを減らしたいという目的によるものでした。&lt;/p>
&lt;p>とにかく、Kotlinはこういう問題に対する反発ないしは反省から言語がデザインされているようにも見えます。最近のモダンな言語の特徴をコピーしただけでなく、Javaを改善させたいという強い意志が言語のデザインから感じ取れているような感覚でした。&lt;/p>
&lt;h3 id="スタンダードライブラリがとにかく便利">スタンダードライブラリがとにかく便利&lt;/h3>
&lt;p>拡張関数が便利な理由ともつながるようなことですが、Kotlinのスタンダードライブラリに存在する関数たちもまた同じ観点から便利といえます。例えば、すでに有名なのがいわゆる&lt;code>Scope Functions&lt;/code>の&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="_blank" rel="noopener"
>let&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" target="_blank" rel="noopener"
>with&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="_blank" rel="noopener"
>run&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html" target="_blank" rel="noopener"
>also&lt;/a>のような関数です。&lt;/p>
&lt;p>これらはJavaだと別途ユーティリティクラスを作るか、プライペートなメソッドを定義するか、特定のクラスを継承してからオーバライドで関数を新しく定義するなどの方法で対応はできるものの、やはり手間がかかるのでやりたくはないものです。これをKotlinでは、より関数型的な方法で解決してくれます。例えばletの例を見ていきましょう。以下のようなdata classがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Member&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> region: String, &lt;span style="color:#ff79c6">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このdata classのインスタンスを一つ作成します。そうすると以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> john = Member(&lt;span style="color:#f1fa8c">&amp;#34;Tokyo&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとで、同じくMemberのインスタンスとしてjakeという変数を追加するとします。jakeは常にjohnと同じregionである必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> jake = Member(&lt;span style="color:#f1fa8c">&amp;#34;Tokyo&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをJavaの考え方で、コードを整理するとしたら以下のようになります。regionを同じインスタンスを使うようにすることですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> tokyo = &lt;span style="color:#f1fa8c">&amp;#34;Tokyo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> john = Member(tokyo, &lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> jake = Member(tokyo, &lt;span style="color:#f1fa8c">&amp;#34;Jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをletを使う場合のコードとして書くと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> jake = john.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Member(&lt;span style="color:#ff79c6">it&lt;/span>.region, &lt;span style="color:#f1fa8c">&amp;#34;jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>共通のregionを別途変数として宣言したくても、jakeのregionはjohnに指定したregionと同じ値となります。そしてある意味、こちらの方が「johnとjakeは同じregionを共有する」という意図がコードの中によく表れているのではないか、という気もします。今は簡単なフィールドを共有しているだけですが、変数の数が増えたり処理すべき項目が多くなった場合はいちいち定数を宣言するよりも、このような書き方の方がより優雅になるのではないか、と思います。そういう意味では、かなり洗練された方法を提供していますね。同じことをJavaでまねるとしたら…あまりやりたくなくなりそうです。&lt;/p>
&lt;h2 id="これはいまいち">これはいまいち&lt;/h2>
&lt;p>KotlinがJavaのさまざまな問題や不便さに注目し、それらの多くを解消してくれたのは事実ですが、果たして&lt;code>全て&lt;/code>Javaより発展しているか、というとそうでもないような気もします。ただし、ここであげているKotlinの問題点ないしデメリットは、メリットと同様、個人的な見解なので参考までに。&lt;/p>
&lt;h3 id="varと型">varと型&lt;/h3>
&lt;p>モダンな言語から接した人なら、変数の宣言が&lt;code>var&lt;/code>だけで集結するのはメリットと言いたくなるかも知れません。実際Kotlinだけでなく、JavaScriptやC#など現代に使われる大体の言語は&lt;code>var&lt;/code>に対応していて、あのJavaすらも10から&lt;code>var&lt;/code>による変数の表記を導入しています。また、Pythonのようにそもそも&lt;code>var&lt;/code>の宣言すらいらない言語があったりもしますね。&lt;code>var&lt;/code>をつけることで変数であることが明確だという考え方から来てるのか、Javaとは違って関数も&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88" target="_blank" rel="noopener"
>First Class Object&lt;/a>として扱う言語としては関数と同様に表記したいからそうしてるのか、よくわかってないのですが、どっちかというと流行りのもののようです。&lt;/p>
&lt;p>こういう傾向だけを見ると、「変数は変数であることが分かればいい」というだけの話になっているようにも思えます。しかし、私はこの&lt;code>var&lt;/code>が果たして良いものであるかという疑問を持っています。Javaに慣れすぎていて、新しいのを受け入れられてない、もしくは&lt;code>var&lt;/code>の良さをわかってないだけかも知れませんが、とにかく「型指定で変数であることも、型もわかるからこっちの方が良くないか」と思ってしまいます。&lt;/p>
&lt;p>こう思うまたの理由は、モダンなプログラミング言語の中でもTypeScriptのように、あえて型指定ができるように既存の言語を変えようとする動きもあるからです。Pythonの場合も3.6から型を宣言できるようになっています。これ自体が、「変数は変数であることが分かればいい」から「変数の型もわかった方がいい」に変わっているように見えます。ただ、問題は最初から型指定で変数を指定する方法がなく、&lt;code>var&lt;/code>しかない言語に型指定(型注釈)が付く場合です。&lt;code>var&lt;/code>のメリットである短くかけるというところが、型指定をすることで台無しになります。&lt;/p>
&lt;p>例えば、Kotlinでの&lt;code>var&lt;/code>だけの宣言だと以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> a = &lt;span style="color:#f1fa8c">&amp;#34;this is string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして&lt;code>var&lt;/code>に型を指定すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> b: String = &lt;span style="color:#f1fa8c">&amp;#34;this is string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの伝統的な書き方だと以下です。こちらの方が、むしろコードは短くなるし、変数であることも明確ではないでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;this is string&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、厳密にいうと変数ではないところでは&lt;code>var&lt;/code>をつけないのは当たり前なのかも知れませんが、Javaだと変数でも戻り値でも引数でも型をつけてしまうのに対して、Kotlinではこれらに&lt;code>var&lt;/code>をつけるか型をつけるか方が省略できるかという場面がそれぞれ区別されてしまうので、これだけはJavaよりも厳格じゃないか？という気になったりもします。例えば以下のような例です。&lt;/p>
&lt;p>関数の引数の場合は、型の指定が必要です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#ff79c6">it&lt;/span>.username, &lt;span style="color:#ff79c6">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして関数の戻り値は、型推論により省略可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>(request: ServerRequest) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#ff79c6">it&lt;/span>.username, &lt;span style="color:#ff79c6">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これはあくまで関数をSingle Expressionで書いた時の話です。明示的にreturnを書く場合は戻り値を省略するとコンパイルエラーになります。例えば以下のような場合がそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// これはコンパイルエラー(戻り値はUnitとなってしまう)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>(request: ServerRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#50fa7b">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#ff79c6">it&lt;/span>.username, &lt;span style="color:#ff79c6">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、data classの場合はフィールドに&lt;code>val&lt;/code>か&lt;code>var&lt;/code>をつける必要があります。しかし、一般的なクラスを宣言する場合は要りません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// data classではvalかvarが必要
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MemberDto&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> username: String, &lt;span style="color:#ff79c6">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// classなら必要ない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MemberEntity&lt;/span>(username: String, name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通常はコンパイルエラーになるので、慣れるまではKotlinのルールに従ってコードを見直すしかないのですが、Javaからの入門だとかなり混乱する部分です。(自分だけかも知れませんが…)&lt;/p>
&lt;h3 id="依存関係">依存関係&lt;/h3>
&lt;p>プロジェクトにKotlinを使う場合はスタンダードライブラリを追加して使う必要があります。ただ、ここで&lt;code>kotlin-stdlib&lt;/code>だけを追加すると、Java 1.7以降に追加された一部の機能(AutoCloseableなど)を使えなくなります。なので、Java 1.7以降の機能を使いたい場合は&lt;code>kotlin-stdlib-jdk7&lt;/code>か&lt;code>kotlin-stdlib-jdk8&lt;/code>を依存関係に追加する必要があります。&lt;/p>
&lt;p>個人的にはOracleとGoogleの訴訟沙汰のようなことがあって、わざと著作権を避けるための独自のパッケージを作ったりしらからではないかなと思いましたが、実際はJava 9から導入されたModuleシステムに対応するための理由だそうです。なので&lt;code>kotlin-stdlib-jre7&lt;/code>が&lt;code>kotlin-stdlib-jdk7&lt;/code>に、&lt;code>kotlin-stdlib-jre8&lt;/code>が&lt;code>kotlin-stdlib-jdk8&lt;/code>に代替されたらしいですね。&lt;/p>
&lt;p>とにかく、これらのスタンダードライブラリを使うには、MavenやGradleのような依存関係を管理するパッケージマネージャを使って一回だけ登録しておけばよく、そこまでめんどくさくはないことなのかも知れませんが、例えば&lt;code>kotlin-stdlib-jre8&lt;/code>があったりするので、初めはどれを選べば良いか、どれが必要であるかを把握するのにも時間を使ってしまうことになるのでデメリットになるのではないかと思います。例えば&lt;code>kotlin-stdlib-jdk7&lt;/code>がなくても、AutoCloseable以外のJDK 1.7の機能は使えたりするのですが、今から作るプロジェクトや既存のプロジェクトにAutoCloseableが使われるかどうかで依存関係をまた追加するかどうかを調べるのもかなり面倒くさそうです。&lt;/p>
&lt;p>そしてJDK7やJDK8対応のスタンダードライブラリが別途存在するということは、今後JavaがバージョンアップしたらまたJDK 17などの新しいスタンダードライブラリが追加される可能性があるということでもあるでしょう。7(1.7)と17はよく勘違いしそうだし…あと、JDK以外の依存関係のパッケージが色々あるので(&lt;code>kotlin-reflect&lt;/code>など)、プロジェクトの構成によってはKotlinの導入にはかなり慎重になる必要がありそうです。ある意味、KotlinがPost Javaとしてのポテンシャルは十分でありながらも、Androidアプリの作成以外にではあまり導入されてないのはこのような理由もあるのではないかという気もしています。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>簡単にPros・Consに分けて自分が感じたKotlinに対して書いてみました。実はまだ本格的な案件で触れてみたわけでもないので、&lt;a class="link" href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="noopener"
>Type aliases&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/docs/reference/inline-classes.html" target="_blank" rel="noopener"
>inline class&lt;/a>のような良さそうな機能に触れてもないです。でもやはり、使えば使うほど魅力的な言語であるなと感じているところです。なので個人的な意見としては、すでにJavaを使っているところなら本格的にKotlinへの移行を考慮しても良いのでは、と思っています。Javaプログラマーなら慣れやすく、より生産性も高いながら、Javaとの100%の互換性も担保されているので…言語の完成度やJVM対応でありながらNative、JavaScriptとの連動も可能なのを見るとまさにPost Javaとして相応しい言語なのではないかと思うくらいです。(他のJVM言語には悪いですが…)&lt;/p>
&lt;p>そういう意味で皆さん、今からでもKotlinやりませんか！&lt;/p></description></item></channel></rss>