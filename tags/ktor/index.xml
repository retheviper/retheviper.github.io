<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ktor on Korean-man in Tokyo</title><link>https://retheviper.github.io/tags/ktor/</link><description>Recent content in Ktor on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 30 Mar 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/tags/ktor/index.xml" rel="self" type="application/rss+xml"/><item><title>動的画像リサイズAPIを作る</title><link>https://retheviper.github.io/posts/image-resize-api/</link><pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/image-resize-api/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.webp" alt="Featured image of post 動的画像リサイズAPIを作る" />&lt;p>この度は、動的画像リサイズのAPIを作りましたのでその紹介です。ここでおいう動的画像リサイズAPIとは、元の画像のURLとリサイズしたいサイズを指定すると、そのサイズにリサイズした画像を返すAPIです。&lt;/p>
&lt;h2 id="目的">目的
&lt;/h2>&lt;p>そもそも動的画像リサイズAPIを作る理由はなにか。それから説明しないとですね。今までは画像の配信において、エンドユーザが画像をアップロードする場合、あらかじめサムネイルの画像も作成してアップロードするようにしていました。&lt;/p>
&lt;p>ただ、その方法だと全ての画面比と解像度に対応したサムネイルを作れないという問題があります。そのため代案として、フロントエンドから画面に最適化したサイズを指定して、APIからリサイズした画像を取得するようにしたいというのが目的です。&lt;/p>
&lt;h2 id="設計技術選定">設計・技術選定
&lt;/h2>&lt;p>APIはマイクロサービスとして、なるべくシンプルに作ることにしました。Getのエンドポイントを一つ持っていて、そこにクエリパラメータで元の画像のURLとリサイズしたいサイズを指定すると、リサイズした画像を返すというものです。フロントエンドではそのままimgタグに使えるようにしたいので、返すのは画像のデータそのまま（ヘッダーには&lt;code>Content-type&lt;/code>を指定）にします。また、リサイズだけでなく、画像の形式を変換することもできるようにします。&lt;/p>
&lt;p>また、APIは&lt;a class="link" href="https://cloud.google.com/run?hl=ja" target="_blank" rel="noopener"
>Cloud Run&lt;/a>上で動かすことにしました。既存のAPIもそうなので使い方を合わせるためでもあり、ローカルでの開発でもdocekr composeを使って楽に開発できるためです。他にもコンテンツの配信には&lt;a class="link" href="https://cloud.google.com/storage?hl=ja" target="_blank" rel="noopener"
>Cloud Storage&lt;/a>を使っているので、それとの連携もしやすいためです。そして最終的に処理された画像は、Cloud CDNに保存され、2回目以降の呼び出しではキャッシュを返すようにします。&lt;/p>
&lt;p>会社ではすでにウェブフレームワークとしてKtorを採用しているので、それと揃えるためにこちらもKtorを採用。Ktorの以前ににNode.jsとRustによる実装を試みたことがありますが、前者は性能の問題から、後者はメンテが難しくなる問題から（社内にRustができる人が少ないので）採用しない方になっています。当時作成していたRustバージョンに近いサンプルコードはGitHubにて公開していますので、&lt;a class="link" href="https://github.com/retheviper/resize-api" target="_blank" rel="noopener"
>こちら&lt;/a>から確認できます。&lt;/p>
&lt;p>画像の変換とリサイズのためには&lt;a class="link" href="https://github.com/sksamuel/scrimage" target="_blank" rel="noopener"
>Scrimage&lt;/a>を採用することにしました。他の候補としてはJavaの&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/javax/imageio/ImageIO.html" target="_blank" rel="noopener"
>ImageIO&lt;/a>なども検討しました。ただ、リサイズ対象の画像のフォーマットと、返すデータのフォーマットとしてWebPを処理する必要があったのですがそれに対応していないものが多かったです。&lt;/p>
&lt;p>他に考えたものとしては、&lt;a class="link" href="http://www.graphicsmagick.org/" target="_blank" rel="noopener"
>GraphicsMagick&lt;/a>のように画像の変換やリサイズを行うツールを使う方法もあります。こちらの場合はJavaから取得したデータを一度ファイルに書き出して、それをコマンドラインで実行するという方法になりますので、その分のI/Oコストがかかるため今回はScrimageを使うことにしました。&lt;/p>
&lt;h2 id="リサイズ処理">リサイズ処理
&lt;/h2>&lt;p>では、実際のAPIを書いていきます。Ktorは使い慣れているのもあり、今回はKtorでのAPI構築というよりはScrimageを使った画像のリサイズ処理が重要なので、その部分に焦点を当てていきます。&lt;/p>
&lt;p>API全体で処理のフローは大まかに以下の通りです。&lt;/p>
&lt;ol>
&lt;li>クエリパラメータからurlとリサイズ後の大きさを取得&lt;/li>
&lt;li>画像の取得&lt;/li>
&lt;li>画像のリサイズ&lt;/li>
&lt;li>画像の形式変換&lt;/li>
&lt;/ol>
&lt;p>ここでScrimageを使った画像の処理は3〜4の部分ですが、実際のリサイズを行う前に取得した画像の形式をまず判定したり、画像のサイズを確認する必要もあります。理由としては処理の効率化のためですね。&lt;/p>
&lt;p>今回はPNG, JPEG, WEBP, GIFの4つの形式に対して、リサイズ後にWEBPに変換するという処理を行うことにしています。ここで元の画像がWEBPだった場合、あえてWEBPに変換する必要はないです。また、リサイズが必要ない場合もあります。そのため、まずは画像の形式を判定して、リサイズが必要な場合のみリサイズ処理を行うようにします。&lt;/p>
&lt;h3 id="画像の形式判定">画像の形式判定
&lt;/h3>&lt;p>URLもしくはローカルストレージ（今回はCloud RunにCloud Storageをマウントする形で使っている）から画像を取得する際、その画像の形式を判定する必要があります。Scrimageでは画像の形式を判定するための&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/format/FormatDetector.java" target="_blank" rel="noopener"
>FormatDetector&lt;/a>というクラスを提供しています。&lt;/p>
&lt;p>使い方は簡単で、以下のように読み込んだ画像のデータをByteの配列で渡すだけです。API上では想定してないフォーマットが来た場合はエラーを返すようにしていて、ここで返す&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/format/Format.java" target="_blank" rel="noopener"
>Format&lt;/a>はPNG, GIF, JPEG, WEBPでありScrimageのものをそのまま使っています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">detectImageFormat&lt;/span>(&lt;span style="color:#66d9ef">data&lt;/span>: ByteArray): Format {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">FormatDetector&lt;/span>.detect(&lt;span style="color:#66d9ef">data&lt;/span>).orElseThrow { IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;Unsupported format&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="png-jpegの処理">PNG, JPEGの処理
&lt;/h3>&lt;p>まず一番簡単なPNG, JPEGの場合です。これらの形式の場合、Scrimageの&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/ImmutableImage.java" target="_blank" rel="noopener"
>ImmutableImage&lt;/a>として扱うことになります。&lt;/p>
&lt;p>ここで画像のデータをImmutableImageに変換するには&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/nio/ImageReader.java" target="_blank" rel="noopener"
>ImageReader&lt;/a>のインタフェースを実装したクラスを使います。&lt;a class="link" href="https://sksamuel.github.io/scrimage/" target="_blank" rel="noopener"
>公式サイト&lt;/a>では&lt;code>ImmutableImage.loader()&lt;/code>で形式に関係なく画像を読み込むことができると書いてありますが、実際にAPIをビルドする際はAWT関連のエラーが出るので、形式に応じて読み込むクラスを変える必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asImmutableImage&lt;/span>(rawData: ByteArray): ImmutableImage {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ImageIOReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ImmutableImageに変換したら、リサイズ処理を行います。Scrimageではリサイズのためのメソッドが用意されているので、それを使ってリサイズを行います。&lt;/p>
&lt;p>ここで注意すべきは、&lt;code>resize()&lt;/code>や&lt;code>resizeTo()&lt;/code>のようなメソッドがあるのですが、前者の場合はパーセントでのリサイズ、後者の場合は指定したサイズにリサイズするという違いがあります。これらの場合、元の画像のアスペクト比が保持されないため、&lt;code>scaleTo()&lt;/code>や&lt;code>scaleToWidth()&lt;/code>などのメソッドを使う必要があります。&lt;/p>
&lt;p>今回はwidthのみを指定してアスペクト比を保持したままリサイズするため、&lt;code>scaleToWidth()&lt;/code>を使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeImmutableImage&lt;/span>(image: ImmutableImage, width: Int): ImmutableImage {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image.scaleToWidth(width)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後に、リサイズした結果をByteArrayとして返すためのメソッドを用意します。どの形式に変換するかによって&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/nio/ImageWriter.java" target="_blank" rel="noopener"
>ImageWriter&lt;/a>を実装するクラスを選ぶ必要があります。今回はWEBPにしたいので、&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-webp/src/main/java/com/sksamuel/scrimage/webp/WebpWriter.java" target="_blank" rel="noopener"
>WebpWriter&lt;/a>を使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">encodeImage&lt;/span>(image: ImmutableImage): ByteArray {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image.bytes(&lt;span style="color:#a6e22e">WebpWriter&lt;/span>.DEFAULT)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後にRouterでは、Content-Typeを指定してByteArrayを返すようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>call.respondBytes(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bytes = resizedImage,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> contentType = ContentType(&lt;span style="color:#e6db74">&amp;#34;image&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;webp&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="webpの場合">WEBPの場合
&lt;/h3>&lt;p>WEBPの場合は、上記データ読み込む時点で&lt;code>WebpImageReader&lt;/code>を使う必要があります。その後のリサイズ処理はPNG, JPEGの場合と同じです。&lt;/p>
&lt;p>ただ、形式がWEBPの場合には&lt;a class="link" href="https://github.com/sksamuel/scrimage/tree/master/scrimage-webp" target="_blank" rel="noopener"
>scrimage-webp&lt;/a>が提供している&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-webp/src/main/java/com/sksamuel/scrimage/webp/WebpImageReader.java" target="_blank" rel="noopener"
>WebpImageReader&lt;/a>を使う必要があります。なので、形式に応じて読み込むクラスを変える必要があります。先ほどの&lt;code>asImmutableImage&lt;/code>の引数に形式を追加して、形式に応じて読み込むクラスを変えるようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asImmutableImage&lt;/span>(rawData: ByteArray, format: Format): ImmutableImage {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (format) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.WEBP &lt;span style="color:#f92672">-&amp;gt;&lt;/span> WebpImageReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.GIF, &lt;span style="color:#a6e22e">Format&lt;/span>.PNG, &lt;span style="color:#a6e22e">Format&lt;/span>.JPEG &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ImageIOReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他の処理はPNG, JPEGの場合と同じです。&lt;/p>
&lt;h3 id="gifの場合">GIFの場合
&lt;/h3>&lt;p>GIFの場合は、&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/nio/AnimatedGif.java" target="_blank" rel="noopener"
>AnimatedGif&lt;/a>というクラスを使ってリサイズを行います。ImmutableImageと同じようにリサイズメソッドが用意されているので、それを使ってリサイズを行います。処理で使われるクラスが違うので、GIFの場合は別途メソッドを用意します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asAnimatedGif&lt;/span>(rawData: ByteArray): AnimatedGif {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">AnimatedGifReader&lt;/span>.read(&lt;span style="color:#a6e22e">ImageSource&lt;/span>.of(rawData))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、AnimatedGifの場合はframesというプロパティで各フレームのデータを保持していて、これらはImmutableImageとして扱うことができます。そのため、リサイズ処理は各フレームに対して行い、それをAnimatedGifに戻すという処理を行います。若干複雑ですが、以下のように書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeAnimatedGif&lt;/span>(gif: AnimatedGif, width: Int): AnimatedGif {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> resizedData = ByteArrayOutputStream().use {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StreamingGifWriter().prepareStream(&lt;span style="color:#66d9ef">it&lt;/span>, &lt;span style="color:#a6e22e">BufferedImage&lt;/span>.TYPE_INT_ARGB).use { stream &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gif.frames.mapIndexed { index, image &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stream.writeFrame(image.scaleToWidth(width), gif.getDelay(index))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.toByteArray()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">AnimatedGifReader&lt;/span>.read(&lt;span style="color:#a6e22e">ImageSource&lt;/span>.of(resizedData))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後に、リサイズした結果をByteArrayとして返すためのメソッドを用意します。基本的にはImmutableImageと同じですが、GIFをWEBPに変換する場合は&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-webp/src/main/java/com/sksamuel/scrimage/webp/Gif2WebpWriter.java" target="_blank" rel="noopener"
>Gif2WebpWriter&lt;/a>を使います。これでWEBPに変換後も、GIFのアニメーションが保持されたままリサイズすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">encodeGif&lt;/span>(gif: AnimatedGif): ByteArray {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> gif.bytes(Gif2WebpWriter.DEFAULT)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="処理を共通化する">処理を共通化する
&lt;/h2>&lt;p>ここまででPNG, JPEG, WEBP, GIFの4つの形式に対してリサイズ処理を行うことができました。ただ、それぞれの形式に対して処理を書いていると、処理が重複してしまうため、共通化する必要があります。特にImmutableImageとAnimatedGifの処理は似ているため、それらを共通化することにします。&lt;/p>
&lt;h3 id="共通interfaceを作る">共通Interfaceを作る
&lt;/h3>&lt;p>ScrimageではImmutableImageとAnimatedGifは別のクラスであるだけでなく、共通のInterfaceを持っていないため、まずはそれを作成する必要があります。ここでは、ImageというInterfaceを作成し、それを実装するクラスを作成します。それぞれのクラスはWrapperとして作成し、それぞれのクラスのプロパティをInterfaceのプロパティとして持つようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Image&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> width: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AnimatedGifWrapper&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> animatedGif: AnimatedGif
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> width: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = animatedGif.frames.first().width
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ImmutableImageWrapper&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> immutableImage: ImmutableImage
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> width: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = immutableImage.width
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="画像取得の共通化">画像取得の共通化
&lt;/h3>&lt;p>あとは外部に公開するAPIとして、&lt;code>asImage&lt;/code>というメソッドを作成し、それぞれの形式に応じてWrapperを返すようにします。ここで、形式の判定は先ほど作成した&lt;code>detectImageFormat&lt;/code>を使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asImage&lt;/span>(rawData: ByteArray): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">val&lt;/span> format = detectImageFormat(rawData)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.GIF &lt;span style="color:#f92672">-&amp;gt;&lt;/span> asAnimatedGifWrapper(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.WEBP, &lt;span style="color:#a6e22e">Format&lt;/span>.PNG, &lt;span style="color:#a6e22e">Format&lt;/span>.JPEG &lt;span style="color:#f92672">-&amp;gt;&lt;/span> asImmutableImageWrapper(rawData, format)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asAnimatedGifWrapper&lt;/span>(rawData: ByteArray): AnimatedGifWrapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> gif = &lt;span style="color:#a6e22e">AnimatedGifReader&lt;/span>.read(&lt;span style="color:#a6e22e">ImageSource&lt;/span>.of(rawData))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> AnimatedGifWrapper(gif)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asImmutableImageWrapper&lt;/span>(rawData: ByteArray, format: Format): ImmutableImageWrapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> image = &lt;span style="color:#66d9ef">when&lt;/span> (format) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.WEBP &lt;span style="color:#f92672">-&amp;gt;&lt;/span> WebpImageReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.GIF, &lt;span style="color:#a6e22e">Format&lt;/span>.PNG, &lt;span style="color:#a6e22e">Format&lt;/span>.JPEG &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ImageIOReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ImmutableImageWrapper(image)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="リサイズ処理の共通化">リサイズ処理の共通化
&lt;/h3>&lt;p>同じく、リサイズ処理も共通化します。ここでは、&lt;code>resizeImage&lt;/code>というメソッドを作成し、それぞれの形式に応じてリサイズ処理を行うようにします。ここで、リサイズ処理は先ほど作成した&lt;code>resizeImmutableImage&lt;/code>と&lt;code>resizeAnimatedGif&lt;/code>を使います。AnimatedGifのリサイズ処理はまた別途&lt;code>writeAnimatedGif&lt;/code>というメソッドを作成して分けています。&lt;/p>
&lt;p>ここでImageはsealed interfaceとして作成しているため、分岐処理はwhen式を使って網羅することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeImage&lt;/span>(image: Image, width: Int): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (image) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> AnimatedGifWrapper &lt;span style="color:#f92672">-&amp;gt;&lt;/span> resizeAnimatedGif(image, width)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> ImmutableImageWrapper &lt;span style="color:#f92672">-&amp;gt;&lt;/span> resizeImmutableImage(image, width)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeAnimatedGif&lt;/span>(gifWrapper: AnimatedGifWrapper, width: Int): AnimatedGifWrapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> gif = gifWrapper.animatedGif
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> resizedData = writeAnimatedGif { stream &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gif.frames.mapIndexed { index, image &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stream.writeFrame(image.scaleToWidth(width), gif.getDelay(index))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> resizedGif = &lt;span style="color:#a6e22e">AnimatedGifReader&lt;/span>.read(&lt;span style="color:#a6e22e">ImageSource&lt;/span>.of(resizedData))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> AnimatedGifWrapper(resizedGif, resizedData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">writeAnimatedGif&lt;/span>(writeFunction: (&lt;span style="color:#a6e22e">StreamingGifWriter&lt;/span>.GifStream) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit): ByteArray {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StreamingGifWriter().use {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> streamingGifWriter.prepareStream(&lt;span style="color:#66d9ef">it&lt;/span>, &lt;span style="color:#a6e22e">BufferedImage&lt;/span>.TYPE_INT_ARGB).use { stream &lt;span style="color:#f92672">-&amp;gt;&lt;/span> writeFunction(stream) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.toByteArray()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeImmutableImage&lt;/span>(imageWrapper: ImmutableImageWrapper, width: Int): ImmutableImageWrapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> resizedImage = imageWrapper.immutableImage.scaleToWidth(width)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ImmutableImageWrapper(resizedImage, imageWrapper.format)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="画像のエンコード処理の共通化">画像のエンコード処理の共通化
&lt;/h3>&lt;p>最後に、画像のエンコード処理も共通化します。ここでは、&lt;code>encodeImage&lt;/code>というメソッドを作成し、それぞれの形式に応じてエンコード処理を行うようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">encodeImage&lt;/span>(image: Image): ByteArray {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (image) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> AnimatedGifWrapper &lt;span style="color:#f92672">-&amp;gt;&lt;/span> image.animatedGif.bytes(Gif2WebpWriter.DEFAULT)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> ImmutableImageWrapper &lt;span style="color:#f92672">-&amp;gt;&lt;/span> image.immutableImage.bytes(&lt;span style="color:#a6e22e">WebpWriter&lt;/span>.DEFAULT)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで共通化も終わり、呼び出す側は&lt;code>asImage&lt;/code>, &lt;code>resizeImage&lt;/code>, &lt;code>encodeImage&lt;/code>の3つのメソッドを使うだけでリサイズ処理を行うことができます。サイズのチェックもImageの方でプロパティ化しているため、それを使ってリサイズが必要かどうかの判定も行うことができます。&lt;/p>
&lt;p>あとはImageWriterなど、毎回インスタンスを生成する必要のないクラスは、シングルトンとして作成しておくとよいでしょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>だいぶ長くなってしまいましたが、ここまでで動的画像リサイズAPIの作成方法を紹介しました。Scrimageを使うことで、PNG, JPEG, WEBP, GIFの4つの形式に対してリサイズ処理を行うことができ、共通化することで処理の重複を防ぐことができました。&lt;/p>
&lt;p>あとは、Cloud Run上で動かすためのDockerfileを作成し、Cloud Storageとの連携を行うことで、画像の配信を行うことができます。また、Cloud CDNを使うことで、2回目以降の呼び出しではキャッシュを返すようにすることで、負荷を軽減することができます。なかなか面白いプロジェクトでした。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Path ParameterをInline classで受け取る</title><link>https://retheviper.github.io/posts/ktor-path-parameter-as-inline/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ktor-path-parameter-as-inline/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.webp" alt="Featured image of post Path ParameterをInline classで受け取る" />&lt;p>最近はサイドプロジェクトとしてシンプルなWebアプリケーションを作っていて、サーバサイドのフレームワークではKtorを採用しています。今まではずっとSpringを触ってきたので、たまにはこうやって違うフレームワークで何か作ってみるのも楽しいですね。&lt;/p>
&lt;p>さて、そこで今回の記事のテーマとなるのが、KtorでPath Parameterを受け取りInline Classとして扱う方法についてです。高度な技術を要するものではないのですが、より型安全で便利に使えるコードが書ける方法ではないかと思い試したことの紹介となります。&lt;/p>
&lt;h2 id="inline-classとは">Inline Classとは
&lt;/h2>&lt;p>Kotlin 1.6から&lt;a class="link" href="https://kotlinlang.org/docs/inline-classes.html" target="_blank" rel="noopener"
>Inline Class&lt;/a>という機能が追加されました。Inline Classは、型のラッパーとして使うことができる機能です。例えば、以下のようなコードがあるとします。プレイヤーがいて、そのプレイヤーごとの成績を表現したものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤー
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Player&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> playerRecordId: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーの成績
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PlayerRecord&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> score: Int)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして以下のようなメソッドがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーの成績を記録する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createPlayerRecord&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> playerId: Int, &lt;span style="color:#66d9ef">val&lt;/span> score: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このメソッドを呼び出すときに、プレイヤーのIDとスコアを渡す必要があります。しかし、このコードでは、プレイヤーのIDとスコアの両方ともがInt型になっているため、プレイヤーのIDをスコアとして渡してしまうというようなミスが起こりうるのです。そこで、以下のように、プレイヤーのIDとスコアをラップした型を定義して、それを使うようにすると、より安全にコードを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーのID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@JvmInline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PlayerId&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// スコア
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@JvmInline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Score&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>二つのInline Classを定義することで、先ほどの関数は以下のように修正できます。こうなると、パラメータを間違えて指定したらコンパイラーがエラーを吐いてくれるので、より安全にコードを書くことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーの成績を記録する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createPlayerRecord&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> playerId: PlayerId, &lt;span style="color:#66d9ef">val&lt;/span> score: Score) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここだけみると、Inline ClassがJavaのラッパークラスや普通のdata classと何が違うんだ？という疑問が湧いてくるかもしれません。また、typealiasのような既存の機能もありますね。ただ、Inline Classはコンパイル時にprimitive型の扱いでありながら、実行時にはラッパークラスのように振る舞うという特徴があります。そのため、Inline Classだと型安全を担保できつつパフォーマンスへの影響も少ないというメリットがあります。&lt;/p>
&lt;h2 id="ktorでpath-parameterを扱う">KtorでPath Parameterを扱う
&lt;/h2>&lt;p>Ktorでは、Path Parameterを受け取るためには、以下のように書く必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/{id}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = call.parameters[&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>]&lt;span style="color:#f92672">?.&lt;/span>toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Path Parameterを取得するために、&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/io.ktor.server.application/-application-call/index.html" target="_blank" rel="noopener"
>ApplicationCall&lt;/a>から&lt;a class="link" href="https://api.ktor.io/ktor-http/io.ktor.http/-parameters/index.html" target="_blank" rel="noopener"
>Parameters&lt;/a>で&lt;code>{id}&lt;/code>に指定された値をまずStringで読み込むようになります。そして、さらに&lt;code>toInt()&lt;/code>でIntに変換しています。これでPath ParameterをIntで受け取り、処理の中で使うことができるようになります。&lt;/p>
&lt;h2 id="path-parameterを受け取る処理を改善する">Path Parameterを受け取る処理を改善する
&lt;/h2>&lt;p>&lt;code>call.parameters&lt;/code>を利用したサンプルは一瞬見てシンプルなコードなのであまり改善の余地はないかなと思うかもしれませんが、実はこのコードにはいくつか問題があります。例えば、Int変換時のエラーを考慮する必要がありますね。&lt;code>toInt()&lt;/code>でIntに変換するときに、&lt;code>null&lt;/code>や&lt;code>&amp;quot;abc&amp;quot;&lt;/code>といった文字列が渡された場合には、&lt;code>NumberFormatException&lt;/code>が発生してしまいます。また、&lt;code>toInt()&lt;/code>でIntに変換するときに、&lt;code>Int.MAX_VALUE&lt;/code>を超える値が渡された場合には、&lt;code>NumberFormatException&lt;/code>が発生してしまいます。このように、Path Parameterを受け取るときには、必ず&lt;code>null&lt;/code>チェックや&lt;code>NumberFormatException&lt;/code>のチェックを行う必要があります。&lt;/p>
&lt;p>また、&lt;code>ApplicationCall&lt;/code>は&lt;code>get()&lt;/code>や&lt;code>post()&lt;/code>のような関数の中でしか呼び出せないです。ということは、エンドポイントごとに同じような処理（エラーハンドリングなど）を書く必要があるということです。ルータ内で何回も同じような処理があるのは望ましくないので、このコードを共通化したいですね。なので、以下のように&lt;code>ApplicationCall&lt;/code>に拡張関数を定義して、Path Parameterを取得する処理を共通化すると良いはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ApplicationCall&lt;/span>.getIdFromPathParameter(name: String): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> parameter = parameters[name] &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;id is required&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = parameter.toIntOrNull() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;id must be integer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> idInt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようにすると、以下のようにエラーハンドリングを共通化できます。try-catchで例外を処理していますが、ここは必要に応じて&lt;a class="link" href="https://ktor.io/docs/status-pages.html" target="_blank" rel="noopener"
>Status Pages&lt;/a>によるエラーハンドリングを追加すると良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/{id}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = call.getIdFromPathParameter(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (e: IllegalArgumentException) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.BadRequest, e.message)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="path-parameterをinline-classでラップする">Path ParameterをInline Classでラップする
&lt;/h2>&lt;p>さて、Path ParameterからInt型で取得する処理を共通化できたので、次はPath ParameterをInline Classでラップすることで、より安全にコードを書くことを考えてみましょう。まず、もっとも簡単な方法は以下のように拡張関数が返す値をInline Classにすることです。先ほどの関数だと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/{playerId}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = PlayerId(call.getIdFromPathParameter(&lt;span style="color:#e6db74">&amp;#34;playerId&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Inline Classもとりあえずコード上ではクラスの扱いなので、ジェネリックを使うこともできます。なので、先ほどの関数をジェネリックを使ったものにする方法も考えられます。イメージ的には、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/{playerId}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = call.getIdFromPathParameter&amp;lt;PlayerId&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;playerId&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようにすると、&lt;code>getIdFromPathParameter()&lt;/code>の戻り値を&lt;code>PlayerId&lt;/code>に変換する処理を&lt;code>getIdFromPathParameter()&lt;/code>の中で行うことができます。また、ジェネリックであるため、使える型を特定のInterfaceに制限し、IDに関するInline Classがそれを実装するという形にしたらより安全なコードになるでしょう。なので、まずは以下のようにID系の共通のInterfaceを定義します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ID系の共通のInterface
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Id&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーのID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@JvmInline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PlayerId&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int) : Id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 監督のID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@JvmInline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DirectorId&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int) : Id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、以下のように&lt;code>getIdFromPathParameter()&lt;/code>をジェネリックにして、&lt;code>Id&lt;/code>を実装したクラスのみを受け取れるようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// IDを取得する拡張関数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#66d9ef">reified&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>: &lt;span style="color:#a6e22e">Id&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">ApplicationCall&lt;/span>.getIdFromPathParameter(name: String): T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> parameter = parameters[name] &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;id is required&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = id.toIntOrNull() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;id must be integer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> T&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.java.getDeclaredConstructor(Int&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.java).apply { isAccessible = &lt;span style="color:#66d9ef">true&lt;/span> }.newInstance(id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修正は簡単で、指定された&lt;code>Id&lt;/code>タイプのインスタンスを作成して、Path Parameterから取得したInt値をラップして返すだけですね。これで&lt;code>Id&lt;/code>を実装するInline Classのみ対応するという制限もかけながら、型の安全性も確保できるようになります。&lt;/p>
&lt;p>ただ一つ、Path Parameterとしての変数名をInline Classの方にcompanion objectとして持たせて共通化できるといいのですが、残念ながらそれは難しいようです。interfaceのcompanion objectはoverrideできなく、Inline Classはabstract classを実装することができないからです。なので、他の方法でPath Parameter名の指定ができるようにすれば拡張関数の引数を減らしよりシンプルなものになるという改善の余地がまだありそうです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>久々にKtorを触り、ブログの記事にしてみましたが、どうだったでしょうか。ずっとRest APIの実装ばかりしていたので、プライベートで何か新しいチャレンジをしてみないと、なかなか発見がない状態となっているのではないかという気がしています。ブログを始めてかれこれ5年目になり、まだ勉強不足だと感じるところが多いと感じつつもなかなかそれを言語化することは簡単ではないとも感じています。&lt;/p>
&lt;p>ブログの更新の頻度が減ることになっても、次からはより良い記事になるように頑張りたいと思います。では、また！&lt;/p></description></item><item><title>Quarkusを触ってみた</title><link>https://retheviper.github.io/posts/quarkus-first-impression/</link><pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/quarkus-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/quarkus.webp" alt="Featured image of post Quarkusを触ってみた" />&lt;p>Spring MVCは良いフレームワークではありますが、最近流行りの&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9" target="_blank" rel="noopener"
>マイクロサービス&lt;/a>には向いてないという批判もあります。理由としては、アプリの起動時間が遅い、サイズが大きい、メモリの使用量が多いなどの問題が挙げられていますね。アプリの起動速度が遅い場合は、変更があった場合の素早い反映が期待できません。アプリのサイズが大きいのとメモリ使用量が多いとインスタンスが増えれば増えるほどコストが高くなるということになりますね。また、これはマイクロサービスだけの話でもないです。サーバレスアプリで、あえてJavaScirptやPythonのようなインタプリタ言語を採用しているのも同じ理由があってこそですね。&lt;/p>
&lt;p>では、これらの問題はどうやって回避できるのでしょうか。そもそもの問題から考えると、全てが全てSpringに局限する問題でもないはずです。他のフレームワークに比べてSpringの起動時間が決して早いとは言えなかったり、メモリの使用量が多いという問題があるのは確かですが、JVMをベースにしている言語を使う限り、ある程度は仕方ない問題にも見えます。JVM言語においてはそのアプリの起動時間、サイズ、メモリ使用量のどれにもJVMが占める割合を含めて考える必要があるからですね。&lt;/p>
&lt;p>ただ、これらの問題を解決できる方法が全くないわけでもありません。今回紹介するのが、その答えとして開発されている&lt;a class="link" href="https://quarkus.io" target="_blank" rel="noopener"
>Quarkus&lt;/a>です。&lt;/p>
&lt;h2 id="quarkusとは">Quarkusとは
&lt;/h2>&lt;p>Quarkusは、&lt;a class="link" href="https://www.redhat.com/ja/technologies/linux-platforms/enterprise-linux" target="_blank" rel="noopener"
>RHEL&lt;/a>で有名なRed Hatが作ったJava用のウェブフレームワークです。公式ホームページの説明が何よりも正確だと思いますので、以下の文を確認してください。&lt;/p>
&lt;blockquote>
&lt;p>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.&lt;/p>
&lt;/blockquote>
&lt;p>Javaのアプリを&lt;code>Kubernetes Native&lt;/code>として作成できる、というのがこのフレームワークの正体性です。Javaと説明していますが、もちろんKotlinのような他のJVM言語も使えるので、そのような言語を使っている場合でも導入を考えられます。&lt;/p>
&lt;p>ここで&lt;code>Kubernetes Native&lt;/code>という言葉が気になりますが、これは単純にコンテナを作ることに特化されている、という表現ではないと思います。Spring Boot 2.3から導入された&lt;a class="link" href="https://spring.io/blog/2020/08/14/creating-efficient-docker-images-with-spring-boot-2-3" target="_blank" rel="noopener"
>Docker Image作成機能&lt;/a>があり、Googleが提供している&lt;a class="link" href="https://github.com/GoogleContainerTools/jib" target="_blank" rel="noopener"
>Jib&lt;/a>のようなライブラリでいくらでもJavaアプリケーションをコンテナ化することができますし、そのほかにもコンテナを作る方法はいくらでもあります。なので、ここで&lt;code>Kubernetes Native&lt;/code>という表現をあえて使っているのは、Kubernetesに特化したものとして設計されているということを意味すると思った方が自然でしょう。&lt;/p>
&lt;p>では、一体何を持って&lt;code>Kubernetes Native&lt;/code>と言えるのでしょう。インフラストラクチャの観点でいう&lt;code>Kubernetes Native&lt;/code>は、Kubernetesだけで完結するアーキテクチャを指しているようです。Kubernetesで完結するということは、それに合わせて最適化しているということと同じ意味合いでしょう。アプリケーションの観点からしてもそれは大きく違わないはずです。まず、Quarkusでは以下のような特徴があると紹介されています。&lt;/p>
&lt;ul>
&lt;li>Nativeコンパイルができる&lt;/li>
&lt;li>起動速度が速い&lt;/li>
&lt;li>メモリ使用量が少ない&lt;/li>
&lt;/ul>
&lt;p>Nativeコンパイルができるということは、JVMを使用する必要がなくなるということなので、先に挙げた三つの問題を全部解消できます。だとすると、マイクロサービスやサーバレスのみでなく、コンテナ単位でのデプロイでもかなり有利になりますね。そして、JVMを使った場合でも他のフレームワークに比べて起動速度とメモリ使用量で優位にあると言われているので、これが本当だとNativeコンパイルしない場合でも十分メリットがあると思われます。&lt;/p>
&lt;h2 id="実際触ってみると">実際触ってみると
&lt;/h2>&lt;p>特徴として挙げられているもの全てが魅力的ではありますが、実際そのフレームワークを使ってみないとわからないこともあります。なので、ちょっとしたサンプルを作り触ってみました感想について少し述べたいと思います。&lt;/p>
&lt;h3 id="起動速度">起動速度
&lt;/h3>&lt;h4 id="spring-bootの場合">Spring Bootの場合
&lt;/h4>&lt;p>Springの起動速度は、DIしているクラスによって大きく異なるので、ここでは&lt;a class="link" href="https://start.spring.io" target="_blank" rel="noopener"
>Spring initializr&lt;/a>から以下の項目のみ設定したアプリケーションを使って起動してみました。&lt;/p>
&lt;ul>
&lt;li>Project: Gradle&lt;/li>
&lt;li>Language: Kotlin&lt;/li>
&lt;li>Spring Boot: 2.5.5&lt;/li>
&lt;li>Packaging: War&lt;/li>
&lt;li>Java: 11&lt;/li>
&lt;li>Dependencies: なし&lt;/li>
&lt;/ul>
&lt;p>そしてローカルでは、Oracle JDK 17を使って起動しています。気のせいかもしれませんが、Java 11を使っていた時より起動が早いような気がしますね。とりわけ、上記通りの設定を済ましたアプリを起動してみると、以下のような結果となりました。（ローカルマシンの情報は消しています）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> . ____ _ __ _ _
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /&lt;span style="color:#ae81ff">\\&lt;/span> / ___&lt;span style="color:#e6db74">&amp;#39;_ __ _ _(_)_ __ __ _ \ \ \ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">( ( )\___ | &amp;#39;&lt;/span>_ | &lt;span style="color:#e6db74">&amp;#39;_| | &amp;#39;&lt;/span>_ &lt;span style="color:#ae81ff">\/&lt;/span> _&lt;span style="color:#e6db74">`&lt;/span> | &lt;span style="color:#ae81ff">\ \ \ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#ae81ff">\\&lt;/span>/ ___&lt;span style="color:#f92672">)&lt;/span>| |_&lt;span style="color:#f92672">)&lt;/span>| | | | | &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">(&lt;/span>_| | &lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39; |____| .__|_| |_|_| |_\__, | / / / /
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> =========|_|==============|___/=/_/_/_/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> :: Spring Boot :: (v2.5.5)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:21.472 INFO 48844 --- [ main] com.example.demo.DemoApplicationKt : Starting DemoApplicationKt using Java 17 on Local.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:21.475 INFO 48844 --- [ main] com.example.demo.DemoApplicationKt : No active profile set, falling back to default profiles: default
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.058 INFO 48844 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.067 INFO 48844 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.068 INFO 48844 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.53]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.117 INFO 48844 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.118 INFO 48844 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 607 ms
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.335 INFO 48844 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &amp;#39;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-17 19:10:22.342 INFO &lt;span style="color:#ae81ff">48844&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span> main&lt;span style="color:#f92672">]&lt;/span> com.example.demo.DemoApplicationKt : Started DemoApplicationKt in 1.129 seconds &lt;span style="color:#f92672">(&lt;/span>JVM running &lt;span style="color:#66d9ef">for&lt;/span> 1.396&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JVMの起動に1.396秒、アプリの起動に1.129秒がかかっていますね。何も依存関係がないので、おそらくこれが自分のマシンでは最速の起動時間と言えるのではないかと思います。これが実際の業務用のアプリとなると、アプリの起動だけで10秒以上かかることもあリますね。一回の起動では10秒でもあまり問題になることはありませんが、ローカルでのテストではテストごとにアプリが起動するような&lt;/p>
&lt;h4 id="quarkus-nativeの場合">Quarkus Nativeの場合
&lt;/h4>&lt;p>では、Quarkusの場合を見ていきたいと思います。まずNativeコンパイルができるというので、&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>を利用してビルドしてみました。実際のビルドはGradleのタスクとして実行できて（固有のパラメータは必要ですが）、簡単です。そしてそれを実行してみた結果が以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>__ ____ __ _____ ___ __ ____ ______
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --/ __ &lt;span style="color:#ae81ff">\/&lt;/span> / / / _ | / _ &lt;span style="color:#ae81ff">\/&lt;/span> //_/ / / / __/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -/ /_/ / /_/ / __ |/ , _/ ,&amp;lt; / /_/ /&lt;span style="color:#ae81ff">\ \ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&lt;span style="color:#ae81ff">\_&lt;/span>__&lt;span style="color:#ae81ff">\_\_&lt;/span>___/_/ |_/_/|_/_/|_|&lt;span style="color:#ae81ff">\_&lt;/span>___/___/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,395 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> quarkus-sample 1.0.0-SNAPSHOT native &lt;span style="color:#f92672">(&lt;/span>powered by Quarkus 2.3.0.Final&lt;span style="color:#f92672">)&lt;/span> started in 0.018s. Listening on: http://0.0.0.0:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,397 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> Profile prod activated.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,397 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> Installed features: &lt;span style="color:#f92672">[&lt;/span>cdi, config-yaml, kotlin, resteasy-reactive, resteasy-reactive-jackson, smallrye-context-propagation, vertx&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>0.018秒がかかっています。ビルドしたプロジェクトの構造が単純であるのもありますが、それでもこの起動速度は確かに速いですね。これなら確かにマイクロサービスだけでなく、リクエストの多いサーバレスアプリケーションでも十分使えると思います。&lt;/p>
&lt;h4 id="quarkus-jvmの場合">Quarkus JVMの場合
&lt;/h4>&lt;p>Springの場合と同じく、Oracle JDK 17を利用して起動してみました。Quarkusには開発モードというものがあり、サーバを起動したまま修正ができるのですが、ここではあえてJarを作って起動しています。余談ですが、Springでは依存関係を全部含む場合はwarになりますが、Quarkusではuber-jarと言っているのが面白いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>__ ____ __ _____ ___ __ ____ ______
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --/ __ &lt;span style="color:#ae81ff">\/&lt;/span> / / / _ | / _ &lt;span style="color:#ae81ff">\/&lt;/span> //_/ / / / __/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -/ /_/ / /_/ / __ |/ , _/ ,&amp;lt; / /_/ /&lt;span style="color:#ae81ff">\ \ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&lt;span style="color:#ae81ff">\_&lt;/span>__&lt;span style="color:#ae81ff">\_\_&lt;/span>___/_/ |_/_/|_/_/|_|&lt;span style="color:#ae81ff">\_&lt;/span>___/___/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,897 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> quarkus-sample 1.0.0-SNAPSHOT on JVM &lt;span style="color:#f92672">(&lt;/span>powered by Quarkus 2.3.0.Final&lt;span style="color:#f92672">)&lt;/span> started in 0.761s. Listening on: http://0.0.0.0:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,905 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> Profile prod activated.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,906 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> Installed features: &lt;span style="color:#f92672">[&lt;/span>cdi, config-yaml, kotlin, resteasy-reactive, resteasy-reactive-jackson, smallrye-context-propagation, vertx&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回は0.761秒がかかりました。Nativeと比べると確かに数十倍も遅くなっていますが、それでもSpringと比べ速い方ですね。&lt;/p>
&lt;p>こうやってアプリの起動が速くなると、ローカルで開発するときもユニットテストが早くなるので即座で確認ができるというメリットもあるかと思います。特にSpringで[RestTemplate]や&lt;a class="link" href="https://spring.pleiades.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/reactive/server/WebTestClient.html" target="_blank" rel="noopener"
>WebTestClient&lt;/a>などを使ったテストケースを書くとテストごとにアプリを起動することになるので、テストケースが増えれば増えるほどかかる時間が多いのが辛いものですね。なので、起動が速いと同じようなテストをQuarkusで書いてもかなり時間が節約できそうです。&lt;/p>
&lt;h3 id="springからの移行が簡単">Springからの移行が簡単
&lt;/h3>&lt;p>最初あまり意識してなかった部分ですが、Quarkusの良い点の一つは、Springからの移行が簡単ということです。アプリを新規に開発するときや既存のアプリのフレームワークを変更する場合には、技術選定において色々と考慮すべきものや観点があると思いますが、その中でいくつかを取り上げると「いかに工数を減らせるか」、「エンジニアを募集しやすいか」などがあるのはないかと思います。こういう観点からすると、現在のエンジニアにとって全く新しい技術だったり、業界であまり使われてない技術だったりすると会社としてもエンジニアとしても大変でしょう。こういう問題があるので、企業にとって新しい技術の導入は難しくなっていると思います。&lt;/p>
&lt;p>なので、新しい技術でありながらも業界でよく使われているものと似ているという点は、エンジニアの学習コストを減らせるのでかなりのメリットと言えるでしょう。では、実際のコードを観ながら、SpringのコードをQuarkusに移行するとした場合はどうなるかを見ていきたいと思います。&lt;/p>
&lt;h4 id="springの場合">Springの場合
&lt;/h4>&lt;p>まず、クエリパラメータにIDを渡し、Personというレコードのデータを取得するAPIがあるとしましょう。Springなら、以下のようなコードになるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RestController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RequestMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonController&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GetMapping&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#a6e22e">PresonResponse&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonService&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> repository.findById(id).let { &lt;span style="color:#a6e22e">PersonDto&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="ktorの場合">Ktorの場合
&lt;/h4>&lt;p>Quarkusのコードを見る前に、まず同じコードをこのブログでも紹介したことのある&lt;a class="link" href="https://ktor.io/" target="_blank" rel="noopener"
>Ktor&lt;/a>で書くとどうなるかをまず見ていきたいと思います。これでSpringと全く違うフレームワークを選ぶという場合の比較ができるでしょう。&lt;/p>
&lt;p>Ktorもよいフレームワークではありますが、フレームワークそのものの設計思想はSpringと異なるので、既存のアプリを移行するとしたら色々と考慮すべきものが多いです。例えば、基本的にDIに対応していないのでライブラリを別途導入する必要がありますね。&lt;/p>
&lt;p>以下は、上記のSpringと同じAPIを、DIライブラリとして&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>を導入して実装したKtorの例です。かなり違う構造になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// DIの設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> personModule = module {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single { PersonService(&lt;span style="color:#66d9ef">get&lt;/span>()) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single { PersonRepository() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Koinをアプリにインストール
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> install(Koin) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modules(personModule)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ルーティングをモジュール化して設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> configureRouting()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ルータにControllerを登録
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.configureRouting() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> personController()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Route&lt;/span>.personController() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Serviceのインジェクション
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PersonService &lt;span style="color:#66d9ef">by&lt;/span> inject()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/person&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#a6e22e">PresonResponse&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Service
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonService&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> repository.findById(id).let { &lt;span style="color:#a6e22e">PersonDto&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="quarkusの場合">Quarkusの場合
&lt;/h4>&lt;p>では、続いてQuarkusでAPIを作成した場合のコードを見ていきましょう。QuarkusでAPIを作成する方法は&lt;a class="link" href="https://resteasy.github.io" target="_blank" rel="noopener"
>RESTEasy&lt;/a>と&lt;a class="link" href="https://quarkus.io/guides/reactive-routes" target="_blank" rel="noopener"
>Reactive Routes&lt;/a>の二つのパターンがありますが、どちらを使った場合でもアプリの作成そのものに大きい違いはないので、ここではRESTEasyを使った実装を紹介したいと思います。まずは以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Path&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonController&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GET&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#a6e22e">PresonResponse&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ApplicationScoped&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonService&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> repository.findById(id).let { &lt;span style="color:#a6e22e">PersonDto&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Springのコードど比較して、使っているアノテーションの種類が違うだけで、ほぼ同じ感覚で実装ができるのがわかります。なので、Ktorの場合のようにアーキテクチャを考え直す必要もなく、移行も簡単になるわけですね。また、RESTEasyを使う場合、ReactiveのAPIを作りやすいというメリットもあります。Reactiveだと&lt;a class="link" href="https://smallrye.io/smallrye-mutiny/" target="_blank" rel="noopener"
>Mutiny&lt;/a>を使うことになりますが、Uni/Multiの概念がMono/Fluxと1:1対応していると思って良いので、Spring WebFluxや他のReactive Streamを触ったことのある方ならすぐに適応できそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Path&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonController&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GET&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): Uni&amp;lt;PersonResponse&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Uni&lt;/span>.createFrom().item(service.getPerson(id).let { &lt;span style="color:#a6e22e">PresonResponse&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KtorやSpring WebFluxのRouter Functionのような書き方もそれなりの良い点はあるかと思いますが、やはりSpring MVCのような書き方に慣れている人も多いだろうし、そのような書き方で特に問題になることもないので、新しいフレームワークだとしてもこのように既存のものと同じような感覚でコードを書けるというのもそのフレームワークを選択しやすくする一つのセールズポイントになるのではないかと思います。例えば&lt;a class="link" href="https://nestjs.com/" target="_blank" rel="noopener"
>NestJS&lt;/a>のように、JavaScript用のフレームワークでもSpring MVCに似たようなコードを書けるのですが、おそらくこれもまたSpringを触った経験のあるエンジニアにアピールするためでしょう。&lt;/p>
&lt;p>こういう面からすると、すでにSpringの経験があるエンジニアならすぐにQuarkusに移行できて、既存のSpringプロジェクトも簡単に移行できそうなので良さそうです。&lt;/p>
&lt;h2 id="懸念">懸念
&lt;/h2>&lt;p>Quarkusを実際触ってみて、最も良いと思われたのは上記の通りですが、Nativeでアプリをビルドしながら、いくつかの懸念もあると感じました。例えば以下のようなものがあります。&lt;/p>
&lt;h3 id="nativeのビルドは遅い">Nativeのビルドは遅い
&lt;/h3>&lt;p>Nativeで起動速度が早くなるのは確かに良いところですが、問題はビルド自体は遅いということです。当然ながら、Nativeとしてビルドするということは、最初から全てのコードをマシンコードとしてコンパイルするということを意味します。JVM用のバイトコードはどの環境でも同じですが、マシンコードはそうではないので、そのプラットフォームに合わせたコードを生成するのに時間がかかるのは当然のことですね。例えば、ローカルでテストに使ったプロジェクトをNativeイメージとしてビルドした場合は以下のような時間がかかりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./gradlew build -Dquarkus.package.type&lt;span style="color:#f92672">=&lt;/span>native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; Task :quarkusBuild
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>building quarkus jar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> classlist: 2,311.58 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>cap&lt;span style="color:#f92672">)&lt;/span>: 3,597.91 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> setup: 5,450.32 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>19:22:21,827 INFO &lt;span style="color:#f92672">[&lt;/span>org.jbo.threads&lt;span style="color:#f92672">]&lt;/span> JBoss Threads version 3.4.2.Final
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>clinit&lt;span style="color:#f92672">)&lt;/span>: 779.71 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>typeflow&lt;span style="color:#f92672">)&lt;/span>: 14,308.32 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>objects&lt;span style="color:#f92672">)&lt;/span>: 16,140.38 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>features&lt;span style="color:#f92672">)&lt;/span>: 1,145.40 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> analysis: 33,857.15 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> universe: 1,718.32 ms, 5.14 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>parse&lt;span style="color:#f92672">)&lt;/span>: 2,635.36 ms, 5.14 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>inline&lt;span style="color:#f92672">)&lt;/span>: 7,363.76 ms, 5.99 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>compile&lt;span style="color:#f92672">)&lt;/span>: 26,314.40 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> compile: 40,954.87 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> image: 10,493.47 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> write: 2,111.59 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span>total&lt;span style="color:#f92672">]&lt;/span>: 97,207.01 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BUILD SUCCESSFUL in 1m 43s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CIでビルドを行っていたり、頻繁にアプリの修正とデプロイが必要な場合にこれでかなりボトルネックになる可能性もあるかと思います。マシンパワーが十分か、デプロイまでの時間があまり気にならない場合は問題にならないと思いますが、起動速度が大事であるなら、その分ビルドに時間がかかると結局は同等のトレードオフになるだけですね。こういう場合はJarとしてビルドする時間や、他のフレームワークを使ってビルド〜起動までにかかる時間を測定してから判断した方が良いかなと思います。&lt;/p>
&lt;h3 id="ピークパフォーマンス">ピークパフォーマンス
&lt;/h3>&lt;p>一般的にCやC++のような言語と比べ、Java(JVM言語)は性能で劣るという話は常識のように受け入れられています。しかし、全ての状況においてそういうわけでもありません。適切なアルゴリズム、アプリケーションのデザインなど言語そのものとは無関係と言えることが理由な場合もありますが、言語の特性を考えてもそういうケースがあるということです。なぜなら、CやC++のようなネイティブコードを生成する言語と、JVM言語のコンパイラの特性が違うからです。&lt;/p>
&lt;p>仮想マシンを挟み、バイトコードをマシンコードにもう一度変換する必要があるJVM言語と比べ、最初からマシンコードを生成する言語の方が性能が優秀であることは当然です。実際それは数値としても表れていて、Javaが登場した当時には性能問題で色々と批判を受けていたらしいですね。今はJavaが比較的性能が大事であるサーバサイドアプリケーションを作成する場合によく採用されていますが、これも「ハードウェアの発展がある」からと言われるケースも多いです。&lt;/p>
&lt;p>ただ、全ての場合においてJVMを挟むアプリケーションがNativeより遅いわけでもありません。なぜなら、コンパイルには「最初から全てコンパイルしておく」&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E4%BA%8B%E5%89%8D%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9" target="_blank" rel="noopener"
>AOT&lt;/a>だけでなく、「必要に応じてコンパイルする」&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%AE%9F%E8%A1%8C%E6%99%82%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9" target="_blank" rel="noopener"
>JIT&lt;/a>の方式もあるからです。&lt;/p>
&lt;p>JVMではJITによりバイトコードの分析と最適化を行い、マシンコードを生成することでより良い性能のコーどを作り出すと言われています。ここで最適化とは、利用頻度の高いメソッドや定数などを含めてオーバヘッドを減らすことを含みます。このような最適化が行われたコードをマシンコードに変換するとしたら、当然性能がより良くなることを期待できますね。ただ、ITは全ての場合に動作してくれるわけでもありません。コンパイルには時間とマシンパワーが必要なので、一度しか利用されないコードをいちいちマシンコードに変換するのは無駄なことですね。なので、JITでコンパイルされるコードは、そのコードの利用頻度により決定されます。よくJavaのマイクロベンチマークで使われている&lt;a class="link" href="https://github.com/openjdk/jmh" target="_blank" rel="noopener"
>JMH&lt;/a>でテストを行うとき、事前にウォーミングアップをおこなっているのも、JITによる最適化でベンチマークの精度を上げるための工夫です。&lt;/p>
&lt;h4 id="検証してみると">検証してみると
&lt;/h4>&lt;p>実際NativeかJVMかによってどれくらいランタイム性能が違うのか気になったので、ループで10万件のデータを作って返すだけのServiceを作成して処理時間を計測してみました。ここでControllerの戻り値に&lt;a class="link" href="https://smallrye.io/smallrye-mutiny/getting-started/creating-multis" target="_blank" rel="noopener"
>Multi&lt;/a>を使ったせいか、APIが呼び出されるたびにレスポンスまでの時間が大きく変化していたので、測定しているのはリクエストからレスポンスまでの時間より「forループによるデータの生成にかかった時間」を計測していると理解してください。&lt;/p>
&lt;p>NativeビルドとJarの実行に使ったのはどれもGraalVM CE 21.3.0(OpenJDK 11)で、処理時間の測定はKotlinの&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.system/measure-time-millis.html" target="_blank" rel="noopener"
>measureTimeMillis&lt;/a>で取得した値をログに吐くという方法を使っています。&lt;/p>
&lt;p>まずNativeで起動した場合の結果です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:14,061 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-6&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">89&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:15,630 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-1&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">52&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:17,079 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-15&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">106&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:18,174 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-5&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">49&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:19,523 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-11&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">50&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:20,468 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-4&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">50&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:21,739 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-7&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">124&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:23,113 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-12&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">53&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:24,073 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-13&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">49&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:25,308 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-2&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">53&lt;/span> ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、以下がJVMで起動した場合の結果です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:32,240 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-8&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">163&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:35,057 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-6&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">33&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:39,418 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-11&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">40&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:42,211 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-3&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">25&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:44,149 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-10&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">38&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:46,283 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-2&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">24&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:48,262 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-20&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">22&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:49,854 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-12&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">26&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:51,552 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-23&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">23&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:52,967 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-7&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">51&lt;/span> ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>やはりJITが関与しているせいか、JVMでは最初の実行で時間がかかっていて、その次から大幅に処理速度が早くなっているのがわかります。GraalVMのコンパイラのバージョンアップでさらにパフォーマンスが向上する可能性はあると思われますが、それはJVMの場合でも同じなので、どうしてもランタイムのピークパフォーマンスが大事な場合はJVMの利用を考慮しても良いかなと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>本当はメモリ使用量などをより正確に測る必要があると思いますが、それに関してはすでに&lt;a class="link" href="https://medium.com/swlh/springboot-vs-quarkus-a-real-life-experiment-be70c021634e" target="_blank" rel="noopener"
>記事があったので&lt;/a>、ここでは割愛します。結論から言いますと、確かにメモリ使用量はヒープを含めQuarkusの方が少ないですが、CPU使用量の最大値とLatencyにおいてはSpring Bootの方が優れているのを確認しました。ただ、ここはQuarkusの方が歴史が短いためであるということもありそうですね。&lt;/p>
&lt;p>とりあえず触ってみた感覚では、確かにKubernetes nativeと言えるだけのものではあると思われます。Nativeビルドしてみると、Jarと比べアプリのサイズ自体は大きくなるものの（倍ほど）、JDKがいらなくなるというのも良いですね。JDKのサイズはAdoptOpenJDKを基準におよそ300MBくらいです。インスタンスが一つの場合だとしたらあまり問題になりそうではないですが、もしインスタンスが増えるとしたらJDKだけでも必要なストレージのサイズが乗数で増えることになるので、Nativeにしたくもなるかなと思います。&lt;/p>
&lt;p>そのほかにも、さまざまなライブラリやフレームワークの組み合わせができるし、Spring Securityなどをそのまま用いることができるのも魅力的です。Springの経験のあるエンジニアなら誰でもすぐに慣れそうなので、会社の立場からも他のフレームワークを使う場合に比べ比較的エンジニアの募集に負担がなくなるのでは、と思ったりもします。&lt;/p>
&lt;p>Spring WebFluxやKtorもよかったのですが、また新しい強者が現れてどれを使うか悩ましい時代になりましたね。本当は&lt;a class="link" href="https://rocket.rs/" target="_blank" rel="noopener"
>Rocket&lt;/a>も触ってみたいんですが、果たして今年内にできるかどうか…&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KtorでRole-based Authorizationを実装する</title><link>https://retheviper.github.io/posts/ktor-role-based-authorization/</link><pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ktor-role-based-authorization/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.webp" alt="Featured image of post KtorでRole-based Authorizationを実装する" />&lt;p>前回、Ktorを紹介しながら、Ktorにはまだ&lt;code>Role-based Authorization&lt;/code>に対応してないので、自前でそのような機能を実装する必要がある、と述べました。Ktorはまだ歴史が短く、SpringやDjango、Railsのように幅広く使われているフレームワークでもないので、おそらく他に比べ実のアプリケーションを作るにあたっては必要な機能が十分でない可能性がありますね。なので、こうやって必要な機能がない場合は直接その機能を実装するしかないです。&lt;/p>
&lt;p>幸い、Ktorでは機能を&lt;a class="link" href="https://ktor.io/docs/plugins.html" target="_blank" rel="noopener"
>Plugin&lt;/a>といい、モジュール単位で追加できるため、必要な機能を実装するのもそのPluginを作ることでできるようになります。ただ、モジュールを利用するということは、機能単位の管理がやりやすくなるものの、そのモジュールはどうやって機能するか、また、どういうお作法が必要となるかを知る必要がありますね。&lt;/p>
&lt;p>今回はネット上に公開されてある&lt;a class="link" href="https://medium.com/@shrikantjagtap99/role-based-authorization-feature-in-ktor-web-framework-in-kotlin-dda88262a86a" target="_blank" rel="noopener"
>記事&lt;/a>を参考にしながら、KtorのRole-based Authorizationを&lt;code>Plugin&lt;/code>として実装してみました。そこで、今回のポストではこういう自作の&lt;code>Plugin&lt;/code>がどうやってKtorの機能として動作するか、どうやって実装するのかについて述べたいと思います。&lt;/p>
&lt;h2 id="role-based-authorizationとは">Role-based Authorizationとは
&lt;/h2>&lt;p>まずは、そもそも&lt;code>Role-based Authorization&lt;/code>とは何か、からですね。これは、ウェブアプリケーションでよく言われている「認可」の方式のうち、ユーザの&lt;code>Role&lt;/code>（役割）に基づいて、APIの実行を制御するものです。例えばECサイトの場合、商品に対して問い合わせをするのは認証されたユーザなら誰でもできるべきですが、「お知らせを書く」や「商品の在庫数を変更する」などの機能はその権限を持つユーザ（Admin）に限定すべきですね。なので、ここで「一般ユーザ」と「管理者」などの&lt;code>Role&lt;/code>を設け、APIに対してのリクエストが発生した際にその&lt;code>Role&lt;/code>をまず確認し、その権限のあるユーザのみがAPIを実行できるようにする、というのが&lt;code>Role-based Authorization&lt;/code>の基本的な概念です。&lt;/p>
&lt;p>これを実現するために既存のアプリに導入する必要のあるものは、大きく分けて&lt;code>Role&lt;/code>の概念と、それを元にリクエストをフィルタリングする機構の二つです。前者の場合はどんなロールがあり、どういう形でユーザに紐付けるかを考えればいいだけなので、テーブルやカラムを追加して既存のユーザの情報と紐づけるだけですみます。しかし、後者はまずフレームワークでどうやってリクエストをフィルタするか、まずその構造から理解する必要がありますね。なんので、まずはKtorでリクエストを扱う方法に対して紹介したいと思います。&lt;/p>
&lt;h2 id="pipelineとfeature">PipelineとFeature
&lt;/h2>&lt;p>Ktorの特徴のうち、最も重要と言えるものは、&lt;a class="link" href="https://ktor.io/docs/pipelines.html" target="_blank" rel="noopener"
>Pipeline&lt;/a>の概念です。この&lt;code>Pipeline&lt;/code>に対して、公式では以下のように説明しています。&lt;/p>
&lt;blockquote>
&lt;p>The pipeline is a structure containing a sequence of functions (blocks/lambdas) that are called one after another, distributed in phases topologically ordered, with the ability to mutate the sequence and to call the remaining functions in the pipeline and then return to current block.&lt;/p>
&lt;/blockquote>
&lt;p>この説明だけでは理解が難しいものですが、要するに、Ktorにおいての処理の単位のことを指していると言ってもよいものです。&lt;code>Pipeline&lt;/code>ではAPIのコールからレスポンスまで一連の流れとしての処理を定義することができます。なので&lt;code>Pipeline&lt;/code>として実現されている代表的な機能は&lt;code>Router&lt;/code>、リクエストに対してのハンドリングを定義する機能（Springの&lt;code>Controller&lt;/code>に対応するもの）となります。&lt;/p>
&lt;p>また、&lt;code>Pipeline&lt;/code>は拡張できるものなので、その形式に合わせて新しい&lt;code>Pipeline&lt;/code>を実装することでモジュール(公式の表現では&lt;code>Plugin&lt;/code>)を実現するのもできます。これらのモジュールを実装し、アプリケーションにインストールすることで、そのモジュールの機能を利用できるようになるのがKtorの特徴です。例えば、kotlin公式のJSON Mapperである&lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>kotlinx.serialization&lt;/a>をアプリケーションに追加するためには以下のようなコードを書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(ContentNegotiation) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> json()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで呼び出している&lt;code>install&lt;/code>関数の実装を見ると、以下のようになっています。&lt;code>feature&lt;/code>(モジュール)と、そのモジュールの設定となる&lt;code>configure&lt;/code>が引数になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">P&lt;/span> : &lt;span style="color:#a6e22e">Pipeline&lt;/span>&amp;lt;*, &lt;span style="color:#a6e22e">ApplicationCall&lt;/span>&amp;gt;, &lt;span style="color:#a6e22e">B&lt;/span> : &lt;span style="color:#a6e22e">Any&lt;/span>, &lt;span style="color:#a6e22e">F&lt;/span> : &lt;span style="color:#a6e22e">Any&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">P&lt;/span>.install(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> feature: ApplicationFeature&amp;lt;P, B, F&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configure: &lt;span style="color:#a6e22e">B&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit = {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): F
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先ほどの&lt;code>kotlinx.serialization&lt;/code>をインストールするために使っていたコードでは、&lt;code>feature&lt;/code>として&lt;code>ContentNegotiation&lt;/code>を渡し、その設定として&lt;code>json&lt;/code>を使うという設定をしているのだなという推測ができますね。実際、&lt;code>ContentNegotiation&lt;/code>の実装は、以下のような形となっています。一部のコードは省略していますが、クラスの中には&lt;code>Configuration&lt;/code>というクラスと、&lt;code>ApplicationFeature&lt;/code>を継承した&lt;code>companion object&lt;/code>を中に持っているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ContentNegotiation&lt;/span> &lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> registrations: List&amp;lt;ConverterRegistration&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> acceptContributors: List&amp;lt;AcceptHeaderContributor&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> checkAcceptHeaderCompliance: Boolean = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Configuration type for [ContentNegotiation] feature
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Configuration&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Implementation of an [ApplicationFeature] for the [ContentNegotiation]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> Feature : ApplicationFeature&amp;lt;ApplicationCallPipeline, Configuration, ContentNegotiation&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の実装でわかるように、&lt;code>Pipeline&lt;/code>として機能するためにはモジュールの設定のための&lt;code>Configuration&lt;/code>というクラスと、モジュールとして機能するための&lt;code>ApplicationFeature&lt;/code>を継承した&lt;code>companion object&lt;/code>が必要であることがわかります。なので、この構造を持ったクラスを定義できれば、自作のモジュールをアプリケーションに実装できるということがわかりますね。&lt;/p>
&lt;h2 id="pluginの実装">Pluginの実装
&lt;/h2>&lt;p>では、実際に&lt;code>Pipeline&lt;/code>として、リクエストに対する認可を判定する機能を作るとしましょう。まずはロールを定義します。&lt;code>enum&lt;/code>が良さそうですね。ここではシンプルに管理者と一般ユーザの2種を作ってみます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Role&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ADMIN(&lt;span style="color:#e6db74">&amp;#34;ADMIN&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> USER(&lt;span style="color:#e6db74">&amp;#34;USER&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのロールは、テーブルなどで管理する必要もありますが、ログイン中のユーザ情報から取得する必要もありますね。認可のためには、ログイン中のユーザにとあるロールが与えられているかどうかの確認が必要となるからです。なので、&lt;code>io.ktor.auth.Principal&lt;/code>を継承したユーザの情報もクラスとして作り、ログインに成功した時はこのクラスにユーザのロールを格納することにします（方法は認可とは関係ないのでここでは割愛させてください）。以下はユーザの情報を格納するための簡単な例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UserPrincipal&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> username: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> roles: Set&amp;lt;Role&amp;gt; = emptySet()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : Principal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、ロールでアクセスを制限する関数を作ります。&lt;code>Router&lt;/code>のエンドポイントに、どのロールの場合にアクセスできるかを指定するようなイメージです。例えば以下のような形で使えたらいいかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 管理者のみアクセスできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> withRole(&lt;span style="color:#a6e22e">Role&lt;/span>.ADMIN) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/admin&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#e6db74">&amp;#34;This is admin page&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 一般ユーザがアクセスできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> withRole(&lt;span style="color:#a6e22e">Role&lt;/span>.USER) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/user&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#e6db74">&amp;#34;This is user page&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Router&lt;/code>の使い方でわかるように、&lt;code>Pipeline&lt;/code>でのコードブロック（関数）はネストが可能なのでこのように一つのレイヤーを挟むのも可能です。ここで追加した&lt;code>withRole&lt;/code>という関数でロールを確認し、APIにアクセスできるかどうかを判定するようにしたら良いでしょう。&lt;/p>
&lt;h3 id="authorizedrotueselectorの実装">AuthorizedRotueSelectorの実装
&lt;/h3>&lt;p>まずは&lt;code>RouteSelector&lt;/code>を実装します。これは、&lt;code>routing&lt;/code>の中にこれから作る認可の関数がネストできるようにするためのものです。もっともシンプルな実装は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AuthorizedRouteSelector&lt;/span>() : RouteSelector() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">evaluate&lt;/span>(context: RoutingResolveContext, segmentIndex: Int) = &lt;span style="color:#a6e22e">RouteSelectorEvaluation&lt;/span>.Constant
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="child-routeの実装">child routeの実装
&lt;/h3>&lt;p>先に実装した&lt;code>AuthorizedRouteSelector&lt;/code>を利用して、実際に&lt;code>child route&lt;/code>として機能する関数を作ります。この&lt;code>child route&lt;/code>は&lt;code>Router&lt;/code>の下にネストすることになるので、&lt;code>Route&lt;/code>の拡張関数を作ることにします。引数としては判定のためのロールと、その下にネストするエンドポイントの関数を設定できるようにすれば良いでしょう。実装は以下のようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Route&lt;/span>.withRole(&lt;span style="color:#66d9ef">val&lt;/span> role: Role, build: &lt;span style="color:#a6e22e">Route&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit): Route {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> authorizedRoute = createChild(AuthorizedRouteSelector())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> application.feature(RoleBaseAuthorizer).interceptPipeline(&lt;span style="color:#66d9ef">this&lt;/span>, role)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> authorizedRoute
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで実装しているものは、まず&lt;code>AuthorizedRouteSelector&lt;/code>で&lt;code>child route&lt;/code>を作り、その後&lt;code>Pipeline&lt;/code>をインターセプトして、ユーザが指定したロールに該当するかどうかを判定します。問題なければ&lt;code>build&lt;/code>を実行させますが、これがネストしている&lt;code>child route&lt;/code>になります。最後に、エンドポイントをネストできるように先ほど作成した&lt;code>child route&lt;/code>のインスタンスを返します。&lt;/p>
&lt;p>&lt;code>Pipeline&lt;/code>をインターセプトする時に呼び出している&lt;code>RoleBaseAuthorizer&lt;/code>は、別途クラスとして作ることにします。これを&lt;code>Feature&lt;/code>として作ることになります。&lt;/p>
&lt;h3 id="認可処理のモジュールの実装">認可処理のモジュールの実装
&lt;/h3>&lt;p>では、本格的に認可の処理を担当するモジュール（&lt;code>Feature&lt;/code>）を実装することにします。先に述べた通り、&lt;code>Configuration&lt;/code>と&lt;code>Feature&lt;/code>を内部に持ったクラスを作ります。ここで&lt;code>Configuration&lt;/code>は、ログイン中のユーザからどうやってロールの情報を取得するかの設定ができるクラスにします。こうすることで、以下のようなことが可能になるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// RoleBaseAuthorizerをFeatureとしてインストール
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> install(RoleBaseAuthorizer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン中のユーザの情報からロールを取得する方法をConfigurationとして指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> getRoles { (&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> UserPrincipal).roles }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Configuration&lt;/code>では、ログイン中のユーザ情報となる&lt;code>UserPrincipal&lt;/code>から&lt;code>roles&lt;/code>を取得する、という関数を渡します。これを持って、&lt;code>RoleBaseAuthorizer&lt;/code>では&lt;code>withRole&lt;/code>関数で指定したロールとユーザのロールを比較するようにします。&lt;/p>
&lt;p>認可のモジュールの設定方法のイメージができたので、次に&lt;code>RoleBaseAuthorizer&lt;/code>を実装します。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RoleBaseAuthorizer&lt;/span>(config: Configuration) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Configuration&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> userRoles: (Principal) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Set&amp;lt;Role&amp;gt; = { emptySet() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン中のユーザの情報からロールの取得方法をセット
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getRoles&lt;/span>(roles: (Principal) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Set&amp;lt;Role&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userRoles = roles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> getRoles = config.userRoles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">interceptPipeline&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pipeline: ApplicationCallPipeline,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> role: Role
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Pipelineの位置付け
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pipeline.insertPhaseAfter(&lt;span style="color:#a6e22e">ApplicationCallPipeline&lt;/span>.Features, &lt;span style="color:#a6e22e">Authentication&lt;/span>.ChallengePhase)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pipeline.insertPhaseAfter(&lt;span style="color:#a6e22e">Authentication&lt;/span>.ChallengePhase, AuthorizationPhase)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インターセプト時の処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pipeline.intercept(AuthorizationPhase) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン中のユーザの情報を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> principal = call.authentication.principal&amp;lt;UserPrincipal&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> AuthorizationException(&lt;span style="color:#e6db74">&amp;#34;Missing principal&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザ情報からロールを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> roles = getRoles(principal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (roles.none { role }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン中のユーザのロールに、アクセス可能なロールが含まれてない場合の処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> Feature : ApplicationFeature&amp;lt;ApplicationCallPipeline, Configuration, RoleBaseAuthorizer&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> key = AttributeKey&amp;lt;RoleBaseAuthorizer&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;RoleBaseAuthorizer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> AuthorizationPhase = PipelinePhase(&lt;span style="color:#e6db74">&amp;#34;Authorization&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">install&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pipeline: ApplicationCallPipeline,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configure: &lt;span style="color:#a6e22e">Configuration&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ): RoleBasedAuthorization {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> configuration = Configuration().apply(configure)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> RoleBaseAuthorizer(configuration)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先に説明した通り、&lt;code>Configuration&lt;/code>ではユーザのロール情報を取得する関数を設定し、保存します。そして&lt;code>interceptPipeline&lt;/code>では、その関数を持って&lt;code>Pipeline&lt;/code>をインターセプトし、ロールの検証を行うようにします。&lt;/p>
&lt;p>また、&lt;code>interceptPipeline&lt;/code>では、引数として渡された&lt;code>Pipeline&lt;/code>の位置付けを設定する必要があります。上記のコードでは、「認証の後」に位置付けしています。その後のロジックは、色々な方法があると思いますので、ここでは割愛させていただきます。&lt;/p>
&lt;p>他に、&lt;code>Feature&lt;/code>の場合は、&lt;code>RoleBaseAuthorizer&lt;/code>が独立したモジュールとして使える設定を行います。単純に名前をつけてインスタンスを返すような、お作法的なものですね。&lt;/p>
&lt;p>ここまでの実装が終わったら、一通り認可に関するモジュールの作成は終わります。ただ、&lt;code>interceptPipeline&lt;/code>の処理としてユーザのロールが、APIにアクセスできない場合の処理として考えられることは二つほどあります。&lt;/p>
&lt;h4 id="レスポンスを返して終了">レスポンスを返して終了
&lt;/h4>&lt;p>まず考えられる方法は、適当なレスポンスを返し、そこで処理を終了させることです。この場合、以下のように実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (roles.none { role }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンスを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> call.respond(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status = &lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.Forbidden,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message = &lt;span style="color:#e6db74">&amp;#34;permission not granted: &lt;/span>&lt;span style="color:#e6db74">$role&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Pipelineの終了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> finish()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで注意すべきことは、レスポンスを返すだけで&lt;code>Pipeline&lt;/code>は終わらないということです。レスポンスを返し処理を止めたい場合は必ず&lt;code>finish()&lt;/code>を呼び出して、&lt;code>Pipeline&lt;/code>を終了させましょう。&lt;/p>
&lt;h4 id="exceptionを投げる">Exceptionを投げる
&lt;/h4>&lt;p>もう一つの方法は、例外を投げる方法ですね。例えば以下のようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 認可されてない場合の例外
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AuthorizationException&lt;/span>(&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> message: String) : Exception(message)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (roles.none { role }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> AuthorizationException(&lt;span style="color:#e6db74">&amp;#34;permission not granted: &lt;/span>&lt;span style="color:#e6db74">$role&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例外を投げる場合は、当然&lt;code>Pipeline&lt;/code>の処理が止まることになりますが、アプリケーションのログでも例外になるのであまり良くないですね。幸い、KtorにもSpringの&lt;code>ExceptionHandler&lt;/code>のような機能があるので、それを活用したら適切な例外のハンドリングが可能になります。例えば以下のようなことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 認可されてない場合のレスポンス
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AuthFailedResponse&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> reason: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 例外のハンドリング
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>install(StatusPages) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exception&amp;lt;Throwable&amp;gt; { cause &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (cause) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 認可の場合の処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> AuthorizationException &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status = &lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.Forbidden,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message = AuthFailedResponse(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason = cause.message
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでアプリケーションのログも綺麗になりますし、他の例外処理に対しても&lt;code>when&lt;/code>の分岐を増やすだけで対応ができるようになります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最初に思っていたことよりも膨大な内容を扱うことになったので、いつもより説明が大雑把な気もしますが、これで&lt;code>Pipeline&lt;/code>とそれを応用した自作モジュールの実装についての説明は一通りできたかなと思います。なので、これを応用すれば、他のモジュールを追加するのもそう難しくなさそうな気がしますね。深堀すると色々また出そうな気がしますが、それについては機会があればまた今度のポストのネタにしましょう。（正直あまり詳しくありませんので…）&lt;/p>
&lt;p>個人的には、このようにRole-based Authorizationの機能を作りながら知った。一連の処理を&lt;code>Pipeline&lt;/code>という単位で扱うという概念ががかなり新鮮で、良いと思いました。処理に対してのインターセプトはSpringでもできるのですが、処理の流れ自体を一つの単位として扱えるならより色々なことができそうな気もしますね。まだKtorに触れたばかりなので、詳しいことはもっと時間をかけてゆっくり調べる必要がありそうですが。&lt;/p>
&lt;p>確かなのは、Ktorはかなり魅力的なフレームワークであるということです。最初はSpringなど、既存の有名なフレームワークと比べ色々と機能が足りない認証だったのですが、こうやって簡単にモジュールを作れるとしたら意外と問題ないかもしれない、という気がします。もちろんそれでも、プロダクションレベルのものを作るにはまだ色々と検証が必要そうな認証はありますが。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Ktorを触ってみた</title><link>https://retheviper.github.io/posts/ktor-first-impression/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ktor-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.webp" alt="Featured image of post Ktorを触ってみた" />&lt;p>サーバサイド言語としてのKotlinは普及しつつありますが、Kotlinを使う場合でもウェブフレームワークとして使われるのはやはりSpringが多いかと思います。理由としては会社ごとの事情というものもあるはずですが、一般的な理由としてはJavaエンジニアにとってKotlinは馴染みやすい物であっても、フレームワークの場合はそうでなく、Springほど検証されたフレームワークはないからということからでしょう。いまだにStrutsを使っていて、Springに移行しようとするところもありますしね。&lt;/p>
&lt;p>KotlinはJavaと完璧（に近い）互換性があるので、Javaで書かれてあるアプリをそのままKotlinに移行しても大した問題はありません。Javaより生産性が高い上にSpringだけでなくJackson、Apache POI、JUnit、Jacocoなどの数多くのライブラリをそのまま使えるのは確かにメリットであって、企業側としてKotlinの導入を検討する理由は確かにそこにあると思います。Javaエンジニアはその数が多いので、エンジニアを募集し安くなるというところもメリットの一つと言えるでしょう。&lt;/p>
&lt;p>ただ、Kotlinを使う場合に長期的にはKotlinで書かれたライブラリやフレームワークを導入することを検討した方が良いかもしれません。コンパイルした結果として生成されるByte codeがJavaと全く一緒だとしても、そもそものソースコードが違う言語なので、使う側のコード（クライアントコード）としては不便なところがあったり、Kotlinに最適化されてない場合もある可能性があるからです。また、KotlinはJVMだけでなく、ネイティブにコンパイルすることもできるので、ネイティブなアプリを作りたい場合はJavaに依存しないAPIを選ぶ必要があるでしょう。&lt;/p>
&lt;p>ということで、今回はJetBrains制のウェブフレームワーク、Ktorと、Ktorと一緒に使えるORMのExposedを少し触ってみて、Springと比べながら紹介したいと思います。&lt;/p>
&lt;h2 id="ktor">Ktor
&lt;/h2>&lt;p>Ktorは、JetBrainsで開発しているマイクロサービス向けの軽量ウェブフレームワークです。&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>公式ホームページ&lt;/a>の紹介にも色々書いてありますが、特にSpringと比べて以下の特徴があるかと思います。&lt;/p>
&lt;h3 id="軽量">軽量
&lt;/h3>&lt;p>Springも軽量とは言われているものの、起動が遅いので、実装する側としてはあまり軽量だという感覚はないです。Springで書かれたアプリケーションの起動が遅いのは、起動時にさまざまなアノテーションを読み込み、DIや設定などを完璧に終わらせているというフレームワークそのもののアーキテクチャに起因しているのではないかと思います。なのでDIされるオブジェクトをLate initにするなどで起動速度を短縮させるテクニックなどが知られていますね。&lt;/p>
&lt;p>しかし、Ktorは起動がかなり早いです。同一規模のアプリをSpringとKtorの両方で作成してベンチマークした訳ではないので正確な数値に関しては割愛しますが、体験だと数倍は早いですね。例えば、In memoryタイプのH2と基本的なCRUDを実装したSpring WebFluxアプリケーションの場合、自分のPCで起動に2.7秒ほどかかりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-07-18 15:08:25.150 INFO &lt;span style="color:#ae81ff">29047&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>main&lt;span style="color:#f92672">]&lt;/span> c.r.s.SpringWebfluxSampleApplicationKt : Started SpringWebfluxSampleApplicationKt in 2.754 seconds &lt;span style="color:#f92672">(&lt;/span>JVM running &lt;span style="color:#66d9ef">for&lt;/span> 3.088&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じ構成でKtorのアプリを実装した場合、起動には1秒もかからなかったです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-07-18 15:09:29.683 &lt;span style="color:#f92672">[&lt;/span>main&lt;span style="color:#f92672">]&lt;/span> INFO ktor.application - Application started in 0.747 seconds.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはおそらく基本的にDIをしなく、アノテーションをあまり使わない（Reflectionを使わない）構造やKtorそのものはREST APIを作成するための必要最低限の機能だけを揃っているのが理由かと思われます。&lt;/p>
&lt;p>アプリの起動が早いというのは、テストにかかる時間を短縮させられるという面でもメリットといえますが、サーバレスなアプリにも適しているということにもなるでしょう。私もAWSのLambdaやAzureのFunctionsなどを触った経験がありますが、この場合にJavaやKotlinの使用を考慮したことはありません。サーバレスの場合、アプリが常に稼働中ではないので、リクエストが発生したたびにアプリを起動しなければならないです。なので起動の遅いSpringはそもそもの考慮対象にならなかったですね。Ktorを使う場合は起動速度が大幅に短縮できるので、JVMの起動速度が許されるというならば、サーバレスアーキテクチャで導入を検討できるレベルになっていると思います。&lt;/p>
&lt;h3 id="拡張可能">拡張可能
&lt;/h3>&lt;p>Ktorが軽量であることとも繋がる話ですが、必要な機能があればプラグイン（モジュール）を追加したり、自分で実装する必要はあります。コードとしては、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> embeddedServer(Netty, port = &lt;span style="color:#ae81ff">8080&lt;/span>, host = &lt;span style="color:#e6db74">&amp;#34;127.0.0.1&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(CORS)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(Compression)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(Sessions) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cookie&amp;lt;MyCookie&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;MY_COOKIE&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(ContentNegotiation) { &lt;span style="color:#75715e">// kotlinx.serialization
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> json()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.start(wait = &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、Ktorの導入直後はモジュールの管理や開発のスピード感という側面ではマイナスになる部分もあるかなと思います。特にまだSpring Securityでは基本的に提供している&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%AD%E3%83%BC%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B9%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E5%88%B6%E5%BE%A1" target="_blank" rel="noopener"
>Role-Based Authorization&lt;/a>などの機能が公式プラグインとして提供されてないので自前の処理を書くしかないという部分もあります。個人的には、モジュール化そのものは慣れたらメリットになる可能性の方が高いと思いますが、導入初期としてはSpringに比べ不利なところなのではないかと思います。&lt;/p>
&lt;p>特にKtorはDIに対応していなく、JetBrains公式のモジュールもないので、DIをするためには&lt;a class="link" href="https://github.com/IVIanuu/injekt" target="_blank" rel="noopener"
>Injekt&lt;/a>, &lt;a class="link" href="https://kodein.org/Kodein-DI/?6.3/ktor" target="_blank" rel="noopener"
>Kodein&lt;/a>, &lt;a class="link" href="https://insert-koin.io" target="_blank" rel="noopener"
>Koin&lt;/a>などをディペンデンシーとして追加する必要があります。ただ、アーキテクチャによってはDIが必要なく、&lt;code>object&lt;/code>で代替することもできると思いますので、どんなアーキテクチャにするかはよく考えて決める必要があるかなと思います。&lt;/p>
&lt;h3 id="coroutine対応">Coroutine対応
&lt;/h3>&lt;p>Spring WebFluxもそうでしたが、最近は多くのウェブフレームワークに非同期・ノンブロッキング対応が行われていますね。PaaSが普及され簡単にインフラの構築ができ、ハードウェアが安くなった今でもソフトウェアで性能を改善できる箇所があるならそれは十分価値があると思っています。だとすると、非同期・ノンブロッキング対応のフレームワークを導入するということも良い選択ではないかと思います。&lt;/p>
&lt;p>Ktorではルーティングの実装として、&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/-route/index.html" target="_blank" rel="noopener"
>Route&lt;/a>の&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/route.html" target="_blank" rel="noopener"
>route&lt;/a>、もしくは&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/get.html" target="_blank" rel="noopener"
>get&lt;/a>, &lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/post.html" target="_blank" rel="noopener"
>post&lt;/a>, &lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/put.html" target="_blank" rel="noopener"
>put&lt;/a>, &lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/delete.html" target="_blank" rel="noopener"
>delete&lt;/a>などのfunctionを呼び出すことになります。これはSpring WebFluxのRouter/Hanlder Functionとよく似ていますね。コードで表すと、以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/hello&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respondText(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてこのHttpメソッドごとの関数のbodyを実装することになりますが、これが基本的に&lt;code>suspend&lt;/code>となっています。これはつまり、実装する側で特に意識しなくてもコードは非同期になるということですね。Spring WebFluxの場合も、Coroutineを使うと簡単に実装ができましたが、&lt;code>suspend&lt;/code>すら意識しなくて良いというところはKtorならではのメリットなのではという気がします。&lt;/p>
&lt;h3 id="テスト">テスト
&lt;/h3>&lt;p>&lt;code>ktor-server-test-host&lt;/code>や&lt;code>kotlin-test&lt;/code>、JUnitなどを使ってテストが可能です。Springでもユニットテストは色々な書き方があるかと思いますが、よりKotlinらしき書き方になっているだけで、基本的にテストの仕方が大きく変わったりはしません。例えば、&lt;code>Get&lt;/code>をのレスポンスをテストするためには以下のようなコードを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withTestApplication(Application&lt;span style="color:#f92672">::&lt;/span>module) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handleRequest(&lt;span style="color:#a6e22e">HttpMethod&lt;/span>.Get, &lt;span style="color:#e6db74">&amp;#34;api/v1/web/members/&lt;/span>&lt;span style="color:#e6db74">$id&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assertEquals(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">actual&lt;/span> = response.status(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expected = &lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assertEquals(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">actual&lt;/span> = response.content,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expected = &lt;span style="color:#a6e22e">Json&lt;/span>.encodeToString(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemberResponse(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userId = userId,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exposed">Exposed
&lt;/h2>&lt;p>Ktorで使える、Kotlinで書かれたORMは代表的に&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>があります。Javaの&lt;a class="link" href="https://www.jooq.org" target="_blank" rel="noopener"
>jOOQ&lt;/a>がそうであったように、SQL DSLを使うことでクエリをコードで書くような感覚で（実施はDSLを解釈してSQLは自動生成されますが）使えるというところが良いです。例えば、Userというテーブルからレコードを取得する場合のコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> userInUsa: List&amp;lt;User&amp;gt; = transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UserTable&lt;/span>.select {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UserTable&lt;/span>.deleted eq &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">UserTable&lt;/span>.id],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">UserTable&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> country = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">UserTable&lt;/span>.country]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.filter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.country = &lt;span style="color:#a6e22e">Country&lt;/span>.USA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、ExposedでははDAOパターンも使えるので、DAOパターンでクエリを書くとしたら以下のようなことができます。JPAやR2DBCと似たような感覚で使えそうですね。(デメリットもおそらく同じかと思いますが)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> userInGermany: List&amp;lt;User&amp;gt; = transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">User&lt;/span>.find { (&lt;span style="color:#a6e22e">UserTable&lt;/span>.country eq &lt;span style="color:#a6e22e">Country&lt;/span>.GERMANY) and (&lt;span style="color:#a6e22e">UserTable&lt;/span>.deleted eq &lt;span style="color:#66d9ef">false&lt;/span>)}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、Exposedの特徴は、テーブルをコードとして定義することでDBに反映させることができるということです。今まで&lt;a class="link" href="https://www.liquibase.org" target="_blank" rel="noopener"
>Liquibase&lt;/a>や&lt;a class="link" href="https://flywaydb.org" target="_blank" rel="noopener"
>Flyway&lt;/a>でDBの形状管理をやっていたことが多かったのですが、個人的に実際のDBとアプリケーションのテーブル定義に乖離があるケースを考えるとこうやってコードの中に定義した方が、データのオーナーという観点からもかなり良いのではないかと思います。特に、頻繁なテーブル定義の修正があったり、マイクロサービスが多いケースではかなり開発が便利になるのではないかと思います。&lt;/p>
&lt;p>Exposedのテーブル定義は、以下のようにできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">Member&lt;/span> : IntIdTable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> userId: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;user_id&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> password: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;password&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">255&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> deleted: Column&amp;lt;Boolean&amp;gt; = bool(&lt;span style="color:#e6db74">&amp;#34;deleted&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> createdBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#e6db74">&amp;#34;created_by&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> createdDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#e6db74">&amp;#34;created_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastModifiedBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#e6db74">&amp;#34;last_modified_by&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastModifiedDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#e6db74">&amp;#34;last_modified_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして実際発行されるSQLは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> &lt;span style="color:#e6db74">&amp;#34;MEMBER&amp;#34;&lt;/span> (ID INT AUTO_INCREMENT &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span>, DELETED BOOLEAN &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, CREATED_BY VARCHAR(&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, CREATED_DATE DATETIME(&lt;span style="color:#ae81ff">9&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, LAST_MODIFIED_BY VARCHAR(&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, LAST_MODIFIED_DATE DATETIME(&lt;span style="color:#ae81ff">9&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, USER_ID VARCHAR(&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;NAME&amp;#34;&lt;/span> VARCHAR(&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, PASSWORD VARCHAR(&lt;span style="color:#ae81ff">255&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで、JPAやR2DBCの場合、Auditableクラスを定義して、エンティティがそれを継承することでカラムを共有したり、Spring Securityに連携することができましたが、Exposedでも似たようなことができました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Audit&lt;/span> : IntIdTable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> deleted: Column&amp;lt;Boolean&amp;gt; = bool(&lt;span style="color:#e6db74">&amp;#34;deleted&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> createdBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#e6db74">&amp;#34;created_by&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> createdDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#e6db74">&amp;#34;created_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastModifiedBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#e6db74">&amp;#34;last_modified_by&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastModifiedDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#e6db74">&amp;#34;last_modified_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">Member&lt;/span> : Audit() { &lt;span style="color:#75715e">// Auditのカラムも含めてテーブルが作成される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> userId: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;user_id&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> password: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;password&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">255&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MyBatisなどに慣れている場合は少し適応に時間が必要かもしれませんが、基本的にはテーブルの定義を除くとほぼSQLの発行をKotlinのコードで書くことになるという感覚なので、便利になるかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>以上で、簡単なCRUDアプリをKtor + Exposedで実装してみた後の感想と紹介を少し書いてみました。まとめると、かなりサクサクコードを書けて性能も良いので、マイクロサービスに特化している構成ではないかと思いました。また、冒頭に述べた通り、ピュアなKotlin制のフレームワークであることも良いですね。Ktorの紹介でもKotlin Multiplatformに基づいていてどのプラットフォームにもアプリをデプロイできると強調していますので、色々なところで活用ができるかと思います。&lt;/p>
&lt;p>まだSpringと他のJavaライブラリに比べ足りないモジュールや機能もありますが、Exposed以外でも&lt;a class="link" href="https://www.ktorm.org" target="_blank" rel="noopener"
>Ktorm&lt;/a>のようなORMがあるなどKotlin制のライブラリの開発も進めていて、IntellijでもKtorのサポートは強力なので今後も発展を期待できそうであります。個人的にまだ仕事で使うことには無理があっても、自作アプリなどを作りたい時は導入をぜひ検討したいと思いました。Kotlinでできることがだんだん増えてきていて、嬉しいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item></channel></rss>