<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ios on Korean-man in Tokyo</title><link>https://retheviper.github.io/tags/ios/</link><description>Recent content in Ios on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 25 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/tags/ios/index.xml" rel="self" type="application/rss+xml"/><item><title>KotlinConf'24を要約してみた</title><link>https://retheviper.github.io/posts/kotlin-conf-2024/</link><pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-conf-2024/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post KotlinConf'24を要約してみた" />&lt;p>今年のKotlinConfが開催されました。数日かけてのイベントなので、全てのセッションを見ることはできませんが、まずはキーノートの方で重要な情報をまとめてみました。全体のスケージュールは&lt;a class="link" href="https://kotlinconf.com/schedule/" target="_blank" rel="noopener"
>こちら&lt;/a>から確認できて、&lt;a class="link" href="https://www.youtube.com/@Kotlin/streams" target="_blank" rel="noopener"
>YouTubeでのライブ配信&lt;/a>も行われているので、興味がある方はぜひチェックしてみてください。&lt;/p>
&lt;p>まずはKotlinConf'24の公式アプリの紹介がありました。公式アプリでは今回行われるカンファレンスとセッションを確認できるもので、&lt;a class="link" href="https://github.com/JetBrains/kotlinconf-app" target="_blank" rel="noopener"
>GitHubにてソースコードを公開&lt;/a>しています。Kotlin Multiplatformで作成されていて、iOS、Android、Webで動作するものなので、いいサンプルとして使えるかもしれません。&lt;/p>
&lt;h2 id="kotlinの今">Kotlinの今
&lt;/h2>&lt;p>まずはKotlinの現状から。常にKotlinを使っているエンジニアの数が、200万以上になっているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage_hu_4e9cf5b624b95683.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage_hu_6ac0077569f6a802.webp 1024w"
loading="lazy"
alt="Kotlinエンジニア数"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>また、Kotlinを導入している企業もどんどん増えているとのことです。代表的な企業は以下の画像通りだそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies_hu_2afd80792f626843.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies_hu_4ba914d418e07899.webp 1024w"
loading="lazy"
alt="Kotlin導入企業"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="kotlin-20-and-k2-compiler">Kotlin 2.0 and K2 Compiler
&lt;/h2>&lt;p>Kotlin 2.0からはK2コンパイラーの導入により、全般的にコンパイルの速度が向上したという話が主なテーマです。ただ一部プロジェクトでは、遅くなるケースもあるとのことでした。また、IntellijでもK2コンパイラーモードがあり、コードハイライトが1.8倍速くなるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance.webp"
width="2056"
height="1216"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance_hu_995494b92274491a.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance_hu_e585bbf4afa9caed.webp 1024w"
loading="lazy"
alt="K2コンパイラーの速度比較"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="405px"
>&lt;/p>
&lt;p>K2モードは、Intellij 2024.1以上から以下の設定画面で設定できます。2024.2からは性能の改善を含め、Beta版として提供される予定です。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode.webp"
width="2188"
height="1668"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode_hu_cc1ee1f60f04b49c.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode_hu_53a70291ccc901c2.webp 1024w"
loading="lazy"
alt="IntellijのK2モード設定画面"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="314px"
>&lt;/p>
&lt;p>2.0へのマイグレーションは1000万行のコード、18000人のエンジニア、80000のプロジェクトでテストされていて、1.9からのマイグレーションはスムーズに行えるとのことです。&lt;/p>
&lt;h3 id="metaの場合">Metaの場合
&lt;/h3>&lt;p>Metaの場合、Kotlin firstでの開発を積極的に進めているとのことでした。IDEからコードの最適化までの全てにおいてKotlinを採用して、既存のJavaで作成されたFacebook, Instagram, Facebook Messenger, WhatsAppなどのアプリにおいて、Kotlinに自動変換できるツールを作成して移行を自動化しているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin_hu_4d0f93915338f0d4.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin_hu_1fae96dffddfbab6.webp 1024w"
loading="lazy"
alt="MetaのKotlin採用"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>そしてMetaはKotlin 1.8の時点から一部のプロジェクトにおいてすでにK2コンパイラーを採用していて、今は95%のプロジェクトがK2コンパイラーを使っているとのことです。その効果としてはAndroidプロジェクトにおいては最大20%のビルド時間の短縮ができたらしいです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler_hu_a06bae37e498f04b.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler_hu_f89f06054d07900c.webp 1024w"
loading="lazy"
alt="MetaのK2コンパイラー採用"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="googleの場合">Googleの場合
&lt;/h3>&lt;p>K2コンパイラーにはGoogle側も協力していて、Androidのツーリングに関してLintや&lt;a class="link" href="https://developer.android.com/kotlin/parcelize?hl=ja" target="_blank" rel="noopener"
>Parcelize&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/docs/ksp-overview.html" target="_blank" rel="noopener"
>KSP&lt;/a>などにもコントリビュートしているそうです。また、Jetpack Composeのコンパイラーの改善もあり、従来はKotlinとバージョンと相違があったのですが、2.0からは同じバージョンで指定できるようになったとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update_hu_7b9333b7c555873b.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update_hu_bfd35cd48dc981bc.webp 1024w"
loading="lazy"
alt="Composeコンパイラーのバージョン指定"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>またAndroid StudioでもKotlin 2.0のサポートを予定しているとのことでした。代表的な機能は以下の画像の通りです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0_hu_7dff0fb15be9b6ab.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0_hu_fed40825b935d73.webp 1024w"
loading="lazy"
alt="AndroidのKotlin 2.0サポート"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Jetpack Composeにおいても新しい機能を追加される予定だそうです。主に以下の画像で挙げている機能が、7月から提供される予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming_hu_f6324f0dc884ac26.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming_hu_90ff3bb7ee738ba9.webp 1024w"
loading="lazy"
alt="Jetpack Composeの追加予定機能"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>コンパイラーそのものの改善もあり、安定性やパフォーマンスが向上しているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance_hu_7c366b40ecc6b27b.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance_hu_9212055a1d57c8f3.webp 1024w"
loading="lazy"
alt="Jetpack Composeの性能改善"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>他にも、Google内部ではサーバサイドKotlinの採用も進んでいたり、KMPによる開発も進んでいるとのことでした。あとはJetpack ComposeのライブラリもMultiplatformに対応していて、ViewModelやRoomなどのライブラリもKotlin Multiplatformで使えるようになったとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform_hu_bf02a4153e503efd.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform_hu_760e4b1939fe9545.webp 1024w"
loading="lazy"
alt="Jetpack ComposeのMultiplatform対応"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="kotlin-multiplatform">Kotlin Multiplatform
&lt;/h2>&lt;p>K2コンパイラーの導入により、Kotlinのコードを直接Swiftのコードに変換することができるようになったとのことです。これにより、iOSアプリの開発においてもKotlin Multiplatformを使って開発することができるようになりました。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift_hu_dbefec7d7fa660fd.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift_hu_74ff27f4f0ead6a3.webp 1024w"
loading="lazy"
alt="KotlinのSwift変換"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>そして&lt;a class="link" href="https://www.jetbrains.com/ja-jp/fleet/" target="_blank" rel="noopener"
>Fleet&lt;/a>で、iOSアプリも開発できるという紹介もありました。FleetだとCompose MultiplatformによるiOSとAndroidのアプリ開発が同時に可能で、リファクタからデバッグまで一貫して開発できるとのことです。AppCodeのサポートが2023年に終了となっていたので、これは嬉しいニュースですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development_hu_fd64c057d5f2e7e4.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development_hu_401bce085ec4a66b.webp 1024w"
loading="lazy"
alt="FleetでのMultiplatform開発"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>また、新しいビルドツールである&lt;a class="link" href="https://github.com/JetBrains/amper" target="_blank" rel="noopener"
>Amper&lt;/a>も紹介されました。まだ発表されてから間もないのですが、すでにJetBrainsのIDEでサポートされていて、YAMLファイルだけでビルド設定を行うことができるので、新しいプロジェクトで使ってみるのもいいかもしれません。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/amper.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/amper_hu_50fac021c2f0f455.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/amper_hu_79b0a97016c43cca.webp 1024w"
loading="lazy"
alt="Amperの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Compose Multiplatformにおいても、以下の新しい機能が追加されたらしいです。どれも期待していた機能だったので、嬉しいですね。個人的にはデスクトップアプリでファイルの選択ダイアログを実装した時に、対応する機能がなくJavaのAWTを使わざるを得なかったので、このようなAPIもあるといいなと思っています。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform_hu_a5236acb62cc7ddb.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform_hu_cb6e6ac8e6384e7a.webp 1024w"
loading="lazy"
alt="Compose Multiplatformの新機能"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="upcoming">Upcoming
&lt;/h2>&lt;p>次に、Kotlin 2.1のベータ版から導入予定の機能について紹介や、新しいライブラリ、AIモデルの発表がありました。以下の画像の通りです。&lt;/p>
&lt;h3 id="guard">Guard
&lt;/h3>&lt;p>whenの分岐で、変数の重複を防ぐための機能です。既存のコードなら、以下のようなコードで&lt;code>status&lt;/code>が重複する場合があっても、どうしようもなかったですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">render&lt;/span>(status: Status): String =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Loading &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Loading&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.isEmpty() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;No data&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">-&amp;gt;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.joinToString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Error &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.isCritical &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Critical problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unknown problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なぜなら、以下のようにコードを変えた場合に&lt;code>and&lt;/code>でコンパイルエラーが発生してしまうからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">render&lt;/span>(status: Status): String =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (status) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Status&lt;/span>.Loading &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Loading&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.isEmpty() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;No data&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Error: expecting &amp;#39;-&amp;gt;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">-&amp;gt;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.joinToString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Error &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.isCritical &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Critical problem&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Error: expecting &amp;#39;-&amp;gt;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unknown problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを改善するため、以下のように&lt;code>Guarded Condition&lt;/code>を導入する予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard_hu_feb9f7f388eb5f77.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard_hu_c93fc04e1d3cc334.webp 1024w"
loading="lazy"
alt="Guardの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="-escaping-problem">$-escaping problem
&lt;/h3>&lt;p>Kotlinで&lt;code>$&lt;/code>は、文字列の中で変数を埋め込むために使われています。ということは、&lt;code>$&lt;/code>を文字列として使いたい場合にエスケープの問題が発生するとのことでもあります。特にMulti-line Stringがそうですね。例えば、以下の例があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jsonSchema: String = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$schema&amp;#34;: &amp;#34;https://json-schema.org/draft/2020-12/schema&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$id&amp;#34;: &amp;#34;https://example.com/product.schema.json&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$dynamicAnchor&amp;#34;: &amp;#34;meta&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;title&amp;#34;: &amp;#34;Product&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>schema&lt;/code>や&lt;code>id&lt;/code>などは変数ではなく、文字列として使いたい場合がありますが、Multi-line Stringの場合にはエスケープができません。なので、以下のようなコードになるケースもありました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jsonSchema: String = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}schema&amp;#34;: &amp;#34;https://json-schema.org/draft/2020-12/schema&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}id&amp;#34;: &amp;#34;https://example.com/product.schema.json&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}dynamicAnchor&amp;#34;: &amp;#34;meta&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;title&amp;#34;: &amp;#34;Product&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを解決するために、文字列リテラルで&lt;code>$&lt;/code>を2回入れることでinterpolationできるようにする、という機能が導入される予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape_hu_a58d40bbc60f5b46.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape_hu_78e1ebe706d6372f.webp 1024w"
loading="lazy"
alt="$-escaping problemの解決"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="non-local-breakcontinue">Non-local break/continue
&lt;/h3>&lt;p>今までは、コンパイラーがLambdaが実行される場所を特定できないため、&lt;code>break&lt;/code>や&lt;code>continue&lt;/code>が使えなかったです。なので、以下のようなコードはエラーになってしまいます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0.&lt;/span>.n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> date = state[i]&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#75715e">// Error: &amp;#39;break&amp;#39; is not allowed here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">continue&lt;/span> &lt;span style="color:#75715e">// Error: &amp;#39;continue&amp;#39; is not allowed here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> process(&lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これもまた、Kotlin 2.1からは&lt;code>let&lt;/code>のようなinline関数を正しく解析できるようになるため、&lt;code>break&lt;/code>や&lt;code>continue&lt;/code>が使えるようになるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/non-local-break-and-continue.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/non-local-break-and-continue_hu_9eb056c8d7fab98.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/non-local-break-and-continue_hu_7db07cf0e36c33e2.webp 1024w"
loading="lazy"
alt="Non-local break/continueの解決"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="contexts">Contexts
&lt;/h3>&lt;p>去年発表された&lt;code>Context&lt;/code>についても発表がありました。これはすでにプレビューとして導入されていて、Kotlin 2.2からはベータ版として提供される予定だそうです。これでDIと似たようなことをしたり、セッションやトランザクションなど色々な関数で使い回す必要があるものは、関数の引数に渡すことなく、&lt;code>Context&lt;/code>を使って共有することができるようになります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/contexts.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/contexts_hu_6adb0c80d16cd915.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/contexts_hu_5fcb8848d262c7d5.webp 1024w"
loading="lazy"
alt="Contextの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="core-libraries">Core Libraries
&lt;/h3>&lt;p>Kotlinのコアライブラリも改善される予定だそうです。すでに発表されている&lt;a class="link" href="https://github.com/Kotlin/kotlinx-io" target="_blank" rel="noopener"
>kotlinx.io&lt;/a>のようなものだけでなく、&lt;a class="link" href="https://github.com/Kotlin/kotlinx-rpc" target="_blank" rel="noopener"
>kotlinx.rpc&lt;/a>のような新しいライブラリの発表もありました。これらのコアライブラリは、Multiplatformでの開発をサポートするために提供されるもので、どのプラットフォームでも使えるものです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries_hu_de9dd39f9dc31c00.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries_hu_50864685e01f0401.webp 1024w"
loading="lazy"
alt="Core Librariesの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="aws-sdk-for-kotlin">AWS SDK for Kotlin
&lt;/h3>&lt;p>Kotlin用のAWS SDKも提供される予定という発表もありました。今まではJavaのSDKを使うことが多かったのですが、CoroutineやNull SafetyのようなKotlinの特徴を活かせつつ、Multiplatformで使えるSDKが提供されるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk_hu_e384fb78f448f45d.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk_hu_eb83556cbbf75753.webp 1024w"
loading="lazy"
alt="AWS SDK for Kotlinの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="kotlin-language-model">Kotlin Language Model
&lt;/h3>&lt;p>Fleetではすでに利用可能で、Intellijでは2024.2から利用可能となるKotlinの言語モデルが開発中のことです。既存のいくつかのモデルと比べ、Kotlinに特化されたからか、比較的パラメータの数が少ないことに比べ、ベンチマークでは高い精度を示しているとのことです。ただ、比較で使っているLlamaの場合はすでにバージョン3がリリースされているので、最新のモデルと比べる場合どの程度の精度があるのかは気になるところです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model_hu_87a2792b84bf0a01.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model_hu_269c801066de89bf.webp 1024w"
loading="lazy"
alt="Kotlin Language Modelの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>KotlinConf'24のキーノートでの発表内容を以上でまとめてみました。他にも多くのセッションがあ理、Kotlin 2.0も&lt;a class="link" href="https://github.com/JetBrains/kotlin/releases/tag/v2.0.0" target="_blank" rel="noopener"
>Changelog&lt;/a>を見ると、多くの変更があるので、また色々とチェックしていきたいところですね。&lt;/p>
&lt;p>Composeの発展も良かったのですが、Flutterのような他のフレームワークもあるのでこれからどれだけのシェアを取れるかが楽しみです。言語としても他の言語の発展も早いので、Kotlinも引けを取らないように頑張ってほしいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinConf'23を要約してみた</title><link>https://retheviper.github.io/posts/kotlin-conf-2023/</link><pubDate>Fri, 14 Apr 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-conf-2023/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post KotlinConf'23を要約してみた" />&lt;p>今年も&lt;a class="link" href="https://kotlinconf.com/" target="_blank" rel="noopener"
>KotlinConf&lt;/a>が開催されました。毎年興味を持って参加やキーノートを視聴しているわけでもありませんが、最近はK2 CompilerにやKMMなどJetbrainsのプロダクトがかなり盛んな感じなので視聴することにしました。そこで思ったより興味深い発表が多かったので、今回はその内容について簡単にまとめてみようかなと思います。&lt;/p>
&lt;p>では、セッション別にどんな話があったのかを紹介していきます。&lt;/p>
&lt;h2 id="k2-compiler">K2 Compiler
&lt;/h2>&lt;p>まずはKotlin 2.0で採用予定の&lt;a class="link" href="https://blog.jetbrains.com/kotlin/2021/10/the-road-to-the-k2-compiler/" target="_blank" rel="noopener"
>K2 Compiler&lt;/a>の話です。2021年から発表されていて、コンパイラの性能向上のみでなくプラグイン対応などの機能も提供する予定となっていますね。今現在開発が進んでいて、Kotlin 1.8がリリースされた今もかなり多い部分が完成されている状態です。&lt;/p>
&lt;p>ここではKotlin 1.8と、2.0になった場合のコンパイラのパフォーマンスの違いをまずグラフとして提示していました。当たり前ながら、2.0でかなり速度が上がったように見えます。同じ環境で20秒かかるものが、10秒に短縮されたということですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison_hu_6f4a4c460afe1bac.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison_hu_850214035683a462.webp 1024w"
loading="lazy"
alt="コンパイル時間の比較"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Andoridの公式言語としてKotlinが採用され、JavaからKotlinに移行した開発者の間でやはりビルドが遅くなったという話を聞いた覚えがあるのでこれはかなり嬉しい結果となっていますね。またコンパイラのパフォーマンスが上がるとintellijでのコンパイルも早くなるわけなのでより快適な開発環境になると思います。&lt;/p>
&lt;p>また、今年の後半にはKotlin 1.9のリリースが予定されていて、その次に1.10のようなバージョンは予定にないとのことでした。つまり、1.9の後はすぐに2.0となるとのことですね。そして2.0は1.9の後方互換性を保つので、1.9でコンパイルができるのであれば2.0でもコンパイルができるとのことです。&lt;/p>
&lt;p>もちろん言語のバージョンアップを急ぐ企業さんはそこまではないと思いますし、コンパイラ自体が変わることでどんな問題が起こるかわからないので、実際の採用まではかなり時間がかるでしょう。ただ個人的にはサイドプロジェクトで色々試してみたいので、来年からはK2 Compilerに触れられるということが楽しみです。&lt;/p>
&lt;h2 id="要望の多い機能">要望の多い機能
&lt;/h2>&lt;p>&lt;a class="link" href="https://www.jetbrains.com/youtrack/" target="_blank" rel="noopener"
>Youtrack&lt;/a>というサイトからJetbrainsのプロダクトに関して議論できるのですが、ここで要望の多い機能に対して今後どのような形で対応していくかを説明するセッションです。ここは一つ一つ、どのような要望があるかを見ていきます。&lt;/p>
&lt;h3 id="static-extensions">Static Extensions
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-11968/Research-and-prototype-namespace-based-solution-for-statics-and-static-extensions" target="_blank" rel="noopener"
>KT-11968&lt;/a>に上がっているもので、JavaクラスにもCompanion objectのように、staticなメソッドやプロパティを追加できるようにしてほしいということです。&lt;/p>
&lt;p>例えば、今までは以下のようにJavaのクラスにCompanion objectを定義してインスタンスの生成なしで使うことはできませんでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">File&lt;/span>.&lt;span style="color:#66d9ef">open&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;data.txt&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>.&lt;span style="color:#a6e22e">Companion&lt;/span>.&lt;span style="color:#66d9ef">open&lt;/span>(name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、&lt;code>static&lt;/code>というキーワードを使って以下のように書けるようになるとのことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>.static.&lt;span style="color:#66d9ef">open&lt;/span>(name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的にはMySQLとJVMの日付のMAX_VALUEの閾値が違ってバグが起きたことがあって、LocalDateに別途プロパティを追加したかったのにJavaのクラスにはstaticなプロパティの追加ができなくて諦めた経験があるのでこれはとても嬉しい変化です。&lt;/p>
&lt;h3 id="collection-literals">Collection Literals
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-43871/Collection-literals" target="_blank" rel="noopener"
>KT-43871&lt;/a>に上がっているもので、その名の通りコレクションのリテラルを作成できるようにしてほしいということです。&lt;/p>
&lt;p>例えば、今までは言語レベルでコレクションのリテラルに対応していなかったので、以下のような書き方が多かったかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>cmdArgs = listOf(&lt;span style="color:#e6db74">&amp;#34;-language-version&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;2.0&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>それが、以下のようにコレクションのリテラルを書けるようになるとのことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> skip: PersistentSet&amp;lt;Int&amp;gt; = [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> skip2 = PersistentSet [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的には&lt;code>const&lt;/code>キーワードの適用範囲をもっと広げてほしいと思っているところですが、これもまた悪くない変化ですね。特にアノテーションなどで使われる配列は実際リテラルになるケースが多いと思いますので、そこでまた色々と活用できる余地ができるかもしれません。&lt;/p>
&lt;h3 id="name-based-destructing">Name-Based Destructing
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-19627" target="_blank" rel="noopener"
>KT-19627&lt;/a>に上がっているもので、分解宣言時に変数名とフィールド名が一致するようにしてほしいということです。&lt;/p>
&lt;p>例えば以下のように分解宣言をしたとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> firstName: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastName: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>firstName, lastName) = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Doe&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードの場合、&lt;code>firstName&lt;/code>は&lt;code>John&lt;/code>, &lt;code>lastName&lt;/code>は&lt;code>Doe&lt;/code>となります。data classの実際のフィールド名とも一致しているので、なんの問題もありません。ただ、もし間違って以下のようにしたらどうでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>lastName, firstName) = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Doe&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、意図とは違って&lt;code>firstName&lt;/code>は&lt;code>Doe&lt;/code>, &lt;code>lastName&lt;/code>は&lt;code>John&lt;/code>となってしまいます。このようなミスを回避するために&lt;a class="link" href="https://kotlinlang.org/docs/inline-classes.html" target="_blank" rel="noopener"
>inline class&lt;/a>などを導入してフィールドごとに型を定義したり、分解宣言そのものを使わないようにするなどの対応をしていることも少なくはないかと思いますが、今後はこのようなミスを回避するために、分解宣言時に変数名とフィールド名が一致するかどうかコンパイラが判断して値の代入を行うことになるとのことです。&lt;/p>
&lt;p>個人的にはかなりすごいと思いますが、心配も多いですね。単純に変数名とフィールドが一致する時のみ動作してくれるのかどうかわからないので、実際の動作を見ておきたいものです。&lt;/p>
&lt;h3 id="context-recivers">Context Recivers
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-10468/Context-receivers-multiple-receivers-on-extension-functions-properties" target="_blank" rel="noopener"
>KT-10468&lt;/a>に上がっているもので、関数にコンテキストが必要な場合はパラメータとしてではなく、別途のキーワードを使ってコンテキストを渡すことができるようにしてほしいということです。&lt;/p>
&lt;p>例えば、以下のような関数があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">processRequest&lt;/span>(context: ServiceContext, request: ServiceRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = request.loadData(context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数ではコンテキストを引数としてもらい、さらにそのコンテキストを違う関数の方に渡しています。当然、呼ばれる関数の方も引数にコンテキストが必要になります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ServiceRequest&lt;/span>.loadData(context: ServiceContext): Data { &lt;span style="color:#75715e">/** ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、関数の中で呼ばれる他の関数が多くなればなるほど、その関数にもコンテキストを渡す必要が出てきます。そこで、以下のように別途のキーワードを使って、引数の追加なしでコンテキストを渡すことができるようになるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>context(ServiceContext)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">processRequest&lt;/span>(request: ServiceRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = request.loadData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>context(ServiceContext)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ServiceRequest&lt;/span>.loadData(): Data { &lt;span style="color:#75715e">/** ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>context&lt;/code>のキーワードに渡せるコンテキストの基準が何か、そしてどのように関数の中でコンテキストを呼び出せるかどうかはまだわかりませんが、より綺麗な感覚になっているかなと思います。&lt;/p>
&lt;h3 id="explicit-fields">Explicit Fields
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-14663/Support-having-a-public-and-a-private-type-for-the-same-property" target="_blank" rel="noopener"
>KT-14663&lt;/a>に上がっているもので、privateなプロパティに対してpublicなプロパティを定義しなくても良いようにしてほしいということです。&lt;/p>
&lt;p>例えば、privateのプロパティに対して、外部から参照する場合は以下のように書くケースがあるかなと思います。privateなプロパティを維持しつつ、外部で参照のみできる別のプロパティがその値を提供するということですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _applicationState = MutableStateFlow(State())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> applicationState: StateFlow&amp;lt;State&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = _applicationState
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、以下のように書けるようになるらしいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> applicationState: StateFlow&amp;lt;State&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span> = MutableStateFlow(State())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>行数をかなり減らせられ、似たようなプロパティを定義する必要もなくなるのでかなり便利そうな感覚です。特にComposeのようにプロパティで状態を管理する場合はこのようなパターンが多いかなと思いますので、有効活用できるかなと思いました。&lt;/p>
&lt;h2 id="kotlin-notebooks">Kotlin Notebooks
&lt;/h2>&lt;p>このセッションで新しくKotlin Notebooksというものの発表がありました。今は&lt;a class="link" href="https://jupyter.org/" target="_blank" rel="noopener"
>Jupyter Notebook&lt;/a>でもKotlinは使えるのですが、似たような機能をKotlin専用として開発したような感覚ですね。Jupyterそのものも有名で、動画の中ですでに多くの機能を紹介しているので説明よりはそのキャプチャを載せておきます。以下のような活用例が紹介されています。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1_hu_2ed1e385aace7760.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1_hu_31d53db5e7f1b98d.webp 1024w"
loading="lazy"
alt="プロトタイピング"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2_hu_e19747fd570102a6.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2_hu_cf2e2f5b486d1ac3.webp 1024w"
loading="lazy"
alt="言語使用の学習(AIサポート)"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3_hu_c3ae33ced0302fa0.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3_hu_2195de9f77b1ac6e.webp 1024w"
loading="lazy"
alt="アルゴリズムの検証(ソートのビジュアライズ)"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4_hu_b5db521035f036e9.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4_hu_992c271b1cc1cffa.webp 1024w"
loading="lazy"
alt="データ調査"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5_hu_ba3daede87f04c28.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5_hu_5506b0eda44673ff.webp 1024w"
loading="lazy"
alt="データ分析"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6_hu_b529835b499ca531.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6_hu_27cf10c1243dd292.webp 1024w"
loading="lazy"
alt="Plot生成"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>その他、自動完成やオンラインでのコードシェア対応、テーブルのソートとカラムの順番変更などができるという点が紹介で明らかになっています。&lt;/p>
&lt;h2 id="googlekotlinconf">Google@KotlinConf
&lt;/h2>&lt;p>こちらのセッションはGoogleの人が出て発表をしていましたが、主に指標の話で、Androidのアプリの中でKotlinやComposeを採用しているものがどれほど多いかの話などが多かったですね。また、GoogleでもKotlinを積極活用していて、Google WorkspaceでもKotlin Multiplatformを利用してビジネスロジックを書いているという話がありました。&lt;/p>
&lt;p>他に注目したいところは、Androidの開発においてGradleのデフォルト設定がKotlin DSLになったというところです。Kotlinで開発をしているならもちろんGroovyよりはKotlinの方が便利だと思っていたので、このような変化はありがたいですね。&lt;/p>
&lt;p>ただ、GoogleでもKotlinを利用しているとはいえ、FlutterやGoという競合もあるので、今後どのような方向性を取っていくのかが気になりました。もちろんKotlinのカンファレンスなのでそのような話には触れなかったのですが、今後のGoogleの方針やCompose Multiplatformのシェアについてはもっと注目したいと思いました。&lt;/p>
&lt;h2 id="crossplatform">Crossplatform
&lt;/h2>&lt;p>このセッションではComposeのiOS対応の発表と、Mutiplatformの現在の紹介などがありました。ComposeのiOSはAlpha、MultiplatformはBetaの段階で多くのライブラリが対応しているなどの話が続きましたね。Kotlinが初めからJVM以外の領域でも活用できることを目標として開発されたのは確かですが、登場から10年以上も経ってやっとそのロードマップが現実になっているなという感覚でした。&lt;/p>
&lt;p>個人的にはXcodeやSwiftUIよりはintellijとComposeの方が合っていると感じていたので、iOSの開発ができるようになったのは大変嬉しく思っています。特に、AppCodeの開発が今年て終了するとのことだったのでMacやiOSの開発のためには致し方なくSwiftUIを勉強する必要があるかなと思っていたところなのでタイミング的にも最適ですね。直近でちょうどKotlinのみでウェブとモバイル、デスクトップのアプリを開発するというサイドプロジェクトをやっているので、早速試してみようかなと思っています。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>純粋にK2 Compilerの現在が知りたくて試聴した動画で、思わぬ発表が続いて嬉しい気持ちになりました。個人的には一つの言語で必要なことができるようにしたいと思っていたので、Kotlinという言語を選択したのは正解だったという気持ちになりました。&lt;/p>
&lt;p>やはりまだサーバサイドでもシェアはそこまで高くないかなと思いますが、これからもいろいろな分野でKotlinを使える環境が整っていくと言語として伸びるポテンシャルは十分など思いますので、また今後に期待ですね。&lt;/p>
&lt;p>取り急ぎ、KotlinConfのキーノートの動画を紹介しましたが、他にもいろいろな動画が公式のチャンネルにて配信中なので、興味がある方はぜひ見てみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item></channel></rss>