<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>nonblocking on Korean-man in Tokyo</title><link>https://retheviper.github.io/tags/nonblocking/</link><description>Recent content in nonblocking on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 06 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/tags/nonblocking/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring WebFluxって何？</title><link>https://retheviper.github.io/posts/spring-webflux/</link><pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-webflux/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.jpg" alt="Featured image of post Spring WebFluxって何？" />&lt;p>Springが初めて発表されたのが2002年なので、およそ20年に近い時間が経ちました。今はJavaと言えば当たり前のようにSpringを使っていて、Spring MVCやMaven、propertiesのような煩雑な環境構築と初期設定の問題も、Spring Bootが登場したおかげでだいぶマシになりましたね。特に自分の場合がそうですが、Spring Boot、Gradle、yamlを使ってXMLは一つもないアプリをよく書いていて、なんでも楽と思います。&lt;/p>
&lt;p>こうも発展を成し遂げているSpringですが、実は数年前から、そもそものSpring MVCの問題を改善したいという声があり、Spring 5.0からはMVCとは全く違う、新しいフレームワークが登場していました。それが今回紹介します、Spring WebFluxです。&lt;/p>
&lt;h2 id="spring-webfluxはmvcと何が違うか">Spring WebFluxはMVCと何が違うか&lt;/h2>
&lt;p>最初から作り直したフレームワークなので、根本的な部分から違うところが多いので、理論的なだと以下のキーワードをあげられますでしょう。&lt;/p>
&lt;ul>
&lt;li>非同期、ノンブロッキング、反応型&lt;/li>
&lt;/ul>
&lt;p>私の(コードモンキーの)レベルからしたら、実際のコードのレベルで体感するMVCとの違いは以下です。&lt;/p>
&lt;ul>
&lt;li>MonoとFlux&lt;/li>
&lt;li>Controller/Serviceの代わりにFunction&lt;/li>
&lt;li>TomcatよりNetty&lt;/li>
&lt;li>JPA/JDBCよりR2DBC&lt;/li>
&lt;li>新しい抽象化クラス&lt;/li>
&lt;/ul>
&lt;p>では、これらの違いについて、一つ一つみていきたいと思います。&lt;/p>
&lt;h2 id="理論的な話">理論的な話&lt;/h2>
&lt;h3 id="非同期ノンブロッキング反応型">非同期、ノンブロッキング、反応型&lt;/h3>
&lt;p>Spring WebFluxは&lt;a class="link" href="https://github.com/reactor/reactor-core" target="_blank" rel="noopener"
>Project Reactor&lt;/a>に基づいて作られていて、その根幹となる考え方は&lt;a class="link" href="https://www.reactive-streams.org" target="_blank" rel="noopener"
>Reactive Stream&lt;/a>だそうです。Reactive Streamは標準APIであり、Java 9から&lt;code>java.util.concurrent.Flow&lt;/code>として導入されています。&lt;/p>
&lt;p>Reactive Streamはデザインパターン的にはObserverと似ています。簡単にいうと、何かのイベントが発生した時に「通知してくれ」と頼んで、データをもらうということです。この「通知してくれ」と頼む行為のことをSubscription(購読)といい、データを発行するPublisherと購読するSubscriberの間でSubscriptionのやり取りで行われます。こういうイベント基盤のプログラムを作ることが、いわゆる「反応型」だそうです。&lt;/p>
&lt;p>そしてReactive StreamではこのSubscriptionのやり取りが、非同期・ノンブロッキングで行われるらしいです。ということは、コードが実行された時点か終わるまでまつ必要がなく、その間に他のことができるということです。なので同じ数の同じタスクを実行するときは同期・ブロッキングと比べあまり性能面での違いはないのですが&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>、スレッド数がボトルネックとなる場合だと、非同期・ノンブロキングの方が早くなります。&lt;/p>
&lt;p>理論的な話は、深くまで踏み入るとキリが無くなるので、実際のコードではどんな違いがあるのか？をみていきましょう。&lt;/p>
&lt;h2 id="コードのレベルでの話">コードのレベルでの話&lt;/h2>
&lt;h3 id="monoとflux">MonoとFlux&lt;/h3>
&lt;p>Spring WebFluxだと、コントローラのメソッドに戻り値(レスポンス)としてMonoとFluxを使うということです。Spirng MVCなら、文字列でJSPファイルを指定したり、REST APIならJSONとして返すオブジェクトを指定していましたね。もちろんMonoとFluxもJSONオブジェクトとして出力されるのですが、作り方が少し独特です。&lt;/p>
&lt;p>Spring WebFluxの根幹となる考え方がReactive Streamであると先に述べましたね。そしてReactive StreamをWebFlux側で実装したものが、MonoとFluxになります。Monoは&lt;code>0か1か&lt;/code>、Fluxは&lt;code>0かNか&lt;/code>の違いだそうですが、必ずしもCollection=Fluxにする必要はなくて、Monoとして扱うことßもできます。&lt;/p>
&lt;p>Reactive Streamは、名前からしてJava 1.8のStream APIとなんらかの関係があるようにも見えます。実際、データの作成と消費の時点が違うのですが&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>、似たような名のメソッドや、Lambdaで完成していくところは似ています。すでに&lt;a class="link" href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener"
>RxJava&lt;/a>や&lt;a class="link" href="https://github.com/jOOQ/jOOL" target="_blank" rel="noopener"
>JOOL&lt;/a>などに慣れているなら、書き方的にはまあり問題なく適応できそうですが、そうでない方には適応が難しいかもしれません。&lt;/p>
&lt;p>例えば、GETで、リクエストを受けたら1秒後にレスポンスを返す簡単なメソッドを実装するとしましょう。Spring MVCによるREST APIだと、以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>@GetMapping
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@ResponseStatus&lt;span style="color:#ff79c6">(&lt;/span>HttpStatus&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">OK&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> String &lt;span style="color:#50fa7b">getTest&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">try&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">sleep&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>1000&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;task completed by mvc&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">catch&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>InterruptedException e&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;task failed by mvc&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>WebFluxでは、以下のようにMonoを作成して返します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>@GetMapping
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@ResponseStatus&lt;span style="color:#ff79c6">(&lt;/span>HttpStatus&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">OK&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> Mono&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">getTest&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Mono&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">delay&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Duration&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">ofMillis&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>1000&lt;span style="color:#ff79c6">)).&lt;/span>&lt;span style="color:#50fa7b">then&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Mono&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">just&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;task completed by Mono&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最近はなんでも宣言的な言語やフレームワークなどが増えているので(例えばFlutterやSwiftUIがそんな感じですね)、こういう書き方は珍しくもないですが、伝統的な命令型プログラミングに慣れている方には少し辛い書き方になるかもしれません。私自身も、StreamやLambdaは好きなものの、ネストしていく命令型とメソッドチェインで長くなる宣言型のどちらがいいか確信がないです…&lt;/p>
&lt;h3 id="controllerserviceの代わりにfunction">Controller/Serviceの代わりにFunction&lt;/h3>
&lt;p>WebFluxのコード上でのもう一つの特徴は、ControllerとServiceの代替となるクラスを作ることができるということです。もちろん従来通りControllerとServiceクラスを利用することもできますが、どうせなら新しいものが使ってみたくなりますね。&lt;/p>
&lt;p>SpringでController/Serviceを作るということは、つまりアノテーションによる「メタプログラミング」に依存して開発するというです。確かにアノテーションは便利であって、Springではアノテーションでなんでもできるような感じもしますね。しかし、アノテーションによる開発では以下のような問題があります。&lt;/p>
&lt;ul>
&lt;li>コンパイラで検証できない&lt;/li>
&lt;li>コードの行為を規定しない&lt;/li>
&lt;li>継承、拡張のルールに標準がない&lt;/li>
&lt;li>理解できない、誤解しやすいコードをを生み出す可能性がある&lt;/li>
&lt;li>テストが極めて難しい&lt;/li>
&lt;li>カスタマイズが難しい&lt;/li>
&lt;/ul>
&lt;p>なぜかというと、アノテーションを使うということは結局Reflectionに依存するということになるからです。Reflectionを使っているとランタイムでバイトコードが生成されてしまうので、コンパイルタイムにできることがあまりないですね。Reflectionは確かに強力な道具ですが、他にも問題はあります。例えばパフォーマンスは低下し、デバッグも難しいです。こういう問題があるのでJavaのコードをネイティブにコンパイルしてくれるという&lt;a class="link" href="https://www.graalvm.org" target="_blank" rel="noopener"
>GraalVM&lt;/a>ではReflectionに対応していないのかもしれないですね。&lt;/p>
&lt;p>とにかく、このような問題を解決するためにWebFluxで新しく導入されたのは、&lt;code>Function&lt;/code>です。はい、言葉通り、関数です。既存のControllerに対応する&lt;code>Router&lt;/code>とServiceに対応する&lt;code>Handler&lt;/code>を作り、関数型モデルとして(Functinalに)コードを書くことができます。もちろんFunctionalに書くとしても、アノテーションは使えます(むしろアノテーションなしではだめです…)。例えば以下のような書き方になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>@Configuration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Router&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Bean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> RouterFunction&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>ServerResponse&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">route&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Handler handler&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> nest&lt;span style="color:#ff79c6">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/web/members&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterFunctions&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">route&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>GET&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span> handler&lt;span style="color:#ff79c6">::&lt;/span>listMember&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">andRoute&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>POST&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span> handler&lt;span style="color:#ff79c6">::&lt;/span>createMember&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Component
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Handler&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> MemberRepository repository&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Autowired
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#50fa7b">Handler&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> MemberRepository repository&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">repository&lt;/span> &lt;span style="color:#ff79c6">=&lt;/span> repository&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> Mono&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>ServerResponse&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">listMember&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> ServerRequest request&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> ok&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">contentType&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>MediaType&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">APPLICATION_JSON&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">body&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Flux&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">fromIterable&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>repository&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">findAll&lt;/span>&lt;span style="color:#ff79c6">()),&lt;/span> Member&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> Mono&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>ServerResponse&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">createMember&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> ServerRequest request&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> ok&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">contentType&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>MediaType&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">APPLICATION_JSON&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">body&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>request&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">bodyToMono&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Member&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">flatMap&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>member &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Mono&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">fromCallable&lt;/span>&lt;span style="color:#ff79c6">(()&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> repository&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">save&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>member&lt;span style="color:#ff79c6">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">then&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Mono&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">just&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>member&lt;span style="color:#ff79c6">))),&lt;/span> Member&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>関数型になってわかりやすくなったような、難しくなったような…&lt;/p>
&lt;h3 id="tomcatよりnetty">TomcatよりNetty&lt;/h3>
&lt;p>Spring WebFluxのデフォルトのアプリケーションサーバはNettyです。簡単に推論できる理由ですが、&lt;a class="link" href="https://netty.io" target="_blank" rel="noopener"
>Netty&lt;/a>の方が最初からノンブロッキングという考え方に基づいて作られているからでしょう。Tomcatはもちろん同期、ブロッキングなので、Nettyと比較すると以下のような違いがあるらしいです。&lt;/p>
&lt;ul>
&lt;li>Tomcat：リクエストとスレッドは1:1&lt;/li>
&lt;li>Netty：リクエストとスレッドはN:1&lt;/li>
&lt;/ul>
&lt;p>もちろん、Spring MVCみたいにNettyの代わりにTomcatを使うこともできます。例えばGradleでは以下のような書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>dependencies &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;org.springframework.boot:spring-boot-starter-webflux:2.3.3.RELEASE&amp;#39;&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exclude &lt;span style="color:#8be9fd;font-style:italic">group:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;org.springframework.boot&amp;#39;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">module:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#39;spring-boot-starter-reactor-netty&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#39;org.springframework.boot:spring-boot-starter-tomcat:2.3.3.RELEASE&amp;#39;&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="jpajdbcよりr2dbc">JPA/JDBCよりR2DBC&lt;/h3>
&lt;p>これもアプリケーションサーバと同じような話です。JPA/JDBCなど、従来のORMはブロッキングなのでノンブロッキングに対応する&lt;a class="link" href="https://r2dbc.io" target="_blank" rel="noopener"
>R2DBC&lt;/a>に変えましょう、ということです。NIOがそうであったように、ブロッキングでもR2DBCを使うと場合によってはパフォーマンスの向上を図ることもできるらしいです。&lt;/p>
&lt;h3 id="新しい抽象化クラス">新しい抽象化クラス&lt;/h3>
&lt;p>WebFluxでは、Spring MVCで使っていた抽象化クラスも変わっています。これも同じく、関数型としての書き方とノンブロッキングに対応するためですね。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>種別&lt;/th>
&lt;th>Spring MVC&lt;/th>
&lt;th>Spring WebFlux&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>リクエスト&lt;/td>
&lt;td>HttpServletRequest&lt;/td>
&lt;td>ServerHttpRequest&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>レスポンス&lt;/td>
&lt;td>HttpServletResponse&lt;/td>
&lt;td>ServerHttpResponse&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>他のAPIをコール&lt;/td>
&lt;td>RestTemplate&lt;/td>
&lt;td>WebClient&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>WebClientの場合は、RestTemplateが&lt;code>deprecated&lt;/code>に変更されるので、Spring MVCを使う場合でも導入を考える必要はあります。実際Spring MVCで使う場合でもResttemplateに比べてパフォーマンスが向上される場合もあると言われています。&lt;/p>
&lt;h2 id="どこに使えばいい">どこに使えばいい？&lt;/h2>
&lt;p>さて、さっくりWebFluxの特徴をみてみましたが、どうでしょうか。書き方もかなり違っていて、Servlet基盤のMVCとは全く違うReactorに基盤しているので、Spring WebFluxの導入はかなり悩ましいことです。実際Spring MVCと同時に使うこともできず(無理矢理Dependencyを追加しても、MVCが優先され、WebFluxの機能は動作しなかったりもします)、Spring Securityなど他のフレームワークもSpring WebFluxのために作りなおったものに変えなくては行けないので、既存のシステムやSpring MVCに基づいて整備したライブラリなどがたくさんある場合はその影響範囲が測定できません。&lt;/p>
&lt;p>そして性能面でも、ノンブロッキングが強いのは、「指定されたスレッド数を超えるリクエストがある場合」という条件下の話です。ノンブロッキングに変えたからって、単一スレッドでの性能が上がるわけでもないということですね。&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;p>ただし、以下のような場合はWebFluxの導入を考えられます。&lt;/p>
&lt;ol>
&lt;li>完全新規サービスをはなから作る&lt;/li>
&lt;li>複数のサービスがあり、サービス同士での呼び出しが多い場合(マイクロサービス)&lt;/li>
&lt;li>BFF&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>の場合&lt;/li>
&lt;/ol>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>簡単に整理しようとしていた内容が、いつの間にかかなり長くなりましたが…おかげで色々と勉強はできたと思います。WebFluxが登場してからもすでに数年が経っていて、RestTemplateがdeprecatedになる予定であるように、究極的には全体をWebFlux基盤に移行する必要が生じる日がいつか来るかもしれません。なんでも最近は非同期、関数型、反応型というキーワードがすごく流行っていますし。&lt;/p>
&lt;p>静的タイプの言語が最初に生まれて、動的タイプの言語も生まれ、TypeScriptのように静的な世界にまた戻るような現象が起きているのを見ると、また関数型から命令型に移行する日もいつか来る可能性があるのかな、と思ったりもします。ただ、こういうパラダイムはどれが絶対というわけではないので、優秀なプログラマならどれも適時適切に使いこなせるようにならないと、という気もします。エンジニアとしての勉強の道は本当に終わりがないですね。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>実際は、スレッド数によるボトルネックのない状態だと、関数型の方が少し遅いらしいです。実際は関数型のAPIの実装の方が複雑だからですね。ただ、この違いはコードの読みやすさや実装のしやすさなどを考慮した時は、十分トレードオフとして考慮できるくらいの差のようです。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Streamは同期なので、データを生産と消費が一緒に行われます。しかし、Reactive Streamではデータの生産がすぐ消費までつながるとは言い切れません。非同期だからです。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>むしろ、単一スレッドでの処理は、WebFluxの方がMVCに比べ少し遅いという話もあります。forループに比べStreamが遅い理由と似ているような気がしますが…&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>Back-end For Front-endの略。マイクロサービスの一種で、複数のエンドポイントをまとめて固有のオブジェクトを生み出すバックエンド。フロントエンドは一つのエンドポイントを呼び出すだけでことが済みます。&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>