<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on Korean-man in Tokyo</title><link>https://retheviper.github.io/tags/javascript/</link><description>Recent content in javascript on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 22 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlinのこれからを語る</title><link>https://retheviper.github.io/posts/kotlin-prospect/</link><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-prospect/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinのこれからを語る" />&lt;p>1年ほどサーバサイドKotlinを扱いながら、ふと「今のKotlinはどこまできていて、これからはどうなるんだろう」と思うようになりました。色々な観点があると思いますが、とりあえず市場においてどれほどの需要があり、展望（これからも積極的に採用され続けそう、苦戦しそうなどの）はどうかなど、いわゆるkotlinという言語の「ステータス」について自分が感じていることについて考えてみたくなったというわけです。&lt;/p>
&lt;p>最近のトレンドを見ると、一つの言語において専門家になるというよりはさまざまな言語を使いこなせる、いわゆる&lt;code>Polyglot&lt;/code>なプログラマが求められていて、常識みたいになっているとも言われているようです。確かに私自信もその経験があるかどうかは関係なく、案件によりさまざまな言語に触れるケースを多くみています。そして今は充実したドキュメントや記事をインターネットに溢れていて、UdemyやCourseraなど良質の講義を提供するサイトも色々とあるので経験がない言語だとしても入門が難しくてできないとは言えない時代になっている感覚でもあります。なので、自分が現在使っている言語がメインストリームに属してあるかどうかの問題は以前よりは重要でなくなった、といえるかもしれません。&lt;/p>
&lt;p>ただ、立場や観点によっては一つの言語に集中したい場合もあるかと思います。例えば学生や、未経験からエンジニアに転職しようとする人にいきなり二つ以上の言語を扱えるように注文するのは難しいことでしょう。エンジニアの追求する技術においてもそうです。フロントエンドエンジニアがいきなり今すぐ使う予定でもないGoやJavaのようなバックエンドで使われる言語を勉強する必要はないはずです。そして会社としては、複数の言語を扱えるエンジニアを求めるということは採用において非常に厳しい条件となるはずです。なので、依然として市場において一つの言語のステータスというのは無視できないものなのではないかと私は思っています。&lt;/p>
&lt;p>というわけで、今回は多少主観的な観点からの話になりますが、他の言語や分野で、Kotlinという言語の展望について考えてみたことを述べたいと思います。それでは、どうぞ。&lt;/p>
&lt;h2 id="vs-java">vs Java&lt;/h2>
&lt;h3 id="better-javaという捉え方">Better javaという捉え方&lt;/h3>
&lt;p>Kotlin(JVM)をJavaと比べると、コンパイル結果がバイトコードを生成するため、「Javaと互換性が完璧であり、性能もまた変わらない」というのが世間一般でいうKotlinの評価ではないかと思います。その上拡張関数やCoroutine、スコープ関数、Null安全性などさまざまな機能が揃っているので、表面上は&lt;code>better java&lt;/code>と読んでも良いのではないかと思わせる面もあります。それに、JavaのバージョンアップでJVMの改良が行われると、結局それもKotlinの改善につながることとなりますね。Javaも1.8以降は半年に1回のリリース政策によりバージョンアップが早くなっていまずが、まだアプリケーションエンジニアの立場からするとKotlinと比べ惜しいところもなくはないかなと思います。&lt;/p>
&lt;p>ここまでの話だと、Kotlinは完璧にJavaを代替できる言語であるかのように聞こえます。つまり、これからは全くJavaを使う理由はなくて、何もかもKotlinに移行するという選択肢しかないかのようにですね。しかし、業界の事情はどうなのでしょうか。&lt;/p>
&lt;p>まずJavaの歴史から考えてみましょう。Javaは長い間、「世界で最もよく使われる言語」であって、他の言語が人気を得た今でもTop 5に入るほどの人気な言語となっています&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。そしてこれが示唆するのは、単純に今の人気、つまり、「これからも使われる可能性」だけの話ではなく、「今まで使われた回数」が圧倒的に高いということも意味するという点です。今まで作られた多くのシステムやアプリケーションがJava基盤になっているので、余程のことがない限りは維持保守や機能の拡張においてJavaのエンジニアを求めることになるでしょう。&lt;/p>
&lt;p>また、こういう側面もあります。JVM言語としてJavaのメリットを活かしつつ、より発展したコードを書けるというコンセプトで登場した言語はKotlinだけではないということです。今までClojure・Scala・Groovyなどさまざまな言語が登場し、それぞれの言語がそれなりの需要や分野を確保・拡張できてはいるものの、そのうちどれも「Javaを超えた」という評価をもらってはいないのが現状かと思います。同じくKotlinの場合も、その立場が他のJVM言語と大きく変わっているとは言えないものではないでしょうか。なので、「JVM言語だ」「Javaよりモダンだ」という特徴は、少なくともKotlinが今後Javaを超えられるという根拠にはならないかと思っています。&lt;/p>
&lt;p>モバイルではAndroidの言語としてJavaよりKotlinを採用する例が多くなっているかと思いますが、これはOracleとGoogleの訴訟絡みでJavaを1.8しか使えなかったことも理由の一つかと思います。現在Javaがよく使われているWebの場合、OpenJDKのバージョンに特に法理的な問題もなく、Java 17からはOracleJDKも無償で利用できるようになったので、モバイルとはまた状況は違うのではないかと個人的には思っています。&lt;/p>
&lt;p>もちろん、上記の問題はJetbrainsでもその点は最初から認識していたため、最初からKotlinがJavaと相互運用できる言語として設計した部分はあります。なので、あくまで既存のJavaアプリケーションをKotlinでリプレイスする、というよりは、部分的な移行から新規開発で占有率を徐々に上げていくことを目標としているのではないかと思います。その戦略は十分に納得できるもので、あとは企業の方でJavaとKotlinという二つの言語を同時に運用することに抵抗がなければ、Javaを使っていた場合でも問題なくKotlinを受け入れられると思います。実際、自分の場合でもJavaからKotlinの移行は全く問題ありませんでした。&lt;/p>
&lt;h3 id="kotlinも強くなる">Kotlinも強くなる&lt;/h3>
&lt;p>最近のフレームワークやライブラリの方をみると、まだKotlinがモバイル以外の分野での認知度は劣るものの、少しづつJavaがメインストリームであった分野で採用されているケースが増えてきているような気もします。例えば、自分が仕事で使っている&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.kotlin" target="_blank" rel="noopener"
>Spring boot&lt;/a>、&lt;a class="link" href="https://github.com/FasterXML/jackson-module-kotlin" target="_blank" rel="noopener"
>Jackson&lt;/a>、&lt;a class="link" href="https://github.com/awslabs/aws-sdk-kotlin" target="_blank" rel="noopener"
>AWS SDK&lt;/a>などウェブアプリケーションで有名なものがKotlinに対応していて、他にも&lt;a class="link" href="https://www.jooq.org/doc/latest/manual/getting-started/jooq-and-kotlin/" target="_blank" rel="noopener"
>jOOQ&lt;/a>、&lt;a class="link" href="https://jooby.io/v1/doc/lang-kotlin/" target="_blank" rel="noopener"
>jooby&lt;/a>、&lt;a class="link" href="https://javalin.io/" target="_blank" rel="noopener"
>Javalin&lt;/a>のようにJavaとKotlinの両方に対応しているものも増えています。&lt;/p>
&lt;p>もしくは、Javaで存在していたライブラリをKotlin向けに調整したものもあります。例えば&lt;a class="link" href="https://tornadofx.io/" target="_blank" rel="noopener"
>TornadoFX&lt;/a>、&lt;a class="link" href="https://github.com/grpc/grpc-kotlin" target="_blank" rel="noopener"
>gRPC&lt;/a>、&lt;a class="link" href="https://github.com/ReactiveX/RxKotlin" target="_blank" rel="noopener"
>RxKotlin&lt;/a>のようなものがそうです。そして、最初からKotlin専用として設計されたものも少なくないです。&lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>Kotlin Serialization&lt;/a>、&lt;a class="link" href="https://github.com/cbeust/klaxon" target="_blank" rel="noopener"
>Klaxon&lt;/a>、&lt;a class="link" href="https://github.com/Netflix/dgs-framework" target="_blank" rel="noopener"
>DGS&lt;/a>、&lt;a class="link" href="https://www.ktorm.org/" target="_blank" rel="noopener"
>Ktorm&lt;/a>、&lt;a class="link" href="https://github.com/kotest/kotest" target="_blank" rel="noopener"
>Kotest&lt;/a>、&lt;a class="link" href="https://github.com/mockk/mockk" target="_blank" rel="noopener"
>MockK&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>、&lt;a class="link" href="https://litote.org/kmongo/" target="_blank" rel="noopener"
>KMongo&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/xodus" target="_blank" rel="noopener"
>Xodus&lt;/a>、&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>、&lt;a class="link" href="https://github.com/Kodein-Framework/Kodein-DI" target="_blank" rel="noopener"
>Kodein-DI&lt;/a>などがそうですね。なので、Javaの世界に寄生していた数年前とは違って、Kotlinだけでもウェブアプリケーションを十分構築できるレベルまできているのではないか、というのが自分の考えです。&lt;/p>
&lt;p>結論として、まだ二つの言語を比べると、Javaの方が圧倒的に規模はでかく、知名度でも上にあるのですが、Kotlinも競争できる力を身につけてきたので、これからは十分状況が変わる可能性がある、と思っています。&lt;/p>
&lt;h2 id="vs-go">vs Go&lt;/h2>
&lt;h3 id="早いの美徳">「早い」の美徳&lt;/h3>
&lt;p>仕事でGoを使っている立場からすると、Kotlinに比べGoの優越な側面はやはり「とにかく早い」ということではないかと思います。基本的にネイティブにコンパイルされる言語なのでランタイム性能も優秀なはずですが、コンパイルもビルドもとにかく早いのは確かに良いなと思いました。特に、コードの修正後にユニットテストで検証してみることが多いのですが、Kotlinのプロジェクトと比べるととにかく早いのでストレスがないですね。(Kotlinの場合は使っているウェブフレームワークがSpringで、テストケースがより多い、ビルド時にはシングルスレッドでやっているということもありますが)&lt;/p>
&lt;p>そのほかにもGitHubのパッケージをそのまま使えたり、別途ライブラリを使わなくてもstructをすぐにJSONとして扱える(&lt;code>omitempty&lt;/code>とかも便利な場面がある)なところは印象的で、かなりウェブ開発に特化されているなという印象までありました。ネイティブなのでビルドして生成されるバイナリのサイズが小さいのも良いですね。これらの特徴からして、最近トレンドとなっているサーバレスやマイクロサービスなどおいてはKotlinよりGoを採用した方が有利な面が多いかなと思います。&lt;/p>
&lt;p>まだサーバがクラウド上のVMに移行したばかりの頃は、JVMを使う言語の問題はだいたいマシンスペックの向上により無視できました。しかし、サーバレスとマイクロサービスアーキテクチャが流行りながらJVMの特徴が再び問題となってきていますね。まずサーバレスだと、JVMが完璧にロードされるまで時間がかかるる上に、さらにコールドスタートにも時間がかかります&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。また、マイクロサービスにおいては、JVMが占めるヒープメモリとストレージが増えることでインスタンスごとのコストが増えるという問題が挙げられています。&lt;/p>
&lt;h3 id="kotlin--遅い">Kotlin != 遅い&lt;/h3>
&lt;p>このような問題に対して、サーバレスだと&lt;a class="link" href="https://site.kotless.io/" target="_blank" rel="noopener"
>Kotless&lt;/a>のようなフレームワークが開発されていたり、&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>を利用してネイティブビルドができる&lt;a class="link" href="https://ja.quarkus.io/" target="_blank" rel="noopener"
>Quarkus&lt;/a>や&lt;a class="link" href="https://github.com/spring-projects-experimental/spring-native" target="_blank" rel="noopener"
>Spring Native&lt;/a>が開発されるなど、JVM言語でも最近のトレンドに合わせて改善が行われていはいます。&lt;/p>
&lt;p>ランタイム性能という面では、JITによる最適化でJVM言語でもGoには劣らないという面もありますね。ベンチマークを見ると&lt;a class="link" href="https://programming-language-benchmarks.vercel.app/go-vs-kotlin" target="_blank" rel="noopener"
>Kotlin/JVMとの比較&lt;/a>や&lt;a class="link" href="https://www.lambrospetrou.com/articles/kotlin-http4k-graalvm-native-and-golang/" target="_blank" rel="noopener"
>Kotlin/Native&lt;/a>でわかるように、Goに対してKotlinが性能で劣る部分もあれば、優位にある部分もあるのがわかります。&lt;/p>
&lt;p>また、&lt;a class="link" href="https://go.dev/blog/intro-generics" target="_blank" rel="noopener"
>Go 1.18でジェエリックが導入&lt;/a>されていますが、&lt;a class="link" href="https://planetscale.com/blog/generics-can-make-your-go-code-slower" target="_blank" rel="noopener"
>ジェネリックにより遅くなる可能性がある&lt;/a>という話もあり、これからもしGoに新しい機能が追加されるとしたら、それがコンパイル速度やランタイム性能に影響を及ぼす可能性もあるかなと思います。&lt;/p>
&lt;p>なので、KotlinとGoという二つの言語で考えると、少なくともパフォーマンスという観点だけではGoにこだわる必要はないかなと思います。しかし、アプリケーションの開発において言語を選ぶ基準はパフォーマンスだけでなく、生産性やクラウドで対応している言語、エンジニアが確保できるかなど色々な側面があるので、Goの代わりにKotlinを選んだほうが効率的だとは言えないのも事実です。自分が転職を決めた時も、サーバサイドではGoのエンジニアを募集している企業の方がKotlinより多かったのですが、単純にパフォーマンスが基準だとしたらこのようなことにはならなかったでしょう。Googleが推している言語であるとか、パフォーマンスだけでなく生産性の面でも優れているなどさまざまな理由が複合的に作用した結果だと言えるものかと思います。&lt;/p>
&lt;h3 id="それでも有利なのは">それでも有利なのは&lt;/h3>
&lt;p>あとは、そもそもの知名度の問題ですね。Kotlinにおいて、ネイティブイメージのビルドができ、性能が劣らないとしても、多くの場合はKotlinをモバイル(Android限定)用の言語だと認識しているのが一般的かなと思います。なので、このような認識がエンジニアと企業で変わらない限り、これからもGoの方がサーバサイドでは市場において優位に立つという状況がしばらくは続くのではないかと思っています。&lt;/p>
&lt;p>他にも、Goはその書きやすさからや入門のしやすさの人気もあると思いますが、それを踏まえると比較的書き方が複雑なKotlinの方が劣るのではないかという推測もできそうですね。自分にとってはKotlinの書き方が簡潔で良い感覚ですが、Goの書き方を簡潔だと思っている方もいるようです。確かに、キーワードが少なく、それらを覚えるのに労力が比較的少ないなら、よりロジックに集中した書き方ができるはずですね。Goで作られたアプリやCLIツールなどが増えているのも、そのような特徴からのものなのではないでしょうか。自分の場合は簡単なツールを作るときはPythonで書くのを好みますが、同じく気軽にコードが書ける稼働かの観点でいうと、KotlinよりGoが優れているとも言える気がします。なので、個人の趣味やサイドプロジェクトなどでよく使われ、それがまた人気につながるだろうと思うと、Goを好むエンジニアが増えるのもおかしくはないですね。&lt;/p>
&lt;h2 id="vs-rust">vs Rust&lt;/h2>
&lt;h3 id="最強の性能">最強の性能？&lt;/h3>
&lt;p>GCがないので同じネイティブでありながらもGoより性能が優秀だというRustですが、これもまたKotlinと同じく、知名度の問題で苦戦しているところがあるかなと思います。そもそもC/C++を代替するのが開発の目的でもあったため仕方ないのかもしれませんが、どちらかというとエンベデッドで使われるイメージがどうしてもあるような気がしますね。意外と&lt;a class="link" href="https://www.figma.com/" target="_blank" rel="noopener"
>Figma&lt;/a>、&lt;a class="link" href="https://1password.com/jp/" target="_blank" rel="noopener"
>1Password&lt;/a>、&lt;a class="link" href="https://discord.com/" target="_blank" rel="noopener"
>Discord&lt;/a>、&lt;a class="link" href="https://www.dropbox.com/" target="_blank" rel="noopener"
>Dropbox&lt;/a>、&lt;a class="link" href="https://www.mozilla.org/ja/" target="_blank" rel="noopener"
>Mozilla&lt;/a>、&lt;a class="link" href="https://line.me/ja/" target="_blank" rel="noopener"
>Line&lt;/a>、&lt;a class="link" href="https://www.npmjs.com/" target="_blank" rel="noopener"
>npm&lt;/a>、&lt;a class="link" href="https://www.cloudflare.com/ja-jp/" target="_blank" rel="noopener"
>Cloudflare&lt;/a>などさまざまな組織で採用されていて、&lt;a class="link" href="https://github.com/ogham/exa" target="_blank" rel="noopener"
>exa&lt;/a>、&lt;a class="link" href="https://github.com/sharkdp/bat" target="_blank" rel="noopener"
>bat&lt;/a>、&lt;a class="link" href="https://github.com/Wilfred/difftastic" target="_blank" rel="noopener"
>difftastic&lt;/a>、&lt;a class="link" href="https://github.com/ClementTsang/bottom" target="_blank" rel="noopener"
>bottom&lt;/a>などのCLIツールから&lt;a class="link" href="https://yew.rs/" target="_blank" rel="noopener"
>yew&lt;/a>、&lt;a class="link" href="https://seed-rs.org/" target="_blank" rel="noopener"
>seed&lt;/a>、&lt;a class="link" href="https://dioxuslabs.com/" target="_blank" rel="noopener"
>Dioxus&lt;/a>、&lt;a class="link" href="https://rocket.rs/" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://github.com/http-rs/tide" target="_blank" rel="noopener"
>tide&lt;/a>、&lt;a class="link" href="https://github.com/poem-web/poem" target="_blank" rel="noopener"
>poem&lt;/a>のようなGUIやウェブフレームワークなどがたくさん開発されていますが、これもまた特に調査してみないとわからないくらいです。&lt;/p>
&lt;p>さまざまなベンチマークでその性能が検証されていて、使ってみたエンジニアからも評判の高いものとなっているRustですが、やはり知名度が低いので、企業からも採用するのはかなり難しい判断になるでしょう。実際Jetbrainsの去年の設問では&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/rust/#Rust_how-do-you-use-rust" target="_blank" rel="noopener"
>Rustは趣味もしくは個人用途、サイドプロジェクトで使う&lt;/a>と答えた割合のエンジニアが多かったのを見ると、やはり企業の需要はあまりようです。ただ、逆にいうと、このようにRustに好意的なエンジニアが増え、さまざまなプロジェクトで使われ始めるといつか市場の状況も変わっていく可能性もあるということです。先ほど述べたGoのケースのように、比較的に歴史の短い若い言語でも十分その価値を立証できるのであれば市場でもメインストリームに合流できます。なので、Rustの未来はむしろ明るく、これからが期待される言語だと個人的には思っています。ただ、人気を得た後も、ウェブアプリケーションを開発するよりは今まで通りエンベデッド・システムプログラミングに特化していきそうな気がしますね。&lt;/p>
&lt;h3 id="kotlinをネイティブにしたら">Kotlinをネイティブにしたら&lt;/h3>
&lt;p>RustをKotlinとの比較をするとしたら、Kotlin/Nativeがあるので、言語自体でできることはそう変わらないものの、Rustがエンベデッドやシステムプログラミングという分野でC/C++を代替していく傾向があるのに対して、これといった成果があまり見当たらないというのが問題かなと思います。特にKotlin/NativeはLLVM基盤なので、GraalVMによるネイティブコンバイるができるウェブフレームワークが登場している今はますますそのポジションが曖昧なものになっている気もします。Object-CやC/C++とのinteropができると言われていますが、そのようなユースケースだとそもそもObject-CやC/C++といった言語を使った方が色々と有利なのではないでしょうか。もちろん、Rustには所有権のような概念があり、他の言語と比べプログラミングが難しいとされているので、Kotlin/Nativeを採用した方がコーディングは楽になるかもしれません。でも、Nativeを追求するならやはりパフォーマンスが重視される場面が多いので、そこではGCのあるKotlinが不利な気がしますね。このような面からすると、やはりKotlin/Nativeのポジショニングが難しそうな気がします。&lt;/p>
&lt;p>結論としては、Kotlin(JVM)とRustはそれぞれ特化した分野が違っていて、大きな変化がない限り互いの領域を蝕むことなく発展していきそうです。どちらかというとKotlin/Nativeが直接的なライバルになる可能性はありますが、そもそものポジショニングが曖昧なところがあるので、Nativeがどうしても必要な場面ではRustが使われる可能性が高いのではないか、という気がしています。&lt;/p>
&lt;h2 id="vs-python">vs Python&lt;/h2>
&lt;h3 id="万能ツール">万能ツール&lt;/h3>
&lt;p>ここ数年で最も人気を得ている言語の一つ、Pythonの場合は、Kotlinと比べて見るとどうでしょうか。まず自分の場合だと、日常での自動化や簡単なツールを作る場面ではPythonの方をよく使っていて、本格的なウェブアプリケーションを開発するとしたらKotlinを選ぶことが多いです。もちろん、なんでもできる言語なので大規模のアプリケーションを作るのにPythonがNGというわけではないです。実際Uber、Google、PayPal、Netflixなど有種の企業がPythonを使っていて、あの有名なInstagramのサーバサイドもPythonで書かれていると言われていますね。&lt;/p>
&lt;p>ただやはり、PythonはデータサイエンスやAIといった分野でよく使われているイメージがあり、使いやすく、そこまで性能が求められていない場面でなら良いものの、個人的にはその限界が明確であることが問題かなという気もします。本格的な業務用のアプリを開発した経験がないのであくまで印象と推測の話となりますが、Pythonをサーバサイドに取り入れている企業は大概がスタートアップであって、サービスが古くなるとインタープリター言語特有のメンテが難しくなるという問題が出てくる可能性が高いではないかと思いますね。JavaScriptの例もありますが、Pythonのタイプヒントはあくまでヒントであって、TypeScriptのようにコンパイルタイムで検出できるエラーを確実にわかるわけでもないです。あとは性能ですが、&lt;a class="link" href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener"
>GIL&lt;/a>のような問題もあります。このような問題を認識しているため、検証用のアプリ(プロトタイプ)をPythonで書いてから他の言語に移行するという例もあるのかなと思ったりしています。&lt;/p>
&lt;h3 id="pythonだけの領域でもないが">Pythonだけの領域でもないが&lt;/h3>
&lt;p>逆にKotlinでいうと、Jupyterを使えるなど&lt;a class="link" href="https://kotlinlang.org/docs/data-science-overview.html#kotlin-libraries" target="_blank" rel="noopener"
>Kotlinでもデータサイエンスに使える&lt;/a>のですが、すでにPythonが市場支配的な言語になっているところでどこまで伸びるかが問題な気がしますね。JetBrainsが主張するように、Pythonと比べ「静的型付け、Null安全性、パフォーマンス」というのは確かにKotlinが持つメリットではあるのですが、そもそものユーザ数が増える何かがないと占有率を上げるのはかなり難しくないのではないかと思います。Pythonは入門が簡単なので講座も多く、実際エンジニアではない人も使うケースが多いのですが、Kotlinはまだそのような面では弱い印象ですね。&lt;/p>
&lt;p>以上のことからして、Pythonは依然としてデータサイエンスなど元々強かった分野に対してはこれからも需要が大きく変わることはなさそうです。ウェブという分野では競合になる可能性はありますが、どちらかというとKotlinを採用した方がより安定した開発ができるので大規模なアプリの開発ではKotlin、小規模ではPythonという形になるのではないかと思います。もちろん、大規模のアプリを開発するにあたってはまたの選択肢があるのでKotlinではない他の言語が採用される可能性の方が高そうですが、あくまで二つの言語を比べた場合の話となります。&lt;/p>
&lt;h2 id="vs-javascript">vs JavaScript&lt;/h2>
&lt;h3 id="多芸多才">多芸多才&lt;/h3>
&lt;p>一つの言語でなんでもできちゃう言語が何かというと、過去はJava、少し前はPython、そして今はなんといってもJavaScriptではないかと思います。フロントエンド、バックエンド、モバイル、データサイエンスなどさまざまな分野で活躍している言語ですね。ランタイムの性能が問題となっている部分に対しても&lt;a class="link" href="https://deno.land/" target="_blank" rel="noopener"
>Deno&lt;/a>のような新しいランタイムが登場したり、V8エンジンの持続的な改善によりだんだん補完されていって、静的型付けに関してもTypeScriptの台頭によって解決されています。まさに無敵の言語のようにも見えます。&lt;/p>
&lt;p>フロントエンドにおいてはJavaScript以外は考えられない&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>というのもあり、&lt;a class="link" href="https://webassembly.org/" target="_blank" rel="noopener"
>WebAssembly&lt;/a>のような技術も発達していますが、これはまたウェブの画面描画だけでなく違う方向に向かっているような感じなので、これから何かあって(あるとは思いませんが)色々な分野で使われなくなるとしてもJavaScriptそのものが使われなくなることはないでしょう。そして同じ意味で、Kotlinがそのような分野に進出するのもかなりハードルが高いと思います。&lt;/p>
&lt;h3 id="kotlinでフロントエンド">Kotlinでフロントエンド？&lt;/h3>
&lt;p>Kotlinで言えば、Kotlin/JVMとKotlin/Native以外に3つの軸として存在しているのが&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>であり、JetBrainsの発信を見るとそこそこ力を入れている感覚ではあります。他にも、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-mpp/" target="_blank" rel="noopener"
>Compose Multiplatform&lt;/a>を通じて、モバイルだけでなくウェブやデスクトップアプリにおいてもKotlinでGUIを作成できるようになったので、なるべく自分のサイドプロジェクトなどではKotlinで完結したいと思っている私の場合はこちらも応援したいと思っています。ただ、まだモバイル以外ではそこまでメジャーではなく、新しい技術の問題(ライブラリの不足、バージョンアップによる変化が激しいなど)が考えられるのでしばらくは様子見な感じですね。あと自分のような特殊な目的がない場合は、個人でも企業側としても無理して採用すべきメリットが薄いという問題もあるかなと思います。&lt;/p>
&lt;p>バックエンドだとKotlinが競合になる可能性はまだ十分ではないかと思います。特に、今までJavaが採用されていた分野だと主にJVMの安定性や数値計算の精度など検証された安全性というものがあるので、これから言語を変えるとしたらKotlinを採用する確率が高いのではないかと思っているところですが、そのような分野だと、最初からJavaScriptによるバックエンドの採用は考えない可能性が高そうです。スタートアップのようにエンジニアの求人が難しく、使われる技術の数を減らしてなるべく工数の削減しようとするか、Pythonのようにプロトタイプのアプリを作るかなどの特殊な状況ではない限り積極的にバックエンドの言語としてJavaScriptを採用する例はあまりなさそうな気がしていて、これからもおそらくそれは大きく変化していく気はしません。ただ、自分のようにKotlinで何もかも解決したい、という方がJavaScript側にもいらっしゃるとしたら、そこはまた話が変わってくるかもしれませんね。フロントエンド、バックエンド、モバイル、デスクトップまで対応したい場合にはJavaScript以上のものがないので、その会社や個人の目的次第でJavaScriptが採用される可能性は高く、そのような状況こそKotlinは採用されない可能性が高いかなと思います。&lt;/p>
&lt;h2 id="vs-dart">vs Dart&lt;/h2>
&lt;h3 id="guiの最強者">GUIの最強者？&lt;/h3>
&lt;p>Dartの場合は、言語そのものというよりは&lt;a class="link" href="https://flutter.dev/" target="_blank" rel="noopener"
>Flutter&lt;/a>が最近熱いですね。最初はモバイルでクロスプラットフォーム開発ができるということで注目されたものですが、Dartに対してはFlutterの最大の競合は&lt;a class="link" href="https://reactnative.dev/" target="_blank" rel="noopener"
>React Native&lt;/a>だと言えるかなと思いますが、それも最近のトレンドを見ると少しづつ逆転してきているような気がします。もちろんこれはあくまでも「クロスプラットフォーム用のフレームワーク」という基準での比較であり、実際は色々と複雑な事情があるでしょう。例えば、フロントエンドエンジニアがモバイルの開発も担当していて、フロントエンドのライブラリとしてはReactを使っているなどの状況を考えると、ここでいきなりFlutterを採用する可能性は低くなるはずですので。&lt;/p>
&lt;p>自分が思うにDartの最大の問題は、その最初の意図(JavaScriptを代替するという)はともかく、言語そのものの印象が薄いということです。少しだけ触ってみた感覚では、いわゆるC-Family言語としての馴染みはあっても、特段ここが魅力的だというところはあまり感じ取れなかったです。それが今はFlutterのおかがで使用率は上がってきていますが、それ以外の分野ではどうかなという疑問がまだあります。&lt;/p>
&lt;h3 id="可能性は他にもあるかもだけど">可能性は他にもあるかもだけど&lt;/h3>
&lt;p>ただ、以前からGoogleの次世代OSである&lt;a class="link" href="https://fuchsia.dev/" target="_blank" rel="noopener"
>Fuchsia&lt;/a>ではメインの開発環境となるという噂もあり、FuchsiaそのものがどんなOSになるかはまだ不明な状態ですが、もし噂通りAndroidの次世代のOSになるとしたら、ネイティブの開発そのものがDartによるものにもなり得る可能性はありますね。もしそうなると、ChromeOSを含めレガシーの環境を捨てることになるので、公式の開発の言語にKotlinを指定した時とは比べ物にならないインパクトがあることを想定すると、なかなか想像できない事態です。&lt;/p>
&lt;p>もちろんDartもプログラミング言語なので、これからのフレームワークやライブラリの開発次第でいくらでも状況は変わる可能性があります。&lt;a class="link" href="https://github.com/yissachar/awesome-dart" target="_blank" rel="noopener"
>こちらのリポジトリ&lt;/a>を参照すると、サーバサイドのフレームワークもすでにいくつか存在しているので、自分の考えているKotlinで全てを解決する、という目標においてはむしろDartの方がやりやすい可能性がありますね。Kotlinの方だと&lt;a class="link" href="https://kotlinlang.org/lp/mobile/" target="_blank" rel="noopener"
>Kotlin/Multiiplatform Mobile&lt;/a>がありますが、これはどちらかというとビジネスロジックの共通化を目標としているものなので、結局iOSのコードを書く必要があります。もちろん、一部の企業でやっているように「UIはFlutterで、ビジネスロジックはネイティブで」ということもできるかとは思いますが、あまりメジャーなやり方にならないかなと思います。実際、Swiftの場合も&lt;a class="link" href="https://vapor.codes/" target="_blank" rel="noopener"
>Vapor&lt;/a>のようなフレームワークがあり、サーバサイドでも十分使えるということをアピールしていますが、採用しているエンジニアや企業が限りなく少ないというのを見ると、単純に「できる」だけでは十分ではなさそうですので。&lt;/p>
&lt;h3 id="モバイルでも強くなっていく">モバイルでも強くなっていく&lt;/h3>
&lt;p>特に今年開催された&lt;a class="link" href="https://io.google/2022/intl/ja/" target="_blank" rel="noopener"
>Google I/O&lt;/a>で確認できるように、Flutter 3ではさらにパフォーマンスの向上やFlutter Desktopの正式リリースなど様々な面での発展を見せていて、これからもFlutterの未来は明るく見えます。Flutterを採用している企業も増えてきているので、このような発展の恩恵を受け入れるのは結局時間の問題に過ぎない気がします。もちろん、ネイティブアプリの開発においても需要はこれからもあり得ると思いますが、クロスプラットフォームアプリでも事足りる分野が増えてくるとしたら、どちらがメインストリームになるかは目に見えるようなものですね。&lt;/p>
&lt;p>このような状況では、今の占有率においてKotlinのホームグラウンドとなっていると言っても過言ではないモバイルの分野で、Flutterの成長ぶりはある意味、Kotlinにおいては脅威のようなものではないかという気がします。なので、これからKotlinならではのメリットをより強化していく必要がありそうですね。先の述べたKotlin/Multiplatform Mobileのようなものが、その役割をしてくれるのではないかと期待しています。そのほかでも、Kotlinでできることは多いので、分野を問わない連携を強化していくと十分Kotlinを利用するメリットはこれからも出てくるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は、いつもと違って自分の考えが中心になる記事なので、色々と偏った判断があるかもしれませんが、とりあえずKotlinエンジニアとしての感想をまとめてみました。もちろん、自分の知見が足りてなく、モバイルやフロントエンド、データサイエンティスト、DevOpsエンジニアなど色々な分野で活躍されている方からしたら色々と間違っているか、的確ではない情報や判断も目立つかなとも思います。&lt;/p>
&lt;p>ただ、一人のエンジニアとして、ただの時流を淡々と見つめているよりは、目指す目標に対して使っている技術や興味のいくものに注目し、自分なりの判断をしてみるのもまた必要なものではないかという気がして、このような記事を作成することになりました。また、このような記事を作成することで、この後に色々な変化があって自分の展望がどれだけあっているか、実際と比べてみるのもまた有意義な振り返りとなりそうな気もします。&lt;/p>
&lt;p>今回はあまり情報がなく、Twitterにでもつぶやいたら良いかも知れない雑談に近いものですが、少しでもここでKotlinのことを改めて認識できたという方がいらっしゃるなら幸いです。&lt;/p>
&lt;p>では、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a class="link" href="https://spectrum.ieee.org/top-programming-languages" target="_blank" rel="noopener"
>IEEE Spectrum&lt;/a>、&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE&lt;/a>、&lt;a class="link" href="https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-programming-scripting-and-markup-languages" target="_blank" rel="noopener"
>Stack Overflow&lt;/a>、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/#Main_programming-languages" target="_blank" rel="noopener"
>Jetbrains&lt;/a>の調査結果を参照しました。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Warm(アイドルインスタンスを常に立ち上げておく)で対応できる部分ではありますが、スケールアウトするとコールドスタートが必要となる場合があり、インスタンスを立ち上げておくことでコストがかかる問題は避けられないですね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>Dartのような言語でJavaScriptを代替しようとした歴史がありますが、今は失敗していて、JavaScriptがより高度化した今はTypeScriptのようなスーパーセットやJavaScriptにトランスパイルできる言語でないとフロントエンドの言語を代替するのは難しいかと思われます。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>色々な言語でやってみた（ソート編）</title><link>https://retheviper.github.io/posts/languages-comparsion-sorting/</link><pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/languages-comparsion-sorting/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.jpg" alt="Featured image of post 色々な言語でやってみた（ソート編）" />&lt;p>今はどんなプログラミング言語を選んでもできることはあまり違わなく、まさに好みで選んでもいいと思えるくらいの時代となっていると思います。特に、&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>のようなトランスパイラーやFlutterのようなフレームワークも続々と登場している時代なので、こういう傾向はこれからもどんどん加速していくのではないかと思います。&lt;/p>
&lt;p>しかしそのような変化がある一方で、今現在はプログラマに一人が扱えるプログラミング言語の数に対する要求も増えいている状況ではないかと思います。実際の業務ではさまざまな理由で使われる言語が決まっていて、自分が今まで触ったことのないものでも使えるようになる必要があり、一人のエンジニアが固定されたポジションでなく、さまざまな分野にかけて実装を行うケースもありますしね。いわゆる&lt;a class="link" href="https://en.wikipedia.org/wiki/Polyglot_%28computing%29" target="_blank" rel="noopener"
>Polyglot&lt;/a>の時代とも言えます。&lt;/p>
&lt;p>なので、少なくともいろいろな言語の特徴を把握しておくということが大事になっているのではないかと思います。そして、そのような必要によるものでなくても、自分が普段接してない言語のコンセプトに触れてみることで、メインとなる言語への理解が深まることもあるのではないのかなと思ったりもします。これはどんな言語でもできることはあまり変わらないということともある意味通じているのですが、他の言語のコンセプトを受け入れた新しいAPIや機能を導入したり、そのようなライブラリが登場する場合もあるので。&lt;/p>
&lt;p>さて、前置きが長くなりましたが、ということで、これからはたまにとある操作をするときにいろいろな言語ではどうやってできるのか、そしてそうした場合の特徴などを簡単に比べてみたいと思います。今回は、配列のソートになります。&lt;/p>
&lt;h2 id="javascript">JavaScript&lt;/h2>
&lt;p>JavaScriptでは&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener"
>Array.prototype.sort()&lt;/a>で配列のソートができます。なので、以下のようなコードを使えます。シンプルですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">sort&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、元の配列の値は変更せず、新しくソートされた配列を作りたい場合は以下の方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [...&lt;span style="color:#a6e22e">a&lt;/span>].&lt;span style="color:#a6e22e">sort&lt;/span>() &lt;span style="color:#75715e">// aをコピーしてソート
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここで気づいた方もいらっしゃると思いますが、ソートされた値が期待通りにはなっていません。本当なら、&lt;code>1, 22, 44, 300, 5000&lt;/code>になるのが普通でしょう。ここで昇順に値をソートしたい場合は、ソートの方法を自前で作成する必要があります。例えば以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">sort&lt;/span>((&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span>) =&amp;gt; &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>sort()&lt;/code>では、引数として渡す&lt;code>compareFunction&lt;/code>（引数が二つ、戻り値はnumber）の戻り値の結果によって、以下のことが起こります。&lt;/p>
&lt;ul>
&lt;li>0より小さいと、aのインデックスをbの先に置く&lt;/li>
&lt;li>0だと、aとbは変更しない&lt;/li>
&lt;li>0より大きいと、bのインデックスをaの先に置く&lt;/li>
&lt;/ul>
&lt;p>これはJavaをやっていた方だと、&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener"
>Comparator&lt;/a>と同じだなとすぐわかる内容ですね。アロー関数の形もJavaのLambdaに似ているので、あまり違和感なく適応できるかと思います。かなりシンプルなのですが、number型の配列に対しては自前の&lt;code>compareFunction&lt;/code>が必要となるということは大事なので、気を付ける必要はあるでしょう。&lt;/p>
&lt;p>配列のインデックスを反転したい場合は、&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener"
>Array.prototype.reverse()&lt;/a>を使うだけで良いです。この場合はnumberの配列でも自前の&lt;code>compareFunction&lt;/code>が必要ないので、便利ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">reverse&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#ae81ff">5000&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="java">Java&lt;/h2>
&lt;p>では、次にJavaの方も見ていきましょう。先に述べた通り、&lt;code>Comparator&lt;/code>を使うと簡単にソートの方法を実装できるので、基本的には同じです。ただ、Javaの場合だとそもそも&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#sort-java.util.Comparator-" target="_blank" rel="noopener"
>List.sort()&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Collections.html#sort-java.util.List-" target="_blank" rel="noopener"
>Collections.sort()&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Arrays.html#sort-int:A-" target="_blank" rel="noopener"
>Arrays.sort()&lt;/a>、[Stream.sorted()]など方法が色々あり、ソートしたいCollectionやArrayなどが&lt;code>Immutable&lt;/code>であるかどうか、&lt;code>Comparator&lt;/code>や&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener"
>Comparable&lt;/a>を自前で実装するか、それともスタンダードライブラリに用意されてあるものを使うかなどのさまざまな選択肢も考慮する必要があるということですね。&lt;/p>
&lt;p>色々な選択肢がある中で、もっとも簡単なのは、&lt;code>Collections.sort()&lt;/code>や&lt;code>Arrays.sort()&lt;/code>を使う方法かなと思います。これを使う場合、primitive型やStringのListは短いコードでソートができるという（そして標準機能という）メリットがありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> var a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;()&lt;/span> &lt;span style="color:#f92672">{{&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>22&lt;span style="color:#f92672">);&lt;/span> add &lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">);&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>44&lt;span style="color:#f92672">);&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>300&lt;span style="color:#f92672">);&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>5000&lt;span style="color:#f92672">);&lt;/span> &lt;span style="color:#f92672">}};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> Collections&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">,&lt;/span> 22&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、&lt;code>List.sort()&lt;/code>が簡単です。&lt;code>Comparator&lt;/code>を引数として渡す必要がありますが、昇順・降順でソートしたい場合は既に用意されてあるメソッドを呼び出すだけですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> var a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;()&lt;/span> &lt;span style="color:#f92672">{{&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>22&lt;span style="color:#f92672">);&lt;/span> add &lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">);&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>44&lt;span style="color:#f92672">);&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>300&lt;span style="color:#f92672">);&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>5000&lt;span style="color:#f92672">);&lt;/span> &lt;span style="color:#f92672">}};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> a&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Comparator&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">naturalOrder&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">,&lt;/span> 22&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに&lt;code>Comparator&lt;/code>で使える既定のソート方法は以下があります。&lt;/p>
&lt;ul>
&lt;li>昇順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#naturalOrder--" target="_blank" rel="noopener"
>naturalOrder()&lt;/a>&lt;/li>
&lt;li>降順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#reverseOrder--" target="_blank" rel="noopener"
>reverseOrder()&lt;/a>&lt;/li>
&lt;li>逆順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#reversed--" target="_blank" rel="noopener"
>reversed()&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>また、&lt;code>Comparator&lt;/code>は、&lt;code>Collections.sort()&lt;/code>の引数としても使えます。なので、降順にソートしたい場合は以下のようなコードを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> var a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;()&lt;/span> &lt;span style="color:#f92672">{{&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>22&lt;span style="color:#f92672">);&lt;/span> add &lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">);&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>44&lt;span style="color:#f92672">);&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>300&lt;span style="color:#f92672">);&lt;/span> add&lt;span style="color:#f92672">(&lt;/span>5000&lt;span style="color:#f92672">);&lt;/span> &lt;span style="color:#f92672">}};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> Collections&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">,&lt;/span> Comparator&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">reverseOrder&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>5000&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 22&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、元のListの値を変更せず、新しくソートされた結果を取得したい場合は、元のListをコピーする方法もありますが、もう一つの方法として&lt;code>Stream&lt;/code>を使う方法を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> var a &lt;span style="color:#f92672">=&lt;/span> List&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">of&lt;/span>&lt;span style="color:#f92672">(&lt;/span>22&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> var b &lt;span style="color:#f92672">=&lt;/span> a&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">stream&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">sorted&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">collect&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Collectors&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toList&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">,&lt;/span> 22&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Stream&lt;/code>でソートする場合でも、&lt;code>Comparator&lt;/code>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> var a &lt;span style="color:#f92672">=&lt;/span> List&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">of&lt;/span>&lt;span style="color:#f92672">(&lt;/span>22&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> var b &lt;span style="color:#f92672">=&lt;/span> a&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">stream&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">sorted&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Comparator&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">reverseOrder&lt;/span>&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">collect&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Collectors&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toList&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>5000&lt;span style="color:#f92672">,&lt;/span> 300&lt;span style="color:#f92672">,&lt;/span> 44&lt;span style="color:#f92672">,&lt;/span> 22&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、DTOのListをソートしたい場合は、DTOが&lt;code>Comparable&lt;/code>を継承するという方法も考えられますが、多くの場合はソート時の条件が明確にわかる&lt;code>Comparator&lt;/code>を実装したいいかなと思います。汎用性や柔軟性を考えても、&lt;code>Comparable&lt;/code>の場合、条件が変わるとクラスを修正する必要があるので、&lt;code>Comparator&lt;/code>を使った方が無難かなと思います。&lt;/p>
&lt;p>Arrayの場合、&lt;code>Arrays.sort()&lt;/code>を利用してソートできる（もちろん&lt;code>Comparator&lt;/code>も使えます）上に、ListやStreamに変換することもできるので上記の方法をそのまま使えます。なので選択肢はもっと多いわけですが、便利な（好みに合う）方法を選ぶといいかなと思います。個人的には&lt;code>Arrays.sort()&lt;/code>に&lt;code>Comparator&lt;/code>を渡した方が可読性という面で良さそうな気がします。&lt;/p>
&lt;h2 id="kotlin">Kotlin&lt;/h2>
&lt;p>Sytax Sugarをたくさん提供しているKotlinらしく、選べるソートのオプションがたくさんあります。なので、少しまとめてみました。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Orderの種類&lt;/th>
&lt;th>ソート結果&lt;/th>
&lt;th>fun&lt;/th>
&lt;th>備考&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Natural&lt;/td>
&lt;td>呼び出し元&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort.html" target="_blank" rel="noopener"
>Array/MutableList.sort()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-descending.html" target="_blank" rel="noopener"
>Array/MutableList.sortDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reverse.html" target="_blank" rel="noopener"
>Array/MutableList.reverse()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Array&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array.html" target="_blank" rel="noopener"
>Array.sortedArray()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array-descending.html" target="_blank" rel="noopener"
>Array.sortedArrayDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reversed-array.html" target="_blank" rel="noopener"
>Array.reveredArray()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted.html" target="_blank" rel="noopener"
>Array/List.sorted()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-descending.html" target="_blank" rel="noopener"
>Array/List.sortedDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/as-reversed.html" target="_blank" rel="noopener"
>List/MutableList.asRevered()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Custom&lt;/td>
&lt;td>呼び出し元&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-by.html" target="_blank" rel="noopener"
>Array/MutableList.sortBy()&lt;/a>&lt;/td>
&lt;td>昇順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-by-descending.html" target="_blank" rel="noopener"
>Array/MutableList.sortByDescending()&lt;/a>&lt;/td>
&lt;td>降順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by.html" target="_blank" rel="noopener"
>Array/Iterable.sortedBy()&lt;/a>&lt;/td>
&lt;td>昇順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by-descending.html" target="_blank" rel="noopener"
>Array/Iterable.sortedByDescending()&lt;/a>&lt;/td>
&lt;td>降順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Array&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array-with.html" target="_blank" rel="noopener"
>Array.sortedArrayWith()&lt;/a>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/" target="_blank" rel="noopener"
>Comparator&lt;/a>必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-with.html" target="_blank" rel="noopener"
>Array/Iterable.sortedWith()&lt;/a>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/" target="_blank" rel="noopener"
>Comparator&lt;/a>必要&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>かなり多い選択肢があるように見えますが、こうやって表としてまとめてみるとまぁまぁわかりそうな気はします。自前の比較処理を書く必要があるか、ソートした結果が元の配列かどうか、そしてArrayになるかListになるかなどいくつかの基準で分けられるということが分かれば大体どれを使った方がいいか悩む必要はないかなと思います。&lt;/p>
&lt;p>なので、まずやりたいことを明確にした上で、どのAPIを使うかを選んで書くだけです。以下はListから、ソートされた新しいListを作成する例です。それぞれ昇順と降順の場合となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> a = listOf(&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> b = a.sorted()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[1, 22, 44, 300, 5000]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> c = a.sortedDescending()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[5000, 300, 44, 22, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、data classの配列をソートしたい場合は&lt;code>sortBy&lt;/code>や&lt;code>sortedBy&lt;/code>を使えます。ここで引数に必要なのは&lt;code>(T) -&amp;gt; R&lt;/code>型のselectorですが、単純にどれを基準にソートするかを指定すれば良いだけですので実装は簡単です。以下の例を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> number: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> a = listOf(Data(&lt;span style="color:#ae81ff">22&lt;/span>), Data(&lt;span style="color:#ae81ff">1&lt;/span>), Data(&lt;span style="color:#ae81ff">44&lt;/span>), Data(&lt;span style="color:#ae81ff">300&lt;/span>), Data(&lt;span style="color:#ae81ff">5000&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> b = a.sortedBy { &lt;span style="color:#66d9ef">it&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Data(number=1), Data(number=22), Data(number=44), Data(number=300), Data(number=5000)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> c = a.sortedByDescending { &lt;span style="color:#66d9ef">it&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Data(number=5000), Data(number=300), Data(number=44), Data(number=22), Data(number=1)]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、より複雑な比較の条件を指定したい場合はJavaの場合と同じく、&lt;code>Comparator&lt;/code>を実装すると良いでしょう。やはりJavaと似ているようで、より単純化した（そしてそのせいで選択肢は増えた）感覚ですね。&lt;/p>
&lt;h2 id="swift">Swift&lt;/h2>
&lt;p>Swiftでは、シンプルに元のCollectionをソートするかソートされた新しいCollectionを作るかの選択肢しかないようです。あまり変わったことはないですが、元のCollectionをソートする場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">var&lt;/span> a = [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a: [Int] = &lt;span style="color:#ae81ff">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">0&lt;/span>] = &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">1&lt;/span>] = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">2&lt;/span>] = &lt;span style="color:#ae81ff">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">3&lt;/span>] = &lt;span style="color:#ae81ff">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">4&lt;/span>] = &lt;span style="color:#ae81ff">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>&amp;gt; a.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span>&amp;gt; print(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして新しいCollectionを作成したい場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">let&lt;/span> a = [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a: [Int] = &lt;span style="color:#ae81ff">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">0&lt;/span>] = &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">1&lt;/span>] = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">2&lt;/span>] = &lt;span style="color:#ae81ff">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">3&lt;/span>] = &lt;span style="color:#ae81ff">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">4&lt;/span>] = &lt;span style="color:#ae81ff">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">let&lt;/span> b = a.sorted()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b: [Int] = &lt;span style="color:#ae81ff">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">0&lt;/span>] = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">1&lt;/span>] = &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">2&lt;/span>] = &lt;span style="color:#ae81ff">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">3&lt;/span>] = &lt;span style="color:#ae81ff">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">4&lt;/span>] = &lt;span style="color:#ae81ff">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span>&amp;gt; print(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Swiftのソートが独特なのはどうやってソートするか、その方法を指定する時です。&lt;a class="link" href="https://developer.apple.com/documentation/swift/array/2296801-sort" target="_blank" rel="noopener"
>sort()&lt;/a>でも&lt;a class="link" href="https://developer.apple.com/documentation/swift/array/2296815-sorted" target="_blank" rel="noopener"
>sorted()&lt;/a>でも引数として&lt;code>areInIncreasingOrder&lt;/code>という関数を渡すことができるようになっていますが、JavaScriptやJava、Kotlinで使われていた&lt;code>compareFunction&lt;/code>や&lt;code>Comparator&lt;/code>の戻り値が数字であったことに対して、&lt;code>areInIncreasingOrder&lt;/code>はpredicate型として戻り値がBoolになっています。なので以下のような形でソートの方法を指定可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> students: Set = [&lt;span style="color:#e6db74">&amp;#34;Kofi&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Abena&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Peter&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Kweku&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Akosua&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> descendingStudents = students.sorted(by: &lt;span style="color:#f92672">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(descendingStudents) &lt;span style="color:#75715e">// &amp;#34;[&amp;#34;Peter&amp;#34;, &amp;#34;Kweku&amp;#34;, &amp;#34;Kofi&amp;#34;, &amp;#34;Akosua&amp;#34;, &amp;#34;Abena&amp;#34;]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、classのフィールドを基準にソートしたい場合は以下の方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span> { &lt;span style="color:#66d9ef">var&lt;/span> number = &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> datas = [Data(number: &lt;span style="color:#ae81ff">1&lt;/span>), Data(number: &lt;span style="color:#ae81ff">3&lt;/span>), Data(number: &lt;span style="color:#ae81ff">4&lt;/span>), Data(number: &lt;span style="color:#ae81ff">2&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> descending = datas.sorted { $0.number &lt;span style="color:#f92672">&amp;gt;&lt;/span> $1.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dump(descending)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> descending: [Data] = 4 values {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> [0] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> number = 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> [1] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> number = 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> [2] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> number = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> [3] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> number = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="go">Go&lt;/h2>
&lt;p>Goにはジェネリックがないからか、&lt;a class="link" href="https://pkg.go.dev/sort" target="_blank" rel="noopener"
>sort&lt;/a>というパッケージに、sliceの種類によってソート用のfuncが色々と用意されています。例えば以下のようなものがあります。&lt;/p>
&lt;ul>
&lt;li>func Float64s(x []float64)&lt;/li>
&lt;li>func Ints(x []int)&lt;/li>
&lt;li>func Strings(x []string)&lt;/li>
&lt;/ul>
&lt;p>なので、structのsliceではい場合はこれらの中でどれかを選んでソートすることになりますね。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Ints&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>) &lt;span style="color:#75715e">// [1 22 44 300 5000]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>structの場合は、以下のような方法が使えます。ソートの基準がまた&lt;code>bool&lt;/code>になっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">people&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Gopher&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">55&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Vera&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">24&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Slice&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">Name&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>].&lt;span style="color:#a6e22e">Name&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>) &lt;span style="color:#75715e">// [{Alice 55} {Bob 75} {Gopher 7} {Vera 24}]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>面白いのは、Goのソートには&lt;a class="link" href="https://pkg.go.dev/sort#SliceStable" target="_blank" rel="noopener"
>sort.SliceStable()&lt;/a>というものが別に存在しているということです。これは&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%AE%89%E5%AE%9A%E3%82%BD%E3%83%BC%E3%83%88" target="_blank" rel="noopener"
>安定ソート&lt;/a>を行うもので、その定義に関してはWikiでは以下のように述べています。&lt;/p>
&lt;blockquote>
&lt;p>同等なデータのソート前の順序が、ソート後も保存されるものをいう。つまり、ソート途中の各状態において、常に順位の位置関係を保っていることをいう。&lt;/p>
&lt;/blockquote>
&lt;p>つまり、安定ソートの場合、ソートの基準となる値が同等の要素間の元の位置関係（インデックス）が保証されるということですね。その結果が実際どうなるのかを見てみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">people&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Elizabeth&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Colin&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Elizabeth&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">SliceStable&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">Age&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>].&lt;span style="color:#a6e22e">Age&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>) &lt;span style="color:#75715e">// [{Alice 25} {Bob 25} {Colin 25} {Elizabeth 25} {Alice 75} {Alice 75} {Bob 75} {Elizabeth 75}]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードの実行結果でわかるように、&lt;code>Alice 25&lt;/code>、&lt;code>Bob 25&lt;/code>、&lt;code>Colin 25&lt;/code>、&lt;code>Elizabeth 25&lt;/code>と&lt;code>Alice 75&lt;/code>, &lt;code>Bob 75&lt;/code>, &lt;code>Elizabeth 75&lt;/code>の元の順が維持されたままソートされたのがわかります。ここでもし&lt;code>sort.Slice()&lt;/code>を使うと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Slice&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">Name&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>].&lt;span style="color:#a6e22e">Name&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>) &lt;span style="color:#75715e">// [{Alice 25} {Alice 75} {Alice 75} {Bob 75} {Bob 25} {Colin 25} {Elizabeth 75} {Elizabeth 25}]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安定ソートはそうでないソートに比べ性能が劣る可能性が高いので（元のインデックスをまで考慮しているので）、一つの値を基準にソートしても問題ない場合は&lt;code>sort.Slice()&lt;/code>でも十分な気がしますが、そうでない場合は安定ソートを考慮する必要がありそうですね。&lt;/p>
&lt;h2 id="python">Python&lt;/h2>
&lt;p>Pythonでは&lt;a class="link" href="https://docs.python.org/3/library/stdtypes.html#list.sort" target="_blank" rel="noopener"
>list.sort()&lt;/a>か、&lt;a class="link" href="https://docs.python.org/3/library/functions.html#sorted" target="_blank" rel="noopener"
>sorted()&lt;/a>を使えます。他の言語でも大体同じだったので命名だけでも推測が可能かと思いますが、前者は元のlistをソートするもので、後者は新しいlistを作り出すものです。&lt;/p>
&lt;p>まず&lt;code>list.sort()&lt;/code>は、以下のように使えます。他の言語とあまり変わらないですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a&lt;span style="color:#f92672">.&lt;/span>sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> print(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>それに対して、&lt;code>sorted()&lt;/code>は以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> sorted(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> print(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、これらの関数では&lt;code>key&lt;/code>や&lt;code>reverse&lt;/code>のようなパラメータを指定することで、どれを基準にソートするか、逆順にソートするかなどを指定できます。Pythonらしいシンプルさですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, number):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>number &lt;span style="color:#f92672">=&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __repr__(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> repr((self&lt;span style="color:#f92672">.&lt;/span>number))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datas &lt;span style="color:#f92672">=&lt;/span> [Data(&lt;span style="color:#ae81ff">1&lt;/span>), Data(&lt;span style="color:#ae81ff">3&lt;/span>), Data(&lt;span style="color:#ae81ff">2&lt;/span>), Data(&lt;span style="color:#ae81ff">4&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datas&lt;span style="color:#f92672">.&lt;/span>sort(key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">lambda&lt;/span> data: data&lt;span style="color:#f92672">.&lt;/span>number) &lt;span style="color:#75715e"># [1, 2, 3, 4]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sorted(datas, key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">lambda&lt;/span> data: data&lt;span style="color:#f92672">.&lt;/span>number, reverse&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>) &lt;span style="color:#75715e"># [4, 3, 2, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="番外stable-sort">番外：Stable sort&lt;/h2>
&lt;p>Goのソート方法の中で少し安定ソートの話が出ましたが、ここで比較した他の言語だとGoのように安定ソートとそうでないソートのどれを使うかという選択肢がなかったので、それぞれの言語での安定ソートはどうやって扱われているのかを表にしてみました。以下をご覧ください。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>言語&lt;/th>
&lt;th>stable&lt;/th>
&lt;th>non-stable&lt;/th>
&lt;th>備考&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Go&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>funcによって選べられる&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Java&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>Streamはnon-stable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>JavaScript&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>ブラウザのバージョンによる&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Python&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kotlin&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>SequenceでもStable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Swift&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>&lt;code>stableを保証できない&lt;/code>と表現&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>多くの言語が安定ソートに対応していますが、少しづつ仕様が違う場合がありました。例えばJavaの場合、Streamによるソートは安定ソートではないため、安定ソートの結果を保証したい場合は既にソートされたCollectionを使うことをおすすめしています。Kotlinの場合はStreamに似たSequenceを使う場合でも、&lt;code>stateful&lt;/code>なためか、安定ソートに対応していました。&lt;/p>
&lt;p>また、JavaScriptの場合はブラウザのバージョンによって違いますが、最新のブラウザを使っている場合は大抵安定ソートに対応していました。ただ、JavaScirptを使った案件の場合はIEも対象ブラウザとして考慮される場合があるのですが、IEだと安定ソートに対応していないので確認が必要かなと思います。&lt;/p>
&lt;p>Swiftの場合はまだソート時のデフォルト値をstableにするかどうかを検討している中で、APIとしてもGoのようにstableとそうでないものを分離するかどうかを検討しているらしいです。またどのアルゴリズムを使うかについて議論しているらしく、しばらくは安定ソートを期待できないかと思います。&lt;/p>
&lt;p>KotlinとPythonはどの場合でも安定ソートとなるので、悩み事が一つ減るのが嬉しいですね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は色々な言語のソートについて調べてみましたが、いかがでしたか。一度ソートしたデータはその後の要素に対するアクセスが早くなるので、チューニングの観点からは必要なものかと思います。そしてこうやって色々な言語のソートのAPIを調べてみると、その言語の設計思想や発展の過程のようなものが少し見えるようで面白く、勉強にもなりますね。個人的にはあまり意識してなかった安定ソートがかなり勉強になりました。&lt;/p>
&lt;p>これからもこうやって色々な言語の使用やAPI、同じことをする場合の各言語による違いなどを比べてみたいと思います。時間と体力が十分であればの話ではありますが…！&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>個人的な2021年のロードマップ</title><link>https://retheviper.github.io/posts/my-roadmap-in-2021/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/my-roadmap-in-2021/</guid><description>&lt;img src="https://retheviper.github.io/images/map.jpg" alt="Featured image of post 個人的な2021年のロードマップ" />&lt;p>エンジニアとして働いていると会社の方針・クライアントの要求・経歴のような、自分の意思以外のところから自分の技術スタックを決まってしまう場合が決して少なくないと思います。会社は利益集団なので、致し方ないのですが、個人としてはどうでしょうか。私は、エンジニアは常にトレンドとともに前に進むべき職種なので、業務としてはあまり機会がないとしても、やはり自分で何かロードマップを立てて、独学でもスキルアップを図るべきたと思っています。&lt;/p>
&lt;p>例えば私は、どんな案件でも主にJavaとSpringのサーバサイドエンジニアか、Jenkins・Shell・Linuxを触るインフラエンジニアとして働いたことが多いのですが、何か一つは自分のアプリやサービスを作ってみたいと思っています。このような目標ないしは願望がある場合、それを成すためには何が必要か、と考えるようになり、そこから適合なプラットフォームは？言語は？フレームワークは？という風に考え始めて、そのうちでもっとも自分にとって合理的な道を選ぶようになります。何が合理的か、という基準は人それぞれですが(主観だけで決められるものでもないし)、会社が自分のエンジニアとしての目標を考えてくれる可能性は低いので、とにかくこういう目標設定は自分でなすべきでしょう。&lt;/p>
&lt;p>そういう意味で、今年の自分のロードマップを、「やりたいこと」と「良さそうなこと」という基準からいくつか立ててみました。まだロードマップとしては何一つ計画を具体化してないので、ただの興味に近いものなのかもしれませんが…とにかく、今の時点で興味を持っているものや考えていることについて、Google Trendを持って語ります。軽く、「こいつは2021年にこういうものに注目するんだな」と思ってください。&lt;/p>
&lt;h2 id="言語">言語&lt;/h2>
&lt;h3 id="typescript">TypeScript&lt;/h3>
&lt;p>いつまでになるかはわかりませんが、少なくともここ数年はJavaScriptの天下が続きそうですね。ただ、なぜそうかというと、Webの標準であるという強力な基盤がある上に、今はNode.jsやElectronのおかげでブラウザ以外でも使える場面が多いから、ということだけでは説明が難しくなりつつあるという側面もある印象です。今はもはやコーディングを学び始めるきっかけや入門の言語としてJavaScriptに触れるケースが多いし、SPAの登場以来からサーバサイドよりもフロントエンドの重要さが増してきたという感覚でもありますね。アプリケーションというのは、結局はユーザのためにデザインされるものであるということを考えると、より画面に密接な言語が持つ権限の方が大きくなるのは当然なのかもしれません。&lt;/p>
&lt;p>そしてバックエンドだけをみるとしても、最近はなるべくサーバサイドの役割を減らしていくか、細かく分けていく感覚ですね。&lt;a class="link" href="https://www.redhat.com/ja/topics/microservices" target="_blank" rel="noopener"
>マイクロサービス&lt;/a>、&lt;a class="link" href="https://www.atmarkit.co.jp/ait/articles/1803/12/news012.html" target="_blank" rel="noopener"
>BFF&lt;/a>、サーバレスのようなキーワードが流行っているのがその証拠だと思います。もちろんJavaScriptという言語そのものの発達によるものもあるとは思いますが、アプリケーションのアーキテクチャやデザインの思想そのものが変わっているので、仕方ないことです。&lt;/p>
&lt;p>そこで、少なくともJavaScriptは基礎だけでもできるようにしないと、と思いました。研修などで簡単な文法については学んだことがありますが、本格的なアプリを書いた経験はあまりなかったので、少なくとも&lt;a class="link" href="https://expressjs.com" target="_blank" rel="noopener"
>Express&lt;/a>で簡単なREST APIを作ってみるとかの経験はかなり役立つかもしれません。また、フロントエンドも少しは触れるようになるとよりいいでしょう。&lt;/p>
&lt;p>このように思ったときに、目に入ってきたのがTypeScriptでした。TypeScriptは以前、Udemyの講座で接したことがあり、気に入っていましたが、最近はかなり人気を得ているらしいですね。実際どうかは、まずGoogle Trendで確認してみました。&lt;/p>
&lt;script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2431_RC04/embed_loader.js">&lt;/script>&lt;script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"typescript","geo":"","time":"today 5-y"}],"category":0,"property":""}, {"exploreQuery":"date=today%205-y&amp;q=typescript","guestPath":"https://trends.google.com:443/trends/embed/"}); &lt;/script>
&lt;p>結果をみると、確かにTypeScriptに対する興味は日々増えていっているような気がします。おそらくAngular・React・Vueのような有名フレームワークやライブラリからTypeScriptに公式対応し始めたのも理由と思いますし、やはり静的型付けの方が生産性が上がるというところがわかったきたからなのでしょう。私はJavaから触れた人間なので、静的型付けのできるTypeScriptの方を学んだ方が良いかなと思います。&lt;/p>
&lt;h3 id="go-or-rust">Go or Rust&lt;/h3>
&lt;p>個人的には、JVM言語が好きですが、やはり高水準言語&amp;amp;VMを挟む構造ということもあり、より低水準に近い言語も扱ってみたいと思っています。今すぐに必要なわけではないのですが、やはりハードウェア制御やバイナリデータを扱うなど、低水準言語ならではのことがやってみたいという純粋な好奇心が理由です。最近はIOTなどでC言語の人気も高くなっていたりしますが、組み込み系ならまだしも、いわゆる「応用ソフトウェア」を開発する身としては、CやC++、もしくはそれよりも古い言語よりは、GoやRustのような言語に触れてみた方が良さそうな気もします。&lt;/p>
&lt;p>ただ、悩ましいのは、それでGoとRustのうち、どれを選ぶかということです。性能だけを考えたら、当然Rustなのかもしれません。多くの場合、Rustが性能ではGoより優れていると言われていますね。実際の例として、音声チャットツールで有名な&lt;a class="link" href="https://discord.com/" target="_blank" rel="noopener"
>Discord&lt;/a>はGoからRustに移行しましたが、これが&lt;a class="link" href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f" target="_blank" rel="noopener"
>性能のため&lt;/a>だったと言っています。ただ、言語を学ぶこと自体の難易度は、やはりRustの方がGoより高いらしいですね。そして一般的に、生産性の方はGoが優れていると言われています。&lt;/p>
&lt;p>なので、以上のことから、自分は何をやってみたらいいのかなと思ってみた結果、CやC++に近い低水準言語の感覚としてRustを触ってみたらどうかな、と思いました。どちらもマイナーな言語ではありますが、&lt;a class="link" href="https://insights.stackoverflow.com/survey" target="_blank" rel="noopener"
>Stack Overflow survey&lt;/a>にて、数回も「もっともエンジニアから愛された言語」として選ばれたこともあるRustの方が、これからコミュニティの成長も期待できるのではないかなと思ったからでもあります。特に&lt;a class="link" href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved" target="_blank" rel="noopener"
>2020年の結果&lt;/a>は、86.1%というすごい結果になっているくらいですので。&lt;/p>
&lt;p>しかし、まだ実務レベルでよく使われているのはやはりGoの方で、リファレンスの量やエンジニアの興味という面でも(仕事で使うとしたら仕方ないのですが)、Goの方がまだ少し優勢ではないのかという気もします。Rustが最初からCやC++の代替を目標としてデザインされた言語であることに比べ、Goという言語がどこまでそのような役割ができるのかというのはまだあまりわかってないのですが、もし同じようなことできるのであれば、あえてRustにこだわる必要はないのではないかと思ったりもしますね。特に、ある言語の成長性というのは、そのコミュニティの大きさにも関係するので…なので、とりあえずGoogle Trendの方で、二つの言語に対する興味度について調べてみました。&lt;/p>
&lt;p>Goの場合は一般動詞(行く)と区別するため、多くの場合&lt;code>golang&lt;/code>で検索するケースが多いらしいです。しかし、Rustもあまり状況は変わってなくて(しかも、ゲーム名としても使われているようですね)、&lt;code>rustlang&lt;/code>という検索語はあまり使われてないと思うので、直接的な比較が難しいですね。なので、なるべく価値中立的なキーワードとして、&lt;code>go programming&lt;/code>と&lt;code>rust programming&lt;/code>を選んでみました。そしてその結果が、以下です。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "go programming", geo: "", time: "today 5-y" },
{ keyword: "rust programming", geo: "", time: "today 5-y" },
],
category: 0,
property: "",
},
{ exploreQuery: "date=today%205-y&amp;q=go%20programming,rust%20programming", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>結果だけをみると、やはりRustの方がすごい人気を得ているように見えますが、まだGoの方が優位にはありますね。なので、こちらの方が(急ぎでもないので)、もう少し観望しながら、ゆっくり決めようと思っています。&lt;/p>
&lt;h3 id="kotlin">Kotlin&lt;/h3>
&lt;p>今はJavaのいう&lt;code>Write once, run everywhere&lt;/code>が、どの言語でも同じようなことができていて(逆にJavaでできない分野はありますが)、それでもJVM言語は依然として魅力的だと思っています。最初からJVMがヒープを設定するのでメモリ管理という面でも安定的で、パフォーマンスも今流行りの高水準言語に比べても優秀な方ですね。また、10年以上世界でもっとも人気な言語だったので、ライブラリ・フレームワーク・リファレンスも豊富ですね。また、バイトコードだけを生成すればいいので、コンパイルする前の言語はどれでも良いです。なのでJava以外でも&lt;a class="link" href="https://www.scala-lang.org" target="_blank" rel="noopener"
>Scala&lt;/a>、&lt;a class="link" href="https://clojure.org" target="_blank" rel="noopener"
>Clojure&lt;/a>、&lt;a class="link" href="https://groovy-lang.org" target="_blank" rel="noopener"
>Groovy&lt;/a>、&lt;a class="link" href="https://www.jython.org" target="_blank" rel="noopener"
>Jython&lt;/a>、&lt;a class="link" href="https://www.jruby.org" target="_blank" rel="noopener"
>JRuby&lt;/a>、&lt;a class="link" href="https://ceylon-lang.org/" target="_blank" rel="noopener"
>Ceylon&lt;/a>、&lt;a class="link" href="https://github.com/Frege/frege" target="_blank" rel="noopener"
>Frege&lt;/a>、&lt;a class="link" href="https://eta-lang.org" target="_blank" rel="noopener"
>Eta&lt;/a>、&lt;a class="link" href="https://haxe.org" target="_blank" rel="noopener"
>Haxe&lt;/a>のような幾多の言語がJVMを利用できるようになっているわけですね。つまり、JVMこそ死なないが、Javaという言語そのものはこれらの言語のどれかに代替できるというわけです。&lt;/p>
&lt;p>そしていろんな言語の候補があるわけですが、その中でも個人的にはKotlinを選びました。近年のJavaも急激なバージョンアップを重ねながら改善されてはいるものの、実際エンタープライズレベルでそういったバージョンアップの効果を期待できるのはLTSバージョンがでた時だけですね。なので、いますぐ生産性を上げながらもJVMをそのまま利用できるという面では、Kotlinのようなモダンな言語への転換を考えるにはちょうどいい時期なのではないかと思っています。もちろん、私みたいにモバイルアプリの開発を考えているとしたら、尚更ですね。&lt;/p>
&lt;p>他にもGoogle推しの言語であることや、&lt;a class="link" href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener"
>Kotlin/Native&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/docs/reference/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>など他の言語でコンパイルできるという点も良いですね(実際Wantedlyでは、&lt;a class="link" href="https://www.wantedly.com/companies/wantedly/post_articles/282562" target="_blank" rel="noopener"
>すでにKotlin Multiplatformを導入&lt;/a>しているらしいです)。そして何より、Kotlinを開発しているのがJetBrainなので、Intellijでは完璧なサポートができるというところも無視できないメリットです。ほんと少しだけですが、使ってみた鑑賞としても、完成度がかなり高い感じの言語だったので(Swiftよりも)、そのようなところからKotlinの未来はかなり明るいと思っています。&lt;/p>
&lt;h2 id="フレームワーク--ライブラリ">フレームワーク &amp;amp; ライブラリ&lt;/h2>
&lt;h3 id="svelte">Svelte&lt;/h3>
&lt;p>先ほど少しJavaScriptの話をしましたが、JavaScriptそのものの需要や重要性については語るまでもないとはいうものの、そのJavaScriptのフレームワーク・ライブラリはどれが良いかという課題だけは、少なくとも数年でこれが正解と言えるような状態ではないかと思います。ここ数年で幾多のフレームワークやライブラリが生まれ、消えていってますね。幸い、いわゆるフロントエンド3強のAngular・React・Vueの中ではReactが勝者になりつつある雰囲気ではあります。Google Trendの結果も、それを見せていますね。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "angular", geo: "", time: "today 12-m" },
{ keyword: "react", geo: "", time: "today 12-m" },
{ keyword: "vue", geo: "", time: "today 12-m" },
],
category: 0,
property: "",
},
{ exploreQuery: "q=angular,react,vue&amp;date=today 12-m,today 12-m,today 12-m", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>しかし、フロントエンド以外の世界はまた話が違います。まだ多くのフレームワークやライブラリが乱立していて、まるで戦国時代のような様子です。こんななかでは、一体どれを選ぶべきか悩ましいし、判断のための調査だけでもかなりの時間と努力が必要となります。このような状況なので、もう数年前から流行っている言葉なのですが、&lt;a class="link" href="https://www.google.com/search?newwindow=1&amp;amp;biw=1680&amp;amp;bih=836&amp;amp;sxsrf=ALeKk03Q7zTnfCMWJbsybKG4qkODOhqViA%3A1611463509708&amp;amp;ei=VfsMYOPbKpvahwO8zpiwCQ&amp;amp;q=javascript&amp;#43;fatigue&amp;amp;oq=javascript&amp;#43;fatigue&amp;amp;gs_lcp=CgZwc3ktYWIQAzIGCAAQBxAeMgIIADIECAAQHjIECAAQHjIECAAQHjIGCAAQBRAeOgQIIxAnOggIABAIEAcQHjoICAAQBRAKEB46CAgAEAgQChAeOgYIABAIEB46BAgAEBM6CAgAEAcQHhATOgoIABAHEAUQHhATUOeYAVjBwAFgnsQBaAFwAHgAgAGyA4gB8BOSAQkwLjcuMy4xLjGYAQCgAQGqAQdnd3Mtd2l6wAEB&amp;amp;sclient=psy-ab&amp;amp;ved=0ahUKEwij2sGw4bPuAhUb7WEKHTwnBpY4ChDh1QMIDQ&amp;amp;uact=5" target="_blank" rel="noopener"
>JavaScript Fatigue&lt;/a>(JavaScript疲労)という言葉があるくらいです。それだけ現代のJavaScriptを学ぶということは大変なことでしょう。&lt;/p>
&lt;p>例えば私みたいに、ほとんどJavaScriptの経験がない人がフロントエンドエンジニアとなって、Reactがもっとも人気があるからそれをやる、と決めたら、まずNode.jsから初めて、パッケージ管理としてはnpmを使うか、yarnを使うか、言語はJavaScriptそのままにするかそれともTypeScriptにするかを決め、次に必要なものとして&lt;a class="link" href="https://webpack.js.org" target="_blank" rel="noopener"
>Webpack&lt;/a>や&lt;a class="link" href="https://babeljs.io" target="_blank" rel="noopener"
>Babel&lt;/a>、&lt;a class="link" href="https://redux.js.org" target="_blank" rel="noopener"
>Redux&lt;/a>を学ぶなどと、知っておくべきものと学ぶべきものが多いです。しかも、それぞれのフレームワークやライブラリがその名前だけでは何が何だかわからなくなります。&lt;a class="link" href="https://ja.nuxtjs.org" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>はVue基盤のフレームワークだけど、&lt;a class="link" href="https://nestjs.com" target="_blank" rel="noopener"
>Nest.js&lt;/a>はNode.js用のフレームワークですね。そして&lt;a class="link" href="https://nextjs.org" target="_blank" rel="noopener"
>Next.js&lt;/a>はまた、React基盤のフレームワークです。この中では、一体どれを学んだらいいか、どれが良いかというのは混乱するだけです。なのでJavaScriptを扱うエンジニアが、疲労を感じるのも当然のことでしょう。&lt;/p>
&lt;p>自分の場合はすでにサーバサイドの実装がある程度はできるので、フロントエンドも触れるようになって、いわゆるフルスタックとして自分一人でアプリが書けたらいいなと思っています。ただ、会社で使われているフロントエンドのフレームワークがあればそれに触れたら良いのですが、個人レベルでは何が良いかはまだ悩ましいものですね。Reactがもっとも人気だから、やはりそれを選ぶべきか？それもいい選択なのかもしれませんが、これからも本格的にフロントエンドの開発に関わるつもりではない限り、本格的にフロントエンドに時間を投資するのはもったいない気もします。そこで考えた代案が、&lt;a class="link" href="https://svelte.dev" target="_blank" rel="noopener"
>Svelte&lt;/a>でした。&lt;/p>
&lt;p>Svleteの特徴(メリット)としては、色々とありますが、私がもっとも注目したところはかなりシンプルであるというところでした。コードが短いので、書き方に慣れるのが圧倒的に早そうな気がします。そのほかは付加的なメリットとしてよく、とにかく「必要な時にサクッとかける」ものとしては、かなり良さげなものではないかなと思ったりもします。もちろん、ちゃんとしたフレームワークなので、本格的なアプリケーションを作る時も良いでしょう。&lt;/p>
&lt;p>ただデメリットとしては、やはりメジャーな3強に比べてそこまで知られても、使われてもないというところです。幸い、Google Trendで確認したところ、少しづつながら注目を得ているのでこれからな気はします。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{ comparisonItem: [{ keyword: "svelte", geo: "", time: "today 5-y" }], category: 0, property: "" },
{ exploreQuery: "date=today%205-y&amp;q=svelte", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;h3 id="flutter">Flutter&lt;/h3>
&lt;p>今はWebアプリケーションばかり書いている私ですが、モバイルの方にも興味があり、どのような言語とフレームワークがあるかだけは把握しておきたいと思っています。そして最近は、モバイルは多くの場合ネイティブよりもハイブリッド・クロースプラットフォームの方が多くなっているような気がします。正確なデータや統計をみたわけではないのであくまで推測に過ぎないのですが、多くの場合ネイティブアプリに投資する時間や予算の余裕のないスタートアップやベンチャー企業の場合は、とりあえずハイブリッド・クロースプラットフォームを好むような印象です。もちろん、複雑な演算やOS特有の機能を使うとしたらやはりネイティブと言われていますが、個人的な経験からだと、意外とハイブリッド・クロースプラットフォームでもできることは多いのでもうOSレベルでもなく、機器固有の機能を活用する必要がなければ大体ハイブリッド・クロースプラットフォームでも事足りるのでは、と思います。&lt;/p>
&lt;p>(ここで個人的な経験というものは、iOS 14から導入されたウィージェット機能を活かした簡単なアプリを作ってみたいなと思い調べたところ、OS固有の機能なので難しいのではないかと思ったものが、意外とReact NativeやFlutterでも十分できるということがわかったことです)&lt;/p>
&lt;p>そして、昔はただのWebViewでできていたアプリも多かったような気がしますが、それならあえてモバイルアプリとして作る必要がないですね(PWAならわかりますが)。でもそのような形のアプリがあったからか、Webの技術から影響され生まれたバイブリッドモバイルアプリのフレームワークもかなり多いような印象です。なのでJavaScriptでコードを書いたり、JavaScriptのフレームワークを基盤にしてアプリを書けるフレームワークがかなり多いですね。例えば&lt;a class="link" href="https://cordova.apache.org" target="_blank" rel="noopener"
>Apache Cordova&lt;/a>、&lt;a class="link" href="https://ionicframework.com" target="_blank" rel="noopener"
>Ionic&lt;/a>、&lt;a class="link" href="https://nativescript.org" target="_blank" rel="noopener"
>NativeScript&lt;/a>、&lt;a class="link" href="https://reactnative.dev" target="_blank" rel="noopener"
>React Native&lt;/a>がそのようなものです。もちろんJavaScript(Web)とは違う系統、つまり伝統的なデスクトップアプリを継承している印象のフレームワークとしてC#基盤の&lt;a class="link" href="https://dotnet.microsoft.com/apps/xamarin" target="_blank" rel="noopener"
>Xamarin&lt;/a>とDart基盤の&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>がありますね。&lt;/p>
&lt;p>これだけ多いハイブリッド・クロースプラットフォームモバイルアプリ用のフレームワークですが、中でもそろそろ淘汰されてそうな技術はあります。またここでGoogle Trendの結果をみてみましょう。5つの項目しか比較ができないので、Flutterは入れてないです。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "cordova", geo: "", time: "today 5-y" },
{ keyword: "ionic", geo: "", time: "today 5-y" },
{ keyword: "xamarin", geo: "", time: "today 5-y" },
{ keyword: "nativescript", geo: "", time: "today 5-y" },
{ keyword: "react native", geo: "", time: "today 5-y" },
],
category: 0,
property: "",
},
{ exploreQuery: "date=today%205-y&amp;q=cordova,ionic,xamarin,nativescript,react%20native", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>少なくとも、NativeScriptにはあまり興味を持っている人がいなく、XamarinやCordovaの場合もだんだん興味が下がっているのを確認できます。そうすると、残りの結果としてはIonicとReact Nativeが残りますね。先ほどフロントエンドの話を少ししましたが、最近のフロントエンド3強の勝者がReactになりそうという現実からして、Web技術に基盤したハイブリッド・クロースプラットフォームモバイルアプリ用のフレームワークは、やはりReact Nativeが適切かなと思います。&lt;/p>
&lt;p>しかし、問題となるのはFlutterです。FlutterはReact Nativeと比べられる場合が多いですね。なので、FlutterともGoogle Trendで比較してみることにします。結果としてはReact nativeと比べFlutterが優勢な気がしています。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "react native", geo: "", time: "today 5-y" },
{ keyword: "flutter", geo: "", time: "today 5-y" },
],
category: 0,
property: "",
},
{ exploreQuery: "date=today%205-y&amp;q=react%20native,flutter", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>理由として上げられるのは、どちらもiOSとAndroidアプリを同時開発できるものであるという点を踏まえると、やはりパフォーマンス問題ではなかったのかという気がします。React Nativeでは、JavaScriptからネイティブコードを呼び出すという構造から必然的にボトルネックになるしかないと言われていますので。そして、あくまで推測なのですが、Dartという別の言語を採用していながらも、JavaやC#のような言語とかなり文法が似ていて、HTMLやXMLとは違う宣言型でのUIの実装ができるというところも、Flutterならではのメリットなのではないか、という気もします。&lt;/p>
&lt;p>もし自分がモバイルアプリを作るとしたら、おそらくネイティブになる可能性が高いのではないかとは思いますが(ハイブリッド・クロースプラットフォームが必要であれば、大抵Web基盤のアプリで事足りそうなので)、場合によってはハイブリッド・クロースプラットフォームも良い選択肢になるでしょう。そしてFlutterはモバイルだけでなく、より多くのプラットフォームのためのフレームワークとして成長していく予定なので、もし今から学ぶとしたらFlutterの方が良いかもしれません。もちろん、Reactがすでにできるフロントエンドエンジニアだとしたら、React Nativeの方が良いとは思いますが、それ以外の場合はやはりFlutterの方が良さそうな気がします。なので、当面はFlutterを視野に入れておきたいものです。&lt;/p>
&lt;p>そのほかに、React Nativeに関しては興味深い記事がいくつかあったので、いくつかの事例を以下に記載します。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c" target="_blank" rel="noopener"
>React Native at Airbnb&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://engineering.udacity.com/react-native-a-retrospective-from-the-mobile-engineering-team-at-udacity-89975d6a8102" target="_blank" rel="noopener"
>React Native: A retrospective from the mobile-engineering team at Udacity&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://qiita.com/taneba/items/9903064aaaffdf041022" target="_blank" rel="noopener"
>React Nativeを採用すべきか〜Shopifyに学ぶ&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="ハードウェア">ハードウェア&lt;/h2>
&lt;h3 id="apple-silicon-mac">Apple silicon Mac&lt;/h3>
&lt;p>私はもともと20年ほどOSはMicrosoftの製品ばかりを使ってきたものです。それがたまたま、iPhoneやiPadから初めてAppleの製品に触れてから思ったよりも自分との相性がよかったので(仕事でLinuxを使っていたので気軽にターミナルを使えるという点が大きいのですが)、今後も引き続きMacを使いたいと思っています。少なくとも、自分の環境ではMacではないと困ることはあっても、Windowsでないと困ることはあまりないですので。&lt;/p>
&lt;p>なので、自然にApple Silicon Macにも興味を持ったわけなのですが、やはりいきなりCPUのアーキテクチャが変わるということは、やはり互換性を担保できない問題があるので、その問題に対してAppleはどのような形で解決策を出すのだろう、という疑問を持っていました。発表直後に&lt;a class="link" href="https://jp.techcrunch.com/2020/07/11/the-real-reason-why-apple-is-putting-apple-slicon-on-the-mac" target="_blank" rel="noopener"
>色々な記事&lt;/a>を読んでみてから予想できたのは、少なくとも「性能(演算・発熱・電力消耗を含め)はIntelより優れている」というところでしたが、それはアーキテクチャがより進んだ工程で作られているからか、それともカスタマイズによるものか、またどれだけ優れているかというのはわからない状態でした。なので「2年で移行する」という話を信じ、まずは様子を見ようとしていました。&lt;/p>
&lt;p>そして今はM1チップのMacが色々とでていて、その性能も検証されていますね。確かなのは性能だけを見ると既存のIntel Macを買う理由はもはやないかのように見えます。さすがに互換性という不安要素があるのに、CPUのアーキテクチャを変えるという宣言をするぐらいのものではあると思います。しかし、やはりエンジニアたる身としては、互換性と安定性にまず目が行くものです。なぜなら、私は最初のメジャーバージョンは必ず、何かわかってない問題を抱えている可能性が高いというのを経験で実感しているからです。実際、Bluetooth問題や初期化が難しい点、スリープモードから起き上がらない問題などが一部で報告されていて、外装ディスプレイも公式的には1台しか対応しないという問題もあります(おそらく、Thunderbolt 3の大域幅の問題なのではないかと思います)。また、続々とUniversalバイナリやM1 Nativeでコンパイルされたアプリも発表されていますが、やはりまだそうではないアプリもたくさんあるので、不安ではありますね。&lt;/p>
&lt;p>しかし、それでもいつかはApple Siliconに全てのMacが転換されるだろうし、いますぐM1チップ搭載モデルを購入しないとしても、十分注目する価値はあるのではないかと思っています。いや、注目だけでなく、今年は16インチMacbook Proのフルチェンジの噂もあるので、もしそれが本当なら自分も乗り換えるのではないかと思っているくらいです。もしそれが出るなら、M1チップ搭載モデルの問題としてあげられたところを改善(少なくとも、外装ディスプレイの件や&lt;a class="link" href="https://9to5mac.com/2021/01/21/macos-big-sur-11-2-rc-now-available" target="_blank" rel="noopener"
>Bluetooth問題&lt;/a>は改善されそうです)されるはずで、今のアプリケーションのM1 Native対応の速度を見ると年内には意外と多くのアプリをNativeに使えるのではないかと思われます。まだまだこれからが注目なのですが、JavaScript中心の開発を行う方にとっては今のM1搭載モデルも十分メリットがあるのではないかと思います(AdoptOpenjdkはまだx64のみなので私は見送りですが…)。また、最近&lt;a class="link" href="https://www.theverge.com/2021/1/21/22242107/linux-apple-m1-mac-port-corellium-ubuntu-details" target="_blank" rel="noopener"
>M1搭載モデルでLinuxを使える&lt;/a>ようになったので、ホームサーバとしてこれらのMacを考慮してみるのも良いチョイスかと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>まだJavaとSpringも全ての機能を使いこなしているとも言えない自分が、今から新しい言語やフレームワークを学ぶという計画を立てるのは無理な話なのかしれません。これはいつも悩ましい主題です。一つの言語に関する知識やスキルを極めていった方が良いか、それとも常にトレンドを追いながら幅広い分野のスキルセットを持つべきか。深い知識も、広い知識も持っていて良いものではありますが、自分がこれから積み上げるキャリアを完成するにはどれがより効率的かという疑問は解消されないものです。&lt;/p>
&lt;p>自分なりの答えを出すとしたら、トレンドを追った方が、より自分の持つスキルセットの深さを増して行く方にも作用するのではないかという気はします。JavaしかできないものなのでJavaのAPIを借りて例え話をすると、Java 1.8では他の言語の持つClosureから影響されてLambdaが導入されましたね。その他にもvarの型推論やテキストブロックなどの改善もまた違う言語から影響されたものです。このような変化は、そもそもJavaの開発者たちが他の言語に注目しなかったら起こらなかったことでしょう。なので、「他と比較することで自分をより深く理解することにもなる」のではないでしょうか。そういう意味からすると、自分がすでに持っているスキルセットのみでなく、業界の動向や流行りを早くキャッチして受け入れることこそ重要ではないかと思ったりもします。&lt;/p>
&lt;p>この度はだいぶ主観的な意見だけ語る場となってしましましたが、どうでしょうか。またこれから自分の考えも、トレンドも変わっていくかもしれませんが、今は私の結論が紹介できただけでよかったかなと思います。そして、こうやって色々と自分の知らない分野について調べたり勉強したりするほど、自分には何もないなと実感でき、良い刺激になります。これからも色々と勉強していかないとですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>静的ウェブページに興味を持つ</title><link>https://retheviper.github.io/posts/static-web-page/</link><pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/static-web-page/</guid><description>&lt;img src="https://retheviper.github.io/images/tools.jpg" alt="Featured image of post 静的ウェブページに興味を持つ" />&lt;p>今更な話ですが、主にバックエンドの仕事をしてきたエンジニアとしては(特に、Springが全てを占拠してしまったJavaがメインな立場からは)、昨今のフロントエンドの世界を見ていると、一瞬よそ見しただけでもすぐに時代遅れな人間になってしまうような気になります。それだけさまざまなライブラリ、フレームワーク、設計思想、プラットフォームが現れ消えていくので、これからどれを学んでおくべきかわからなくなります。&lt;/p>
&lt;p>例えばアプリの設計思想だと、SPA&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>がトレンドになっているものの、&lt;a class="link" href="https://webassembly.org" target="_blank" rel="noopener"
>WASM&lt;/a>の登場でPWA&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>も登場し始めています。JavaScriptのフレームワークでは、「Virtual DOMを使用するので早い」という、&lt;a class="link" href="https://angular.io" target="_blank" rel="noopener"
>Angular&lt;/a>・&lt;a class="link" href="https://reactjs.org" target="_blank" rel="noopener"
>React&lt;/a>・&lt;a class="link" href="https://vuejs.org" target="_blank" rel="noopener"
>Vue.js&lt;/a>が今の通称「3強」となっていますが、「DOMを直接更新するから早い」という&lt;a class="link" href="https://svelte.dev" target="_blank" rel="noopener"
>Svelte&lt;/a>もあります。&lt;a class="link" href="https://nodejs.org" target="_blank" rel="noopener"
>Node.js&lt;/a>は失敗したという&lt;a class="link" href="https://deno.land" target="_blank" rel="noopener"
>Deno&lt;/a>が登場しているし、今の&lt;a class="link" href="https://www.typescriptlang.org" target="_blank" rel="noopener"
>TypeScript&lt;/a>の位置を目指したが失敗したと思われた&lt;a class="link" href="https://dart.dev" target="_blank" rel="noopener"
>Dart&lt;/a>は、&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>や&lt;a class="link" href="https://fuchsia.dev" target="_blank" rel="noopener"
>Fuchsia&lt;/a>で再起できているようにも見えますね。&lt;/p>
&lt;p>このように、フロントエンド系は新しい概念と技術の氾濫で混乱な状況ですが、面白くも、トレンドと逆行するような形のWebアプリ、いや、Webサイトの構築に関する概念もそれなりの割合を示しているように見えます。本日のポストのテーマである、「静的ウェブページ」です。&lt;/p>
&lt;h2 id="静的ウェブページstatic-web-pageとは">静的ウェブページ(Static Web Page)とは&lt;/h2>
&lt;p>「静的」であるということは、「動的」と区分される特徴があるということでしょう。ここでいう動的か静的かというのは、入力によって何かの処理が行われるか、もしくは常にサーバに保存されたデータをそのまま返すかががもっとも重要な基準となっているようです。例えばWikipediaでは以下のように定義しています。&lt;/p>
&lt;blockquote>
&lt;p>A static web page (sometimes called a flat page or a stationary page) is a web page that is delivered to the user&amp;rsquo;s web browser exactly as stored, in contrast to dynamic web pages which are generated by a web application.&lt;/p>
&lt;/blockquote>
&lt;p>言い方を変えると、サイトが「アプリケーション」として作られたものならば動的、もしくはただの固定されたデータを表示するための「ページ」であるなら静的といえますね。&lt;/p>
&lt;h2 id="なぜ今更">なぜ今更？&lt;/h2>
&lt;p>サーバに保存されたデータをそのまま返すという概念は、 Webアプリケーションが登場する前から存在していました。当時のウェブサイトはhtmlとcss、イメージなどのリソースをFTPなどでサーバにアップロードしてホスティングを行っていたのですが、これは今の静的ウェブページにとっても同じ方式です。&lt;/p>
&lt;p>つまり、概念だけを見ると静的ウェブページは昔に流行っていた「ホームページ」や「ブログ」などに近いものです。時代に逆行するような、静的ウェブページが今更注目されるのは、なぜか。&lt;/p>
&lt;p>当たり前ながら、当時とは違って、JavaScriptの発展によりサーバに依存しなくても簡単な処理はブラウザでできるようにもなり、適切なAPIがあればバックエンドを実装する必要がなくなるのもあり、AWS LambdaやAzure Functionsのようなサービスによりサーバレスができる環境ができるなど、バックエンドよりはフロントエンドの目的によって選択できる方法が多くなったという点があるでしょう。&lt;/p>
&lt;p>そして、もっとも根本的な、サイトの目的がありますね。ブログ、ポートフォリオ、イベント案内などそもそも「大した処理が必要ない」サイトに関しては、静的にしたほうがリソース使用、費用、パフォーマンス、セキュリティという面で動的ウェブページより有利です。例えば今このブログみたいにですね。&lt;/p>
&lt;p>最近はMarkdownなどで文書を書くと、それを元に静的ウェブページを作成してくれるツールもたくさんあり、そのようなツールで生成したデータを載せるだけでホスティングする方法も多いです。自分でソースを管理できて、簡単にホスティングできるのである意味ではもっとも静的ウェブページを作り安い時代となったとも言えますね。&lt;/p>
&lt;h2 id="静的ウェブページを作られるツール">静的ウェブページを作られるツール&lt;/h2>
&lt;p>多くの場合、静的ウェブサイトの生成ツールの使用は難しくありません。ベースになっている言語の実行環境を構築して、テンプレートをダウンロードして適用するか、作っていくかなのですが、ツールを実行するための環境の構築はツールのホームページの手順通りでよく、テンプレートも人の作っておいたものを持ってきて少し修正するくらいです。簡単な修正なら、HTML、CSS、JSON、YAMLくらいのファイルをいじるだけなので(プロパティファイルで色々なオプションを選択できる例もあります)、難しくありません。あとはMarkdownなどで記事を書いていくだけですね。&lt;/p>
&lt;p>ただ、自分の経験からだと、既製のテンプレートを大きく変えるか、最初から作り直す場合は自分が触ることのできる言語をベースにしておいた方が良いということですね。例えばこのブログは&lt;a class="link" href="https://jekyllrb.com" target="_blank" rel="noopener"
>Jekyll&lt;/a>で作られていて、テンプレートも一部修正していますが、そもそも私はRubyに慣れてないので根本的な部分を修正してはいないところです。&lt;/p>
&lt;p>Jekyll以外には、Nodejs基盤のツールが多いようです。例えば&lt;a class="link" href="https://metalsmith.io" target="_blank" rel="noopener"
>Metalsmith&lt;/a>や、&lt;a class="link" href="https://hexo.io" target="_blank" rel="noopener"
>Hexo&lt;/a>のような物があって、React基盤の&lt;a class="link" href="https://www.gatsbyjs.com" target="_blank" rel="noopener"
>Gatsby&lt;/a>、Vue.js基盤の&lt;a class="link" href="https://vuepress.vuejs.org" target="_blank" rel="noopener"
>VuePress&lt;/a>もあります。JavaScriptとそのフレームワークの使用に慣れているなら、こちらがいいかもしれませんね。他には、Go言語基盤の&lt;a class="link" href="https://gohugo.io" target="_blank" rel="noopener"
>Hugo&lt;/a>もありますので、Goに慣れている方ならこちらを選択することもありですね。&lt;/p>
&lt;h2 id="静的ウェブページを載せられるプラットフォーム">静的ウェブページを載せられるプラットフォーム&lt;/h2>
&lt;p>ツールを使って、静的サイトを作ったら、次はホスティングが必要となりますね。静的ウェブページのホスティングの場合、このブログでも使用している&lt;a class="link" href="https://pages.github.com" target="_blank" rel="noopener"
>GitHub Pages&lt;/a>や&lt;a class="link" href="https://www.netlify.com" target="_blank" rel="noopener"
>netlify&lt;/a>のようなサービスがあり、データをGitなどでアップロードすると自動でビルドとデプロイが完了される便利さがあります。&lt;/p>
&lt;p>他にはクラウドを利用する方法があります。AWSやAzure、Google Cloud Platformのようなクラウドサービスには、&lt;a class="link" href="https://aws.amazon.com/s3" target="_blank" rel="noopener"
>S3&lt;/a>や&lt;a class="link" href="https://azure.microsoft.com/ja-jp/services/storage/blobs" target="_blank" rel="noopener"
>Blob&lt;/a>のようにウェブからアクセスできるストレージサービスが必ずありますが、このストレージにツールで作成した静的サイトをアップロードしてホスティングする方法もあります。特にGoogleのサービスの場合、&lt;a class="link" href="https://firebase.google.com" target="_blank" rel="noopener"
>Google Firebase&lt;/a>というアプリ開発に特化したプラットフォームもあるのでAPIとの連携が必要な場合は考慮できる候補ではないかと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>ここでは単にツールとプラットフォームを紹介(というより、言及)しただけですが、静的ウェブページでできることや活用できるものは、他にも多いようです。同じ静的ウェブページだとしても、どのような技術の組み合わせでどのような物が作り上げられるかがかなり変わってくるのですが、実際にどんな物ができるかは&lt;a class="link" href="https://jamstack.org" target="_blank" rel="noopener"
>JAMstack&lt;/a>のExamplesタブから色々発見できますので、参考にしてみてください。&lt;/p>
&lt;p>個人的にはGatsbyに興味があって、Reactの勉強のついでに、いつかポートフォリオのためのサイトをそれで作り上げてみようかなと思っています。Oracleクラウドだと無料のVMやDBも提供されるので、簡単なAPIを作成しておくのも可能になるかもしれませんね。いや、いい時代になったものです。皆さんもぜひ、静的ウェブページで自分だけのサイトを築き上げてみてください。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Single Page Applicationの略で、従来のWebアプリケーションが複数の画面で構成されていたことに対して、画面を一つにして開発の効率やパフォーマンスの向上を図ったWebアプリケーションのこと。画面がサーバサイドと分離されているため、バックエンドとして選択できるものの幅が広いという特徴もあります。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Progressive Web Applicationの略で、Webアプリでありながらもネイティブアプリならではのメリット(パフォーマンスが高い、インストールすることでオフラインでも利用可能)を採用したアプリケーションのことを指します。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>最近注目しているものたち</title><link>https://retheviper.github.io/posts/personal-interests-in-this-time/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/personal-interests-in-this-time/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.jpg" alt="Featured image of post 最近注目しているものたち" />&lt;p>常に勉強し続けなければならないのがこの業界の定めとは思いますが、変化は日々加速されていて、何に従って何を頼れば良いかわからない時もありますね。新しい言語が続々登場してくるなかでも、昔は性能の問題で注目されてなかった言語がいきなり人気を得たり、当たり前と思っていたパラダイムがひっくり返されたりもします。今はJavaScriptの時代と行っても過言ではない状況に来ていると思いますが、今後はどうなるのでしょうか。いくつか、個人的に興味をもったIT業界の動向についてまとめてみました。&lt;/p>
&lt;h2 id="apple-silicon-mac">Apple Silicon mac&lt;/h2>
&lt;p>こないだ、Appleの開発者向けイベントである&lt;a class="link" href="https://developer.apple.com/videos/play/wwdc2020/101" target="_blank" rel="noopener"
>「WWDC2020」&lt;/a>が開催されました。毎年必ずライブで見ているわけではないのですが(深夜に始まるので…)、最近はテレワークをしていて通勤時間がなくなっているのもあり、最初から最後までライブで見ることができました。&lt;/p>
&lt;p>iOSやiPadOS、macOSの変化ももちろん興味深かったのですが、やはり今回のイベントで最も印象的なものがなんだったかというと、macのメインプロセッサが&lt;a class="link" href="https://www.apple.com/newsroom/2020/06/apple-announces-mac-transition-to-apple-silicon" target="_blank" rel="noopener"
>Apple製のものに変わる&lt;/a>ということでしたね。自分はPowerPC時代のmacは経験したことがありませんが、PPCからIntelへの転換は成功的だったので、今回もそうなると思います。個人的にiPadも使っているのですが、あまりIntelのCPUに比べ性能が劣るという印象は受けたこともありませんでした。&lt;/p>
&lt;p>もちろん、Bootcampを使えなくなることもあり、他にもx86を基盤に作られたサードパーティアプリケーションが使えなくなる可能性もあるので、新しいプロセッサのmacが今年発売したところですぐに使っているmacを買い換えるつもりはありません(高いし…)。でも、以前から&lt;a class="link" href="https://llvm.org" target="_blank" rel="noopener"
>LLVM&lt;/a>や&lt;a class="link" href="https://developer.apple.com/mac-catalyst" target="_blank" rel="noopener"
>Catalyst&lt;/a>のように、違うプラットフォーム(プロセッサ)でも問題なくアプリが起動できるような環境を構築するために何年も投資しているのを見ると、意外と転換は早く、問題なくできるのではと思います。特に自分はWebアプリを書くだけなので、あまりlow levelの技術に触れることもなく、使っている言語のコンパイラが新しいプロセッサに対応してくれれば良いだけですね。実際WWDCの紹介でも、xcodeで作成したプロジェクトは再度ビルドするだけで良いと言ってました。&lt;/p>
&lt;p>ただ気になるのは、自分のIntel製CPUを搭載しているmacに対してのOSのサポートがいつまで続くか、くらいですかね。最近はWindowsの発展もすごいのですが、自分の環境だとあまりWindowsにこだわる必要はないので問題なく転換できそうな気もします。そしてプロセッサのみではなく、SoCなのですでにiPadやiPhoneに適用されているさまざまなセンサーやニューラルエンジンなどを使えるのも大きいメリットと思います。&lt;/p>
&lt;p>ただ、こういう感想はあくまで開発者としての自分の立場から考えた個人レベルの問題で、エンタプライズレベルだといくら&lt;a class="link" href="https://www.apple.com/newsroom/2020/06/apple-announces-mac-transition-to-apple-silicon" target="_blank" rel="noopener"
>Rosetta2&lt;/a>や&lt;a class="link" href="https://developer.apple.com/documentation/xcode/building_a_universal_macos_binary" target="_blank" rel="noopener"
>Universal Binary2&lt;/a>が優秀だとしてもどこかで互換性や性能の問題は起こり得ると思うので要注意とは思います。Officeのデモンストレーションは、今よりもパフォーマンスが優れているように見えたのでよかったのですが、事務職の人があえてmacを使う理由はそもそもないので…&lt;/p>
&lt;p>他、すでに$500でA12Zを搭載したmacを借りることができるようなので、意外とすぐに新プロセッサmacの性能や互換性問題は明らかになるかもしれませんね。まずはそこに注目かな、と思っています。性能のみならず、作業時の温度や電力消費量もどれだけ改善されたか、知りたいところですね。来週あたりでベンチマークを見れるのではないかと思っています。&lt;/p>
&lt;h2 id="deno">Deno&lt;/h2>
&lt;p>JavaScriptはあまり触ってないので、Node.jsにも詳しくないわけですが、やはり昨今のWebアプリだとNode.jsなしでは話にならない時代になっていますね。自分の場合はTypeScriptの方でJavaScriptよりも良い印象を受けたので、NodeでもネイティブなTypeScriptサポートができるといいなと思っていました。それが、Nodeの開発者によって&lt;a class="link" href="https://deno.land" target="_blank" rel="noopener"
>Deno&lt;/a>という新しいランタイムが登場したらしいです。&lt;/p>
&lt;p>基本的にNodeでの反省点(async/awaitのような？)から作っているもののようで、その他にも特徴としてはTypeScriptのコンパイラを内蔵していて、いちいちコンパイルしなくても(JavaScirptにトランスパイルしなくても)使えるというところが自分にとっては最大のメリットのように思われます。&lt;/p>
&lt;p>ただDenoの問題だと、やはり既存のNode.js用モジュールを使えない、というところと、TypeScriptのコンパイルが遅いというところがあげられています。Rustを使って自体のTypeScriptコンパイラを作るという計画があるらしいですが、いつになったら完成できるかわからないのでしばらくDenoを使ったプロジェクトはあまり発券できないかもですね。&lt;/p>
&lt;h2 id="blazor">Blazor&lt;/h2>
&lt;p>5月には&lt;a class="link" href="https://news.microsoft.com/build2020" target="_blank" rel="noopener"
>「Microsoft Build 2020」&lt;/a>にて、&lt;a class="link" href="https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-now-available" target="_blank" rel="noopener"
>Blazor WebAssemblyのリリース発表&lt;/a>がありました。これで.NETとC#による、ブラウザから実行可能なWebアプリケーションを作成できるらしいです。&lt;/p>
&lt;p>Node.jsを使ったWebアプリケーションのメリットとして、よく「一つの言語でサーバサイドとクライアントサイドの両方を開発できる」ことがあげられていますが、このようにJavaScriptを使わなくてもそれが可能になるようなフレームワーク＆ランタイムが登場することもあるのですね。JavaScirptも良い言語ですが、そもそもの限界が明確なので、C#のようなコンパイル言語をブラウザ上で使えるのは逆のパターン(JavaScriptをサーバサイドで使う)に比べ良いところが多いのではないかと思います。&lt;/p>
&lt;p>また、BlazorファミリーとしてPWAの実装ができるBlazor PWA、ElectronとWebViewでのデスクトップアプリが実装できるBlazor Hybrid、HTML要素なしでネイティブアプリが実装できるBlazor Nativeも続々登場する予定だというので、これに刺激を受け他のコンパイル言語でもブラウザで実行できるようになるのではないかと思います。&lt;/p>
&lt;p>WSLやGitHubもありますが、いろいろな意味で最近のMicrosoftの変化と投資はすごいものですね…&lt;/p>
&lt;h2 id="flutter-for-web">Flutter for web&lt;/h2>
&lt;p>iOSとAndroidの二つのプラットフォームのアプリを同時に開発でき、同じく機能するReact Nativeに比べ性能でもネイティブアプリに劣らないことがメリットという&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>ですが、最近Flutterを利用したWebアプリケーションも続々登場しているようです。そもそもFlutterを書くための言語である&lt;a class="link" href="https://dart.dev" target="_blank" rel="noopener"
>Dart&lt;/a>が、次世代JavaScirptを目標に開発されたものなのでおかしいことではないのですが、こうやって一つの言語でモバイルとWebアプリケーションの両方を開発できるということはBlazorの場合と同じく魅力的です。&lt;/p>
&lt;p>ただ、Googleが開発しているというところから、DartではなくKotlinでよかったのでは？という気持ちはありますね。また、自社のサービスをすぐ見捨てる傾向のあるGoogleなのでいつまでFlutterが生き残ることができるか、ということも疑問として残っています。MicrosoftのXamarinがいまいちになっているので、モバイルだけはFlutterを採用して開発するようなこともあるのではないかと思いますが、Webアプリケーションを開発するとしたらC#を利用できるBlazorの方がより魅力的ではないかと思います。&lt;/p>
&lt;h2 id="rust">Rust&lt;/h2>
&lt;p>ポストC、C++として注目されている&lt;a class="link" href="https://www.rust-lang.org" target="_blank" rel="noopener"
>Rust&lt;/a>ですが、最近はこの言語の人気が恐ろしいほどですね。まだエンタプライズレベルでは、既存に構築しているシステムや熟練されたエンジニアがいないなどの理由でRustが使われているケースはあまりないようですが、CやC++と同等のパフォーマンスを見せながらも安定的という面が最大のメリットと言われているらしいです。&lt;/p>
&lt;p>個人的にはWebアプリケーションレベルであまりシステムと直接関わるようなことをする場合はないのですが、PWAの登場などWebアプリケーションでもデスクトップ並みの性能を求められることがあったり、Javaでは直接扱うことのできないバイナリファイルの扱いなどで限界を感じていたりしているので、Rustのような言語が扱えたらより良いアプリケーションを作れるようになるのでは、と思っています。&lt;/p>
&lt;p>特に、コミュニケーションツールとして有名な&lt;a class="link" href="https://discord.com" target="_blank" rel="noopener"
>Discord&lt;/a>がもともと使っていた&lt;a class="link" href="https://golang.org" target="_blank" rel="noopener"
>Golang&lt;/a>をあえてRustに交替したとの記事もあったので、同じくCとC++の代替言語として開発されたGolangさえも圧倒するメリットとは一体何かという疑問が湧いてきて、ますます気になっているところです。最近人気のKotlinの場合も、おそらくJavaと完全互換できるという特徴がなかったら成功できなかったと思いますが、互換性もない言語に転換するほどRustが持っているメリットとは一体なんなのか、知りたいですね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いろいろな技術と変化があり、幸せのような、プレッシャーを感じるような複雑な気持ちではありますが、どれも肯定的な変化をもたらしてくれている、と思っています。特に、各言語の変化に関してはJavaのモットーである&lt;code>Write once, run everywhere&lt;/code>がどの言語でもより発展した形として実現されているところをみているようですね。結局どの言語も似たようなものになりつつあるような感覚もするのですが、逆にいうともうどの言語を使うかはあまり関係ない時代になりつつある気もします。&lt;/p>
&lt;p>なので、いったんはそのような変化についていけられるよう、自分のスキルを磨くことですね。どの言語を使うかがあまり重要ではなくなるということは、つまりその言語で何ができるかがより重要ということになると思うので、今の自分にできる言語を使ってさまざまな経験をしてみるのが優先すべきことではないかという気がします。あまり実装ができない最近ですが、個人的なプロジェクトでも進めながら経験してみたくなりました。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>JavaプログラマーがみたTypeScript</title><link>https://retheviper.github.io/posts/typescript-first-impression/</link><pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/typescript-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/typescript.jpg" alt="Featured image of post JavaプログラマーがみたTypeScript" />&lt;p>このたびは、新しい案件で&lt;a class="link" href="https://angular.io" target="_blank" rel="noopener"
>Angular&lt;/a>とSpring BootによるWebアプリケーションの開発を担当することになりました。Spring Bootは今までずっとやってきているのであまり問題はないと思いますが、問題はAngularです。Angularはバージョン2からTypeScriptを使うことになっているらしく、JavaScriptとjQueryを少し触ったくらいの経験しかないのでそもそもTypeScriptがどんなものかすら知らなかったです。ただわかっているのは、JavaやC#みたいに静的言語みたくコードを書いたら、それをいい感じにコンパイルしてJavaScriptに変えてくれる、ということだけでした。&lt;/p>
&lt;p>なのでまずTypeScriptの勉強を始めましたが、言語そのものの特徴に含め、TypeScriptで何かを作る時に必要となる知識は意外と大きいことに気付きました。今回のポストでは正直な感想と、どんなものが必要なのかをJavaしか知らない初心者である自分の観点から述べていきたいと思います。&lt;/p>
&lt;h2 id="驚くほどjavaに似ている">驚くほどJavaに似ている&lt;/h2>
&lt;p>元々C/C++、C#、JavaといったいわゆるC-family言語と似ているとの話は聞いていましたが、実際TypeScriptを触ってみると本当にそうでした。最初、なんの情報もなかった時(型を指定できて、コンパイルしたらJavaScriptに変わるという話だけ聞いている時)、ただ普通の変数の宣言に型指定ができるようになっているだけかと思っていたのですが、それだけでなく意外とオブジェクト指向に合わせて発展、もしくは回帰している印象を受けました。&lt;/p>
&lt;h3 id="型指定はいい感じ">型指定はいい感じ&lt;/h3>
&lt;p>型の指定は、元々動的言語であるJavaScriptを昔ながらの静的言語化するものですね。でも、書き方自体は昔のままでなく、KotlinやSwiftのようなモダンな言語に似ています。型をまず書くのではなく、変数として宣言したあとに型をつける&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>のですね。例えば以下のようになります。&lt;/p>
&lt;p>Javaでの型指定&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> 1000&lt;span style="color:#f92672">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>TypeScriptの型指定&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、こういう型指定を、TypeScriptでは「型注釈」とも呼ぶらしいです。TypeScriptはコンパイルされたらランタイムで型が決まるJavaScriptになるので、コンパイラーのために注釈をつけてあげる、という意味に近いようです。&lt;/p>
&lt;h3 id="型以外の類似点">型以外の類似点&lt;/h3>
&lt;p>TypeScriptには型指定だけでなく、C#やJavaプログラマーならすでに慣れているAccess修飾子、Interface、Class、Generics、Decorator(Annotation)なども用意されています。これらの一部は最近JavaScriptでも対応している機能ではありますが、実際のアプリを開発する業務ではブラウザの制約から最新のJavaScriptを使えない場合もあり不便ですね。しかし、TypeScriptを使うとコンパイラのオプションを指定することでどのバージョンのJavaScriptとしてソースコードを出力するか選択できるので、ブラウザをあまり気にせず同じコードを書けます。これは本当にありがたいですね。&lt;/p>
&lt;p>他に、依存関係をnpmといったパッケージマネージャで管理できるというのも良いところ。これはJavaScriptでもできる(というか、そちらが先ですが)ことですが、Importと組み合わせたらほぼC-familyと似たような感覚で運用できるという面が良いですね。JavaScriptのモジュールというのも、またES6から対応しているのでそれ以前のバージョンを使う場合だとかなり面倒くなるかも知れない、と思いました。知識不足なだけかもしれませんが…&lt;/p>
&lt;h2 id="気になったところ">気になったところ&lt;/h2>
&lt;p>TypeScriptの良いところは、やはり昔ながらの言語に慣れている人にはかなり快適にコードをかけるような環境を提供していて、コンパイルタイムでエラーを探せるという、その何ふさわしいものとなっている点だと思います。ただ、少し気になったところもあったのでそれについても書きます。&lt;/p>
&lt;h3 id="結局はjavascript">結局はJavaScript&lt;/h3>
&lt;p>TypeScriptはJavaScriptのSuper setなので、JavaScriptの機能をそのまま利用できるというのが特徴だとも言われています。最初はそれをメリットとして捉えていましたが、勉強をしながらやはりデメリットもあるんだなと感じました。JavaScriptをそのままかけるということは、結局言い方を変えると、ソースコードの中にJavaScript(Vanilla)とTypeScriptが混在していても問題なくなるということですね。こうなった場合にTypeScriptがSuper setという特徴を諦めないかぎりコードが動かなくなることはないと思いますが、人の観点からするとかなり混乱するコードが生まれる可能性もあるのではないかと思いますね。&lt;/p>
&lt;h4 id="javascriptでも書けるということの意味">JavaScriptでも書けるということの意味&lt;/h4>
&lt;p>そもそもJavaScriptの歴史の方が長く、ユーザも絶対的にJavaScriptの方が多いです。そして、私みたいにC-family言語ではなくJavaScriptからプログラミングに入門した人もいるので、そのような人にとってTypeScriptはあえて使うメリットのない、ただの不便なものにしか思われない可能性もあると思います。また、JavaScriptの方に慣れている人がTypeScriptに移ったとしても、結局はJavaScriptと変わらない書き方になる可能性もなくはないはずですね。&lt;/p>
&lt;p>TypeScriptがSuper setとして企画された理由は、既存のJavaScriptプログラマーを吸収するための政策だったと思いますが、プログラミング言語は自由が多いほど混乱しやすいと思うので、これはやはりメリットでもデメリットでもあると思いました。&lt;/p>
&lt;h4 id="prototype">prototype&lt;/h4>
&lt;p>クラス基盤のオブジェクト指向言語から入門しているからか、自分にはJavaScriptの&lt;code>prototype&lt;/code>という概念があまりわかってないです。ともかくJavaScriptにはこのprototypeというのがあって、オブジェクトを変数として使うこともできるという特徴を持っていますね&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。Javaプログラマーとしてはオブジェクトはクラス、クラスはファイル一つ、という風に考えることが一般的なので、こういう自由度に触れるとどうしたらいいか混乱しそうな感覚です。そしてもちろん、これはTypeScriptよりもJavaScriptの特徴ではありますが、TypeScriptがSuper setである以上避けられない問題なのですね。&lt;/p>
&lt;h4 id="module">Module&lt;/h4>
&lt;p>モジュールがJavaScriptに導入されて、TypeScriptでももちろんそのまま使えます。個別のファイルにクラスを一つづつ作成して、インポートして使っているとまるでJavaと大差ないようにも思われますね。でもこのモジュールというものも実際はややこしいところがあるようで、書き方をどうするか考えなくてはならない場合もあるようです。&lt;/p>
&lt;p>例えばPythonのように&lt;code>as&lt;/code>を入れることでインポートしたモジュールに別名をつけることができるけど、そうしたら問題が怒るケースもあるとか、CORS設定で塞がる場合もあるとかというのが最初はかなり複雑だなと感じました。まだ深堀りしてないので実際は使ってみないとわからないと思いますが、そもそも使ってみないとわからないという部分はやはり気になりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 二つの書き方ができるが、一緒ではない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">express&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;express&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">express&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;express&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="コンパイル">コンパイル&lt;/h4>
&lt;p>TypeScriptをインストールすると、ターミナルから&lt;code>tsc&lt;/code>というコマンドを使えるようになります。そしてTypeScriptで作成したファイルは&lt;code>.ts&lt;/code>というファイルに書いて、tscコマンドで&lt;code>.js&lt;/code>に変わりますね。&lt;code>tsconfig.json&lt;/code>ファイルを定義することでどうコンパイルするか様々なオプションを指定することもできます。例えばJavaScriptにコンパイルする時、どんなバージョンでコンパイルするか、どのファイルをコンパイルするか、&lt;code>.js&lt;/code>ファイルはどこに吐き出すかなど。&lt;/p>
&lt;p>ただ、コンパイルにかなり時間がかかるのもあり、コンパイルされたファイルは結局JavaScriptになります&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>。そしてこれは、TypeScriptで作成しても「ランタイムでは弱タイプになる」ということを意味しますね。ちゃんとタイプを明示して(&lt;code>any&lt;/code>を使わず)コードを作成しただけでは不十分なケースが十分あり得るので、ランタイムでも型による問題が起こらないようにする必要性があるかも知れないという印象を受けました。&lt;/p>
&lt;p>最近はnpmの代替ランタイムとしてTypeScriptをそのまま使える&lt;a class="link" href="https://deno.land" target="_blank" rel="noopener"
>Deno&lt;/a>のようなものも登場していますが、やはり内部的にはtscを使っているらしく、このコンパイル速度が遅いのが最大の問題として挙げられていました。Rustで新しいコンパイラを作成しているとのことですが、それがいつ完成されるかもわからないですね。&lt;/p>
&lt;p>そしてtscのみでなく、&lt;a class="link" href="https://webpack.js.org" target="_blank" rel="noopener"
>webpack&lt;/a>を使う場合はts-loaderを使ったりするとかなり初期設定が複雑な印象を受けました。他に&lt;a class="link" href="https://babeljs.io" target="_blank" rel="noopener"
>Babel&lt;/a>などを使う場合もあるらしいですが、コンパイルをするためという理由でこのようなベンドラやコンパイラをまた勉強しなくてはならないというのは少し不便な部分ですね。JavaScriptと紐付けられている言語としての運命みたいなものかもしれませんが…&lt;/p>
&lt;h2 id="すっきりしたところ">すっきりしたところ&lt;/h2>
&lt;h3 id="javascriptライブラリを使える">JavaScriptライブラリを使える&lt;/h3>
&lt;p>「TypeScriptではJavaScriptのライブラリも使える」という話も聞きましたが、実際それがどうやって可能になったのかが疑問でした。例えばTypeScriptにも型推論があってある程度、型を宣言しなくても良い場合はあるものの、基本的には型注釈で明示的に型を指定してあげないとうまくコンパイルできない部分もありますね。しかし、すでに存在しているJavaScriptのライブラリ全てがTypeScriptを考慮して作られているとは考えられないので、これをTypeScriptではどのような形で対応しているかが一番の疑問でした。&lt;/p>
&lt;p>答えは意外と簡単で、&lt;code>.d.ts&lt;/code>という形で「型定義ファイル」を作成すると良い、ということでした。すでにTypeScriptに対応しているライブラリの場合もこの型定義ファイルによってTypeScriptが型を参照できるようにしていて、自作することも可能。そしてメジャーなものの場合、&lt;code>node_modules&lt;/code>にインストールできる形で型定義ファイルを提供している場合もありました。&lt;/p>
&lt;p>すでに作成されている型定義ファイルのインストールも簡単で、例えばnodeのTypeScript型定義が必要な場合は&lt;code>npm install --save-dev @types/node&lt;/code>のようにコマンド一つでインストールができて、GitHubの&lt;a class="link" href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener"
>リポジトリ&lt;/a>を参照するとどんなライブラリの型定義ファイルが提供されているか確認することもできました。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>まだ色々気になるところはありますが、多くはTypeScriptそのものというよりもJavaScriptの特性から起因しているものが多いため、現時点でフロントエンドエンジニアがどの言語を選択すべきかというと、やはりTypeScriptの方が良いのではないかと思いました。もちろん、これは自分のスタートがJavaであることもあるとは思いますが、やはりコンパイルタイムで多くの問題を事前にキャッチできるというメリットは捨てがたいものだと思っています。&lt;/p>
&lt;p>現在はJavaScriptとの互換性のために色々初期設定など煩雑だったりコンパイルに時間がかかるなどの問題もいくつかありますが、これらもAngularみたいに最初からTypeScriptを前提に作られるフレームワークやライブラリが増えたり、ブラウザからTypeScriptに対応したり(これは可能性が低いかな…)したら自然に解決される問題ではないかとも思いますね。&lt;/p>
&lt;p>最初は単純にAngularを使うために勉強したものの、意外としっかりしていて、これからの未来もかなり明るい感じだったのでエンジニアの皆さんにもぜひお勧めしたいと思っているところです。&lt;/p>
&lt;p>ああ、Pythonも型指定できるようになるといいな…&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>もちろん、最近はC#もJavaも&lt;code>var&lt;/code>で変数を宣言することもできますが、習慣もあり、元々静的言語では型から書いた方が良いのではないかと個人的には思っています。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>しかも、ES6で登場したClassは結局プロトタイプ基盤の&lt;code>function&lt;/code>の書き方をちょっと変えただけなのですね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>Javaのようにバイトコードに変わったり、Cのように機械語に変わるようなものとは少し違うのでTypeScriptのコンパイルは&lt;code>トランスパイル&lt;/code>とも呼ぶらしいです。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>知識不足でした！Pythonも3.6から型の宣言ができるようになっています。&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>