<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Compose on Korean-man in Tokyo</title><link>https://retheviper.github.io/tags/compose/</link><description>Recent content in Compose on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 25 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/tags/compose/index.xml" rel="self" type="application/rss+xml"/><item><title>KotlinConf'24を要約してみた</title><link>https://retheviper.github.io/posts/kotlin-conf-2024/</link><pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-conf-2024/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinConf'24を要約してみた" />&lt;p>今年のKotlinConfが開催されました。数日かけてのイベントなので、全てのセッションを見ることはできませんが、まずはキーノートの方で重要な情報をまとめてみました。全体のスケージュールは&lt;a class="link" href="https://kotlinconf.com/schedule/" target="_blank" rel="noopener"
>こちら&lt;/a>から確認できて、&lt;a class="link" href="https://www.youtube.com/@Kotlin/streams" target="_blank" rel="noopener"
>YouTubeでのライブ配信&lt;/a>も行われているので、興味がある方はぜひチェックしてみてください。&lt;/p>
&lt;p>まずはKotlinConf'24の公式アプリの紹介がありました。公式アプリでは今回行われるカンファレンスとセッションを確認できるもので、&lt;a class="link" href="https://github.com/JetBrains/kotlinconf-app" target="_blank" rel="noopener"
>GitHubにてソースコードを公開&lt;/a>しています。Kotlin Multiplatformで作成されていて、iOS、Android、Webで動作するものなので、いいサンプルとして使えるかもしれません。&lt;/p>
&lt;h2 id="kotlinの今">Kotlinの今&lt;/h2>
&lt;p>まずはKotlinの現状から。常にKotlinを使っているエンジニアの数が、200万以上になっているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage_hub3ba13be49a6828c9de3715db7f23862_72520_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage_hub3ba13be49a6828c9de3715db7f23862_72520_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Kotlinエンジニア数"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>また、Kotlinを導入している企業もどんどん増えているとのことです。代表的な企業は以下の画像通りだそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies_huc6aef245febedaeb6032b72a98ba9331_80568_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies_huc6aef245febedaeb6032b72a98ba9331_80568_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Kotlin導入企業"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="kotlin-20-and-k2-compiler">Kotlin 2.0 and K2 Compiler&lt;/h2>
&lt;p>Kotlin 2.0からはK2コンパイラーの導入により、全般的にコンパイルの速度が向上したという話が主なテーマです。ただ一部プロジェクトでは、遅くなるケースもあるとのことでした。また、IntellijでもK2コンパイラーモードがあり、コードハイライトが1.8倍速くなるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance.webp"
width="2056"
height="1216"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance_hua6710ccce01267c60da264e401c19c35_103860_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance_hua6710ccce01267c60da264e401c19c35_103860_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="K2コンパイラーの速度比較"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="405px"
>&lt;/p>
&lt;p>K2モードは、Intellij 2024.1以上から以下の設定画面で設定できます。2024.2からは性能の改善を含め、Beta版として提供される予定です。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode.webp"
width="2188"
height="1668"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode_hucd6e39bb5bcd2b2433dcb028dd68479a_110960_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode_hucd6e39bb5bcd2b2433dcb028dd68479a_110960_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="IntellijのK2モード設定画面"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="314px"
>&lt;/p>
&lt;p>2.0へのマイグレーションは1000万行のコード、18000人のエンジニア、80000のプロジェクトでテストされていて、1.9からのマイグレーションはスムーズに行えるとのことです。&lt;/p>
&lt;h3 id="metaの場合">Metaの場合&lt;/h3>
&lt;p>Metaの場合、Kotlin firstでの開発を積極的に進めているとのことでした。IDEからコードの最適化までの全てにおいてKotlinを採用して、既存のJavaで作成されたFacebook, Instagram, Facebook Messenger, WhatsAppなどのアプリにおいて、Kotlinに自動変換できるツールを作成して移行を自動化しているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin_huab5088ae8b08c67c58940e3fa4ffa242_82010_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin_huab5088ae8b08c67c58940e3fa4ffa242_82010_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="MetaのKotlin採用"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>そしてMetaはKotlin 1.8の時点から一部のプロジェクトにおいてすでにK2コンパイラーを採用していて、今は95%のプロジェクトがK2コンパイラーを使っているとのことです。その効果としてはAndroidプロジェクトにおいては最大20%のビルド時間の短縮ができたらしいです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler_hud72c3bd8dc71c7ee89a72db16853cc87_87106_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler_hud72c3bd8dc71c7ee89a72db16853cc87_87106_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="MetaのK2コンパイラー採用"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="googleの場合">Googleの場合&lt;/h3>
&lt;p>K2コンパイラーにはGoogle側も協力していて、Androidのツーリングに関してLintや&lt;a class="link" href="https://developer.android.com/kotlin/parcelize?hl=ja" target="_blank" rel="noopener"
>Parcelize&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/docs/ksp-overview.html" target="_blank" rel="noopener"
>KSP&lt;/a>などにもコントリビュートしているそうです。また、Jetpack Composeのコンパイラーの改善もあり、従来はKotlinとバージョンと相違があったのですが、2.0からは同じバージョンで指定できるようになったとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update_hu7fd259c25ed8e5eca2338d777d8a309f_80422_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update_hu7fd259c25ed8e5eca2338d777d8a309f_80422_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Composeコンパイラーのバージョン指定"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>またAndroid StudioでもKotlin 2.0のサポートを予定しているとのことでした。代表的な機能は以下の画像の通りです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0_huf6b6d7263a6bedddd389a0740fc0f2f5_97080_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0_huf6b6d7263a6bedddd389a0740fc0f2f5_97080_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="AndroidのKotlin 2.0サポート"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Jetpack Composeにおいても新しい機能を追加される予定だそうです。主に以下の画像で挙げている機能が、7月から提供される予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming_hu21ad215560a306b28dc706633ddd07ef_87466_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming_hu21ad215560a306b28dc706633ddd07ef_87466_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Jetpack Composeの追加予定機能"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>コンパイラーそのものの改善もあり、安定性やパフォーマンスが向上しているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance_hu8104ee915afa4dbf564f1e1f8e9ada01_82306_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance_hu8104ee915afa4dbf564f1e1f8e9ada01_82306_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Jetpack Composeの性能改善"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>他にも、Google内部ではサーバサイドKotlinの採用も進んでいたり、KMPによる開発も進んでいるとのことでした。あとはJetpack ComposeのライブラリもMultiplatformに対応していて、ViewModelやRoomなどのライブラリもKotlin Multiplatformで使えるようになったとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform_hu184b7352b4d801225a477076fb3871bb_93470_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform_hu184b7352b4d801225a477076fb3871bb_93470_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Jetpack ComposeのMultiplatform対応"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="kotlin-multiplatform">Kotlin Multiplatform&lt;/h2>
&lt;p>K2コンパイラーの導入により、Kotlinのコードを直接Swiftのコードに変換することができるようになったとのことです。これにより、iOSアプリの開発においてもKotlin Multiplatformを使って開発することができるようになりました。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift_hu36f0b70d6e09af0f70082a80b24d77fa_80636_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift_hu36f0b70d6e09af0f70082a80b24d77fa_80636_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="KotlinのSwift変換"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>そして&lt;a class="link" href="https://www.jetbrains.com/ja-jp/fleet/" target="_blank" rel="noopener"
>Fleet&lt;/a>で、iOSアプリも開発できるという紹介もありました。FleetだとCompose MultiplatformによるiOSとAndroidのアプリ開発が同時に可能で、リファクタからデバッグまで一貫して開発できるとのことです。AppCodeのサポートが2023年に終了となっていたので、これは嬉しいニュースですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development_hu0d5bfc4b1237efd7f31684765c0b1bff_96184_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development_hu0d5bfc4b1237efd7f31684765c0b1bff_96184_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="FleetでのMultiplatform開発"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>また、新しいビルドツールである&lt;a class="link" href="https://github.com/JetBrains/amper" target="_blank" rel="noopener"
>Amper&lt;/a>も紹介されました。まだ発表されてから間もないのですが、すでにJetBrainsのIDEでサポートされていて、YAMLファイルだけでビルド設定を行うことができるので、新しいプロジェクトで使ってみるのもいいかもしれません。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/amper.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/amper_hu6e4361bc5fcbb127fffd2cd06f8d9ee0_93446_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/amper_hu6e4361bc5fcbb127fffd2cd06f8d9ee0_93446_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Amperの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Compose Multiplatformにおいても、以下の新しい機能が追加されたらしいです。どれも期待していた機能だったので、嬉しいですね。個人的にはデスクトップアプリでファイルの選択ダイアログを実装した時に、対応する機能がなくJavaのAWTを使わざるを得なかったので、このようなAPIもあるといいなと思っています。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform_hu1ec0861aeaca3268d9d904f6b2bc1845_76646_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform_hu1ec0861aeaca3268d9d904f6b2bc1845_76646_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Compose Multiplatformの新機能"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="upcoming">Upcoming&lt;/h2>
&lt;p>次に、Kotlin 2.1のベータ版から導入予定の機能について紹介や、新しいライブラリ、AIモデルの発表がありました。以下の画像の通りです。&lt;/p>
&lt;h3 id="guard">Guard&lt;/h3>
&lt;p>whenの分岐で、変数の重複を防ぐための機能です。既存のコードなら、以下のようなコードで&lt;code>status&lt;/code>が重複する場合があっても、どうしようもなかったですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">render&lt;/span>(status: Status): String =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Loading &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Loading&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.isEmpty() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;No data&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">-&amp;gt;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.joinToString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Error &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.isCritical &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Critical problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unknown problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なぜなら、以下のようにコードを変えた場合に&lt;code>and&lt;/code>でコンパイルエラーが発生してしまうからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">render&lt;/span>(status: Status): String =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (status) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Status&lt;/span>.Loading &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Loading&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.isEmpty() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;No data&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Error: expecting &amp;#39;-&amp;gt;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">-&amp;gt;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.joinToString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Error &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.isCritical &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Critical problem&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Error: expecting &amp;#39;-&amp;gt;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unknown problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを改善するため、以下のように&lt;code>Guarded Condition&lt;/code>を導入する予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard_hu9521d200448d3c4a99eb6ca76abb58d4_87392_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard_hu9521d200448d3c4a99eb6ca76abb58d4_87392_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Guardの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="-escaping-problem">$-escaping problem&lt;/h3>
&lt;p>Kotlinで&lt;code>$&lt;/code>は、文字列の中で変数を埋め込むために使われています。ということは、&lt;code>$&lt;/code>を文字列として使いたい場合にエスケープの問題が発生するとのことでもあります。特にMulti-line Stringがそうですね。例えば、以下の例があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jsonSchema: String = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$schema&amp;#34;: &amp;#34;https://json-schema.org/draft/2020-12/schema&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$id&amp;#34;: &amp;#34;https://example.com/product.schema.json&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$dynamicAnchor&amp;#34;: &amp;#34;meta&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;title&amp;#34;: &amp;#34;Product&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>schema&lt;/code>や&lt;code>id&lt;/code>などは変数ではなく、文字列として使いたい場合がありますが、Multi-line Stringの場合にはエスケープができません。なので、以下のようなコードになるケースもありました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jsonSchema: String = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}schema&amp;#34;: &amp;#34;https://json-schema.org/draft/2020-12/schema&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}id&amp;#34;: &amp;#34;https://example.com/product.schema.json&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}dynamicAnchor&amp;#34;: &amp;#34;meta&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;title&amp;#34;: &amp;#34;Product&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを解決するために、文字列リテラルで&lt;code>$&lt;/code>を2回入れることでinterpolationできるようにする、という機能が導入される予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape_hu3203318b61bb42e5c5916a550c5b226c_89156_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape_hu3203318b61bb42e5c5916a550c5b226c_89156_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="$-escaping problemの解決"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="non-local-breakcontinue">Non-local break/continue&lt;/h3>
&lt;p>今までは、コンパイラーがLambdaが実行される場所を特定できないため、&lt;code>break&lt;/code>や&lt;code>continue&lt;/code>が使えなかったです。なので、以下のようなコードはエラーになってしまいます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0.&lt;/span>.n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> date = state[i]&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#75715e">// Error: &amp;#39;break&amp;#39; is not allowed here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">continue&lt;/span> &lt;span style="color:#75715e">// Error: &amp;#39;continue&amp;#39; is not allowed here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> process(&lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これもまた、Kotlin 2.1からは&lt;code>let&lt;/code>のようなinline関数を正しく解析できるようになるため、&lt;code>break&lt;/code>や&lt;code>continue&lt;/code>が使えるようになるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/non-local-break-continue.webp"
loading="lazy"
alt="Non-local break/continueの解決"
>&lt;/p>
&lt;h3 id="contexts">Contexts&lt;/h3>
&lt;p>去年発表された&lt;code>Context&lt;/code>についても発表がありました。これはすでにプレビューとして導入されていて、Kotlin 2.2からはベータ版として提供される予定だそうです。これでDIと似たようなことをしたり、セッションやトランザクションなど色々な関数で使い回す必要があるものは、関数の引数に渡すことなく、&lt;code>Context&lt;/code>を使って共有することができるようになります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/contexts.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/contexts_hu56f3d437804e5230ee0dd5ddb1a1b5e9_81618_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/contexts_hu56f3d437804e5230ee0dd5ddb1a1b5e9_81618_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Contextの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="core-libraries">Core Libraries&lt;/h3>
&lt;p>Kotlinのコアライブラリも改善される予定だそうです。すでに発表されている&lt;a class="link" href="https://github.com/Kotlin/kotlinx-io" target="_blank" rel="noopener"
>kotlinx.io&lt;/a>のようなものだけでなく、&lt;a class="link" href="https://github.com/Kotlin/kotlinx-rpc" target="_blank" rel="noopener"
>kotlinx.rpc&lt;/a>のような新しいライブラリの発表もありました。これらのコアライブラリは、Multiplatformでの開発をサポートするために提供されるもので、どのプラットフォームでも使えるものです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries_hu4860cf71836d2df4ff0406de789a76fb_79312_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries_hu4860cf71836d2df4ff0406de789a76fb_79312_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Core Librariesの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="aws-sdk-for-kotlin">AWS SDK for Kotlin&lt;/h3>
&lt;p>Kotlin用のAWS SDKも提供される予定という発表もありました。今まではJavaのSDKを使うことが多かったのですが、CoroutineやNull SafetyのようなKotlinの特徴を活かせつつ、Multiplatformで使えるSDKが提供されるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk_hude1a88b155c3317ae0d889e904fff447_88676_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk_hude1a88b155c3317ae0d889e904fff447_88676_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="AWS SDK for Kotlinの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="kotlin-language-model">Kotlin Language Model&lt;/h3>
&lt;p>Fleetではすでに利用可能で、Intellijでは2024.2から利用可能となるKotlinの言語モデルが開発中のことです。既存のいくつかのモデルと比べ、Kotlinに特化されたからか、比較的パラメータの数が少ないことに比べ、ベンチマークでは高い精度を示しているとのことです。ただ、比較で使っているLlamaの場合はすでにバージョン3がリリースされているので、最新のモデルと比べる場合どの程度の精度があるのかは気になるところです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model_hu6e0fd101ad4ac706498eb15da5bb2442_84954_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model_hu6e0fd101ad4ac706498eb15da5bb2442_84954_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Kotlin Language Modelの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>KotlinConf'24のキーノートでの発表内容を以上でまとめてみました。他にも多くのセッションがあ理、Kotlin 2.0も&lt;a class="link" href="https://github.com/JetBrains/kotlin/releases/tag/v2.0.0" target="_blank" rel="noopener"
>Changelog&lt;/a>を見ると、多くの変更があるので、また色々とチェックしていきたいところですね。&lt;/p>
&lt;p>Composeの発展も良かったのですが、Flutterのような他のフレームワークもあるのでこれからどれだけのシェアを取れるかが楽しみです。言語としても他の言語の発展も早いので、Kotlinも引けを取らないように頑張ってほしいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinConf'23を要約してみた</title><link>https://retheviper.github.io/posts/kotlin-conf-2023/</link><pubDate>Fri, 14 Apr 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-conf-2023/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinConf'23を要約してみた" />&lt;p>今年も&lt;a class="link" href="https://kotlinconf.com/" target="_blank" rel="noopener"
>KotlinConf&lt;/a>が開催されました。毎年興味を持って参加やキーノートを視聴しているわけでもありませんが、最近はK2 CompilerにやKMMなどJetbrainsのプロダクトがかなり盛んな感じなので視聴することにしました。そこで思ったより興味深い発表が多かったので、今回はその内容について簡単にまとめてみようかなと思います。&lt;/p>
&lt;p>では、セッション別にどんな話があったのかを紹介していきます。&lt;/p>
&lt;h2 id="k2-compiler">K2 Compiler&lt;/h2>
&lt;p>まずはKotlin 2.0で採用予定の&lt;a class="link" href="https://blog.jetbrains.com/kotlin/2021/10/the-road-to-the-k2-compiler/" target="_blank" rel="noopener"
>K2 Compiler&lt;/a>の話です。2021年から発表されていて、コンパイラの性能向上のみでなくプラグイン対応などの機能も提供する予定となっていますね。今現在開発が進んでいて、Kotlin 1.8がリリースされた今もかなり多い部分が完成されている状態です。&lt;/p>
&lt;p>ここではKotlin 1.8と、2.0になった場合のコンパイラのパフォーマンスの違いをまずグラフとして提示していました。当たり前ながら、2.0でかなり速度が上がったように見えます。同じ環境で20秒かかるものが、10秒に短縮されたということですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison_hu289f29ab394cd6066b8df4bdc9e6c13b_69280_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison_hu289f29ab394cd6066b8df4bdc9e6c13b_69280_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="コンパイル時間の比較"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Andoridの公式言語としてKotlinが採用され、JavaからKotlinに移行した開発者の間でやはりビルドが遅くなったという話を聞いた覚えがあるのでこれはかなり嬉しい結果となっていますね。またコンパイラのパフォーマンスが上がるとintellijでのコンパイルも早くなるわけなのでより快適な開発環境になると思います。&lt;/p>
&lt;p>また、今年の後半にはKotlin 1.9のリリースが予定されていて、その次に1.10のようなバージョンは予定にないとのことでした。つまり、1.9の後はすぐに2.0となるとのことですね。そして2.0は1.9の後方互換性を保つので、1.9でコンパイルができるのであれば2.0でもコンパイルができるとのことです。&lt;/p>
&lt;p>もちろん言語のバージョンアップを急ぐ企業さんはそこまではないと思いますし、コンパイラ自体が変わることでどんな問題が起こるかわからないので、実際の採用まではかなり時間がかるでしょう。ただ個人的にはサイドプロジェクトで色々試してみたいので、来年からはK2 Compilerに触れられるということが楽しみです。&lt;/p>
&lt;h2 id="要望の多い機能">要望の多い機能&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.jetbrains.com/youtrack/" target="_blank" rel="noopener"
>Youtrack&lt;/a>というサイトからJetbrainsのプロダクトに関して議論できるのですが、ここで要望の多い機能に対して今後どのような形で対応していくかを説明するセッションです。ここは一つ一つ、どのような要望があるかを見ていきます。&lt;/p>
&lt;h3 id="static-extensions">Static Extensions&lt;/h3>
&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-11968/Research-and-prototype-namespace-based-solution-for-statics-and-static-extensions" target="_blank" rel="noopener"
>KT-11968&lt;/a>に上がっているもので、JavaクラスにもCompanion objectのように、staticなメソッドやプロパティを追加できるようにしてほしいということです。&lt;/p>
&lt;p>例えば、今までは以下のようにJavaのクラスにCompanion objectを定義してインスタンスの生成なしで使うことはできませんでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">File&lt;/span>.&lt;span style="color:#66d9ef">open&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;data.txt&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>.&lt;span style="color:#a6e22e">Companion&lt;/span>.&lt;span style="color:#66d9ef">open&lt;/span>(name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、&lt;code>static&lt;/code>というキーワードを使って以下のように書けるようになるとのことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>.static.&lt;span style="color:#66d9ef">open&lt;/span>(name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的にはMySQLとJVMの日付のMAX_VALUEの閾値が違ってバグが起きたことがあって、LocalDateに別途プロパティを追加したかったのにJavaのクラスにはstaticなプロパティの追加ができなくて諦めた経験があるのでこれはとても嬉しい変化です。&lt;/p>
&lt;h3 id="collection-literals">Collection Literals&lt;/h3>
&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-43871/Collection-literals" target="_blank" rel="noopener"
>KT-43871&lt;/a>に上がっているもので、その名の通りコレクションのリテラルを作成できるようにしてほしいということです。&lt;/p>
&lt;p>例えば、今までは言語レベルでコレクションのリテラルに対応していなかったので、以下のような書き方が多かったかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>cmdArgs = listOf(&lt;span style="color:#e6db74">&amp;#34;-language-version&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;2.0&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>それが、以下のようにコレクションのリテラルを書けるようになるとのことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> skip: PersistentSet&amp;lt;Int&amp;gt; = [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> skip2 = PersistentSet [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的には&lt;code>const&lt;/code>キーワードの適用範囲をもっと広げてほしいと思っているところですが、これもまた悪くない変化ですね。特にアノテーションなどで使われる配列は実際リテラルになるケースが多いと思いますので、そこでまた色々と活用できる余地ができるかもしれません。&lt;/p>
&lt;h3 id="name-based-destructing">Name-Based Destructing&lt;/h3>
&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-19627" target="_blank" rel="noopener"
>KT-19627&lt;/a>に上がっているもので、分解宣言時に変数名とフィールド名が一致するようにしてほしいということです。&lt;/p>
&lt;p>例えば以下のように分解宣言をしたとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> firstName: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastName: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>firstName, lastName) = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Doe&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードの場合、&lt;code>firstName&lt;/code>は&lt;code>John&lt;/code>, &lt;code>lastName&lt;/code>は&lt;code>Doe&lt;/code>となります。data classの実際のフィールド名とも一致しているので、なんの問題もありません。ただ、もし間違って以下のようにしたらどうでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>lastName, firstName) = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Doe&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、意図とは違って&lt;code>firstName&lt;/code>は&lt;code>Doe&lt;/code>, &lt;code>lastName&lt;/code>は&lt;code>John&lt;/code>となってしまいます。このようなミスを回避するために&lt;a class="link" href="https://kotlinlang.org/docs/inline-classes.html" target="_blank" rel="noopener"
>inline class&lt;/a>などを導入してフィールドごとに型を定義したり、分解宣言そのものを使わないようにするなどの対応をしていることも少なくはないかと思いますが、今後はこのようなミスを回避するために、分解宣言時に変数名とフィールド名が一致するかどうかコンパイラが判断して値の代入を行うことになるとのことです。&lt;/p>
&lt;p>個人的にはかなりすごいと思いますが、心配も多いですね。単純に変数名とフィールドが一致する時のみ動作してくれるのかどうかわからないので、実際の動作を見ておきたいものです。&lt;/p>
&lt;h3 id="context-recivers">Context Recivers&lt;/h3>
&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-10468/Context-receivers-multiple-receivers-on-extension-functions-properties" target="_blank" rel="noopener"
>KT-10468&lt;/a>に上がっているもので、関数にコンテキストが必要な場合はパラメータとしてではなく、別途のキーワードを使ってコンテキストを渡すことができるようにしてほしいということです。&lt;/p>
&lt;p>例えば、以下のような関数があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">processRequest&lt;/span>(context: ServiceContext, request: ServiceRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = request.loadData(context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数ではコンテキストを引数としてもらい、さらにそのコンテキストを違う関数の方に渡しています。当然、呼ばれる関数の方も引数にコンテキストが必要になります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ServiceRequest&lt;/span>.loadData(context: ServiceContext): Data { &lt;span style="color:#75715e">/** ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、関数の中で呼ばれる他の関数が多くなればなるほど、その関数にもコンテキストを渡す必要が出てきます。そこで、以下のように別途のキーワードを使って、引数の追加なしでコンテキストを渡すことができるようになるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>context(ServiceContext)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">processRequest&lt;/span>(request: ServiceRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = request.loadData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>context(ServiceContext)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ServiceRequest&lt;/span>.loadData(): Data { &lt;span style="color:#75715e">/** ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>context&lt;/code>のキーワードに渡せるコンテキストの基準が何か、そしてどのように関数の中でコンテキストを呼び出せるかどうかはまだわかりませんが、より綺麗な感覚になっているかなと思います。&lt;/p>
&lt;h3 id="explicit-fields">Explicit Fields&lt;/h3>
&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-14663/Support-having-a-public-and-a-private-type-for-the-same-property" target="_blank" rel="noopener"
>KT-14663&lt;/a>に上がっているもので、privateなプロパティに対してpublicなプロパティを定義しなくても良いようにしてほしいということです。&lt;/p>
&lt;p>例えば、privateのプロパティに対して、外部から参照する場合は以下のように書くケースがあるかなと思います。privateなプロパティを維持しつつ、外部で参照のみできる別のプロパティがその値を提供するということですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _applicationState = MutableStateFlow(State())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> applicationState: StateFlow&amp;lt;State&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = _applicationState
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、以下のように書けるようになるらしいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> applicationState: StateFlow&amp;lt;State&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span> = MutableStateFlow(State())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>行数をかなり減らせられ、似たようなプロパティを定義する必要もなくなるのでかなり便利そうな感覚です。特にComposeのようにプロパティで状態を管理する場合はこのようなパターンが多いかなと思いますので、有効活用できるかなと思いました。&lt;/p>
&lt;h2 id="kotlin-notebooks">Kotlin Notebooks&lt;/h2>
&lt;p>このセッションで新しくKotlin Notebooksというものの発表がありました。今は&lt;a class="link" href="https://jupyter.org/" target="_blank" rel="noopener"
>Jupyter Notebook&lt;/a>でもKotlinは使えるのですが、似たような機能をKotlin専用として開発したような感覚ですね。Jupyterそのものも有名で、動画の中ですでに多くの機能を紹介しているので説明よりはそのキャプチャを載せておきます。以下のような活用例が紹介されています。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1_hu06403b1b89feef3e492decaed0d81c46_68910_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1_hu06403b1b89feef3e492decaed0d81c46_68910_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="プロトタイピング"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2_hu139c01037ed2db259a137cf88a47579f_91280_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2_hu139c01037ed2db259a137cf88a47579f_91280_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="言語使用の学習(AIサポート)"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3_hu450f7497e01387b52bed7e5737209c2e_74536_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3_hu450f7497e01387b52bed7e5737209c2e_74536_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="アルゴリズムの検証(ソートのビジュアライズ)"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4_hu0677be80cf782869dae8d9ee20bfd5cc_98812_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4_hu0677be80cf782869dae8d9ee20bfd5cc_98812_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="データ調査"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5_hue2b369f0f8b7dd6ad3a2d83552345cc6_72452_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5_hue2b369f0f8b7dd6ad3a2d83552345cc6_72452_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="データ分析"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6_hu165594b5fb29de743fc2d838d18cdaa6_66612_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6_hu165594b5fb29de743fc2d838d18cdaa6_66612_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Plot生成"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>その他、自動完成やオンラインでのコードシェア対応、テーブルのソートとカラムの順番変更などができるという点が紹介で明らかになっています。&lt;/p>
&lt;h2 id="googlekotlinconf">Google@KotlinConf&lt;/h2>
&lt;p>こちらのセッションはGoogleの人が出て発表をしていましたが、主に指標の話で、Androidのアプリの中でKotlinやComposeを採用しているものがどれほど多いかの話などが多かったですね。また、GoogleでもKotlinを積極活用していて、Google WorkspaceでもKotlin Multiplatformを利用してビジネスロジックを書いているという話がありました。&lt;/p>
&lt;p>他に注目したいところは、Androidの開発においてGradleのデフォルト設定がKotlin DSLになったというところです。Kotlinで開発をしているならもちろんGroovyよりはKotlinの方が便利だと思っていたので、このような変化はありがたいですね。&lt;/p>
&lt;p>ただ、GoogleでもKotlinを利用しているとはいえ、FlutterやGoという競合もあるので、今後どのような方向性を取っていくのかが気になりました。もちろんKotlinのカンファレンスなのでそのような話には触れなかったのですが、今後のGoogleの方針やCompose Multiplatformのシェアについてはもっと注目したいと思いました。&lt;/p>
&lt;h2 id="crossplatform">Crossplatform&lt;/h2>
&lt;p>このセッションではComposeのiOS対応の発表と、Mutiplatformの現在の紹介などがありました。ComposeのiOSはAlpha、MultiplatformはBetaの段階で多くのライブラリが対応しているなどの話が続きましたね。Kotlinが初めからJVM以外の領域でも活用できることを目標として開発されたのは確かですが、登場から10年以上も経ってやっとそのロードマップが現実になっているなという感覚でした。&lt;/p>
&lt;p>個人的にはXcodeやSwiftUIよりはintellijとComposeの方が合っていると感じていたので、iOSの開発ができるようになったのは大変嬉しく思っています。特に、AppCodeの開発が今年て終了するとのことだったのでMacやiOSの開発のためには致し方なくSwiftUIを勉強する必要があるかなと思っていたところなのでタイミング的にも最適ですね。直近でちょうどKotlinのみでウェブとモバイル、デスクトップのアプリを開発するというサイドプロジェクトをやっているので、早速試してみようかなと思っています。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>純粋にK2 Compilerの現在が知りたくて試聴した動画で、思わぬ発表が続いて嬉しい気持ちになりました。個人的には一つの言語で必要なことができるようにしたいと思っていたので、Kotlinという言語を選択したのは正解だったという気持ちになりました。&lt;/p>
&lt;p>やはりまだサーバサイドでもシェアはそこまで高くないかなと思いますが、これからもいろいろな分野でKotlinを使える環境が整っていくと言語として伸びるポテンシャルは十分など思いますので、また今後に期待ですね。&lt;/p>
&lt;p>取り急ぎ、KotlinConfのキーノートの動画を紹介しましたが、他にもいろいろな動画が公式のチャンネルにて配信中なので、興味がある方はぜひ見てみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinだけでファイルサーバを作ってみた</title><link>https://retheviper.github.io/posts/kotlin-compose-web/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-compose-web/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinだけでファイルサーバを作ってみた" />&lt;p>世の中にはさまざまなプログラミング言語があり、それぞれの特徴も明確で、言語ごとにできる・できないことも違うケースが多いですね。企業ならエンジニアの採用や費用など現実的な観点から技術選定をするので、プロジェクトにおいてどの言語を使うかは明確かつ一般的な基準があるかと思います。しかし、個人のレベルだとチームでの作業を考慮すべきでもなく、その人の好みや慣れというものから言語を選ぶ傾向があるのではないかと思います。なので、割とマイナーな言語やフレームワークを使うケースもあるでしょう。&lt;/p>
&lt;p>自分がまさにそうであって、個人的に使うために実装するアプリや自動化のスクリプトなどは、なるべくKotlinやPythonで作成しています。特にKotlinの場合、仕事でも使っているので最も慣れているからでもありますが、さまざまなフレームワークや言語自体の特徴によりサーバサイドというジャンルやJVMという環境に限らずいろいろなことにチャレンジできるのが魅力的で好きです。&lt;/p>
&lt;p>というわけで、今回もプライベートでちょっと変わった形でウェブアプリを一つ作ってみた、という話です。どこが変わっているかというと、表題にも書いてある通りですが、「Kotlin」だけでファイルサーバのアプリを実装した話となります。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>まず、どんなアプリをなぜ作ったかから述べないとですね。私の実家には、以前から使っていたWindowsのパソコンがあります。組み立てたのはおよそ8年ほど前のことで、最近は自分が実家に帰ることも少ないのであまり使われてないです。ただ、今のPC(Mac)からファイルを送ったりもらったりして使うことがあります。&lt;/p>
&lt;p>ここでファイルのやりとりには、今までMicrosoft社の&lt;a class="link" href="https://www.microsoft.com/ja-jp/microsoft-365/onedrive/online-cloud-storage" target="_blank" rel="noopener"
>OneDrive&lt;/a>を使っていました。片方で必要なファイルをOneDriveのフォルダにコピーしておくと、そのファイルがクラウドにアップロードされ、自動的に同期される方式ですね。これでも問題は全然なく安定的に使ってはいましたが、ふと思うとクラウドを経由するというステップが無駄だという気がしました。また、同期の前後でファイルをコピーしたり移動したりすることもめんどい作業になっています。&lt;/p>
&lt;p>ここで、自分でインターネット越しでファイルのやり取りができるアプリを作ってみたらどうかと思ったわけです。すでに自分が思っているような機能を提供している何らかのサービスはあるかもしれませんが、そこまで複雑なものでもないので、数日で作れるような気がしましたのでとりあえずチャレンジしてみることにしました。（SFTPというオプションもありましたが、GUIで楽にしたかったので却下です）&lt;/p>
&lt;h2 id="要件">要件&lt;/h2>
&lt;p>さて、作りたいものがあったらやることは決まっています。いつものことですが、アプリを作る前に簡単に要件を決めておきます。まず、機能的には以下のようなことができれば良いかなと思いました。&lt;/p>
&lt;ul>
&lt;li>サーバアプリを起動すると、クライアントからサーバのストレージにアクセスできる&lt;/li>
&lt;li>サーバのパスを指定したらその中身（ファイルとフォルダ）が見える&lt;/li>
&lt;li>フォルダをクリックすると表示中のパスが変わる&lt;/li>
&lt;li>ファイルをクリックするとダウンロードできる&lt;/li>
&lt;li>パスにファイルをアップロードできる&lt;/li>
&lt;/ul>
&lt;p>機能が決まったらそれを実現するための技術の番ですね。ここでは、何よりもKotlinで全て解決したい！という考えで、技術選定は全てKotlinを中心にしています。&lt;/p>
&lt;p>まずFrontendでは、ちょうどこないだ&lt;a class="link" href="https://www.jetbrains.com/lp/compose-desktop/" target="_blank" rel="noopener"
>Compose for Desktop&lt;/a>で簡単なアプリを作ったとこのブログに書いたことがありましたが、&lt;a class="link" href="https://compose-web.ui.pages.jetbrains.team/" target="_blank" rel="noopener"
>Compose for Web&lt;/a>というものもあったので、今回はこれを使ってみるとどうかなと思いました。これに関しては言語を統一したいという理由が最も大きいのですが、他にはFrontendの経験や知識があんまりないので少しでも触れてみた技術を使いたかったという理由もあります。&lt;/p>
&lt;p>Backendのフレームワークは&lt;a class="link" href="https://ktor.io/" target="_blank" rel="noopener"
>Ktor&lt;/a>にすることとしました。普段はSpringをやっているのでこちらの場合もあまり本格的な経験があるわけではありませんが、以前触れてみた感覚だとアプリの起動がはやく、実装も簡単だったので採用。また同じく、最も大きい理由はKotlin用ということです。&lt;/p>
&lt;p>大きくはこの二つで、他にも当然色々とライブラリなどが必要となるわけですが、ここは実装を進めながら必要なものがKotlin製かJetBrainsのものかを基準に選んで実装することにしました。もしくは実装において参考となるだろう公式のドキュメントに出てくるものを採用するという方針です。&lt;/p>
&lt;h2 id="frontend">Frontend&lt;/h2>
&lt;p>Frontendでは、先に述べた通りCompose for Webを使いました。やはり初めてということもあったのですが、まだ新しい技術だったり、そもそも自分がFrontendに対してあまりわかってないということもあったので最も工数がかかった部分です。ここについては、肌で感じたことを良かった点・思ったことと違った点・問題だった点という三つの軸で分けて述べていきたいと思います。&lt;/p>
&lt;h3 id="良かった点">良かった点&lt;/h3>
&lt;p>良かった点としては、やはりComposeでデスクトップアプリを作ってみた経験を活かした実装ができたというところです。Composeでは&lt;a class="link" href="https://developer.android.com/jetpack/compose/state#state-in-composables" target="_blank" rel="noopener"
>&lt;code>remember&lt;/code>と&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>&lt;/a>を組み合わせて状態を管理したり、&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Composable" target="_blank" rel="noopener"
>@Composable&lt;/a>をつけた関数の単位で画面の構成要素を分けて実装することができますが、ここでもそれは同じでした。&lt;/p>
&lt;p>なので、「指定したパスをブラウズ」する機能を実装した時、「一つ前のパスに戻る機能を追加したいな」と思ったときはそのパスを保持するために状態にパスを持たせたり、サーバから取得したパスの中身のオブジェクト（ファイルやフォルダなど）を画面に描画するためのコンポーネントを一つの&lt;code>@Composable&lt;/code>関数として定義して使ったりなどが思ったよりも簡単にできたわけです。&lt;/p>
&lt;p>他にもKotlinなのでCoroutineが簡単に使えたり、サーバサイドと同じリポジトリにソースコードを作成できるというところも良いところでした。特に後者の場合、GradleでKotlinのプラグインを&lt;code>multiplatform&lt;/code>にすることでFrontendではJavaScriptにコンパイルされ、サーバサイドではいつも通りJVMのバイトコードにコンパイルされるようにできるという点がお気に入りです。&lt;/p>
&lt;h3 id="思ったことと違った点">思ったことと違った点&lt;/h3>
&lt;p>自分の考えが甘かったのですが、Desktopとはかなり違うところがありました。何かというと、言語としてはKotlinを使うとしても、HTMLやCSSを排除することはできないという点です。ここでもやはり&lt;code>div&lt;/code>や&lt;code>form&lt;/code>のようなタグを使ったり、タグにマウスオーバ時のカーソルを変えるためにタグの&lt;code>attr&lt;/code>を変更する必要がありました。例えば、以下はファイルアップロードのコンポーネントですが、Kotlinで書いているだけで実際はHTMLをそのまま書いているような感覚です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Composable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">FileUploadForm&lt;/span>(currentPath: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Div {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Form(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$API&lt;/span>&lt;span style="color:#e6db74">_URL&lt;/span>&lt;span style="color:#e6db74">$ENPOINT&lt;/span>&lt;span style="color:#e6db74">_UPLOAD&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attrs = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method(&lt;span style="color:#a6e22e">FormMethod&lt;/span>.Post)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> encType(&lt;span style="color:#a6e22e">FormEncType&lt;/span>.MultipartFormData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target(&lt;span style="color:#a6e22e">FormTarget&lt;/span>.Blank)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HiddenInput {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name(&lt;span style="color:#e6db74">&amp;#34;target&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span>(currentPath)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Input(&lt;span style="color:#a6e22e">InputType&lt;/span>.File) { name(&lt;span style="color:#e6db74">&amp;#34;file&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Input(&lt;span style="color:#a6e22e">InputType&lt;/span>.Submit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここは完全に他のプラットフォームでのComposeを使うというよりは、Kotlinようにラップされたクラスを提供するだけという印象が強く、やはりある程度Frontendの知識が必要となる部分ではないかと思っています。なので、&lt;a class="link" href="https://reactjs.org/" target="_blank" rel="noopener"
>React&lt;/a>や&lt;a class="link" href="https://vuejs.org/" target="_blank" rel="noopener"
>Vue.js&lt;/a>などメジャーなFrontendのフレームワークの知識がある場合にはあまりComposeを選ぶ理由はなさそうな気がしています。&lt;/p>
&lt;p>他には、いつもとは違ってKotlin/JSとKotlin/JVMが共存するプロジェクトとなっているためか、intellij上の自動補完やビルド時の挙動が少し違う感覚があります。例えば、Gradleで依存関係を変更してもすぐに反映されなかったり…&lt;/p>
&lt;h3 id="問題だった点">問題だった点&lt;/h3>
&lt;p>意外と問題になったのは、プロジェクトのビルドでした。Compose for Webでは&lt;code>index.html&lt;/code>ファイルとWebpackなどを使ってビルドされた&lt;code>js&lt;/code>ファイルを使うことになり、ビルド自体はGradleのコマンドひとつで簡単にできるものですが、どうやら内部的に&lt;a class="link" href="https://yarnpkg.com/" target="_blank" rel="noopener"
>yarn&lt;/a>などを使っているようですが、intellijで生成したプロジェクトのデフォルト設定ではビルド時にエラーが出ることが多かったです。&lt;/p>
&lt;p>調べてみると自分のようなエラーが出る場合、&lt;a class="link" href="https://github.com/Kotlin/kotlinx-datetime/issues/193" target="_blank" rel="noopener"
>ビルドできない場合はKotlinのバージョンが&lt;code>v1.6.20&lt;/code>以降だと解消される&lt;/a>らしいのですが、問題はComposeのバージョンでした。このアプリを実装した時点の最新は&lt;a class="link" href="https://github.com/JetBrains/compose-jb/releases/tag/v1.1.1" target="_blank" rel="noopener"
>v1.1.1&lt;/a>なのですが、これだと対応しているKotlinのバージョンが&lt;code>v1.6.10&lt;/code>までです。なので、自分の場合は&lt;code>v1.2.0&lt;/code>のベータ版を使ってKotlinのバージョンを&lt;code>v1.7.10&lt;/code>にしてから解消できました。これはマイナーなプロジェクトのハマりどころと言えるものかもしれないですね。&lt;/p>
&lt;p>また、HTTPクライアントとしては&lt;a class="link" href="https://ktor.io/docs/getting-started-ktor-client.html" target="_blank" rel="noopener"
>Ktor Client&lt;/a>を使っていますが、大容量のファイルをアップロードする場合を想定して&lt;code>form&lt;/code>タグでMultipartのデータを直接送るよりHTTPクライアントを使う方法を取ろうとするとうまくいかなかったです。Ktor ClientはMultiplatform対応のものなので、クライアントの宣言時に&lt;a class="link" href="https://ktor.io/docs/http-client-engines.html" target="_blank" rel="noopener"
>どのEngineを使うかを選択できる&lt;/a>のですが、Kotlin/JSで使えるEngineだと&lt;a class="link" href="https://ktor.io/docs/request.html#binary" target="_blank" rel="noopener"
>公式で紹介している内容&lt;/a>通りに実装しても&lt;code>File&lt;/code>オブジェクトを直接扱えないので送信ができませんでした。ここは今後の改善に期待するか、Websocketなどを使うなど他の方法を取る必要がありそうです。&lt;/p>
&lt;h2 id="backend">Backend&lt;/h2>
&lt;p>次にBackendですが、こちらは自分の慣れている分野で、Ktor自体については他のポストでも述べたことがあり、技術的な面の話よりはロジック面で試行錯誤をしたことを中心に述べていきたいと思います。&lt;/p>
&lt;h3 id="ファイルツリーのブラウズ">ファイルツリーのブラウズ&lt;/h3>
&lt;p>このアプリにはまずファイルをブラウズする機能があるので、クライアントで指定したパスを探索して、その中にあるコンテンツ（ファイルとフォルダ）を返す必要があります。問題は、JSONの構造をどうするかですね。ここではまず一つの方法を試してみてから判断することにしました。&lt;/p>
&lt;h4 id="全取得する">全取得する&lt;/h4>
&lt;p>最初は、以下のような形で実装をしようと思いました。パスを指定したら、その配下にある全てのフォルダをたどり、親子関係をネストで表現する形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Documents&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;children&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;SomeDocument.pdf&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;file&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1391482&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;mimeType&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;application/pdf&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Images&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;children&amp;#34;&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようなファイルツリー返すために、サーバ側のコードは以下のようなものを使いました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ルートとなるパスを指定すると、子要素（ファイルとフォルダ）を全て取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> files = &lt;span style="color:#a6e22e">Files&lt;/span>.list(root)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#66d9ef">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathをJSONオブジェクトとして加工する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Path&lt;/span>.toFileTree(): FileTree {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> FileTree(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">this&lt;/span>.fileName.toString(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.fileSize(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#a6e22e">FileType&lt;/span>.DIRECTORY &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">FileType&lt;/span>.FILE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> children = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.list(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#66d9ef">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walk-java.nio.file.Path-java.nio.file.FileVisitOption...-" target="_blank" rel="noopener"
>Files.walk()&lt;/a>を使うと、指定したパスを基準にネストされているファイルツリーを全て&lt;code>Stream&amp;lt;Path&amp;gt;&lt;/code>として取得してくれますが、それだと上記のJSONの形として加工するのが簡単ではないです。一度取得した結果をもとに、親子関係を追跡しながらJSONオブジェクトとしてまとめるにはかなり複雑な処理になるっでしょう。&lt;/p>
&lt;p>なので、ここでは&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#list-java.nio.file.Path-" target="_blank" rel="noopener"
>Files.list()&lt;/a>を使って指定したパスに含まれた要素を取得し、その要素がディレクトリの場合はさらに子要素として取得するように再帰を使って子要素を再度取得するという形としてまとめています。単純な処理ですが、効率的になりましたね。&lt;/p>
&lt;p>ただ、この方法で思った通りのファイルツリーをJSONとして返すことはできましたが、問題がありました。まず、指定したパスがルートに近くなればなるほど探索にかかる時間が長くなり、レスポンスも遅く慣ればJSONのサイズも大きくなるという問題がありました。また、JSONを受け取ったところで、Frontendで描画をするにも難点がありそうな気がしました。というわけで、この案はまず廃棄して、二つ目の方法を取ることにしました。&lt;/p>
&lt;h4 id="ネストさせない">ネストさせない&lt;/h4>
&lt;p>次に試した方法は、指定したパスのみに処理を制限することでした。何かというと、JSONオブジェクトのネストを無くして、指定したパスにどんなファイルとフォルダが含まれているかだけをリストとして返すということです。つまり、以下のような形になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Documents&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Images&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうなると、中のフォルダを辿る必要がなくなるのでレルポンスも早く、軽くなるわけです。最初からちゃんと考えるべきだったのですが、こちらの方がFrontendとしても実装が楽であって、さらにサブパスのフォルダにアクセスしたい場合はそのパスを再度Backendに送ればいいだけですね。コードとしては再帰を使わなくなったくらいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> files = &lt;span style="color:#a6e22e">Files&lt;/span>.list(root)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#66d9ef">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathをJSONオブジェクトとして加工する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Path&lt;/span>.toFileTree(): FileTree {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> FileTree(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">this&lt;/span>.fileName.toString(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.fileSize(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#a6e22e">FileType&lt;/span>.DIRECTORY &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">FileType&lt;/span>.FILE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルアップロード">ファイルアップロード&lt;/h3>
&lt;p>ファイルアップロードについては、Mutlipartとして送られているデータをどう扱うかですが、これはKtorらしく簡単な処理で対応できました。以下のコードが実際の実装となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// router
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>post(ENPOINT_UPLOAD) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Multipartデータを受信
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> multipart = call.receiveMultipart()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイル保存先のパス
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> path = &lt;span style="color:#a6e22e">Path&lt;/span>.of(ROOT_DIRECTORY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> multipart.forEachPart { part &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (part) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ルートでないパスを指定した場合は保存先を更新
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">PartData&lt;/span>.FormItem &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (part.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;target&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = path.resolve(part.&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルデータを保存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">PartData&lt;/span>.FileItem &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> file = &lt;span style="color:#a6e22e">Files&lt;/span>.createFile(path.resolve(part.originalFileName&lt;span style="color:#f92672">!!&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> part.streamProvider().use { input &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.newOutputStream(&lt;span style="color:#66d9ef">file&lt;/span>).use { output &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input.copyTo(output)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// どちらでもない場合は一旦出力
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Unknown part: &lt;/span>&lt;span style="color:#e6db74">$part&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 処理の終わったデータはdispose
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> part.dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、個人的にはストレージアクセスのある処理に対してはNIOを使いたいので、はじめは&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/nio/file/Files.html#copy-java.io.InputStream-java.nio.file.Path-java.nio.file.CopyOption...-" target="_blank" rel="noopener"
>Files.copy()&lt;/a>を使おうと思ったのですが、なぜかファイルの保存処理を以下のような作成するとうまくいかなったです。Coroutineとの相性に何か問題があるのかもしれないですので、ここは注意ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> file = &lt;span style="color:#a6e22e">Files&lt;/span>.createFile(path.resolve(part.originalFileName&lt;span style="color:#f92672">!!&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Files&lt;/span>.copy(part.streamProvider(), &lt;span style="color:#66d9ef">file&lt;/span>) &lt;span style="color:#75715e">// ファイルが保存されない
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルダウンロード">ファイルダウンロード&lt;/h3>
&lt;p>ファイルダウンロードの場合も、ロジックは特にないので、ほとんどKtorのみのコードとなっています。自分の好みでPathを使っているくらいですのでコードだけを紹介します。ひとつ注意すべきところは、アップロードする時もそうですが、ファイル名を返すときにURLパスとしてエンコードすることですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">get&lt;/span>(ENDPOINT_DOWNLOAD) {&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> filepath = call.request.queryParameters[&lt;span style="color:#e6db74">&amp;#34;filepath&amp;#34;&lt;/span>] &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> path = &lt;span style="color:#a6e22e">FileService&lt;/span>.getFullPath(filepath) &lt;span style="color:#75715e">// ルートディレクトリからのフルパスを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">Files&lt;/span>.notExists(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.BadRequest, &lt;span style="color:#e6db74">&amp;#34;File not found&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.response.header(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#a6e22e">HttpHeaders&lt;/span>.ContentDisposition,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#a6e22e">ContentDisposition&lt;/span>.&lt;span style="color:#a6e22e">Attachment&lt;/span>.withParameter(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = &lt;span style="color:#a6e22e">ContentDisposition&lt;/span>.&lt;span style="color:#a6e22e">Parameters&lt;/span>.FileName,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> = path.fileName.toString().encodeURLPath()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ).toString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respondFile(path.toFile())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="注意すべきところ">注意すべきところ&lt;/h3>
&lt;p>まず、一つのプロジェクトにKotlin/JSとKotlin/JVMを両立する場合、&lt;code>dependencies&lt;/code>として記述するものに対しては&lt;code>build.gradle.kts&lt;/code>ファイルで以下のように指定することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>kotlin {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sourceSets {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Kotlin/JSの依存関係
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> jsMain &lt;span style="color:#66d9ef">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(compose.web.core)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(compose.runtime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Kotlin/JVMの依存関係
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> jvmMain &lt;span style="color:#66d9ef">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-core-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-auth-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Composeを使うためには&lt;code>plugin&lt;/code>として指定する必要があり、これがプロジェクト全体の依存関係に追加されることになっていました。なので、アプリの作りとしてはまずFrontendのComposeをビルドし、サーバを起動したらビルドしたファイルをstaticとして提供する構造になっていますが、Backendの起動にもComposeのランタイムが必要になります。このランタイムを追加してくれないと、エラーが吐き出され、Ktorが起動できなくなっています。何かKotlin/JSのみの依存関係にpluginを追加する他の方法があるかもしれませんが、とりあえずはJVMの依存関係に以下のようにランタイムを追加することで問題は解消できました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jvmMain &lt;span style="color:#66d9ef">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-core-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-auth-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> implementation(compose.runtime) &lt;span style="color:#75715e">// Composeランタイム
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="その他">その他&lt;/h2>
&lt;p>Kotlin/JSとKotlin/JVMを一つのプロジェクトとして扱う場合に、&lt;code>common&lt;/code>というパッケージを設けることで、コードの共有ができるのが何より嬉しかったところです。例えば、JSONオブジェクトをdata classとして定義してcommonパッケージに置くことで、FrontendとBackendの両方で同じオブジェクトを使うことができます。他にももちろんEnumやconstを共有できたりするので、実装がかなり楽でした。&lt;/p>
&lt;p>また、今回は採用しなかったのですが、Ktor Serverの場合&lt;a class="link" href="https://ktor.io/docs/type-safe-routing.html#resource_classes" target="_blank" rel="noopener"
>Type-safe Routing&lt;/a>というものに対応しているので、うまく活用できたらかなり良さそうな気がしました。これはKtor Clientでも&lt;a class="link" href="https://ktor.io/docs/type-safe-request.html#define_route" target="_blank" rel="noopener"
>Type-safe Request&lt;/a>として対応しているので、FrontendとBackend両方で使える機能です。またKtorを使う機会があったら、ぜひ使ってみたいと思っています。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>ファイルアップロードが思った通り改善できなかったので、アプリの完成はまだ少し先のことになりそうですが、かなり面白い経験となりました。Kotlinでできることは色々とあるので、また何か作ってみたいものがあればチャレンジしてみたくなります。ただ、やはりまだ成熟してない技術なので、思ってもなかったところで問題が発生したりリファレンスがあまりないという点ではまだプロダクションレベルでは使えないものかなという気がします。&lt;/p>
&lt;p>アプリ全体のコードはGitHubにて公開していますので、&lt;a class="link" href="https://github.com/retheviper/FileTransporter" target="_blank" rel="noopener"
>こちら&lt;/a>から参照できます。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinでデスクトップアプリを作ってみた</title><link>https://retheviper.github.io/posts/kotlin-compose-desktop/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-compose-desktop/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinでデスクトップアプリを作ってみた" />&lt;p>バックエンドの開発をしていると、テストの自動化では対応できない場合もありますね。理想的なシナリオとしては、ユニットテストから全てのシナリオを想定したインテグレーションテストまでを全部作成でき、開発・企画に属するものがそれらを理解しきっていることだろうとは思いますが、現実ではなかなか難しいものです。特に、サービスが成長していきながら技術的負債を解消しようとしたり、新しい機能を足したり、昔は対応できなかった改修が必要となったり、運用上のイレギュラー対応が必要となったりなどで最初の仕様は変わり続けていき、改修を行うエンジニアや運用する側でも今の状態がどうで、どう変わるべきかを判断するのは難しくなりがちなのだから、と自分は理解しています。&lt;/p>
&lt;p>なので、少なくとも今のアプリがちゃんと想定通りに動くかどうかを人の手で検証する必要が出てくるケースも十分にあり得るものです。そしてそうなった場合はどうやってテストを行うかを考える必要もありますね。テストの方法も色々あり、小さい機能単位でユニットテストを行い、最終的にはインテグレーションテストやシナリオテストまで上がっていくと良いはずですが、その全部を自動化するのが難しいケースもあるかと思います。例えばテストするためのデータのパターンを色々と用意する必要があったり、エンジニアが完全に仕様を把握してなかったりなどの場合もありますね。なので、人の手によるテスト（モンキーテスト的な）が必要となる場面も存在すると思います。&lt;/p>
&lt;p>今回はその「人の手によるテスト」を手伝うために、テストツールを作った話です。自分の扱っているシステムはマイクロサービスの一つであり、業務仕様が複雑でさまざまなパターンで機能をテストする必要がありました。なのでエンジニアとしては実装を進めながら、同時に業務仕様に詳しい人にさまざまなパターンのデータを使ってテストができるツールを作ることになったわけです。&lt;/p>
&lt;h2 id="目標と設計技術選定">目標と設計、技術選定&lt;/h2>
&lt;p>実は以前から、リポジトリにはすでにテストツールが存在していました。しかし調べたところ、作られて2年以上放置されていて、Ruby on railsという自分が全く触れたことも（興味を持ったことも）ないフレームワークで作られているという問題がありました。これだと、自分がRubyを勉強して既存のツールを改修するという手もあったかもしれませんが、以下の理由から一から作り直そうと思いました。&lt;/p>
&lt;ol>
&lt;li>KotlinエンジニアがRubyアプリをメンテするのは良くない&lt;/li>
&lt;li>ドキュメント化が進んでなく、使い方が不便&lt;/li>
&lt;/ol>
&lt;p>そう決めてからは、テストを行いたい側（企画）からの要請を受け、ツールに要求される仕様としての機能をまとめることに。テストが行えるツールという確実な目標があったので、仕様は極めて単純です。要求事項としてツールに揃うべき機能は以下のようなものでした。&lt;/p>
&lt;ul>
&lt;li>テストデータのファイルを読み込ませる&lt;/li>
&lt;li>バックエンドのアプリのAPIを呼び出す&lt;/li>
&lt;li>APIの実行結果をファイルに書き込む&lt;/li>
&lt;/ul>
&lt;p>テストツールとしては上記に挙げている要求事項を満たしているならテストツールとしては合格というわけです。しかし、実際のテストを行いたい側がまずエンジニアではなく、今後もエンジニアではない人がツールを触る可能性があります。そこまでを考慮して、以下の追加的な目標を立てました。&lt;/p>
&lt;ul>
&lt;li>環境構築をしなくても使えるようにする&lt;/li>
&lt;li>手順書がなくても使えるくらい簡単なものに仕上げる&lt;/li>
&lt;/ul>
&lt;p>ここまで決めたら、次に要求されている機能の細部を掘り下げていきます。設計書を書くほどでもないですが、土台となる設計のようなものです。&lt;/p>
&lt;ul>
&lt;li>データの読み込みと書き込み
&lt;ul>
&lt;li>ツールを使える人はSQLが使える=テーブル（表）が読める&lt;/li>
&lt;li>テーブルの形でデータの入出力ができた方がわかりやすい&lt;/li>
&lt;li>テストデータはCSVで読み込む&lt;/li>
&lt;li>API実行結果もCSVに書き込む&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>APIコールができる
&lt;ul>
&lt;li>HTTPクライアントでGET・POSTする&lt;/li>
&lt;li>APIコールにはトークンが必要
&lt;ul>
&lt;li>トークンはセキュリティ問題でソースコードに埋め込むのはNG&lt;/li>
&lt;li>しかし毎回入力するのはめんどくさい&lt;/li>
&lt;li>アプリを実行して最初はトークンを入力し、次回からはそのトークンを使い回すようにする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>本番以外の環境が対象
&lt;ul>
&lt;li>複数の環境があるのでどれかを選択できるようにする&lt;/li>
&lt;li>これも毎回入力はめんどくさい&lt;/li>
&lt;li>最初に一回だけ選択できるようにしたい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>そして自分の立てた目標を、上記の要求事項を達成できるかどうかを考えながら振り返ってみます。環境構築をしなくても使えるなら、実行可能な一つのバイナリとして提供した方が良いでしょう。また、使い方が簡単な方だと、やはりGUIを含めた方が良いですね。特にGUIを採用したら要求事項に対してもかなり良い感じで機能を完成できると思いました。&lt;/p>
&lt;p>例えばファイルの読み込みや書き込みにはパスの指定が必要で、トークンと環境の選択も入力が必要な項目で、CLIだとやはり不便です。エンジニアではない人が触るとしたら尚更ですね。Windowsユーザなら、コマンドラインも考慮しなければならないかもしれません。その反面、GUIだとファイルパスならダイアログ、トークンの入力もテキストポックス、環境の選択ならプールダウンメニューで対応できます。なので、「バイナリの実行で起動できるGUIのアプリを作る」という結論を出しています。&lt;/p>
&lt;h2 id="compose-for-desktop">Compose for Desktop&lt;/h2>
&lt;p>テストツールの仕様と技術的な要件が決まったら次は技術選定になりますがね。まずどの言語を使うかについてですが、自分以外でも同じチーム、つまりKotlinエンジニアがこれからもメンテを行うことになる可能性が高いのでKotlinにしました。Kotlinを使うことで、機能の実現で必要なライブラリの選定も楽になりますね。すでにテスト対象のバックエンドアプリで使っているHTTPクライアントがあるので、一部のコードはそのまま移植しても良いはずです。また、同じライブラリを使うことでメンテもより簡単になるでしょう。&lt;/p>
&lt;p>あとはGUIですが、今回は&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-desktop/" target="_blank" rel="noopener"
>Compose for Desktop&lt;/a>を使うことにしました。KotlinはJavaと互換性があるので、当然&lt;a class="link" href="https://ja.wikipedia.org/wiki/Swing" target="_blank" rel="noopener"
>Swing&lt;/a>や&lt;a class="link" href="https://openjfx.io/" target="_blank" rel="noopener"
>JavaFX&lt;/a>などJavaのGUIツールキットをそのまま使うという選択肢もあります。他にも&lt;a class="link" href="https://github.com/edvin/tornadofx" target="_blank" rel="noopener"
>TornadoFX&lt;/a>という選択肢があったりもしますが、今回あえてComposeを選んだのはいくつかの理由があります。&lt;/p>
&lt;p>まずは個人的にモバイルに興味があって以前から興味を持っていたので、今回本格的にこれでアプリを作ってみたいという願望もありましたが、今後もKotlinエンジニアの手でメンテが行われるとすると、やはりモバイルの経験があるか、少なくとも興味を持つ方が多いだろうという点です。Composeはまだ正式リリースされて1年ほどしか経ってない新しいものですが、最近流行っているいわゆる「宣言型」のフレームワークなので、少なくともAndroidアプリの開発ではメインストリームになる可能性が高いだろうという判断からでした。&lt;/p>
&lt;p>また、Composeはモバイルのみでなく、そもそもマルチプラットフォーム向けに開発されたものなので、Windows/Mac/Linuxの環境を問わず実行可能なバイナリをビルドできるという点でも魅力的だったです。これならテスターがどんなOSを使っていても同じ感覚でツールを使えて、&lt;/p>
&lt;p>ただ、やはり今まであまり接したことのない技術なので勉強はもちろん試行錯誤などもあったので、テストツールを作りながらこれは覚えておいた方が良いなと思ったところをいくつか挙げてみようと思います。&lt;/p>
&lt;h3 id="状態管理">状態管理&lt;/h3>
&lt;p>&lt;a class="link" href="../swift-ui-first-impression-2/" >SwiftUIのポスト&lt;/a>の時も触れた状態管理ですが、Composeでも同じくGUIを扱うことになるので、状態管理が大事となります。今回はアプリとしての画面がひとつしかないので、複数の画面にまたがって状態を管理する必要はないかなと思いましたが、それでもやはり処理を行うためにはアプリ全体で共有する状態として管理が必要なものがいくつかありました。&lt;/p>
&lt;p>ただ、上記ポストでも述べた通り、SwiftUIとComposeとは状態管理の方式が少し違います。SwiftUIでは状態がどこで使われるかによって明確に使われるアノテーションやクラスなどが変わっていたなら、Composeでは大体&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary?hl=ja#remember%28kotlin.Function0%29" target="_blank" rel="noopener"
>remember()&lt;/a>と&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState?hl=ja" target="_blank" rel="noopener"
>&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>&lt;/a>の組み合わせで事足りることになります。画面の構成要素の最小単位をComposeではWidgetでも使い方が同じだということは、SwiftUIと比べると定義するのは簡単ですが、使い方には少し注意が必要だなという感覚でした。&lt;/p>
&lt;p>まず、Composeでの状態は、以下のような三つの方法で定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Delegateで定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> isOn: Boolean &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#66d9ef">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 直接値を書き換えできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>isOn = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 分解宣言で定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>isOff: Boolean, setIsOff: (Boolean) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#66d9ef">true&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 参照と更新が分離される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (isOff) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setIsOff(&lt;span style="color:#f92672">!is&lt;/span>Off) &lt;span style="color:#75715e">// toggle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// MubtableState&amp;lt;T&amp;gt;として扱う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> isNotOff: MutableState&amp;lt;Boolean&amp;gt; = remember { mutableStateOf(&lt;span style="color:#66d9ef">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ラッパーになっているので、値を更新するためにはvalueにアクセスする必要がある
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>isNotOff.&lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#f92672">!is&lt;/span>&lt;span style="color:#a6e22e">NotOff&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでDelegateで&lt;code>var&lt;/code>として定義した場合は最も使いやすくなりますが、Intellij上ではコンパイルエラーになりがちです。なぜかというと、Delegateを使うためには&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#%28androidx.compose.runtime.MutableState%29.setValue%28kotlin.Any,kotlin.reflect.KProperty,kotlin.Any%29" target="_blank" rel="noopener"
>androidx.compose.runtime.setValue&lt;/a>と&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#%28androidx.compose.runtime.State%29.getValue%28kotlin.Any,kotlin.reflect.KProperty%29" target="_blank" rel="noopener"
>androidx.compose.runtime.getValue&lt;/a>をimportする必要がありますが、これが自動で行われないからです。最初このエラーの理由がわからなかったり、忙しい場合にいちいちimport文を書いていくが面倒だったりでかなり使わなくなるケースも多いかなという気がします。ただこれは、まだIntellijでのCompose対応が完璧ではないのが原因なので、これはいずれ解消されると期待できるでしょう。&lt;/p>
&lt;p>分解宣言で値の参照と更新を別々で使うのは、どこで使うか悩ましいケースもあるかなと思いますが、Composeの一部Widgetに状態を渡す場合に使われる場面があります。代表的なものが&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField%28kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors%29" target="_blank" rel="noopener"
>TextField&lt;/a>で、これはコードを見るとすぐにその目的がわかります。実際のコードで、以下のように使われます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>text: String, updateText: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TextField(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onValueChange = setValue, &lt;span style="color:#75715e">// TextFieldに文字を入力するとその値でtextを更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span> = text &lt;span style="color:#75715e">// textの値をTextFieldに表示する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後に&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>として定義するケースですが、直接的な値の更新ができないので最も使い方としては不便なのですが、実際は最も多く使われるのではないかと思います。なぜかというと、アプリ全体で状態を共有するなど複数のWidgetをまたがって使う場合は、以下のようにclassの中にフィールドとして&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>を定義することになるからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// アプリ全体で共有するためにクラスに状態を定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> isOn: MutableState&amp;lt;Boolean&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはもちろん別途&lt;a class="link" href="https://kotlinlang.org/docs/properties.html#getters-and-setters" target="_blank" rel="noopener"
>getter/setter&lt;/a>をclassに定義しておくと、中のvalueにアクセスしなくても直接プロパティにアクセスする感覚で使えます。イメージ的には以下のようなものですね。これだと状態として管理したい項目が増えれば増えるほどコードの量が増えてしまう面倒さがあるというのが短所かなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _isOn: MutableState&amp;lt;Boolean&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isOn: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = _isOn.&lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>) { _isOn.&lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、Composeでの状態には定義する方法が色々あり、それぞれの特徴があるわけなのでどの場面で使うかによって適切な定義の方法を考えるのが何よりも大事だという印象です。&lt;/p>
&lt;h3 id="swingawt">Swing/AWT&lt;/h3>
&lt;p>Compose for Desktopの特徴の一つは、Swingや&lt;a class="link" href="https://en.wikipedia.org/wiki/Abstract_Window_Toolkit" target="_blank" rel="noopener"
>AWT&lt;/a>に対する互換性があるという点です。最初は&lt;a class="link" href="https://github.com/JetBrains/compose-jb/blob/master/tutorials/Tray_Notifications_MenuBar_new/README.md" target="_blank" rel="noopener"
>Macのトレイ、メニューバー、通知&lt;/a>にも対応していたので基本的な機能は全て揃っているのではないかと思いましたが、実はそうでもなく、一部の機能はSwingやAWTの機能を借りて実装することになるケースもありました。実際、私の作ったテストツールでも一部SwingとAWTの機能を使っているところがあります。&lt;/p>
&lt;p>例えばファイル選択機能がそうです。CSVを読み込むためにファイル選択のダイアログを表示したかったのですが、ComposeのWigdetではまだ対応できてないので、やむを得なくAWTの&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/FileDialog.html" target="_blank" rel="noopener"
>FileDialog&lt;/a>を使う必要がありました。以下がその実装の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 選択したファイル名を状態として保持する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> fileName &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// AWTのファイル選択ダイアログを使う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>FileDialog(ComposeWindow()).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 選択できるのはCSVのみにしたい
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> setFilenameFilter { _, name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> name.endsWith(&lt;span style="color:#e6db74">&amp;#34;.csv&amp;#34;&lt;/span>, ignoreCase = &lt;span style="color:#66d9ef">true&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isVisible = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルが選択された場合は状態を更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (!&lt;span style="color:#66d9ef">file&lt;/span>.isNullOrBlank()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileName = &lt;span style="color:#66d9ef">file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これでも十分ではない場合もありました。フォルダのみを選択できるようにしたい場合に&lt;code>FileDialog&lt;/code>はあまり良い選択ではなかったのです。名前からそうですが、あくまでファイルの選択を想定したものであるため、フォルダのみを選択できるようにはできなかったのです。なので、フォルダのみを選択できるようにするためには、Swingの力も借りる必要があります。その場合は、以下のように実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 選択したフォルダのパスを状態として保持する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> selectedPath &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Swingのファイル選択ダイアログをディレクトリのみ選択できるように設定して定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> fileChooser = JFileChooser().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dialogTitle = &lt;span style="color:#e6db74">&amp;#34;Choose Directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileSelectionMode = &lt;span style="color:#a6e22e">JFileChooser&lt;/span>.DIRECTORIES_ONLY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ダイアログを表示する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (fileChooser.showOpenDialog(ComposeWindow()) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">JFileChooser&lt;/span>.APPROVE_OPTION) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ダイアログで選択したパスが状態として保持しているパスと違う場合、選択したディレクトリの絶対パスを状態として更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> path = fileChooser.selectedFile.absolutePath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (selectedPath &lt;span style="color:#f92672">!=&lt;/span> path) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectedPath = path
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回はこの二つユースケースのみSwingやAWTが登場していませんでしたが、どんなアプリを実装するかによって他のAPIも色々と使う必要性が出てくるかも知れないという良い一例になっている気がします。まだComposeはリリースされて1年ほどしか経っていないので、今後のバージョンアップでより多彩なWidgetが追加されることに期待ですね。&lt;/p>
&lt;h3 id="ビルド">ビルド&lt;/h3>
&lt;p>Composeを選んだ理由の一つのバイナリのビルドができるという点ですが、これはかなり満足度が高かったです。&lt;code>gradle&lt;/code>を使って、コマンドひとつで実行可能なバイナリが生成されます。Macでビルドして見ると、他のアプリと同じくパッケージが生成されます。中を見ると、実行に必要なJREと依存関係のJarが含まれていて、ネイティブではなくJVM上で起動される構造になっていました。&lt;/p>
&lt;p>バイナリをビルドするときのオプションには色々なものがあり、OSの種類(Windows, Mac, Linux)によって違うアイコンを使ったり、基本的には含まれないモジュールを含むように指定したりすることができました。以下が実際のビルド時のオプションのサンプルです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>compose.desktop {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> application {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mainClass = &lt;span style="color:#e6db74">&amp;#34;com.testtool.MainKt&amp;#34;&lt;/span> &lt;span style="color:#75715e">// 実行時のメインクラスを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> nativeDistributions {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> packageName = &lt;span style="color:#e6db74">&amp;#34;Test Tool&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> packageVersion = &lt;span style="color:#e6db74">&amp;#34;1.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modules(&lt;span style="color:#e6db74">&amp;#34;java.sql&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;java.naming&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// デフォルトでは含まれないパッケージを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> macOS {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iconFile.&lt;span style="color:#66d9ef">set&lt;/span>(project.&lt;span style="color:#66d9ef">file&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;misc/appicon/icon-mac.icns&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> windows {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iconFile.&lt;span style="color:#66d9ef">set&lt;/span>(project.&lt;span style="color:#66d9ef">file&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;misc/appicon/icon-win.ico&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ビルド時は注意が必要です。ビルドするとき、Composeでは内部的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/14/docs/specs/man/jpackage.html" target="_blank" rel="noopener"
>jpackage&lt;/a>を使うので、まずJava 15以上が必要となります。また、CPUのアーキテクチャによって違うJDKをインストールするようになっているため、ビルドするマシンと違うのアーキテクチャのCPUを使っているマシンをターゲットにすることはできません。&lt;/p>
&lt;p>つまり、自分の使用のMacだとApple Silicon用のバイナリが生成され、IntelチップのMacだとx64用のバイナリが生成されるということです。実際ComposeでApp Storeにアプリを提出した人もいるらしいのですが、Rosettaで起動できるということでIntelチップのMacを使ってビルドしているとのことでした。Universal Binaryを作りたい場合は、JDKそのものがまずUniversal Binaryとして提供されることを待つしかなさそうです。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回はデスクトップアプリの中でもかなり制限された機能と単純なロジックしかないシンプルなものを作ったので、もしこれからまたComposeを使ってさまざまな機能を持つように実装するとしたら(マルチウィンドウやダークモード対応、ナビゲーションなど)また色々と発見があるかも知れない気がしています。個人的にはかなりためになる経験で、思ったより実装もそこまで難しくなかったので、ツールの機能を拡張するか新しいツールを作ってみるチャンスがあるとしたら再度Composeを使ってみたいなと思いました。&lt;/p>
&lt;p>まだリリースされてからそう長くもなく、足りない機能や情報も多かったり競合のフレームワークが色々とあるので未来はどうなるかわからないものですが、自分のようにKotlinをメインとしているエンジニアで、GUIに興味がある方なら一度はComposeを使って見ることをお勧めしたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>SwiftUIを触ってみた〜その2〜</title><link>https://retheviper.github.io/posts/swift-ui-first-impression-2/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/swift-ui-first-impression-2/</guid><description>&lt;img src="https://retheviper.github.io/images/swift.jpg" alt="Featured image of post SwiftUIを触ってみた〜その2〜" />&lt;p>前回に続いて、今回はSwiftUIを触りながら感じたことについて述べたいと思います。自分のように、今までバックエンドの実績しかないエンジニアがGUIを作るとしたら、画面のレイアウトや色合い、画面間の繊維など「今までなかった概念」で混乱することも多いかなと思います。そしてその中でも特に難しい、うまく扱えない機能などもあるかなと思います。&lt;/p>
&lt;p>自分の場合、プロダクションレベルのコードを書いたことはないものの、以前から&lt;a class="link" href="https://reactnative.dev/" target="_blank" rel="noopener"
>React Native&lt;/a>, &lt;a class="link" href="https://flutter.dev/" target="_blank" rel="noopener"
>Flutter&lt;/a>, &lt;a class="link" href="https://developer.android.com/jetpack/compose" target="_blank" rel="noopener"
>Jetpack Compose&lt;/a>には少し触れたことがあったためSwiftUIで「画面を構成する方式」については少し理解しているつもりでした。しかし、やはりバックエンドでは存在しない機能がありました。&lt;/p>
&lt;p>今回はそのSwiftUIの話となりますが、中でも私が注目した機能もしくは概念について述べたいと思います。&lt;/p>
&lt;h2 id="swiftui">SwiftUI&lt;/h2>
&lt;p>まずは、SwiftUIそのものに対して簡単に紹介しましょう。SwiftUIはいわゆる宣言型(Declarative)UIのフレームワークで、&lt;a class="link" href="https://ja.reactjs.org/" target="_blank" rel="noopener"
>React&lt;/a>や&lt;a class="link" href="https://vuejs.org/" target="_blank" rel="noopener"
>Vue&lt;/a>などのフロントエンドからの影響が見えます。要するに、画面を構成する要素(Widget, Component, Materialなどフレームワークやライブラリによって呼び方は様々ですが)を一つのオブジェクトとして「宣言」し、それらの要素の組み合わせによって一つの画面を完成するという形になっているということです。このような宣言型UIはSwiftUIだけでなく、モバイルに限定してもReact NativeやFlutter、Jetpack Composeなど様々なフレームワークやライブラリで採択しているものでもあります。&lt;/p>
&lt;p>そして、要素の実装についてもフレームワークやライブラリによって色々と方法が分かれますが、SwiftUIでは、個別の要素はViewといい、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"
>View&lt;/a>というprotocolをstructとして実装していきます。なので、一覧を表示する画面であれば、一つの行としてデータを表示するView、その行をリストとして表示するためのView、さらに一覧の上や下にメニューを表示するViewなどが一つ一つのstructとして定義されていく形ということです。&lt;/p>
&lt;p>このような画面の作り方は、フレームワークのパラダイム・コンセプトとして決まってあるものなので、それに従って実装を進めることには私のようにバックグラウンドが全く違うエンジニアでも特に問題はないかなと思います。&lt;/p>
&lt;p>ただ、実際のアプリを作るとしましょう。画面に対してはフレームワークで提示する通り要素を実装して作ったとしたら、アプリを実行してなんらかの処理を行うためにはバックエンドを繋げるか、アプリ内でなんらかの処理を行うかなど「ロジック」とつなげる必要があるはずです。ここで常にとは言い難いのですが、バックエンドでは見慣れない概念が出てくる場合があります。「状態」というものです。&lt;/p>
&lt;h2 id="状態">状態&lt;/h2>
&lt;p>バックエンドのアプリを実装している場合は、リクエストがあり、それに対してのレスポンス（HTTPステータスのみだとしても）がある、という明確なプロセスがありますね。この一連の処理には、「途中で変化する」という概念はありません。この場合のデータは永続化されるか、処理が終了するまでの一時的な物が多いです。&lt;/p>
&lt;p>しかし、画面の世界だと話は変わってきます。多くのモバイルアプリではスライダ、ボタン、テキストボックスなどいろいろな要素で構成されてあり、それらの要素に関する状態が常に変わってくるケースもあるのです。ファイルをダウンロードしている状態を表示するためのプログレスバーがあるとしたら、単純に進行状況を見せるとしたら一つのスレッドを割り当てて処理するだけで良いでしょう。&lt;/p>
&lt;p>ここで一つ、もしダウンロードに「一時停止」のような機能があったらどうでしょうか。プロセスが進行中にボタンを押下したら止まり、再度押下したら再開されるような機能です。他にも色々と考慮すべきものはあるかと思いますが、この「停止している」「再開した」という概念をどこかに記憶しておく必要はあるでしょう。つまり、画面においてのユーザの入力に対して、なんらかの処理を実際に行うまで記憶しておくための機構が必要ということですね。&lt;/p>
&lt;p>SwiftUIでももちろん、状態を管理するためのものがあります。ただ、ユースケースで考えると画面の要素(View)一つに限って必要なものか、それとも複数の要素において必要なものか、複数の画面（アプリ全体）にかけて必要なものかという、スコープによって必要な状態は違うものになります。View一つで必要なものをアプリ全体で管理する必要もなければ、複雑になりがちだからですね。なので、ここではそのスコープ別に状態を管理するためにどんなものがあるのかについて述べていきたいと思います。&lt;/p>
&lt;h3 id="個別viewの状態">個別Viewの状態&lt;/h3>
&lt;p>まずは最も小さい単位、Viewの場合です。先に述べた、一覧の画面が良い例になりそうですね。Appleのチュートリアルでは、以下のような一覧の画面を作ることになります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list.webp"
width="860"
height="1756"
srcset="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list_hu8af76eed233006b3914ba9d5bc28f3ef_48790_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list_hu8af76eed233006b3914ba9d5bc28f3ef_48790_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="List View"
class="gallery-image"
data-flex-grow="48"
data-flex-basis="117px"
>&lt;/p>
&lt;p>この画面では右上のボタンを押すことで、一覧に表示するアイテムをフィルタリングできる機能があります。たとえば一部の行にハートマークがついてありますが、これは「お気に入り」を意味していて、そのお気に入りとして登録したものだけをフィルタするか、アイテムのカテゴリでフィルタするかなどの機能が入っています。&lt;/p>
&lt;p>そしてこの画面では、「フィルタするカテゴリ」や「お気に入りだけを表示する」を状態として扱っていますが、この状態は他の画面では知る必要がないデータとなっています。この場合に使えるのが、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/state" target="_blank" rel="noopener"
>@State&lt;/a>です。コードとしては、以下のようになっています。(一部省略)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 一覧画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// お気に入りだけを表示するかどうか&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> showFavoritesOnly = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィルタするカテゴリ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> filter = FilterCategory.all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// カテゴリの種類&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">FilterCategory&lt;/span>: String, CaseIterable, Identifiable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> all = &lt;span style="color:#e6db74">&amp;#34;ALL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> lakes = &lt;span style="color:#e6db74">&amp;#34;Lakes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> rivers = &lt;span style="color:#e6db74">&amp;#34;Rivers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> mountains = &lt;span style="color:#e6db74">&amp;#34;Mountains&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> id: FilterCategory { &lt;span style="color:#66d9ef">self&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// アイテムにフィルタを適用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> filteredLandmarks: [Landmark] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modelData.landmarks.filter { landmark &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">!&lt;/span>showFavoritesOnly &lt;span style="color:#f92672">||&lt;/span> landmark.isFavorite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (filter == .all &lt;span style="color:#f92672">||&lt;/span> filter.rawValue == landmark.category.rawValue )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NavigationView {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// アイテムの表示部&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(selection: &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>selectedLandmark) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(filteredLandmarks) { landmark &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NavigationLink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkDetail(landmark: landmark)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkRow(landmark: landmark)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toolbar {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ToolbarItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ツールバーにフィルタを適用するためのボタンを追加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Menu {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 選択できるカテゴリ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Picker(&lt;span style="color:#e6db74">&amp;#34;Category&amp;#34;&lt;/span>, selection: &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>filter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(FilterCategory.allCases) { category &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(category.rawValue).tag(category)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .pickerStyle(.inline)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// お気に入りだけを表示するかどうかのトグル&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Toggle(isOn: &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>showFavoritesOnly) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#e6db74">&amp;#34;Favorites only&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#e6db74">&amp;#34;heart.fill&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#e6db74">&amp;#34;Filter&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#e6db74">&amp;#34;slider.horizontal.3&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、一つのViewにおいて状態を管理するためには、&lt;code>@State&lt;/code>を使うことになります。&lt;/p>
&lt;h3 id="親子関係のviewが共有する状態">親子関係のViewが共有する状態&lt;/h3>
&lt;p>さて、一つのViewでの状態を管理することはできましたが、次に気になるのは複数のView、特に親子関係になるView間でどうやって状態を共有できるかです。たとえば先ほどの一覧画面だと、一つ一つの行がViewになっているものなのですが、&lt;/p>
&lt;p>実は、親のViewから子Viewに状態を渡すというのは、すでに先ほどのコードに表れています。「お気に入りだけを表示するかどうか」のトグルがあるのですが、ここで&lt;code>isOn&lt;/code>に親の状態を渡していますね。ただ、トグル時の挙動を&lt;code>@State&lt;/code>で定義したBooleanと結びつけるために&lt;code>isOn&lt;/code>として渡す際、&lt;code>$&lt;/code>をつけることに注目する必要があります。&lt;code>$&lt;/code>をつけることで、Booleanではなく、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/binding" target="_blank" rel="noopener"
>&lt;code>Binding&amp;lt;Boolean&amp;gt;&lt;/code>&lt;/a>という形でプロパティを渡すことになります。こうしてラッパーを渡すことで、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/toggle/" target="_blank" rel="noopener"
>Toggle&lt;/a>の中でも親の状態を変更できるようになります。&lt;code>Toggle&lt;/code>は確かに一覧の画面とは別のViewになりますが、押下するたびに親の状態である&lt;code>showFavoritesOnly&lt;/code>の値が変わるということです。&lt;/p>
&lt;p>後でまた関連したポストを書きたいと思いますが、Jetpack Composeでも何となく似たような形で状態の管理ができる方法があります。例えば、&lt;code>@State&lt;/code>のように簡単な状態を管理するためには以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// true/falseの状態
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> toggle: Boolean &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#66d9ef">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> toggle {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;On!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toggle = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Off!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toggle = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のような書き方はいわゆる&lt;a class="link" href="https://kotlinlang.org/docs/delegation.html" target="_blank" rel="noopener"
>Delegation&lt;/a>によるもので、&lt;code>mutableStateOf&amp;lt;T&amp;gt;&lt;/code>が返すのは&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState" target="_blank" rel="noopener"
>&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>&lt;/a>ですが、&lt;code>by&lt;/code>を使うことで実際は&lt;code>Boolean&lt;/code>そのものを扱うようになります。&lt;/p>
&lt;p>そして&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>を分解し、以下のように状態と、状態を変化させる処理の処理を指定することもできます。これもまた、先ほどの&lt;code>Binding&lt;/code>のような役割をするようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// テキストの状態と値の変更
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>content: String, onValueChange: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// テキストフィールドに状態を表示し、変化があった場合は状態を変更させる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>TextField(&lt;span style="color:#66d9ef">value&lt;/span> = content, onValueChange = onValueChange)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやって他の要素に状態の変更を可能にするためには、基本的にその状態をラップしているオブジェクトを利用するという考えは、SwiftUIでもJetpack Composeでも一緒のようです。ただ、&lt;code>$&lt;/code>というキーワードを使ってラッパーにアクセスできるSwiftと、状態のオブジェクトをどうやって宣言するかを考える必要のあるKotlinの違いがまた面白いポイントです。&lt;/p>
&lt;h3 id="アプリ全体で共有する状態">アプリ全体で共有する状態&lt;/h3>
&lt;p>さて、次はもっと大きい単位としての状態について述べたいと思います。アプリの画面は色々とあり、仲には親子の関係ではない場合もあります。Appleのチュートリアルのアプリをまたの例としてあげますと、以下のように、タブが分かれている場合が代表的なものと言えるかもしれません。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu.webp"
width="732"
height="1466"
srcset="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu_hu93303c8a7cdcd61ea94dce76260b9f35_74024_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu_hu93303c8a7cdcd61ea94dce76260b9f35_74024_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Menu View"
class="gallery-image"
data-flex-grow="49"
data-flex-basis="119px"
>&lt;/p>
&lt;p>ここで、下にある「Featured」や「List」をタッチすることにより表示される画面が変わるわけですが、この二つの画面は親子といえる関係ではありません。以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> selection: Tab = .featured
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Tab&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> featured
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// タブメニュー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TabView(selection: &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>selection) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Featured画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CategoryHome()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tabItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#e6db74">&amp;#34;Featured&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#e6db74">&amp;#34;star&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tag(Tab.featured)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// LandmarkList画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tabItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#e6db74">&amp;#34;List&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#e6db74">&amp;#34;list.bullet&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tag(Tab.list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要件によっては、この対等な関係にある画面間でも状態を共有する必要はあります。たとえば、ショッピングのアプリを作るとしたら、自分のアカウントの画面を開いている場合でもカートに入れている商品の情報は維持される必要がありますね。このように、現在表示している画面とは関係なく、アプリ全体で共有する状態が必要な場面があります。&lt;/p>
&lt;p>この場合は、どうしたらいいでしょうか？もちろん、起点となるViewがあるので、そこに&lt;code>@State&lt;/code>を定義しておくというのも一つの方法かもしれません。ただ、状態として管理したい項目が増えれば増えるほど複雑になりがちですね。起点のViewには複数の&lt;code>@State&lt;/code>が必要となり、画面ごとにそれらを渡す必要があります。だとすると、やはり一つのオブジェクトに状態をまとめて置いて使いまわしたいものです。&lt;/p>
&lt;p>Appleのチュートリアルでもそれを提示していて、画面間で共有するデータとしてLandmarkのデータと、ユーザのプロフィールをまとめて共有できるオブジェクトとして提供する方法があります。まずは、以下がその状態のオブジェクトのコードとなります。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ModelData&lt;/span>: ObservableObject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> landmarks: [Landmark] = load(&lt;span style="color:#e6db74">&amp;#34;landmarkData.json&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> profile = Profile.&lt;span style="color:#66d9ef">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでアプリ内でLandmarkの情報はjsonから読み取ったものとなっていて、プロフィールはEnumとなっています。そして&lt;a class="link" href="https://developer.apple.com/documentation/combine/observableobject" target="_blank" rel="noopener"
>ObservableObject&lt;/a>というプロトコールが使われているのが見えますね。&lt;code>ObservableObject&lt;/code>を使うことで、このModelDataというクラスは変更される状態を保持し、値の変更があった場合はそれを参照する画面に通知する&lt;code>Publisher&lt;/code>として機能することになります。そしてそれぞれの状態となるプロパティについては、&lt;a class="link" href="https://developer.apple.com/documentation/combine/published" target="_blank" rel="noopener"
>@Published&lt;/a>をつけることで状態として指定することになります。&lt;/p>
&lt;p>こうして状態を保持するためのオブジェクトを定義したら、次はアプリ内でどうやって使用するかですね。チュートリアルでは、以下のようにアプリのメインとなるstructに以下のように定義しています。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>@main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarksApp&lt;/span>: App {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ModelDataを状態のオブジェクトとして宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @StateObject &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> modelData = ModelData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some Scene {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WindowGroup {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ContentView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .environmentObject(modelData) &lt;span style="color:#75715e">// メイン画面に状態オブジェクトを渡す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードでわかるように、アプリでは定義しておいた状態オブジェクトを&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/stateobject" target="_blank" rel="noopener"
>@StateObject&lt;/a>をつけて、メイン画面に渡すことで使うようになります。ちなみにこうやって&lt;code>View&lt;/code>として定義された画面にならどんなものでも&lt;code>environmentObject()&lt;/code>に状態オブジェクトを渡すことができるので、画面の一部だけをプレビューとして表示する場合でも、プレビューに表示する画面に状態オブジェクトを渡すことで動作を試すこともできます。例えば、先ほどのLandmarkの一覧画面のプレビューだと、以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarkList_Previews&lt;/span>: PreviewProvider {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> previews: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .environmentObject(ModelData()) &lt;span style="color:#75715e">// 状態オブジェクトを渡す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうして状態オブジェクトを画面に渡したら、中では使うだけです。&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/environmentobject" target="_blank" rel="noopener"
>@EnvironmentObject&lt;/a>というアノテーションを使って、状態を持つオブジェクトを宣言するだけで自動的にオブジェクトはDIされ、その画面で使えるようになります。また一覧の画面の話となりますが、以下のコードを見てください。&lt;code>landmarks&lt;/code>のデータを使って一覧を表示しているのがわかります。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 状態オブジェクト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @EnvironmentObject &lt;span style="color:#66d9ef">var&lt;/span> modelData: ModelData
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 状態オブジェクトからデータを取り出しフィルタを適用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> filteredLandmarks: [Landmark] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modelData.landmarks.filter { landmark &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">!&lt;/span>showFavoritesOnly &lt;span style="color:#f92672">||&lt;/span> landmark.isFavorite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (filter == .all &lt;span style="color:#f92672">||&lt;/span> filter.rawValue == landmark.category.rawValue )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、Jetpack Composeの場合はこのような方法ではなく、オブジェクトそのものを&lt;code>remember&lt;/code>するように使うようです。例えば以下のような形になります。そもそも要素を作成するアプローチが違うのが理由の一つなのかもしれませんね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// アプリ全体で共有する状態
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ApplicationState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> environment: MutableState&amp;lt;Environment&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> hash: MutableState&amp;lt;String&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 状態の初期化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@Composable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">rememberApplicationState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment: MutableState&amp;lt;Environment&amp;gt; = mutableStateOf(&lt;span style="color:#a6e22e">Environment&lt;/span>.PRODUCTION),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hash: MutableState&amp;lt;String&amp;gt; = mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): ApplicationState {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> remember(environment, hash) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationState(environment, hash)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 状態の定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> appState = rememberApplicationState()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="永続化できる状態">永続化できる状態&lt;/h3>
&lt;p>今までの状態は、アプリが実行中のみ有効なものでした。それだけでも十分な場合もありますが、場合によっては状態を永続化したい場合もあるでしょう。例えば、学習用のアプリだとしたらどこまで進行したかなどを保存しておきたいかなと思います。このような種のデータは、アプリを再起動しても変わらないことを期待しますね。&lt;/p>
&lt;p>もちろん、この場合のためにDBがあり、ネットワーク機能のあるアプリならサーバ側にデータを保存したりするでしょう。ただ、この場合は「状態」とは言えないものですね。なぜなら、状態は画面の更新を伴うものだからです。画面をタッチした回数を、画面に表示しながら同時に保存しておきたい場合は毎回DBの更新と参照で実装したくない場合もあるかなと思います。そこで使えるのが、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/appstorage" target="_blank" rel="noopener"
>@AppStorage&lt;/a>です。これを使うことで、画面の更新と永続化を同時に行うことができます。&lt;/p>
&lt;p>また、チュートリアルによると、いくつかデフォルトとして保存されているデータに関してもこのアノテーションでアクセスできるようにになっています。一覧画面に表示される「お気に入り」ボタンの例ですが、ボタンのアイコンを&lt;code>@AppStorage&lt;/code>から参照するようになっています。コードは以下です。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">FavoriteButton&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ボタンはハートのアイコンとして表示する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @AppStorage(&lt;span style="color:#e6db74">&amp;#34;Favorite.iconType&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> iconType: IconType = .heart
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。自分の感想としては、やはり今まで自分が触れてきた分野とは全く違う概念やアプローチが多かったので、大変興味深いと思いつつ、「これであっているのか」という疑問もかなり湧いてくるような経験となっています。全く経験のない分野に足を踏み入れるのは常にそういうものなのかもしれませんが。&lt;/p>
&lt;p>ただこれで、ある程度アプリを作る場合にどうやって処理を行うべきかについての疑問の一つは解けたような気がします。本当は画面を作る分、他にも色々と新しい概念が出てきたり、画面のレイアウトやUXの観点で色々と難しいものが出てくるかもしれませんが、とにかく「動く」ものを作れそうな気はしますね。何卒自分のようにバックエンドのみを経験してきた形にとって参考できるような記事となっていればと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>SwiftUIを触ってみた〜その1〜</title><link>https://retheviper.github.io/posts/swift-ui-first-impression-1/</link><pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/swift-ui-first-impression-1/</guid><description>&lt;img src="https://retheviper.github.io/images/swift.jpg" alt="Featured image of post SwiftUIを触ってみた〜その1〜" />&lt;p>今までの自分のキャリアを振り返ってみると、仕事としての経験はバックエンドばかりで、画面側の実装にはあまり関わったことがありません。しかし、スタンドアロンのアプリを作るためには、ウェブ・モバイル・デスクトップを問わず画面が必要となるので、いつかは画面側の実装もできるようになる必要があるかなと常に思っているところです。&lt;/p>
&lt;p>画面を作るといっても、どんな分野のエンジニアとしてキャリアパスを考えているか、どのような企業で働きたいか、慣れている言語は何であるかなど色々と考慮すべき要素は多いのですが、自分の場合はKotlinに慣れているのもあり、ウェブ・モバイル・デスクトップアプリに全部対応できるという点から&lt;a class="link" href="https://www.jetbrains.com/lp/compose-mpp" target="_blank" rel="noopener"
>Jectpack Compose&lt;/a>を、また普段からMacとiPhone、iPadといったApple社の製品をよく使っている上、KotlinからのSwift入門が比較的簡単ということで&lt;a class="link" href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener"
>SwiftUI&lt;/a>を勉強したいと思っています。&lt;/p>
&lt;p>さて、言語とフレームワークを決めてからは実践ですね。&lt;a class="link" href="https://developer.apple.com/tutorials/swiftui" target="_blank" rel="noopener"
>公式のチュートリアル&lt;/a>が充実していたので、まずはこちらの方をすすめながら感じたSwiftやSwiftUIで印象的だった部分についてまとめてみたいと思います。もちろん、自分は仕事としてモバイルアプリの実装に関わったことがないのでコンテンツとしては粗末なものとなるかなと思いますが、もし自分のようにKotlinのバックグラウンドからSwiftに触れてみようと思っている方や、バックエンドのみのキャリアからGUIに初めて触れる方、もしくはKotlinとSwiftのどちらかに興味を持っている方には参考になる内容となればと思います。&lt;/p>
&lt;h2 id="swift">Swift&lt;/h2>
&lt;p>まずは言語そのものから。KotlinとSwiftはよく似ているという話を聞くことがありますが、正確に「どこが」というのはやはり触れてみる前はわからないものです。似ているという表現は共通点があるという意味なので、何に基準を置くかによって挙げられる共通点は色々と変わってくるものだからです。&lt;/p>
&lt;p>例えば、言語デザインの観点でOOP志向的で、関数型的な要素があり、GCが存在する、ということでも共通点は発見できます。もしくは、言語の使用としてキーワードや書き方の印象が似ているという意味にもなれますね。細かくは、セミコロンを使わなくて良いという点も挙げられますね。&lt;/p>
&lt;p>なので、まずは上記のチュートリアルを進行しながら、肌で感じた感覚から、Kotlinに比べたSwiftはどのようなものだったかを述べていきたいと思います。&lt;/p>
&lt;h3 id="kotlinに似ているもの">Kotlinに似ているもの&lt;/h3>
&lt;p>では、まずKotlinに似ているなと感じたところから述べていきます。似ているとしても、あくまで「肌の感触」なものなので、厳密には違う仕様になっているものも多いのですが、ここでの基準は「Kotlinでできたことをどれほど近い感覚で再現できるか」となっていますので（といっても個人的な感想ですが）、参考までに。&lt;/p>
&lt;h4 id="computed-properties">Computed properties&lt;/h4>
&lt;p>まず、プロパティの話からです。Kotlinではdata classを定義するとき、プロパティを以下のような二つの方法で定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> age: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> isAdult: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = age &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>age&lt;/code>はインスタンスを作成するときに固定される単純な値となりますが、&lt;code>isAdult&lt;/code>はgetterとして定義した処理(&lt;code>age&lt;/code>が18以上かどうかという)の結果を返すように定義する形ですね。このような処理を伴うプロパティは、Swiftでも同じく&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID259" target="_blank" rel="noopener"
>Computed Properties&lt;/a>を通じて定義することができました。同じような処理を行う場合、以下のように定義できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> age: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isAdult: Bool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> age &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだ一つしたあげてないのですが、これだけでもなんとなく「KotlinとSwiftが似ている」の意味が少しは見えてきた気がしますね。処理を伴うプロパティを扱える、という仕様がそうですが、型の定義もそうで、キーワードは少し違うけど大体似たような感覚でコードが読めるというところがそうです。&lt;/p>
&lt;p>ただ、やはり違う部分もありますね。data classに対して、SwiftはGoやRustのようにstructを使えるというところがそうかなと思います。もちろんSwiftにもClassはあるので、目的によってどれかを選ぶようになるらしいです。という面では、またなんとなくKotlinでdata classとclassを分けて使うという点と似ているような気もしますね。&lt;/p>
&lt;h4 id="extension">Extension&lt;/h4>
&lt;p>次は、拡張です。Kotlinではオブジェクトについて、そのオブジェクトの外にメソッドやプロパティを定義することができますね。これらを拡張関数や拡張プロパティと呼び、以下のように定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> Student.isUnderAge: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = age &amp;lt; &lt;span style="color:#ae81ff">18&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前このブログでも述べたことのある&lt;a class="link" href="https://www.amazon.co.jp/dp/B08WXCRVD2/ref=dp-kindle-redirect?_encoding=UTF8&amp;amp;btkr=1" target="_blank" rel="noopener"
>Effective Kotlin&lt;/a>で提示されている活用方法ですが、ユースケースやドメインによって違う処理が必要となった場合は、class内に全てのメソッドやプロパティをを定義するよりはこのような拡張を使って、パッケージごとに定義することでアクセス制限を設ける方法があります。&lt;/p>
&lt;p>同じようなことがSwiftでもできますが、書き方はやはり少し違いました。上記のようなプロパティをSwiftで同じ方法で実装する場合、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isUnderAge: Bool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> age &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにSwiftには&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html" target="_blank" rel="noopener"
>Extension&lt;/a>が別途キーワードとして存在していて、新しくclassやstructを定義するかのような感覚で関数やプロパティを付け加えることができます。個人的な感想としてはRustの&lt;a class="link" href="https://doc.rust-jp.rs/book-ja/ch05-03-method-syntax.html" target="_blank" rel="noopener"
>メソッド&lt;/a>と似ている形で、一つの&lt;code>extension&lt;/code>の中にまとめられるところがむしろKotlinより整頓された感覚なので良さげですね。Kotlinの場合、一つのオブジェクトに対しての拡張が複数あると少し汚くも見えるので…&lt;/p>
&lt;h4 id="string-interpolation">String Interpolation&lt;/h4>
&lt;p>Javaの場合でもそうで、多くの言語では文字列と、違う変数として格納してある値を一つの文字列にまとめる場合は&lt;code>format()&lt;/code>を使うか、文字列に変換して結合するケースが多いかなと思います。Kotlinでもそのような使い方はもちろんできますが、&lt;a class="link" href="https://kotlinlang.org/docs/basic-types.html#string-templates" target="_blank" rel="noopener"
>String template&lt;/a>があるので、簡単に文字列の中で違う値を埋め込むことができます。例えば以下のようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> world = &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(&lt;span style="color:#e6db74">&amp;#34;Hello, &lt;/span>&lt;span style="color:#e6db74">$world&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Swiftでも&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID292" target="_blank" rel="noopener"
>String Interpolation&lt;/a>があるので、同じことができます。少し書き方が変わっているのですが、機能的にはほぼ一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> world = &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#34;Hello, &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>world&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="arguments">Arguments&lt;/h4>
&lt;p>Kotlinでは、関数のパラメータにデフォルト値を設定することで、簡単にオーバーロードを実現でき、そのパラメータが渡されてない場合の処理にも対応できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// timesに指定した数値分、stringを標準出力する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>(string: String, times: Int = &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(times) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello, &lt;/span>&lt;span style="color:#e6db74">$string&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// timesに値を指定しなくても関数を呼び出せる
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、どのパラメータに値を指定したいかを明確にするときや、関数に定義されたパラメータの順番に関係なく値を指定したい場合など色々な場面で&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>Named Arguments&lt;/a>を使うことができますね。例えば&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html" target="_blank" rel="noopener"
>joinToString()&lt;/a>には&lt;code>separator&lt;/code>、&lt;code>limit&lt;/code>、&lt;code>truncated&lt;/code>など6つのパラメータがあるのですが、デフォルト値が指定されていて、Named Argumentsにより以下のような使い方が可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;D&amp;#34;&lt;/span>).joinToString(prefix = &lt;span style="color:#e6db74">&amp;#34;[&amp;#34;&lt;/span>, postfix = &lt;span style="color:#e6db74">&amp;#34;]&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Named ArgumentはKotlinにおいてはオプションで、基本的にはJava同様、関数に定義されてあるパラメータの順番に合わせて値を渡すだけでも問題ありません。しかし、Swiftではこれが逆になっていて、sturctのインスタンスを作る場合や関数を呼び出す場合は基本的にパラメータは基本的にNamed Argumentsのような形で渡す必要があります。これを&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID166" target="_blank" rel="noopener"
>Argument Label&lt;/a>と読んでいるそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>(string: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>string&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(string: &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// Function Argument Labelでstringを指定&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、これもKotlinと同様、デフォルト値を指定することができ、その場合はパラメータを省略することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>(string: String, times: Int = &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> count = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">repeat&lt;/span> { &lt;span style="color:#75715e">// Kotlinのdo-whileループ的なもの&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>string&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (count &lt;span style="color:#f92672">&amp;lt;=&lt;/span> times)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(string: &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// timesを省略している&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、アンダースコアを使うことでArgument Labelを省略できるようにもなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>(&lt;span style="color:#66d9ef">_&lt;/span> string: String, times: Int = &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> count = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">repeat&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>string&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (count &lt;span style="color:#f92672">&amp;lt;=&lt;/span> times)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// stringを省略&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>関数を定義する側からしたらあまり似ていないような気もするのですが、呼び出す側としてはかなり似たような形でコードが書けるのが特徴的かなと思います。&lt;/p>
&lt;h4 id="range">Range&lt;/h4>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html#:~:text=values%20using%20the-,rangeTo%28%29,-function%20from%20the" target="_blank" rel="noopener"
>rangeTo()&lt;/a>を使って、簡単に数値の範囲を定義することができます。この関数は&lt;a class="link" href="https://kotlinlang.org/docs/keyword-reference.html#operators-and-special-symbols" target="_blank" rel="noopener"
>operator&lt;/a>として定義されているので、&lt;code>..&lt;/code>で簡単に使えます。こうやって定義したRangeでは、最小値と最大値の取得や、Listに変換するなど色々なことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Rangeの定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> min = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> max = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> range = min&lt;span style="color:#f92672">..&lt;/span>max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 最小値と最大値の取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(range.start) &lt;span style="color:#75715e">// 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(range.endInclusive) &lt;span style="color:#75715e">// 20
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RangeをListにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> intList = range.toList() &lt;span style="color:#75715e">// [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Swiftでも&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID73" target="_blank" rel="noopener"
>Range Operator&lt;/a>を使って範囲を定義することができます。こちらも形は似ていて、&lt;code>...&lt;/code>となります。ドットの数がKotlinより一つ多いという点を除くと全く同じ感覚で、最小値と最大値もまた名前が違うだけでプロパティとして取得できるという点もまた一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Rangeの定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> min = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> max = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> range = min...max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 最小値と最大値の取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(range.lowerBound) &lt;span style="color:#75715e">// 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(range.upperBound) &lt;span style="color:#75715e">// 20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RangeをArrayにする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> array = Array(range) &lt;span style="color:#75715e">// [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記のコードを見ると気付きにくいところですが、Range実装については両言語での扱いが少し違うところがあります。Kotlinでは&lt;code>rangeTo()&lt;/code>の戻り値が、元の値の型に合わせて&lt;code>InteRange&lt;/code>や&lt;code>LongRange&lt;/code>のようなものとなっていて、最小値と最大値をプロパティで取得する場合も&lt;code>rangeTo&lt;/code>に渡された二つの値の型と一緒です。&lt;/p>
&lt;p>しかし、Swiftの&lt;a class="link" href="https://developer.apple.com/documentation/swift/range" target="_blank" rel="noopener"
>Range&lt;/a>は&lt;code>Range&amp;lt;Bound&amp;gt;&lt;/code>という型で、当然Rangeから取得できる最小値や最大値も&lt;a class="link" href="https://developer.apple.com/documentation/swift/rangeexpression/bound/" target="_blank" rel="noopener"
>Bound&lt;/a>の型となっています。IntやLongとはまた別の型になるので、場合によっては注意して使う必要があるかもしれません。&lt;/p>
&lt;h3 id="swiftだけのもの">Swiftだけのもの&lt;/h3>
&lt;p>今まではKotlinユーザの観点から、Kotlinとどれだけ同じ感覚でコードを書けるか、ということを述べていましたが、ここからは少し間隔が違うなと思ったところを少しまとめてみようと思います。&lt;/p>
&lt;h4 id="メソッドプロパティコールでの省略">メソッド・プロパティコールでの省略&lt;/h4>
&lt;p>Kotlinでは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply()&lt;/a>のように自分自身を指しているのが明確な場合、&lt;code>this&lt;/code>を省略することができます。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> age: Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> studentA = Student(name = &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>).apply { age = &lt;span style="color:#ae81ff">18&lt;/span> } &lt;span style="color:#75715e">// Student(name=A, age=18)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、&lt;code>this&lt;/code>を使う場合か、明確に対象importしているなど特定のケースを除くとKotlinでは基本的に&lt;code>Class.method()&lt;/code>のような形でどのクラスのメンバを呼び出しているかを表記するのが原則ですね。&lt;/p>
&lt;p>しかし、Swiftの場合は少し状況が違います。もっとゆるい感じで、コンパイラを基準に対象が明確であれば、&lt;code>.method()&lt;/code>のような形で省略できるような感覚です。以下はSwiftUIのチュートリアルで提示しているコードの一部を抜粋したものですが、&lt;code>filter&lt;/code>が&lt;code>FilterCategory&lt;/code>というenumであるため、&lt;code>.all&lt;/code>という形で三項演算子の中で使われていることを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> filter = FilterCategory.all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">FilterCategory&lt;/span>: String, CaseIterable, Identifiable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> all = &lt;span style="color:#e6db74">&amp;#34;ALL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> lakes = &lt;span style="color:#e6db74">&amp;#34;Lakes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> rivers = &lt;span style="color:#e6db74">&amp;#34;Rivers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> mountains = &lt;span style="color:#e6db74">&amp;#34;Mountains&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> id: FilterCategory { &lt;span style="color:#66d9ef">self&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> title: String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> title = filter == .all ? &lt;span style="color:#e6db74">&amp;#34;Landmarks&amp;#34;&lt;/span> : filter.rawValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> showFavoritesOnly ? &lt;span style="color:#e6db74">&amp;#34;Favorite &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>title&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> : title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="protocol">Protocol&lt;/h4>
&lt;p>Swiftでは&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" target="_blank" rel="noopener"
>Protocol&lt;/a>というものがあり、JavaやKotlinのinterfaceと大体同じ感覚で使えます。ここまでだとあまり差はないように思いますが、実際にはstructやclass、enumなどを定義するときには、必要に応じでprotocolを採用(adopt)する必要があるというところが体験できる違いかなと思います。&lt;/p>
&lt;p>例えば、Kotlinで一つのdata classを定義するとしたら、以下のようなメンバが自動て追加されます。&lt;/p>
&lt;ul>
&lt;li>equals()&lt;/li>
&lt;li>hashCode()&lt;/li>
&lt;li>toString()&lt;/li>
&lt;li>componentN()&lt;/li>
&lt;li>copy()&lt;/li>
&lt;/ul>
&lt;p>しかし、Swiftのstruct, class, enumなどにはこのようなメンバは基本的に追加されません。なので、必要なメンバがあればそれに関するprotocolを採用し、実装する必要があります。例えばハッシュ値が使いたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/hashable" target="_blank" rel="noopener"
>Hashable&lt;/a>、
Jsonなどに変換するためには&lt;a class="link" href="https://developer.apple.com/documentation/swift/codable" target="_blank" rel="noopener"
>Codable&lt;/a>、Listでループしたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/identifiable" target="_blank" rel="noopener"
>Identifiable&lt;/a>、enumの全ケースを網羅してループしたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/caseiterable" target="_blank" rel="noopener"
>CaseIterable&lt;/a>、同一化を比較したい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/equatable" target="_blank" rel="noopener"
>Equatable&lt;/a>を採用するなどです。&lt;/p>
&lt;p>もちろんJavaやKotlinでも必要に応じてintefaceやannotationを使う必要はありますが、SwiftだとKotlinで気軽に使える機能がstructやclassなどを定義した時点では揃ってない可能性があるので、ここは気をつけるべきところですね。&lt;/p>
&lt;h4 id="some">some&lt;/h4>
&lt;p>Swiftでは少し変わった感覚のキーワードがあるます。そのキーワードの説明するために、まずは以下のようなprotocolとstructの定義があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protocol&lt;/span> &lt;span style="color:#a6e22e">Something&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">GoodThing&lt;/span>: Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s good thing!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようなコードがある場合、変数の型宣言や関数の戻り値で少し独特なキーワードを使うことができます。&lt;code>some&lt;/code>というものです。実際使う時は、以下のようなコードとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> good: some Something = GoodThing()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">returnSomething&lt;/span>() -&amp;gt; some Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> GoodThing()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これだけでは&lt;code>some&lt;/code>というキーワードが一体どんなものかわからないですね。ここでKotlinの概念を持ってくるとどうでしょうか。実は、Kotlinでもこれによく似た機能があります。&lt;code>&amp;lt;T extends Something&amp;gt;&lt;/code>です。KotlinやJavaの経験がある型ならこれで十分に何を意味しているかがしっくり来るかなと思います。&lt;/p>
&lt;p>つまり、&lt;code>some&lt;/code>はとあるprotocolを満足する何かしらのインスタンスを示すものです。Swiftではそれを満足するオブジェクトであってもprotocolを直接変数の型や関数の戻り値として定義して直接使うことはできない場合があります。その場合に&lt;code>some&lt;/code>を使うことで問題を回避できます。JavaやKotlinでinterfaceを使って、その具体的な実装は問わなく使うのと一緒だと言えます。このキーワードのおかげで、SwiftUIでは&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"
>View&lt;/a>を満足して入れば画面を構成するどんなコンポーネントとして扱えるようになります。&lt;/p>
&lt;p>ただ、interfaceを扱うのとは概念的に同じだとしても、コードを書く側の感覚としては全く違うのでここは注意しなければならないと思います。&lt;/p>
&lt;h4 id="compiler-control-statements">Compiler Control Statements&lt;/h4>
&lt;p>Swiftには&lt;a class="link" href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#ID538" target="_blank" rel="noopener"
>Compiler Control Statements&lt;/a>という仕様があり、コンパイル時の処理を指定できます。例えば、SwiftUIのチュートリアルでは一つのアプリを実装して、OSによって違う機能を実現するためにこれを利用しているケースがあります。以下がその例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// watchOSで起動する場合は、通知を使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#if&lt;/span> &lt;span style="color:#75715e">os&lt;/span>(&lt;span style="color:#75715e">watchOS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WKNotificationScene(controller: NotificationController.&lt;span style="color:#66d9ef">self&lt;/span>, category: &lt;span style="color:#e6db74">&amp;#34;LandmarkNear&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// macOSで起動する場合は、設定を使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#if&lt;/span> &lt;span style="color:#75715e">os&lt;/span>(&lt;span style="color:#75715e">macOS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Settings {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkSettings()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合もAndroidでアプリを実装する場合はこのような設定が必要になる場面もあるかもしれませんが、バックエンドの経験上ではコードによりコンパイラをコントロールするというケースはあまりなかったので、かなり新鮮な感覚でした。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。SwiftUIの話をするつもりが、Swiftのことだけでかなりの量になってしまったので、SwiftUIについては次のポストで述べようかなと思っています。しかし、Swiftだけでもかなり興味深いところが多かったので、やはりチュートリアルを触ってみて色々な経験ができたので良い選択をしたかなと思います。&lt;/p>
&lt;p>また、やはりKotlinとSwiftがなんとなく似ている部分があるのは感覚的には確かなので、やはりどちらかの経験があると残りの片方への入門もしやすくなるのかなという感覚はあります。これは外国語の教育（自分の専攻です）でいうスキーマ、いわゆるバックグラウンドの知識ある故のことだろうなと思うと、少しうれしくもなりますね。やはりKotlinやってよかったなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>個人的な2022年のロードマップ</title><link>https://retheviper.github.io/posts/my-roadmap-in-2022/</link><pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/my-roadmap-in-2022/</guid><description>&lt;img src="https://retheviper.github.io/images/map.jpg" alt="Featured image of post 個人的な2022年のロードマップ" />&lt;p>このブログを書き始めてから、今年で4年目となります。振り返ってみるとブログを書き始めた頃はSEとして主にSIerの基盤チームの仕事をしていたので、インフラやライブラリを含めさまざまな技術に触れることが多かったのですが、去年に転職をして本格的に業務系エンジニアとしてバックエンドを担当することになり触れる技術や興味などにも変化があったかなと思います。なので、今回は振り返りを兼ねて今年のロードマップに関して少し述べたいと思います。&lt;/p>
&lt;p>過去分のポストを振り返ってみると最初は主にJava、Spring、Linux、Jenkinsなどに関するものが多かったのですが、最近はやはりKotlinで使えるさまざまなフレームワークなどに興味が移っている感覚です。基本的にJavaでもKotlinでもJVM言語であることは同じなのでできることや分野は大差なく、転職してからも使っているフレームワークはSpringなのですが、Kotlinの開発元であるJetBrains社がいろいろなフレームワークを開発しているのもあり自然にそれらに興味を持つようになっていますね。&lt;/p>
&lt;h2 id="sophomore-jinxを克服する">Sophomore jinxを克服する&lt;/h2>
&lt;p>Sophomore jinxは日本語で「2年目のジンクス」といわれている言葉です。大学2年目になると新入生だった頃と比べ、成績が下がり熱意が消えるというということを指す言葉らしいです。これの意味を拡張して、1年目に新人王などに選ばれた選手がその次の年からは成績が悪化したり、人気の映画の続編が面白くなかったりする場合など最初より何か劣化した場合を指すことになっているとか。&lt;/p>
&lt;p>自分の場合はエンジニアになってから4年目になるのですが、確かに2年目からは1年目の時と比べ熱意はなくなっている気がします。だからと言って新しい技術に興味がなくなったり、プログラミング自体が飽きたという訳ではありませんが、前はやりたいことがあったらずっとモニタと睨めっこしながら徹夜でコードを書いたりしていたのに、今はとてもそういう気にならないというのが違うところですね。年を取ったためかとも思いますが、&lt;/p>
&lt;p>これについては自己分析とやりたいこと、そしてできることを冷静に整理して少しづつでも何か成果物を出せるようにしないと思っています。去年もそうでしたが、このようなポストを書くのはそのためでもあります。計画しているもの全てを成せるとは思いませんが、多くの目標の一部でも達成した方が最初から少ない数の目標を立てるよりは良いのかなという気がしています。なので、まずは「やるかどうかわからないけどアンテナは張っておく」という感覚でいろいろな技術に目を通しておこうかなと思っています。&lt;/p>
&lt;h2 id="frontend">Frontend&lt;/h2>
&lt;p>私はJavaScriptとTypeScriptの基礎を研修やUdemyの講座で学んだくらいのレベルで、フロントエンドの仕事をあまりやることがなかったです。しかし、昨今のウェブアプリの開発においてのトレンドをみるとやはりフロントエンドの技術を一つは学んでおいた方が良さげな気もしますし、バックエンドの役割を吸収しているような気配すらするなという気がしますね。何より、エンドユーザにとって画面のないアプリは想像できないので、今まで自分が使うためのAPIやライブラリ、コマンドラインアプリだけでなく本格的にGUIを活用した何かを作ってみるべき時が来たかなと思っています。&lt;/p>
&lt;p>何よりフロントエンドの場合、数年前はいろいろなライブラリとフレームワークが存在してどれを使った方がいいか全くわからない状況でしたが、最近は3強だといわれていた中でもAngularを抜いたReactとVueのみが生き残り、さらにそれらを基盤にしたフレームワークが登場するなど、そろそろ技術の成熟期と言ってもいい時代になったのではないかと思いますので、React基盤の&lt;a class="link" href="https://nextjs.org" target="_blank" rel="noopener"
>Next.js&lt;/a>か、Vue基盤の&lt;a class="link" href="https://nuxtjs.org" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>のどちらかを選べばよい時期なのではと思います。私自身も今年はそのうちのどちらかに触れてみたいなと思っています。&lt;/p>
&lt;p>せっかくなので&lt;a class="link" href="https://nestjs.com" target="_blank" rel="noopener"
>NestJS&lt;/a>のようなJavaScript用のサーバサイドフレームワークにも触れてみるのは良いかもしれませんが、サーバサイドというバックグラウンドがある自分にとってはまずはフロントエンドのみでちょうどよいチャレンジかなと思ったりもします。後述しますが、バックエンドではまた別に触ってみたいものもありますのでなおさらですね。&lt;/p>
&lt;h2 id="quarkus">Quarkus&lt;/h2>
&lt;p>個人的にはSpringを長く使っていたので、新しいフレームワークを使ってみたいという願望があります。一つのフレームワークに慣れると、それを使い続けるのも選択肢としては悪くないと思いますが、新しい技術にはメリットもデメリットもあるものなので、少なくとも触れてみる必要はあるかなと思います。なので去年は&lt;a class="link" href="https://quarkus.io" target="_blank" rel="noopener"
>Quarkus&lt;/a>と&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>Ktor&lt;/a>の二つを触ってみました。&lt;/p>
&lt;p>個人的にはJetBrainsのプロダクトに信用を持っていて、Kotlin向けという点でもKtorは悪くなかったと思ったのですが、機能が不十分であるところや、アーキテクチャで悩ましいところがあるという面で躊躇しています。一方でQuarkusはネイティブにコンパイルでき、Springのライブラリを一部そのまま使えたり、そもそもSpringとあまり変わらない感覚でコードをサクサク書けそうなイメージなので本格的に使用してみたいと思っています。最大の問題はやはり、ネイティブの場合ビルドにかなり時間がかかるということですが、これはCIとの連携をうまくやっていくしかないかもしれませんね。&lt;/p>
&lt;h2 id="fastapi">FastAPI&lt;/h2>
&lt;p>いきなりPythonになりますが、&lt;a class="link" href="https://fastapi.tiangolo.com" target="_blank" rel="noopener"
>FastAPI&lt;/a>にも触れてみたいと思っています。以前から違う分野に転職をするとしてもバックエンドはやり続く可能性が高いと思い、いろいろな言語とフレームワークを触ってみたいと思っていました。その候補としては&lt;a class="link" href="https://expressjs.com/ja" target="_blank" rel="noopener"
>Express&lt;/a>、&lt;a class="link" href="https://rocket.rs" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://vapor.codes" target="_blank" rel="noopener"
>Vapor&lt;/a>などがあって、これらを全部触ってみた後、最も自分の好みに合ったものをプライベートで使い続けようと思っていたのです。&lt;/p>
&lt;p>そんな中、Pythonは普段もたまに簡単な自動化のスクリプトを作るなどの目的で使っているので、&lt;a class="link" href="https://www.djangoproject.com" target="_blank" rel="noopener"
>Django&lt;/a>を触ってみようかと思っていたところ、最近はFastAPIで爆速の開発ができるという話を聞いて興味を持つようになりました。今もKotlinとSpringで開発はできますが、シンプルなプロジェクトならこういった軽いオプションが一つあっても悪くなさそうな気がします。インタープリタ言語なので起動も早く、&lt;a class="link" href="https://www.techempower.com/benchmarks" target="_blank" rel="noopener"
>Techempowerのベンチマーク&lt;/a>でも意外と悪くないパフォーマンスを見せてくれているのも魅力的ですが、&lt;a class="link" href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener"
>Swagger&lt;/a>と&lt;a class="link" href="https://github.com/Redocly/redoc" target="_blank" rel="noopener"
>ReDoc&lt;/a>によるドキュメンテーションが自動で行われるというところがかなり良さげです。なんでもサクッと作れそうな感じがしますね。&lt;/p>
&lt;p>また、直接使わないとしてもコードが綺麗で勉強になる噂を聞いているので、少なくとも一度はコードを読んでみたくなります。&lt;/p>
&lt;h2 id="swiftui-and-jetpack-compose">SwiftUI and Jetpack Compose&lt;/h2>
&lt;p>個人的に本当にやりたかった分野は、GUIを持つアプリを作り上げることです。エンジニアという職業を持つ前から作ったのも&lt;a class="link" href="https://openjfx.io" target="_blank" rel="noopener"
>JavaFX&lt;/a>によるデスクトップアプリでしたので。最近はJavaScriptだけでも&lt;a class="link" href="https://www.electronjs.org" target="_blank" rel="noopener"
>Electron&lt;/a>や&lt;a class="link" href="https://reactnative.dev" target="_blank" rel="noopener"
>React Native&lt;/a>などを使ってなんでもできるという時代にはなっていますが、せっかくJavaとKotlinができるようになったので、ネイティブアプリを作ってみた方が良さそうな気がします。&lt;/p>
&lt;p>以前&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>が発表されてまもない時期に、一度React Nativeと一緒にチュートリアルだけ触れてみたことがあるのですが、当時にもFlutterのいわゆる「宣言型GUI」というものに魅力を感じていたのでこれからモバイルをやるとしたらFlutterかなと悩んでいました。最近はモバイルだけでなく、デスクトップアプリやウェブアプリまで作れるようになったのでなおさらでしたね。&lt;/p>
&lt;p>しかし、&lt;a class="link" href="https://developer.apple.com/xcode/swiftui" target="_blank" rel="noopener"
>SwiftUI&lt;/a>と&lt;a class="link" href="https://developer.android.com/jetpack/compose?hl=ja" target="_blank" rel="noopener"
>Jetpack Compose&lt;/a>というものが登場してからは完全にこちらに傾きました。どうしても同時にマルチプラットフォームアプリが開発できるという面ではFlutterが有利だとは思いますが、それと似たような感覚でネイティブのUIが作れられるようになったのでもう悩む必要がないかなという気がします。&lt;/p>
&lt;p>特に、SwiftUIだとMac用のデスクトップアプリを作ることもできますが、Jetpack Composeならデスクトップアプリだけでなくウェブアプリも作ることができて、さらに&lt;a class="link" href="https://kotlinlang.org/docs/kmm-getting-started.html" target="_blank" rel="noopener"
>Kotlin Multiplatform Mobile&lt;/a>を使うとビジネスロジックの共有ができるようになるのでこちらの方が自分の場合にはより合うのではないかという気がしています。自分に合うというのは、私がめんどくさがり屋なので一つの言語で全てを解決したいという願望を持っているというだけの話ですが…とにかく一度使ってみて、よかったらフロントエンドでもJetpack Composeを使ってみるのはありかなと思っています。&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>という選択肢もありますが、こちらはまた次の機会で。&lt;/p>
&lt;p>ただこれらのデメリットは、やはりどれもまだ完成されてない技術ということですね。分野を問わず新しい技術のジレンマでもありますが、新技術がどれだけ良くてもそれだけでは完全ではない（もしくはかなり不便）という場面が出てくる可能性があるので、当面は少し様子を見ながらシンプルなアプリを作ってみることから初めてみようと思います。Flutterという良い先例があるので、良さげな機能はすぐに吸収してくれるという期待もあります。&lt;/p>
&lt;h2 id="oracle-cloud">Oracle Cloud&lt;/h2>
&lt;p>他のクラウドと比べかなり後発したためか、無料プランでもメモリ1GBのVMインスタンスを二つも提供するという破格の政策で知られたOracle Clouですが、2021年からはさらに選べるVMインスタンスにARM（&lt;a class="link" href="https://www.oracle.com/jp/cloud/compute/arm" target="_blank" rel="noopener"
>Ampere A1&lt;/a>というオプションを追加しています。&lt;/p>
&lt;p>Ampereが既存のAMDやIntel製CPUを使うインスタンスと比べて目立つのはやはり性能です。ARMだと互換性の問題がありx86と比べ利用率が下がると思ったためか、無料プランでも4つのOCPU、24GBのメモリという良い性能のインスタンスを提供しています。無料のインスタンスを2つまで作ることができるので、2つのOCPUと12GBのメモリという構成を2つのインスタンスに分けて指定することもできます。&lt;/p>
&lt;p>個人的には既存の無料で使えるインスタンスが1つのOCPU、1GBのメモリというオプションだったので、Javaアプリのビルドなどヘビーな作業には向いてないのが惜しいところでした。なので&lt;a class="link" href="https://mattermost.com" target="_blank" rel="noopener"
>Mattermost&lt;/a>のサーバとして使うなど軽い感じでしか使い道がなかったのですが、Ampereの導入でCI用サーバなどに使える道もできたかなと思います。Oracle Cloudのホームページで紹介していること以外でも、他の&lt;a class="link" href="https://jiuyu.medium.com/oracle-cloud-ampere-a1-cpu-benchmarks-6464ef43593d" target="_blank" rel="noopener"
>ベンチマーク&lt;/a>を参照するとCPU性能は期待しても良さそうな気がします。無料でOracle DBも提供されているのでそちらを使うか、それともVMインスタンスを一つDB用に使うか、GCPやAWSの無料サービスと組み合わせて使うとかでも色々できそうな気がします。&lt;/p>
&lt;p>ただ、やはり互換性が気になっていたのですが、個人的にはApple Silicon搭載Macを使ってみながら「意外と悪くない」という結論に至っています。プログラミング言語などはすでにARM対応済みのものが多く、サーバで使うとしたら&lt;a class="link" href="https://www.ffmpeg.org" target="_blank" rel="noopener"
>FFmpeg&lt;/a>、&lt;a class="link" href="https://imagemagick.org/index.php" target="_blank" rel="noopener"
>ImageMagick&lt;/a>、&lt;a class="link" href="http://www.graphicsmagick.org" target="_blank" rel="noopener"
>GraphicsMagick&lt;/a>などを使うケースもあるかなと思いますが、どれもARMバージョンをインストールもしくはビルドできるので特に問題はなさそうです。&lt;/p>
&lt;p>他に問題なら、今の所VMインスタンスを作ろうとしてもハードウェアが十分ではないのか、2つのOCPU以上のスペックでは作れないというのが問題ですね。時間が解決してくれる問題かもしれませんが、いつになったらインスタンスを自由に作れるかわからないというのは確かに問題と言えるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>意欲がないといいつつ、これだけやってみたいものが多いというのはまだ自分がエンジニアとして気持ちが死んでいるわけではないからよかったなと思わせます。本当は意欲がないというより「面倒臭いだけ」と訂正するべきかもですね…&lt;/p>
&lt;p>というわけで、色々とやりたいことだけを並べてみましたが、今年はそろそろ何か実際使えるアプリを作り出すのを第一の目標にしたいと思っています。何か作ってみるだけでも間違いなく良い経験、良い経歴になるはずなので。&lt;/p>
&lt;p>では、また！&lt;/p></description></item></channel></rss>