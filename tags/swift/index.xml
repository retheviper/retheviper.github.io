<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>swift on Korean-man in Tokyo</title><link>https://retheviper.github.io/tags/swift/</link><description>Recent content in swift on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 20 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/tags/swift/index.xml" rel="self" type="application/rss+xml"/><item><title>SwiftUIを触ってみた〜その2〜</title><link>https://retheviper.github.io/posts/swift-ui-first-impression-2/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/swift-ui-first-impression-2/</guid><description>&lt;img src="https://retheviper.github.io/images/swift.jpg" alt="Featured image of post SwiftUIを触ってみた〜その2〜" />&lt;p>前回に続いて、今回はSwiftUIを触りながら感じたことについて述べたいと思います。自分のように、今までバックエンドの実績しかないエンジニアがGUIを作るとしたら、画面のレイアウトや色合い、画面間の繊維など「今までなかった概念」で混乱することも多いかなと思います。そしてその中でも特に難しい、うまく扱えない機能などもあるかなと思います。&lt;/p>
&lt;p>自分の場合、プロダクションレベルのコードを書いたことはないものの、以前から&lt;a class="link" href="https://reactnative.dev/" target="_blank" rel="noopener"
>React Native&lt;/a>, &lt;a class="link" href="https://flutter.dev/" target="_blank" rel="noopener"
>Flutter&lt;/a>, &lt;a class="link" href="https://developer.android.com/jetpack/compose" target="_blank" rel="noopener"
>Jetpack Compose&lt;/a>には少し触れたことがあったためSwiftUIで「画面を構成する方式」については少し理解しているつもりでした。しかし、やはりバックエンドでは存在しない機能がありました。&lt;/p>
&lt;p>今回はそのSwiftUIの話となりますが、中でも私が注目した機能もしくは概念について述べたいと思います。&lt;/p>
&lt;h2 id="swiftui">SwiftUI&lt;/h2>
&lt;p>まずは、SwiftUIそのものに対して簡単に紹介しましょう。SwiftUIはいわゆる宣言型(Declarative)UIのフレームワークで、&lt;a class="link" href="https://ja.reactjs.org/" target="_blank" rel="noopener"
>React&lt;/a>や&lt;a class="link" href="https://vuejs.org/" target="_blank" rel="noopener"
>Vue&lt;/a>などのフロントエンドからの影響が見えます。要するに、画面を構成する要素(Widget, Component, Materialなどフレームワークやライブラリによって呼び方は様々ですが)を一つのオブジェクトとして「宣言」し、それらの要素の組み合わせによって一つの画面を完成するという形になっているということです。このような宣言型UIはSwiftUIだけでなく、モバイルに限定してもReact NativeやFlutter、Jetpack Composeなど様々なフレームワークやライブラリで採択しているものでもあります。&lt;/p>
&lt;p>そして、要素の実装についてもフレームワークやライブラリによって色々と方法が分かれますが、SwiftUIでは、個別の要素はViewといい、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"
>View&lt;/a>というprotocolをstructとして実装していきます。なので、一覧を表示する画面であれば、一つの行としてデータを表示するView、その行をリストとして表示するためのView、さらに一覧の上や下にメニューを表示するViewなどが一つ一つのstructとして定義されていく形ということです。&lt;/p>
&lt;p>このような画面の作り方は、フレームワークのパラダイム・コンセプトとして決まってあるものなので、それに従って実装を進めることには私のようにバックグラウンドが全く違うエンジニアでも特に問題はないかなと思います。&lt;/p>
&lt;p>ただ、実際のアプリを作るとしましょう。画面に対してはフレームワークで提示する通り要素を実装して作ったとしたら、アプリを実行してなんらかの処理を行うためにはバックエンドを繋げるか、アプリ内でなんらかの処理を行うかなど「ロジック」とつなげる必要があるはずです。ここで常にとは言い難いのですが、バックエンドでは見慣れない概念が出てくる場合があります。「状態」というものです。&lt;/p>
&lt;h2 id="状態">状態&lt;/h2>
&lt;p>バックエンドのアプリを実装している場合は、リクエストがあり、それに対してのレスポンス（HTTPステータスのみだとしても）がある、という明確なプロセスがありますね。この一連の処理には、「途中で変化する」という概念はありません。この場合のデータは永続化されるか、処理が終了するまでの一時的な物が多いです。&lt;/p>
&lt;p>しかし、画面の世界だと話は変わってきます。多くのモバイルアプリではスライダ、ボタン、テキストボックスなどいろいろな要素で構成されてあり、それらの要素に関する状態が常に変わってくるケースもあるのです。ファイルをダウンロードしている状態を表示するためのプログレスバーがあるとしたら、単純に進行状況を見せるとしたら一つのスレッドを割り当てて処理するだけで良いでしょう。&lt;/p>
&lt;p>ここで一つ、もしダウンロードに「一時停止」のような機能があったらどうでしょうか。プロセスが進行中にボタンを押下したら止まり、再度押下したら再開されるような機能です。他にも色々と考慮すべきものはあるかと思いますが、この「停止している」「再開した」という概念をどこかに記憶しておく必要はあるでしょう。つまり、画面においてのユーザの入力に対して、なんらかの処理を実際に行うまで記憶しておくための機構が必要ということですね。&lt;/p>
&lt;p>SwiftUIでももちろん、状態を管理するためのものがあります。ただ、ユースケースで考えると画面の要素(View)一つに限って必要なものか、それとも複数の要素において必要なものか、複数の画面（アプリ全体）にかけて必要なものかという、スコープによって必要な状態は違うものになります。View一つで必要なものをアプリ全体で管理する必要もなければ、複雑になりがちだからですね。なので、ここではそのスコープ別に状態を管理するためにどんなものがあるのかについて述べていきたいと思います。&lt;/p>
&lt;h3 id="個別viewの状態">個別Viewの状態&lt;/h3>
&lt;p>まずは最も小さい単位、Viewの場合です。先に述べた、一覧の画面が良い例になりそうですね。Appleのチュートリアルでは、以下のような一覧の画面を作ることになります。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 48;
flex-basis: 117px"
>
&lt;a href="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list.png" data-size="860x1756">
&lt;img src="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list.png"
width="860"
height="1756"
srcset="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list_hu0267d8896987db251873bf1e3d824beb_440048_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list_hu0267d8896987db251873bf1e3d824beb_440048_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="List View">
&lt;/a>
&lt;figcaption>List View&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>この画面では右上のボタンを押すことで、一覧に表示するアイテムをフィルタリングできる機能があります。たとえば一部の行にハートマークがついてありますが、これは「お気に入り」を意味していて、そのお気に入りとして登録したものだけをフィルタするか、アイテムのカテゴリでフィルタするかなどの機能が入っています。&lt;/p>
&lt;p>そしてこの画面では、「フィルタするカテゴリ」や「お気に入りだけを表示する」を状態として扱っていますが、この状態は他の画面では知る必要がないデータとなっています。この場合に使えるのが、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/state" target="_blank" rel="noopener"
>@State&lt;/a>です。コードとしては、以下のようになっています。(一部省略)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 一覧画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// お気に入りだけを表示するかどうか&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">showFavoritesOnly&lt;/span> = &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// フィルタするカテゴリ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">filter&lt;/span> = FilterCategory.all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// カテゴリの種類&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">enum&lt;/span> &lt;span style="color:#50fa7b">FilterCategory&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>, CaseIterable, Identifiable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> all = &lt;span style="color:#f1fa8c">&amp;#34;ALL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> lakes = &lt;span style="color:#f1fa8c">&amp;#34;Lakes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> rivers = &lt;span style="color:#f1fa8c">&amp;#34;Rivers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> mountains = &lt;span style="color:#f1fa8c">&amp;#34;Mountains&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">id&lt;/span>: FilterCategory { &lt;span style="color:#ff79c6">self&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// アイテムにフィルタを適用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">filteredLandmarks&lt;/span>: [Landmark] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modelData.landmarks.filter { landmark &lt;span style="color:#ff79c6">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ff79c6">!&lt;/span>showFavoritesOnly &lt;span style="color:#ff79c6">||&lt;/span> landmark.isFavorite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> (filter == .all &lt;span style="color:#ff79c6">||&lt;/span> filter.rawValue == landmark.category.rawValue )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">body&lt;/span>: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NavigationView {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// アイテムの表示部&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(selection: $selectedLandmark) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(filteredLandmarks) { landmark &lt;span style="color:#ff79c6">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NavigationLink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkDetail(landmark: landmark)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkRow(landmark: landmark)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toolbar {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ToolbarItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ツールバーにフィルタを適用するためのボタンを追加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Menu {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 選択できるカテゴリ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Picker(&lt;span style="color:#f1fa8c">&amp;#34;Category&amp;#34;&lt;/span>, selection: $filter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(FilterCategory.allCases) { category &lt;span style="color:#ff79c6">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(category.rawValue).tag(category)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .pickerStyle(.inline)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// お気に入りだけを表示するかどうかのトグル&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Toggle(isOn: $showFavoritesOnly) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#f1fa8c">&amp;#34;Favorites only&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#f1fa8c">&amp;#34;heart.fill&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#f1fa8c">&amp;#34;Filter&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#f1fa8c">&amp;#34;slider.horizontal.3&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、一つのViewにおいて状態を管理するためには、&lt;code>@State&lt;/code>を使うことになります。&lt;/p>
&lt;h3 id="親子関係のviewが共有する状態">親子関係のViewが共有する状態&lt;/h3>
&lt;p>さて、一つのViewでの状態を管理することはできましたが、次に気になるのは複数のView、特に親子関係になるView間でどうやって状態を共有できるかです。たとえば先ほどの一覧画面だと、一つ一つの行がViewになっているものなのですが、&lt;/p>
&lt;p>実は、親のViewから子Viewに状態を渡すというのは、すでに先ほどのコードに表れています。「お気に入りだけを表示するかどうか」のトグルがあるのですが、ここで&lt;code>isOn&lt;/code>に親の状態を渡していますね。ただ、トグル時の挙動を&lt;code>@State&lt;/code>で定義したBooleanと結びつけるために&lt;code>isOn&lt;/code>として渡す際、&lt;code>$&lt;/code>をつけることに注目する必要があります。&lt;code>$&lt;/code>をつけることで、Booleanではなく、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/binding" target="_blank" rel="noopener"
>Binding&lt;!-- raw HTML omitted -->&lt;/a>という形でプロパティを渡すことになります。こうしてラッパーを渡すことで、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/toggle/" target="_blank" rel="noopener"
>Toggle&lt;/a>の中でも親の状態を変更できるようになります。&lt;code>Toggle&lt;/code>は確かに一覧の画面とは別のViewになりますが、押下するたびに親の状態である&lt;code>showFavoritesOnly&lt;/code>の値が変わるということです。&lt;/p>
&lt;p>後でまた関連したポストを書きたいと思いますが、Jetpack Composeでも何となく似たような形で状態の管理ができる方法があります。例えば、&lt;code>@State&lt;/code>のように簡単な状態を管理するためには以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// true/falseの状態
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> toggle: Boolean &lt;span style="color:#ff79c6">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#ff79c6">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> toggle {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;On!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toggle = &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;Off!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toggle = &lt;span style="color:#ff79c6">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のような書き方はいわゆる&lt;a class="link" href="https://kotlinlang.org/docs/delegation.html" target="_blank" rel="noopener"
>Delegation&lt;/a>によるもので、&lt;code>mutableStateOf&amp;lt;T&amp;gt;&lt;/code>が返すのは&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState" target="_blank" rel="noopener"
>MutableState&lt;!-- raw HTML omitted -->&lt;/a>ですが、&lt;code>by&lt;/code>を使うことで実際は&lt;code>Boolean&lt;/code>そのものを扱うようになります。&lt;/p>
&lt;p>そして&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>を分解し、以下のように状態と、状態を変化させる処理の処理を指定することもできます。これもまた、先ほどの&lt;code>Binding&lt;/code>のような役割をするようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// テキストの状態と値の変更
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> (content: String, onValueChange: (String) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// テキストフィールドに状態を表示し、変化があった場合は状態を変更させる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>TextField(&lt;span style="color:#ff79c6">value&lt;/span> = content, onValueChange = onValueChange)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやって他の要素に状態の変更を可能にするためには、基本的にその状態をラップしているオブジェクトを利用するという考えは、SwiftUIでもJetpack Composeでも一緒のようです。ただ、&lt;code>$&lt;/code>というキーワードを使ってラッパーにアクセスできるSwiftと、状態のオブジェクトをどうやって宣言するかを考える必要のあるKotlinの違いがまた面白いポイントです。&lt;/p>
&lt;h3 id="アプリ全体で共有する状態">アプリ全体で共有する状態&lt;/h3>
&lt;p>さて、次はもっと大きい単位としての状態について述べたいと思います。アプリの画面は色々とあり、仲には親子の関係ではない場合もあります。Appleのチュートリアルのアプリをまたの例としてあげますと、以下のように、タブが分かれている場合が代表的なものと言えるかも知れません。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 49;
flex-basis: 119px"
>
&lt;a href="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu.png" data-size="732x1466">
&lt;img src="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu.png"
width="732"
height="1466"
srcset="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu_hu9c7790eb6847b0c09531674054eff1d4_1201768_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu_hu9c7790eb6847b0c09531674054eff1d4_1201768_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Menu View">
&lt;/a>
&lt;figcaption>Menu View&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>ここで、下にある「Featured」や「List」をタッチすることにより表示される画面が変わるわけですが、この二つの画面は親子といえる関係ではありません。以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">selection&lt;/span>: Tab = .featured
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">enum&lt;/span> &lt;span style="color:#50fa7b">Tab&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> featured
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">body&lt;/span>: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// タブメニュー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TabView(selection: $selection) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Featured画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CategoryHome()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tabItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#f1fa8c">&amp;#34;Featured&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#f1fa8c">&amp;#34;star&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tag(Tab.featured)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// LandmarkList画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tabItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#f1fa8c">&amp;#34;List&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#f1fa8c">&amp;#34;list.bullet&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tag(Tab.list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要件によっては、この対等な関係にある画面間でも状態を共有する必要はあります。たとえば、ショッピングのアプリを作るとしたら、自分のアカウントの画面を開いている場合でもカートに入れている商品の情報は維持される必要がありますね。このように、現在表示している画面とは関係なく、アプリ全体で共有する状態が必要な場面があります。&lt;/p>
&lt;p>この場合は、どうしたらいいでしょうか？もちろん、起点となるViewがあるので、そこに&lt;code>@State&lt;/code>を定義しておくというのも一つの方法かも知れません。ただ、状態として管理したい項目が増えれば増えるほど複雑になりがちですね。起点のViewには複数の&lt;code>@State&lt;/code>が必要となり、画面ごとにそれらを渡す必要があります。だとすると、やはり一つのオブジェクトに状態をまとめて置いて使いまわしたいものです。&lt;/p>
&lt;p>Appleのチュートリアルでもそれを提示していて、画面間で共有するデータとしてLandmarkのデータと、ユーザのプロフィールをまとめて共有できるオブジェクトとして提供する方法があります。まずは、以下がその状態のオブジェクトのコードとなります。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">ModelData&lt;/span>: ObservableObject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">landmarks&lt;/span>: [Landmark] = load(&lt;span style="color:#f1fa8c">&amp;#34;landmarkData.json&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">profile&lt;/span> = Profile.&lt;span style="color:#ff79c6">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでアプリ内でLandmarkの情報はjsonから読み取ったものとなっていて、プロフィールはEnumとなっています。そして&lt;a class="link" href="https://developer.apple.com/documentation/combine/observableobject" target="_blank" rel="noopener"
>ObservableObject&lt;/a>というプロトコールが使われているのが見えますね。&lt;code>ObservableObject&lt;/code>を使うことで、このModelDataというクラスは変更される状態を保持し、値の変更があった場合はそれを参照する画面に通知する&lt;code>Publisher&lt;/code>として機能することになります。そしてそれぞれの状態となるプロパティについては、&lt;a class="link" href="https://developer.apple.com/documentation/combine/published" target="_blank" rel="noopener"
>@Published&lt;/a>をつけることで状態として指定することになります。&lt;/p>
&lt;p>こうして状態を保持するためのオブジェクトを定義したら、次はアプリ内でどうやって使用するかですね。チュートリアルでは、以下のようにアプリのメインとなるstructに以下のように定義しています。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>@main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarksApp&lt;/span>: App {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ModelDataを状態のオブジェクトとして宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @StateObject &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">modelData&lt;/span> = ModelData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">body&lt;/span>: some Scene {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WindowGroup {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ContentView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .environmentObject(modelData) &lt;span style="color:#6272a4">// メイン画面に状態オブジェクトを渡す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードでわかるように、アプリでは定義しておいた状態オブジェクトを&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/stateobject" target="_blank" rel="noopener"
>@StateObject&lt;/a>をつけて、メイン画面に渡すことで使うようになります。ちなみにこうやって&lt;code>View&lt;/code>として定義された画面にならどんなものでも&lt;code>environmentObject()&lt;/code>に状態オブジェクトを渡すことができるので、画面の一部だけをプレビューとして表示する場合でも、プレビューに表示する画面に状態オブジェクトを渡すことで動作を試すこともできます。例えば、先ほどのLandmarkの一覧画面のプレビューだと、以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarkList_Previews&lt;/span>: PreviewProvider {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">previews&lt;/span>: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .environmentObject(ModelData()) &lt;span style="color:#6272a4">// 状態オブジェクトを渡す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうして状態オブジェクトを画面に渡したら、中では使うだけです。&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/environmentobject" target="_blank" rel="noopener"
>@EnvironmentObject&lt;/a>というアノテーションを使って、状態を持つオブジェクトを宣言するだけで自動的にオブジェクトはDIされ、その画面で使えるようになります。また一覧の画面の話となりますが、以下のコードを見てください。&lt;code>landmarks&lt;/code>のデータを使って一覧を表示しているのがわかります。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 状態オブジェクト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @EnvironmentObject &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">modelData&lt;/span>: ModelData
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 状態オブジェクトからデータを取り出しフィルタを適用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">filteredLandmarks&lt;/span>: [Landmark] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modelData.landmarks.filter { landmark &lt;span style="color:#ff79c6">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ff79c6">!&lt;/span>showFavoritesOnly &lt;span style="color:#ff79c6">||&lt;/span> landmark.isFavorite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> (filter == .all &lt;span style="color:#ff79c6">||&lt;/span> filter.rawValue == landmark.category.rawValue )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、Jetpack Composeの場合はこのような方法ではなく、オブジェクトそのものを&lt;code>remember&lt;/code>するように使うようです。例えば以下のような形になります。そもそも要素を作成するアプローチが違うのが理由の一つなのかも知れませんね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// アプリ全体で共有する状態
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">ApplicationState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> environment: MutableState&amp;lt;Environment&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> hash: MutableState&amp;lt;String&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 状態の初期化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>@Composable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">rememberApplicationState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment: MutableState&amp;lt;Environment&amp;gt; = mutableStateOf(&lt;span style="color:#50fa7b">Environment&lt;/span>.PRODUCTION),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hash: MutableState&amp;lt;String&amp;gt; = mutableStateOf(&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): ApplicationState {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> remember(environment, hash) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationState(environment, hash)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 状態の定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> appState = rememberApplicationState()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="永続化できる状態">永続化できる状態&lt;/h3>
&lt;p>今までの状態は、アプリが実行中のみ有効なものでした。それだけでも十分な場合もありますが、場合によっては状態を永続化したい場合もあるでしょう。例えば、学習用のアプリだとしたらどこまで進行したかなどを保存しておきたいかなと思います。このような種のデータは、アプリを再起動しても変わらないことを期待しますね。&lt;/p>
&lt;p>もちろん、この場合のためにDBがあり、ネットワーク機能のあるアプリならサーバ側にデータを保存したりするでしょう。ただ、この場合は「状態」とは言えないものですね。なぜなら、状態は画面の更新を伴うものだからです。画面をタッチした回数を、画面に表示しながら同時に保存しておきたい場合は毎回DBの更新と参照で実装したくない場合もあるかなと思います。そこで使えるのが、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/appstorage" target="_blank" rel="noopener"
>@AppStorage&lt;/a>です。これを使うことで、画面の更新と永続化を同時に行うことができます。&lt;/p>
&lt;p>また、チュートリアルによると、いくつかデフォルトとして保存されているデータに関してもこのアノテーションでアクセスできるようにになっています。一覧画面に表示される「お気に入り」ボタンの例ですが、ボタンのアイコンを&lt;code>@AppStorage&lt;/code>から参照するようになっています。コードは以下です。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">FavoriteButton&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ボタンはハートのアイコンとして表示する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @AppStorage(&lt;span style="color:#f1fa8c">&amp;#34;Favorite.iconType&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">iconType&lt;/span>: IconType = .heart
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。自分の感想としては、やはり今まで自分が触れてきた分野とは全く違う概念やアプローチが多かったので、大変興味深いと思いつつ、「これであっているのか」という疑問もかなり湧いてくるような経験となっています。全く経験のない分野に足を踏み入れるのは常にそういうものなのかも知れませんが。&lt;/p>
&lt;p>ただこれで、ある程度アプリを作る場合にどうやって処理を行うべきかについての疑問の一つは解けたような気がします。本当は画面を作る分、他にも色々と新しい概念が出てきたり、画面のレイアウトやUXの観点で色々と難しいものが出てくるかも知れませんが、とにかく「動く」ものを作れそうな気はしますね。何卒自分のようにバックエンドのみを経験してきた形にとって参考できるような記事となっていればと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>SwiftUIを触ってみた〜その1〜</title><link>https://retheviper.github.io/posts/swift-ui-first-impression-1/</link><pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/swift-ui-first-impression-1/</guid><description>&lt;img src="https://retheviper.github.io/images/swift.jpg" alt="Featured image of post SwiftUIを触ってみた〜その1〜" />&lt;p>今までの自分のキャリアを振り返ってみると、仕事としての経験はバックエンドばかりで、画面側の実装にはあまり関わったことがありません。しかし、スタンドアロンのアプリを作るためには、ウェブ・モバイル・デスクトップを問わず画面が必要となるので、いつかは画面側の実装もできるようになる必要があるかなと常に思っているところです。&lt;/p>
&lt;p>画面を作るといっても、どんな分野のエンジニアとしてキャリアパスを考えているか、どのような企業で働きたいか、慣れている言語は何であるかなど色々と考慮すべき要素は多いのですが、自分の場合はKotlinに慣れているのもあり、ウェブ・モバイル・デスクトップアプリに全部対応できるという点から&lt;a class="link" href="https://www.jetbrains.com/lp/compose-mpp" target="_blank" rel="noopener"
>Jectpack Compose&lt;/a>を、また普段からMacとiPhone、iPadといったApple社の製品をよく使っている上、KotlinからのSwift入門が比較的簡単ということで&lt;a class="link" href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener"
>SwiftUI&lt;/a>を勉強したいと思っています。&lt;/p>
&lt;p>さて、言語とフレームワークを決めてからは実践ですね。&lt;a class="link" href="https://developer.apple.com/tutorials/swiftui" target="_blank" rel="noopener"
>公式のチュートリアル&lt;/a>が充実していたので、まずはこちらの方をすすめながら感じたSwiftやSwiftUIで印象的だった部分についてまとめてみたいと思います。もちろん、自分は仕事としてモバイルアプリの実装に関わったことがないのでコンテンツとしては粗末なものとなるかなと思いますが、もし自分のようにKotlinのバックグラウンドからSwiftに触れてみようと思っている方や、バックエンドのみのキャリアからGUIに初めて触れる方、もしくはKotlinとSwiftのどちらかに興味を持っている方には参考になる内容となればと思います。&lt;/p>
&lt;h2 id="swift">Swift&lt;/h2>
&lt;p>まずは言語そのものから。KotlinとSwiftはよく似ているという話を聞くことがありますが、正確に「どこが」というのはやはり触れてみる前はわからないものです。似ているという表現は共通点があるという意味なので、何に基準を置くかによって挙げられる共通点は色々と変わってくるものだからです。&lt;/p>
&lt;p>例えば、言語デザインの観点でOOP志向的で、関数型的な要素があり、GCが存在する、ということでも共通点は発見できます。もしくは、言語の使用としてキーワードや書き方の印象が似ているという意味にもなれますね。細かくは、セミコロンを使わなくて良いという点も挙げられますね。&lt;/p>
&lt;p>なので、まずは上記のチュートリアルを進行しながら、肌で感じた感覚から、Kotlinに比べたSwiftはどのようなものだったかを述べていきたいと思います。&lt;/p>
&lt;h3 id="kotlinに似ているもの">Kotlinに似ているもの&lt;/h3>
&lt;p>では、まずKotlinに似ているなと感じたところから述べていきます。似ているとしても、あくまで「肌の感触」なものなので、厳密には違う仕様になっているものも多いのですが、ここでの基準は「Kotlinでできたことをどれほど近い感覚で再現できるか」となっていますので（といっても個人的な感想ですが）、参考までに。&lt;/p>
&lt;h4 id="computed-properties">Computed properties&lt;/h4>
&lt;p>まず、プロパティの話からです。Kotlinではdata classを定義するとき、プロパティを以下のような二つの方法で定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> age: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> isAdult: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>() = age &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">18&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>age&lt;/code>はインスタンスを作成するときに固定される単純な値となりますが、&lt;code>isAdult&lt;/code>はgetterとして定義した処理(&lt;code>age&lt;/code>が18以上かどうかという)の結果を返すように定義する形ですね。このような処理を伴うプロパティは、Swiftでも同じく&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID259" target="_blank" rel="noopener"
>Computed Properties&lt;/a>を通じて定義することができました。同じような処理を行う場合、以下のように定義できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">age&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">isAdult&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">Bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> age &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">18&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだ一つしたあげてないのですが、これだけでもなんとなく「KotlinとSwiftが似ている」の意味が少しは見えてきた気がしますね。処理を伴うプロパティを扱える、という仕様がそうですが、型の定義もそうで、キーワードは少し違うけど大体似たような感覚でコードが読めるというところがそうです。&lt;/p>
&lt;p>ただ、やはり違う部分もありますね。data classに対して、SwiftはGoやRustのようにstructを使えるというところがそうかなと思います。もちろんSwiftにもClassはあるので、目的によってどれかを選ぶようになるらしいです。という面では、またなんとなくKotlinでdata classとclassを分けて使うという点と似ているような気もしますね。&lt;/p>
&lt;h4 id="extension">Extension&lt;/h4>
&lt;p>次は、拡張です。Kotlinではオブジェクトについて、そのオブジェクトの外にメソッドやプロパティを定義することができますね。これらを拡張関数や拡張プロパティと呼び、以下のように定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> Student.isUnderAge: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>() = age &amp;lt; &lt;span style="color:#bd93f9">18&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前このブログでも述べたことのある&lt;a class="link" href="https://www.amazon.co.jp/dp/B08WXCRVD2/ref=dp-kindle-redirect?_encoding=UTF8&amp;amp;btkr=1" target="_blank" rel="noopener"
>Effective Kotlin&lt;/a>で提示されている活用方法ですが、ユースケースやドメインによって違う処理が必要となった場合は、class内に全てのメソッドやプロパティをを定義するよりはこのような拡張を使って、パッケージごとに定義することでアクセス制限を設ける方法があります。&lt;/p>
&lt;p>同じようなことがSwiftでもできますが、書き方はやはり少し違いました。上記のようなプロパティをSwiftで同じ方法で実装する場合、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">extension&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">isUnderAge&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">Bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> age &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> &lt;span style="color:#bd93f9">18&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにSwiftには&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html" target="_blank" rel="noopener"
>Extension&lt;/a>が別途キーワードとして存在していて、新しくclassやstructを定義するかのような感覚で関数やプロパティを付け加えることができます。個人的な感想としてはRustの&lt;a class="link" href="https://doc.rust-jp.rs/book-ja/ch05-03-method-syntax.html" target="_blank" rel="noopener"
>メソッド&lt;/a>と似ている形で、一つの&lt;code>extension&lt;/code>の中にまとめられるところがむしろKotlinより整頓された感覚なので良さげですね。Kotlinの場合、一つのオブジェクトに対しての拡張が複数あると少し汚くも見えるので…&lt;/p>
&lt;h4 id="string-interpolation">String Interpolation&lt;/h4>
&lt;p>Javaの場合でもそうで、多くの言語では文字列と、違う変数として格納してある値を一つの文字列にまとめる場合は&lt;code>format()&lt;/code>を使うか、文字列に変換して結合するケースが多いかなと思います。Kotlinでもそのような使い方はもちろんできますが、&lt;a class="link" href="https://kotlinlang.org/docs/basic-types.html#string-templates" target="_blank" rel="noopener"
>String template&lt;/a>があるので、簡単に文字列の中で違う値を埋め込むことができます。例えば以下のようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> world = &lt;span style="color:#f1fa8c">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(&lt;span style="color:#f1fa8c">&amp;#34;Hello, &lt;/span>&lt;span style="color:#f1fa8c">$world&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Swiftでも&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID292" target="_blank" rel="noopener"
>String Interpolation&lt;/a>があるので、同じことができます。少し書き方が変わっているのですが、機能的にはほぼ一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">world&lt;/span> = &lt;span style="color:#f1fa8c">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#f1fa8c">&amp;#34;Hello, &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>world&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="arguments">Arguments&lt;/h4>
&lt;p>Kotlinでは、関数のパラメータにデフォルト値を設定することで、簡単にオーバーロードを実現でき、そのパラメータが渡されてない場合の処理にも対応できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// timesに指定した数値分、stringを標準出力する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">printHello&lt;/span>(string: String, times: Int = &lt;span style="color:#bd93f9">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(times) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;Hello, &lt;/span>&lt;span style="color:#f1fa8c">$string&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(&lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// timesに値を指定しなくても関数を呼び出せる
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、どのパラメータに値を指定したいかを明確にするときや、関数に定義されたパラメータの順番に関係なく値を指定したい場合など色々な場面で&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>Named Arguments&lt;/a>を使うことができますね。例えば&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html" target="_blank" rel="noopener"
>joinToString()&lt;/a>には&lt;code>separator&lt;/code>、&lt;code>limit&lt;/code>、&lt;code>truncated&lt;/code>など6つのパラメータがあるのですが、デフォルト値が指定されていて、Named Argumentsにより以下のような使い方が可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;D&amp;#34;&lt;/span>).joinToString(prefix = &lt;span style="color:#f1fa8c">&amp;#34;[&amp;#34;&lt;/span>, postfix = &lt;span style="color:#f1fa8c">&amp;#34;]&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Named ArgumentはKotlinにおいてはオプションで、基本的にはJava同様、関数に定義されてあるパラメータの順番に合わせて値を渡すだけでも問題ありません。しかし、Swiftではこれが逆になっていて、sturctのインスタンスを作る場合や関数を呼び出す場合は基本的にパラメータは基本的にNamed Argumentsのような形で渡す必要があります。これを&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID166" target="_blank" rel="noopener"
>Argument Label&lt;/a>と読んでいるそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">printHello&lt;/span>(string: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#f1fa8c">&amp;#34;Hello &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>string&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(string: &lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// Function Argument Labelでstringを指定&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、これもKotlinと同様、デフォルト値を指定することができ、その場合はパラメータを省略することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">printHello&lt;/span>(string: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>, times: &lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span> = &lt;span style="color:#bd93f9">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">count&lt;/span> = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">repeat&lt;/span> { &lt;span style="color:#6272a4">// Kotlinのdo-whileループ的なもの&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#f1fa8c">&amp;#34;Hello &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>string&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">while&lt;/span> (count &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> times)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(string: &lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// timesを省略している&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、アンダースコアを使うことでArgument Labelを省略できるようにもなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">printHello&lt;/span>(&lt;span style="color:#ff79c6">_&lt;/span> string: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>, times: &lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span> = &lt;span style="color:#bd93f9">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">count&lt;/span> = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">repeat&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#f1fa8c">&amp;#34;Hello &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>string&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">while&lt;/span> (count &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> times)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(&lt;span style="color:#f1fa8c">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#6272a4">// stringを省略&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>関数を定義する側からしたらあまり似ていないような気もするのですが、呼び出す側としてはかなり似たような形でコードが書けるのが特徴的かなと思います。&lt;/p>
&lt;h4 id="range">Range&lt;/h4>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html#:~:text=values%20using%20the-,rangeTo%28%29,-function%20from%20the" target="_blank" rel="noopener"
>rangeTo()&lt;/a>を使って、簡単に数値の範囲を定義することができます。この関数は&lt;a class="link" href="https://kotlinlang.org/docs/keyword-reference.html#operators-and-special-symbols" target="_blank" rel="noopener"
>operator&lt;/a>として定義されているので、&lt;code>..&lt;/code>で簡単に使えます。こうやって定義したRangeでは、最小値と最大値の取得や、Listに変換するなど色々なことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Rangeの定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> min = &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> max = &lt;span style="color:#bd93f9">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> range = min&lt;span style="color:#ff79c6">..&lt;/span>max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 最小値と最大値の取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(range.start) &lt;span style="color:#6272a4">// 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(range.endInclusive) &lt;span style="color:#6272a4">// 20
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// RangeをListにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> intList = range.toList() &lt;span style="color:#6272a4">// [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Swiftでも&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID73" target="_blank" rel="noopener"
>Range Operator&lt;/a>を使って範囲を定義することができます。こちらも形は似ていて、&lt;code>...&lt;/code>となります。ドットの数がKotlinより一つ多いという点を除くと全く同じ感覚で、最小値と最大値もまた名前が違うだけでプロパティとして取得できるという点もまた一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Rangeの定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">min&lt;/span> = &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">max&lt;/span> = &lt;span style="color:#bd93f9">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">range&lt;/span> = min...max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 最小値と最大値の取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(range.lowerBound) &lt;span style="color:#6272a4">// 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(range.upperBound) &lt;span style="color:#6272a4">// 20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// RangeをArrayにする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">array&lt;/span> = &lt;span style="color:#8be9fd;font-style:italic">Array&lt;/span>(range) &lt;span style="color:#6272a4">// [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記のコードを見ると気付きにくいところですが、Range実装については両言語での扱いが少し違うところがあります。Kotlinでは&lt;code>rangeTo()&lt;/code>の戻り値が、元の値の型に合わせて&lt;code>InteRange&lt;/code>や&lt;code>LongRange&lt;/code>のようなものとなっていて、最小値と最大値をプロパティで取得する場合も&lt;code>rangeTo&lt;/code>に渡された二つの値の型と一緒です。&lt;/p>
&lt;p>しかし、Swiftの&lt;a class="link" href="https://developer.apple.com/documentation/swift/range" target="_blank" rel="noopener"
>Range&lt;/a>は&lt;code>Range&amp;lt;Bound&amp;gt;&lt;/code>という型で、当然Rangeから取得できる最小値や最大値も&lt;a class="link" href="https://developer.apple.com/documentation/swift/rangeexpression/bound/" target="_blank" rel="noopener"
>Bound&lt;/a>の型となっています。IntやLongとはまた別の型になるので、場合によっては注意して使う必要があるかも知れません。&lt;/p>
&lt;h3 id="swiftだけのもの">Swiftだけのもの&lt;/h3>
&lt;p>今まではKotlinユーザの観点から、Kotlinとどれだけ同じ感覚でコードを書けるか、ということを述べていましたが、ここからは少し間隔が違うなと思ったところを少しまとめてみようと思います。&lt;/p>
&lt;h4 id="メソッドプロパティコールでの省略">メソッド・プロパティコールでの省略&lt;/h4>
&lt;p>Kotlinでは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply()&lt;/a>のように自分自身を指しているのが明確な場合、&lt;code>this&lt;/code>を省略することができます。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> age: Int = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> studentA = Student(name = &lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>).apply { age = &lt;span style="color:#bd93f9">18&lt;/span> } &lt;span style="color:#6272a4">// Student(name=A, age=18)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、&lt;code>this&lt;/code>を使う場合か、明確に対象importしているなど特定のケースを除くとKotlinでは基本的に&lt;code>Class.method()&lt;/code>のような形でどのクラスのメンバを呼び出しているかを表記するのが原則ですね。&lt;/p>
&lt;p>しかし、Swiftの場合は少し状況が違います。もっとゆるい感じで、コンパイラを基準に対象が明確であれば、&lt;code>.method()&lt;/code>のような形で省略できるような感覚です。以下はSwiftUIのチュートリアルで提示しているコードの一部を抜粋したものですが、&lt;code>filter&lt;/code>が&lt;code>FilterCategory&lt;/code>というenumであるため、&lt;code>.all&lt;/code>という形で三項演算子の中で使われていることを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">filter&lt;/span> = FilterCategory.all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">enum&lt;/span> &lt;span style="color:#50fa7b">FilterCategory&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>, CaseIterable, Identifiable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> all = &lt;span style="color:#f1fa8c">&amp;#34;ALL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> lakes = &lt;span style="color:#f1fa8c">&amp;#34;Lakes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> rivers = &lt;span style="color:#f1fa8c">&amp;#34;Rivers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> mountains = &lt;span style="color:#f1fa8c">&amp;#34;Mountains&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">id&lt;/span>: FilterCategory { &lt;span style="color:#ff79c6">self&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">title&lt;/span>: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">title&lt;/span> = filter == .all ? &lt;span style="color:#f1fa8c">&amp;#34;Landmarks&amp;#34;&lt;/span> : filter.rawValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> showFavoritesOnly ? &lt;span style="color:#f1fa8c">&amp;#34;Favorite &lt;/span>&lt;span style="color:#f1fa8c">\(&lt;/span>title&lt;span style="color:#f1fa8c">)&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> : title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="protocol">Protocol&lt;/h4>
&lt;p>Swiftでは&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" target="_blank" rel="noopener"
>Protocol&lt;/a>というものがあり、JavaやKotlinのinterfaceと大体同じ感覚で使えます。ここまでだとあまり差はないように思いますが、実際にはstructやclass、enumなどを定義するときには、必要に応じでprotocolを採用(adopt)する必要があるというところが体験できる違いかなと思います。&lt;/p>
&lt;p>例えば、Kotlinで一つのdata classを定義するとしたら、以下のようなメンバが自動て追加されます。&lt;/p>
&lt;ul>
&lt;li>equals()&lt;/li>
&lt;li>hashCode()&lt;/li>
&lt;li>toString()&lt;/li>
&lt;li>componentN()&lt;/li>
&lt;li>copy()&lt;/li>
&lt;/ul>
&lt;p>しかし、Swiftのstruct, class, enumなどにはこのようなメンバは基本的に追加されません。なので、必要なメンバがあればそれに関するprotocolを採用し、実装する必要があります。例えばハッシュ値が使いたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/hashable" target="_blank" rel="noopener"
>Hashable&lt;/a>、
Jsonなどに変換するためには&lt;a class="link" href="https://developer.apple.com/documentation/swift/codable" target="_blank" rel="noopener"
>Codable&lt;/a>、Listでループしたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/identifiable" target="_blank" rel="noopener"
>Identifiable&lt;/a>、enumの全ケースを網羅してループしたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/caseiterable" target="_blank" rel="noopener"
>CaseIterable&lt;/a>、同一化を比較したい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/equatable" target="_blank" rel="noopener"
>Equatable&lt;/a>を採用するなどです。&lt;/p>
&lt;p>もちろんJavaやKotlinでも必要に応じてintefaceやannotationを使う必要はありますが、SwiftだとKotlinで気軽に使える機能がstructやclassなどを定義した時点では揃ってない可能性があるので、ここは気をつけるべきところですね。&lt;/p>
&lt;h4 id="some">some&lt;/h4>
&lt;p>Swiftでは少し変わった感覚のキーワードがあるます。そのキーワードの説明するために、まずは以下のようなprotocolとstructの定義があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">protocol&lt;/span> &lt;span style="color:#50fa7b">Something&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">define&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">GoodThing&lt;/span>: Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">define&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#f1fa8c">&amp;#34;It&amp;#39;s good thing!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようなコードがある場合、変数の型宣言や関数の戻り値で少し独特なキーワードを使うことができます。&lt;code>some&lt;/code>というものです。実際使う時は、以下のようなコードとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">good&lt;/span>: some Something = GoodThing()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">returnSomething&lt;/span>() -&amp;gt; some Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> GoodThing()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これだけでは&lt;code>some&lt;/code>というキーワードが一体どんなものかわからないですね。ここでKotlinの概念を持ってくるとどうでしょうか。実は、Kotlinでもこれによく似た機能があります。&lt;code>&amp;lt;T extends Something&amp;gt;&lt;/code>です。KotlinやJavaの経験がある型ならこれで十分に何を意味しているかがしっくり来るかなと思います。&lt;/p>
&lt;p>つまり、&lt;code>some&lt;/code>はとあるprotocolを満足する何かしらのインスタンスを示すものです。Swiftではそれを満足するオブジェクトであってもprotocolを直接変数の型や関数の戻り値として定義して直接使うことはできない場合があります。その場合に&lt;code>some&lt;/code>を使うことで問題を回避できます。JavaやKotlinでinterfaceを使って、その具体的な実装は問わなく使うのと一緒だと言えます。このキーワードのおかげで、SwiftUIでは&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"
>View&lt;/a>を満足して入れば画面を構成するどんなコンポーネントとして扱えるようになります。&lt;/p>
&lt;p>ただ、interfaceを扱うのとは概念的に同じだとしても、コードを書く側の感覚としては全く違うのでここは注意しなければならないと思います。&lt;/p>
&lt;h4 id="compiler-control-statements">Compiler Control Statements&lt;/h4>
&lt;p>Swiftには&lt;a class="link" href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#ID538" target="_blank" rel="noopener"
>Compiler Control Statements&lt;/a>という仕様があり、コンパイル時の処理を指定できます。例えば、SwiftUIのチュートリアルでは一つのアプリを実装して、OSによって違う機能を実現するためにこれを利用しているケースがあります。以下がその例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// watchOSで起動する場合は、通知を使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#if&lt;/span> &lt;span style="color:#ff79c6">os&lt;/span>(&lt;span style="color:#ff79c6">watchOS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WKNotificationScene(controller: NotificationController.&lt;span style="color:#ff79c6">self&lt;/span>, category: &lt;span style="color:#f1fa8c">&amp;#34;LandmarkNear&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// macOSで起動する場合は、設定を使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#if&lt;/span> &lt;span style="color:#ff79c6">os&lt;/span>(&lt;span style="color:#ff79c6">macOS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Settings {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkSettings()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合もAndroidでアプリを実装する場合はこのような設定が必要になる場面もあるかも知れませんが、バックエンドの経験上ではコードによりコンパイラをコントロールするというケースはあまりなかったので、かなり新鮮な感覚でした。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。SwiftUIの話をするつもりが、Swiftのことだけでかなりの量になってしまったので、SwiftUIについては次のポストで述べようかなと思っています。しかし、Swiftだけでもかなり興味深いところが多かったので、やはりチュートリアルを触ってみて色々な経験ができたので良い選択をしたかなと思います。&lt;/p>
&lt;p>また、やはりKotlinとSwiftがなんとなく似ている部分があるのは感覚的には確かなので、やはりどちらかの経験があると残りの片方への入門もしやすくなるのかなという感覚はあります。これは外国語の教育（自分の専攻です）でいうスキーマ、いわゆるバックグラウンドの知識ある故のことだろうなと思うと、少しうれしくもなりますね。やはりKotlinやってよかったなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>個人的な2022年のロードマップ</title><link>https://retheviper.github.io/posts/my-roadmap-in-2022/</link><pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/my-roadmap-in-2022/</guid><description>&lt;img src="https://retheviper.github.io/images/map.jpg" alt="Featured image of post 個人的な2022年のロードマップ" />&lt;p>このブログを書き始めてから、今年で4年目となります。振り返ってみるとブログを書き始めた頃はSEとして主にSIerの基盤チームの仕事をしていたので、インフラやライブラリを含めさまざまな技術に触れることが多かったのですが、去年に転職をして本格的に業務系エンジニアとしてバックエンドを担当することになり触れる技術や興味などにも変化があったかなと思います。なので、今回は振り返りを兼ねて今年のロードマップに関して少し述べたいと思います。&lt;/p>
&lt;p>過去分のポストを振り返ってみると最初は主にJava、Spring、Linux、Jenkinsなどに関するものが多かったのですが、最近はやはりKotlinで使えるさまざまなフレームワークなどに興味が移っている感覚です。基本的にJavaでもKotlinでもJVM言語であることは同じなのでできることや分野は大差なく、転職してからも使っているフレームワークはSpringなのですが、Kotlinの開発元であるJetBrains社がいろいろなフレームワークを開発しているのもあり自然にそれらに興味を持つようになっていますね。&lt;/p>
&lt;h2 id="sophomore-jinxを克服する">Sophomore jinxを克服する&lt;/h2>
&lt;p>Sophomore jinxは日本語で「2年目のジンクス」といわれている言葉です。大学2年目になると新入生だった頃と比べ、成績が下がり熱意が消えるというということを指す言葉らしいです。これの意味を拡張して、1年目に新人王などに選ばれた選手がその次の年からは成績が悪化したり、人気の映画の続編が面白くなかったりする場合など最初より何か劣化した場合を指すことになっているとか。&lt;/p>
&lt;p>自分の場合はエンジニアになってから4年目になるのですが、確かに2年目からは1年目の時と比べ熱意はなくなっている気がします。だからと言って新しい技術に興味がなくなったり、プログラミング自体が飽きたという訳ではありませんが、前はやりたいことがあったらずっとモニタと睨めっこしながら徹夜でコードを書いたりしていたのに、今はとてもそういう気にならないというのが違うところですね。年を取ったためかとも思いますが、&lt;/p>
&lt;p>これについては自己分析とやりたいこと、そしてできることを冷静に整理して少しづつでも何か成果物を出せるようにしないと思っています。去年もそうでしたが、このようなポストを書くのはそのためでもあります。計画しているもの全てを成せるとは思いませんが、多くの目標の一部でも達成した方が最初から少ない数の目標を立てるよりは良いのかなという気がしています。なので、まずは「やるかどうかわからないけどアンテナは張っておく」という感覚でいろいろな技術に目を通しておこうかなと思っています。&lt;/p>
&lt;h2 id="frontend">Frontend&lt;/h2>
&lt;p>私はJavaScriptとTypeScriptの基礎を研修やUdemyの講座で学んだくらいのレベルで、フロントエンドの仕事をあまりやることがなかったです。しかし、昨今のウェブアプリの開発においてのトレンドをみるとやはりフロントエンドの技術を一つは学んでおいた方が良さげな気もしますし、バックエンドの役割を吸収しているような気配すらするなという気がしますね。何より、エンドユーザにとって画面のないアプリは想像できないので、今まで自分が使うためのAPIやライブラリ、コマンドラインアプリだけでなく本格的にGUIを活用した何かを作ってみるべき時が来たかなと思っています。&lt;/p>
&lt;p>何よりフロントエンドの場合、数年前はいろいろなライブラリとフレームワークが存在してどれを使った方がいいか全くわからない状況でしたが、最近は3強だといわれていた中でもAngularを抜いたReactとVueのみが生き残り、さらにそれらを基盤にしたフレームワークが登場するなど、そろそろ技術の成熟期と言ってもいい時代になったのではないかと思いますので、React基盤の&lt;a class="link" href="https://nextjs.org" target="_blank" rel="noopener"
>Next.js&lt;/a>か、Vue基盤の&lt;a class="link" href="https://nuxtjs.org" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>のどちらかを選べばよい時期なのではと思います。私自身も今年はそのうちのどちらかに触れてみたいなと思っています。&lt;/p>
&lt;p>せっかくなので&lt;a class="link" href="https://nestjs.com" target="_blank" rel="noopener"
>NestJS&lt;/a>のようなJavaScript用のサーバサイドフレームワークにも触れてみるのは良いかも知れませんが、サーバサイドというバックグラウンドがある自分にとってはまずはフロントエンドのみでちょうどよいチャレンジかなと思ったりもします。後述しますが、バックエンドではまた別に触ってみたいものもありますのでなおさらですね。&lt;/p>
&lt;h2 id="quarkus">Quarkus&lt;/h2>
&lt;p>個人的にはSpringを長く使っていたので、新しいフレームワークを使ってみたいという願望があります。一つのフレームワークに慣れると、それを使い続けるのも選択肢としては悪くないと思いますが、新しい技術にはメリットもデメリットもあるものなので、少なくとも触れてみる必要はあるかなと思います。なので去年は&lt;a class="link" href="https://quarkus.io" target="_blank" rel="noopener"
>Quarkus&lt;/a>と&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>Ktor&lt;/a>の二つを触ってみました。&lt;/p>
&lt;p>個人的にはJetBrainsのプロダクトに信用を持っていて、Kotlin向けという点でもKtorは悪くなかったと思ったのですが、機能が不十分であるところや、アーキテクチャで悩ましいところがあるという面で躊躇しています。一方でQuarkusはネイティブにコンパイルでき、Springのライブラリを一部そのまま使えたり、そもそもSpringとあまり変わらない感覚でコードをサクサク書けそうなイメージなので本格的に使用してみたいと思っています。最大の問題はやはり、ネイティブの場合ビルドにかなり時間がかかるということですが、これはCIとの連携をうまくやっていくしかないかも知れませんね。&lt;/p>
&lt;h2 id="fastapi">FastAPI&lt;/h2>
&lt;p>いきなりPythonになりますが、&lt;a class="link" href="https://fastapi.tiangolo.com" target="_blank" rel="noopener"
>FastAPI&lt;/a>にも触れてみたいと思っています。以前から違う分野に転職をするとしてもバックエンドはやり続く可能性が高いと思い、いろいろな言語とフレームワークを触ってみたいと思っていました。その候補としては&lt;a class="link" href="https://expressjs.com/ja" target="_blank" rel="noopener"
>Express&lt;/a>、&lt;a class="link" href="https://rocket.rs" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://vapor.codes" target="_blank" rel="noopener"
>Vapor&lt;/a>などがあって、これらを全部触ってみた後、最も自分の好みに合ったものをプライベートで使い続けようと思っていたのです。&lt;/p>
&lt;p>そんな中、Pythonは普段もたまに簡単な自動化のスクリプトを作るなどの目的で使っているので、&lt;a class="link" href="https://www.djangoproject.com" target="_blank" rel="noopener"
>Django&lt;/a>を触ってみようかと思っていたところ、最近はFastAPIで爆速の開発ができるという話を聞いて興味を持つようになりました。今もKotlinとSpringで開発はできますが、シンプルなプロジェクトならこういった軽いオプションが一つあっても悪くなさそうな気がします。インタープリタ言語なので起動も早く、&lt;a class="link" href="https://www.techempower.com/benchmarks" target="_blank" rel="noopener"
>Techempowerのベンチマーク&lt;/a>でも意外と悪くないパフォーマンスを見せてくれているのも魅力的ですが、&lt;a class="link" href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener"
>Swagger&lt;/a>と&lt;a class="link" href="https://github.com/Redocly/redoc" target="_blank" rel="noopener"
>ReDoc&lt;/a>によるドキュメンテーションが自動で行われるというところがかなり良さげです。なんでもサクッと作れそうな感じがしますね。&lt;/p>
&lt;p>また、直接使わないとしてもコードが綺麗で勉強になる噂を聞いているので、少なくとも一度はコードを読んでみたくなります。&lt;/p>
&lt;h2 id="swiftui-and-jetpack-compose">SwiftUI and Jetpack Compose&lt;/h2>
&lt;p>個人的に本当にやりたかった分野は、GUIを持つアプリを作り上げることです。エンジニアという職業を持つ前から作ったのも&lt;a class="link" href="https://openjfx.io" target="_blank" rel="noopener"
>JavaFX&lt;/a>によるデスクトップアプリでしたので。最近はJavaScriptだけでも&lt;a class="link" href="https://www.electronjs.org" target="_blank" rel="noopener"
>Electron&lt;/a>や&lt;a class="link" href="https://reactnative.dev" target="_blank" rel="noopener"
>React Native&lt;/a>などを使ってなんでもできるという時代にはなっていますが、せっかくJavaとKotlinができるようになったので、ネイティブアプリを作ってみた方が良さそうな気がします。&lt;/p>
&lt;p>以前&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>が発表されてまもない時期に、一度React Nativeと一緒にチュートリアルだけ触れてみたことがあるのですが、当時にもFlutterのいわゆる「宣言型GUI」というものに魅力を感じていたのでこれからモバイルをやるとしたらFlutterかなと悩んでいました。最近はモバイルだけでなく、デスクトップアプリやウェブアプリまで作れるようになったのでなおさらでしたね。&lt;/p>
&lt;p>しかし、&lt;a class="link" href="https://developer.apple.com/xcode/swiftui" target="_blank" rel="noopener"
>SwiftUI&lt;/a>と&lt;a class="link" href="https://developer.android.com/jetpack/compose?hl=ja" target="_blank" rel="noopener"
>Jetpack Compose&lt;/a>というものが登場してからは完全にこちらに傾きました。どうしても同時にマルチプラットフォームアプリが開発できるという面ではFlutterが有利だとは思いますが、それと似たような感覚でネイティブのUIが作れられるようになったのでもう悩む必要がないかなという気がします。&lt;/p>
&lt;p>特に、SwiftUIだとMac用のデスクトップアプリを作ることもできますが、Jetpack Composeならデスクトップアプリだけでなくウェブアプリも作ることができて、さらに&lt;a class="link" href="https://kotlinlang.org/docs/kmm-getting-started.html" target="_blank" rel="noopener"
>Kotlin Multiplatform Mobile&lt;/a>を使うとビジネスロジックの共有ができるようになるのでこちらの方が自分の場合にはより合うのではないかという気がしています。自分に合うというのは、私がめんどくさがり屋なので一つの言語で全てを解決したいという願望を持っているというだけの話ですが…とにかく一度使ってみて、よかったらフロントエンドでもJetpack Composeを使ってみるのはありかなと思っています。&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>という選択肢もありますが、こちらはまた次の機会で。&lt;/p>
&lt;p>ただこれらのデメリットは、やはりどれもまだ完成されてない技術ということですね。分野を問わず新しい技術のジレンマでもありますが、新技術がどれだけ良くてもそれだけでは完全ではない（もしくはかなり不便）という場面が出てくる可能性があるので、当面は少し様子を見ながらシンプルなアプリを作ってみることから初めてみようと思います。Flutterという良い先例があるので、良さげな機能はすぐに吸収してくれるという期待もあります。&lt;/p>
&lt;h2 id="oracle-cloud">Oracle Cloud&lt;/h2>
&lt;p>他のクラウドと比べかなり後発したためか、無料プランでもメモリ1GBのVMインスタンスを二つも提供するという破格の政策で知られたOracle Clouですが、2021年からはさらに選べるVMインスタンスにARM（&lt;a class="link" href="https://www.oracle.com/jp/cloud/compute/arm" target="_blank" rel="noopener"
>Ampere A1&lt;/a>というオプションを追加しています。&lt;/p>
&lt;p>Ampereが既存のAMDやIntel製CPUを使うインスタンスと比べて目立つのはやはり性能です。ARMだと互換性の問題がありx86と比べ利用率が下がると思ったためか、無料プランでも4つのOCPU、24GBのメモリという良い性能のインスタンスを提供しています。無料のインスタンスを2つまで作ることができるので、2つのOCPUと12GBのメモリという構成を2つのインスタンスに分けて指定することもできます。&lt;/p>
&lt;p>個人的には既存の無料で使えるインスタンスが1つのOCPU、1GBのメモリというオプションだったので、Javaアプリのビルドなどヘビーな作業には向いてないのが惜しいところでした。なので&lt;a class="link" href="https://mattermost.com" target="_blank" rel="noopener"
>Mattermost&lt;/a>のサーバとして使うなど軽い感じでしか使い道がなかったのですが、Ampereの導入でCI用サーバなどに使える道もできたかなと思います。Oracle Cloudのホームページで紹介していること以外でも、他の&lt;a class="link" href="https://jiuyu.medium.com/oracle-cloud-ampere-a1-cpu-benchmarks-6464ef43593d" target="_blank" rel="noopener"
>ベンチマーク&lt;/a>を参照するとCPU性能は期待しても良さそうな気がします。無料でOracle DBも提供されているのでそちらを使うか、それともVMインスタンスを一つDB用に使うか、GCPやAWSの無料サービスと組み合わせて使うとかでも色々できそうな気がします。&lt;/p>
&lt;p>ただ、やはり互換性が気になっていたのですが、個人的にはApple Silicon搭載Macを使ってみながら「意外と悪くない」という結論に至っています。プログラミング言語などはすでにARM対応済みのものが多く、サーバで使うとしたら&lt;a class="link" href="https://www.ffmpeg.org" target="_blank" rel="noopener"
>FFmpeg&lt;/a>、&lt;a class="link" href="https://imagemagick.org/index.php" target="_blank" rel="noopener"
>ImageMagick&lt;/a>、&lt;a class="link" href="http://www.graphicsmagick.org" target="_blank" rel="noopener"
>GraphicsMagick&lt;/a>などを使うケースもあるかなと思いますが、どれもARMバージョンをインストールもしくはビルドできるので特に問題はなさそうです。&lt;/p>
&lt;p>他に問題なら、今の所VMインスタンスを作ろうとしてもハードウェアが十分ではないのか、2つのOCPU以上のスペックでは作れないというのが問題ですね。時間が解決してくれる問題かも知れませんが、いつになったらインスタンスを自由に作れるかわからないというのは確かに問題と言えるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>意欲がないといいつつ、これだけやってみたいものが多いというのはまだ自分がエンジニアとして気持ちが死んでいるわけではないからよかったなと思わせます。本当は意欲がないというより「面倒臭いだけ」と訂正するべきかもですね…&lt;/p>
&lt;p>というわけで、色々とやりたいことだけを並べてみましたが、今年はそろそろ何か実際使えるアプリを作り出すのを第一の目標にしたいと思っています。何か作ってみるだけでも間違いなく良い経験、良い経歴になるはずなので。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>色々な言語でやってみた（ソート編）</title><link>https://retheviper.github.io/posts/languages-comparsion-sorting/</link><pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/languages-comparsion-sorting/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.jpg" alt="Featured image of post 色々な言語でやってみた（ソート編）" />&lt;p>今はどんなプログラミング言語を選んでもできることはあまり違わなく、まさに好みで選んでもいいと思えるくらいの時代となっていると思います。特に、&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>のようなトランスパイラーやFlutterのようなフレームワークも続々と登場している時代なので、こういう傾向はこれからもどんどん加速していくのではないかと思います。&lt;/p>
&lt;p>しかしそのような変化がある一方で、今現在はプログラマに一人が扱えるプログラミング言語の数に対する要求も増えいている状況ではないかと思います。実際の業務ではさまざまな理由で使われる言語が決まっていて、自分が今まで触ったことのないものでも使えるようになる必要があり、一人のエンジニアが固定されたポジションでなく、さまざまな分野にかけて実装を行うケースもありますしね。いわゆる&lt;a class="link" href="https://en.wikipedia.org/wiki/Polyglot_%28computing%29" target="_blank" rel="noopener"
>Polyglot&lt;/a>の時代とも言えます。&lt;/p>
&lt;p>なので、少なくともいろいろな言語の特徴を把握しておくということが大事になっているのではないかと思います。そして、そのような必要によるものでなくても、自分が普段接してない言語のコンセプトに触れてみることで、メインとなる言語への理解が深まることもあるのではないのかなと思ったりもします。これはどんな言語でもできることはあまり変わらないということともある意味通じているのですが、他の言語のコンセプトを受け入れた新しいAPIや機能を導入したり、そのようなライブラリが登場する場合もあるので。&lt;/p>
&lt;p>さて、前置きが長くなりましたが、ということで、これからはたまにとある操作をするときにいろいろな言語ではどうやってできるのか、そしてそうした場合の特徴などを簡単に比べてみたいと思います。今回は、配列のソートになります。&lt;/p>
&lt;h2 id="javascript">JavaScript&lt;/h2>
&lt;p>JavaScriptでは&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener"
>Array.prototype.sort()&lt;/a>で配列のソートができます。なので、以下のようなコードを使えます。シンプルですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> a.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、元の配列の値は変更せず、新しくソートされた配列を作りたい場合は以下の方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> b &lt;span style="color:#ff79c6">=&lt;/span> [...a].sort() &lt;span style="color:#6272a4">// aをコピーしてソート
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> console.log(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここで気づいた方もいらっしゃると思いますが、ソートされた値が期待通りにはなっていません。本当なら、&lt;code>1, 22, 44, 300, 5000&lt;/code>になるのが普通でしょう。ここで昇順に値をソートしたい場合は、ソートの方法を自前で作成する必要があります。例えば以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> a.sort((a, b) =&amp;gt; a &lt;span style="color:#ff79c6">-&lt;/span> b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>sort()&lt;/code>では、引数として渡す&lt;code>compareFunction&lt;/code>（引数が二つ、戻り値はnumber）の戻り値の結果によって、以下のことが起こります。&lt;/p>
&lt;ul>
&lt;li>0より小さいと、aのインデックスをbの先に置く&lt;/li>
&lt;li>0だと、aとbは変更しない&lt;/li>
&lt;li>0より大きいと、bのインデックスをaの先に置く&lt;/li>
&lt;/ul>
&lt;p>これはJavaをやっていた方だと、&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener"
>Comparator&lt;/a>と同じだなとすぐわかる内容ですね。アロー関数の形もJavaのLambdaに似ているので、あまり違和感なく適応できるかと思います。かなりシンプルなのですが、number型の配列に対しては自前の&lt;code>compareFunction&lt;/code>が必要となるということは大事なので、気を付ける必要はあるでしょう。&lt;/p>
&lt;p>配列のインデックスを反転したい場合は、&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener"
>Array.prototype.reverse()&lt;/a>を使うだけで良いです。この場合はnumberの配列でも自前の&lt;code>compareFunction&lt;/code>が必要ないので、便利ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> a.reverse()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#bd93f9">5000&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="java">Java&lt;/h2>
&lt;p>では、次にJavaの方も見ていきましょう。先に述べた通り、&lt;code>Comparator&lt;/code>を使うと簡単にソートの方法を実装できるので、基本的には同じです。ただ、Javaの場合だとそもそも&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#sort-java.util.Comparator-" target="_blank" rel="noopener"
>List.sort()&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Collections.html#sort-java.util.List-" target="_blank" rel="noopener"
>Collections.sort()&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Arrays.html#sort-int:A-" target="_blank" rel="noopener"
>Arrays.sort()&lt;/a>、[Stream.sorted()]など方法が色々あり、ソートしたいCollectionやArrayなどが&lt;code>Immutable&lt;/code>であるかどうか、&lt;code>Comparator&lt;/code>や&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener"
>Comparable&lt;/a>を自前で実装するか、それともスタンダードライブラリに用意されてあるものを使うかなどのさまざまな選択肢も考慮する必要があるということですね。&lt;/p>
&lt;p>色々な選択肢がある中で、もっとも簡単なのは、&lt;code>Collections.sort()&lt;/code>や&lt;code>Arrays.sort()&lt;/code>を使う方法かなと思います。これを使う場合、primitive型やStringのListは短いコードでソートができるという（そして標準機能という）メリットがありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ArrayList&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;()&lt;/span> &lt;span style="color:#ff79c6">{{&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add &lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> &lt;span style="color:#ff79c6">}};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> Collections&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">sort&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、&lt;code>List.sort()&lt;/code>が簡単です。&lt;code>Comparator&lt;/code>を引数として渡す必要がありますが、昇順・降順でソートしたい場合は既に用意されてあるメソッドを呼び出すだけですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ArrayList&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;()&lt;/span> &lt;span style="color:#ff79c6">{{&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add &lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> &lt;span style="color:#ff79c6">}};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> a&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">sort&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Comparator&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">naturalOrder&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに&lt;code>Comparator&lt;/code>で使える既定のソート方法は以下があります。&lt;/p>
&lt;ul>
&lt;li>昇順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#naturalOrder--" target="_blank" rel="noopener"
>naturalOrder()&lt;/a>&lt;/li>
&lt;li>降順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#reverseOrder--" target="_blank" rel="noopener"
>reverseOrder()&lt;/a>&lt;/li>
&lt;li>逆順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#reversed--" target="_blank" rel="noopener"
>reversed()&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>また、&lt;code>Comparator&lt;/code>は、&lt;code>Collections.sort()&lt;/code>の引数としても使えます。なので、降順にソートしたい場合は以下のようなコードを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ArrayList&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;()&lt;/span> &lt;span style="color:#ff79c6">{{&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add &lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> add&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span> &lt;span style="color:#ff79c6">}};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> Collections&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">sort&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">,&lt;/span> Comparator&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">reverseOrder&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>a&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、元のListの値を変更せず、新しくソートされた結果を取得したい場合は、元のListをコピーする方法もありますが、もう一つの方法として&lt;code>Stream&lt;/code>を使う方法を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var b &lt;span style="color:#ff79c6">=&lt;/span> a&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">sorted&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Stream&lt;/code>でソートする場合でも、&lt;code>Comparator&lt;/code>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var a &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> var b &lt;span style="color:#ff79c6">=&lt;/span> a&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">sorted&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Comparator&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">reverseOrder&lt;/span>&lt;span style="color:#ff79c6">()).&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#ff79c6">==&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>&lt;span style="color:#bd93f9">5000&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">300&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">44&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">22&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、DTOのListをソートしたい場合は、DTOが&lt;code>Comparable&lt;/code>を継承するという方法も考えられますが、多くの場合はソート時の条件が明確にわかる&lt;code>Comparator&lt;/code>を実装したいいかなと思います。汎用性や柔軟性を考えても、&lt;code>Comparable&lt;/code>の場合、条件が変わるとクラスを修正する必要があるので、&lt;code>Comparator&lt;/code>を使った方が無難かなと思います。&lt;/p>
&lt;p>Arrayの場合、&lt;code>Arrays.sort()&lt;/code>を利用してソートできる（もちろん&lt;code>Comparator&lt;/code>も使えます）上に、ListやStreamに変換することもできるので上記の方法をそのまま使えます。なので選択肢はもっと多いわけですが、便利な（好みに合う）方法を選ぶといいかなと思います。個人的には&lt;code>Arrays.sort()&lt;/code>に&lt;code>Comparator&lt;/code>を渡した方が可読性という面で良さそうな気がします。&lt;/p>
&lt;h2 id="kotlin">Kotlin&lt;/h2>
&lt;p>Sytax Sugarをたくさん提供しているKotlinらしく、選べるソートのオプションがたくさんあります。なので、少しまとめてみました。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Orderの種類&lt;/th>
&lt;th>ソート結果&lt;/th>
&lt;th>fun&lt;/th>
&lt;th>備考&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Natural&lt;/td>
&lt;td>呼び出し元&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort.html" target="_blank" rel="noopener"
>Array/MutableList.sort()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-descending.html" target="_blank" rel="noopener"
>Array/MutableList.sortDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reverse.html" target="_blank" rel="noopener"
>Array/MutableList.reverse()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Array&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array.html" target="_blank" rel="noopener"
>Array.sortedArray()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array-descending.html" target="_blank" rel="noopener"
>Array.sortedArrayDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reversed-array.html" target="_blank" rel="noopener"
>Array.reveredArray()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted.html" target="_blank" rel="noopener"
>Array/List.sorted()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-descending.html" target="_blank" rel="noopener"
>Array/List.sortedDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/as-reversed.html" target="_blank" rel="noopener"
>List/MutableList.asRevered()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Custom&lt;/td>
&lt;td>呼び出し元&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-by.html" target="_blank" rel="noopener"
>Array/MutableList.sortBy()&lt;/a>&lt;/td>
&lt;td>昇順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-by-descending.html" target="_blank" rel="noopener"
>Array/MutableList.sortByDescending()&lt;/a>&lt;/td>
&lt;td>降順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by.html" target="_blank" rel="noopener"
>Array/Iterable.sortedBy()&lt;/a>&lt;/td>
&lt;td>昇順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by-descending.html" target="_blank" rel="noopener"
>Array/Iterable.sortedByDescending()&lt;/a>&lt;/td>
&lt;td>降順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Array&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array-with.html" target="_blank" rel="noopener"
>Array.sortedArrayWith()&lt;/a>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/" target="_blank" rel="noopener"
>Comparator&lt;/a>必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-with.html" target="_blank" rel="noopener"
>Array/Iterable.sortedWith()&lt;/a>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/" target="_blank" rel="noopener"
>Comparator&lt;/a>必要&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>かなり多い選択肢があるように見えますが、こうやって表としてまとめてみるとまぁまぁわかりそうな気はします。自前の比較処理を書く必要があるか、ソートした結果が元の配列かどうか、そしてArrayになるかListになるかなどいくつかの基準で分けられるということが分かれば大体どれを使った方がいいか悩む必要はないかなと思います。&lt;/p>
&lt;p>なので、まずやりたいことを明確にした上で、どのAPIを使うかを選んで書くだけです。以下はListから、ソートされた新しいListを作成する例です。それぞれ昇順と降順の場合となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> a = listOf(&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> b = a.sorted()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[1, 22, 44, 300, 5000]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> c = a.sortedDescending()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[5000, 300, 44, 22, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、data classの配列をソートしたい場合は&lt;code>sortBy&lt;/code>や&lt;code>sortedBy&lt;/code>を使えます。ここで引数に必要なのは&lt;code>(T) -&amp;gt; R&lt;/code>型のselectorですが、単純にどれを基準にソートするかを指定すれば良いだけですので実装は簡単です。以下の例を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Data&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> number: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> a = listOf(Data(&lt;span style="color:#bd93f9">22&lt;/span>), Data(&lt;span style="color:#bd93f9">1&lt;/span>), Data(&lt;span style="color:#bd93f9">44&lt;/span>), Data(&lt;span style="color:#bd93f9">300&lt;/span>), Data(&lt;span style="color:#bd93f9">5000&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> b = a.sortedBy { &lt;span style="color:#ff79c6">it&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[Data(number=1), Data(number=22), Data(number=44), Data(number=300), Data(number=5000)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> c = a.sortedByDescending { &lt;span style="color:#ff79c6">it&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[Data(number=5000), Data(number=300), Data(number=44), Data(number=22), Data(number=1)]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、より複雑な比較の条件を指定したい場合はJavaの場合と同じく、&lt;code>Comparator&lt;/code>を実装すると良いでしょう。やはりJavaと似ているようで、より単純化した（そしてそのせいで選択肢は増えた）感覚ですね。&lt;/p>
&lt;h2 id="swift">Swift&lt;/h2>
&lt;p>Swiftでは、シンプルに元のCollectionをソートするかソートされた新しいCollectionを作るかの選択肢しかないようです。あまり変わったことはないですが、元のCollectionをソートする場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">1&lt;/span>&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">a&lt;/span> = [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a: [&lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span>] = &lt;span style="color:#bd93f9">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">0&lt;/span>] = &lt;span style="color:#bd93f9">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">1&lt;/span>] = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">2&lt;/span>] = &lt;span style="color:#bd93f9">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">3&lt;/span>] = &lt;span style="color:#bd93f9">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">4&lt;/span>] = &lt;span style="color:#bd93f9">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">2&lt;/span>&amp;gt; a.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">3&lt;/span>&amp;gt; print(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして新しいCollectionを作成したい場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">1&lt;/span>&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">a&lt;/span> = [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a: [&lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span>] = &lt;span style="color:#bd93f9">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">0&lt;/span>] = &lt;span style="color:#bd93f9">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">1&lt;/span>] = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">2&lt;/span>] = &lt;span style="color:#bd93f9">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">3&lt;/span>] = &lt;span style="color:#bd93f9">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">4&lt;/span>] = &lt;span style="color:#bd93f9">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">2&lt;/span>&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">b&lt;/span> = a.sorted()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b: [&lt;span style="color:#8be9fd;font-style:italic">Int&lt;/span>] = &lt;span style="color:#bd93f9">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">0&lt;/span>] = &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">1&lt;/span>] = &lt;span style="color:#bd93f9">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">2&lt;/span>] = &lt;span style="color:#bd93f9">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">3&lt;/span>] = &lt;span style="color:#bd93f9">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#bd93f9">4&lt;/span>] = &lt;span style="color:#bd93f9">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">3&lt;/span>&amp;gt; print(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Swiftのソートが独特なのはどうやってソートするか、その方法を指定する時です。&lt;a class="link" href="https://developer.apple.com/documentation/swift/array/2296801-sort" target="_blank" rel="noopener"
>sort()&lt;/a>でも&lt;a class="link" href="https://developer.apple.com/documentation/swift/array/2296815-sorted" target="_blank" rel="noopener"
>sorted()&lt;/a>でも引数として&lt;code>areInIncreasingOrder&lt;/code>という関数を渡すことができるようになっていますが、JavaScriptやJava、Kotlinで使われていた&lt;code>compareFunction&lt;/code>や&lt;code>Comparator&lt;/code>の戻り値が数字であったことに対して、&lt;code>areInIncreasingOrder&lt;/code>はpredicate型として戻り値がBoolになっています。なので以下のような形でソートの方法を指定可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">students&lt;/span>: Set = [&lt;span style="color:#f1fa8c">&amp;#34;Kofi&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Abena&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Peter&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Kweku&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Akosua&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">descendingStudents&lt;/span> = students.sorted(by: &lt;span style="color:#ff79c6">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(descendingStudents) &lt;span style="color:#6272a4">// &amp;#34;[&amp;#34;Peter&amp;#34;, &amp;#34;Kweku&amp;#34;, &amp;#34;Kofi&amp;#34;, &amp;#34;Akosua&amp;#34;, &amp;#34;Abena&amp;#34;]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、classのフィールドを基準にソートしたい場合は以下の方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> &lt;span style="color:#50fa7b">Data&lt;/span> { &lt;span style="color:#8be9fd;font-style:italic">var&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">number&lt;/span> = &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">datas&lt;/span> = [Data(number: &lt;span style="color:#bd93f9">1&lt;/span>), Data(number: &lt;span style="color:#bd93f9">3&lt;/span>), Data(number: &lt;span style="color:#bd93f9">4&lt;/span>), Data(number: &lt;span style="color:#bd93f9">2&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">descending&lt;/span> = datas.sorted { &lt;span style="color:#8be9fd;font-style:italic">$0&lt;/span>.number &lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">$1&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dump(descending)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> descending: [Data] = 4 values {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> [0] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> number = 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> [1] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> number = 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> [2] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> number = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> [3] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> number = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="go">Go&lt;/h2>
&lt;p>Goにはジェネリックがないからか、&lt;a class="link" href="https://pkg.go.dev/sort" target="_blank" rel="noopener"
>sort&lt;/a>というパッケージに、sliceの種類によってソート用のfuncが色々と用意されています。例えば以下のようなものがあります。&lt;/p>
&lt;ul>
&lt;li>func Float64s(x []float64)&lt;/li>
&lt;li>func Ints(x []int)&lt;/li>
&lt;li>func Strings(x []string)&lt;/li>
&lt;/ul>
&lt;p>なので、structのsliceではい場合はこれらの中でどれかを選んでソートすることになりますね。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd">int&lt;/span>{&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort.&lt;span style="color:#50fa7b">Ints&lt;/span>(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(a) &lt;span style="color:#6272a4">// [1 22 44 300 5000]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>structの場合は、以下のような方法が使えます。ソートの基準がまた&lt;code>bool&lt;/code>になっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>people &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name &lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Age &lt;span style="color:#8be9fd">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Gopher&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">55&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Vera&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">24&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort.&lt;span style="color:#50fa7b">Slice&lt;/span>(people, &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i, j &lt;span style="color:#8be9fd">int&lt;/span>) &lt;span style="color:#8be9fd">bool&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> people[i].Name &amp;lt; people[j].Name })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(people) &lt;span style="color:#6272a4">// [{Alice 55} {Bob 75} {Gopher 7} {Vera 24}]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>面白いのは、Goのソートには&lt;a class="link" href="https://pkg.go.dev/sort#SliceStable" target="_blank" rel="noopener"
>sort.SliceStable()&lt;/a>というものが別に存在しているということです。これは&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%AE%89%E5%AE%9A%E3%82%BD%E3%83%BC%E3%83%88" target="_blank" rel="noopener"
>安定ソート&lt;/a>を行うもので、その定義に関してはWikiでは以下のように述べています。&lt;/p>
&lt;blockquote>
&lt;p>同等なデータのソート前の順序が、ソート後も保存されるものをいう。つまり、ソート途中の各状態において、常に順位の位置関係を保っていることをいう。&lt;/p>
&lt;/blockquote>
&lt;p>つまり、安定ソートの場合、ソートの基準となる値が同等の要素間の元の位置関係（インデックス）が保証されるということですね。その結果が実際どうなるのかを見てみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>people &lt;span style="color:#ff79c6">:=&lt;/span> []&lt;span style="color:#8be9fd;font-style:italic">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Name &lt;span style="color:#8be9fd">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Age &lt;span style="color:#8be9fd">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Elizabeth&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Colin&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#f1fa8c">&amp;#34;Elizabeth&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sort.&lt;span style="color:#50fa7b">SliceStable&lt;/span>(people, &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i, j &lt;span style="color:#8be9fd">int&lt;/span>) &lt;span style="color:#8be9fd">bool&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> people[i].Age &amp;lt; people[j].Age })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(people) &lt;span style="color:#6272a4">// [{Alice 25} {Bob 25} {Colin 25} {Elizabeth 25} {Alice 75} {Alice 75} {Bob 75} {Elizabeth 75}]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードの実行結果でわかるように、&lt;code>Alice 25&lt;/code>、&lt;code>Bob 25&lt;/code>、&lt;code>Colin 25&lt;/code>、&lt;code>Elizabeth 25&lt;/code>と&lt;code>Alice 75&lt;/code>, &lt;code>Bob 75&lt;/code>, &lt;code>Elizabeth 75&lt;/code>の元の順が維持されたままソートされたのがわかります。ここでもし&lt;code>sort.Slice()&lt;/code>を使うと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>sort.&lt;span style="color:#50fa7b">Slice&lt;/span>(people, &lt;span style="color:#8be9fd;font-style:italic">func&lt;/span>(i, j &lt;span style="color:#8be9fd">int&lt;/span>) &lt;span style="color:#8be9fd">bool&lt;/span> { &lt;span style="color:#ff79c6">return&lt;/span> people[i].Name &amp;lt; people[j].Name })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fmt.&lt;span style="color:#50fa7b">Println&lt;/span>(people) &lt;span style="color:#6272a4">// [{Alice 25} {Alice 75} {Alice 75} {Bob 75} {Bob 25} {Colin 25} {Elizabeth 75} {Elizabeth 25}]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安定ソートはそうでないソートに比べ性能が劣る可能性が高いので（元のインデックスをまで考慮しているので）、一つの値を基準にソートしても問題ない場合は&lt;code>sort.Slice()&lt;/code>でも十分な気がしますが、そうでない場合は安定ソートを考慮する必要がありそうですね。&lt;/p>
&lt;h2 id="python">Python&lt;/h2>
&lt;p>Pythonでは&lt;a class="link" href="https://docs.python.org/3/library/stdtypes.html#list.sort" target="_blank" rel="noopener"
>list.sort()&lt;/a>か、&lt;a class="link" href="https://docs.python.org/3/library/functions.html#sorted" target="_blank" rel="noopener"
>sorted()&lt;/a>を使えます。他の言語でも大体同じだったので命名だけでも推測が可能かと思いますが、前者は元のlistをソートするもので、後者は新しいlistを作り出すものです。&lt;/p>
&lt;p>まず&lt;code>list.sort()&lt;/code>は、以下のように使えます。他の言語とあまり変わらないですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a&lt;span style="color:#ff79c6">.&lt;/span>sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>それに対して、&lt;code>sorted()&lt;/code>は以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a &lt;span style="color:#ff79c6">=&lt;/span> [&lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> b &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">sorted&lt;/span>(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">print&lt;/span>(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">22&lt;/span>, &lt;span style="color:#bd93f9">44&lt;/span>, &lt;span style="color:#bd93f9">300&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、これらの関数では&lt;code>key&lt;/code>や&lt;code>reverse&lt;/code>のようなパラメータを指定することで、どれを基準にソートするか、逆順にソートするかなどを指定できます。Pythonらしいシンプルさですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">def&lt;/span> __init__(self, number):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#ff79c6">.&lt;/span>number &lt;span style="color:#ff79c6">=&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">def&lt;/span> __repr__(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">repr&lt;/span>((self&lt;span style="color:#ff79c6">.&lt;/span>number))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datas &lt;span style="color:#ff79c6">=&lt;/span> [Data(&lt;span style="color:#bd93f9">1&lt;/span>), Data(&lt;span style="color:#bd93f9">3&lt;/span>), Data(&lt;span style="color:#bd93f9">2&lt;/span>), Data(&lt;span style="color:#bd93f9">4&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datas&lt;span style="color:#ff79c6">.&lt;/span>sort(key&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">lambda&lt;/span> data: data&lt;span style="color:#ff79c6">.&lt;/span>number) &lt;span style="color:#6272a4"># [1, 2, 3, 4]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">sorted&lt;/span>(datas, key&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">lambda&lt;/span> data: data&lt;span style="color:#ff79c6">.&lt;/span>number, reverse&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#ff79c6">True&lt;/span>) &lt;span style="color:#6272a4"># [4, 3, 2, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="番外stable-sort">番外：Stable sort&lt;/h2>
&lt;p>Goのソート方法の中で少し安定ソートの話が出ましたが、ここで比較した他の言語だとGoのように安定ソートとそうでないソートのどれを使うかという選択肢がなかったので、それぞれの言語での安定ソートはどうやって扱われているのかを表にしてみました。以下をご覧ください。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>言語&lt;/th>
&lt;th>stable&lt;/th>
&lt;th>non-stable&lt;/th>
&lt;th>備考&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Go&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>funcによって選べられる&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Java&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>Streamはnon-stable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>JavaScript&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>ブラウザのバージョンによる&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Python&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kotlin&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>SequenceでもStable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Swift&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>&lt;code>stableを保証できない&lt;/code>と表現&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>多くの言語が安定ソートに対応していますが、少しづつ仕様が違う場合がありました。例えばJavaの場合、Streamによるソートは安定ソートではないため、安定ソートの結果を保証したい場合は既にソートされたCollectionを使うことをおすすめしています。Kotlinの場合はStreamに似たSequenceを使う場合でも、&lt;code>stateful&lt;/code>なためか、安定ソートに対応していました。&lt;/p>
&lt;p>また、JavaScriptの場合はブラウザのバージョンによって違いますが、最新のブラウザを使っている場合は大抵安定ソートに対応していました。ただ、JavaScirptを使った案件の場合はIEも対象ブラウザとして考慮される場合があるのですが、IEだと安定ソートに対応していないので確認が必要かなと思います。&lt;/p>
&lt;p>Swiftの場合はまだソート時のデフォルト値をstableにするかどうかを検討している中で、APIとしてもGoのようにstableとそうでないものを分離するかどうかを検討しているらしいです。またどのアルゴリズムを使うかについて議論しているらしく、しばらくは安定ソートを期待できないかと思います。&lt;/p>
&lt;p>KotlinとPythonはどの場合でも安定ソートとなるので、悩み事が一つ減るのが嬉しいですね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は色々な言語のソートについて調べてみましたが、いかがでしたか。一度ソートしたデータはその後の要素に対するアクセスが早くなるので、チューニングの観点からは必要なものかと思います。そしてこうやって色々な言語のソートのAPIを調べてみると、その言語の設計思想や発展の過程のようなものが少し見えるようで面白く、勉強にもなりますね。個人的にはあまり意識してなかった安定ソートがかなり勉強になりました。&lt;/p>
&lt;p>これからもこうやって色々な言語の使用やAPI、同じことをする場合の各言語による違いなどを比べてみたいと思います。時間と体力が十分であればの話ではありますが…！&lt;/p>
&lt;p>では、また！&lt;/p></description></item></channel></rss>