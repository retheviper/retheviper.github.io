<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='アプリを書いていると、DBに保存した形とは違う形でデータを読み込んだり出力するケースが多いです。代表的に、多くのバックエンドアプリで採用して'><title>data classのListをCSVにする</title>
<link rel=canonical href=https://retheviper.github.io/posts/kotlin-write-csv/><link rel=stylesheet href=/scss/style.min.abbd69b2908fdfcd5179898beaafd374514a86538d81639ddd2c58c06ae54e40.css><meta property='og:title' content='data classのListをCSVにする'><meta property='og:description' content='アプリを書いていると、DBに保存した形とは違う形でデータを読み込んだり出力するケースが多いです。代表的に、多くのバックエンドアプリで採用して'><meta property='og:url' content='https://retheviper.github.io/posts/kotlin-write-csv/'><meta property='og:site_name' content='Korean-man in Tokyo'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='kotlin'><meta property='article:tag' content='java'><meta property='article:tag' content='csv'><meta property='article:published_time' content='2022-08-27T00:00:00+00:00'><meta property='article:modified_time' content='2022-08-27T00:00:00+00:00'><meta property='og:image' content='https://retheviper.github.io/images/kotlin.jpg'><meta name=twitter:title content="data classのListをCSVにする"><meta name=twitter:description content="アプリを書いていると、DBに保存した形とは違う形でデータを読み込んだり出力するケースが多いです。代表的に、多くのバックエンドアプリで採用して"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://retheviper.github.io/images/kotlin.jpg'><link rel="shortcut icon" href=/favicon.ico><link rel=icon href=/favicon/favicon.ico><link rel=mask-icon href=safari-pinned-tab.svg color=black><link rel=manifest href=/favicon/manifest.json><script async src="https://www.googletagmanager.com/gtag/js?id=G-BYJBEJB6DX"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BYJBEJB6DX")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu768313a802c015f07dded3abd3d4245d_264018_300x0_resize_box_3.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>👋</span></figure><div class=site-meta><h1 class=site-name><a href=/>Korean-man in Tokyo</a></h1><h2 class=site-description>一人前になりたいです</h2></div></header><ol class=social-menu><li><a href=https://www.credly.com/users/youngbin-kim.6d7122f1/badges target=_blank title=Certificates rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-certificate" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="15" cy="15" r="3"/><path d="M13 17.5V22l2-1.5 2 1.5v-4.5"/><path d="M10 19H5a2 2 0 01-2-2V7c0-1.1.9-2 2-2h14a2 2 0 012 2v10a2 2 0 01-1 1.73"/><line x1="6" y1="9" x2="18" y2="9"/><line x1="6" y1="12" x2="9" y2="12"/><line x1="6" y1="15" x2="8" y2="15"/></svg></a></li><li><a href=https://github.com/retheviper target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/%E8%8B%B1%E6%96%8C-%E9%87%91-6736ba194/ target=_blank title=LinkedIn rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-linkedin" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="16" height="16" rx="2"/><line x1="8" y1="11" x2="8" y2="16"/><line x1="8" y1="8" x2="8" y2="8.01"/><line x1="12" y1="16" x2="12" y2="11"/><path d="M16 16v-3a2 2 0 00-4 0"/></svg></a></li><li><a href=https://retheviper.github.io/index.xml target=_blank title=RSS rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://retheviper.github.io/ selected></option></select></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#kotlinでcsvを扱う>KotlinでCSVを扱う</a><ol><li><a href=#data-classからヘッダを作る>data classからヘッダを作る</a><ol><li><a href=#アノテーションを使う場合>アノテーションを使う場合</a></li></ol></li><li><a href=#data-classをlistに変える>data classをListに変える</a></li></ol></li><li><a href=#最後に>最後に</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/kotlin-write-csv/><img src=/images/kotlin.jpg loading=lazy alt="Featured image of post data classのListをCSVにする"></a></div><div class=article-details><header class=article-category><a href=/categories/kotlin/ style=background-color:#2a9d8f;color:#fff>kotlin</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/kotlin-write-csv/>data classのListをCSVにする</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 27, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>10 minute read</time></div></footer></div></header><section class=article-content><p>アプリを書いていると、DBに保存した形とは違う形でデータを読み込んだり出力するケースが多いです。代表的に、多くのバックエンドアプリで採用しているREST APIがそうですね。APIの入力値と戻り値は、DBに保存されている形とは一致しないケースが多く、必要(リクエストを送信してきた側の都合)に合わせて適切にパラメータを受け取り、レスポンスを返すようになっています。そして時と場合によっては、人間が楽に読める形としてデータをまとめる必要もあります。そういった場合はExcelファイルやCSV、PDFといったいろいろなものを想定できますね。</p><p>今回のポストも場合も人が読める形のファイルとして、特にCSVを扱う場合にKotlin側の実装をどうやっていくかに関するものです。</p><h2 id=kotlinでcsvを扱う>KotlinでCSVを扱う</h2><p>KotlinのCSV読み込み/書き込みのライブラリとして<a class=link href=https://github.com/doyaaaaaken/kotlin-csv/ target=_blank rel=noopener>kotlin-csv</a>があり、JVMだけでなくKoltin/JSの場合でもこのライブラリを使って簡単にCSVを扱えます。更に<a class=link href=https://github.com/blackmo18/kotlin-grass target=_blank rel=noopener>kotlin-grass</a>というライブラリもあり、<code>kotlin-csv</code>との組み合わせででCSVのデータを簡単にdata classのListとしてまとめることもできますね。読み込みの際に指定できるデータのフォーマットやカスタムマッピングオプションなどの機能も豊富にあり、かなり使いやすく良いライブラリとなっています。</p><p>しかし、実は<code>kotlin-csv</code>を使うときに問題が一つあります。先に述べた通りCSVにデータの出力そのものは可能なものとなっているのですが、読み込みの時にdata classへのマッピングには別のライブラリが必要であったように、data classのリストを書き込むには追加の処理が必要となります。これは、kotlin-csvの書き込み用のメソッドが以下のようになっているからです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>writeAll</span>(rows: List&lt;List&lt;Any?&gt;&gt;, targetFile: File, append: Boolean = <span style=color:#66d9ef>false</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>open</span>(targetFile, append) { writeRows(rows) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ここで<code>rows</code>が書き込みで使うデータとなりますが、型が<code>List&lt;List&lt;Any?>></code>になっているので、列のデータを一つの行としてListに定義し、それをさらにListに格納することでCSVのデータ全体を定義する必要があります。これはつまり、data classのリストを書き込むためには、フィールド一つ一つを列として定義し、それらをListとしてまとめる必要があるということです。また、CSVには一般的にヘッダが含まれますが、<code>List&lt;List&lt;Any?>></code>の形だと最初の行にヘッダのみを定義した行は必要となることでもありますね。</p><p>一見複雑に見えますが、<a class=link href=https://kotlinlang.org/docs/reflection.html target=_blank rel=noopener>reflection</a>を利用すると、data classのフィールド名とその値を得ることができますので、それを利用してdata classのListをこのメソッドに適した形に変えられます。これをヘッダを作る方法と、data classの値を行に変更する二つの段階で分けて説明していきます。</p><h3 id=data-classからヘッダを作る>data classからヘッダを作る</h3><p>まずはヘッダを作ります。ヘッダを作るには、data classからフィールドを取得し、そのフィールドの名前のみを取得するといいでしょう。<code>id</code>というフィールドがあるとしたら、ヘッダもそのまま<code>id</code>になるということです。フィールド名とは別の名前をつけたい場合はアノテーションを活用する方法を考えられますが、まずはフィールド名をそのまま使う方法から述べたいと思います。</p><p>Kotlinのdata classから、フィールドを取得する方法が3つがあります。まずは、<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/members.html target=_blank rel=noopener>KClass.members</a>があります。ただ、これだとメソッドを含め、全てのメンバーを持ってくることになります。以下のようにですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Data</span>(<span style=color:#66d9ef>val</span> id: Int, <span style=color:#66d9ef>val</span> name: String)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> members = Data<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.members
</span></span><span style=display:flex><span>println(members)
</span></span><span style=display:flex><span><span style=color:#75715e>// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String, fun Line_2.Data.component1(): kotlin.Int, fun Line_2.Data.component2(): kotlin.String, fun Line_2.Data.copy(kotlin.Int, kotlin.String): Line_2.Data, fun Line_2.Data.equals(kotlin.Any?): kotlin.Boolean, fun Line_2.Data.hashCode(): kotlin.Int, fun Line_2.Data.toString(): kotlin.String]
</span></span></span></code></pre></div><p>フィールド名が現れているのでこれも使える方法の一つではありますが、やはりdata classだと基本的に<code>equals()</code>, <code>hashCode()</code>, <code>copy()</code>, <code>toString()</code>, <code>componentN()</code>のようなメソッドが
できてしまうので、これらをフィルタする必要があります。例えば、以下のようにですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> memberProperties = Data<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.members.filterNot { <span style=color:#66d9ef>it</span>.name.contains(<span style=color:#e6db74>&#34;component&#34;</span>) <span style=color:#f92672>||</span> <span style=color:#66d9ef>it</span>.name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;copy&#34;</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>it</span>.name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;equals&#34;</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>it</span>.name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;hashCode&#34;</span> <span style=color:#f92672>||</span> <span style=color:#66d9ef>it</span>.name <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;toString&#34;</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(memberProperties)
</span></span><span style=display:flex><span><span style=color:#75715e>// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String]
</span></span></span></code></pre></div><p>しかし、フィルタをしなくてももっと簡単にフィールドのみを抽出できる方法もあります。<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/member-properties.html target=_blank rel=noopener>memberProperties</a>を使うことです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> memberProperties = Data<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.memberProperties
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(memberProperties)
</span></span><span style=display:flex><span><span style=color:#75715e>// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String]
</span></span></span></code></pre></div><p>ただ、この方法にも問題はあります。取得したフィールドの順番が、data classに定義した通りにならなく、アルファベット順になるということです。以下の例を見ると、nameとageの順で定義したフィールドが、ageとnameの順になっているのがわかります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>(<span style=color:#66d9ef>val</span> name: String, <span style=color:#66d9ef>val</span> age: Int)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> memberProperties = Person<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.memberProperties
</span></span><span style=display:flex><span>println(memberProperties) <span style=color:#75715e>// name, age順にならない
</span></span></span><span style=display:flex><span><span style=color:#75715e>// [val Line_11.Person.age: kotlin.Int, val Line_11.Person.name: kotlin.String]
</span></span></span></code></pre></div><p>ここでどうしてもフィールドを定義した順に取得したい場合、data classのコンストラクタを使う方法があります。まずはコンストラクタを使った方法ですが、これはdata classに、自動的にコンストラクタがフィールドを定義した順番通りのパラメータを持つように生成されるということを利用した方法です。以下のようになります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> parameters = Person<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.primaryConstructor<span style=color:#f92672>!!</span>.parameters.mapNotNull { <span style=color:#66d9ef>it</span>.name }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(parameters) <span style=color:#75715e>// [name, age]
</span></span></span></code></pre></div><p>多少強引な方法ではありますが、これでフィールドとして使うフィールド名は取得できました。では、次にアノテーションを使う場合を見ていきましょう。</p><h4 id=アノテーションを使う場合>アノテーションを使う場合</h4><p>フィールド名をそのままヘッダとして利用したくない場合は、アノテーションを活用できます。フィールドとしてStringを持つアノテーションを定義して、ヘッダを読み取るときにそのフィールドにつけたアノテーションを取得するという方法です。例えば、以下のようなアノテーションを定義したとしましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Target</span>(<span style=color:#a6e22e>AnnotationTarget</span>.PROPERTY)
</span></span><span style=display:flex><span><span style=color:#66d9ef>annotation</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CsvHeaderName</span>(<span style=color:#66d9ef>val</span> value: String)
</span></span></code></pre></div><p>アノテーションは、以下のようにdata classで使います。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@CsvHeaderName</span>(<span style=color:#e6db74>&#34;名前&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> name: String,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@CsvHeaderName</span>(<span style=color:#e6db74>&#34;年齢&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> age: Int
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>そしてこのdata classのアノテーションを取得していきます。<code>memberProperties</code>でフィールドを取得した場合、そのフィールドからアノテーションの一覧(アノテーションは複数存在できるので)を取得し、そこから先に定義した<code>CsvHeaderName</code>のみをフィルタします。あとはアノテーションがあるかどうかをみて、どちらの値を使うかを決めればいいですね。以下のコードが、そのサンプルです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> datas = listOf(Person(<span style=color:#e6db74>&#34;John&#34;</span>, <span style=color:#ae81ff>20</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> headers = datas.first()<span style=color:#f92672>!!::</span><span style=color:#66d9ef>class</span>.memberProperties.map { <span style=color:#66d9ef>property</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>val</span> name = <span style=color:#66d9ef>property</span>.annotations.filterIsInstance&lt;CsvHeaderName&gt;().firstOrNull() <span style=color:#75715e>// アノテーションはないケースもある
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            name<span style=color:#f92672>?.</span><span style=color:#66d9ef>value</span> <span style=color:#f92672>?:</span> <span style=color:#66d9ef>property</span>.name <span style=color:#75715e>// アノテーションがnullの場合は、フィールド名を使う
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(headers) <span style=color:#75715e>// [年齢, 名前]
</span></span></span></code></pre></div><p><code>primaryConstructor</code>のパラメータで取得した場合でも、やり方は大きく変わりません。この場合は、コンストラクタのパラメータを基準にループしながら一致するフィールドを探すという処理が追加されるだけです。例えば以下のようにです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> fieldNames = seeds.first()<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.primaryConstructor<span style=color:#f92672>!!</span>.parameters.mapNotNull { <span style=color:#66d9ef>it</span>.name }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> headers = fieldNames.mapNotNull { name <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// パラメータと一致するフィールドを対象に処理を行う
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    datas.first()<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.memberProperties.find { <span style=color:#66d9ef>it</span>.name <span style=color:#f92672>==</span> name }<span style=color:#f92672>?.</span>let { <span style=color:#66d9ef>property</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> headerName = <span style=color:#66d9ef>property</span>.annotations.filterIsInstance&lt;CsvHeaderName&gt;().firstOrNull()
</span></span><span style=display:flex><span>        headerName<span style=color:#f92672>?.</span><span style=color:#66d9ef>value</span> <span style=color:#f92672>?:</span> <span style=color:#66d9ef>property</span>.name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>これで、ヘッダのデータはできました。次は、このヘッダに合わせて下に出力する行としてdata classをListに変換するのみですね。</p><h3 id=data-classをlistに変える>data classをListに変える</h3><p>ヘッダの処理で既にやっていたように、data classをListに変換する場合でも処理は大きく変わりません。違う点は、フィールドから実際のデータを取得するだけですね。ここでは、コンストラクタからパラメータを取得した場合を想定してコードを書きましょう。</p><p>Kotlinのreflectionでフィールドの値を取得する場合はJavaと変わらなくて、取得したフィールドにdata classのインスタンスを渡すだけとなります。ただ、フィールドがnullの場合は考慮する必要があります。nullになってしまうと、その列自体がスキップされ、最終的に出力されたCSVのデータで列がずれる場合があるからです。なので、空白のStringを指定するなどで、行ごとの長さ(Listのサイズ)を合わせる必要があります。以下のようにですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>datas.map { d <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    fieldNames.mapNotNull { name <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        d<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.memberProperties.find { <span style=color:#66d9ef>it</span>.name <span style=color:#f92672>==</span> name }<span style=color:#f92672>?.</span>let { <span style=color:#66d9ef>field</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>field</span>.call(d) <span style=color:#f92672>?:</span> <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e>// フィールドの値を取得し、nullのばいは空白にする
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            } 
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>ただ、ここで時間や日付を扱う場合、フォーマッタを利用したいケースがあるかと思います。例えば、アプリの中では<code>LocalTime</code>として扱っているが、CSVとしては<code>HH:mm</code>のような形で出力したい場合や、<code>LocalDate</code>を<code>yy/MM/dd</code>にしたい場合などですね。ここでフォーマット自体は、<a class=link href=https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/DateTimeFormatter.html target=_blank rel=noopener>DateTimeFormatter</a>を使うだけですが、問題は取得したフィールドがどの型であるかの判定です。</p><p>Kotlinのreflectionで取得したフィールドは、<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property1/ target=_blank rel=noopener>KProperty1</a>という型になっています。ここでどうやって元の型を取得するかが問題ですね。このクラスは<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-callable/ target=_blank rel=noopener>KCallable</a>というインタフェースを実装していて、ここには<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-callable/return-type.html target=_blank rel=noopener>returnType</a>というプロパティがあります。これで<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-type/ target=_blank rel=noopener>KType</a>というインタフェースが取得できるようになるので、これを持って判定をおこ泣くことになります。</p><p>しかし、名前から分かるように、<code>KType</code>はKotlinの型に関するインタフェースとなっています。比較したい<code>LocalDate</code>や<code>LocalTime</code>などのクラスはJavaのものなので、直接的な比較ができないですね。幸い、JavaのクラスでもKotlinで参照できる<code>Ktype</code>として変換することはできます。以下のようにです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> localDateKType: KType = LocalDate<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType()
</span></span></code></pre></div><p>なので、あとは分岐によって適切なフォーマッタを使うだけですね。以下のようにです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>datas.map { d <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        fieldNames.mapNotNull { name <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            d<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.memberProperties.find { <span style=color:#66d9ef>it</span>.name <span style=color:#f92672>==</span> name }<span style=color:#f92672>?.</span>let { <span style=color:#66d9ef>field</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>field</span>.call(d)<span style=color:#f92672>?.</span>let {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>when</span> (<span style=color:#66d9ef>field</span>.returnType) { <span style=color:#75715e>// タイプによる分岐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        LocalDate<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType() <span style=color:#f92672>-&gt;</span> dateFormatter.format(<span style=color:#66d9ef>it</span> <span style=color:#66d9ef>as</span> LocalDate)
</span></span><span style=display:flex><span>                        LocalTime<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType() <span style=color:#f92672>-&gt;</span> timeFormatter.format(<span style=color:#66d9ef>it</span> <span style=color:#66d9ef>as</span> LocalTime)
</span></span><span style=display:flex><span>                        LocalDateTime<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType() <span style=color:#f92672>-&gt;</span> dateTimeFormatter.format(<span style=color:#66d9ef>it</span> <span style=color:#66d9ef>as</span> LocalDateTime)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>it</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#f92672>?:</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>ただ、ここでもう一つ注意しなければならないのは、nullableなフィールドのKTypeは別のものになるということです。つまり、上記のコードでは、以下のようなdata classのフィールドは分岐処理でフォーマッタが働かなくなるということです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// どのフィールドもフォーマットされない
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DateTimes</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> date: LocalDate?,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> time: LocalTime?,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> dateTime: LocalDateTime?
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>この場合は、<code>KType</code>を作るときにnullableであることを指定することで簡単に解決できます。あとは分岐で、両方チェックするようにするだけです。以下のようにですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>datas.map { d <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        fieldNames.mapNotNull { name <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            d<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.memberProperties.find { <span style=color:#66d9ef>it</span>.name <span style=color:#f92672>==</span> name }<span style=color:#f92672>?.</span>let { <span style=color:#66d9ef>field</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>field</span>.call(d)<span style=color:#f92672>?.</span>let {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>when</span> (<span style=color:#66d9ef>field</span>.returnType) { <span style=color:#75715e>// nullableでもnullableではない場合でも分岐でフォーマットする
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        LocalDate<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType(), LocalDate<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType(nullable = <span style=color:#66d9ef>true</span>) <span style=color:#f92672>-&gt;</span> dateFormatter.format(<span style=color:#66d9ef>it</span> <span style=color:#66d9ef>as</span> LocalDate)
</span></span><span style=display:flex><span>                        LocalTime<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType(), LocalTime<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType(nullable = <span style=color:#66d9ef>true</span>) <span style=color:#f92672>-&gt;</span> timeFormatter.format(<span style=color:#66d9ef>it</span> <span style=color:#66d9ef>as</span> LocalTime)
</span></span><span style=display:flex><span>                        LocalDateTime<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType(), LocalDateTime<span style=color:#f92672>::</span><span style=color:#66d9ef>class</span>.createType(nullable = <span style=color:#66d9ef>true</span>) <span style=color:#f92672>-&gt;</span> dateTimeFormatter.format(<span style=color:#66d9ef>it</span> <span style=color:#66d9ef>as</span> LocalDateTime)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>else</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>it</span>
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#f92672>?:</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>あとは、ヘッダと、data classから取得した値のリストを結合して<code>kotlin-csv</code>の<code>writeAll()</code>に渡すだけですね。一つ、値は上記のコードで既に<code>List&lt;List&lt;Any>></code>の形となっていますが、ヘッダは<code>List&lt;String></code>なので、ヘッダは更にListに入れる必要があります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// ヘッダ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>val</span> header = <span style=color:#75715e>// 省略
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 実際のデータ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>val</span> rows = datas.map { <span style=color:#75715e>/** 省略 */</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>csvWriter().writeAll(
</span></span><span style=display:flex><span>            rows = listOf(headers) + rows,
</span></span><span style=display:flex><span>            targetFile = targetFile
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>これでヘッダが先に行に書き込まれ、次の行からはdata classのフィールドに格納した実際の値が出力されることになりました。</p><h2 id=最後に>最後に</h2><p>この度軽く「KotlinなんだからKotlin制のライブラリを使おう」と、軽い気持ちで採用したライブラリが想定していたものと違ったので困っていましたが、幸いJavaを使っていた時に<a class=link href=https://poi.apache.org/ target=_blank rel=noopener>Apache POI</a>を使って似たような機能をするライブラリを作ってみた経験があったのでその知識を活かせたと言えます。当時はまだ駆け出しのエンジニア(今もそうと思っていますが)だったので大変苦労した思い出でもありますが、今はその経験があってこそ対処できたようなものなので大変ありがたい経験だったなと思いました。</p><p>上記のコードに対してはちょっとしたライブラリを作ってみたので、またどこかで活用してみたいものですね。色々と改善して、のちにMaven Repositoryのようなところでも公開できるようになったらなと思います。</p><p>では、また！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/kotlin/>Kotlin</a>
<a href=/tags/java/>Java</a>
<a href=/tags/csv/>Csv</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/posts/kotlin-how-to-kotlin-like/><div class=article-image><img src=/images/kotlin.jpg loading=lazy data-key data-hash=/images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinはどう書いたらいいか</h2></div></a></article><article class=has-image><a href=/posts/kotlin-prospect/><div class=article-image><img src=/images/kotlin.jpg loading=lazy data-key data-hash=/images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinのこれからを語る</h2></div></a></article><article class=has-image><a href=/posts/effective-kotlin/><div class=article-image><img src=/images/kotlin.jpg loading=lazy data-key data-hash=/images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Effective Kotlinを読む</h2></div></a></article><article class=has-image><a href=/posts/kotlin-japanese-era/><div class=article-image><img src=/images/kotlin.jpg loading=lazy data-key data-hash=/images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinで和暦を使う</h2></div></a></article><article class=has-image><a href=/posts/kotlin-hidden-cost-3/><div class=article-image><img src=/images/kotlin.jpg loading=lazy data-key data-hash=/images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinの隠されたコストーその３</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2024 Korean-man in Tokyo</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.20.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>