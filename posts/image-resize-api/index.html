<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='この度は、動的画像リサイズのAPIを作りましたのでその紹介です。ここでおいう動的画像リサイズAPIとは、元の画像のURLとリサイズしたいサイズを指定すると、そのサイズにリサイズした画像を返すAPIです。
'><title>動的画像リサイズAPIを作る</title>
<link rel=canonical href=https://retheviper.github.io/posts/image-resize-api/><link rel=stylesheet href=/scss/style.min.abbd69b2908fdfcd5179898beaafd374514a86538d81639ddd2c58c06ae54e40.css><meta property='og:title' content='動的画像リサイズAPIを作る'><meta property='og:description' content='この度は、動的画像リサイズのAPIを作りましたのでその紹介です。ここでおいう動的画像リサイズAPIとは、元の画像のURLとリサイズしたいサイズを指定すると、そのサイズにリサイズした画像を返すAPIです。
'><meta property='og:url' content='https://retheviper.github.io/posts/image-resize-api/'><meta property='og:site_name' content='Korean-man in Tokyo'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:tag' content='ktor'><meta property='article:tag' content='kotlin'><meta property='article:tag' content='scrimage'><meta property='article:tag' content='rust'><meta property='article:published_time' content='2024-03-30T00:00:00+00:00'><meta property='article:modified_time' content='2024-03-30T00:00:00+00:00'><meta property='og:image' content='https://retheviper.github.io/images/ktor.webp'><meta name=twitter:title content="動的画像リサイズAPIを作る"><meta name=twitter:description content="この度は、動的画像リサイズのAPIを作りましたのでその紹介です。ここでおいう動的画像リサイズAPIとは、元の画像のURLとリサイズしたいサイズを指定すると、そのサイズにリサイズした画像を返すAPIです。
"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://retheviper.github.io/images/ktor.webp'><link rel="shortcut icon" href=/favicon.ico><link rel=icon href=/favicon/favicon.ico><link rel=mask-icon href=safari-pinned-tab.svg color=black><link rel=manifest href=/favicon/manifest.json><script async src="https://www.googletagmanager.com/gtag/js?id=G-BYJBEJB6DX"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BYJBEJB6DX")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu5847319893060935988.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>👋</span></figure><div class=site-meta><h1 class=site-name><a href=/>Korean-man in Tokyo</a></h1><h2 class=site-description>一人前になりたいです</h2></div></header><ol class=social-menu><li><a href=https://www.credly.com/users/youngbin-kim.6d7122f1/badges target=_blank title=Certificates rel=me><svg class="icon icon-tabler icon-tabler-certificate" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="15" cy="15" r="3"/><path d="M13 17.5V22l2-1.5 2 1.5v-4.5"/><path d="M10 19H5a2 2 0 01-2-2V7c0-1.1.9-2 2-2h14a2 2 0 012 2v10a2 2 0 01-1 1.73"/><line x1="6" y1="9" x2="18" y2="9"/><line x1="6" y1="12" x2="9" y2="12"/><line x1="6" y1="15" x2="8" y2="15"/></svg></a></li><li><a href=https://github.com/retheviper target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/%E8%8B%B1%E6%96%8C-%E9%87%91-6736ba194/ target=_blank title=LinkedIn rel=me><svg class="icon icon-tabler icon-tabler-brand-linkedin" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="4" y="4" width="16" height="16" rx="2"/><line x1="8" y1="11" x2="8" y2="16"/><line x1="8" y1="8" x2="8" y2="8.01"/><line x1="12" y1="16" x2="12" y2="11"/><path d="M16 16v-3a2 2 0 00-4 0"/></svg></a></li><li><a href=https://retheviper.github.io/index.xml target=_blank title=RSS rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><div class=menu-bottom-section><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://retheviper.github.io/ selected></option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></div></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#目的>目的</a></li><li><a href=#設計技術選定>設計・技術選定</a></li><li><a href=#リサイズ処理>リサイズ処理</a><ol><li><a href=#画像の形式判定>画像の形式判定</a></li><li><a href=#png-jpegの処理>PNG, JPEGの処理</a></li><li><a href=#webpの場合>WEBPの場合</a></li><li><a href=#gifの場合>GIFの場合</a></li></ol></li><li><a href=#処理を共通化する>処理を共通化する</a><ol><li><a href=#共通interfaceを作る>共通Interfaceを作る</a></li><li><a href=#画像取得の共通化>画像取得の共通化</a></li><li><a href=#リサイズ処理の共通化>リサイズ処理の共通化</a></li><li><a href=#画像のエンコード処理の共通化>画像のエンコード処理の共通化</a></li></ol></li><li><a href=#最後に>最後に</a></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/image-resize-api/><img src=/images/ktor.webp loading=lazy alt="Featured image of post 動的画像リサイズAPIを作る"></a></div><div class=article-details><header class=article-category><a href=/categories/ktor/ style=background-color:#2a9d8f;color:#fff>ktor</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/image-resize-api/>動的画像リサイズAPIを作る</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 30, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>11 minute read</time></div></footer></div></header><section class=article-content><p>この度は、動的画像リサイズのAPIを作りましたのでその紹介です。ここでおいう動的画像リサイズAPIとは、元の画像のURLとリサイズしたいサイズを指定すると、そのサイズにリサイズした画像を返すAPIです。</p><h2 id=目的>目的</h2><p>そもそも動的画像リサイズAPIを作る理由はなにか。それから説明しないとですね。今までは画像の配信において、エンドユーザが画像をアップロードする場合、あらかじめサムネイルの画像も作成してアップロードするようにしていました。</p><p>ただ、その方法だと全ての画面比と解像度に対応したサムネイルを作れないという問題があります。そのため代案として、フロントエンドから画面に最適化したサイズを指定して、APIからリサイズした画像を取得するようにしたいというのが目的です。</p><h2 id=設計技術選定>設計・技術選定</h2><p>APIはマイクロサービスとして、なるべくシンプルに作ることにしました。Getのエンドポイントを一つ持っていて、そこにクエリパラメータで元の画像のURLとリサイズしたいサイズを指定すると、リサイズした画像を返すというものです。フロントエンドではそのままimgタグに使えるようにしたいので、返すのは画像のデータそのまま（ヘッダーには<code>Content-type</code>を指定）にします。また、リサイズだけでなく、画像の形式を変換することもできるようにします。</p><p>また、APIは<a class=link href="https://cloud.google.com/run?hl=ja" target=_blank rel=noopener>Cloud Run</a>上で動かすことにしました。既存のAPIもそうなので使い方を合わせるためでもあり、ローカルでの開発でもdocekr composeを使って楽に開発できるためです。他にもコンテンツの配信には<a class=link href="https://cloud.google.com/storage?hl=ja" target=_blank rel=noopener>Cloud Storage</a>を使っているので、それとの連携もしやすいためです。そして最終的に処理された画像は、Cloud CDNに保存され、2回目以降の呼び出しではキャッシュを返すようにします。</p><p>会社ではすでにウェブフレームワークとしてKtorを採用しているので、それと揃えるためにこちらもKtorを採用。Ktorの以前ににNode.jsとRustによる実装を試みたことがありますが、前者は性能の問題から、後者はメンテが難しくなる問題から（社内にRustができる人が少ないので）採用しない方になっています。当時作成していたRustバージョンに近いサンプルコードはGitHubにて公開していますので、<a class=link href=https://github.com/retheviper/resize-api target=_blank rel=noopener>こちら</a>から確認できます。</p><p>画像の変換とリサイズのためには<a class=link href=https://github.com/sksamuel/scrimage target=_blank rel=noopener>Scrimage</a>を採用することにしました。他の候補としてはJavaの<a class=link href=https://docs.oracle.com/javase/jp/8/docs/api/javax/imageio/ImageIO.html target=_blank rel=noopener>ImageIO</a>なども検討しました。ただ、リサイズ対象の画像のフォーマットと、返すデータのフォーマットとしてWebPを処理する必要があったのですがそれに対応していないものが多かったです。</p><p>他に考えたものとしては、<a class=link href=http://www.graphicsmagick.org/ target=_blank rel=noopener>GraphicsMagick</a>のように画像の変換やリサイズを行うツールを使う方法もあります。こちらの場合はJavaから取得したデータを一度ファイルに書き出して、それをコマンドラインで実行するという方法になりますので、その分のI/Oコストがかかるため今回はScrimageを使うことにしました。</p><h2 id=リサイズ処理>リサイズ処理</h2><p>では、実際のAPIを書いていきます。Ktorは使い慣れているのもあり、今回はKtorでのAPI構築というよりはScrimageを使った画像のリサイズ処理が重要なので、その部分に焦点を当てていきます。</p><p>API全体で処理のフローは大まかに以下の通りです。</p><ol><li>クエリパラメータからurlとリサイズ後の大きさを取得</li><li>画像の取得</li><li>画像のリサイズ</li><li>画像の形式変換</li></ol><p>ここでScrimageを使った画像の処理は3〜4の部分ですが、実際のリサイズを行う前に取得した画像の形式をまず判定したり、画像のサイズを確認する必要もあります。理由としては処理の効率化のためですね。</p><p>今回はPNG, JPEG, WEBP, GIFの4つの形式に対して、リサイズ後にWEBPに変換するという処理を行うことにしています。ここで元の画像がWEBPだった場合、あえてWEBPに変換する必要はないです。また、リサイズが必要ない場合もあります。そのため、まずは画像の形式を判定して、リサイズが必要な場合のみリサイズ処理を行うようにします。</p><h3 id=画像の形式判定>画像の形式判定</h3><p>URLもしくはローカルストレージ（今回はCloud RunにCloud Storageをマウントする形で使っている）から画像を取得する際、その画像の形式を判定する必要があります。Scrimageでは画像の形式を判定するための<a class=link href=https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/format/FormatDetector.java target=_blank rel=noopener>FormatDetector</a>というクラスを提供しています。</p><p>使い方は簡単で、以下のように読み込んだ画像のデータをByteの配列で渡すだけです。API上では想定してないフォーマットが来た場合はエラーを返すようにしていて、ここで返す<a class=link href=https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/format/Format.java target=_blank rel=noopener>Format</a>はPNG, GIF, JPEG, WEBPでありScrimageのものをそのまま使っています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>detectImageFormat</span>(<span style=color:#66d9ef>data</span>: ByteArray): Format {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>FormatDetector</span>.detect(<span style=color:#66d9ef>data</span>).orElseThrow { IllegalArgumentException(<span style=color:#e6db74>&#34;Unsupported format&#34;</span>) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=png-jpegの処理>PNG, JPEGの処理</h3><p>まず一番簡単なPNG, JPEGの場合です。これらの形式の場合、Scrimageの<a class=link href=https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/ImmutableImage.java target=_blank rel=noopener>ImmutableImage</a>として扱うことになります。</p><p>ここで画像のデータをImmutableImageに変換するには<a class=link href=https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/nio/ImageReader.java target=_blank rel=noopener>ImageReader</a>のインタフェースを実装したクラスを使います。<a class=link href=https://sksamuel.github.io/scrimage/ target=_blank rel=noopener>公式サイト</a>では<code>ImmutableImage.loader()</code>で形式に関係なく画像を読み込むことができると書いてありますが、実際にAPIをビルドする際はAWT関連のエラーが出るので、形式に応じて読み込むクラスを変える必要があります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>asImmutableImage</span>(rawData: ByteArray): ImmutableImage {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ImageIOReader().read(rawData)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ImmutableImageに変換したら、リサイズ処理を行います。Scrimageではリサイズのためのメソッドが用意されているので、それを使ってリサイズを行います。</p><p>ここで注意すべきは、<code>resize()</code>や<code>resizeTo()</code>のようなメソッドがあるのですが、前者の場合はパーセントでのリサイズ、後者の場合は指定したサイズにリサイズするという違いがあります。これらの場合、元の画像のアスペクト比が保持されないため、<code>scaleTo()</code>や<code>scaleToWidth()</code>などのメソッドを使う必要があります。</p><p>今回はwidthのみを指定してアスペクト比を保持したままリサイズするため、<code>scaleToWidth()</code>を使います。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>resizeImmutableImage</span>(image: ImmutableImage, width: Int): ImmutableImage {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> image.scaleToWidth(width)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最後に、リサイズした結果をByteArrayとして返すためのメソッドを用意します。どの形式に変換するかによって<a class=link href=https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/nio/ImageWriter.java target=_blank rel=noopener>ImageWriter</a>を実装するクラスを選ぶ必要があります。今回はWEBPにしたいので、<a class=link href=https://github.com/sksamuel/scrimage/blob/master/scrimage-webp/src/main/java/com/sksamuel/scrimage/webp/WebpWriter.java target=_blank rel=noopener>WebpWriter</a>を使います。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>encodeImage</span>(image: ImmutableImage): ByteArray {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> image.bytes(<span style=color:#a6e22e>WebpWriter</span>.DEFAULT)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最後にRouterでは、Content-Typeを指定してByteArrayを返すようにします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>call.respondBytes(
</span></span><span style=display:flex><span>    bytes = resizedImage,
</span></span><span style=display:flex><span>    contentType = ContentType(<span style=color:#e6db74>&#34;image&#34;</span>, <span style=color:#e6db74>&#34;webp&#34;</span>)
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h3 id=webpの場合>WEBPの場合</h3><p>WEBPの場合は、上記データ読み込む時点で<code>WebpImageReader</code>を使う必要があります。その後のリサイズ処理はPNG, JPEGの場合と同じです。</p><p>ただ、形式がWEBPの場合には<a class=link href=https://github.com/sksamuel/scrimage/tree/master/scrimage-webp target=_blank rel=noopener>scrimage-webp</a>が提供している<a class=link href=https://github.com/sksamuel/scrimage/blob/master/scrimage-webp/src/main/java/com/sksamuel/scrimage/webp/WebpImageReader.java target=_blank rel=noopener>WebpImageReader</a>を使う必要があります。なので、形式に応じて読み込むクラスを変える必要があります。先ほどの<code>asImmutableImage</code>の引数に形式を追加して、形式に応じて読み込むクラスを変えるようにします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>asImmutableImage</span>(rawData: ByteArray, format: Format): ImmutableImage {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>when</span> (format) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Format</span>.WEBP <span style=color:#f92672>-&gt;</span> WebpImageReader().read(rawData)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Format</span>.GIF, <span style=color:#a6e22e>Format</span>.PNG, <span style=color:#a6e22e>Format</span>.JPEG <span style=color:#f92672>-&gt;</span> ImageIOReader().read(rawData)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>他の処理はPNG, JPEGの場合と同じです。</p><h3 id=gifの場合>GIFの場合</h3><p>GIFの場合は、<a class=link href=https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/nio/AnimatedGif.java target=_blank rel=noopener>AnimatedGif</a>というクラスを使ってリサイズを行います。ImmutableImageと同じようにリサイズメソッドが用意されているので、それを使ってリサイズを行います。処理で使われるクラスが違うので、GIFの場合は別途メソッドを用意します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>asAnimatedGif</span>(rawData: ByteArray): AnimatedGif {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>AnimatedGifReader</span>.read(<span style=color:#a6e22e>ImageSource</span>.of(rawData))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>また、AnimatedGifの場合はframesというプロパティで各フレームのデータを保持していて、これらはImmutableImageとして扱うことができます。そのため、リサイズ処理は各フレームに対して行い、それをAnimatedGifに戻すという処理を行います。若干複雑ですが、以下のように書くことができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>resizeAnimatedGif</span>(gif: AnimatedGif, width: Int): AnimatedGif {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> resizedData = ByteArrayOutputStream().use {
</span></span><span style=display:flex><span>        StreamingGifWriter().prepareStream(<span style=color:#66d9ef>it</span>, <span style=color:#a6e22e>BufferedImage</span>.TYPE_INT_ARGB).use { stream <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            gif.frames.mapIndexed { index, image <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                stream.writeFrame(image.scaleToWidth(width), gif.getDelay(index))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>it</span>.toByteArray()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>AnimatedGifReader</span>.read(<span style=color:#a6e22e>ImageSource</span>.of(resizedData))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最後に、リサイズした結果をByteArrayとして返すためのメソッドを用意します。基本的にはImmutableImageと同じですが、GIFをWEBPに変換する場合は<a class=link href=https://github.com/sksamuel/scrimage/blob/master/scrimage-webp/src/main/java/com/sksamuel/scrimage/webp/Gif2WebpWriter.java target=_blank rel=noopener>Gif2WebpWriter</a>を使います。これでWEBPに変換後も、GIFのアニメーションが保持されたままリサイズすることができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>encodeGif</span>(gif: AnimatedGif): ByteArray {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> gif.bytes(Gif2WebpWriter.DEFAULT)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=処理を共通化する>処理を共通化する</h2><p>ここまででPNG, JPEG, WEBP, GIFの4つの形式に対してリサイズ処理を行うことができました。ただ、それぞれの形式に対して処理を書いていると、処理が重複してしまうため、共通化する必要があります。特にImmutableImageとAnimatedGifの処理は似ているため、それらを共通化することにします。</p><h3 id=共通interfaceを作る>共通Interfaceを作る</h3><p>ScrimageではImmutableImageとAnimatedGifは別のクラスであるだけでなく、共通のInterfaceを持っていないため、まずはそれを作成する必要があります。ここでは、ImageというInterfaceを作成し、それを実装するクラスを作成します。それぞれのクラスはWrapperとして作成し、それぞれのクラスのプロパティをInterfaceのプロパティとして持つようにします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>sealed</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Image</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> width: Int
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AnimatedGifWrapper</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> animatedGif: AnimatedGif
</span></span><span style=display:flex><span>) : Image {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>val</span> width: Int
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span>() = animatedGif.frames.first().width
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ImmutableImageWrapper</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> immutableImage: ImmutableImage
</span></span><span style=display:flex><span>) : Image {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>val</span> width: Int
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span>() = immutableImage.width
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=画像取得の共通化>画像取得の共通化</h3><p>あとは外部に公開するAPIとして、<code>asImage</code>というメソッドを作成し、それぞれの形式に応じてWrapperを返すようにします。ここで、形式の判定は先ほど作成した<code>detectImageFormat</code>を使います。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>asImage</span>(rawData: ByteArray): Image {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>when</span> (<span style=color:#66d9ef>val</span> format = detectImageFormat(rawData)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Format</span>.GIF <span style=color:#f92672>-&gt;</span> asAnimatedGifWrapper(rawData)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Format</span>.WEBP, <span style=color:#a6e22e>Format</span>.PNG, <span style=color:#a6e22e>Format</span>.JPEG <span style=color:#f92672>-&gt;</span> asImmutableImageWrapper(rawData, format)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>asAnimatedGifWrapper</span>(rawData: ByteArray): AnimatedGifWrapper {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> gif = <span style=color:#a6e22e>AnimatedGifReader</span>.read(<span style=color:#a6e22e>ImageSource</span>.of(rawData))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> AnimatedGifWrapper(gif)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>asImmutableImageWrapper</span>(rawData: ByteArray, format: Format): ImmutableImageWrapper {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> image = <span style=color:#66d9ef>when</span> (format) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Format</span>.WEBP <span style=color:#f92672>-&gt;</span> WebpImageReader().read(rawData)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Format</span>.GIF, <span style=color:#a6e22e>Format</span>.PNG, <span style=color:#a6e22e>Format</span>.JPEG <span style=color:#f92672>-&gt;</span> ImageIOReader().read(rawData)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ImmutableImageWrapper(image)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=リサイズ処理の共通化>リサイズ処理の共通化</h3><p>同じく、リサイズ処理も共通化します。ここでは、<code>resizeImage</code>というメソッドを作成し、それぞれの形式に応じてリサイズ処理を行うようにします。ここで、リサイズ処理は先ほど作成した<code>resizeImmutableImage</code>と<code>resizeAnimatedGif</code>を使います。AnimatedGifのリサイズ処理はまた別途<code>writeAnimatedGif</code>というメソッドを作成して分けています。</p><p>ここでImageはsealed interfaceとして作成しているため、分岐処理はwhen式を使って網羅することができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>resizeImage</span>(image: Image, width: Int): Image {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>when</span> (image) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>is</span> AnimatedGifWrapper <span style=color:#f92672>-&gt;</span> resizeAnimatedGif(image, width)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>is</span> ImmutableImageWrapper <span style=color:#f92672>-&gt;</span> resizeImmutableImage(image, width)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>resizeAnimatedGif</span>(gifWrapper: AnimatedGifWrapper, width: Int): AnimatedGifWrapper {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> gif = gifWrapper.animatedGif
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> resizedData = writeAnimatedGif { stream <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        gif.frames.mapIndexed { index, image <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>            stream.writeFrame(image.scaleToWidth(width), gif.getDelay(index))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> resizedGif = <span style=color:#a6e22e>AnimatedGifReader</span>.read(<span style=color:#a6e22e>ImageSource</span>.of(resizedData))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> AnimatedGifWrapper(resizedGif, resizedData)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>writeAnimatedGif</span>(writeFunction: (<span style=color:#a6e22e>StreamingGifWriter</span>.GifStream) <span style=color:#f92672>-&gt;</span> Unit): ByteArray {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> withContext(<span style=color:#a6e22e>Dispatchers</span>.IO) {
</span></span><span style=display:flex><span>        StreamingGifWriter().use {
</span></span><span style=display:flex><span>            streamingGifWriter.prepareStream(<span style=color:#66d9ef>it</span>, <span style=color:#a6e22e>BufferedImage</span>.TYPE_INT_ARGB).use { stream <span style=color:#f92672>-&gt;</span> writeFunction(stream) }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>it</span>.toByteArray()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>resizeImmutableImage</span>(imageWrapper: ImmutableImageWrapper, width: Int): ImmutableImageWrapper {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> resizedImage = imageWrapper.immutableImage.scaleToWidth(width)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ImmutableImageWrapper(resizedImage, imageWrapper.format)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=画像のエンコード処理の共通化>画像のエンコード処理の共通化</h3><p>最後に、画像のエンコード処理も共通化します。ここでは、<code>encodeImage</code>というメソッドを作成し、それぞれの形式に応じてエンコード処理を行うようにします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>encodeImage</span>(image: Image): ByteArray {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>when</span> (image) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>is</span> AnimatedGifWrapper <span style=color:#f92672>-&gt;</span> image.animatedGif.bytes(Gif2WebpWriter.DEFAULT)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>is</span> ImmutableImageWrapper <span style=color:#f92672>-&gt;</span> image.immutableImage.bytes(<span style=color:#a6e22e>WebpWriter</span>.DEFAULT)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>これで共通化も終わり、呼び出す側は<code>asImage</code>, <code>resizeImage</code>, <code>encodeImage</code>の3つのメソッドを使うだけでリサイズ処理を行うことができます。サイズのチェックもImageの方でプロパティ化しているため、それを使ってリサイズが必要かどうかの判定も行うことができます。</p><p>あとはImageWriterなど、毎回インスタンスを生成する必要のないクラスは、シングルトンとして作成しておくとよいでしょう。</p><h2 id=最後に>最後に</h2><p>だいぶ長くなってしまいましたが、ここまでで動的画像リサイズAPIの作成方法を紹介しました。Scrimageを使うことで、PNG, JPEG, WEBP, GIFの4つの形式に対してリサイズ処理を行うことができ、共通化することで処理の重複を防ぐことができました。</p><p>あとは、Cloud Run上で動かすためのDockerfileを作成し、Cloud Storageとの連携を行うことで、画像の配信を行うことができます。また、Cloud CDNを使うことで、2回目以降の呼び出しではキャッシュを返すようにすることで、負荷を軽減することができます。なかなか面白いプロジェクトでした。</p><p>では、また！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/ktor/>Ktor</a>
<a href=/tags/kotlin/>Kotlin</a>
<a href=/tags/scrimage/>Scrimage</a>
<a href=/tags/rust/>Rust</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/posts/ktor-path-parameter-as-inline/><div class=article-image><img src=/images/ktor.webp loading=lazy data-key data-hash=/images/ktor.webp></div><div class=article-details><h2 class=article-title>Path ParameterをInline classで受け取る</h2></div></a></article><article class=has-image><a href=/posts/ktor-role-based-authorization/><div class=article-image><img src=/images/ktor.webp loading=lazy data-key data-hash=/images/ktor.webp></div><div class=article-details><h2 class=article-title>KtorでRole-based Authorizationを実装する</h2></div></a></article><article class=has-image><a href=/posts/ktor-first-impression/><div class=article-image><img src=/images/ktor.webp loading=lazy data-key data-hash=/images/ktor.webp></div><div class=article-details><h2 class=article-title>Ktorを触ってみた</h2></div></a></article><article class=has-image><a href=/posts/kotlin-prospect/><div class=article-image><img src=/images/kotlin.webp loading=lazy data-key data-hash=/images/kotlin.webp></div><div class=article-details><h2 class=article-title>Kotlinのこれからを語る</h2></div></a></article><article class=has-image><a href=/posts/rust-first-impression/><div class=article-image><img src=/images/rust.webp loading=lazy data-key data-hash=/images/rust.webp></div><div class=article-details><h2 class=article-title>Kotlinプログラマが見たRust</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2024 Korean-man in Tokyo</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.20.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>