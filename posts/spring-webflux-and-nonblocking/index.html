<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="今まではずっとSpring MVCを使ってきたので、最近はKotlin + Spring WebFluxという組み合わせで簡単なアプリを作ってみているところで"><title>Spring WebFlux、少し触ってみてからの話</title><link rel=canonical href=https://retheviper.github.io/posts/spring-webflux-and-nonblocking/><link rel=stylesheet href=/scss/style.min.fbb68fe51fb77bdd639dccfe1c7b590d2330cf8b81da91f1585b35c3d07fbac8.css><meta property="og:title" content="Spring WebFlux、少し触ってみてからの話"><meta property="og:description" content="今まではずっとSpring MVCを使ってきたので、最近はKotlin + Spring WebFluxという組み合わせで簡単なアプリを作ってみているところで"><meta property="og:url" content="https://retheviper.github.io/posts/spring-webflux-and-nonblocking/"><meta property="og:site_name" content="Korean-man in Tokyo"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="spring"><meta property="article:tag" content="webflux"><meta property="article:tag" content="r2dbc"><meta property="article:tag" content="reactor"><meta property="article:tag" content="loom"><meta property="article:published_time" content="2020-12-20T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-20T00:00:00+00:00"><meta property="og:image" content="https://retheviper.github.io/images/spring.jpg"><meta name=twitter:title content="Spring WebFlux、少し触ってみてからの話"><meta name=twitter:description content="今まではずっとSpring MVCを使ってきたので、最近はKotlin + Spring WebFluxという組み合わせで簡単なアプリを作ってみているところで"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://retheviper.github.io/images/spring.jpg"><link rel=apple-touch-icon sizes=57x57 href=/favicon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/favicon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/favicon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/favicon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/favicon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/favicon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/favicon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/favicon/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><script async src="https://www.googletagmanager.com/gtag/js?id=G-BYJBEJB6DX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BYJBEJB6DX",{anonymize_ip:!1})}</script></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/spring-webflux-and-nonblocking/><img src=/../../images/spring.jpg loading=lazy alt="Featured image of post Spring WebFlux、少し触ってみてからの話"></a></div><div class=article-details><header class=article-category><a href=/categories/spring/ style=background-color:#2a9d8f;color:#fff>spring</a></header><h2 class=article-title><a href=/posts/spring-webflux-and-nonblocking/>Spring WebFlux、少し触ってみてからの話</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Dec 20, 2020</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>16 minute read</time></div></footer></div></header><section class=article-content><p>今まではずっとSpring MVCを使ってきたので、最近はKotlin + Spring WebFluxという組み合わせで簡単なアプリを作ってみているところです(Spring WebFluxそのものについての紹介は、前回のポストでしているのでここでは割愛します)。Spring WebFluxが紹介されたのももう3年前のことなので(あと少しで、4年になりますね)、もうかなりの時間が経ちますが、実際はあまり幅広く使われてはいないのが現状ではないかと思います。なのでネットで調べてもあまり参考できそうなものがなかったりしますね。</p><p>これはおそらくSpring WebFluxが本格的に導入するにはまだ色々と考えるべきところがあるからでしょう。例えば、フレームワークとしてまだまだ成熟している技術ではないということがあります。まだ、このフレームワークの核心となるReactorの書き方に慣れていない人が多い(Reactiveといいつつ、<a class=link href=https://github.com/ReactiveX/RxJava target=_blank rel=noopener>RxJava</a>ともまた微妙に違いますしね)という面も考慮しなくてはならないです。会社の立場からしたら、このようにまだ新しい技術をすぐに取り入れるということはリスクもあり、エンジニアの学習コストも考えなくてはいけないという面からあまりメリットがないです。</p><p>そして前回紹介した通り、パフォーマンスの面からしても既存のSpring MVCプロジェクトをSpring WebFluxに変えるだけではあまり得しないという問題があります。なら、新規プロジェクトから導入して良いのでは？と思われる可能性もあると思いますが、スタートアップやベンチャー企業などではそもそもJVM言語を使和ないケースが多いので(勝手なイメージかもしれませんが、そのような企業はやはりPythonやRuby、JavaScriptが多いと思います)、そもそも考慮の対象になっていないのかもしれません。また、もしJVM言語に慣れているエンジニアがいるからSpring WebFluxは導入できるとしても、やはり前述した「検証されてない」と「学習コストがかかる」という問題からは自由ではないですね。</p><p>少なくともこれらの理由からエンタープライズレベルでは、まだSpring WebFluxの導入は難しいかと思います。ただ、おそらくSpringの未来はWebFluxにあるので、これからだんだんWebFluxを中心に開発が行われる可能性もあるので、今からでもReactorの書き方になれる必要があるのかもしれません。また、Springという一つのフレームワークの観点からでなくても、非同期による同時処理性能の向上は、多数のユーザの利用する頻度の高いWebアプリケーションの開発においては重要な要素であるので、少なくともその概念、思想、そしてコードの書き方には慣れる必要があるかもしれません。そういう意味で、自作アプリをSpring WebFluxで書いてみた経験とそこから感じたことを述べたいと思います。</p><h2 id=spring-webfluxのアプリを書くということ>Spring WebFluxのアプリを書くということ</h2><p>Spirng WebFluxは既存のController + Serviceというパターンでもコードを書くことができます。なので、一見みると既存のSpring MVCで作られたプロジェクトと並行して運用したり、既存のコードを少し書き換えるだけで簡単にWebFluxに移行できそうなイメージを与えていると思います。が、実際はそうでもないような気がします。まず私の場合、簡単なCRUDのサンプル(GitHubのリポジトリは<a class=link href=https://github.com/retheviper/springwebfluxsample target=_blank rel=noopener>こちら</a>)を作ってみてから、これを応用して<a class=link href=https://chouseisan.com target=_blank rel=noopener>調整さん</a>のマイナークロンを作ってみようとしました。</p><p>ここで、サンプルではSpring Data JPAを使っていましたが、WebFluxで本格的なノンブロッキングのアプリを書いてみたいと思ったので、<a class=link href=https://r2dbc.io/ target=_blank rel=noopener>R2DBC</a>を導入してDBアクセスも非同期で構成することにしました。なぜかというと、非同期の処理の中に一つでも同期の処理が発生するとしたら、それだけでももはや非同期ではなくなるからです。なのでORMもそれに合わせてR2DBCを使う必要がる、とのことです。</p><p>幸い、R2DBCは使い方としてもSpring Data JPAやSpring Data JDBCとそう変わらない感覚で、Interface形式のRepositoryを作り、DTO形式のオブジェクト(Kotlinなら、Data classで十分でした)を作るだけでDBとのマッピングは簡単にできました。あとJPAに比べ、アノテーションの数が少なくなっているだけなのでテーブルとしてオブジェクトを定義するのも簡単です(<code>@Id</code>をつけるのみで終わります)。そしてSpring Data JDBCとは違って、メソッド名から自動でクエリを生成してくれるというところもあったので、最初は楽だと思いました。でも、やはり初めて触っている技術で、そうなんでもうまくいくはずがありません。一つ、問題にあってしまいました。</p><h3 id=joinができない>Joinができない</h3><p>個人的にはどんな技術でも、やはりある程度の時間がたち、安定期に入る前までは既存の技術に比べ圧倒的な優位にあり、すぐに乗り換えるべきと言えなくするところ(つまり、レガシーを捨てがたくする要素)が必ずしも一つ以上は存在すると思います。そういう意味からすると、Spring Data R2DBCが既存のORMを今すぐ代替するには十分ではないと言える部分は、自動でJoinを行う方法がない(テーブル間の関係をあらかじめオブジェクトとして定義することができない)というところと言えるのではと思います。</p><p>Spring Data JPAやJDBCを使う場合、アノテーションを使うことで簡単にテーブル間の関係(<a class=link href=https://docs.oracle.com/javaee/6/api/javax/persistence/OneToOne.html target=_blank rel=noopener>@OneToOne</a>など)を定義できて、テーブルの関係をコード内で簡単に定義できます。しかし、これがまだR2DBCでは対応していない機能となっています。こういう状況では、リポジトリに<code>@Query</code>アノテーションをつけて直接Joinが含まれたSQLを書いたメソッドを定義するか、二つのオブジェクトをアプリケーションの中で組み合わせるかの方法があるかと思います。</p><p>ここで前者の場合、コードカバレッジとして取れない部分になってしまうので(そして、個人的には性能が良いとしても、あまりクエリが複雑になりそうなものはメンテの観点からよく思ってないので)、後者の方法を取ることにしました。オブジェクトとリポジトリが1:1になって、後でテーブルに修正が発生してもそのテーブルに当てはまるオブジェクトを直すだけで済むので、より簡単な方法だと思ったからです。しかし、その決定にも問題はありました。R2DBCが返すSQLの実行結果としてのオブジェクトは、オブジェクトそのままではなく、<code>Mono</code>か<code>Flux</code>であったからです。</p><h4 id=blockのジレンマ>block()のジレンマ</h4><p>リポジトリから取得したオブジェクトが<code>Mono</code>や<code>Flux</code>なので、またどうやって二つのオブジェクトを組み合わせるか(Joinさせるか)を考える必要があります。</p><p>一番簡単な方法としては、<code>Mono</code>や<code>Flux</code>をブロッキングして使う方法がありますね。すでに<code>Mono</code>や<code>Flux</code>には<code>block()</code>というメソッドが用意されてあって、同期のコードの中で使うことも可能になっています。例えばSpring MVCでもRestTemplateよりWebClientを使うことが推奨されているので、非同期と同期のの共存が不可能なわけでも、おかしいわけでもないです。</p><p>ただ問題は、そのような方法を取ると非同期のメリットがなくなるということです。なぜなら非同期が見せてくれる素晴らしい同時処理性能は、どこか一つの箇所でもブロッキングが挟むと、結局は同期コードになってしまうからです。それなら今までのSpring MVCとORMでよくて、あえてWebFluxやR2DBCを使う必要が無くなりますね。なので別の方法を試してみることにしました。</p><h4 id=mono--monoもしくはflux--flux>Mono + MonoもしくはFlux + Flux</h4><p>やはりここで取るべき方法は、非同期に相応しい処理方法を探すことでしょう。なので調べた結果、二つの<code>Mono</code>もしくは<code>Flux</code>を配列のようなオブジェクトとして結合して扱う方法があるということがわかりました。答えは意外と簡単で、<code>zipWith()</code>というメソッドを使うことで二つの<code>Mono</code>か<code>Flux</code>をつなげることができます。つなげた<code>Mono</code>もしくは<code>Flux</code>は、Kotlin基準でタプルになるのであとは<code>map()</code>からタプルのインデックス(繋ぎ元が<code>t1</code>、繋ぎ先が<code>t2</code>となります)を指定して使うだけです。例えば、以下のコードは<code>Paticipant</code>というオブジェクトをリポジトリから取得したあと、さらに<code>CandidateParticipants</code>を取得して結合する例です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>getParticipant</span>(participantId: Long): Mono&lt;ParticipantDto&gt; =
</span></span><span style=display:flex><span>    repository.findById(participantId)
</span></span><span style=display:flex><span>        .zipWith(candidateParticipantHandler.getåCandidateParticipantsByParticipantsId(participantId).collectList())
</span></span><span style=display:flex><span>        .map { mapDto(<span style=color:#ff79c6>it</span>.t1, <span style=color:#ff79c6>it</span>.t2) }
</span></span></code></pre></div><p>ただ、このような方式を使ってテーブルをJoinするためには、二つのMonoとFluxを取得できる環境である必要があります。なのでSelectを発行するメソッド(Get系のAPIなど)なら、オブジェクトにテーブル間の関係を上手く設計して反映する必要があります。つまり、一つのキーでJoin対象の全てのオブジェクトを取得できるようにする必要があるということになります。最初のオブジェクトを取得したあと、そのオブジェクトが持つまたのキーで紹介したら良いのでは？と思ったこともありますが、残念ながら私の知る限りは簡単にできそうにないです。なぜなら、そのような方法を取るには以下の手順が必要になるからです。</p><ol><li>キーを持ってJoin元のテーブルを照会、データを<code>Mono</code>もしくは<code>Flux</code>として取得する</li><li>取得した<code>Mono</code>もしくは<code>Flux</code>の<code>map()</code>を呼び出し、更なるキーを抽出、Join先のテーブルを照会する</li><li>Join元とJoin先のテーブルを組み合わせる</li></ol><p>一見問題なさそうですが、<code>Join先のテーブルを紹介する</code>段階で、またの<code>Mono</code>もしくは<code>Flux</code>を取得してしまうので、それからどうやって元のオブジェクトを取り出すかが問題となります。ここでまた<code>block()</code>を使うと、今までやってきたことたちが台無しとなってしまうわけです。なので、かなり不便でありながら、コードを持ってのテーブルのJoinは、現時点ではこのような方法しかないのではと思っているところです。</p><h2 id=これがベストか>これがベストか</h2><p>こうやって、WebFluxで疑問となった問題は、なんとか解決することはできました。しかし、個人的にはこのようなやり方に違和感があります。そして、その理由をProject LoomのリーダであるRon Pressleの<a class=link href=https://www.infoq.com/presentations/continuations-java/ target=_blank rel=noopener>説明</a>から探すことができました。彼の話によると、今の非同期プログラミングは以下の三つの問題を持っています。</p><h3 id=コントロールフローを見失いやすい>コントロールフローを見失いやすい</h3><p>非同期でコードを書いていると、どんなロジックと目的でコードを書いていたか忘れてしまうような気がする時があります。それはおそらく、アプリケーションの本来の目的を達成するための「ビジネスロジック」よりも、「ノンブロッキングのお作法」の方を気にかけることが多くなるからですね。非同期でコードを書いていると、簡単な条件分岐や繰り返してもかなりコードが複雑になり、一体どのような処理をしようとしたか、その制御の流れを見失いやすくなります。Javaだけやっていた自分にはあまり実感がないですが、JavaScirptで非同期のコードを書いた経験のある方にはこれが理解できるでしょう。(あの有名な、コールバックヘル問題とかがあるし…)</p><p>例えばこのポストでも紹介した通り、二つのテーブルをJoinするために、何をしているかをみてください。同期だったら、最初からJoinしたデータを取得するか、二つのオブジェクトを順番に宣言して処理するだけ済む話ですね。このように簡単な処理でも非同期に変えようとすると、そのコードで何をしたいかよりも、まず非同期の形式に合わせたコードを書くことになるので、「一体何をしようとしているのか」という、そもそもの目的がわからなくなる場合があるという話です。</p><h3 id=コンテキストを見失ってしまう>コンテキストを見失ってしまう</h3><p>非同期だと、例外が発生した時に、スタックトレースを追うのが非常に難しくなります。なぜなら、同期の場合は一つのスレッドが一つのリクエストを処理するため、何が実行されどんな結果になったのかを追跡するためにはそのスレッドの残した履歴を見るだけで十分です。しかし、非同期だと、一つのリクエストが複数のスレッドを渡りながら処理されるため、一つのスレッドの履歴を追うだけでは一体どんなことが起こっているかわからなくなるからです。</p><h3 id=コードの伝染>コードの伝染</h3><p>非同期でコードを書くことになると、結局はアプリケーション全体から同期という概念を排除する結論に至るかもしれません。なぜなら、先に述べました通り、非同期の処理の中で一つでも同期の処理が混ざっているとしたら、それだけでも全体の処理が同期になっちゃうからです。なので、同期と非同期を一つのアプリの中で共存させるのはかなり難しくなり、結果的には非同期のコードに他のコードが「伝染」されるようなことが起きてしまうケースが発生します。例えばWebFluxの例では、同期のコードと混ぜて使うこともほぼ不可能に近いので、あえてオブジェクトを<code>Mono</code>や<code>Flux</code>に入れ(非同期に変え)、<code>zipWith()</code>でタプルとして結び、<code>map()</code>や<code>flatMap()</code>で処理するという形になるしかなくなります。そしてその逆の方法を取るとしたら(<code>block()</code>で<code>Mono</code>の中身を持ち出すなど)、もはや最初から同期でコードを書いた方が良いということになってしまうという問題があります。</p><h2 id=それでも非同期は必要>それでも非同期は必要</h2><p>以上のことは、おそらく非同期に触れてみた人なら誰でも一度は触れてみた問題であり、共感する人も多いのではないかと思います。しかし、このような不便さがあるにもかかわらず、依然として非同期プログラミングの必要性はあります。特に、今のトレンドだと多くのWebアプリケーションで同時処理性能が重要となっていますので、尚更です。実際<a class=link href="https://support.google.com/analytics/answer/4589209?hl=ja" target=_blank rel=noopener>グーグルアナリティクス</a>は、KissMetricsを引用して「ページのレスポンスが 1 秒遅れると、コンバージョン数が 7% 減少する」、「47% の消費者は 2 秒以内にウェブページが読み込まれることを期待している」と行っているくらいですが、このような要求に対応できるのはやはり非同期としか言えません。なので、JavaScriptやC#のような言語では<code>async</code>/<code>await</code>/<code>promise</code>などを試し、Kotlinで<a class=link href=https://kotlinlang.org/docs/reference/coroutines-overview.html target=_blank rel=noopener>Coroutine</a>というものを導入するなど、なんとしても非同期の短所を補完するという努力をしているところですね。</p><p>特に、Javaの場合はOSのスレッドを直接使用するので、同時に処理できるリクエストは数千くらいにすぎません。なので、このスレッド基盤という言語そのものの限界を克服するため今まで多くの非同期ライブラリが作られてきました。しかし、ライブラリにはやはり限界があったので、JVMレベルでの対応が検討されているところです。それが先ほど紹介しました、<a class=link href=https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html target=_blank rel=noopener>Project Loom</a>というものです。</p><h3 id=project-loomという答え>Project Loomという答え</h3><p>Project Loomでは、既存のスレッドをFiberという仮想・軽量スレッドとして切り分け、同時処理性能をあげると同時に、「非同期プログラミングを同期プログラミングの感覚でできるように」して、今までのように非同期か同期かによってコードが変わるような現象を無くすのが目的です。Fiberは数百万まで生成できるというし、使い方としても既存のスレッドどあまり変わらないので、コードの修正も少なくなります。それに、同期の感覚で書いても内部的に<code>async</code>/<code>await</code>を使ったかのように処理されるので、コールバックヘルのような問題も無くなりますね。</p><p>また、KotlinのCoroutineはあくまでコンパイラレベルの対応なので、上述した3つの問題のうち、「コンテキストを見失う」、「コードの伝染」という問題は根本的に解決できませんが、Project LoomはJVMレベルの対応なので、これらの問題が全部解消されるというメリットもあります。そして既存の同期APIを非同期に変えることで、クライアントコードとしてはあまり変わることなくすぐに適応できるのも魅力的ですね。</p><p>多くの場合に「非同期の性能」は欲しくても、多くのプログラマが「同期の書き方」に慣れているという現実からして、Proejct Loomが正式リリースされるとしたら既存のCoroutineや<code>async</code>/<code>await</code>/<code>promise</code>、Reactice Streamを使ったプロジェクトの多くがFiberを使ったコードに変わるのではないかと思います。</p><h2 id=最後に>最後に</h2><p>どんな分野でも、過渡期にあるものがもっとも混乱しやすく、辛いものです。そしてプログラミングにおいては、非同期プログラミングというパラダイムが、まさにそうなのではないかと思います。多くの天才たちが言語、ライブラリ、フレームワークとしうさまざまな方面から非同期プログラミングの短所を克服しようと努力してきて、やがてその結実が見えてくるような気がします。Reactive Steamの思想、「反応型」という概念は個人的に嫌いではないですが、それが今までのプログラミングに比べあまりにも変わった書き方になってくるので、個人的には「特定の目的のため、完全に違う言語も学ぶのと同じくらいの努力が必要となるが、その効率の悪さを甘んずるほどのメリットがあるか」とも思います。それはおそらく、まだ自分が本格的に非同期のコードを書いてみたことがないのでそう思うだけなのかもしれませんが。でも、これもProject Loomのように、同期の感覚で非同期プログラミングができるような技術があると解決される問題でしょう。</p><p>ただ、まだProject Loomは完成した技術ではなく、開発途中のものなので、のちに限界や問題が見つかる可能性もありますね。そして将来的にWebFluxなどで採用されるとしても、リリースのタイミングがわからないので、それまではReactive StreamやCoroutineを使うしかないので、のちにLoomのリリースに合わせて既存のコードを全部書き換えるというのも無理な話です。なるべく早く出て欲しいのですが、まだ2年以内のリリースはないみたいなので、今の姿とは全く違うものになる可能性もありますね。</p><p>だとしても、JVM自体が代わり、非同期プログラミングがより楽なるということは魅力的なものです。最近はKotlinにハマっていますが、こうやって変わっていくJavaを見るのも楽しいことですね。また新しい世界が見えてきそうな気分です。</p><p>では、また！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/spring/>spring</a>
<a href=/tags/webflux/>webflux</a>
<a href=/tags/r2dbc/>r2dbc</a>
<a href=/tags/reactor/>reactor</a>
<a href=/tags/loom/>loom</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/posts/spring-webflux-dividing-router-and-handler/><div class=article-image><img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg></div><div class=article-details><h2 class=article-title>WebFluxのFunctional Enpointに対する小考察</h2></div></a></article><article class=has-image><a href=/posts/spring-webflux-router/><div class=article-image><img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg></div><div class=article-details><h2 class=article-title>WebFluxではFunctional Enpointを使うべきか</h2></div></a></article><article class=has-image><a href=/posts/spring-webflux/><div class=article-image><img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg></div><div class=article-details><h2 class=article-title>Spring WebFluxって何？</h2></div></a></article><article class=has-image><a href=/posts/spring-boot-2-to-3/><div class=article-image><img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg></div><div class=article-details><h2 class=article-title>Spring Boot 3を導入してみた</h2></div></a></article><article class=has-image><a href=/posts/spring-data-jpa/><div class=article-image><img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg></div><div class=article-details><h2 class=article-title>MyBatisよりJPAが使いたい</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2023 Korean-man in Tokyo</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.7.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#spring-webfluxのアプリを書くということ>Spring WebFluxのアプリを書くということ</a><ol><li><a href=#joinができない>Joinができない</a><ol><li><a href=#blockのジレンマ>block()のジレンマ</a></li><li><a href=#mono--monoもしくはflux--flux>Mono + MonoもしくはFlux + Flux</a></li></ol></li></ol></li><li><a href=#これがベストか>これがベストか</a><ol><li><a href=#コントロールフローを見失いやすい>コントロールフローを見失いやすい</a></li><li><a href=#コンテキストを見失ってしまう>コンテキストを見失ってしまう</a></li><li><a href=#コードの伝染>コードの伝染</a></li></ol></li><li><a href=#それでも非同期は必要>それでも非同期は必要</a><ol><li><a href=#project-loomという答え>Project Loomという答え</a></li></ol></li><li><a href=#最後に>最後に</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>