<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="DBのテーブルとして、1:Nのリレーションは珍しいものではありません。例えば、ECサイトで会員登録をし、複数の配送先を設定できるようにすると"><title>ExposedでOneToManyをどうマッピングするか</title><link rel=canonical href=https://retheviper.github.io/posts/exposed-mapping-record-to-object/><link rel=stylesheet href=/scss/style.min.fbb68fe51fb77bdd639dccfe1c7b590d2330cf8b81da91f1585b35c3d07fbac8.css><meta property="og:title" content="ExposedでOneToManyをどうマッピングするか"><meta property="og:description" content="DBのテーブルとして、1:Nのリレーションは珍しいものではありません。例えば、ECサイトで会員登録をし、複数の配送先を設定できるようにすると"><meta property="og:url" content="https://retheviper.github.io/posts/exposed-mapping-record-to-object/"><meta property="og:site_name" content="Korean-man in Tokyo"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="kotlin"><meta property="article:tag" content="exposed"><meta property="article:tag" content="map"><meta property="article:published_time" content="2021-07-26T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-26T00:00:00+00:00"><meta property="og:image" content="https://retheviper.github.io/images/exposed.jpg"><meta name=twitter:title content="ExposedでOneToManyをどうマッピングするか"><meta name=twitter:description content="DBのテーブルとして、1:Nのリレーションは珍しいものではありません。例えば、ECサイトで会員登録をし、複数の配送先を設定できるようにすると"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://retheviper.github.io/images/exposed.jpg"><link rel=apple-touch-icon sizes=57x57 href=/favicon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/favicon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/favicon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/favicon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/favicon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/favicon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/favicon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/favicon/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><script async src="https://www.googletagmanager.com/gtag/js?id=G-BYJBEJB6DX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BYJBEJB6DX",{anonymize_ip:!1})}</script></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/exposed-mapping-record-to-object/><img src=/../../images/exposed.jpg loading=lazy alt="Featured image of post ExposedでOneToManyをどうマッピングするか"></a></div><div class=article-details><header class=article-category><a href=/categories/exposed/ style=background-color:#2a9d8f;color:#fff>exposed</a></header><h2 class=article-title><a href=/posts/exposed-mapping-record-to-object/>ExposedでOneToManyをどうマッピングするか</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jul 26, 2021</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>10 minute read</time></div></footer></div></header><section class=article-content><p>DBのテーブルとして、1:Nのリレーションは珍しいものではありません。例えば、ECサイトで会員登録をし、複数の配送先を設定できるようにするとしたら、この会員情報のテーブルに配送先のカラムを追加するよりは、配送先のテーブルを分離して別に管理した方がデータの持ち方としては合理的で安全なはずです。そして分離した配送先のテーブルは、会員情報のテーブルとN:1の関係になるのが一般的でしょう。</p><p>ただ、データの持ち方が優先的なDBと、そのデータを処理して形にするアプリケーションでは事情が違いますね。例えば上記の通り、一つの会員情報のレコードに対して複数の配送先のレコードが存在し得る場合、SQLでデータを表現すると、以下のような形になるはずです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>|-----------|-------------|-----------------|
</span></span><span style=display:flex><span>| member.id | member.name | mailing.address |
</span></span><span style=display:flex><span>|-----------|-------------|-----------------|
</span></span><span style=display:flex><span>|         1 |        John |           Tokyo |
</span></span><span style=display:flex><span>|         1 |        John |        New York |
</span></span><span style=display:flex><span>|         1 |        John |         Beijing |
</span></span><span style=display:flex><span>|         2 |     Simpson |           Osaka |
</span></span><span style=display:flex><span>|         2 |     Simpson |          Nagoya |
</span></span><span style=display:flex><span>|-----------|-------------|-----------------|
</span></span></code></pre></div><p>しかしアプリケーションではこのような形でデータを扱うことはあまりないですね。一つのレコードに対して複数のレコードが含まれるということは、Kotlinだと以下のように表現するのが一般的かと思います。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>data</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Member</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> id: Int,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> name: String,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> mailingAdress: List&lt;String&gt;
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>そして普通は、このようなオブジェクトをJSONの形にしてREST APIのレスポンスとして使う場合が多いですね。なので、先程のレコードをJSONにした場合は以下のようになるはずです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;members&#34;</span>: [
</span></span><span style=display:flex><span>        { 
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;id&#34;</span>: <span style=color:#bd93f9>1</span>,
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;name&#34;</span>: <span style=color:#f1fa8c>&#34;John&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;mailingAddress&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#f1fa8c>&#34;Tokyo&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#f1fa8c>&#34;New York&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#f1fa8c>&#34;Beijing&#34;</span>
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;id&#34;</span>: <span style=color:#bd93f9>2</span>,
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;name&#34;</span>: <span style=color:#f1fa8c>&#34;Simpson&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>&#34;mailingAddress&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#f1fa8c>&#34;Osaka&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#f1fa8c>&#34;Nagoya&#34;</span>
</span></span><span style=display:flex><span>            ]            
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    ] 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ここで問題は、オブジェクトをJSONに変えることはそう難しくないのですが（<a class=link href=https://github.com/FasterXML/jackson target=_blank rel=noopener>Jackson</a>, <a class=link href=https://github.com/google/gson target=_blank rel=noopener>Gson</a>, <a class=link href=https://github.com/Kotlin/kotlinx.serialization target=_blank rel=noopener>Kotlin Serialization</a>のようなライブラリがすでにありますし）</p><p>では、このような場合、DBから取得したレコードをどうやってオブジェクトにマッピングしたら良いのでしょう。JPAのようなORMを使う場合、クラスにテーブル間の関係を表すフィールドとアノテーションを適切に使うことでレコードへのマッピングは自動に行われますが、<a class=link href=https://www.jooq.org target=_blank rel=noopener>jOOQ</a>や<a class=link href=https://querydsl.com target=_blank rel=noopener>Querydsl</a>, <a class=link href=https://github.com/JetBrains/Exposed target=_blank rel=noopener>Exposed</a>, <a class=link href=https://www.ktorm.org target=_blank rel=noopener>Ktorm</a>のようなORMで、DSLを使ってSQLを書く場合はデータのマッピングを手動で行う必要があります。そして取得したデータは行の配列という形になるので、どうマッピングしたら（効率が）いいかは少し悩ましいところです。</p><p>なので、今回はExposedのDSLを使って取得したOne to Manyのレコードを、コード上でどうやってオブジェクトにマッピングするかについて考えたことを述べたいとお思います。</p><h2 id=テーブルごとにselectする>テーブルごとにSelectする</h2><p>もっとも簡単な方法は、そもそもレコードの取得時に個別のテーブルに対してSelectしてからマッピングすることですね。個別のテーブルに対してクエリを発行するので、書き方としては明瞭になるというメリットもあります。例えば、以下のようなことができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>transaction {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// まずはMemberテーブルをSelectし、オブジェクトにマッピングする
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>val</span> member = <span style=color:#50fa7b>Member</span>.select { <span style=color:#50fa7b>Member</span>.id eq id }
</span></span><span style=display:flex><span>        .first()
</span></span><span style=display:flex><span>        .let {
</span></span><span style=display:flex><span>            MemberDto(
</span></span><span style=display:flex><span>                id = row[<span style=color:#50fa7b>Member</span>.id].<span style=color:#ff79c6>value</span>,
</span></span><span style=display:flex><span>                name = row[<span style=color:#50fa7b>Member</span>.name],
</span></span><span style=display:flex><span>                role = listOf(row[<span style=color:#50fa7b>Mailing</span>.role])
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// MailingテーブルをSelectし、リストにする
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>val</span> mailingAddress = Mailing
</span></span><span style=display:flex><span>            .select { <span style=color:#50fa7b>Mailing</span>.memberId eq member.id }
</span></span><span style=display:flex><span>            .map { <span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Mailing</span>.address] }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// オブジェクトのコピーを作り配送先のデータをマッピング
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    member.copy(mailingAddress = mailingAddress)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>もっとも簡単で、コードとしてもわかりやすい方法ではありますが、トランザクションの観点からするとあまりよくない方法ですね。Exposedでは、<code>transaction</code>ブロックに包むことでトランザクションの単位を制御できるものの、一回で済ませるクエリの発行が複数になるという問題があります。ここではMemberテーブルを照会するたびにMailingテーブルも照会することになるので1回のクエリが追加されているだけですが、もしMemberテーブルに1:Nの関係となっているテーブルが増えれば増えるほどクエリの発行数も増えることになるでしょう。そして今回は一つのレコードに対してのコードとなっていますが、照会対象のMemberテーブルのレコードが増えれば増えるほど発行されるクエリの数も多くなります。</p><p>また、オブジェクトのインスタンスを作っておいて、わざわあコピーするというのもあまり効率が良いとは言えません。これもまたクエリの数が増える問題と同じく、照会対象のレコードが増えれば増えるほど生成されるオブジェクトのインスタンスも増えることになるという訳ですね。なので、全く性能や効率を考えてないコードと言えます。</p><h2 id=joinしてマッピングする>joinしてマッピングする</h2><p>関係のあるデータを複数のテーブルを跨いで取得するには、やはり<code>join</code>が効率的でしょう。これならまず発行されるクエリの数は個別のテーブルに対してSelectする時に比べ、劇的に減ります。アルゴリズムでよく使われる表現の<a class=link href=https://vmm.dev/ja/cci/cci-0.md target=_blank rel=noopener>Big O記法</a>で表現すると、前者は<code>O(N^2)</code>であり、これは<code>O(1)</code>と表現できるはずです。</p><p>ならばデータを取得する際に、クエリとしては<code>join</code>を使うのが理想的なのはわかりますが、問題はそうやって取得したデータをどう加工するかです。先に述べましたが、取得したデータのうち重複するものがあるからですね。そしてこれが重複しているかどうかはクエリを実行した結果を取得して、確認するまではわかりません。</p><p>ここで考えられる方法は三つほどありますので、一つづつ紹介していきます。</p><h3 id=reduce>reduce</h3><p>まずはクエリの結果として取得した行を、それぞれオブジェクトにマッピングした後、<code>reduce</code>でまとめる方法です。例えば以下のようになります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>transaction {
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Member</span>.leftJoin(Mailing)
</span></span><span style=display:flex><span>        .select { (<span style=color:#50fa7b>Member</span>.id eq id) and (<span style=color:#50fa7b>Mailing</span>.memberId eq <span style=color:#50fa7b>Member</span>.id) }
</span></span><span style=display:flex><span>        .map {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// とりあえずオブジェクトにマッピングする
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            MemberDto(
</span></span><span style=display:flex><span>                id = <span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Member</span>.id].<span style=color:#ff79c6>value</span>,
</span></span><span style=display:flex><span>                name = <span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Member</span>.name],
</span></span><span style=display:flex><span>                mailingAddress = listOf(<span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Mailing</span>.address])
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }.reduce { acc, memberDto <span style=color:#ff79c6>-&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// オブジェクトを一つに集約させる（mailingAddressは累計）
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            acc.copy(
</span></span><span style=display:flex><span>                mailingAddress = acc.mailingAddress + memberDto.mailingAddress
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>このやり方で考えられる問題は、まず行数分のオブジェクトのインスタンスが作られるということです。このクエリとして取得しようとしているMemberのレコードは一つのみですが、そのレコードに紐づくMailingのレコードが多ければ多いほど件数は増え、当然生成されるオブジェクトの数も多くなります。また、マッピングだけでなく、<code>reduce</code>でもオブジェクトをコピーしているので、やはり行数分のオブジェクトが生成されていると考えられます。オブジェクトのインスタンス数は行数x2になる訳ですね。</p><p>そしてもう一つの問題は、Memberのレコードを複数取得する場合、全部一つのオブジェクトにまとまってしまうという問題がありますね。なので、このやり方だと一つのレコードを取得する場合のみしか適応できなくなります。</p><h3 id=groupby>groupBy</h3><p>取得したレコードを、一度Mapに変換するとどうでしょうか。KotlinのCollectionには<code>groupBy</code>というメソッドがあり、keyとvalueのマッピング方法を指定すると、一つのkeyに<code>List</code>形式のvalueになります。Mapなので、keyでMemberのオブジェクトをマッピングしておいて、valueとしてはMailingのレコードをまとめておくと良いでしょう。keyは同じものだと上書きされるので、取得したいMemberのレコードが複数の場合でも問題ないはずです。コードでは、以下のようになります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>transaction {
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Member</span>.leftJoin(Mailing)
</span></span><span style=display:flex><span>        .select { (<span style=color:#50fa7b>Member</span>.id eq id) and (<span style=color:#50fa7b>Mailing</span>.memberId eq <span style=color:#50fa7b>Member</span>.id) }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// keyはMemberオブジェクトのマッピング、valueではMailingのレコードを集約
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        .groupBy({
</span></span><span style=display:flex><span>            MemberDto(
</span></span><span style=display:flex><span>                id = <span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Member</span>.id].<span style=color:#ff79c6>value</span>,
</span></span><span style=display:flex><span>                name = <span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Member</span>.name],
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }, { <span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Mailing</span>.address] })
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// keyのオブジェクトにMailingのレコードを設定
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        .map { (key, <span style=color:#ff79c6>value</span>) <span style=color:#ff79c6>-&gt;</span>
</span></span><span style=display:flex><span>            key.copy(mailingAddress = <span style=color:#ff79c6>value</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>この方法だと、今まで照会した他の方法で考えられる問題をだいぶ解消できそうな気がしますね。ただ、気になるのは、<code>groupBy</code>の引数がLambdaであることです。引数として関数を渡すということは、ループしながらその関数を実行することになるという意味なので、<code>reduce</code>の時と同じ量のインスタンスが作られる可能性がありそうですね。なので、<code>groupBy</code>の実装を見ていきたいと思います。中のコードは、以下の通りです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>inline</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>, <span style=color:#50fa7b>K</span>, <span style=color:#50fa7b>V</span>&gt; <span style=color:#50fa7b>Iterable</span>&lt;T&gt;.groupBy(keySelector: (T) <span style=color:#ff79c6>-&gt;</span> K, valueTransform: (T) <span style=color:#ff79c6>-&gt;</span> V): Map&lt;K, List&lt;V&gt;&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> groupByTo(LinkedHashMap&lt;K, MutableList&lt;V&gt;&gt;(), keySelector, valueTransform)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>groupBy</code>の実装では、<code>groupByTo</code>という関数に自分の引数と、作られるMapのインスタンスを渡しているだけですね。では、さらに<code>groupByTo</code>の中身を見ていきましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>inline</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>, <span style=color:#50fa7b>K</span>, <span style=color:#50fa7b>V</span>, <span style=color:#50fa7b>M</span> : <span style=color:#50fa7b>MutableMap</span>&lt;<span style=color:#ff79c6>in</span> <span style=color:#50fa7b>K</span>, <span style=color:#50fa7b>MutableList</span>&lt;<span style=color:#50fa7b>V</span>&gt;&gt;&gt; <span style=color:#50fa7b>Iterable</span>&lt;T&gt;.groupByTo(destination: M, keySelector: (T) <span style=color:#ff79c6>-&gt;</span> K, valueTransform: (T) <span style=color:#ff79c6>-&gt;</span> V): M {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (element <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>this</span>) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>val</span> key = keySelector(element)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>val</span> list = destination.getOrPut(key) { ArrayList&lt;V&gt;() }
</span></span><span style=display:flex><span>        list.add(valueTransform(element))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> destination
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ここで確かになっていることは、やはり最初のCollectionの要素数分、<code>keySelector</code>と<code>valueTransform</code>を実行しているということです。Mapに変えることになるので、<code>reduce</code>の時とは違ってMemberレコードがいくつあっても一つに集約されるような事態は起こらないと考えられますが、依然としてオブジェクトのインスタンスが複数できてしまうという問題はあります。なので、また他の方法を探してみましょう。</p><h3 id=map>Map</h3><p>最後に考えられるのは、Selectした行をMapにまとめるのではなく、外部にMapを宣言し、それを利用することです。Mapには、<code>compute</code>という関数があり、引数として渡したkeyに対してどんな処理をするか（どんなvalueを作って入れるか）を指定できます。例えば、指定したkeyに対してvalueが存在しない場合は要素として追加し、存在する場合はそのvalueを変えるなどの処理ができるようになります。なので、これをうまく使うとインスタンスの生成問題を解決できる気がしますね。</p><p>トランザクションとは関係のないMapをまず宣言し、Selectしたデータに対して<code>compute</code>を実行することにします。<code>compute</code>では指定したkey（Memberのidなど）がMapの中にない場合にMemberのインスタンスを作成するようにして、すでにある場合はそのオブジェクトにMailingのデータを追加するようにすれば良いでしょう。そしてループが終わったらMapのvalueのみを取得すると良いですね。</p><p>以上のことを、コードで表すと以下のようになります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// オブジェクトをまとめるためのMap（keyはMember.id）
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> helperMap = mutableMapOf&lt;Int, MemberDto&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>transaction {
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>Member</span>.leftJoin(Mailing)
</span></span><span style=display:flex><span>        .select {
</span></span><span style=display:flex><span>            (<span style=color:#50fa7b>Member</span>.id eq id) and (<span style=color:#50fa7b>Mailing</span>.memberId eq <span style=color:#50fa7b>Mailing</span>.id)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        .forEach {
</span></span><span style=display:flex><span>            helperMap.compute(<span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Member</span>.id].<span style=color:#ff79c6>value</span>) { key, <span style=color:#ff79c6>value</span> <span style=color:#ff79c6>-&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// valueがnullではない場合、コピーしてmailingAddressを累計
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                <span style=color:#ff79c6>value</span><span style=color:#ff79c6>?.</span>copy(
</span></span><span style=display:flex><span>                    mailingAddress = <span style=color:#ff79c6>value</span>.mailingAddress + <span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Mailing</span>.address]
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// valueがnullの場合はインスタンスを作る
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>                ) <span style=color:#ff79c6>?:</span> MemberDto(
</span></span><span style=display:flex><span>                    id = key,
</span></span><span style=display:flex><span>                    name = <span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Member</span>.name],
</span></span><span style=display:flex><span>                    mailingAddress = listOf(<span style=color:#ff79c6>it</span>[<span style=color:#50fa7b>Mailing</span>.address])
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }.let {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// valueをListに変換
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            helperMap.map { <span style=color:#ff79c6>it</span>.<span style=color:#ff79c6>value</span> }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>いかがでしょうか。これで重複するデータなく、インスタンスの作成も最低限に抑えることができたかと思います。もちろん、mailingAddressを追加するたびにコピーが発生するという問題はありますが、ここは専用のsetterなどを作っておくことで回避できると思います。</p><p>一つ注意しなくてはならないのは、ここで使っているMapをフィールドとして宣言したりするとデータの整合性やアプリケーションのメモリ使用量に響くということです。なので必ずメソッドの中でのみMapのインスタンスが作成されるようにする必要があります。</p><h2 id=最後に>最後に</h2><p>DSLを使ってクエリを直接作成する場合、JPAのようなORMの問題とされているN+1(必ず連関しているテーブルもjoinしてくる)のような問題を回避できますが、直接オブジェクトへのマッピングも書かなくてはならないという短所がありますね。個人的にクエリを書くのは楽しくないですが、クエリをコードとして管理でき、必要なクエリだけを書けるというところでDSLの方が良い点もあると思います。テーブルの構造や処理によってはORMが勝手にクエリもマッピングもしてくれるのが楽ではありますが。</p><p>ただ、ORMでどうやってデータを取得するかの問題だけでなく、ここで扱った「重複するデータをどう違う形のデータに加工するか」の問題は、必ずしもDBからレコードを取得する場合のみのことに限らないので（例えば他のAPIを読んだ結果としてもそんなデータはあり得ますね）、色々方法を考えておく必要はありそうです。今の時点ではMapを利用した方法がもっとも良さそうな気がしますが、他にもっと効率的な方法があるかもしれませんしね。</p><p>では、また！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/kotlin/>kotlin</a>
<a href=/tags/exposed/>exposed</a>
<a href=/tags/map/>map</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/posts/ktor-first-impression/><div class=article-image><img src=/../../images/ktor.jpg loading=lazy data-key data-hash=/../../images/ktor.jpg></div><div class=article-details><h2 class=article-title>Ktorを触ってみた</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2023 Korean-man in Tokyo</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.7.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#テーブルごとにselectする>テーブルごとにSelectする</a></li><li><a href=#joinしてマッピングする>joinしてマッピングする</a><ol><li><a href=#reduce>reduce</a></li><li><a href=#groupby>groupBy</a></li><li><a href=#map>Map</a></li></ol></li><li><a href=#最後に>最後に</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>