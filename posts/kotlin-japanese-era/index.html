<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="帳票などで、たまに和暦を処理する必要な時がありますね。例えば元号を表記するとか、和暦の年度を表記するなどの場合があるかと思います。Kotli"><title>Kotlinで和暦を使う</title><link rel=canonical href=https://retheviper.github.io/posts/kotlin-japanese-era/><link rel=stylesheet href=/scss/style.min.fbb68fe51fb77bdd639dccfe1c7b590d2330cf8b81da91f1585b35c3d07fbac8.css><meta property="og:title" content="Kotlinで和暦を使う"><meta property="og:description" content="帳票などで、たまに和暦を処理する必要な時がありますね。例えば元号を表記するとか、和暦の年度を表記するなどの場合があるかと思います。Kotli"><meta property="og:url" content="https://retheviper.github.io/posts/kotlin-japanese-era/"><meta property="og:site_name" content="Korean-man in Tokyo"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="kotlin"><meta property="article:tag" content="java"><meta property="article:published_time" content="2021-12-05T00:00:00+00:00"><meta property="article:modified_time" content="2021-12-05T00:00:00+00:00"><meta property="og:image" content="https://retheviper.github.io/images/kotlin.jpg"><meta name=twitter:title content="Kotlinで和暦を使う"><meta name=twitter:description content="帳票などで、たまに和暦を処理する必要な時がありますね。例えば元号を表記するとか、和暦の年度を表記するなどの場合があるかと思います。Kotli"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://retheviper.github.io/images/kotlin.jpg"><link rel=apple-touch-icon sizes=57x57 href=/favicon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/favicon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/favicon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/favicon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/favicon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/favicon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/favicon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/favicon/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><script async src="https://www.googletagmanager.com/gtag/js?id=G-BYJBEJB6DX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BYJBEJB6DX",{anonymize_ip:!1})}</script></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/kotlin-japanese-era/><img src=/../../images/kotlin.jpg loading=lazy alt="Featured image of post Kotlinで和暦を使う"></a></div><div class=article-details><header class=article-category><a href=/categories/kotlin/ style=background-color:#2a9d8f;color:#fff>kotlin</a></header><h2 class=article-title><a href=/posts/kotlin-japanese-era/>Kotlinで和暦を使う</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Dec 05, 2021</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>9 minute read</time></div></footer></div></header><section class=article-content><p>帳票などで、たまに和暦を処理する必要な時がありますね。例えば元号を表記するとか、和暦の年度を表記するなどの場合があるかと思います。Kotlin(JVM)の場合、西暦だとJavaのAPIの<code>Date</code>や<code>LocalDate</code>などのAPIを使うと簡単ですが、和暦が必要となるのはごく一部のケースなので方法がなかなか分かりづらいかと思います。なので、今回はKotlinで和暦を扱う方法について少しまとめてみました。</p><h2 id=japanseera--japanesedate>JapanseEra / JapaneseDate</h2><p>Javaでは、1.8から和暦で日付を扱える<a class=link href=https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseDate.html target=_blank rel=noopener>JapaneseDate</a>及び元号を扱える<a class=link href=https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseEra.html target=_blank rel=noopener>JapaneseEra</a>というAPIを提供しています。なので<code>JapaneseDate</code>のインスタンスを作り、そこから<code>JapaneseEra</code>を取得することで簡単に元号の情報を取得できるようになります。実際の使い方は以下の通りです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// 現在日付のJapaneseDateを取得
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> japaneseDate = JapaneseDate.now()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// JapaneseEraの取得
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> japaneseEra = japaneseDate.era
</span></span></code></pre></div><p><code>JapaneseDate</code>の場合、<code>LocalDate</code>と同じく<a class=link href=https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/chrono/ChronoLocalDate.html target=_blank rel=noopener>ChronoLocalDate</a>を継承しているのでインスタンスを作成する方法はそう変わりません。なので、以下のようなこともできます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// LocalDateをJapaneseDateに変換
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> japaneseDateFromLocalDate = JapaneseDate.from(LocalDate.now())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 特定の日付を指定してJapaneseDate
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> japaneseDateFromSpecificDate = JapaneseDate.of(<span style=color:#bd93f9>2000</span>, <span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>31</span>)
</span></span></code></pre></div><h2 id=元号を日本語で表記する>元号を日本語で表記する</h2><p>和暦を扱う場合にやりたいことは大きく二つかと思います。一つは、元号を文字列として扱うこと、そしてもう一つは、和暦での年度を数字として扱うことです。まずは、元号を文字列として取得できる方法について説明します。</p><p>まず上記で紹介した通り、<code>JapaneseDate</code>のインスタンスを取得した上で、さらにそのオブジェクトが保持している<code>JapaneseEra</code>を取得する必要があります。その後、<code>JapaneseEra.getDisplayName()</code>という関数に<a class=link href=https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/TextStyle.html target=_blank rel=noopener>TextStyle</a>と<a class=link href=https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/Locale.html target=_blank rel=noopener>Locale</a>を指定して文字列を取得することができます。前者は文字の出力型を指定する列挙型定数で、後者は言語の指定と思ってください。</p><p><code>TextStyle</code>の場合、以下のような値があります。他の言語だと指定したものによって出力がかなり変わってくるかも知れませんが、日本語の場合は<code>FULL</code>と<code>NARROW</code>だけで十分ではないかと思います。</p><div class=table-wrapper><table><thead><tr><th>定数</th><th>出力例</th></tr></thead><tbody><tr><td><code>FULL</code></td><td>昭和</td></tr><tr><td><code>FULL_STANDALONE</code></td><td>昭和</td></tr><tr><td><code>NARROW</code></td><td>S</td></tr><tr><td><code>NARROW_STANDALONE</code></td><td>S</td></tr><tr><td><code>SHORT</code></td><td>昭和</td></tr><tr><td><code>SHORT_STANDALONE</code></td><td>昭和</td></tr></tbody></table></div><p><code>Locale</code>の場合、<code>Locale.JAPAN</code>や<code>Locale.JAPANESE</code>のどちらを指定しても結果は同じです。ただ、実装としては以下のようになるのでなるべく<code>Locale.JAPAN</code>を使った方が良さそうです。</p><div class=table-wrapper><table><thead><tr><th>Locale</th><th>作られるBaseLocaleの設定</th></tr></thead><tbody><tr><td><code>JAPAN</code></td><td><code>language = ja, region = JP</code></td></tr><tr><td><code>JAPANESE</code></td><td><code>language = ja</code></td></tr></tbody></table></div><p>以下はこれらの定数を渡して元号を文字列として取得する例です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> today = JapaneseDate.now()
</span></span><span style=display:flex><span><span style=color:#ff79c6>val</span> era = today.era
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 元号を漢字で取得
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> eraName = era.getDisplayName(TextStyle.FULL, Locale.JAPAN) <span style=color:#6272a4>// 令和
</span></span></span></code></pre></div><p>元号だけでなく、年度までも合わせて表記したい場合もあるかと思います。その場合に使えるものは<a class=link href=https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/format/DateTimeFormatter.html target=_blank rel=noopener>DateTimeFormatter</a>です。これも<code>JapaneseDate</code>が実質<code>LocalDate</code>と同じく<code>ChronoLocalDate</code>を継承しているから可能なことですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// 日付を日本語で表記する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> formatter = DateTimeFormatter.ofPattern(<span style=color:#f1fa8c>&#34;Gy年&#34;</span>, Locale.JAPAN)
</span></span><span style=display:flex><span><span style=color:#ff79c6>val</span> todayString = formatter.format(JapaneseDate.now()) <span style=color:#6272a4>// 令和3年
</span></span></span></code></pre></div><p>もしJava 1.8以前のバージョンを使うなどで<code>LocalDate</code>や<code>JapaneseDate</code>が使えなく、<code>java.util.Date</code>の方を使うしかない場合は、以下のような方法で年号と年度の取得が可能です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> format = SimpleDateFormat(<span style=color:#f1fa8c>&#34;Gy年&#34;</span>, Locale(<span style=color:#f1fa8c>&#34;Ja&#34;</span>, <span style=color:#f1fa8c>&#34;JP&#34;</span>, <span style=color:#f1fa8c>&#34;JP&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#ff79c6>val</span> year = format.format(Date()) <span style=color:#6272a4>// 令和3年
</span></span></span></code></pre></div><p><code>java.util.Date</code>を使う場合は、<code>Locale</code>に第3引数の<code>variant</code>まで指定する必要があるので、既存の列挙型として定義されたものは使えません。</p><p>また、<code>Locale.ENGLISH</code>などに設定すると、<code>JapaenseDate</code>を使っている場合でも取得した結果は<code>AD2021年12月5日</code>になります。</p><h3 id=合字で表記する>合字で表記する</h3><p>年号については、Unicodeで合字を取得して使いたい場合もあるかと思います。その場合は、以下のようにUnicodeのMapなどを定義しておいて取得するのが良いかと思います。拡張関数などを定義するのも良いでしょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> eraUnicodeMap = mapOf(
</span></span><span style=display:flex><span>    JapaneseEra.MEIJI to <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\u337e</span><span style=color:#f1fa8c>&#34;</span>, <span style=color:#6272a4>// ㍾
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    JapaneseEra.TAISHO to <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\u337d</span><span style=color:#f1fa8c>&#34;</span>, <span style=color:#6272a4>// ㍽
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    JapaneseEra.SHOWA to <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\u337c</span><span style=color:#f1fa8c>&#34;</span>, <span style=color:#6272a4>// ㍼
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    JapaneseEra.HEISEI to <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\u337b</span><span style=color:#f1fa8c>&#34;</span>, <span style=color:#6272a4>// ㍻
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    JapaneseEra.REIWA to <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>\u32ff</span><span style=color:#f1fa8c>&#34;</span> <span style=color:#6272a4>// ㋿
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>val</span> era = JapaneseDate.now().era
</span></span><span style=display:flex><span><span style=color:#6272a4>// 元号を合字で取得する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> eraUnicode = eraUnicodeMap[era] <span style=color:#6272a4>// ㋿
</span></span></span></code></pre></div><p>上記のサンプルでは<code>JapaneseEra</code>が列挙型なのでそのままキーとしていますが、<code>JapaneseEra</code>は数値としての情報も持っているのでそちらを使う方法もあるでしょう。それぞれの値に対する数値は以下の通りです。</p><div class=table-wrapper><table><thead><tr><th>JapaneseEra</th><th>数値</th></tr></thead><tbody><tr><td>MEIJI</td><td>-1</td></tr><tr><td>TAISHO</td><td>0</td></tr><tr><td>SHOWA</td><td>1</td></tr><tr><td>HEISEI</td><td>2</td></tr><tr><td>REIWA</td><td>3</td></tr></tbody></table></div><p>2021年から2022年の3月の場合は令和3年なので、<code>JapaneseEra.REIWA.value</code>の値が年度だと勘違いされやすいかなと思います。実際の年度の情報は<code>JapaneseDate</code>の方にあるので注意しましょう。</p><h2 id=年度を数字で表示する>年度を数字で表示する</h2><p><code>JapaneseEra</code>は元号を得るために使う列挙型定数のクラスなので、これ自体は<code>JapaneseDate</code>の日付情報を持っていません。なので参照できる情報は、あくまでも元となる<code>JapaneseDate</code>が属した元号の情報のみです。</p><p>なので数値としての年度は、列挙型の<a class=link href=https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/temporal/ChronoField.html target=_blank rel=noopener>ChronoField</a>を<code>JapaneseDate.get()</code>に渡して取得する必要があります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> today = JapaneseDate.of(<span style=color:#bd93f9>2010</span>, <span style=color:#bd93f9>12</span>, <span style=color:#bd93f9>31</span>) <span style=color:#6272a4>// 平成22年
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 年度をIntとして取得する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> year = today.<span style=color:#ff79c6>get</span>(ChronoField.YEAR) <span style=color:#6272a4>// 2010
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> yearOfHeisei = today.<span style=color:#ff79c6>get</span>(ChronoField.YEAR_OF_ERA) <span style=color:#6272a4>// 22
</span></span></span></code></pre></div><p>これは<code>JapaneseDate</code>が<code>LocalDate</code>と違って、直接<code>year</code>をgetterで取得できないからです。実際オブジェクトの中を覗いてみると、<code>LocalDate</code>は年月日をintとshortのフィールドとして保持していることに対して、<code>JapaneseDate</code>は<code>LocalDate</code>とint型の<code>yearOfEra</code>を持っていて、<code>get(ChronoField.YEAR_OF_ERA)</code>を通じてはじめて<code>yearOfEra</code>を取得できることになります。getterを用意していないのはおそらく<code>LocalDate</code>と<code>yearOfEra</code>という二つの概念があるからなのではないかと思います。もちろん、Kotlinなのでこれは簡単に拡張関数を書くことでgetterを作ることはできますね。</p><p>また、日付のオブジェクトとして<code>LocalDate</code>を使っている場合は場合は<code>ChronoField.YEAR_OF_ERA</code>を渡しても西暦の年度が返ってくるので、和暦を使うために<code>JapaneseDate</code>を使っているかどうかをまず確認しましょう。</p><h3 id=年度を2桁の文字で表示する>年度を2桁の文字で表示する</h3><p>厳密に言って和暦とは関係のないことですが、年度を取得して使う場合、一貫して先端に「0」のついた2桁の文字列として扱いたい場合もあるかと思います。<code>JapaneseDate</code>を通じて年度を取得した場合は<code>Int</code>型になるので、1〜9の間は1桁の数字となるわけですが、これを01〜09に表示したい場合は以下の方法が使えます。</p><h4 id=decimalformatを利用する>DecimalFormatを利用する</h4><p>一つは、JavaのAPIである<a class=link href=https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/text/DecimalFormat.html target=_blank rel=noopener>DecimalFormat</a>を使うことです。小数点の範囲などをわかりやすく指定できるので個人的には好むやり方です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> today = JapaneseDate.now() <span style=color:#6272a4>// 令和3年
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 数字を表示するためのフォーマットを指定
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> decimalFormat = DecimalFormat(<span style=color:#f1fa8c>&#34;00&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>val</span> year = decimalFormat.format(today) <span style=color:#6272a4>// 03
</span></span></span></code></pre></div><h4 id=stringformatを利用する>String.formatを利用する</h4><p>もう一つの方法は、Kotlinのスタンダードライブラリの機能である<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/format.html target=_blank rel=noopener>String.format()</a>を使うことです。性能注視なら、こちらの方法が良いかなと思います。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> today = JapaneseDate.now() <span style=color:#6272a4>// 令和3年
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 数字を表示するためのフォーマットを指定
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> year = <span style=color:#f1fa8c>&#34;%02d&#34;</span>.format(today) <span style=color:#6272a4>// 03
</span></span></span></code></pre></div><h2 id=番外kotlinx-datetime>番外：kotlinx-datetime</h2><p>Kotlinには元々日付や時間を扱うAPIがなかったのですが、2020年から<a class=link href=https://github.com/Kotlin/kotlinx-datetime target=_blank rel=noopener>kotlinx-datetime</a>を提供しています。なのでKotlin/JSやKotlin/Nativeなど、JVM上で動かない場合でも日付を扱える公式のAPIができたわけですが、いくつかの懸念があるのでこれを導入するには検討が必要かと思います。</p><h3 id=pre-releaseの段階>Pre-releaseの段階</h3><p><code>kotlinx-datetime</code>はまだpre-releaseの段階で、2021年10月に<code>v0.3.1</code>がリリースされています。なので色々とバグがあったり、思い通りにならない可能性があります。また、開発途中のものなので仕方ありませんが、現時点で提供している機能も<code>java.time</code>のAPIに比べて少なく、簡単に年号の計算などができるわけではありません。今は必要最低限の機能だけを提供していると思って良いでしょう。</p><h3 id=マルチプラットフォーム向け>マルチプラットフォーム向け</h3><p>Kotlinのスタンダードライブラリ、及び<code>kotlinx</code>として提供されるライブラリはマルチプラットホームを考慮した実装となっているため、プラットホームが違っても同じ使い方ができるというメリットがありますが、かえってデメリットになる場合もあります。実際、<code>kotlinx-datetime</code>のJVMの実装は内部的に<code>jata.time</code>のAPIに依存しているため、JVMだけを使う場合はあえて導入する必要がないともいえます。</p><p>また、プラットフォームごとに実装が違うということはどこかで予期せぬ例外が発生したり、期待した結果にならないケースも発生しえる、ということにもなるかと思います。</p><h2 id=javatimeの懸念>java.timeの懸念</h2><p><code>JapaneseEra</code>では明治以前（慶応など）の元号は使えませんが、おそらくその理由は和暦でグレゴリウス暦が使われたのは明治からだったという歴史的な背景があるのではないかと思います。また、<code>JapaneseDate</code>でも明治6年(西暦1873年1月1日)以前の日付を指定すると以下のように例外が発生します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Exception in thread <span style=color:#f1fa8c>&#34;main&#34;</span> java.time.DateTimeException: JapaneseDate before Meiji <span style=color:#bd93f9>6</span> is not supported
</span></span><span style=display:flex><span>	at java.base/java.time.chrono.JapaneseDate.&lt;init&gt;<span style=color:#ff79c6>(</span>JapaneseDate.java:333<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>	at java.base/java.time.chrono.JapaneseDate.of<span style=color:#ff79c6>(</span>JapaneseDate.java:257<span style=color:#ff79c6>)</span>
</span></span></code></pre></div><p>なので、単純に帳票を作るなどのケースでなく、歴史的な研究のための日付計算ではここで紹介した方法は使えないケースもあるかと思います。</p><p>また、JDKのバージョンなどの問題があるためか、<code>JapaneseEra.REIWA</code>の取得ができなく、エラーとなるケースがあるので注意する必要があります。この場合でも<code>value</code>の値の取得は問題ないので、少し可読性は低下しながら分岐などの判定に定数をそのまま使うのは避けたほうが良さそうです。（正確な理由はわかりませんが…）</p><h2 id=最後に>最後に</h2><p>いかがでしたか。少し興味本位で調べ始めたもののまとめではありますが、本業の方で実際に必要な処理でもあり、これをどうやって拡張関数として落とせるかということも考えられる良い機会となったかなと思っています。</p><p>また、JavaのAPIに関しては<a class=link href=https://qiita.com/yamadamn/items/56e7370bae2ceaec55d5 target=_blank rel=noopener>Javaバージョン別の改元(新元号)対応まとめ</a>という良い記事があったので、興味のある方はご一読ください。</p><p>では、また！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/kotlin/>kotlin</a>
<a href=/tags/java/>java</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/posts/kotlin-write-csv/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>data classのListをCSVにする</h2></div></a></article><article class=has-image><a href=/posts/kotlin-prospect/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinのこれからを語る</h2></div></a></article><article class=has-image><a href=/posts/effective-kotlin/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Effective Kotlinを読む</h2></div></a></article><article class=has-image><a href=/posts/kotlin-hidden-cost-3/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinの隠されたコストーその３</h2></div></a></article><article class=has-image><a href=/posts/kotlin-hidden-cost-2/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinの隠されたコストーその２</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2022 Korean-man in Tokyo</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.7.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#japanseera--japanesedate>JapanseEra / JapaneseDate</a></li><li><a href=#元号を日本語で表記する>元号を日本語で表記する</a><ol><li><a href=#合字で表記する>合字で表記する</a></li></ol></li><li><a href=#年度を数字で表示する>年度を数字で表示する</a><ol><li><a href=#年度を2桁の文字で表示する>年度を2桁の文字で表示する</a><ol><li><a href=#decimalformatを利用する>DecimalFormatを利用する</a></li><li><a href=#stringformatを利用する>String.formatを利用する</a></li></ol></li></ol></li><li><a href=#番外kotlinx-datetime>番外：kotlinx-datetime</a><ol><li><a href=#pre-releaseの段階>Pre-releaseの段階</a></li><li><a href=#マルチプラットフォーム向け>マルチプラットフォーム向け</a></li></ol></li><li><a href=#javatimeの懸念>java.timeの懸念</a></li><li><a href=#最後に>最後に</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>