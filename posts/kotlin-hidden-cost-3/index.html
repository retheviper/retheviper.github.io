<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Kotlinの隠されたコスト、その最後の記事となります。今までの記事もかなり興味深かったですが、今回はさらにKotlinならではの機能に触れ"><title>Kotlinの隠されたコストーその３</title><link rel=canonical href=https://retheviper.github.io/posts/kotlin-hidden-cost-3/><link rel=stylesheet href=/scss/style.min.fbb68fe51fb77bdd639dccfe1c7b590d2330cf8b81da91f1585b35c3d07fbac8.css><meta property="og:title" content="Kotlinの隠されたコストーその３"><meta property="og:description" content="Kotlinの隠されたコスト、その最後の記事となります。今までの記事もかなり興味深かったですが、今回はさらにKotlinならではの機能に触れ"><meta property="og:url" content="https://retheviper.github.io/posts/kotlin-hidden-cost-3/"><meta property="og:site_name" content="Korean-man in Tokyo"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="kotlin"><meta property="article:tag" content="java"><meta property="article:published_time" content="2021-11-28T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-28T00:00:00+00:00"><meta property="og:image" content="https://retheviper.github.io/images/kotlin.jpg"><meta name=twitter:title content="Kotlinの隠されたコストーその３"><meta name=twitter:description content="Kotlinの隠されたコスト、その最後の記事となります。今までの記事もかなり興味深かったですが、今回はさらにKotlinならではの機能に触れ"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://retheviper.github.io/images/kotlin.jpg"><link rel=apple-touch-icon sizes=57x57 href=/favicon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/favicon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/favicon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/favicon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/favicon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/favicon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/favicon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/favicon/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><script async src="https://www.googletagmanager.com/gtag/js?id=G-BYJBEJB6DX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-BYJBEJB6DX',{anonymize_ip:!1})}</script></head><body class="article-page has-toc"><script>(function(){const e='StackColorScheme';localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t='StackColorScheme',e=localStorage.getItem(t),n=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;e=='dark'||e==='auto'&&n?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/kotlin-hidden-cost-3/><img src=/../../images/kotlin.jpg loading=lazy alt="Featured image of post Kotlinの隠されたコストーその３"></a></div><div class=article-details><header class=article-category><a href=/categories/kotlin/ style=background-color:#2a9d8f;color:#fff>kotlin</a></header><h2 class=article-title><a href=/posts/kotlin-hidden-cost-3/>Kotlinの隠されたコストーその３</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Nov 28, 2021</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>11 minute read</time></div></footer></div></header><section class=article-content><p>Kotlinの隠されたコスト、その最後の記事となります。今までの記事もかなり興味深かったですが、今回はさらにKotlinならではの機能に触れているので、Kotlinそのものに対する理解も含めてみる必要があり、さらに深い内容となっているかと思います。</p><p>今回のアジェンダは、「委譲プロパティ」と「rangeを使ったループ」になります。この記事は<a class=link href=https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-3-3bf6e0dbf0a4 target=_blank rel=noopener>Exploring Kotlin’s hidden costs - Part 3</a>の内容を要約したものです。</p><h2 id=委譲プロパティ>委譲プロパティ</h2><p><a class=link href=https://kotlinlang.org/docs/delegated-properties.html target=_blank rel=noopener>委譲プロパティ</a>とは、<code>getter</code>と<code>setter</code>が<code>委譲(delegate)</code>というオブジェクトによって実装された<a class=link href=https://kotlinlang.org/docs/properties.html target=_blank rel=noopener>プロパティ</a>を指します。これによって再利用可能なカスタムプロパティを作ることができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Example</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>var</span> p: String <span style=color:#ff79c6>by</span> Delegate()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>委譲オブジェクトはプロパティの設定と読み込みのため<code>getValue()</code>と<code>setValue()</code>を実装する必要があります。そしてこれらの関数はプロパティのメタデータ（プロパティ名）とオブジェクトのインスタンスを引数として必要とします。</p><p>クラスが委譲プロパティとして定義されると、コンパイラは下記のようなコードを生成します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>Example</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   @NotNull
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>final</span> Delegate p$delegate <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> Delegate<span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>   <span style=color:#6272a4>// $FF: 生成されたフィールド
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>   <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>final</span> KProperty<span style=color:#ff79c6>[]</span> $$delegatedProperties <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> KProperty<span style=color:#ff79c6>[]{(</span>KProperty<span style=color:#ff79c6>)</span>Reflection<span style=color:#ff79c6>.</span><span style=color:#50fa7b>mutableProperty1</span><span style=color:#ff79c6>(</span><span style=color:#ff79c6>new</span> MutablePropertyReference1Impl<span style=color:#ff79c6>(</span>Reflection<span style=color:#ff79c6>.</span><span style=color:#50fa7b>getOrCreateKotlinClass</span><span style=color:#ff79c6>(</span>Example<span style=color:#ff79c6>.</span><span style=color:#50fa7b>class</span><span style=color:#ff79c6>),</span> <span style=color:#f1fa8c>&#34;p&#34;</span><span style=color:#ff79c6>,</span> <span style=color:#f1fa8c>&#34;getP()Ljava/lang/String;&#34;</span><span style=color:#ff79c6>))};</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   @NotNull
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> String <span style=color:#50fa7b>getP</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>p$delegate</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>getValue</span><span style=color:#ff79c6>(</span><span style=color:#ff79c6>this</span><span style=color:#ff79c6>,</span> $$delegatedProperties<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>]);</span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>setP</span><span style=color:#ff79c6>(</span>@NotNull String var1<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      Intrinsics<span style=color:#ff79c6>.</span><span style=color:#50fa7b>checkParameterIsNotNull</span><span style=color:#ff79c6>(</span>var1<span style=color:#ff79c6>,</span> <span style=color:#f1fa8c>&#34;&lt;set-?&gt;&#34;</span><span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>p$delegate</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>setValue</span><span style=color:#ff79c6>(</span><span style=color:#ff79c6>this</span><span style=color:#ff79c6>,</span> $$delegatedProperties<span style=color:#ff79c6>[</span>0<span style=color:#ff79c6>],</span> var1<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>一部staticプロパティのメタデータがクラスに追加されます。そして毎回値の設定と読み込みが発生するたびにコンストラクタによる初期化が起こります。</p><h3 id=委譲インスタンス>委譲インスタンス</h3><p>上記サンプルでは新しい委譲のインスタンスがプロパティの実装のため生成されています。委譲がstatefulの場合にこのようになります。たとえはローカルで計算されたプロパティを使うなどの場合です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>StringDelegate</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>var</span> cache: String? = <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>operator</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>getValue</span>(thisRef: Any?, <span style=color:#ff79c6>property</span>: KProperty&lt;*&gt;): String {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>var</span> result = cache
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> (result <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>null</span>) {
</span></span><span style=display:flex><span>            result = someOperation()
</span></span><span style=display:flex><span>            cache = result
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> result
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>またコンストラクタに追加のパラメータが渡されると、新しい委譲のインスタンスが必要となります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Example</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> nameView <span style=color:#ff79c6>by</span> BindViewDelegate&lt;TextView&gt;(R.id.name)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>statelessであり、すでに渡されたオブジェクトのインスタンスとプロパティ名を保ちたいだけなら委譲クラスに<code>object</code>をつけてsingletonにする方法があります。たとえば下記のようなものです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>object</span> <span style=color:#50fa7b>FragmentDelegate</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>operator</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>getValue</span>(thisRef: Activity, <span style=color:#ff79c6>property</span>: KProperty&lt;*&gt;): Fragment? {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> thisRef.fragmentManager.findFragmentByTag(<span style=color:#ff79c6>property</span>.name)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>また既存のオブジェクトを拡張して委譲することもできます。つまり、<code>getValue()</code>や<code>setValue()</code>を拡張関数として定義することもできるということです。Kotlinではすでに<code>Map</code>と<code>MutableMap</code>に拡張関数として委譲するパターンを使っています。（プロパティ名をキーで使っています）</p><p>もし一つのクラス内でローカルの委譲インスタンスに複数のプロパティを保持して再利用したいなら、そのクラスのコンストラクタでインスタンスを初期化しましょう。</p><p>Kotlin 1.1以降、<a class=link href=https://kotlinlang.org/docs/delegated-properties.html#local-delegated-properties target=_blank rel=noopener>関数内のローカル変数を委譲プロパティにする</a>こともできます。この場合、委譲は後で初期化できます。</p><p>クラスに定義された委譲プロパティごとにオーバーヘッドとメタデータの追加が発生するのでなるべくプロパティを再利用できるようにした方が良いでしょう。また、定義したい項目が多い場合に、果たして委譲プロパティが良い選択肢であるかを考慮すべきです。</p><h3 id=ジェネリック委譲>ジェネリック委譲</h3><p>委譲関数はジェネリックでも定義できます。なので委譲クラスをさまざまな型のプロパティとして定義することもできます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>private</span> <span style=color:#ff79c6>var</span> maxDelay: Long <span style=color:#ff79c6>by</span> SharedPreferencesDelegate&lt;Long&gt;()
</span></span></code></pre></div><p>ただ、上記のようにprimitiveをジェネリック委譲を使う場合、<code>boxing</code>と<code>unboxing</code>が値の指定と読み込みで発生することに注意する必要があります。これはプロパティがnon-nullの場合でも起こることです。</p><p>なのでnon-nullなprimitive型の委譲プロパティを定義する場合はジェネリックで定義を避けたほうが良いです。</p><h3 id=スタンダード委譲lazy>スタンダード委譲（lazy()）</h3><p>Kotlinでは<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html target=_blank rel=noopener>Delegates.notNull()</a>、<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html target=_blank rel=noopener>Delegates.observable()</a>や<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html target=_blank rel=noopener>lazy()</a>のような委譲のための標準機能が存在しています。</p><p><code>lazy()</code>は読み込み専用の委譲プロパティのための関数です。初めて読み込みが発生する際、プロパティを初期化するた目にlambdaを指定できます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> dateFormat: DateFormat <span style=color:#ff79c6>by</span> lazy {
</span></span><span style=display:flex><span>    SimpleDateFormat(<span style=color:#f1fa8c>&#34;dd-MM-yyyy&#34;</span>, Locale.getDefault())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>これはその値が実際に読み込まれるまで高いコストの初期化を遅延させるという、パフォーマンスと可読性の側面で優れた方法です。</p><p>ただ、<code>lazy()</code>はinline関数ではなく、引数として渡されたlambdaは別の<code>Function</code>クラスとしてコンパイルされ、戻り値の委譲オブジェクトもまたinline化されないことには注意する必要があります。</p><p>そして<code>lazy()</code>関数で見逃しやすいのは<code>mode</code>という引数で戻り値の委譲タイプを決められるということです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>&gt; <span style=color:#50fa7b>lazy</span>(initializer: () <span style=color:#ff79c6>-&gt;</span> T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>&gt; <span style=color:#50fa7b>lazy</span>(mode: LazyThreadSafetyMode, initializer: () <span style=color:#ff79c6>-&gt;</span> T): Lazy&lt;T&gt; =
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>when</span> (mode) {
</span></span><span style=display:flex><span>            LazyThreadSafetyMode.SYNCHRONIZED <span style=color:#ff79c6>-&gt;</span> SynchronizedLazyImpl(initializer)
</span></span><span style=display:flex><span>            LazyThreadSafetyMode.PUBLICATION <span style=color:#ff79c6>-&gt;</span> SafePublicationLazyImpl(initializer)
</span></span><span style=display:flex><span>            LazyThreadSafetyMode.NONE <span style=color:#ff79c6>-&gt;</span> UnsafeLazyImpl(initializer)
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p><code>mode</code>を指定していない場合、デフォルトとしては<code>LazyThreadSafetyMode.SYNCHRONIZED</code>が使われますが、これは複数のスレッドで初期化ブロックが安全に実行されることを保証するためにコストの高い<code>double-checked lock</code>を行います。</p><p>シングルスレッドしかプロパティに対するアクセスがないというのがわかっているなら、無駄なロックは下げた方がいいでしょう。こういう場合は<code>LazyThreadSafetyMode.NONE</code>を使えます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> dateFormat: DateFormat <span style=color:#ff79c6>by</span> lazy(LazyThreadSafetyMode.NONE) {
</span></span><span style=display:flex><span>    SimpleDateFormat(<span style=color:#f1fa8c>&#34;dd-MM-yyyy&#34;</span>, Locale.getDefault())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ranges>Ranges</h2><p><a class=link href=https://kotlinlang.org/docs/ranges.html target=_blank rel=noopener>Ranges</a>で限定された範囲の値のセットを定義できます。この値は<code>Comparable</code>なものならなんでも指定できますね。そして、この表現式を使うと<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-closed-range/ target=_blank rel=noopener>ClosedRange</a>というインタフェースの実装ができることになります。</p><h3 id=包含テスト>包含テスト</h3><p>rangeを使って範囲内に特定の値が含まれているかどうかを<code>in</code>や<code>!in</code>を使って検知することができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>in</span> <span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>10</span>) {
</span></span><span style=display:flex><span>    println(i)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>rangeはnon-nullなprimitive型（<code>Int</code>, <code>Long</code>, <code>Byte</code>, <code>Short</code>, <code>Float</code>, <code>Double</code>, <code>Char</code>）に対する最適化が行われるので、コンパイルされた結果は以下のようになります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#ff79c6>if</span><span style=color:#ff79c6>(</span>1 <span style=color:#ff79c6>&lt;=</span> i <span style=color:#ff79c6>&amp;&amp;</span> i <span style=color:#ff79c6>&lt;=</span> 10<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>i<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>なので、オーバーヘッドや追加オブジェクトの割り当てなどは起こらないです。しかし、primitiveではない場合はどうでしょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>if</span> (name <span style=color:#ff79c6>in</span> <span style=color:#f1fa8c>&#34;Alfred&#34;</span><span style=color:#ff79c6>..</span><span style=color:#f1fa8c>&#34;Alicia&#34;</span>) {
</span></span><span style=display:flex><span>    println(name)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kotlin 1.1.50以前はコンパイル時に<code>ClosedRange</code>オブジェクトが常に生成されました。しかし、1.1.50からは以下のようになります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>if</span>(name.compareTo(<span style=color:#f1fa8c>&#34;Alfred&#34;</span>) <span style=color:#ff79c6>&gt;=</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>if</span>(name.compareTo(<span style=color:#f1fa8c>&#34;Alicia&#34;</span>) <span style=color:#ff79c6>&lt;=</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>      System.<span style=color:#ff79c6>out</span>.println(name);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>rangeはまた、<code>when</code>の条件式でも使えます。<code>if-else</code>より可読性が良くなりますね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> message = <span style=color:#ff79c6>when</span> (statusCode) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>in</span> <span style=color:#bd93f9>200.</span>.<span style=color:#bd93f9>299</span> <span style=color:#ff79c6>-&gt;</span> <span style=color:#f1fa8c>&#34;OK&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>in</span> <span style=color:#bd93f9>300.</span>.<span style=color:#bd93f9>399</span> <span style=color:#ff79c6>-&gt;</span> <span style=color:#f1fa8c>&#34;Find it somewhere else&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>-&gt;</span> <span style=color:#f1fa8c>&#34;Oops&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ただ、rangeを使う場合、特定の値が含まれているかどうかをチェックするとき、指定された範囲とそれを使うコードの間に間があるとコストがかかることになります。たとえば以下のようなコードがあるとします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> myRange <span style=color:#ff79c6>get</span>() = <span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>rangeTest</span>(i: Int) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (i <span style=color:#ff79c6>in</span> myRange) {
</span></span><span style=display:flex><span>        println(i)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>この場合はコンパイルすると<code>IntRange</code>オブジェクトが追加されます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>final</span> IntRange <span style=color:#50fa7b>getMyRange</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>new</span> IntRange<span style=color:#ff79c6>(</span>1<span style=color:#ff79c6>,</span> 10<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>public</span> <span style=color:#8be9fd;font-style:italic>final</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>rangeTest</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> i<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>if</span><span style=color:#ff79c6>(</span><span style=color:#ff79c6>this</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>getMyRange</span><span style=color:#ff79c6>().</span><span style=color:#50fa7b>contains</span><span style=color:#ff79c6>(</span>i<span style=color:#ff79c6>))</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>i<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>これはプロパティのgetterを<code>inline</code>として定義しても同じです。なのでなるべくrangeが使われるテストの方に直接書くことでオブジェクトが追加されない要因した方が良いです。また、primitiveではないオブジェクトを使う場合は定数として定義し、<code>ClosedRange</code>のインスタンスを再利用する方法があります。</p><h3 id=forループ>forループ</h3><p><code>Float</code>と<code>Double</code>を除いたprimitive型の範囲をループで使うのも良い選択です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>in</span> <span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>10</span>) {
</span></span><span style=display:flex><span>    println(i)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>コンパイルされた結果にはオーバーヘッドが発生しません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 1<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>byte</span> var2 <span style=color:#ff79c6>=</span> 11<span style=color:#ff79c6>;</span> i <span style=color:#ff79c6>&lt;</span> var2<span style=color:#ff79c6>;</span> <span style=color:#ff79c6>++</span>i<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>i<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>逆順にループしたい場合は<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/down-to.html target=_blank rel=noopener>downTo()</a>を使えます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>in</span> <span style=color:#bd93f9>10</span> downTo <span style=color:#bd93f9>1</span>) {
</span></span><span style=display:flex><span>    println(i)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>これにもまた、オーバーヘッドは発生しません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 10<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>byte</span> var1 <span style=color:#ff79c6>=</span> 1<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span><span style=color:#ff79c6>(</span><span style=color:#ff79c6>true</span><span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>i<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>if</span><span style=color:#ff79c6>(</span>i <span style=color:#ff79c6>==</span> var1<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>--</span>i<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p><a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/until.html target=_blank rel=noopener>until</a>を使って特定の値未満にループするのも良いですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>in</span> <span style=color:#bd93f9>0</span> until size) {
</span></span><span style=display:flex><span>    println(i)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以前は少しコストがかかることになりましたが、Kotlin 1.1.4以降は以下のようなコードが生成されます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> var2 <span style=color:#ff79c6>=</span> size<span style=color:#ff79c6>;</span> i <span style=color:#ff79c6>&lt;</span> var2<span style=color:#ff79c6>;</span> <span style=color:#ff79c6>++</span>i<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>i<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>ただ、そのほかは最適化があまり効いてないケースもあります。<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/reversed.html target=_blank rel=noopener>reversed()</a>を使う例があるとしましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>in</span> (<span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>10</span>).reversed()) {
</span></span><span style=display:flex><span>    println(i)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>コンパイルされたコードがあまり綺麗とは言えません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>IntProgression var10000 = RangesKt.reversed((IntProgression)(new IntRange(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>10</span>)));
</span></span><span style=display:flex><span>int i = var10000.getFirst();
</span></span><span style=display:flex><span>int var3 = var10000.getLast();
</span></span><span style=display:flex><span>int var4 = var10000.getStep();
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span>(var4 &gt; <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>if</span>(i &gt; var3) {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>} <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span>(i &lt; var3) {
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span>(<span style=color:#ff79c6>true</span>) {
</span></span><span style=display:flex><span>   System.<span style=color:#ff79c6>out</span>.println(i);
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>if</span>(i <span style=color:#ff79c6>==</span> var3) {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   i <span style=color:#ff79c6>+=</span> var4;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>IntRange</code>オブジェクトが範囲を再定義するため生成され、さらに<code>IntProgression</code>オブジェクトが逆順に要素を整列するために生成されます。</p><p><code>progression</code>を作るのに二つ以上の関数が使われていると、二つ以上のオブジェクトを作るようなオーバーヘッドが発生することになります。</p><p>上記のルールは<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/step.html target=_blank rel=noopener>step()</a>を使う場合も同じで、<code>step 1</code>を指定しても状況は変わりません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>in</span> <span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>10</span> step <span style=color:#bd93f9>2</span>) {
</span></span><span style=display:flex><span>    println(i)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>さらに、生成されたコードで最後の値を読み込む時、<code>IntProgression</code>オブジェクトの最後の要素と<code>step()</code>で指定した範囲を考慮して追加の処理が行われます。上記のサンプルだと最後の要素は<code>9</code>です。</p><p>なので、<code>for</code>を利用したループをするときはなるべく<code>..</code>、<code>downTo()</code>、<code>until()</code>を利用してオーバーヘッドを避けた方が良いでしょう。</p><h3 id=foreachループ>forEachループ</h3><p><code>for</code>ループの代わりに、rangeに対してinline拡張関数の<code>forEach()</code>を使う場合も結果はあまり変わりません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>(<span style=color:#bd93f9>1.</span>.<span style=color:#bd93f9>10</span>).forEach {
</span></span><span style=display:flex><span>    println(<span style=color:#ff79c6>it</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>しかし、<code>forEach()</code>は<code>Iterable</code>に対してのみ最適化されてないです。これはつまり、iteratorを生成する必要があるということを意味します。なので、コンパイルされると以下のようになります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Iterable $receiver$iv <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>(</span>Iterable<span style=color:#ff79c6>)(</span><span style=color:#ff79c6>new</span> IntRange<span style=color:#ff79c6>(</span>1<span style=color:#ff79c6>,</span> 10<span style=color:#ff79c6>));</span>
</span></span><span style=display:flex><span>Iterator var1 <span style=color:#ff79c6>=</span> $receiver$iv<span style=color:#ff79c6>.</span><span style=color:#50fa7b>iterator</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span><span style=color:#ff79c6>(</span>var1<span style=color:#ff79c6>.</span><span style=color:#50fa7b>hasNext</span><span style=color:#ff79c6>())</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   <span style=color:#8be9fd>int</span> element$iv <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>((</span>IntIterator<span style=color:#ff79c6>)</span>var1<span style=color:#ff79c6>).</span><span style=color:#50fa7b>nextInt</span><span style=color:#ff79c6>();</span>
</span></span><span style=display:flex><span>   System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>element$iv<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>これは今までのサンプルよりもコストのかかるものです。<code>IntRange</code>オブジェクトを生成するだけでなく、<code>IntIterator</code>オブジェクトも生成しているからです。primitiveではない場合はさらにコストがかかるでしょう。</p><p>なので、rangeを使ったループが必要な場合は<code>forEach()</code>より<code>for</code>ループを使ってオーバーヘッドを減らした方が良いです。</p><h3 id=collectionインデックスループ>collectionインデックスループ</h3><p>Kotlinのスタンダードライブラリは<a class=link href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/indices.html target=_blank rel=noopener>indices</a>という拡張プロパティで配列と<code>Collection</code>のインテックスを提供します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> list = listOf(<span style=color:#f1fa8c>&#34;A&#34;</span>, <span style=color:#f1fa8c>&#34;B&#34;</span>, <span style=color:#f1fa8c>&#34;C&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>in</span> list.indices) {
</span></span><span style=display:flex><span>    println(list[i])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>indices</code>のコンパイルされた結果は良い最適化を見せてくれます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List list <span style=color:#ff79c6>=</span> CollectionsKt<span style=color:#ff79c6>.</span><span style=color:#50fa7b>listOf</span><span style=color:#ff79c6>(</span><span style=color:#ff79c6>new</span> String<span style=color:#ff79c6>[]{</span><span style=color:#f1fa8c>&#34;A&#34;</span><span style=color:#ff79c6>,</span> <span style=color:#f1fa8c>&#34;B&#34;</span><span style=color:#ff79c6>,</span> <span style=color:#f1fa8c>&#34;C&#34;</span><span style=color:#ff79c6>});</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>int</span> i <span style=color:#ff79c6>=</span> 0<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span><span style=color:#ff79c6>(</span><span style=color:#8be9fd>int</span> var2 <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>((</span>Collection<span style=color:#ff79c6>)</span>list<span style=color:#ff79c6>).</span><span style=color:#50fa7b>size</span><span style=color:#ff79c6>();</span> i <span style=color:#ff79c6>&lt;</span> var2<span style=color:#ff79c6>;</span> <span style=color:#ff79c6>++</span>i<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>   Object var3 <span style=color:#ff79c6>=</span> list<span style=color:#ff79c6>.</span><span style=color:#50fa7b>get</span><span style=color:#ff79c6>(</span>i<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>   System<span style=color:#ff79c6>.</span><span style=color:#50fa7b>out</span><span style=color:#ff79c6>.</span><span style=color:#50fa7b>println</span><span style=color:#ff79c6>(</span>var3<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p><code>IntRange</code>オブジェクトが作られてないです。では、自前で実装してみるとどうなるのでしょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>inline</span> <span style=color:#ff79c6>val</span> SparseArray&lt;*&gt;.indices: IntRange
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>get</span>() = <span style=color:#bd93f9>0</span> until size()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>printValues</span>(map: SparseArray&lt;String&gt;) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>in</span> map.indices) {
</span></span><span style=display:flex><span>        println(map.valueAt(i))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>拡張プロパティとして定義してコンパイルすると、あまり効率的ではないコードになっていることがわかります。<code>IntRange</code>オブジェクトが作られてます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> static <span style=color:#ff79c6>final</span> void printValues(@NotNull SparseArray map) {
</span></span><span style=display:flex><span>   Intrinsics.checkParameterIsNotNull(map, <span style=color:#f1fa8c>&#34;map&#34;</span>);
</span></span><span style=display:flex><span>   IntRange var10000 = RangesKt.until(<span style=color:#bd93f9>0</span>, map.size());
</span></span><span style=display:flex><span>   int i = var10000.getFirst();
</span></span><span style=display:flex><span>   int var2 = var10000.getLast();
</span></span><span style=display:flex><span>   <span style=color:#ff79c6>if</span>(i <span style=color:#ff79c6>&lt;=</span> var2) {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>while</span>(<span style=color:#ff79c6>true</span>) {
</span></span><span style=display:flex><span>         Object $<span style=color:#ff79c6>receiver</span>$iv = map.valueAt(i);
</span></span><span style=display:flex><span>         System.<span style=color:#ff79c6>out</span>.println($<span style=color:#ff79c6>receiver</span>$iv);
</span></span><span style=display:flex><span>         <span style=color:#ff79c6>if</span>(i <span style=color:#ff79c6>==</span> var2) {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>break</span>;
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>         <span style=color:#ff79c6>++</span>i;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>この場合は代わりに<code>until()</code>と<code>for</code>ループを使った方が良いでしょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>printValues</span>(map: SparseArray&lt;String&gt;) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (i <span style=color:#ff79c6>in</span> <span style=color:#bd93f9>0</span> until map.size()) {
</span></span><span style=display:flex><span>        println(map.valueAt(i))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=最後に>最後に</h2><p>いかがでしたか。個人的にはあまり委譲プロパティを使ったことがなく、そもそもの理解を兼ねてかなり勉強になりました。また、rangeに関しても、Javaでの習慣でテストクラスのフィールドとして定義していろいろな関数で使い回していましたが、まさかそれがよりコストのかかることだとは思ってなかったので少しショックでした。</p><p>また、改めてKotlinで提供している機能とAPIに対して正しく理解する必要があると思いました。そして<a class=link href=https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%83%E3%82%AB%E3%83%A0%E3%81%AE%E5%89%83%E5%88%80 target=_blank rel=noopener>オッカムの剃刀</a>でも話しているように、なるべくシンプルなロジックとコードを追求する必要があるとも思いましたね。intellijのメニューのうち、<code>Tools > Kotlin > Show Kotlin Bytecode</code> でいつでもJavaのコードにdecomplieされたコードを確認できるので、最新だとどのように変換されるのかを確認してみながらコードを最適化を行なった方が良いかも知れません。</p><p>今月はいつもの、自分の経験や仮説を紹介するようなポストでなく、ほぼ翻訳のみになってしまいましたが、私自身としてはかなり貴重な知識を得られたと思っています。またの機会で何か良いものがあったら、是非とも紹介させていただきたいですね。</p><p>では、また！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/kotlin/>kotlin</a>
<a href=/tags/java/>java</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/posts/kotlin-prospect/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinのこれからを語る</h2></div></a></article><article class=has-image><a href=/posts/effective-kotlin/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Effective Kotlinを読む</h2></div></a></article><article class=has-image><a href=/posts/kotlin-japanese-era/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinで和暦を使う</h2></div></a></article><article class=has-image><a href=/posts/kotlin-hidden-cost-2/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinの隠されたコストーその２</h2></div></a></article><article class=has-image><a href=/posts/kotlin-hidden-cost-1/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinの隠されたコストーその１</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2022 Korean-man in Tokyo</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.7.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#委譲プロパティ>委譲プロパティ</a><ol><li><a href=#委譲インスタンス>委譲インスタンス</a></li><li><a href=#ジェネリック委譲>ジェネリック委譲</a></li><li><a href=#スタンダード委譲lazy>スタンダード委譲（lazy()）</a></li></ol></li><li><a href=#ranges>Ranges</a><ol><li><a href=#包含テスト>包含テスト</a></li><li><a href=#forループ>forループ</a></li><li><a href=#foreachループ>forEachループ</a></li><li><a href=#collectionインデックスループ>collectionインデックスループ</a></li></ol></li><li><a href=#最後に>最後に</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>