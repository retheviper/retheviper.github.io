<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Korean-man in Tokyo</title><link>https://retheviper.github.io/posts/</link><description>Recent content in Posts on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 08 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>JVM はまだ進化する</title><link>https://retheviper.github.io/posts/jvm-evolution/</link><pubDate>Tue, 08 Jul 2025 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jvm-evolution/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post JVM はまだ進化する" />&lt;p>現代のプログラミング環境は、Go や Rust などの軽量ランタイムが受け入れられる中、「JVM の方向性」に疑問を持つ声も聞かれるようになってきました。私自身もそうで、特にクラウド環境では、JVM の起動時間やメモリ使用量が問題となるケースも少なくないです。なのでサーバレス環境の場合、純粋に起動時間のためPythonやNode.jsを選ぶこともあります。&lt;/p>
&lt;p>しかし JVM は、現在も新技術によって性能改善の余地を持ち続けています。この記事では、Leyden や Loom を始めとした現在進行中の主要プロジェクトを概覧し、JVM の「性能」は未来にわたってどれだけ改善可能かを検討します。&lt;/p>
&lt;h2 id="jit-から-aot--pgo-へ">JIT から AOT + PGO へ
&lt;/h2>&lt;p>&lt;a class="link" href="https://en.wikipedia.org/wiki/Just-in-time_compilation" target="_blank" rel="noopener"
>JIT (Just-In-Time Compiler)&lt;/a>は、バイトコードを実行時にネイティブコードへコンパイルする技術です。
最適化コードをランタイムで生成できる依存性が高い一方、warm-up期間&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>や&amp;quot;jitter&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>による性能不定は無視できません。&lt;/p>
&lt;p>これらを解決するために考案されたのが&lt;a class="link" href="https://www.graalvm.org" target="_blank" rel="noopener"
>Graal&lt;/a> で、 C2 の代替として設計された高性能 JIT コンパイラです。inlining, escape analysis, vectorization などで事前に最適化を行い、JIT の不安定性を削減します。&lt;/p>
&lt;p>例えば&lt;a class="link" href="https://www.oracle.com/a/ocom/docs/graalvm-twitter-casestudy-constellation.pdf" target="_blank" rel="noopener"
>Twitterの事例&lt;/a> では Graal JIT を通じて CPU 利用率を8〜11%削減し、Kotlinのマイクロベンチマークでは &lt;a class="link" href="https://martijndwars.nl/2020/02/24/graal-vs-c2.html" target="_blank" rel="noopener"
>+18%の性能向上&lt;/a> を報告しています。&lt;/p>
&lt;h2 id="leyden-で起動の早さと安定性を両立">Leyden で起動の早さと安定性を両立
&lt;/h2>&lt;p>&lt;a class="link" href="https://openjdk.org/projects/leyden/" target="_blank" rel="noopener"
>Project Leyden&lt;/a> は、JVM アプリケーションの起動時間と warm-up 時間を根本的に短縮することを目標にしています。&lt;/p>
&lt;p>従来の JIT ベースの最適化は、ランタイムの初期段階でプロファイル情報を集めながら段階的に性能を引き上げていく「適応的」最適化方式ですが、Leyden はそれを「事前確定的」（static）な最適化に置き換える方向性をとります。&lt;/p>
&lt;p>このために Leyden は、以下の要素をアーカイブとして事前に保存する「condensers」という概念を導入しています。この condensers は、以下の情報を含むアーカイブです。&lt;/p>
&lt;ul>
&lt;li>使用クラスのリストと linking 情報&lt;/li>
&lt;li>ヒープの初期状態（AppCDS + heap snapshot）&lt;/li>
&lt;li>プロファイル情報（PGO）&lt;/li>
&lt;li>コンパイル済みコード&lt;/li>
&lt;/ul>
&lt;p>これにより、アプリケーションの起動直後から JIT 後のような性能を発揮し、jitter を最小限に抑えることが期待されます。&lt;/p>
&lt;p>たとえば &lt;a class="link" href="https://quarkus.io/" target="_blank" rel="noopener"
>Quarkus&lt;/a> チームは Leyden の初期実装に基づき、以下のような改善を報告しています。&lt;/p>
&lt;ul>
&lt;li>起動時間を 50% 以上短縮&lt;/li>
&lt;li>Native Image に近い応答速度を実現しつつ JVM の柔軟性は保持&lt;/li>
&lt;li>メモリ使用量を最大 30% 削減&lt;/li>
&lt;/ul>
&lt;p>Leyden の関連 JEP には、&lt;a class="link" href="https://openjdk.org/jeps/483" target="_blank" rel="noopener"
>JEP 483&lt;/a>（class loading/linking の事前保存）、&lt;a class="link" href="https://openjdk.org/jeps/515" target="_blank" rel="noopener"
>JEP 515&lt;/a>（PGO support）などがあり、JDK 25 以降で順次取り込まれる予定です。&lt;/p>
&lt;h2 id="zgc-shenandoah-そして-lxr">ZGC, Shenandoah, そして LXR
&lt;/h2>&lt;p>GCは JVM の性能に大きく影響する要素です。近年導入した&lt;a class="link" href="https://wiki.openjdk.org/display/zgc/Main" target="_blank" rel="noopener"
>ZGC&lt;/a> や &lt;a class="link" href="https://wiki.openjdk.org/display/shenandoah/Main" target="_blank" rel="noopener"
>Shenandoah GC&lt;/a> は「pause-less GC」を目指し、ZGC は広大なヒープを持つ JVM でも少なくとも &amp;lt;1ms の GC ポーズを実現しています。&lt;/p>
&lt;p>最新の &lt;a class="link" href="https://www.steveblackburn.org/pubs/papers/lxr-pldi-2022.pdf" target="_blank" rel="noopener"
>LXR GC&lt;/a>（研究段階）は、ZGC より九分すぐれた性能を見せ、tail latency を30倍減少、throughput を6倍向上という報告も出ています。&lt;/p>
&lt;p>&lt;a class="link" href="https://www.datastax.com/blog/apache-cassandra-benchmarking-40-brings-heat-new-garbage-collectors-zgc-and-shenandoah" target="_blank" rel="noopener"
>Cassandra ベンチマーク&lt;/a>では Shenandoah が p99 レイテンシを77%減らすなど、リアルなサービスへの影響も証明されています。&lt;/p>
&lt;p>これらは、小型のサービスから広大な JVM グラフまで、性能の jitter を削減しながら throughput を保てるっという為に大きな意味を持ちます。&lt;/p>
&lt;h2 id="valhalla-の支援するメモリー効率">Valhalla の支援するメモリー効率
&lt;/h2>&lt;p>&lt;a class="link" href="https://openjdk.org/projects/valhalla/" target="_blank" rel="noopener"
>Project Valhalla&lt;/a> は「value class」を JVM に実装することで、ヒープのオブジェクト依存を解消し、キャッシュローカリティを向上させます。&lt;/p>
&lt;p>通常のオブジェクトはヒープ内の分散やヘッダーを持ち、GC やキャッシュミスに負担をかけますが、value class はプリミティブな構造体のように inlined されるため、メモリーバンドを向上させます。&lt;/p>
&lt;p>特に Kotlin の data class は Valhalla から大きな影響を受け、変数配列やベクタ計算のような性能パスでは &lt;a class="link" href="https://www.reddit.com/r/java/comments/1dnhgut/i_actually_tested_jdk_20_valhalla_here_are_my/" target="_blank" rel="noopener"
>数倍の向上&lt;/a> も期待できます。&lt;/p>
&lt;h2 id="loom-でスケーラブルな-io-並行性の実現">Loom でスケーラブルな I/O 並行性の実現
&lt;/h2>&lt;p>&lt;a class="link" href="https://openjdk.org/projects/loom/" target="_blank" rel="noopener"
>Project Loom&lt;/a> は仮想スレッドによって、従来のブロッキングな I/O コードをそのまま保ちながら、大量の同時接続を処理できるようにする試みです。&lt;/p>
&lt;p>ここで重要なのが、既存の並行処理との関係です。&lt;/p>
&lt;p>従来の Java（および Spring MVC）は、&lt;strong>リクエストごとに OS スレッドを1本消費する&lt;/strong>アーキテクチャでした。
しかしこれは、同時接続数が多くなるとすぐにスレッド枯渇やコンテキストスイッチによる性能低下を招きます。&lt;/p>
&lt;p>この問題を解決するために導入されたのが &lt;a class="link" href="https://docs.spring.io/spring-framework/reference/web/webflux.html" target="_blank" rel="noopener"
>Spring WebFlux&lt;/a> です。
WebFlux は &lt;a class="link" href="https://projectreactor.io/" target="_blank" rel="noopener"
>Reactor&lt;/a> に基づくノンブロッキング非同期モデルで、少数のスレッドで大量のリクエストを捌くことを可能にしました。&lt;/p>
&lt;p>ただしその代償として、開発者は &lt;code>Mono&lt;/code> や &lt;code>Flux&lt;/code> を理解し、非同期パイプラインの構築を強いられ、デバッグも難しくなるという課題がありました。幸 Kotlin では &lt;code>suspend&lt;/code> 関数を使うことで非同期処理を簡潔に書けますが、Java では依然として複雑なコードが必要でしたね。&lt;/p>
&lt;p>ここで登場する Loom の仮想スレッドは、&lt;strong>WebFlux 並のスケーラビリティを持ちながらも、従来通りの「同期的なコード」で記述できる&lt;/strong>という点で画期的です。コード自体も、既存のスレッドベースのコードとほぼ同じままです。&lt;/p>
&lt;p>Java 21 で仮想スレッドが正式に導入され、&lt;a class="link" href="https://docs.spring.io/spring-framework/reference/integration/virtual-threads.html" target="_blank" rel="noopener"
>Spring MVC の VirtualThreadTaskExecutor&lt;/a> などがその代表例です。従来の Servlet ベースの構成に最小限の変更で仮想スレッドを導入可能であり、&lt;a class="link" href="https://github.com/chrisgleissner/loom-webflux-benchmarks" target="_blank" rel="noopener"
>WebFlux よりも低レイテンシかつ高スループットを実現&lt;/a>できます。&lt;/p>
&lt;p>Netty や Tomcat など、一部のアプリケーションサーバも Loom 対応を進めており、今後は仮想スレッドが標準的な選択肢となっていくのではと思います。&lt;/p>
&lt;h2 id="まとめ">まとめ
&lt;/h2>&lt;p>以下に、この記事で紹介した JVM の主要な改善点をまとめます。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>Graal&lt;/a> や &lt;a class="link" href="https://openjdk.org/projects/leyden/" target="_blank" rel="noopener"
>Leyden&lt;/a> により JIT 不安定性や warm-up 時間を削減&lt;/li>
&lt;li>&lt;a class="link" href="https://wiki.openjdk.org/display/zgc/Main" target="_blank" rel="noopener"
>ZGC&lt;/a>, &lt;a class="link" href="https://wiki.openjdk.org/display/shenandoah/Main" target="_blank" rel="noopener"
>Shenandoah&lt;/a>, &lt;a class="link" href="https://arxiv.org/abs/2210.17175" target="_blank" rel="noopener"
>LXR GC&lt;/a> により低レイテンシなヒープでの GC を実現&lt;/li>
&lt;li>&lt;a class="link" href="https://openjdk.org/projects/valhalla/" target="_blank" rel="noopener"
>Valhalla&lt;/a> によるメモリ実行効率向上&lt;/li>
&lt;li>&lt;a class="link" href="https://openjdk.org/projects/loom/" target="_blank" rel="noopener"
>Loom&lt;/a> による I/O スケーラビリティの高効化&lt;/li>
&lt;/ul>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>JVM は長い歴史を持つ一方で、近年はその限界も語られがちでした。&lt;/p>
&lt;p>でも、ここで紹介した Leyden や Loom のようなプロジェクトは、Java の価値を単なる互換性だけでなく「今のニーズに応える性能基盤」として再構築しようとしています。&lt;/p>
&lt;p>特に Kotlin や Scala など、Java 以外の言語でもこのような JVM の改善を活用できるので、これからの進化にも期待が持てますね。&lt;/p>
&lt;p>まだまだアプリケーション開発のパラダイムや性能基盤は変わり続けていくもので、これからの先はまたどうなるかわかりませんが、このような技術革新が続くといいですね。&lt;/p>
&lt;p>では、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>JITが最適化を行うために必要な初期段階のこと&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>実行時間のばらつきのこと&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>KtorのRequest処理を改善する</title><link>https://retheviper.github.io/posts/ktor-validation/</link><pubDate>Sat, 28 Jun 2025 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ktor-validation/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.webp" alt="Featured image of post KtorのRequest処理を改善する" />&lt;p>KotlinはJavaとの互換性があるので、Javaで構築した既存のシステムの一部を書き換えたり、言語だけを変えて新しいシステムを構築したりするケースが多いかなと思います。しかし、同じJVM上で動作するKotlinとJavaでも、フレームワークやライブラリの違いにより改善できる箇所もあります。&lt;/p>
&lt;p>Javaの歴史が長いこともあり、Javaのフレームワークやライブラリは非常に多くの機能を提供していますが、Kotlinではより簡潔で直感的なコードを書くことができる場合があります。また、その中ではKotlinの特性を活かした設計が可能だったり、性能の向上が期待できたりします。&lt;/p>
&lt;p>今回はそのような改善の一例として、Ktorでのリクエストバリデーションの実装方法について紹介します。&lt;/p>
&lt;h2 id="既存">既存
&lt;/h2>&lt;p>実務では&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>Ktor&lt;/a>、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>といったKotlin用のフレームワークを採用しています。ただ一部ではJavaのライブラリに依存していて、直列化ではJackson、リクエストのバリデーションではjakarta.validationを使用していました。&lt;/p>
&lt;p>JavaやKotlinでよく使われるSpring Bootの場合、これらのライブラリを使うのがとても簡単ですね。例えば、リクエストのバリデーションは&lt;code>@Valid&lt;/code>や&lt;code>@Validated&lt;/code>アノテーションで自動的に行うことができます。&lt;/p>
&lt;p>しかし、Ktorではそうでもいきません。なので、Ktorのリクエストバリデーションは、手動で行う必要がありました。例えば、以下のようにしていました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// リクエストのバリデーションを行う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">AnnotationValidator&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> validator: Validator = &lt;span style="color:#a6e22e">Validation&lt;/span>.buildDefaultValidatorFactory().validator
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getViolationMessages&lt;/span>(model: Any?): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> model &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> violations = validator.validate(model)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> violations.map { &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${it.propertyPath}&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#e6db74">${it.message}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// バリデーションを行うインターフェース
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Validatable&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">validate&lt;/span>(): List&amp;lt;String&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// リクエストボディ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CreateLogRequest&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:NotNull
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:NotBlank
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:Size(max = &lt;span style="color:#ae81ff">36&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:Pattern(regexp = &lt;span style="color:#e6db74">&amp;#34;^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JsonProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;user_id&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> userId: String?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:NotNull
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:NotBlank
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:Size(max = &lt;span style="color:#ae81ff">2048&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JsonProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;referral&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> referral: String?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:NotNull
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:NotBlank
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@field&lt;/span>:Size(max = &lt;span style="color:#ae81ff">2048&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JsonProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;user_agent&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> userAgent: String?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : Validatable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">validate&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">AnnotationValidator&lt;/span>.getViolationMessages(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コントローラー
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LogController&lt;/span> : KoinComponent {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> logUseCase: sLogUseCase &lt;span style="color:#66d9ef">by&lt;/span> inject()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createLog&lt;/span>(request: CreateLogRequest): CreateLogResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> validationErrors = request.validate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (validationErrors.isNotEmpty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> BadRequestException(&lt;span style="color:#e6db74">&amp;#34;Validation failed: &lt;/span>&lt;span style="color:#e6db74">${validationErrors.joinToString(&amp;#34;, &amp;#34;)}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> logUseCase.createLog(request)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで自分が問題と思ったのは、以下のようなものがあります。&lt;/p>
&lt;ol>
&lt;li>リクエストのバリデーションを手動で行う必要があるため、コードが冗長になりやすい。&lt;/li>
&lt;li>各コントローラーやリクエストに対して同じようなバリデーションコードを書く必要があるため、コードの重複が発生しやすい。&lt;/li>
&lt;li>バリデーションと直列化でアノテーションに依存しているため、リフレクションによるパフォーマンスの低下や、アノテーションの変更が必要な場合にコードの修正が必要になる。&lt;/li>
&lt;li>プロパティの型をアノテーションで指定するため、型安全なコードが書きにくい。&lt;/li>
&lt;/ol>
&lt;p>なので、これらの問題を解決するために、Ktorのリクエストバリデーションを改善する方法を考えました。&lt;/p>
&lt;h2 id="改善">改善
&lt;/h2>&lt;p>自分で考えた改善策は以下のようなものです。&lt;/p>
&lt;ol>
&lt;li>Ktor公式の&lt;a class="link" href="https://ktor.io/docs/request-validation.html" target="_blank" rel="noopener"
>Request Validation&lt;/a>を使用して、アノテーションに依存しないバリデーションを実装する。&lt;/li>
&lt;li>バリデーションのロジックを共通化できるようにする。&lt;/li>
&lt;li>Jacksonから&lt;a class="link" href="https://kotlinlang.org/docs/serialization.html" target="_blank" rel="noopener"
>Kotlinx Serialization&lt;/a>に移行して、アノテーションをさらに減らしつつとパフォーマンスを向上させる。&lt;/li>
&lt;/ol>
&lt;p>それぞれ分けると以下のような内容になります。&lt;/p>
&lt;h3 id="ktorのrequest-validationを使用する">KtorのRequest Validationを使用する
&lt;/h3>&lt;p>まずはValidatableControllerというインターフェースを作成して、それぞれのコントローラーで実装します。このインターフェースは、KtorのRequest Validationを使用してリクエストのバリデーションを行うためのもので、Ktorのプラグインに登録するためのメソッドを持っています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ValidatableController&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">configureValidation&lt;/span>(validationConfig: RequestValidationConfig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、data classを修正します。jakarta.validationのアノテーションは削除し、Validatableというインターフェースも削除します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CreateLogRequest&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JsonProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;user_id&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> userId: String?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JsonProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;referral&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> referral: String?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JsonProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;user_agent&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> userAgent: String?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、コントローラーを修正します。ValidatableControllerを継承させ、バリデーションのロジックを&lt;code>configureValidation&lt;/code>メソッドに移動し、KtorのRequest Validationを使用してリクエストのバリデーションを行います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LogController&lt;/span> : KoinComponent, ValidatableController {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> logUseCase: LogUseCase &lt;span style="color:#66d9ef">by&lt;/span> inject()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">configureValidation&lt;/span>(validationConfig: RequestValidationConfig) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> validationConfig.validate&amp;lt;CreateLogRequest&amp;gt; { request &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.userId &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;User ID must not be null&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.userId.isBlank() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;User ID must not be blank&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.userId.length &amp;gt; &lt;span style="color:#ae81ff">36&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;User ID must not exceed 36 characters&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> !request.userId.matches(Regex(&lt;span style="color:#e6db74">&amp;#34;^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$&amp;#34;&lt;/span>)) &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;User ID must be a valid UUID format&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.referral &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;Referral must not be null&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.referral.isBlank() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;Referral must not be blank&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.referral.length &amp;gt; &lt;span style="color:#ae81ff">2048&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;Referral must not exceed 2048 characters&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.userAgent &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;User Agent must not be null&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.userAgent.isBlank() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;User Agent must not be blank&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.userAgent.length &amp;gt; &lt;span style="color:#ae81ff">2048&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;User Agent must not exceed 2048 characters&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Valid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createLog&lt;/span>(request: CreateLogRequest): CreateLogResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> logUseCase.createLog(request)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようにすることで、KtorのRequest Validationを使用してリクエストのバリデーションを行うことができます。これにより、アノテーションに依存せず、コードの冗長性を減らすことができます。&lt;/p>
&lt;h3 id="モジュールの設定">モジュールの設定
&lt;/h3>&lt;p>次は、ValidationControllerをKtorのモジュールとして設定します。インターフェースとして&lt;code>ValidatableController&lt;/code>を定義した理由は、DIで使用している&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>を使用して、すべてのコントローラーを取得し、KtorのRequest Validationに登録するためです。&lt;/p>
&lt;p>まずKoinではinterfaceに対して実装クラスをバインディングするいくつかの方法があります。代表的には、以下のような方法があるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> koinModule = module {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single&amp;lt;ValidatableController&amp;gt; { AccessLogController() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この方法では、&lt;code>ValidatableController&lt;/code>インターフェースを実装したクラスを単一のインスタンスとして登録します。しかし、これでは複数の&lt;code>ValidatableController&lt;/code>を登録することができません。&lt;/p>
&lt;p>この場合、&lt;code>get()&lt;/code>を使用して、1つの&lt;code>ValidatableController&lt;/code>のみを取得することはできます。しかしここでやりたいことは、複数の&lt;code>ValidatableController&lt;/code>を取得して、リクエストのバリデーションを共通化することなのでこの方法は適していません。&lt;/p>
&lt;p>またの方法が、&lt;a class="link" href="https://insert-koin.io/docs/reference/koin-core/definitions/#additional-type-binding" target="_blank" rel="noopener"
>bind&lt;/a>を使用する方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> koinModule = module {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single { LogController() } bind ValidatableController&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">single&lt;/span> { AnotherController() } bind ValidatableController&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先ほどのコードとは違って、&lt;code>bind&lt;/code>を使用することで、Koinはそのインターフェースを実装したすべてのクラスを取得できるようになります。なので、以下のようなコードで全てのコントローラーを取得することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.configureRequestValidation() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> validatableControllers: List&amp;lt;ValidatableController&amp;gt; = getKoin().getAll()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(RequestValidation) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> validatableControllers.forEach { controller &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> controller.configureValidation(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうすることでリクエストのバリデーションを共通化することができます。これからは新しいコントローラーを追加する際も、&lt;code>ValidatableController&lt;/code>インターフェースを実装するだけで、KtorのRequest Validationに自動的に登録されるようになります。&lt;/p>
&lt;h3 id="kotlinx-serializationの使用">Kotlinx Serializationの使用
&lt;/h3>&lt;p>最後に、Kotlinx Serializationを使用して直列化を行います。これにより、アノテーションの使用を減らし、パフォーマンスを向上させることができます。&lt;/p>
&lt;p>Kotlinx Serializationは、KSP（Kotlin Symbol Processing）を使用して、コンパイル時に直列化のコードを生成します。これにより、リフレクションを使用せずに直列化を行うことができ、パフォーマンスの向上が期待できまし、リクエストのバリデーションでも型安全なコードを書くことができるため、コードの可読性も向上します。&lt;/p>
&lt;p>まず、Kotlinx Serializationを使用するために、既存のJacksonからKotlinx Serializationに移行します。以下のように、ContentNegotiationプラグインを使用してシリアライザを設定します。プロパティの命名規則をスネークケースに変更するために、&lt;code>JsonNamingStrategy.SnakeCase&lt;/code>を使用することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.configureContentNegotiation() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(ContentNegotiation) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> json(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Json {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> namingStrategy = &lt;span style="color:#a6e22e">JsonNamingStrategy&lt;/span>.SnakeCase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、リクエストボディのデータクラスに&lt;code>@Serializable&lt;/code>アノテーションを追加します。Kotlinx Serializationでは@Serializableだけでスネークケースへの変換も可能となり、プロパティ名にアノテーションが不要になります。また、プロパティはそのまま型を指定するだけです。型を指定することでNullチェックも自動になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Serializable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CreateLogRequest&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> userId: UUID,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> referral: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> userAgent: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、コントローラのバリデーションを修正します。userIdの型が&lt;code>String&lt;/code>から&lt;code>UUID&lt;/code>に変更されたので、正規表現のチェックは不要になりました。かなりスッキリしましたね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LogController&lt;/span> : KoinComponent, ValidatableController {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> logUseCase: LogUseCase &lt;span style="color:#66d9ef">by&lt;/span> inject()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">configureValidation&lt;/span>(validationConfig: RequestValidationConfig) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> validationConfig.validate&amp;lt;CreateLogRequest&amp;gt; { request &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.referral.isBlank() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;Referral must not be blank&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.referral.length &amp;gt; &lt;span style="color:#ae81ff">2048&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;Referral must not exceed 2048 characters&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.userAgent.isBlank() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;User Agent must not be blank&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.userAgent.length &amp;gt; &lt;span style="color:#ae81ff">2048&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Invalid(&lt;span style="color:#e6db74">&amp;#34;User Agent must not exceed 2048 characters&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">ValidationResult&lt;/span>.Valid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="評価">評価
&lt;/h3>&lt;p>結論的に以下のような改善ができたと思います。&lt;/p>
&lt;ul>
&lt;li>バリデーションと直列化のコードが簡潔になり、可読性が向上した&lt;/li>
&lt;li>バリデーションと直列化でアノテーションを使用しなくなり、リフレクションによるパフォーマンスの低下を回避できた&lt;/li>
&lt;li>バリデーションに対してビジネスロジック以外のチェックを減らすことができた&lt;/li>
&lt;/ul>
&lt;p>また、サイドエフェクトとして以下のような点もあります。&lt;/p>
&lt;ul>
&lt;li>Regexが不要になっているか、共通化してインスタンスの使い回しができる&lt;/li>
&lt;li>max, minなどのチェックが不要になっている&lt;/li>
&lt;li>limit, offsetなど頻繁に使うパラメータのチェックを共通化できる&lt;/li>
&lt;/ul>
&lt;p>ただ、以下のような懸念もあります。&lt;/p>
&lt;ul>
&lt;li>LocalDateTimeやLocalDateなどのKotlinx Serializationでサポートされていない型を使用する場合、独自のシリアライザを実装する必要がある&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// LocalDateTimeのシリアライザの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">LocalDateTimeSerializer&lt;/span> : KSerializer&amp;lt;LocalDateTime&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> descriptor: SerialDescriptor = PrimitiveSerialDescriptor(&lt;span style="color:#e6db74">&amp;#34;java.time.LocalDateTime&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">PrimitiveKind&lt;/span>.STRING)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">serialize&lt;/span>(encoder: Encoder, &lt;span style="color:#66d9ef">value&lt;/span>: LocalDateTime) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> encoder.encodeString(&lt;span style="color:#66d9ef">value&lt;/span>.format(&lt;span style="color:#a6e22e">DateTimeFormatter&lt;/span>.ISO_LOCAL_DATE_TIME))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">deserialize&lt;/span>(decoder: Decoder): LocalDateTime {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">LocalDateTime&lt;/span>.parse(decoder.decodeString(), &lt;span style="color:#a6e22e">DateTimeFormatter&lt;/span>.ISO_LOCAL_DATE_TIME)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.configureSerialization() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(ContentNegotiation) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> json(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Json {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// LocalDateTimeのシリアライザを登録
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> serializersModule = SerializersModule {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> contextual(LocalDateTimeSerializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Serializable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ExampleRequest&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// LocalDateTimeのフィールドでは、独自のシリアライザを使用する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">@Contextual&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> timestamp: LocalDateTime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Enumのようにコンパイル時に値が決まっている型を使用する場合も、独自のシリアライザを実装する必要がある&lt;/li>
&lt;li>Kotlinx SerializationはまだJacksonほどの機能がないため、特定の機能が必要な場合はKotlinx Serializationでは実装できないことがある&lt;/li>
&lt;li>Ktor Request Validationはリクエストボディのみのバリデーションをサポートしているため、クエリパラメータやヘッダのバリデーションは別途実装する必要がある&lt;/li>
&lt;/ul>
&lt;p>なので、今回の対応は意図としては成功したと思いますが、まだまだ改善の余地はあるかなと思います。また、環境や要件によっては、このような改善が適さない場合もあるかもしれません。&lt;/p>
&lt;h2 id="改善内容のまとめ">改善内容のまとめ
&lt;/h2>&lt;p>以下の表に、改善前後の違いを簡潔にまとめました。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>項目&lt;/th>
&lt;th>改善前&lt;/th>
&lt;th>改善後&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>バリデーションの方法&lt;/td>
&lt;td>&lt;code>jakarta.validation&lt;/code> + 手動呼び出し&lt;/td>
&lt;td>Ktor公式のRequestValidationプラグイン&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>アノテーションの使用&lt;/td>
&lt;td>&lt;code>@NotNull&lt;/code>, &lt;code>@Pattern&lt;/code>, &lt;code>@JsonProperty&lt;/code>など多数&lt;/td>
&lt;td>&lt;code>@Serializable&lt;/code>のみ、基本的に不要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UUIDバリデーション&lt;/td>
&lt;td>正規表現でチェック&lt;/td>
&lt;td>&lt;code>UUID&lt;/code>型指定で型安全に&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>直列化ライブラリ&lt;/td>
&lt;td>Jackson（リフレクションを使う）&lt;/td>
&lt;td>kotlinx.serialization（KSP利用で高速）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>バリデーションの共通化&lt;/td>
&lt;td>各コントローラーで個別に記述&lt;/td>
&lt;td>&lt;code>ValidatableController&lt;/code>で共通定義可能&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Koinとの連携&lt;/td>
&lt;td>取得や登録が煩雑もしくはしない&lt;/td>
&lt;td>&lt;code>bind&lt;/code> + &lt;code>getAll()&lt;/code> で一括取得&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回はKtorのRequest処理を改善する方法について紹介しました。Kotlinの特性を活かし、KtorのRequest Validationを使用することで、リクエストのバリデーションを簡潔に行うことができました。また、Kotlinx Serializationを使用することで、直列化のパフォーマンスも向上させることができました。&lt;/p>
&lt;p>このように、KotlinとKtorを使用することで、Javaのフレームワークやライブラリでは実現できないような改善が可能になることがあります。特に、Kotlinの特性を活かした設計や、パフォーマンスの向上が期待できる点は大きなメリットです。&lt;/p>
&lt;p>今後もKotlinやKtorを使った開発において、より良い設計やパフォーマンスの向上を目指していきたいと思います。もし、他にもKtorやKotlinに関する改善点やアイデアがあれば、また共有していきたいと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>ホームサーバを作ってみた</title><link>https://retheviper.github.io/posts/home-server/</link><pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/home-server/</guid><description>&lt;img src="https://retheviper.github.io/images/nginx.webp" alt="Featured image of post ホームサーバを作ってみた" />&lt;p>この度は、ホームサーバを作りました。まだ作ったばかりなので、色々と改善や課題があるかと思いますが、一通りの構成を整えたので、その構成について簡単に説明します。&lt;/p>
&lt;h2 id="なぜ自作サーバを作るのか">なぜ自作サーバを作るのか
&lt;/h2>&lt;p>最近は無料で使えるクラウドのサービスも多く、FirebaseやVercelなどのサービスを使えば、簡単にWebアプリケーションを公開することができます。なので既存のサービスを利用するだけで良いのでは？ということは自分でも考えたことはありますが、そこであえて自作サーバを作ることになった理由について簡単に説明します。&lt;/p>
&lt;h3 id="性能">性能
&lt;/h3>&lt;p>多くのクラウドで提供するVMやサーバレスのサービスは、CPUやメモリ、ストレージなどに制限があることが多いです。また、AWSやGCPといったサービスの場合、使われているCPUのアーキテクチャがBroadwellのような、かなり旧時代のものが使われていることが多いですね。それに比べ、今回自作サーバの構築に使ったマシンはM2 ProのMac miniなので、IPCで比べるとより高い性能を期待できます。メモリも同じく、32GBのメモリを搭載しているので、メモリの制約もないですね。&lt;/p>
&lt;h3 id="費用">費用
&lt;/h3>&lt;p>無料のサービスだと基本的に費用はかからなくても、セキュリティのためのWAFのような追加の機能を追加したり、データベースを使ったりすると、結局はお金がかかることが多いです。そして使用量が多くなるとあまり費用が安いわけでもないですね。当分は趣味や個人的に使うための機能のためだけに使いたいので、少しでも支出を減らしたいと思いました。自作サーバだと電気代がかかることはありますが、Mac miniの場合は消費電力が少ないので、それほど気にならなく、使っていない時はスリープにしておけば電気代も抑えられると思います。&lt;/p>
&lt;h3 id="機能">機能
&lt;/h3>&lt;p>サーバレスやVMの場合、場合によっては対応するランタイムが決まっていたり、DBの選択肢が限られていたりすることがあります。例えば、今もOracle Cloudの無料のインスタンスを利用中ですが、無料の場合PostgreSQLを利用できないのでVMの中にDBを起動する形となっています。このように既存のプラットフォームを使うと自分が使いたい機能よりも、サービスの提供する機能に合わせる必要があることがありますね。今回は特にそういった制約を受けずに、自分が使いたい技術を使って自由にサービスを構築したいと思いました。&lt;/p>
&lt;h3 id="その他">その他
&lt;/h3>&lt;p>他にも色々な理由を書きましたが、最も大きな理由は2台のMacを使っているところで、余っているリソースを活用したいと思ったところですね。移動がある時はMacBook Proを使っていて、常に使っているのはMac miniなのでサーバとして運用して、外からもアクセスできるようにしたいと思いました。&lt;/p>
&lt;h2 id="インフラ構成">インフラ構成
&lt;/h2>&lt;p>インフラの場合、まず全体を図で表すと以下のようになります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/home-server/home-network-infrastructure.png"
width="4360"
height="1278"
srcset="https://retheviper.github.io/posts/home-server/home-network-infrastructure_hu_8fec89c200e984f7.png 480w, https://retheviper.github.io/posts/home-server/home-network-infrastructure_hu_3f2035a5e1df40ce.png 1024w"
loading="lazy"
alt="インフラ構成"
class="gallery-image"
data-flex-grow="341"
data-flex-basis="818px"
>&lt;/p>
&lt;h3 id="onu">ONU
&lt;/h3>&lt;p>自宅では、NURO光を利用しているので、そもそもネットの接続のためにはONUが必要ですね。ONUはOptical Network Unitの略で、光回線を利用してインターネットに接続するための装置です。基本的なルータとしての機能も揃っているものです。&lt;/p>
&lt;p>私の場合ONUとは別にWi-Fiルータを使っているので、ONUの設定としてはフォートフォワードだけを設定しておきました。TCPの80番ポートと443番ポートをフォートフォワードしておけば、外部からONUの後ろにアクセスが可能になります。&lt;/p>
&lt;h3 id="ルータ">ルータ
&lt;/h3>&lt;p>次はルータです。先に説明した通り、ONUにはルータとしての機能も揃っているのであえて使う必要はないものですが、ルータが提供している無料のDDNSの機能を使うために、ルータを使っています。ONUだけではIPが固定されていないので、ルータのDDNSを使い、さらにそれを購入したドメインに紐付けることで、常に同じドメインでアクセスできるようになります。固定のドメインがあるので、SSL証明書も取得しやすくなりますね。ここでも80番ポートと443番ポートをフォートフォワードしておきます。&lt;/p>
&lt;h3 id="サーバ">サーバ
&lt;/h3>&lt;p>サーバは、上述したMac miniを使っています。中ではDockerコンテナとしてビルドしたNginxとKtorのアプリケーションが動いています。Nginxはリバースプロキシとして動いており、Ktorのアプリケーションにリクエストを転送しています。Ktorアプリケーションでは静的ファイルの配信ができるので、Compose Web(WASM)で作成したWebアプリケーションを配信しています。&lt;/p>
&lt;p>DockerでNginxとKtorは同じネットワークとして構成しているので、NginxからKtorにアクセスする際は、コンテナ名でアクセスできます。Nginxが80番ポートと443番ポートからのリクエストを受けて、Ktorのアプリケーションに転送しています。そしてCertbotを使ってSSL証明書を取得しているので、HTTPSでアクセスできるようになっています。80番のリクエストは301リダイレクトで443番にリダイレクトです。&lt;/p>
&lt;p>これらの構成は、以下のようにDocker Composeで定義しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">nginx&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">build&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">context&lt;/span>: &lt;span style="color:#ae81ff">.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dockerfile&lt;/span>: &lt;span style="color:#ae81ff">Dockerfile_nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;80:80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;443:443&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">certs:/etc/letsencrypt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">certs-data:/var/www/certbot&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">networks&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">home_network&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">certbot&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">certbot/certbot&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">certbot&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">certs:/etc/letsencrypt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">certs-data:/var/www/certbot&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">networks&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">home_network&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">build&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">context&lt;/span>: &lt;span style="color:#ae81ff">.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dockerfile&lt;/span>: &lt;span style="color:#ae81ff">Dockerfile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">app:latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">app&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;8888:8888&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">networks&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">home_network&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">depends_on&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">nginx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">networks&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">home_network&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">driver&lt;/span>: &lt;span style="color:#ae81ff">bridge&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">certs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">certs-data&lt;/span>:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、不正アクセスを防ぐためにNginxは以下のようなDockerfileでビルドしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Dockerfile" data-lang="Dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ベースイメージとして最新の Nginx を使用&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">FROM&lt;/span>&lt;span style="color:#e6db74"> nginx:latest&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># 必要なパッケージをインストール（git, wget, dnsutils）&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> apt-get update &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> apt-get install -y &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> git &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> dnsutils &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> wget &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> rm -rf /var/lib/apt/lists/*&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Nginx Ultimate Bad Bot Blocker のリポジトリをクローン&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> git clone https://github.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker.git /opt/nginx-ultimate-bad-bot-blocker&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># 必要なディレクトリを作成し、bot 設定ファイルをコピー&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> mkdir -p /etc/nginx/bots.d /usr/local/sbin &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cp /opt/nginx-ultimate-bad-bot-blocker/bots.d/* /etc/nginx/bots.d/ &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cp /opt/nginx-ultimate-bad-bot-blocker/conf.d/globalblacklist.conf /etc/nginx/conf.d/&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># install-ngxblocker スクリプトのダウンロードと実行&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> wget https://raw.githubusercontent.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker/master/install-ngxblocker -O /usr/local/sbin/install-ngxblocker &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> chmod +x /usr/local/sbin/install-ngxblocker &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> /usr/local/sbin/install-ngxblocker -x&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># setup-ngxblocker スクリプトのダウンロードと実行&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> wget https://raw.githubusercontent.com/mitchellkrogza/nginx-ultimate-bad-bot-blocker/master/setup-ngxblocker -O /usr/local/sbin/setup-ngxblocker &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> chmod +x /usr/local/sbin/setup-ngxblocker &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> /usr/local/sbin/setup-ngxblocker -x&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Nginx のカスタム設定ファイルを追加（nginx.conf や default.conf を追加する）&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> ./nginx/nginx.conf /etc/nginx/nginx.conf&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> ./nginx/default.conf /etc/nginx/conf.d/default.conf&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># 証明書のためのボリューム（Let&amp;#39;s Encrypt を使用する場合）&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">VOLUME&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;/etc/letsencrypt&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;/var/www/certbot&amp;#34;&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># Nginx 設定をテストして起動&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">CMD&lt;/span> [&lt;span style="color:#e6db74">&amp;#34;nginx&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-g&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;daemon off;&amp;#34;&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="課題">課題
&lt;/h2>&lt;p>概ねインフラの構成には問題がないですが、アプリケーションの部分にはいくつか課題を感じました。主にFrontendで使っているCompose Web(Wasm)のことです。&lt;/p>
&lt;h3 id="routing未対応">Routing未対応
&lt;/h3>&lt;p>Wasmで作成したアプリケーションの特徴なのかもしれませんが、基本的にSPAのような静的コンテンツを生成するのもあり、まだAlphaのため色々と未対応の部分があります。特にRoutingが未対応なので、ページ遷移が課題ですね。まだ公式はないのですが、直近で&lt;a class="link" href="https://mvnrepository.com/artifact/app.softwork/routing-compose-wasm-js" target="_blank" rel="noopener"
>Compose Wasmに対応するRoutingのライブラリ&lt;/a>がリリースされたり、他にもいくつかあるので今回はそれを使ってみようと思います。&lt;/p>
&lt;h3 id="safari-未対応">Safari 未対応
&lt;/h3>&lt;p>Wasmの場合、ブラウザによっては動作しないことがあります。Compose Webの場合、Safariでは動作しないことがわかっているので、Safariでの動作を考える必要があります。理由はGCにまだ未対応だからとのことですね。Macを使う場合でもSafariを使っているユーザは少ないと思いますが、iOSの場合はSafariを使うユーザが多いので、これはなかなか大きな課題ですね。ただ、&lt;a class="link" href="https://www.publickey1.jp/blog/24/safariwasmgcsafari_technology_preview_202wasmgc.html" target="_blank" rel="noopener"
>SafariでももうすぐWasmGCに対応する&lt;/a>とのことなので、それまで待つしかないですね。&lt;/p>
&lt;h3 id="cjk未対応">CJK未対応
&lt;/h3>&lt;p>いわゆる日本語や中国語、韓国語などの文字が未対応です。Compose Webの場合、まだCJKの文字が未対応のようで、日本語を入力すると文字化けしてしまいます。これはおそらくフォントないしはレンダリングの問題のようで、&lt;a class="link" href="https://github.com/JetBrains/compose-multiplatform/issues/3967" target="_blank" rel="noopener"
>こちらのやりとり&lt;/a>を見ると最新のComposeのバージョンで一部を解消したようですが、Koltinのバージョンによっては使えなかったりするのでまだ色々と調整が必要そうです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回は主にインフラの構成の話になりましたが、Composeを使ってKotlinだけで完結するようなアプリケーションを作るのも目的の一つだったので、もしできれば今後はComposeを使ったアプリケーションの開発についても書いていけたらと思います。Compose Webの場合はJSの時代から少し触っていたものの、最近はWasmの方に力を入れてきたのもあって、まだまだ未対応の部分が多いですが、これからの発展が楽しみですね。個人的には、commonパッケージを通じてサーバとクライアントのコードを共有できるのが一番の魅力だと思っているので、色々とアーキテクチャなどを考えながら開発していきたいと思います。&lt;/p>
&lt;p>それでは、また！&lt;/p></description></item><item><title>KotlinConf'24を要約してみた</title><link>https://retheviper.github.io/posts/kotlin-conf-2024/</link><pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-conf-2024/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post KotlinConf'24を要約してみた" />&lt;p>今年のKotlinConfが開催されました。数日かけてのイベントなので、全てのセッションを見ることはできませんが、まずはキーノートの方で重要な情報をまとめてみました。全体のスケージュールは&lt;a class="link" href="https://kotlinconf.com/schedule/" target="_blank" rel="noopener"
>こちら&lt;/a>から確認できて、&lt;a class="link" href="https://www.youtube.com/@Kotlin/streams" target="_blank" rel="noopener"
>YouTubeでのライブ配信&lt;/a>も行われているので、興味がある方はぜひチェックしてみてください。&lt;/p>
&lt;p>まずはKotlinConf'24の公式アプリの紹介がありました。公式アプリでは今回行われるカンファレンスとセッションを確認できるもので、&lt;a class="link" href="https://github.com/JetBrains/kotlinconf-app" target="_blank" rel="noopener"
>GitHubにてソースコードを公開&lt;/a>しています。Kotlin Multiplatformで作成されていて、iOS、Android、Webで動作するものなので、いいサンプルとして使えるかもしれません。&lt;/p>
&lt;h2 id="kotlinの今">Kotlinの今
&lt;/h2>&lt;p>まずはKotlinの現状から。常にKotlinを使っているエンジニアの数が、200万以上になっているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage_hu_4e9cf5b624b95683.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage_hu_6ac0077569f6a802.webp 1024w"
loading="lazy"
alt="Kotlinエンジニア数"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>また、Kotlinを導入している企業もどんどん増えているとのことです。代表的な企業は以下の画像通りだそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies_hu_2afd80792f626843.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies_hu_4ba914d418e07899.webp 1024w"
loading="lazy"
alt="Kotlin導入企業"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="kotlin-20-and-k2-compiler">Kotlin 2.0 and K2 Compiler
&lt;/h2>&lt;p>Kotlin 2.0からはK2コンパイラーの導入により、全般的にコンパイルの速度が向上したという話が主なテーマです。ただ一部プロジェクトでは、遅くなるケースもあるとのことでした。また、IntellijでもK2コンパイラーモードがあり、コードハイライトが1.8倍速くなるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance.webp"
width="2056"
height="1216"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance_hu_995494b92274491a.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance_hu_e585bbf4afa9caed.webp 1024w"
loading="lazy"
alt="K2コンパイラーの速度比較"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="405px"
>&lt;/p>
&lt;p>K2モードは、Intellij 2024.1以上から以下の設定画面で設定できます。2024.2からは性能の改善を含め、Beta版として提供される予定です。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode.webp"
width="2188"
height="1668"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode_hu_cc1ee1f60f04b49c.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode_hu_53a70291ccc901c2.webp 1024w"
loading="lazy"
alt="IntellijのK2モード設定画面"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="314px"
>&lt;/p>
&lt;p>2.0へのマイグレーションは1000万行のコード、18000人のエンジニア、80000のプロジェクトでテストされていて、1.9からのマイグレーションはスムーズに行えるとのことです。&lt;/p>
&lt;h3 id="metaの場合">Metaの場合
&lt;/h3>&lt;p>Metaの場合、Kotlin firstでの開発を積極的に進めているとのことでした。IDEからコードの最適化までの全てにおいてKotlinを採用して、既存のJavaで作成されたFacebook, Instagram, Facebook Messenger, WhatsAppなどのアプリにおいて、Kotlinに自動変換できるツールを作成して移行を自動化しているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin_hu_4d0f93915338f0d4.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin_hu_1fae96dffddfbab6.webp 1024w"
loading="lazy"
alt="MetaのKotlin採用"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>そしてMetaはKotlin 1.8の時点から一部のプロジェクトにおいてすでにK2コンパイラーを採用していて、今は95%のプロジェクトがK2コンパイラーを使っているとのことです。その効果としてはAndroidプロジェクトにおいては最大20%のビルド時間の短縮ができたらしいです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler_hu_a06bae37e498f04b.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler_hu_f89f06054d07900c.webp 1024w"
loading="lazy"
alt="MetaのK2コンパイラー採用"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="googleの場合">Googleの場合
&lt;/h3>&lt;p>K2コンパイラーにはGoogle側も協力していて、Androidのツーリングに関してLintや&lt;a class="link" href="https://developer.android.com/kotlin/parcelize?hl=ja" target="_blank" rel="noopener"
>Parcelize&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/docs/ksp-overview.html" target="_blank" rel="noopener"
>KSP&lt;/a>などにもコントリビュートしているそうです。また、Jetpack Composeのコンパイラーの改善もあり、従来はKotlinとバージョンと相違があったのですが、2.0からは同じバージョンで指定できるようになったとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update_hu_7b9333b7c555873b.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update_hu_bfd35cd48dc981bc.webp 1024w"
loading="lazy"
alt="Composeコンパイラーのバージョン指定"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>またAndroid StudioでもKotlin 2.0のサポートを予定しているとのことでした。代表的な機能は以下の画像の通りです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0_hu_7dff0fb15be9b6ab.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0_hu_fed40825b935d73.webp 1024w"
loading="lazy"
alt="AndroidのKotlin 2.0サポート"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Jetpack Composeにおいても新しい機能を追加される予定だそうです。主に以下の画像で挙げている機能が、7月から提供される予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming_hu_f6324f0dc884ac26.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming_hu_90ff3bb7ee738ba9.webp 1024w"
loading="lazy"
alt="Jetpack Composeの追加予定機能"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>コンパイラーそのものの改善もあり、安定性やパフォーマンスが向上しているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance_hu_7c366b40ecc6b27b.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance_hu_9212055a1d57c8f3.webp 1024w"
loading="lazy"
alt="Jetpack Composeの性能改善"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>他にも、Google内部ではサーバサイドKotlinの採用も進んでいたり、KMPによる開発も進んでいるとのことでした。あとはJetpack ComposeのライブラリもMultiplatformに対応していて、ViewModelやRoomなどのライブラリもKotlin Multiplatformで使えるようになったとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform_hu_bf02a4153e503efd.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform_hu_760e4b1939fe9545.webp 1024w"
loading="lazy"
alt="Jetpack ComposeのMultiplatform対応"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="kotlin-multiplatform">Kotlin Multiplatform
&lt;/h2>&lt;p>K2コンパイラーの導入により、Kotlinのコードを直接Swiftのコードに変換することができるようになったとのことです。これにより、iOSアプリの開発においてもKotlin Multiplatformを使って開発することができるようになりました。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift_hu_dbefec7d7fa660fd.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift_hu_74ff27f4f0ead6a3.webp 1024w"
loading="lazy"
alt="KotlinのSwift変換"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>そして&lt;a class="link" href="https://www.jetbrains.com/ja-jp/fleet/" target="_blank" rel="noopener"
>Fleet&lt;/a>で、iOSアプリも開発できるという紹介もありました。FleetだとCompose MultiplatformによるiOSとAndroidのアプリ開発が同時に可能で、リファクタからデバッグまで一貫して開発できるとのことです。AppCodeのサポートが2023年に終了となっていたので、これは嬉しいニュースですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development_hu_fd64c057d5f2e7e4.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development_hu_401bce085ec4a66b.webp 1024w"
loading="lazy"
alt="FleetでのMultiplatform開発"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>また、新しいビルドツールである&lt;a class="link" href="https://github.com/JetBrains/amper" target="_blank" rel="noopener"
>Amper&lt;/a>も紹介されました。まだ発表されてから間もないのですが、すでにJetBrainsのIDEでサポートされていて、YAMLファイルだけでビルド設定を行うことができるので、新しいプロジェクトで使ってみるのもいいかもしれません。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/amper.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/amper_hu_50fac021c2f0f455.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/amper_hu_79b0a97016c43cca.webp 1024w"
loading="lazy"
alt="Amperの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Compose Multiplatformにおいても、以下の新しい機能が追加されたらしいです。どれも期待していた機能だったので、嬉しいですね。個人的にはデスクトップアプリでファイルの選択ダイアログを実装した時に、対応する機能がなくJavaのAWTを使わざるを得なかったので、このようなAPIもあるといいなと思っています。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform_hu_a5236acb62cc7ddb.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform_hu_cb6e6ac8e6384e7a.webp 1024w"
loading="lazy"
alt="Compose Multiplatformの新機能"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="upcoming">Upcoming
&lt;/h2>&lt;p>次に、Kotlin 2.1のベータ版から導入予定の機能について紹介や、新しいライブラリ、AIモデルの発表がありました。以下の画像の通りです。&lt;/p>
&lt;h3 id="guard">Guard
&lt;/h3>&lt;p>whenの分岐で、変数の重複を防ぐための機能です。既存のコードなら、以下のようなコードで&lt;code>status&lt;/code>が重複する場合があっても、どうしようもなかったですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">render&lt;/span>(status: Status): String =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Loading &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Loading&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.isEmpty() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;No data&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">-&amp;gt;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.joinToString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Error &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.isCritical &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Critical problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unknown problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なぜなら、以下のようにコードを変えた場合に&lt;code>and&lt;/code>でコンパイルエラーが発生してしまうからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">render&lt;/span>(status: Status): String =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (status) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Status&lt;/span>.Loading &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Loading&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.isEmpty() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;No data&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Error: expecting &amp;#39;-&amp;gt;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">-&amp;gt;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.joinToString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Error &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.isCritical &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Critical problem&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Error: expecting &amp;#39;-&amp;gt;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unknown problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを改善するため、以下のように&lt;code>Guarded Condition&lt;/code>を導入する予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard_hu_feb9f7f388eb5f77.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard_hu_c93fc04e1d3cc334.webp 1024w"
loading="lazy"
alt="Guardの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="-escaping-problem">$-escaping problem
&lt;/h3>&lt;p>Kotlinで&lt;code>$&lt;/code>は、文字列の中で変数を埋め込むために使われています。ということは、&lt;code>$&lt;/code>を文字列として使いたい場合にエスケープの問題が発生するとのことでもあります。特にMulti-line Stringがそうですね。例えば、以下の例があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jsonSchema: String = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$schema&amp;#34;: &amp;#34;https://json-schema.org/draft/2020-12/schema&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$id&amp;#34;: &amp;#34;https://example.com/product.schema.json&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$dynamicAnchor&amp;#34;: &amp;#34;meta&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;title&amp;#34;: &amp;#34;Product&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>schema&lt;/code>や&lt;code>id&lt;/code>などは変数ではなく、文字列として使いたい場合がありますが、Multi-line Stringの場合にはエスケープができません。なので、以下のようなコードになるケースもありました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jsonSchema: String = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}schema&amp;#34;: &amp;#34;https://json-schema.org/draft/2020-12/schema&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}id&amp;#34;: &amp;#34;https://example.com/product.schema.json&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}dynamicAnchor&amp;#34;: &amp;#34;meta&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;title&amp;#34;: &amp;#34;Product&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを解決するために、文字列リテラルで&lt;code>$&lt;/code>を2回入れることでinterpolationできるようにする、という機能が導入される予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape_hu_a58d40bbc60f5b46.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape_hu_78e1ebe706d6372f.webp 1024w"
loading="lazy"
alt="$-escaping problemの解決"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="non-local-breakcontinue">Non-local break/continue
&lt;/h3>&lt;p>今までは、コンパイラーがLambdaが実行される場所を特定できないため、&lt;code>break&lt;/code>や&lt;code>continue&lt;/code>が使えなかったです。なので、以下のようなコードはエラーになってしまいます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0.&lt;/span>.n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> date = state[i]&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#75715e">// Error: &amp;#39;break&amp;#39; is not allowed here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">continue&lt;/span> &lt;span style="color:#75715e">// Error: &amp;#39;continue&amp;#39; is not allowed here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> process(&lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これもまた、Kotlin 2.1からは&lt;code>let&lt;/code>のようなinline関数を正しく解析できるようになるため、&lt;code>break&lt;/code>や&lt;code>continue&lt;/code>が使えるようになるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/non-local-break-and-continue.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/non-local-break-and-continue_hu_9eb056c8d7fab98.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/non-local-break-and-continue_hu_7db07cf0e36c33e2.webp 1024w"
loading="lazy"
alt="Non-local break/continueの解決"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="contexts">Contexts
&lt;/h3>&lt;p>去年発表された&lt;code>Context&lt;/code>についても発表がありました。これはすでにプレビューとして導入されていて、Kotlin 2.2からはベータ版として提供される予定だそうです。これでDIと似たようなことをしたり、セッションやトランザクションなど色々な関数で使い回す必要があるものは、関数の引数に渡すことなく、&lt;code>Context&lt;/code>を使って共有することができるようになります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/contexts.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/contexts_hu_6adb0c80d16cd915.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/contexts_hu_5fcb8848d262c7d5.webp 1024w"
loading="lazy"
alt="Contextの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="core-libraries">Core Libraries
&lt;/h3>&lt;p>Kotlinのコアライブラリも改善される予定だそうです。すでに発表されている&lt;a class="link" href="https://github.com/Kotlin/kotlinx-io" target="_blank" rel="noopener"
>kotlinx.io&lt;/a>のようなものだけでなく、&lt;a class="link" href="https://github.com/Kotlin/kotlinx-rpc" target="_blank" rel="noopener"
>kotlinx.rpc&lt;/a>のような新しいライブラリの発表もありました。これらのコアライブラリは、Multiplatformでの開発をサポートするために提供されるもので、どのプラットフォームでも使えるものです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries_hu_de9dd39f9dc31c00.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries_hu_50864685e01f0401.webp 1024w"
loading="lazy"
alt="Core Librariesの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="aws-sdk-for-kotlin">AWS SDK for Kotlin
&lt;/h3>&lt;p>Kotlin用のAWS SDKも提供される予定という発表もありました。今まではJavaのSDKを使うことが多かったのですが、CoroutineやNull SafetyのようなKotlinの特徴を活かせつつ、Multiplatformで使えるSDKが提供されるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk_hu_e384fb78f448f45d.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk_hu_eb83556cbbf75753.webp 1024w"
loading="lazy"
alt="AWS SDK for Kotlinの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="kotlin-language-model">Kotlin Language Model
&lt;/h3>&lt;p>Fleetではすでに利用可能で、Intellijでは2024.2から利用可能となるKotlinの言語モデルが開発中のことです。既存のいくつかのモデルと比べ、Kotlinに特化されたからか、比較的パラメータの数が少ないことに比べ、ベンチマークでは高い精度を示しているとのことです。ただ、比較で使っているLlamaの場合はすでにバージョン3がリリースされているので、最新のモデルと比べる場合どの程度の精度があるのかは気になるところです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model_hu_87a2792b84bf0a01.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model_hu_269c801066de89bf.webp 1024w"
loading="lazy"
alt="Kotlin Language Modelの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>KotlinConf'24のキーノートでの発表内容を以上でまとめてみました。他にも多くのセッションがあ理、Kotlin 2.0も&lt;a class="link" href="https://github.com/JetBrains/kotlin/releases/tag/v2.0.0" target="_blank" rel="noopener"
>Changelog&lt;/a>を見ると、多くの変更があるので、また色々とチェックしていきたいところですね。&lt;/p>
&lt;p>Composeの発展も良かったのですが、Flutterのような他のフレームワークもあるのでこれからどれだけのシェアを取れるかが楽しみです。言語としても他の言語の発展も早いので、Kotlinも引けを取らないように頑張ってほしいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>動的画像リサイズAPIを作る</title><link>https://retheviper.github.io/posts/image-resize-api/</link><pubDate>Sat, 30 Mar 2024 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/image-resize-api/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.webp" alt="Featured image of post 動的画像リサイズAPIを作る" />&lt;p>この度は、動的画像リサイズのAPIを作りましたのでその紹介です。ここでおいう動的画像リサイズAPIとは、元の画像のURLとリサイズしたいサイズを指定すると、そのサイズにリサイズした画像を返すAPIです。&lt;/p>
&lt;h2 id="目的">目的
&lt;/h2>&lt;p>そもそも動的画像リサイズAPIを作る理由はなにか。それから説明しないとですね。今までは画像の配信において、エンドユーザが画像をアップロードする場合、あらかじめサムネイルの画像も作成してアップロードするようにしていました。&lt;/p>
&lt;p>ただ、その方法だと全ての画面比と解像度に対応したサムネイルを作れないという問題があります。そのため代案として、フロントエンドから画面に最適化したサイズを指定して、APIからリサイズした画像を取得するようにしたいというのが目的です。&lt;/p>
&lt;h2 id="設計技術選定">設計・技術選定
&lt;/h2>&lt;p>APIはマイクロサービスとして、なるべくシンプルに作ることにしました。Getのエンドポイントを一つ持っていて、そこにクエリパラメータで元の画像のURLとリサイズしたいサイズを指定すると、リサイズした画像を返すというものです。フロントエンドではそのままimgタグに使えるようにしたいので、返すのは画像のデータそのまま（ヘッダーには&lt;code>Content-type&lt;/code>を指定）にします。また、リサイズだけでなく、画像の形式を変換することもできるようにします。&lt;/p>
&lt;p>また、APIは&lt;a class="link" href="https://cloud.google.com/run?hl=ja" target="_blank" rel="noopener"
>Cloud Run&lt;/a>上で動かすことにしました。既存のAPIもそうなので使い方を合わせるためでもあり、ローカルでの開発でもdocekr composeを使って楽に開発できるためです。他にもコンテンツの配信には&lt;a class="link" href="https://cloud.google.com/storage?hl=ja" target="_blank" rel="noopener"
>Cloud Storage&lt;/a>を使っているので、それとの連携もしやすいためです。そして最終的に処理された画像は、Cloud CDNに保存され、2回目以降の呼び出しではキャッシュを返すようにします。&lt;/p>
&lt;p>会社ではすでにウェブフレームワークとしてKtorを採用しているので、それと揃えるためにこちらもKtorを採用。Ktorの以前ににNode.jsとRustによる実装を試みたことがありますが、前者は性能の問題から、後者はメンテが難しくなる問題から（社内にRustができる人が少ないので）採用しない方になっています。当時作成していたRustバージョンに近いサンプルコードはGitHubにて公開していますので、&lt;a class="link" href="https://github.com/retheviper/resize-api" target="_blank" rel="noopener"
>こちら&lt;/a>から確認できます。&lt;/p>
&lt;p>画像の変換とリサイズのためには&lt;a class="link" href="https://github.com/sksamuel/scrimage" target="_blank" rel="noopener"
>Scrimage&lt;/a>を採用することにしました。他の候補としてはJavaの&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/javax/imageio/ImageIO.html" target="_blank" rel="noopener"
>ImageIO&lt;/a>なども検討しました。ただ、リサイズ対象の画像のフォーマットと、返すデータのフォーマットとしてWebPを処理する必要があったのですがそれに対応していないものが多かったです。&lt;/p>
&lt;p>他に考えたものとしては、&lt;a class="link" href="http://www.graphicsmagick.org/" target="_blank" rel="noopener"
>GraphicsMagick&lt;/a>のように画像の変換やリサイズを行うツールを使う方法もあります。こちらの場合はJavaから取得したデータを一度ファイルに書き出して、それをコマンドラインで実行するという方法になりますので、その分のI/Oコストがかかるため今回はScrimageを使うことにしました。&lt;/p>
&lt;h2 id="リサイズ処理">リサイズ処理
&lt;/h2>&lt;p>では、実際のAPIを書いていきます。Ktorは使い慣れているのもあり、今回はKtorでのAPI構築というよりはScrimageを使った画像のリサイズ処理が重要なので、その部分に焦点を当てていきます。&lt;/p>
&lt;p>API全体で処理のフローは大まかに以下の通りです。&lt;/p>
&lt;ol>
&lt;li>クエリパラメータからurlとリサイズ後の大きさを取得&lt;/li>
&lt;li>画像の取得&lt;/li>
&lt;li>画像のリサイズ&lt;/li>
&lt;li>画像の形式変換&lt;/li>
&lt;/ol>
&lt;p>ここでScrimageを使った画像の処理は3〜4の部分ですが、実際のリサイズを行う前に取得した画像の形式をまず判定したり、画像のサイズを確認する必要もあります。理由としては処理の効率化のためですね。&lt;/p>
&lt;p>今回はPNG, JPEG, WEBP, GIFの4つの形式に対して、リサイズ後にWEBPに変換するという処理を行うことにしています。ここで元の画像がWEBPだった場合、あえてWEBPに変換する必要はないです。また、リサイズが必要ない場合もあります。そのため、まずは画像の形式を判定して、リサイズが必要な場合のみリサイズ処理を行うようにします。&lt;/p>
&lt;h3 id="画像の形式判定">画像の形式判定
&lt;/h3>&lt;p>URLもしくはローカルストレージ（今回はCloud RunにCloud Storageをマウントする形で使っている）から画像を取得する際、その画像の形式を判定する必要があります。Scrimageでは画像の形式を判定するための&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/format/FormatDetector.java" target="_blank" rel="noopener"
>FormatDetector&lt;/a>というクラスを提供しています。&lt;/p>
&lt;p>使い方は簡単で、以下のように読み込んだ画像のデータをByteの配列で渡すだけです。API上では想定してないフォーマットが来た場合はエラーを返すようにしていて、ここで返す&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/format/Format.java" target="_blank" rel="noopener"
>Format&lt;/a>はPNG, GIF, JPEG, WEBPでありScrimageのものをそのまま使っています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">detectImageFormat&lt;/span>(&lt;span style="color:#66d9ef">data&lt;/span>: ByteArray): Format {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">FormatDetector&lt;/span>.detect(&lt;span style="color:#66d9ef">data&lt;/span>).orElseThrow { IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;Unsupported format&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="png-jpegの処理">PNG, JPEGの処理
&lt;/h3>&lt;p>まず一番簡単なPNG, JPEGの場合です。これらの形式の場合、Scrimageの&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/ImmutableImage.java" target="_blank" rel="noopener"
>ImmutableImage&lt;/a>として扱うことになります。&lt;/p>
&lt;p>ここで画像のデータをImmutableImageに変換するには&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/nio/ImageReader.java" target="_blank" rel="noopener"
>ImageReader&lt;/a>のインタフェースを実装したクラスを使います。&lt;a class="link" href="https://sksamuel.github.io/scrimage/" target="_blank" rel="noopener"
>公式サイト&lt;/a>では&lt;code>ImmutableImage.loader()&lt;/code>で形式に関係なく画像を読み込むことができると書いてありますが、実際にAPIをビルドする際はAWT関連のエラーが出るので、形式に応じて読み込むクラスを変える必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asImmutableImage&lt;/span>(rawData: ByteArray): ImmutableImage {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ImageIOReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ImmutableImageに変換したら、リサイズ処理を行います。Scrimageではリサイズのためのメソッドが用意されているので、それを使ってリサイズを行います。&lt;/p>
&lt;p>ここで注意すべきは、&lt;code>resize()&lt;/code>や&lt;code>resizeTo()&lt;/code>のようなメソッドがあるのですが、前者の場合はパーセントでのリサイズ、後者の場合は指定したサイズにリサイズするという違いがあります。これらの場合、元の画像のアスペクト比が保持されないため、&lt;code>scaleTo()&lt;/code>や&lt;code>scaleToWidth()&lt;/code>などのメソッドを使う必要があります。&lt;/p>
&lt;p>今回はwidthのみを指定してアスペクト比を保持したままリサイズするため、&lt;code>scaleToWidth()&lt;/code>を使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeImmutableImage&lt;/span>(image: ImmutableImage, width: Int): ImmutableImage {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image.scaleToWidth(width)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後に、リサイズした結果をByteArrayとして返すためのメソッドを用意します。どの形式に変換するかによって&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/nio/ImageWriter.java" target="_blank" rel="noopener"
>ImageWriter&lt;/a>を実装するクラスを選ぶ必要があります。今回はWEBPにしたいので、&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-webp/src/main/java/com/sksamuel/scrimage/webp/WebpWriter.java" target="_blank" rel="noopener"
>WebpWriter&lt;/a>を使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">encodeImage&lt;/span>(image: ImmutableImage): ByteArray {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image.bytes(&lt;span style="color:#a6e22e">WebpWriter&lt;/span>.DEFAULT)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後にRouterでは、Content-Typeを指定してByteArrayを返すようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>call.respondBytes(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bytes = resizedImage,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> contentType = ContentType(&lt;span style="color:#e6db74">&amp;#34;image&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;webp&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="webpの場合">WEBPの場合
&lt;/h3>&lt;p>WEBPの場合は、上記データ読み込む時点で&lt;code>WebpImageReader&lt;/code>を使う必要があります。その後のリサイズ処理はPNG, JPEGの場合と同じです。&lt;/p>
&lt;p>ただ、形式がWEBPの場合には&lt;a class="link" href="https://github.com/sksamuel/scrimage/tree/master/scrimage-webp" target="_blank" rel="noopener"
>scrimage-webp&lt;/a>が提供している&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-webp/src/main/java/com/sksamuel/scrimage/webp/WebpImageReader.java" target="_blank" rel="noopener"
>WebpImageReader&lt;/a>を使う必要があります。なので、形式に応じて読み込むクラスを変える必要があります。先ほどの&lt;code>asImmutableImage&lt;/code>の引数に形式を追加して、形式に応じて読み込むクラスを変えるようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asImmutableImage&lt;/span>(rawData: ByteArray, format: Format): ImmutableImage {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (format) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.WEBP &lt;span style="color:#f92672">-&amp;gt;&lt;/span> WebpImageReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.GIF, &lt;span style="color:#a6e22e">Format&lt;/span>.PNG, &lt;span style="color:#a6e22e">Format&lt;/span>.JPEG &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ImageIOReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他の処理はPNG, JPEGの場合と同じです。&lt;/p>
&lt;h3 id="gifの場合">GIFの場合
&lt;/h3>&lt;p>GIFの場合は、&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-core/src/main/java/com/sksamuel/scrimage/nio/AnimatedGif.java" target="_blank" rel="noopener"
>AnimatedGif&lt;/a>というクラスを使ってリサイズを行います。ImmutableImageと同じようにリサイズメソッドが用意されているので、それを使ってリサイズを行います。処理で使われるクラスが違うので、GIFの場合は別途メソッドを用意します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asAnimatedGif&lt;/span>(rawData: ByteArray): AnimatedGif {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">AnimatedGifReader&lt;/span>.read(&lt;span style="color:#a6e22e">ImageSource&lt;/span>.of(rawData))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、AnimatedGifの場合はframesというプロパティで各フレームのデータを保持していて、これらはImmutableImageとして扱うことができます。そのため、リサイズ処理は各フレームに対して行い、それをAnimatedGifに戻すという処理を行います。若干複雑ですが、以下のように書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeAnimatedGif&lt;/span>(gif: AnimatedGif, width: Int): AnimatedGif {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> resizedData = ByteArrayOutputStream().use {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StreamingGifWriter().prepareStream(&lt;span style="color:#66d9ef">it&lt;/span>, &lt;span style="color:#a6e22e">BufferedImage&lt;/span>.TYPE_INT_ARGB).use { stream &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gif.frames.mapIndexed { index, image &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stream.writeFrame(image.scaleToWidth(width), gif.getDelay(index))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.toByteArray()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">AnimatedGifReader&lt;/span>.read(&lt;span style="color:#a6e22e">ImageSource&lt;/span>.of(resizedData))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後に、リサイズした結果をByteArrayとして返すためのメソッドを用意します。基本的にはImmutableImageと同じですが、GIFをWEBPに変換する場合は&lt;a class="link" href="https://github.com/sksamuel/scrimage/blob/master/scrimage-webp/src/main/java/com/sksamuel/scrimage/webp/Gif2WebpWriter.java" target="_blank" rel="noopener"
>Gif2WebpWriter&lt;/a>を使います。これでWEBPに変換後も、GIFのアニメーションが保持されたままリサイズすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">encodeGif&lt;/span>(gif: AnimatedGif): ByteArray {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> gif.bytes(Gif2WebpWriter.DEFAULT)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="処理を共通化する">処理を共通化する
&lt;/h2>&lt;p>ここまででPNG, JPEG, WEBP, GIFの4つの形式に対してリサイズ処理を行うことができました。ただ、それぞれの形式に対して処理を書いていると、処理が重複してしまうため、共通化する必要があります。特にImmutableImageとAnimatedGifの処理は似ているため、それらを共通化することにします。&lt;/p>
&lt;h3 id="共通interfaceを作る">共通Interfaceを作る
&lt;/h3>&lt;p>ScrimageではImmutableImageとAnimatedGifは別のクラスであるだけでなく、共通のInterfaceを持っていないため、まずはそれを作成する必要があります。ここでは、ImageというInterfaceを作成し、それを実装するクラスを作成します。それぞれのクラスはWrapperとして作成し、それぞれのクラスのプロパティをInterfaceのプロパティとして持つようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Image&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> width: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AnimatedGifWrapper&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> animatedGif: AnimatedGif
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> width: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = animatedGif.frames.first().width
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ImmutableImageWrapper&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> immutableImage: ImmutableImage
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> width: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = immutableImage.width
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="画像取得の共通化">画像取得の共通化
&lt;/h3>&lt;p>あとは外部に公開するAPIとして、&lt;code>asImage&lt;/code>というメソッドを作成し、それぞれの形式に応じてWrapperを返すようにします。ここで、形式の判定は先ほど作成した&lt;code>detectImageFormat&lt;/code>を使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asImage&lt;/span>(rawData: ByteArray): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">val&lt;/span> format = detectImageFormat(rawData)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.GIF &lt;span style="color:#f92672">-&amp;gt;&lt;/span> asAnimatedGifWrapper(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.WEBP, &lt;span style="color:#a6e22e">Format&lt;/span>.PNG, &lt;span style="color:#a6e22e">Format&lt;/span>.JPEG &lt;span style="color:#f92672">-&amp;gt;&lt;/span> asImmutableImageWrapper(rawData, format)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asAnimatedGifWrapper&lt;/span>(rawData: ByteArray): AnimatedGifWrapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> gif = &lt;span style="color:#a6e22e">AnimatedGifReader&lt;/span>.read(&lt;span style="color:#a6e22e">ImageSource&lt;/span>.of(rawData))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> AnimatedGifWrapper(gif)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">asImmutableImageWrapper&lt;/span>(rawData: ByteArray, format: Format): ImmutableImageWrapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> image = &lt;span style="color:#66d9ef">when&lt;/span> (format) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.WEBP &lt;span style="color:#f92672">-&amp;gt;&lt;/span> WebpImageReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Format&lt;/span>.GIF, &lt;span style="color:#a6e22e">Format&lt;/span>.PNG, &lt;span style="color:#a6e22e">Format&lt;/span>.JPEG &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ImageIOReader().read(rawData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ImmutableImageWrapper(image)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="リサイズ処理の共通化">リサイズ処理の共通化
&lt;/h3>&lt;p>同じく、リサイズ処理も共通化します。ここでは、&lt;code>resizeImage&lt;/code>というメソッドを作成し、それぞれの形式に応じてリサイズ処理を行うようにします。ここで、リサイズ処理は先ほど作成した&lt;code>resizeImmutableImage&lt;/code>と&lt;code>resizeAnimatedGif&lt;/code>を使います。AnimatedGifのリサイズ処理はまた別途&lt;code>writeAnimatedGif&lt;/code>というメソッドを作成して分けています。&lt;/p>
&lt;p>ここでImageはsealed interfaceとして作成しているため、分岐処理はwhen式を使って網羅することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeImage&lt;/span>(image: Image, width: Int): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (image) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> AnimatedGifWrapper &lt;span style="color:#f92672">-&amp;gt;&lt;/span> resizeAnimatedGif(image, width)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> ImmutableImageWrapper &lt;span style="color:#f92672">-&amp;gt;&lt;/span> resizeImmutableImage(image, width)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeAnimatedGif&lt;/span>(gifWrapper: AnimatedGifWrapper, width: Int): AnimatedGifWrapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> gif = gifWrapper.animatedGif
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> resizedData = writeAnimatedGif { stream &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gif.frames.mapIndexed { index, image &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stream.writeFrame(image.scaleToWidth(width), gif.getDelay(index))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> resizedGif = &lt;span style="color:#a6e22e">AnimatedGifReader&lt;/span>.read(&lt;span style="color:#a6e22e">ImageSource&lt;/span>.of(resizedData))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> AnimatedGifWrapper(resizedGif, resizedData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">writeAnimatedGif&lt;/span>(writeFunction: (&lt;span style="color:#a6e22e">StreamingGifWriter&lt;/span>.GifStream) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit): ByteArray {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StreamingGifWriter().use {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> streamingGifWriter.prepareStream(&lt;span style="color:#66d9ef">it&lt;/span>, &lt;span style="color:#a6e22e">BufferedImage&lt;/span>.TYPE_INT_ARGB).use { stream &lt;span style="color:#f92672">-&amp;gt;&lt;/span> writeFunction(stream) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.toByteArray()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resizeImmutableImage&lt;/span>(imageWrapper: ImmutableImageWrapper, width: Int): ImmutableImageWrapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> resizedImage = imageWrapper.immutableImage.scaleToWidth(width)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ImmutableImageWrapper(resizedImage, imageWrapper.format)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="画像のエンコード処理の共通化">画像のエンコード処理の共通化
&lt;/h3>&lt;p>最後に、画像のエンコード処理も共通化します。ここでは、&lt;code>encodeImage&lt;/code>というメソッドを作成し、それぞれの形式に応じてエンコード処理を行うようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">encodeImage&lt;/span>(image: Image): ByteArray {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (image) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> AnimatedGifWrapper &lt;span style="color:#f92672">-&amp;gt;&lt;/span> image.animatedGif.bytes(Gif2WebpWriter.DEFAULT)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> ImmutableImageWrapper &lt;span style="color:#f92672">-&amp;gt;&lt;/span> image.immutableImage.bytes(&lt;span style="color:#a6e22e">WebpWriter&lt;/span>.DEFAULT)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで共通化も終わり、呼び出す側は&lt;code>asImage&lt;/code>, &lt;code>resizeImage&lt;/code>, &lt;code>encodeImage&lt;/code>の3つのメソッドを使うだけでリサイズ処理を行うことができます。サイズのチェックもImageの方でプロパティ化しているため、それを使ってリサイズが必要かどうかの判定も行うことができます。&lt;/p>
&lt;p>あとはImageWriterなど、毎回インスタンスを生成する必要のないクラスは、シングルトンとして作成しておくとよいでしょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>だいぶ長くなってしまいましたが、ここまでで動的画像リサイズAPIの作成方法を紹介しました。Scrimageを使うことで、PNG, JPEG, WEBP, GIFの4つの形式に対してリサイズ処理を行うことができ、共通化することで処理の重複を防ぐことができました。&lt;/p>
&lt;p>あとは、Cloud Run上で動かすためのDockerfileを作成し、Cloud Storageとの連携を行うことで、画像の配信を行うことができます。また、Cloud CDNを使うことで、2回目以降の呼び出しではキャッシュを返すようにすることで、負荷を軽減することができます。なかなか面白いプロジェクトでした。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Cloud BuildのCI/CDを高速化してみた</title><link>https://retheviper.github.io/posts/application-build-cache/</link><pubDate>Sun, 21 Jan 2024 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/application-build-cache/</guid><description>&lt;img src="https://retheviper.github.io/images/gcp.webp" alt="Featured image of post Cloud BuildのCI/CDを高速化してみた" />&lt;p>CI/CDは一度インフラとアプリケーションを構築すれば、あまり変わることはありません。極端な話、期待通り動いてくれれば問題はないといえることです。しかし、場合によってはCI/CDのフローを見直すことも必要になります。アプリケーションの機能追加やインフラの変更などにはいつ変化があるかわからないし、緊急対応が必要な場合は迅速なデプロイが必要とされる場合もあるからです。そのため、CI/CDの高速化が非常に重要な課題となるケースもあります。&lt;/p>
&lt;p>実は去年転職をしましたが、転職先の会社ではCI/CDの高速化が課題となっていました。前職では2週間に一回というリリースのサイクルがあったのですが、今回は一日でも数回のリリースがあるため何よりもそのため、CI/CDの高速化を行うために、いくつかの方法を試してみました。今回はその中で、最も効果があった方法を紹介します。&lt;/p>
&lt;h2 id="インフラ構成">インフラ構成
&lt;/h2>&lt;p>基本的には、以下のような構成になっています。&lt;/p>
&lt;ul>
&lt;li>GitHubにソースコードおよびCI/CDの構成ファイルを配置&lt;/li>
&lt;li>Cloud Buildを利用してDockerコンテナをビルド&lt;/li>
&lt;li>Cloud Runにデプロイ&lt;/li>
&lt;/ul>
&lt;p>この構成はFrontend, Backendともに同じで、データベースマイグレーションも同じ環境となっています。マイグレーションの時にはCloud RunでFlywayを実行してAlloyDBにマイグレーションを行っているようになっています。&lt;/p>
&lt;h2 id="キャッシュで高速化">キャッシュで高速化
&lt;/h2>&lt;p>CI/CDの高速化にはいくつかの方法がありますが、今回はキャッシュを利用することで高速化を行いました。&lt;/p>
&lt;p>高速化のために考えられるのはいくつかの方法がありますが、まずは簡単な方法としてキャッシュを利用することにしました。今回利用したキャッシュは二つで、一つはGradleのキャッシュ、もう一つはDockerイメージのキャッシュです。&lt;/p>
&lt;h3 id="gradleのキャッシュ">Gradleのキャッシュ
&lt;/h3>&lt;p>まずGradleには&lt;a class="link" href="https://docs.gradle.org/current/userguide/build_cache.html" target="_blank" rel="noopener"
>Build Cache&lt;/a>と&lt;a class="link" href="https://docs.gradle.org/current/userguide/configuration_cache.html" target="_blank" rel="noopener"
>Configuration Cache&lt;/a>というものがあり、これらを有効にした場合、次回のビルドからはそれぞれ前回のビルドの成果物とビルド時の設定をキャッシュとして使うことになるのでビルドの時間をかなり短縮することができます。&lt;/p>
&lt;p>これらのキャッシュを有効にするには、&lt;code>gradle.properties&lt;/code>ファイルに以下のように設定を行います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">//&lt;/span> &lt;span style="color:#e6db74">build cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">org.gradle.caching&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">//&lt;/span> &lt;span style="color:#e6db74">configuration cache&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">org.gradle.configuration-cache&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="dockerイメージのキャッシュ">Dockerイメージのキャッシュ
&lt;/h3>&lt;p>Gradleのキャッシュを有効にしても、CI/CDの環境で実際ビルドが走る時に利用できるキャッシュが存在しなければなりません。そのために利用したのがDockerのキャッシュです。Cloud Buildのフローが実行されるたびに前回のビルドの成果物をどこかにプッシュしておき、ビルドが走る時にそれを利用するとGradleのキャッシュを利用することができるようになります。&lt;/p>
&lt;p>これを実現するためにはまず最初にCloud buildの構成ファイルは以前は以下のようになっていました。(一部抜粋)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">gcr.io/cloud-builders/docker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">build&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;-t&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:$COMMIT_SHA&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">api&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;-f&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">api/Dockerfile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">Build&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">gcr.io/cloud-builders/docker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">push&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:$COMMIT_SHA&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">Push&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;gcr.io/google.com/cloudsdktool/cloud-sdk:slim&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">run&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">update&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">$_SERVICE_NAME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;--platform=managed&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;--image=$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:COMMIT_SHA&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &amp;gt;-&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --labels=managed-by=gcp-cloud-build-deploy-cloud-run,commit-sha=$COMMIT_SHA,gcb-build-id=$BUILD_ID,gcb-trigger-id=$_TRIGGER_ID,$_LABELS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;--region=$_DEPLOY_REGION&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;--quiet&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">Deploy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">entrypoint&lt;/span>: &lt;span style="color:#ae81ff">gcloud&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">images&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:COMMIT_SHA&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のファイルでは、最初にコミットのハッシュでDockerイメージをビルドし、それをプッシュしています。その後、Cloud Runにデプロイするために、そのイメージを利用しています。この時、イメージのタグにはコミットのハッシュを利用しています。&lt;/p>
&lt;p>ここでキャッシュを挟むようにすると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">gcr.io/cloud-builders/docker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;-c&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &amp;gt;-&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> docker pull $_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:latest
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> || exit 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">Pull&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">entrypoint&lt;/span>: &lt;span style="color:#ae81ff">bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">gcr.io/cloud-builders/docker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">build&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;--cache-from&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:latest&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;-t&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:$COMMIT_SHA&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;-t&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:latest&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">api&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;-f&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">api/Dockerfile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">Build&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">gcr.io/cloud-builders/docker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">push&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:$COMMIT_SHA&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">Push (Cache)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">gcr.io/cloud-builders/docker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">push&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:latest&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">Push (Latest)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;gcr.io/google.com/cloudsdktool/cloud-sdk:slim&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">args&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">run&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">services&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">update&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">$_SERVICE_NAME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;--platform=managed&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;--image=$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:latest&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &amp;gt;-&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --labels=managed-by=gcp-cloud-build-deploy-cloud-run,commit-sha=$COMMIT_SHA,gcb-build-id=$BUILD_ID,gcb-trigger-id=$_TRIGGER_ID,$_LABELS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;--region=$_DEPLOY_REGION&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;--quiet&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">Deploy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">entrypoint&lt;/span>: &lt;span style="color:#ae81ff">gcloud&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">images&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#39;$_GCR_HOSTNAME/$PROJECT_ID/$REPO_NAME/$_SERVICE_NAME:latest&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のファイルでは、まず最初に前回のビルドの成果物をプルしています。これにより、前回のビルドの成果物を利用することができます。その後、ビルドでは&lt;code>--cache-from&lt;/code>オプションを利用して、前回のビルドの成果物をキャッシュとして利用しています。また、イメージのタグには&lt;code>latest&lt;/code>とコミットのハッシュを利用しています。そして最後にContainer Registryに&lt;code>latest&lt;/code>とコミット8種の両方をプッシュします。こうすると、Container Registryでは一つのイメージに対して二つのタグが付与され、次回のビルドでも&lt;code>latest&lt;/code>を利用できるようになります。&lt;/p>
&lt;h3 id="dockerfileの修正">Dockerfileの修正
&lt;/h3>&lt;p>Dockerイメージをビルドする際にDockerfileを使っていましたが、キャッシュをより効率的に利用するためにDockerfileを修正しました。修正前のDockerfileは以下のようになっていました。(一部抜粋)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span>&lt;span style="color:#e6db74"> eclipse-temurin:17&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> mkdir /api&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">WORKDIR&lt;/span>&lt;span style="color:#e6db74"> /api&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> ./gradlew build -x test -x compileTestKotlin&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のDockerfileでは、まずGradleのビルドを行っていて、成果物はGradleの設定によりjarファイルとしてビルドされます。そしてCloud RunではリポジトリないのEntrypointを実行するように設定しているため、jarファイルを実行するようになっています。&lt;/p>
&lt;p>一般的にはjarファイルだけを残すとコンテナのサイズを小さくすることができますが、今回はキャッシュを利用するためにjarファイル以外の成果物も残す必要があるので、ここは修正していません。ただ、Gradleのビルドが走る時に、毎回依存関係の解決を行うのは非常に時間がかかるので、依存関係の解決を行う部分だけをキャッシュするようにしました。結果は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span>&lt;span style="color:#e6db74"> eclipse-temurin:17&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">WORKDIR&lt;/span>&lt;span style="color:#e6db74"> /api&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># dependency cache&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> build.gradle.kts settings.gradle.kts gradlew gradle.properties /api/&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> gradle /api/gradle&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> docker /api/docker&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> detekt /api/detekt&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> ./gradlew build -x test -x compileTestKotlin -x detekt &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># build app&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> src /api/src&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> resources /api/resources&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> ./gradlew build -x test -x compileTestKotlin&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>デプロイではほとんどの場合、ソースコードの変更が行われます。なので、あまり変わることのないGradle関係のファイルだけを先にコピーして、ソースコードのない状態でビルドを行います。これにより、実際のアプリはビルドされずに依存関係の解決だけが行われます。それからソースコードをコピーしてビルドを行います。&lt;/p>
&lt;p>なぜこのような構造にしたかというと、Dockerイメージのビルド時にはキャッシュが存在していても、コピーしたファイルに変更があった場合にキャッシュが無効になるためです。依存関係の更新があった場合は仕方なくキャッシュは効かなくなりますが、ソースコードの変更がない場合は依存関係の解決まではキャッシュが有効になるため、ビルドの時間を短縮することができます。&lt;/p>
&lt;p>ここでは主にBackendの設定を紹介しましたが、Frontendの設定もDockerfileを同じように修正することでキャッシュを利用できるようにしています。backendと多少は設定が違いますが、基本的にはyarnもGradleと仕組みとしては同じく先に依存関係の解決を行うようにするだけです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span>&lt;span style="color:#e6db74"> node:18.17.1-slim AS base&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">WORKDIR&lt;/span>&lt;span style="color:#e6db74"> /app&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># dependency cache&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> package.json yarn.lock ./&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> yarn --frozen-lockfile&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> ./tsconfig.json ./&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> ./packages/app/package.json ./packages/app/package.json&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> cd ./packages/app &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> yarn &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e"># build app&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">FROM&lt;/span>&lt;span style="color:#e6db74"> base AS builder&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">WORKDIR&lt;/span>&lt;span style="color:#e6db74"> /app&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> ./packages/app/ ./packages/app/&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">COPY&lt;/span> --from&lt;span style="color:#f92672">=&lt;/span>base /app/packages/app ./packages/app&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">RUN&lt;/span> yarn build:app:production&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>データベースマイグレーションの場合、Cloud Buildで直接DBに接続してマイグレーションを行うのが難しかったのと、Backendと同様の設定をすることでDBアクセスは簡単にできたので基本的にはBackendと同じくDockerイメージを作成し、Cloud Run上でEntrypointのスクリプトを利用しFlywayを実行するようにしていました。&lt;/p>
&lt;p>ただ、ここでBackendと同じDockerfileを使って同じくアプリをビルドしたあと、実際のアプリをCloud Runで実行するようになっていましたが、ここは必要なかったので（Cloud Runでは指定したポートからコンテナが応答するようにすればいいだけなので）アプリのビルドは行わなく、依存関係の解決だけを行うようにしました。ポートからの応答に関してはnginxを起動して応答するようにしています。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回はCI/CDの高速化について紹介しました。キャッシュを利用することで、ビルドの時間が大幅に短縮できて、既存だと14分ほどかかっていたのが今は6分ほどになっているので、一日中でも数回のリリースが行われる現状はかなり大きい成果だと言えます。ただ、データベースのマイグレーションではCloud Runを使わないようにするなど依然として改善の余地はありますね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Java 21は何が変わったか</title><link>https://retheviper.github.io/posts/java-enter-to-21/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-enter-to-21/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Java 21は何が変わったか" />&lt;p>Java 17がリリースされてから約2年、今月にはJava 21がリリースされます。まだ案件によっては1.7など古いバージョンを使っている場合も多いと思いますが、21は新しいLTSなので、今後新しいプロジェクトを始めるときは採用を検討するのも良いかもしれません。そこで今回はJava 21で何が変わったのかをざっくりとまとめてみました。&lt;/p>
&lt;p>今回の記事はJava 17からの変化について述べているので、Java 11から17までの変化については&lt;a class="link" href="../java-enter-to-17/" >前回のポスト&lt;/a>を参照してください。&lt;/p>
&lt;h2 id="言語スペック">言語スペック
&lt;/h2>&lt;h3 id="string-templates-preview">String Templates (Preview)
&lt;/h3>&lt;p>Kotlinのような言語にはいわゆるString Interpolationという機能があります。これは文字列の中に変数を埋め込むことができる機能ですね。例えばxとyという変数があったとして、それをStringに埋め込むときにKotlinだと以下のように書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> s = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$x&lt;/span>&lt;span style="color:#e6db74"> plus &lt;/span>&lt;span style="color:#e6db74">$y&lt;/span>&lt;span style="color:#e6db74"> equals &lt;/span>&lt;span style="color:#e6db74">${x + y}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをJavaで実現するためには以下のように書くことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String concatenation&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; plus &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> y &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; equals &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">+&lt;/span> y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// StringBuilder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#e6db74">&amp;#34; plus &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#e6db74">&amp;#34; equals &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(x &lt;span style="color:#f92672">+&lt;/span> y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String.format&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%2$d plus %1$d equals %3$d&amp;#34;&lt;/span>, x, y, x &lt;span style="color:#f92672">+&lt;/span> y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String t &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%2$d plus %1$d equals %3$d&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">formatted&lt;/span>(x, y, x &lt;span style="color:#f92672">+&lt;/span> y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// MessageFormat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MessageFormat mf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MessageFormat(&lt;span style="color:#e6db74">&amp;#34;{0} plus {1} equals {2}&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> mf.&lt;span style="color:#a6e22e">format&lt;/span>(x, y, x &lt;span style="color:#f92672">+&lt;/span> y);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらの方法はどれも冗長で、可読性が低いです。そこでJava 21ではString Templatesという機能が追加されました。これは文字列の中に変数を埋め込むことができる機能です。なので、Javaでももっと簡単な方法でStringを作成することができるようになりました。&lt;/p>
&lt;p>ただ、String InterpolationにはSQL Injectionのような問題があるので、Javaでは別のアプローチを取りました。これは文字列の中に変数を埋め込むのではなく、文字列の中に変数を埋め込むための&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/lang/StringTemplate.html" target="_blank" rel="noopener"
>テンプレート&lt;/a>をまず作成して、それを使って文字列を作成するという方法になっています。なのでコード以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// STRを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Joan&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String info &lt;span style="color:#f92672">=&lt;/span> STR.&lt;span style="color:#e6db74">&amp;#34;My name is \{name}&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// My name is Joan&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RAWを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Joan&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringTemplate st &lt;span style="color:#f92672">=&lt;/span> RAW.&lt;span style="color:#e6db74">&amp;#34;My name is \{name}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String info &lt;span style="color:#f92672">=&lt;/span> STR.&lt;span style="color:#a6e22e">process&lt;/span>(st); &lt;span style="color:#75715e">// My name is Joan&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/lang/StringTemplate.html#STR" target="_blank" rel="noopener"
>STR&lt;/a>や&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/lang/StringTemplate.html#RAW" target="_blank" rel="noopener"
>RAW&lt;/a>はStringTemplateのインスタンスをまず作るようになっていますが、このStringTemplateのインスタンスにはfragmentsというフィールドとvaluesという配列があります。fragmentsは文字列の中に変数があるところを空文字列に置き換えたものの配列で、valuesは変数の値の配列です。なので、変数を埋め込んだ結果の文字列だけでなく実際与えられた変数の値も取得することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> 10, y &lt;span style="color:#f92672">=&lt;/span> 20;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringTemplate st &lt;span style="color:#f92672">=&lt;/span> RAW.&lt;span style="color:#e6db74">&amp;#34;\{x} plus \{y} equals \{x + y}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> st.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// StringTemplate{ fragments = [ &amp;#34;&amp;#34;, &amp;#34; plus &amp;#34;, &amp;#34; equals &amp;#34;, &amp;#34;&amp;#34; ], values = [10, 20, 30] }&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、StringTemplateにはProcessorというInterfaceがあり、Functional Interfaceとして独自の実装をすることも可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Processor Interface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">StringTemplate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@FunctionalInterface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Processor&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>R, E &lt;span style="color:#66d9ef">extends&lt;/span> Throwable&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> R &lt;span style="color:#a6e22e">process&lt;/span>(StringTemplate st) &lt;span style="color:#66d9ef">throws&lt;/span> E;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> INTER &lt;span style="color:#f92672">=&lt;/span> StringTemplate.&lt;span style="color:#a6e22e">Processor&lt;/span>.&lt;span style="color:#a6e22e">of&lt;/span>(StringTemplate::interpolate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> INTER.&lt;span style="color:#e6db74">&amp;#34;\{x} plus \{y} equals \{x + y}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだPreviewなので、このような使い方は今後変わる可能性がありますが、かなり面白いアプローチなので今後の動向に注目したい機能でした。&lt;/p>
&lt;h3 id="sequenced-collections">Sequenced Collections
&lt;/h3>&lt;p>JavaのCollectionの場合、種類によって最後の要素を取るためには色々書き方が変わったり、冗長になったりしますね。例えば、最初の要素と最後の要素を取る場合Collecitonの種類によって以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// List&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> firstOnList &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> lastOnList &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(list.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Deque&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> firstOnDeque &lt;span style="color:#f92672">=&lt;/span> deque.&lt;span style="color:#a6e22e">getFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> lastOnDeque &lt;span style="color:#f92672">=&lt;/span> deque.&lt;span style="color:#a6e22e">getLast&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SortedSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> firstOnSortedSet &lt;span style="color:#f92672">=&lt;/span> sortedSet.&lt;span style="color:#a6e22e">first&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> lastOnSortedSet &lt;span style="color:#f92672">=&lt;/span> sortedSet.&lt;span style="color:#a6e22e">last&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// LinkedHashSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> firstOnLinkedHashSet &lt;span style="color:#f92672">=&lt;/span> linkedHashSet.&lt;span style="color:#a6e22e">iterator&lt;/span>().&lt;span style="color:#a6e22e">next&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> lastOnLinkedHashSet &lt;span style="color:#f92672">=&lt;/span> linkedHashSet.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">reduce&lt;/span>((first, second) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> second).&lt;span style="color:#a6e22e">orElse&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、ループを逆順にする場合もコードは冗長になったり、使い勝手が悪く感じられる場合もあります。例えば以下のコードを見ると、やろうとしていることは一緒なのに、コードが全然違うということがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// NavigableSet with descendingSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> e: navigableSet.&lt;span style="color:#a6e22e">descendingSet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Deque with reverse Iterator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> deque.&lt;span style="color:#a6e22e">descendingIterator&lt;/span>(); it.&lt;span style="color:#a6e22e">hasNext&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> e &lt;span style="color:#f92672">=&lt;/span> it.&lt;span style="color:#a6e22e">next&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// List with reverse ListIterator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">listIterator&lt;/span>(list.&lt;span style="color:#a6e22e">size&lt;/span>()); it.&lt;span style="color:#a6e22e">hasPrevious&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> e &lt;span style="color:#f92672">=&lt;/span> it.&lt;span style="color:#a6e22e">previous&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また実装クラスによっては要素の順番が保持されるCollectionからそうでないものにダウングレードされるケースもあります。例えばLinkedHashSetをCollections::unmodifiableSetでラップすると、LinkedHashSetの順番が失われることになります。&lt;/p>
&lt;p>そこでJava 21では&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/SequencedCollection.html" target="_blank" rel="noopener"
>SequencedCollection&lt;/a>および&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/SequencedSet.html" target="_blank" rel="noopener"
>SequencedSet&lt;/a>というInterfaceを追加して、上記の問題を解決します。これらInterfaceは以下のようなメソッドを提供します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SequencedCollection&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Collection&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// new method&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedCollection&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">reversed&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// methods promoted from Deque&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addFirst&lt;/span>(E);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addLast&lt;/span>(E);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E &lt;span style="color:#a6e22e">getFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E &lt;span style="color:#a6e22e">getLast&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E &lt;span style="color:#a6e22e">removeFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E &lt;span style="color:#a6e22e">removeLast&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SequencedSet&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>, SequencedCollection&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedSet&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">reversed&lt;/span>(); &lt;span style="color:#75715e">// covariant override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>またMapにおいても&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/SequencedMap.html" target="_blank" rel="noopener"
>SequencedMap&lt;/a>というInterfaceが追加されていて、以下のようなメソッドを提供します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SequencedMap&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>K,V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>K,V&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// new methods&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>K,V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">reversed&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedSet&lt;span style="color:#f92672">&amp;lt;&lt;/span>K&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">sequencedKeySet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedCollection&lt;span style="color:#f92672">&amp;lt;&lt;/span>V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">sequencedValues&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedSet&lt;span style="color:#f92672">&amp;lt;&lt;/span>Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K,V&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">sequencedEntrySet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V &lt;span style="color:#a6e22e">putFirst&lt;/span>(K, V);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V &lt;span style="color:#a6e22e">putLast&lt;/span>(K, V);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// methods promoted from NavigableMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">firstEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">lastEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">pollFirstEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">pollLastEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらの新しいInterfaceが追加されることで、Collection全体の継承関係が以下のように変更されました。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/java-enter-to-21/SequencedCollectionDiagram20220216.webp"
width="1512"
height="840"
srcset="https://retheviper.github.io/posts/java-enter-to-21/SequencedCollectionDiagram20220216_hu_21426385c5c95c7d.webp 480w, https://retheviper.github.io/posts/java-enter-to-21/SequencedCollectionDiagram20220216_hu_dfa4c98e808e1924.webp 1024w"
loading="lazy"
alt="Sequenced Collections"
class="gallery-image"
data-flex-grow="180"
data-flex-basis="432px"
>
&lt;em>出典：OpenJDK - &lt;a class="link" href="https://openjdk.org/jeps/431" target="_blank" rel="noopener"
>JEP 431: Sequenced Collections&lt;/a>&lt;/em>&lt;/p>
&lt;p>継承関係によってダウンキャストが発生する場合もあるかなと思いますが、Listの場合はSequencedCollectionを継承しているのでそのまま新しいメソッドを使うことができます。&lt;/p>
&lt;h3 id="generational-zgc">Generational ZGC
&lt;/h3>&lt;p>ZGCはJava 11で導入されたGarbage Collectorですが、Java 21ではGenerational ZGCという機能が追加されました。これはZGCの性能を向上させるために、ZGCのヒープをYoung GenerationとOld Generationに分けることになります。これによって、Young GenerationのGCをより頻繁に行うことができるようになり、Young GenerationのGCの時間を短縮することができ、メモリやCPUのオーバーヘッドを減らすことができるらしいです。&lt;/p>
&lt;p>Generational ZGCを使うには以下のように起動オプションを指定します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>java -XX:+UseZGC -XX:+ZGenerational
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、新しいGCに関しては&lt;a class="link" href="https://openjdk.org/jeps/439" target="_blank" rel="noopener"
>公式のドキュメント&lt;/a>を参照すると色々と設計や実装について述べていますが、アプリケーションエンジニアの立場としてはそれを使った場合の実際の性能上の利点がどれくらいあるのかが気になるところですね。なので、実際にGenerational ZGCを使った場合の性能については&lt;a class="link" href="https://timefold.ai/blog/2023/java-21-performance/" target="_blank" rel="noopener"
>こちらの記事&lt;/a>が参考になるかと思います。結論としてはまだParallelGCがもっとも性能が良いということになっています。もちろんこれはマシンスペック（特にメモリ）によっても変わってくると思うので、自分の環境で試してみるのが良いかと思います。&lt;/p>
&lt;h3 id="record-patterns">Record Patterns
&lt;/h3>&lt;p>Java 16では&lt;a class="link" href="https://openjdk.org/jeps/394" target="_blank" rel="noopener"
>Pattern Matching&lt;/a>という機能が導入され、instanceOfで型チェックをした後にキャストするというコードを簡潔に書くことができるようになりました。例えば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Prior to Java 16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (obj &lt;span style="color:#66d9ef">instanceof&lt;/span> String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String s &lt;span style="color:#f92672">=&lt;/span> (String)obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... use s ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (obj &lt;span style="color:#66d9ef">instanceof&lt;/span> String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... use s ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java 21ではこのPattern Matchingを、同じくJava 16で導入された&lt;a class="link" href="https://openjdk.org/jeps/395" target="_blank" rel="noopener"
>Record&lt;/a>にも適用することができるようになりました。例えば以下のようなコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">Point&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> y) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printSum&lt;/span>(Object obj) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (obj &lt;span style="color:#66d9ef">instanceof&lt;/span> Point p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> p.&lt;span style="color:#a6e22e">x&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> p.&lt;span style="color:#a6e22e">y&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(x&lt;span style="color:#f92672">+&lt;/span>y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printSum&lt;/span>(Object obj) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (obj &lt;span style="color:#66d9ef">instanceof&lt;/span> &lt;span style="color:#a6e22e">Point&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> y)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(x&lt;span style="color:#f92672">+&lt;/span>y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらにネストしたRecordにも適用することができます。例えば以下のようなコードも可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printXCoordOfUpperLeftPointWithPatterns&lt;/span>(Rectangle r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (r &lt;span style="color:#66d9ef">instanceof&lt;/span> &lt;span style="color:#a6e22e">Rectangle&lt;/span>(ColoredPoint(Point(&lt;span style="color:#66d9ef">var&lt;/span> x, &lt;span style="color:#66d9ef">var&lt;/span> y), &lt;span style="color:#66d9ef">var&lt;/span> c),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> lr)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Upper-left corner: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="pattern-matching-for-switch">Pattern Matching for switch
&lt;/h3>&lt;p>Pattern Matchingの改善はswitchにも適用されています。例えば以下のように、switchのcaseにnullを指定することができたり、スマートキャストが使えたり、さらにwhenを使った条件分岐ができるようになりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">testStringEnhanced&lt;/span>(String response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;y&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Y&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;You got it&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;n&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;N&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Shame&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> String s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> when s.&lt;span style="color:#a6e22e">equalsIgnoreCase&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;YES&amp;#34;&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;You got it&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> String s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> when s.&lt;span style="color:#a6e22e">equalsIgnoreCase&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;NO&amp;#34;&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Shame&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> String s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Sorry?&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この改善はEnumにも適用されています。例えば以下のようなコードが可能になりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">exhaustiveSwitchWithBetterEnumSupport&lt;/span>(CardClassification c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Suit.&lt;span style="color:#a6e22e">CLUBS&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s clubs&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Suit.&lt;span style="color:#a6e22e">DIAMONDS&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s diamonds&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Suit.&lt;span style="color:#a6e22e">HEARTS&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s hearts&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Suit.&lt;span style="color:#a6e22e">SPADES&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s spades&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Tarot t &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s a tarot&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだprimitive typeには適用されないのですが、これは今後改善する予定らしいので、また次のバージョンで期待したいところです。&lt;/p>
&lt;h3 id="foreign-fuctions-and-memory-access-api-third-preview">Foreign Fuctions and Memory Access API (Third Preview)
&lt;/h3>&lt;p>Java 19から導入された機能で、Java runtime外のコードやデータにアクセスできるようなAPIが追加されます。これはJava 21ではThird Previewとして提供されていて、JavaからCやC++のコードを呼び出すことができるようになります。例えば以下のようなコードでCのライブラリを呼び出すことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. Find foreign function on the C library path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linker linker &lt;span style="color:#f92672">=&lt;/span> Linker.&lt;span style="color:#a6e22e">nativeLinker&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SymbolLookup stdlib &lt;span style="color:#f92672">=&lt;/span> linker.&lt;span style="color:#a6e22e">defaultLookup&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MethodHandle radixsort &lt;span style="color:#f92672">=&lt;/span> linker.&lt;span style="color:#a6e22e">downcallHandle&lt;/span>(stdlib.&lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;radixsort&amp;#34;&lt;/span>), ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. Allocate on-heap memory to store four strings&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> javaStrings &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#e6db74">&amp;#34;mouse&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cat&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;dog&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;car&amp;#34;&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3. Use try-with-resources to manage the lifetime of off-heap memory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (Arena offHeap &lt;span style="color:#f92672">=&lt;/span> Arena.&lt;span style="color:#a6e22e">ofConfined&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 4. Allocate a region of off-heap memory to store four pointers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemorySegment pointers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> offHeap.&lt;span style="color:#a6e22e">allocateArray&lt;/span>(ValueLayout.&lt;span style="color:#a6e22e">ADDRESS&lt;/span>, javaStrings.&lt;span style="color:#a6e22e">length&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 5. Copy the strings from on-heap to off-heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> javaStrings.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemorySegment cString &lt;span style="color:#f92672">=&lt;/span> offHeap.&lt;span style="color:#a6e22e">allocateUtf8String&lt;/span>(javaStrings&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pointers.&lt;span style="color:#a6e22e">setAtIndex&lt;/span>(ValueLayout.&lt;span style="color:#a6e22e">ADDRESS&lt;/span>, i, cString);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 6. Sort the off-heap data by calling the foreign function&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> radixsort.&lt;span style="color:#a6e22e">invoke&lt;/span>(pointers, javaStrings.&lt;span style="color:#a6e22e">length&lt;/span>, MemorySegment.&lt;span style="color:#a6e22e">NULL&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 7. Copy the (reordered) strings from off-heap to on-heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> javaStrings.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemorySegment cString &lt;span style="color:#f92672">=&lt;/span> pointers.&lt;span style="color:#a6e22e">getAtIndex&lt;/span>(ValueLayout.&lt;span style="color:#a6e22e">ADDRESS&lt;/span>, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> javaStrings&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> cString.&lt;span style="color:#a6e22e">getUtf8String&lt;/span>(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// 8. All off-heap memory is deallocated here&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">assert&lt;/span> Arrays.&lt;span style="color:#a6e22e">equals&lt;/span>(javaStrings,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span> {&lt;span style="color:#e6db74">&amp;#34;car&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cat&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;dog&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;mouse&amp;#34;&lt;/span>}); &lt;span style="color:#75715e">// true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今はJavaを使って他の言語で作られたライブラリやアプリケーションを参照する場合、WrapperやRuntimeを利用した形が多いかなと思いますが、これを使うことでより簡単に他の言語のライブラリを呼び出すことができ、アプリケーションのサイズを減らしたり、パフォーマンスを向上させることができるようになるかなと思います。ただ、まだPreviewなので今後変わる可能性があるのと、直接メモリにアクセスするのでメモリリークの可能性があるかなと思いますので、使用時には注意が必要かと思います。&lt;/p>
&lt;h3 id="unnamed-patterns-and-variables-preview">Unnamed Patterns and Variables (Preview)
&lt;/h3>&lt;p>処理の中で使われてない変数を&lt;code>_&lt;/code>で表現することができるようになりました。なので、以下のようなコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Loop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> acc &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Order _ : orders) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (acc &lt;span style="color:#f92672">&amp;lt;&lt;/span> LIMIT) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... acc&lt;span style="color:#f92672">++&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Multiple assignment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> q &lt;span style="color:#f92672">=&lt;/span> ... &lt;span style="color:#75715e">// x1, y1, z1, x2, y2, z2, ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (q.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> q.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> _ &lt;span style="color:#f92672">=&lt;/span> q.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> _ &lt;span style="color:#f92672">=&lt;/span> q.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... &lt;span style="color:#66d9ef">new&lt;/span> Point(x, 0) ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Catch block&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... i ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">catch&lt;/span> (NumberFormatException _) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Bad number: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// try-with-resources&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> _ &lt;span style="color:#f92672">=&lt;/span> ScopedContext.&lt;span style="color:#a6e22e">acquire&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... no use of acquired resource ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Lambda&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toMap&lt;/span>(String::toUpperCase, _ &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;NODATA&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="virtual-threads">Virtual threads
&lt;/h3>&lt;p>Project Loomという名で長い間開発されていた機能です。個人的な意見ですが、Java 21においてもっとも注目されている機能ではないかと思います。既存のマルチスレッドプログラミングでは生成できるスレッドの数において物理的な制約があったのですが、今回の導入される仮想スレッドはそのOSのスレッドをさらに細かく分けて使うことになるので、より多くのスレッドを同時に扱うことができるのが特徴です。&lt;/p>
&lt;p>使い方としては既存の物理スレッドと大きく変わるわけではないので、以下のようなコードで使うことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> executor &lt;span style="color:#f92672">=&lt;/span> Executors.&lt;span style="color:#a6e22e">newVirtualThreadPerTaskExecutor&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IntStream.&lt;span style="color:#a6e22e">range&lt;/span>(0, 10_000).&lt;span style="color:#a6e22e">forEach&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executor.&lt;span style="color:#a6e22e">submit&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(Duration.&lt;span style="color:#a6e22e">ofSeconds&lt;/span>(1));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// executor.close() is called implicitly, and waits&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>仮想スレッドは実際のOSのスレッドに1:1対応しないので、既存のようにThreadPoolを作成してスレッドの数を制限する必要はほとんどありません。公式でもPoolを使うことをおすすめしないと言っているくらいです。&lt;/p>
&lt;p>実際&lt;a class="link" href="https://kt.academy/article/dispatcher-loom" target="_blank" rel="noopener"
>KotlinでJavaの仮想スレッドを利用するようにDispatcherを実装して実験した記事&lt;/a>によると、30スレッドのマシンでも100万の
仮想スレッドを作成して処理を行うことができるのがわかります。JVM言語で作成されたサーバーサイドアプリケーションの場合、従来のスレッドモデルではスレッドの数を制限する必要があったので、この仮想スレッドの導入によって、より多くのリクエストを同時に処理することができるようになるかなと思います。&lt;/p>
&lt;h3 id="unnamed-classes-and-instance-main-methods-preview">Unnamed Classes and Instance Main Methods (Preview)
&lt;/h3>&lt;p>関数をトップレベルに定義することができるようになりました。なので、伝統のHello Worldのサンプルは以下のようなコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Prior to Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HelloWorld&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, World!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, World!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>トップレベルの関数やフィールドもUnnamed Classのメンバー扱いとなるので、以下のようなコードも問題なく動きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Method&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#a6e22e">greeting&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, World!&amp;#34;&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(greeting());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Field&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String greeting &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, World!&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(greeting);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、main関数を持つUnnamed Classは以下のように実行することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">new&lt;/span> Object() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// the unnamed class&amp;#39;s body&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}.&lt;span style="color:#a6e22e">main&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="scoped-values-preview">Scoped Values (Preview)
&lt;/h3>&lt;p>Webアプリケーションの場合、一つのリクエストに対してはスレッドが割り当てられ、一貫したコンテキストの中で実行されるようにするのが一般的です。ただ、そこでコンテキストをオブジェクトとして扱う場合、既存だと実行される関数の引数として渡す必要があります。例えば以下のようなコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">handle&lt;/span>(Request request, Response response, FrameworkContext context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> userInfo &lt;span style="color:#f92672">=&lt;/span> readUserInfo(context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> UserInfo &lt;span style="color:#a6e22e">readUserInfo&lt;/span>(FrameworkContext context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (UserInfo)framework.&lt;span style="color:#a6e22e">readKey&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;userInfo&amp;#34;&lt;/span>, context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/ThreadLocal.html" target="_blank" rel="noopener"
>ThreadLocal&lt;/a>を使用して以下のように書くこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Framework&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Application application;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Framework&lt;/span>(Application app) { &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">application&lt;/span> &lt;span style="color:#f92672">=&lt;/span> app; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>FrameworkContext&lt;span style="color:#f92672">&amp;gt;&lt;/span> CONTEXT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">serve&lt;/span>(Request request, Response response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> context &lt;span style="color:#f92672">=&lt;/span> createContext(request);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CONTEXT.&lt;span style="color:#a6e22e">set&lt;/span>(context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Application.&lt;span style="color:#a6e22e">handle&lt;/span>(request, response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> PersistedObject &lt;span style="color:#a6e22e">readKey&lt;/span>(String key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> context &lt;span style="color:#f92672">=&lt;/span> CONTEXT.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> db &lt;span style="color:#f92672">=&lt;/span> getDBConnection(context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#a6e22e">readKey&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、ThreadLocalを使う場合は色々と問題があります。まずThreadLocalの値そのものが変更されるということです。そして不要になったThreadLocalの値を適宜削除する必要があったり、オーバーヘッドが発生するということです。&lt;/p>
&lt;p>そこでJava 21では&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/lang/ScopedValue.html" target="_blank" rel="noopener"
>ScopedValue&lt;/a>というクラスが追加されました。これを使うと以下のようにスレッドあたりの値を設定することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Framework&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ScopedValue&lt;span style="color:#f92672">&amp;lt;&lt;/span>FrameworkContext&lt;span style="color:#f92672">&amp;gt;&lt;/span> CONTEXT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> ScopedValue.&lt;span style="color:#a6e22e">newInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">serve&lt;/span>(Request request, Response response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> context &lt;span style="color:#f92672">=&lt;/span> createContext(request);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScopedValue.&lt;span style="color:#a6e22e">where&lt;/span>(CONTEXT, context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">run&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Application.&lt;span style="color:#a6e22e">handle&lt;/span>(request, response));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> PersistedObject &lt;span style="color:#a6e22e">readKey&lt;/span>(String key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> context &lt;span style="color:#f92672">=&lt;/span> CONTEXT.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> db &lt;span style="color:#f92672">=&lt;/span> getDBConnection(context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#a6e22e">readKey&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ScopedVlaueにはsetterがないですが、だからと言って他の値を与えられないわけではないです。ThreadLocalとは別のアプローチで、特定の値を渡してrun()関数を実行することができるようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> ScopedValue&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> X &lt;span style="color:#f92672">=&lt;/span> ScopedValue.&lt;span style="color:#a6e22e">newInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScopedValue.&lt;span style="color:#a6e22e">where&lt;/span>(X, &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">run&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> bar());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">bar&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(X.&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// prints hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScopedValue.&lt;span style="color:#a6e22e">where&lt;/span>(X, &lt;span style="color:#e6db74">&amp;#34;goodbye&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">run&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> baz());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(X.&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// prints hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">baz&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(X.&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// prints goodbye&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このScopedValueはスレッドの実行中にだけ値が保持されないので、ThreadLocalより安全な使い方ができるようになっています。&lt;/p>
&lt;h3 id="vector-api-sixth-incubator">Vector API (Sixth Incubator)
&lt;/h3>&lt;p>Java 1.0の時代の配列を扱う&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Vector.html" target="_blank" rel="noopener"
>Vector&lt;/a>とは違って、数値（行列）の計算のためのVector APIが追加されました。基本的に以下のようなことができるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Prior to Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">scalarComputation&lt;/span>(&lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a, &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b, &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> a.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">*&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">*&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1.&lt;span style="color:#a6e22e">0f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> VectorSpecies&lt;span style="color:#f92672">&amp;lt;&lt;/span>Float&lt;span style="color:#f92672">&amp;gt;&lt;/span> SPECIES &lt;span style="color:#f92672">=&lt;/span> FloatVector.&lt;span style="color:#a6e22e">SPECIES_PREFERRED&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">vectorComputation&lt;/span>(&lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a, &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b, &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> upperBound &lt;span style="color:#f92672">=&lt;/span> SPECIES.&lt;span style="color:#a6e22e">loopBound&lt;/span>(a.&lt;span style="color:#a6e22e">length&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> upperBound; i &lt;span style="color:#f92672">+=&lt;/span> SPECIES.&lt;span style="color:#a6e22e">length&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// FloatVector va, vb, vc;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> va &lt;span style="color:#f92672">=&lt;/span> FloatVector.&lt;span style="color:#a6e22e">fromArray&lt;/span>(SPECIES, a, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> vb &lt;span style="color:#f92672">=&lt;/span> FloatVector.&lt;span style="color:#a6e22e">fromArray&lt;/span>(SPECIES, b, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> vc &lt;span style="color:#f92672">=&lt;/span> va.&lt;span style="color:#a6e22e">mul&lt;/span>(va)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">add&lt;/span>(vb.&lt;span style="color:#a6e22e">mul&lt;/span>(vb))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">neg&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vc.&lt;span style="color:#a6e22e">intoArray&lt;/span>(c, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> a.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">*&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">*&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1.&lt;span style="color:#a6e22e">0f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一般的なWebアプリケーションではあまり使われることはないかと思いますが、もしこのような計算が必要とされる処理を書く場合、従来のコードよりも高速で並列かもできるということなので、使う場面があるかもしれません。&lt;/p>
&lt;h3 id="deprecate-the-windows-32-bit-x86-port-for-removal">Deprecate the Windows 32-bit x86 Port for Removal
&lt;/h3>&lt;p>Windows x86-32のポートがいずれ終わるので、まずはDeprecatedにしてするということです。Virtual Threadが該当のOSだと期待通りの性能向上がなく、32bitに対応する最後のWindowsであるWindows 10が2025年10月にサポート終了となるための対応とされています。&lt;/p>
&lt;h3 id="prepare-to-disallow-the-dynamic-loading-of-agents">Prepare to Disallow the Dynamic Loading of Agents
&lt;/h3>&lt;p>Java agentによる動的ロードは、実行中のアプリケーションを変更することも可能です。しかしこのよう機能はアプリケーションの整合性を保証できなくする可能性もあります。そのような問題を防ぐために、将来は動的ロードを禁止し、Java 21ではまず警告を出力します。以下のようなメッセージが出力されることがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>WARNING: A {Java,JVM TI} agent has been loaded dynamically (file:/u/bob/agent.jar)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARNING: Dynamic loading of agents will be disallowed by default in a future release
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような警告を回避するためにはアプリケーションの実行時に&lt;code>-XX:+EnableDynamicAgentLoading&lt;/code>というオプションを指定する必要があります。&lt;/p>
&lt;p>&lt;a class="link" href="https://www.datadoghq.com/" target="_blank" rel="noopener"
>Datadog&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/cd/F25597_01/document/products/wls/docs90/jmxinst/understanding.html" target="_blank" rel="noopener"
>JMX&lt;/a>などアプリケーションをモニタリングするためのツールがこのような機能に依存している場合があるので、今後のバージョンを使う際には何か実装の方法が変わるかもしれませんね。&lt;/p>
&lt;h3 id="key-encapsulation-mechanism-api">Key Encapsulation Mechanism API
&lt;/h3>&lt;p>最新の暗号化のアルゴリズムに対応するものです。量子コンピュータでは既存の暗号化アルゴリズムが通用しなくなるという話もあるので、その対応として導入されたものかと思われます（公式でも、&lt;code> Post-Quantum Cryptography standardization process&lt;/code>と述べています）。&lt;/p>
&lt;p>新しいアルゴリズムを用いた公開鍵・秘密鍵のペアの生成、カプセル化、カプセルの解除などの機能に対応しています。以下のような使い方となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Receiver side&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KeyPairGenerator g &lt;span style="color:#f92672">=&lt;/span> KeyPairGenerator.&lt;span style="color:#a6e22e">getInstance&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ABC&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KeyPair kp &lt;span style="color:#f92672">=&lt;/span> g.&lt;span style="color:#a6e22e">generateKeyPair&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>publishKey(kp.&lt;span style="color:#a6e22e">getPublic&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Sender side&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM kemS &lt;span style="color:#f92672">=&lt;/span> KEM.&lt;span style="color:#a6e22e">getInstance&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ABC-KEM&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PublicKey pkR &lt;span style="color:#f92672">=&lt;/span> retrieveKey();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ABCKEMParameterSpec specS &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ABCKEMParameterSpec(...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM.&lt;span style="color:#a6e22e">Encapsulator&lt;/span> e &lt;span style="color:#f92672">=&lt;/span> kemS.&lt;span style="color:#a6e22e">newEncapsulator&lt;/span>(pkR, specS, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM.&lt;span style="color:#a6e22e">Encapsulated&lt;/span> enc &lt;span style="color:#f92672">=&lt;/span> e.&lt;span style="color:#a6e22e">encapsulate&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SecretKey secS &lt;span style="color:#f92672">=&lt;/span> enc.&lt;span style="color:#a6e22e">key&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendBytes(enc.&lt;span style="color:#a6e22e">encapsulation&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendBytes(enc.&lt;span style="color:#a6e22e">params&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Receiver side&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> em &lt;span style="color:#f92672">=&lt;/span> receiveBytes();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> params &lt;span style="color:#f92672">=&lt;/span> receiveBytes();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM kemR &lt;span style="color:#f92672">=&lt;/span> KEM.&lt;span style="color:#a6e22e">getInstance&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ABC-KEM&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AlgorithmParameters algParams &lt;span style="color:#f92672">=&lt;/span> AlgorithmParameters.&lt;span style="color:#a6e22e">getInstance&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ABC-KEM&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>algParams.&lt;span style="color:#a6e22e">init&lt;/span>(params);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ABCKEMParameterSpec specR &lt;span style="color:#f92672">=&lt;/span> algParams.&lt;span style="color:#a6e22e">getParameterSpec&lt;/span>(ABCKEMParameterSpec.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM.&lt;span style="color:#a6e22e">Decapsulator&lt;/span> d &lt;span style="color:#f92672">=&lt;/span> kemR.&lt;span style="color:#a6e22e">newDecapsulator&lt;/span>(kp.&lt;span style="color:#a6e22e">getPrivate&lt;/span>(), specR);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SecretKey secR &lt;span style="color:#f92672">=&lt;/span> d.&lt;span style="color:#a6e22e">decapsulate&lt;/span>(em);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="structured-concurrency-preview">Structured Concurrency (Preview)
&lt;/h3>&lt;p>並列処理をより簡単にするためのAPIです。複数のスレッドで実行される作業の単位を一つのタスクとして扱うことができます。&lt;/p>
&lt;p>例えば以下のようなコードがあったとします。userとorderのデータをそれぞれ違うスレッドで取得して、その結果を返す関数です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Response &lt;span style="color:#a6e22e">handle&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ExecutionException, InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Future&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> esvc.&lt;span style="color:#a6e22e">submit&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> findUser());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Future&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> order &lt;span style="color:#f92672">=&lt;/span> esvc.&lt;span style="color:#a6e22e">submit&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> fetchOrder());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String theUser &lt;span style="color:#f92672">=&lt;/span> user.&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Join findUser&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> theOrder &lt;span style="color:#f92672">=&lt;/span> order.&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Join fetchOrder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Response(theUser, theOrder);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードだと、以下のような問題が考えられます。&lt;/p>
&lt;ul>
&lt;li>findUser()で例外が発生してもfetchOrder()は実行されてリソースの無駄になる&lt;/li>
&lt;li>handle()を実行しているスレッドがインタラプトされた場合、findUser()とfetchOrder()は実行されたままになる&lt;/li>
&lt;li>findUser()の実行が長すぎる場合、fetchOrder()が失敗してもそれを待つことになる（結果的に失敗）&lt;/li>
&lt;/ul>
&lt;p>これらの問題が挙げられてということは、新しいAPIではそれを解決できるということですね。新しいAPIでは上記の問題を、以下のようなコードで解決します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Response &lt;span style="color:#a6e22e">handle&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ExecutionException, InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> scope &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StructuredTaskScope.&lt;span style="color:#a6e22e">ShutdownOnFailure&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> scope.&lt;span style="color:#a6e22e">fork&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> findUser());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> order &lt;span style="color:#f92672">=&lt;/span> scope.&lt;span style="color:#a6e22e">fork&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> fetchOrder());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scope.&lt;span style="color:#a6e22e">join&lt;/span>() &lt;span style="color:#75715e">// Join both subtasks&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">throwIfFailed&lt;/span>(); &lt;span style="color:#75715e">// ... and propagate errors&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Here, both subtasks have succeeded, so compose their results&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Response(user.&lt;span style="color:#a6e22e">get&lt;/span>(), order.&lt;span style="color:#a6e22e">get&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html" target="_blank" rel="noopener"
>StructuredTaskScope&lt;/a>を利用して処理を行う場合、以下のメリットがあります。&lt;/p>
&lt;ul>
&lt;li>findUser()やfecthOrder()のどちらかが失敗したら、残りの処理はキャンセルされる&lt;/li>
&lt;li>handle()を実行しているスレッドがインタラプトされた場合、findUser()とfetchOrder()はキャンセルされる&lt;/li>
&lt;li>処理が明確に理解できる&lt;/li>
&lt;/ul>
&lt;h2 id="api">API
&lt;/h2>&lt;p>今回の新しいAPIに関しては、言語スペックでよく説明されており、新しいJavadocの方でそれぞれのバージョン別にどんなものが追加されたかフィルタしながら確認ができるので、ここでは&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/new-list.html" target="_blank" rel="noopener"
>Javadocのリンク&lt;/a>だけを貼っておきます。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがだったでしょうか。私はもうJavaでアプリを書くことはほとんどなく、主にKotlinを書いていて、新しいAPIもそこまでコードに影響を与えることはないのですが、それでもJavaの新しいバージョンがリリースされると、なんだか嬉しくなりますね。特にVirtual ThreadのようなAPIはKotlinでも使えるし、Javaで作成されたTomcatやNettyのようなミドルウェアの性能もこれを活用することでさらに性能が上がると思うとありがたいです。他にも追加されるAPIはKotlinとはまた違うアプローチをしているので大変勉強になるなと思いました。&lt;/p>
&lt;p>今は仕事でJava 17を使っているのですが、Java 21になったらすぐにでも使いたいと思います。特に来年はKotlinも2.0がリリースされるので、Javaの新機能を活かしてKotlinのビルドもパフォーマンスもさらに向上させていきたいなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その四〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-4/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-4/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinで書いてみた〜その四〜" />&lt;p>しばらくKotlinで書いてみたシリーズを書いていなかったので、今回はその四です。&lt;/p>
&lt;h2 id="listをlistでソート">ListをListでソート
&lt;/h2>&lt;p>データ構造として、ListをListでソートしたい場合がありますね。例えばとあるテーブルに対して、別のテーブルのIDを持たせている場合などです。このテーブルのIDを配列にして、並び順を表現しているとしたら、この配列を元にソートしたいことになります。&lt;/p>
&lt;p>もちろんクエリでソートすることもできますが、クエリでソートすると、ソートした結果をキャッシュできないというデメリットがあります。そこで、ListをListでソートする方法を考えてみました。&lt;/p>
&lt;p>まずは以下のようなデータがあるとします。イメージとしては、複数の画像を持つImageBoxというデータがあり、そのImageBoxのimageOrderにはImageのIDが配列として入っているとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ImageBox&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> title: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> imageOrder: List&amp;lt;Int&amp;gt; &lt;span style="color:#75715e">// imageのIDの配列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Image&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> url: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでDBとしてはImageBoxテーブルとImageテーブルがあり、ImageBoxテーブルのimageOrderにはImageテーブルのIDが配列として入っているとします。そしてアプリではImageBoxのimageOrderの順番にImageを表示したいとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> imageBox = ImageBox(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title = &lt;span style="color:#e6db74">&amp;#34;title&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageOrder = listOf(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> images = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">1&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url1&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">2&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url2&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">3&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url3&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">4&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url4&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">5&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url5&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、以下のようにソートすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// imageBoxのimageOrderのをIndexをkeyとするMapに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> indexMap = imageBox.imageOrder.mapIndexed { index, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span> to index }.toMap()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// imagesをimageOrderを元にソート
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> sortedImages = images.sortedBy { indexMap[&lt;span style="color:#66d9ef">it&lt;/span>.id] }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原理は簡単で、imageOrderの配列をIndexとvalueのMapに変換して、その値を元にソートしているだけです。この方法であれば、クエリでソートすることなく、imageOrderの順番にソートすることができます。&lt;/p>
&lt;p>また、こういったソートは以下のように拡張関数として定義すると、他の場所でも使い回すことができます。anotherには並び順を表現する配列を渡して、keySelectorにはソートしたい配列の要素から並び順の基準となる値を取り出す関数を渡します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">U&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.sortedBy(another: List&amp;lt;U&amp;gt;, keySelector: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> U): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> indexMap = another.mapIndexed { index, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span> to index }.toMap()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.sortedBy { indexMap[keySelector(&lt;span style="color:#66d9ef">it&lt;/span>)] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> sortedImages = images.sortedBy(imageBox.imageOrder) { &lt;span style="color:#66d9ef">it&lt;/span>.id }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>keySelectorでitすら省略したい場合は、以下のような方法もあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">U&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.sortedBy(another: List&amp;lt;U&amp;gt;, keySelector: &lt;span style="color:#a6e22e">T&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> U): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> indexMap = another.mapIndexed { index, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span> to index }.toMap()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.sortedBy { indexMap[keySelector(&lt;span style="color:#66d9ef">it&lt;/span>)] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> sortedImages = images.sortedBy(imageBox.imageOrder) { id }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="listのページング">Listのページング
&lt;/h2>&lt;p>ページングはよくDBのクエリで行いますが、クエリでなくコードのみで処理したい場合もありますね。例えば、外部APIに対してリクエストを送る場合などです。この場合、ページングをどう実装するかが課題になります。&lt;/p>
&lt;p>この場合は以下のように拡張関数を定義することで、Listのページングを実装することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.paginated(offset: Int, limit: Int): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ページングが必要ない場合はそのまま返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (offest &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> limit &amp;lt; size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ページングが必要な場合はoffsetとlimitを元にsubListを取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> fromIndex = (offset - &lt;span style="color:#ae81ff">1&lt;/span>) * limit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">&amp;lt;=&lt;/span> fromIndex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ページングの範囲外の場合は空のリストを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ページングの範囲内の場合はsubListを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> toIndex = size.coerceAtMost(fromIndex + limit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> subList(fromIndex, toIndex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>細かいものとしては&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-at-most.html" target="_blank" rel="noopener"
>coerceAtMost()&lt;/a>を使って、sizeより大きい値を渡された場合はsizeを返すようにしています。これはもちろんIndexOutOfBoundsExceptionを防ぐためです。&lt;/p>
&lt;h2 id="exposed">Exposed
&lt;/h2>&lt;p>厳密にいって&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>はORMなのですが、Kotlinの書き方によってさらに便利になる部分もあるので今回はこちらも紹介したいと思います。&lt;/p>
&lt;h3 id="insertとupdateの共通化">InsertとUpdateの共通化
&lt;/h3>&lt;p>ExposedでInsertやUpdateを書くのはかなり直感的なのですが、多くの場合にInsertとUpdateで同じ処理を書くことになります。そこで、InsertとUpdateの共通化を考えてみました。例えば以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">insert&lt;/span>(image: Image): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.insert {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[id] = image.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[url] = image.url
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[title] = image.title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[description] = image.description
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(image: Image): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.update({ &lt;span style="color:#a6e22e">ImageTable&lt;/span>.id eq image.id }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[url] = image.url
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[title] = image.title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[description] = image.description
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、InsertとUpdateではID以外だとurlやtitleのような値をセットするという面では同じ処理を書いているだけですね。テーブルが増えれば増えるほど、このようなコードも増えていきます。幸いExposedではUpdate時の&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/main/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/statements/UpdateBuilder.kt" target="_blank" rel="noopener"
>UpdateBuilder&lt;/a>をInsert時の&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/main/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/statements/InsertStatement.kt" target="_blank" rel="noopener"
>InsertStatement&lt;/a>が継承している形の実装となっているので、以下のように共通化することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">UpdateBuilder&lt;/span>&amp;lt;Int&amp;gt;.setParametersFrom(image: Image) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[url] = image.url
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[title] = image.title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[description] = image.description
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような関数を定義すると、InsertとUpdateの処理は以下のように書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">insert&lt;/span>(image: Image): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.insert {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[id] = image.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.setParametersFrom(image)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(image: Image): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.update({ &lt;span style="color:#a6e22e">ImageTable&lt;/span>.id eq image.id }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.setParametersFrom(image)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはbatchInsertの場合でも同じです。&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/main/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/statements/BatchInsertStatement.kt" target="_blank" rel="noopener"
>BatchInsertStatement&lt;/a>もまたInsertStatementを継承しているので、以下のように共通化することができます。これでだいぶすっきりしたコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">batchInsert&lt;/span>(images: List&amp;lt;Image&amp;gt;): List&amp;lt;Image&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.batchInsert(images) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[id] = &lt;span style="color:#66d9ef">it&lt;/span>.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.setParametersFrom(&lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> images
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="batchupsertの実装">BatchUpsertの実装
&lt;/h3>&lt;p>ExposedにbatchInsertはありますが、batchUpsertはありません。ただ、クエリの書き方とアプリ側の実装によってbatchUpsertを実現することはできます。もちろん&lt;a class="link" href="https://github.com/PerfectDreams/ExposedPowerUtils" target="_blank" rel="noopener"
>ExposedPowerUtils&lt;/a>のようなライブラリもあるので、それを導入するのも良いでしょう。&lt;/p>
&lt;p>ただ、あのライブラリを使う場合は少し問題がありました。まずこのライブラリの実装では特定のカラムを指定して、それを基準にデータがすでに存在する場合はUpdate、存在しない場合はInsertという処理を行っています。最終的に作られるコードは、Insertをまず実行して、指定したカラムが重複している場合は&lt;code>ON CONFLICT&lt;/code>でUpdateを実行するというものです。&lt;/p>
&lt;p>ここでテーブルのIDはアプリ側で生成するUUIDであり、ON CONFLICTの基準となるカラムがFKの場合にはIDまでUPDATEされるという問題がありました。なので、先ほどのライブラリの実装を元に、PKを除いてUpdateするように実装を変更しました。それが以下です。（あと一部使ってない引数は省略してます）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span> : &lt;span style="color:#a6e22e">Table&lt;/span>, &lt;span style="color:#a6e22e">E&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">T&lt;/span>.batchUpsert(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">data&lt;/span>: Collection&amp;lt;E&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">vararg&lt;/span> keys: Column&amp;lt;*&amp;gt; = (primaryKey &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;primary key is missing&amp;#34;&lt;/span>)).columns,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body: &lt;span style="color:#a6e22e">T&lt;/span>.(BatchInsertStatement, E) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): BatchInsertOrUpdate {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> BatchInsertOrUpdate(table = &lt;span style="color:#66d9ef">this&lt;/span>, keys = keys).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">data&lt;/span>.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addBatch()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> execute(&lt;span style="color:#a6e22e">TransactionManager&lt;/span>.current())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BatchInsertOrUpdate&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> table: Table,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">vararg&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> keys: Column&amp;lt;*&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : BatchInsertStatement(table, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">prepareSQL&lt;/span>(transaction: Transaction): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> transactionManager = &lt;span style="color:#a6e22e">TransactionManager&lt;/span>.current()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> primaryKey = table.primaryKey&lt;span style="color:#f92672">?.&lt;/span>columns&lt;span style="color:#f92672">?.&lt;/span>toSet() &lt;span style="color:#75715e">// ここでprimaryKeyを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> updateSetter = ((table.columns - keys.toSet())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .let { columns &lt;span style="color:#f92672">-&amp;gt;&lt;/span> primaryKey&lt;span style="color:#f92672">?.&lt;/span>let { columns - primaryKey } &lt;span style="color:#f92672">?:&lt;/span> columns }) &lt;span style="color:#75715e">// ここでprimaryKeyを除外
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .joinToString { &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${transactionManager.identity(it)}&lt;/span>&lt;span style="color:#e6db74"> = EXCLUDED.&lt;/span>&lt;span style="color:#e6db74">${transactionManager.identity(it)}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> onConflict =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ON CONFLICT (&lt;/span>&lt;span style="color:#e6db74">${keys.joinToString { transactionManager.identity(it) }&lt;/span>&lt;span style="color:#e6db74">}) DO UPDATE SET &lt;/span>&lt;span style="color:#e6db74">$updateSetter&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${super.prepareSQL(transaction)}&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#e6db74">$onConflict&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="トランザクションを分ける">トランザクションを分ける
&lt;/h3>&lt;p>この度はリードレプリカを導入することになり、GET系のAPIにはとりあえずリードレプリカを使うことになりました。ただ、リードレプリカは更新系のクエリを受け付けないので、更新系のクエリはプライマリに送る必要があります。&lt;/p>
&lt;p>そして、APIの実装としては例外を投げる前に明示的にロールバックを行うため別途の関数を定義していて、これと同じような使い方としてリードレプリカに接続するものを作りたいと思いました。まず、既存で使っていた関数は以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">transactionWrapper&lt;/span>(statement: &lt;span style="color:#a6e22e">Transaction&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> statement()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (ex: Exception) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">TransactionManager&lt;/span>.current().rollback()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Exposedでは&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/7c8d8a20e2efef5d0282ca6b703a433ecbf4a607/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/transactions/ThreadLocalTransactionManager.kt#L156" target="_blank" rel="noopener"
>transaction&lt;/a>の引数に&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/7c8d8a20e2efef5d0282ca6b703a433ecbf4a607/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/Database.kt" target="_blank" rel="noopener"
>Database&lt;/a>を渡すことで、簡単にどのDBに接続するかを指定することができます。なので、これを使ってリードレプリカに接続する関数を以下のように定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">readReplicaTransactionWrapper&lt;/span>(statement: &lt;span style="color:#a6e22e">Transaction&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> readReplicaDatabase: Database = getKoinModule(named(&lt;span style="color:#e6db74">&amp;#34;readReplicaDatabase&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> transaction(readReplicaDatabase) { statement() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでの&lt;code>Database&lt;/code>を&lt;a class="link" href="https://github.com/InsertKoinIO/koin" target="_blank" rel="noopener"
>Koin&lt;/a>を使用してinjectしているので、追加で以下のような設定を加えてます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// デフォルトのDBはプライマリに固定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> defaultDatabase: Database = getKoinModule(named(&lt;span style="color:#e6db74">&amp;#34;primaryDatabase&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">TransactionManager&lt;/span>.defaultDatabase = defaultDatabase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Top level functionでKoinのinjectを使うための設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">getKoinModule&lt;/span>(qualifier: Qualifier? = &lt;span style="color:#66d9ef">null&lt;/span>): T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">KoinComponent&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> value: T &lt;span style="color:#66d9ef">by&lt;/span> inject(qualifier)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.&lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでtransactionを使うたびに関数名だけを変えるだけで、プライマリとリードレプリカに接続することができます。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたでしょうか。今回もKotlinの小技的なものを紹介してみました。最近はあまり複雑なロジックを書いてない上、プライベートでの開発もあまりしてないので、なかなかブログのネタが思いつかないですね。たまにこちらのブログの記事を参考にしていただいている方がいるようなので、もう少し頻繁に更新できるように頑張ります。&lt;/p>
&lt;p>しばらくブログを更新してませんでしたが、今回はCompose Multiplatformも1.5.0になり、Java 21のリリースもまもなくなので、近いうちにまたそれらについての記事も更新していきたいと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinConf'23を要約してみた</title><link>https://retheviper.github.io/posts/kotlin-conf-2023/</link><pubDate>Fri, 14 Apr 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-conf-2023/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post KotlinConf'23を要約してみた" />&lt;p>今年も&lt;a class="link" href="https://kotlinconf.com/" target="_blank" rel="noopener"
>KotlinConf&lt;/a>が開催されました。毎年興味を持って参加やキーノートを視聴しているわけでもありませんが、最近はK2 CompilerにやKMMなどJetbrainsのプロダクトがかなり盛んな感じなので視聴することにしました。そこで思ったより興味深い発表が多かったので、今回はその内容について簡単にまとめてみようかなと思います。&lt;/p>
&lt;p>では、セッション別にどんな話があったのかを紹介していきます。&lt;/p>
&lt;h2 id="k2-compiler">K2 Compiler
&lt;/h2>&lt;p>まずはKotlin 2.0で採用予定の&lt;a class="link" href="https://blog.jetbrains.com/kotlin/2021/10/the-road-to-the-k2-compiler/" target="_blank" rel="noopener"
>K2 Compiler&lt;/a>の話です。2021年から発表されていて、コンパイラの性能向上のみでなくプラグイン対応などの機能も提供する予定となっていますね。今現在開発が進んでいて、Kotlin 1.8がリリースされた今もかなり多い部分が完成されている状態です。&lt;/p>
&lt;p>ここではKotlin 1.8と、2.0になった場合のコンパイラのパフォーマンスの違いをまずグラフとして提示していました。当たり前ながら、2.0でかなり速度が上がったように見えます。同じ環境で20秒かかるものが、10秒に短縮されたということですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison_hu_6f4a4c460afe1bac.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison_hu_850214035683a462.webp 1024w"
loading="lazy"
alt="コンパイル時間の比較"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Andoridの公式言語としてKotlinが採用され、JavaからKotlinに移行した開発者の間でやはりビルドが遅くなったという話を聞いた覚えがあるのでこれはかなり嬉しい結果となっていますね。またコンパイラのパフォーマンスが上がるとintellijでのコンパイルも早くなるわけなのでより快適な開発環境になると思います。&lt;/p>
&lt;p>また、今年の後半にはKotlin 1.9のリリースが予定されていて、その次に1.10のようなバージョンは予定にないとのことでした。つまり、1.9の後はすぐに2.0となるとのことですね。そして2.0は1.9の後方互換性を保つので、1.9でコンパイルができるのであれば2.0でもコンパイルができるとのことです。&lt;/p>
&lt;p>もちろん言語のバージョンアップを急ぐ企業さんはそこまではないと思いますし、コンパイラ自体が変わることでどんな問題が起こるかわからないので、実際の採用まではかなり時間がかるでしょう。ただ個人的にはサイドプロジェクトで色々試してみたいので、来年からはK2 Compilerに触れられるということが楽しみです。&lt;/p>
&lt;h2 id="要望の多い機能">要望の多い機能
&lt;/h2>&lt;p>&lt;a class="link" href="https://www.jetbrains.com/youtrack/" target="_blank" rel="noopener"
>Youtrack&lt;/a>というサイトからJetbrainsのプロダクトに関して議論できるのですが、ここで要望の多い機能に対して今後どのような形で対応していくかを説明するセッションです。ここは一つ一つ、どのような要望があるかを見ていきます。&lt;/p>
&lt;h3 id="static-extensions">Static Extensions
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-11968/Research-and-prototype-namespace-based-solution-for-statics-and-static-extensions" target="_blank" rel="noopener"
>KT-11968&lt;/a>に上がっているもので、JavaクラスにもCompanion objectのように、staticなメソッドやプロパティを追加できるようにしてほしいということです。&lt;/p>
&lt;p>例えば、今までは以下のようにJavaのクラスにCompanion objectを定義してインスタンスの生成なしで使うことはできませんでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">File&lt;/span>.&lt;span style="color:#66d9ef">open&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;data.txt&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>.&lt;span style="color:#a6e22e">Companion&lt;/span>.&lt;span style="color:#66d9ef">open&lt;/span>(name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、&lt;code>static&lt;/code>というキーワードを使って以下のように書けるようになるとのことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>.static.&lt;span style="color:#66d9ef">open&lt;/span>(name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的にはMySQLとJVMの日付のMAX_VALUEの閾値が違ってバグが起きたことがあって、LocalDateに別途プロパティを追加したかったのにJavaのクラスにはstaticなプロパティの追加ができなくて諦めた経験があるのでこれはとても嬉しい変化です。&lt;/p>
&lt;h3 id="collection-literals">Collection Literals
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-43871/Collection-literals" target="_blank" rel="noopener"
>KT-43871&lt;/a>に上がっているもので、その名の通りコレクションのリテラルを作成できるようにしてほしいということです。&lt;/p>
&lt;p>例えば、今までは言語レベルでコレクションのリテラルに対応していなかったので、以下のような書き方が多かったかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>cmdArgs = listOf(&lt;span style="color:#e6db74">&amp;#34;-language-version&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;2.0&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>それが、以下のようにコレクションのリテラルを書けるようになるとのことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> skip: PersistentSet&amp;lt;Int&amp;gt; = [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> skip2 = PersistentSet [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的には&lt;code>const&lt;/code>キーワードの適用範囲をもっと広げてほしいと思っているところですが、これもまた悪くない変化ですね。特にアノテーションなどで使われる配列は実際リテラルになるケースが多いと思いますので、そこでまた色々と活用できる余地ができるかもしれません。&lt;/p>
&lt;h3 id="name-based-destructing">Name-Based Destructing
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-19627" target="_blank" rel="noopener"
>KT-19627&lt;/a>に上がっているもので、分解宣言時に変数名とフィールド名が一致するようにしてほしいということです。&lt;/p>
&lt;p>例えば以下のように分解宣言をしたとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> firstName: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastName: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>firstName, lastName) = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Doe&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードの場合、&lt;code>firstName&lt;/code>は&lt;code>John&lt;/code>, &lt;code>lastName&lt;/code>は&lt;code>Doe&lt;/code>となります。data classの実際のフィールド名とも一致しているので、なんの問題もありません。ただ、もし間違って以下のようにしたらどうでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>lastName, firstName) = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Doe&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、意図とは違って&lt;code>firstName&lt;/code>は&lt;code>Doe&lt;/code>, &lt;code>lastName&lt;/code>は&lt;code>John&lt;/code>となってしまいます。このようなミスを回避するために&lt;a class="link" href="https://kotlinlang.org/docs/inline-classes.html" target="_blank" rel="noopener"
>inline class&lt;/a>などを導入してフィールドごとに型を定義したり、分解宣言そのものを使わないようにするなどの対応をしていることも少なくはないかと思いますが、今後はこのようなミスを回避するために、分解宣言時に変数名とフィールド名が一致するかどうかコンパイラが判断して値の代入を行うことになるとのことです。&lt;/p>
&lt;p>個人的にはかなりすごいと思いますが、心配も多いですね。単純に変数名とフィールドが一致する時のみ動作してくれるのかどうかわからないので、実際の動作を見ておきたいものです。&lt;/p>
&lt;h3 id="context-recivers">Context Recivers
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-10468/Context-receivers-multiple-receivers-on-extension-functions-properties" target="_blank" rel="noopener"
>KT-10468&lt;/a>に上がっているもので、関数にコンテキストが必要な場合はパラメータとしてではなく、別途のキーワードを使ってコンテキストを渡すことができるようにしてほしいということです。&lt;/p>
&lt;p>例えば、以下のような関数があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">processRequest&lt;/span>(context: ServiceContext, request: ServiceRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = request.loadData(context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数ではコンテキストを引数としてもらい、さらにそのコンテキストを違う関数の方に渡しています。当然、呼ばれる関数の方も引数にコンテキストが必要になります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ServiceRequest&lt;/span>.loadData(context: ServiceContext): Data { &lt;span style="color:#75715e">/** ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、関数の中で呼ばれる他の関数が多くなればなるほど、その関数にもコンテキストを渡す必要が出てきます。そこで、以下のように別途のキーワードを使って、引数の追加なしでコンテキストを渡すことができるようになるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>context(ServiceContext)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">processRequest&lt;/span>(request: ServiceRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = request.loadData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>context(ServiceContext)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ServiceRequest&lt;/span>.loadData(): Data { &lt;span style="color:#75715e">/** ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>context&lt;/code>のキーワードに渡せるコンテキストの基準が何か、そしてどのように関数の中でコンテキストを呼び出せるかどうかはまだわかりませんが、より綺麗な感覚になっているかなと思います。&lt;/p>
&lt;h3 id="explicit-fields">Explicit Fields
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-14663/Support-having-a-public-and-a-private-type-for-the-same-property" target="_blank" rel="noopener"
>KT-14663&lt;/a>に上がっているもので、privateなプロパティに対してpublicなプロパティを定義しなくても良いようにしてほしいということです。&lt;/p>
&lt;p>例えば、privateのプロパティに対して、外部から参照する場合は以下のように書くケースがあるかなと思います。privateなプロパティを維持しつつ、外部で参照のみできる別のプロパティがその値を提供するということですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _applicationState = MutableStateFlow(State())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> applicationState: StateFlow&amp;lt;State&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = _applicationState
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、以下のように書けるようになるらしいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> applicationState: StateFlow&amp;lt;State&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span> = MutableStateFlow(State())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>行数をかなり減らせられ、似たようなプロパティを定義する必要もなくなるのでかなり便利そうな感覚です。特にComposeのようにプロパティで状態を管理する場合はこのようなパターンが多いかなと思いますので、有効活用できるかなと思いました。&lt;/p>
&lt;h2 id="kotlin-notebooks">Kotlin Notebooks
&lt;/h2>&lt;p>このセッションで新しくKotlin Notebooksというものの発表がありました。今は&lt;a class="link" href="https://jupyter.org/" target="_blank" rel="noopener"
>Jupyter Notebook&lt;/a>でもKotlinは使えるのですが、似たような機能をKotlin専用として開発したような感覚ですね。Jupyterそのものも有名で、動画の中ですでに多くの機能を紹介しているので説明よりはそのキャプチャを載せておきます。以下のような活用例が紹介されています。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1_hu_2ed1e385aace7760.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1_hu_31d53db5e7f1b98d.webp 1024w"
loading="lazy"
alt="プロトタイピング"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2_hu_e19747fd570102a6.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2_hu_cf2e2f5b486d1ac3.webp 1024w"
loading="lazy"
alt="言語使用の学習(AIサポート)"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3_hu_c3ae33ced0302fa0.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3_hu_2195de9f77b1ac6e.webp 1024w"
loading="lazy"
alt="アルゴリズムの検証(ソートのビジュアライズ)"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4_hu_b5db521035f036e9.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4_hu_992c271b1cc1cffa.webp 1024w"
loading="lazy"
alt="データ調査"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5_hu_ba3daede87f04c28.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5_hu_5506b0eda44673ff.webp 1024w"
loading="lazy"
alt="データ分析"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6_hu_b529835b499ca531.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6_hu_27cf10c1243dd292.webp 1024w"
loading="lazy"
alt="Plot生成"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>その他、自動完成やオンラインでのコードシェア対応、テーブルのソートとカラムの順番変更などができるという点が紹介で明らかになっています。&lt;/p>
&lt;h2 id="googlekotlinconf">Google@KotlinConf
&lt;/h2>&lt;p>こちらのセッションはGoogleの人が出て発表をしていましたが、主に指標の話で、Androidのアプリの中でKotlinやComposeを採用しているものがどれほど多いかの話などが多かったですね。また、GoogleでもKotlinを積極活用していて、Google WorkspaceでもKotlin Multiplatformを利用してビジネスロジックを書いているという話がありました。&lt;/p>
&lt;p>他に注目したいところは、Androidの開発においてGradleのデフォルト設定がKotlin DSLになったというところです。Kotlinで開発をしているならもちろんGroovyよりはKotlinの方が便利だと思っていたので、このような変化はありがたいですね。&lt;/p>
&lt;p>ただ、GoogleでもKotlinを利用しているとはいえ、FlutterやGoという競合もあるので、今後どのような方向性を取っていくのかが気になりました。もちろんKotlinのカンファレンスなのでそのような話には触れなかったのですが、今後のGoogleの方針やCompose Multiplatformのシェアについてはもっと注目したいと思いました。&lt;/p>
&lt;h2 id="crossplatform">Crossplatform
&lt;/h2>&lt;p>このセッションではComposeのiOS対応の発表と、Mutiplatformの現在の紹介などがありました。ComposeのiOSはAlpha、MultiplatformはBetaの段階で多くのライブラリが対応しているなどの話が続きましたね。Kotlinが初めからJVM以外の領域でも活用できることを目標として開発されたのは確かですが、登場から10年以上も経ってやっとそのロードマップが現実になっているなという感覚でした。&lt;/p>
&lt;p>個人的にはXcodeやSwiftUIよりはintellijとComposeの方が合っていると感じていたので、iOSの開発ができるようになったのは大変嬉しく思っています。特に、AppCodeの開発が今年て終了するとのことだったのでMacやiOSの開発のためには致し方なくSwiftUIを勉強する必要があるかなと思っていたところなのでタイミング的にも最適ですね。直近でちょうどKotlinのみでウェブとモバイル、デスクトップのアプリを開発するというサイドプロジェクトをやっているので、早速試してみようかなと思っています。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>純粋にK2 Compilerの現在が知りたくて試聴した動画で、思わぬ発表が続いて嬉しい気持ちになりました。個人的には一つの言語で必要なことができるようにしたいと思っていたので、Kotlinという言語を選択したのは正解だったという気持ちになりました。&lt;/p>
&lt;p>やはりまだサーバサイドでもシェアはそこまで高くないかなと思いますが、これからもいろいろな分野でKotlinを使える環境が整っていくと言語として伸びるポテンシャルは十分など思いますので、また今後に期待ですね。&lt;/p>
&lt;p>取り急ぎ、KotlinConfのキーノートの動画を紹介しましたが、他にもいろいろな動画が公式のチャンネルにて配信中なので、興味がある方はぜひ見てみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Path ParameterをInline classで受け取る</title><link>https://retheviper.github.io/posts/ktor-path-parameter-as-inline/</link><pubDate>Sun, 26 Mar 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ktor-path-parameter-as-inline/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.webp" alt="Featured image of post Path ParameterをInline classで受け取る" />&lt;p>最近はサイドプロジェクトとしてシンプルなWebアプリケーションを作っていて、サーバサイドのフレームワークではKtorを採用しています。今まではずっとSpringを触ってきたので、たまにはこうやって違うフレームワークで何か作ってみるのも楽しいですね。&lt;/p>
&lt;p>さて、そこで今回の記事のテーマとなるのが、KtorでPath Parameterを受け取りInline Classとして扱う方法についてです。高度な技術を要するものではないのですが、より型安全で便利に使えるコードが書ける方法ではないかと思い試したことの紹介となります。&lt;/p>
&lt;h2 id="inline-classとは">Inline Classとは
&lt;/h2>&lt;p>Kotlin 1.6から&lt;a class="link" href="https://kotlinlang.org/docs/inline-classes.html" target="_blank" rel="noopener"
>Inline Class&lt;/a>という機能が追加されました。Inline Classは、型のラッパーとして使うことができる機能です。例えば、以下のようなコードがあるとします。プレイヤーがいて、そのプレイヤーごとの成績を表現したものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤー
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Player&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> playerRecordId: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーの成績
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PlayerRecord&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> score: Int)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして以下のようなメソッドがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーの成績を記録する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createPlayerRecord&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> playerId: Int, &lt;span style="color:#66d9ef">val&lt;/span> score: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このメソッドを呼び出すときに、プレイヤーのIDとスコアを渡す必要があります。しかし、このコードでは、プレイヤーのIDとスコアの両方ともがInt型になっているため、プレイヤーのIDをスコアとして渡してしまうというようなミスが起こりうるのです。そこで、以下のように、プレイヤーのIDとスコアをラップした型を定義して、それを使うようにすると、より安全にコードを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーのID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@JvmInline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PlayerId&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// スコア
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@JvmInline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Score&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>二つのInline Classを定義することで、先ほどの関数は以下のように修正できます。こうなると、パラメータを間違えて指定したらコンパイラーがエラーを吐いてくれるので、より安全にコードを書くことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーの成績を記録する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createPlayerRecord&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> playerId: PlayerId, &lt;span style="color:#66d9ef">val&lt;/span> score: Score) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここだけみると、Inline ClassがJavaのラッパークラスや普通のdata classと何が違うんだ？という疑問が湧いてくるかもしれません。また、typealiasのような既存の機能もありますね。ただ、Inline Classはコンパイル時にprimitive型の扱いでありながら、実行時にはラッパークラスのように振る舞うという特徴があります。そのため、Inline Classだと型安全を担保できつつパフォーマンスへの影響も少ないというメリットがあります。&lt;/p>
&lt;h2 id="ktorでpath-parameterを扱う">KtorでPath Parameterを扱う
&lt;/h2>&lt;p>Ktorでは、Path Parameterを受け取るためには、以下のように書く必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/{id}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = call.parameters[&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>]&lt;span style="color:#f92672">?.&lt;/span>toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Path Parameterを取得するために、&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/io.ktor.server.application/-application-call/index.html" target="_blank" rel="noopener"
>ApplicationCall&lt;/a>から&lt;a class="link" href="https://api.ktor.io/ktor-http/io.ktor.http/-parameters/index.html" target="_blank" rel="noopener"
>Parameters&lt;/a>で&lt;code>{id}&lt;/code>に指定された値をまずStringで読み込むようになります。そして、さらに&lt;code>toInt()&lt;/code>でIntに変換しています。これでPath ParameterをIntで受け取り、処理の中で使うことができるようになります。&lt;/p>
&lt;h2 id="path-parameterを受け取る処理を改善する">Path Parameterを受け取る処理を改善する
&lt;/h2>&lt;p>&lt;code>call.parameters&lt;/code>を利用したサンプルは一瞬見てシンプルなコードなのであまり改善の余地はないかなと思うかもしれませんが、実はこのコードにはいくつか問題があります。例えば、Int変換時のエラーを考慮する必要がありますね。&lt;code>toInt()&lt;/code>でIntに変換するときに、&lt;code>null&lt;/code>や&lt;code>&amp;quot;abc&amp;quot;&lt;/code>といった文字列が渡された場合には、&lt;code>NumberFormatException&lt;/code>が発生してしまいます。また、&lt;code>toInt()&lt;/code>でIntに変換するときに、&lt;code>Int.MAX_VALUE&lt;/code>を超える値が渡された場合には、&lt;code>NumberFormatException&lt;/code>が発生してしまいます。このように、Path Parameterを受け取るときには、必ず&lt;code>null&lt;/code>チェックや&lt;code>NumberFormatException&lt;/code>のチェックを行う必要があります。&lt;/p>
&lt;p>また、&lt;code>ApplicationCall&lt;/code>は&lt;code>get()&lt;/code>や&lt;code>post()&lt;/code>のような関数の中でしか呼び出せないです。ということは、エンドポイントごとに同じような処理（エラーハンドリングなど）を書く必要があるということです。ルータ内で何回も同じような処理があるのは望ましくないので、このコードを共通化したいですね。なので、以下のように&lt;code>ApplicationCall&lt;/code>に拡張関数を定義して、Path Parameterを取得する処理を共通化すると良いはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ApplicationCall&lt;/span>.getIdFromPathParameter(name: String): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> parameter = parameters[name] &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;id is required&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = parameter.toIntOrNull() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;id must be integer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> idInt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようにすると、以下のようにエラーハンドリングを共通化できます。try-catchで例外を処理していますが、ここは必要に応じて&lt;a class="link" href="https://ktor.io/docs/status-pages.html" target="_blank" rel="noopener"
>Status Pages&lt;/a>によるエラーハンドリングを追加すると良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/{id}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = call.getIdFromPathParameter(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (e: IllegalArgumentException) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.BadRequest, e.message)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="path-parameterをinline-classでラップする">Path ParameterをInline Classでラップする
&lt;/h2>&lt;p>さて、Path ParameterからInt型で取得する処理を共通化できたので、次はPath ParameterをInline Classでラップすることで、より安全にコードを書くことを考えてみましょう。まず、もっとも簡単な方法は以下のように拡張関数が返す値をInline Classにすることです。先ほどの関数だと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/{playerId}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = PlayerId(call.getIdFromPathParameter(&lt;span style="color:#e6db74">&amp;#34;playerId&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Inline Classもとりあえずコード上ではクラスの扱いなので、ジェネリックを使うこともできます。なので、先ほどの関数をジェネリックを使ったものにする方法も考えられます。イメージ的には、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/{playerId}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = call.getIdFromPathParameter&amp;lt;PlayerId&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;playerId&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようにすると、&lt;code>getIdFromPathParameter()&lt;/code>の戻り値を&lt;code>PlayerId&lt;/code>に変換する処理を&lt;code>getIdFromPathParameter()&lt;/code>の中で行うことができます。また、ジェネリックであるため、使える型を特定のInterfaceに制限し、IDに関するInline Classがそれを実装するという形にしたらより安全なコードになるでしょう。なので、まずは以下のようにID系の共通のInterfaceを定義します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ID系の共通のInterface
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Id&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// プレイヤーのID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@JvmInline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PlayerId&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int) : Id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 監督のID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@JvmInline&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DirectorId&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int) : Id
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、以下のように&lt;code>getIdFromPathParameter()&lt;/code>をジェネリックにして、&lt;code>Id&lt;/code>を実装したクラスのみを受け取れるようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// IDを取得する拡張関数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#66d9ef">reified&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>: &lt;span style="color:#a6e22e">Id&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">ApplicationCall&lt;/span>.getIdFromPathParameter(name: String): T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> parameter = parameters[name] &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;id is required&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id = id.toIntOrNull() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;id must be integer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> T&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.java.getDeclaredConstructor(Int&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.java).apply { isAccessible = &lt;span style="color:#66d9ef">true&lt;/span> }.newInstance(id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修正は簡単で、指定された&lt;code>Id&lt;/code>タイプのインスタンスを作成して、Path Parameterから取得したInt値をラップして返すだけですね。これで&lt;code>Id&lt;/code>を実装するInline Classのみ対応するという制限もかけながら、型の安全性も確保できるようになります。&lt;/p>
&lt;p>ただ一つ、Path Parameterとしての変数名をInline Classの方にcompanion objectとして持たせて共通化できるといいのですが、残念ながらそれは難しいようです。interfaceのcompanion objectはoverrideできなく、Inline Classはabstract classを実装することができないからです。なので、他の方法でPath Parameter名の指定ができるようにすれば拡張関数の引数を減らしよりシンプルなものになるという改善の余地がまだありそうです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>久々にKtorを触り、ブログの記事にしてみましたが、どうだったでしょうか。ずっとRest APIの実装ばかりしていたので、プライベートで何か新しいチャレンジをしてみないと、なかなか発見がない状態となっているのではないかという気がしています。ブログを始めてかれこれ5年目になり、まだ勉強不足だと感じるところが多いと感じつつもなかなかそれを言語化することは簡単ではないとも感じています。&lt;/p>
&lt;p>ブログの更新の頻度が減ることになっても、次からはより良い記事になるように頑張りたいと思います。では、また！&lt;/p></description></item><item><title>Spring Boot 3を導入してみた</title><link>https://retheviper.github.io/posts/spring-boot-2-to-3/</link><pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-boot-2-to-3/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post Spring Boot 3を導入してみた" />&lt;p>Spring Boot 2 (Spring Framework 5) から Spring Boot 3 (Spring Framework 6) にアップデートしてみました。&lt;/p>
&lt;h2 id="java-17">Java 17
&lt;/h2>&lt;p>仕事でJavaを使っていたごろは、Java 17をずっと待っていました。以前こちらのブログの記事として整理したこともありましたがテキストブロックやSwitchを式で使えるなど便利な機能がたくさん追加されたためです。しかし、Kotlinを使っている今は機能や言語仕の観点からJavaのバージョンを機にする必要はありません。なので、既存のアプリケーションがJava 11で動いているのであれば、Java 17に上げるモチベーションはあまりないように見えるかもしれません。&lt;/p>
&lt;p>それでもあえてバージョンを上げようとした理由は、まずサポート期間が今年の9月で終わるからということになります。正確にはJava 11のPremier Supportが2023年9月で終わり、それに準するExtended Supportは2026年9月までということになります。ただ、「準する」という表現が曖昧で、11は今の時点ではもうだいぶ古く、17もリリースから1年以上の期間の間に十分検証されていると判断しました。&lt;/p>
&lt;p>サポート期間の話だけだと、まだ終了まで半年以上の時間が残っているのですが、このタイミングで行うのは会社で「リファクタ期間」というものを設けているためです。この期間中は主に技術負債の解消や依存関係のバージョンアップなどを重点的に行うので、新しい機能の開発とバージョンアップが重なり問題が起こるような事項は避けたいと思いました。&lt;/p>
&lt;p>そのほかでも、新しいJavaのバージョンを採用することでパフォーマンスの向上を図ることができる点があります。例えば、&lt;a class="link" href="https://www.optaplanner.org/blog/2021/09/15/HowMuchFasterIsJava17.html" target="_blank" rel="noopener"
>Java 11よりGCの性能が改善されていたり&lt;/a>、状況によって&lt;a class="link" href="https://malloc.se/blog/zgc-jdk17" target="_blank" rel="noopener"
>ZGCの導入を考慮できる&lt;/a>オプションができたりです。Javaのバージョンが上がるということは、JVMの改善を含むということになるので、Kotlinでも十分その恩義を受けられることになるでしょう。&lt;/p>
&lt;p>なので、Java 17を採用することで決め、以降時の経験に関して共有したいと思います。&lt;/p>
&lt;h3 id="record">Record
&lt;/h3>&lt;p>社内ではORMとして&lt;a class="link" href="https://www.jooq.org/" target="_blank" rel="noopener"
>jOOQ&lt;/a>を採用していて、これから自動生成されたテーブル定義のコードをKotlinのコード(Repository)で呼び出す構造となっています。ただ、場合によってはこの自動生成のコードによりJava 17でのコンパイルが失敗することがあります。今回の場合は、以下のようなエラーメッセージと共にコンパイルが失敗するのを確認できました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>エラー: Recordの参照はあいまいです
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> public &amp;lt;O extends Record&amp;gt; SomeTable(Table&amp;lt;O&amp;gt; child, ForeignKey&amp;lt;O, SomeRecord&amp;gt; key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ^
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> org.jooqのインタフェース org.jooq.Recordとjava.langのクラス java.lang.Recordの両方が一致します
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはjOOQに&lt;a class="link" href="https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/Record.html" target="_blank" rel="noopener"
>Record&lt;/a>というクラスが存在していて、自動生成のコードでそれを利用しているためです。Java 14以降Lombokの&lt;a class="link" href="https://projectlombok.org/features/Value" target="_blank" rel="noopener"
>@Value&lt;/a>と似た機能を持つ&lt;a class="link" href="https://docs.oracle.com/en/java/javase/15/language/records.html" target="_blank" rel="noopener"
>Record Class&lt;/a>が登場していて、&lt;code>record&lt;/code>キーワードを使って定義したクラスは全て&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Record.html" target="_blank" rel="noopener"
>java.lang.Record&lt;/a>を実装する形になっています。というわけで、「jOOQのRecordを意味するのか、JavaのRecordを意味するのかコンパイラが判断できない」とエラーが発生してしまうのです。&lt;/p>
&lt;p>これは、既存の自動生成コードのインポートを修正するだけで回避できます。既存のコードだと、自動生成のコードでは以下のようにjOOQのクラスをインポートしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.jooq.*;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、明確にjOOQのRecordを指定するように修正します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.jooq.Record;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.jooq.*;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上で問題なくコンパイルが通るようになりました。もし自作のライブラリなどで&lt;code>Record&lt;/code>というクラスを定義している場合はここと同じエラーになる可能性があるので、なるべくクラスの名前を変えた方が良いかもです。&lt;/p>
&lt;h3 id="docker-image">Docker Image
&lt;/h3>&lt;p>現在開発中のサービスは&lt;a class="link" href="https://github.com/GoogleContainerTools/jib" target="_blank" rel="noopener"
>Jib&lt;/a>を使ってコンテナ化しています。ここでベースとなるイメージの指定が必要なのですが、既存で使っていたイメージはOpenJDKの&lt;a class="link" href="https://hub.docker.com/layers/library/openjdk/11-jre/images/sha256-762d8d035c3b1c98d30c5385f394f4d762302ba9ee8e0da8c93344c688d160b2?context=explore" target="_blank" rel="noopener"
>11-jre&lt;/a>でした。これが17からはJREのみのイメージはなく、&lt;a class="link" href="https://hub.docker.com/layers/library/openjdk/17-jdk/images/sha256-98f0304b3a3b7c12ce641177a99d1f3be56f532473a528fda38d53d519cafb13?context=explore" target="_blank" rel="noopener"
>17-jdk&lt;/a>のみとなったので、バージョンをあげる際は注意する必要があります。&lt;/p>
&lt;p>ただ、OpenJDK以外のイメージ意外を使っている場合は状況が違うかもしれませんので確認が必要です。例えば、&lt;a class="link" href="https://hub.docker.com/layers/library/eclipse-temurin/17-jre/images/sha256-402c656f078bc116a6db1e2e23b08c6f4a78920a2c804ea4c2d3e197f1d6b47c?context=explore" target="_blank" rel="noopener"
>Temurin&lt;/a>や&lt;a class="link" href="https://hub.docker.com/layers/azul/zulu-openjdk/17-jre/images/sha256-09163c13aefbe5e0aa3dc7910d9997e416031e777ca0c50bd9b66a63b46be481?context=explore" target="_blank" rel="noopener"
>Zulu&lt;/a>は&lt;code>17-jre&lt;/code>を提供していて、Libericaの場合は&lt;a class="link" href="https://hub.docker.com/layers/bellsoft/liberica-openjdk-alpine/17/images/sha256-50feb980f142b152e19c9dc25c835e0e451321eb3b837a3a924f457b11ce8c59?context=explore" target="_blank" rel="noopener"
>17&lt;/a>とバージョンだけになっているなど使っているJDKの種類によってタグ名が違うので、JDKのバージョンアップの際には使っているイメージのタグはチェックしておく方が良いでしょう。&lt;/p>
&lt;h3 id="依存関係">依存関係
&lt;/h3>&lt;p>自分の担当しているアプリで発生していた問題ではないのですが(マイクロサービスとして、Kotlinのサービスは複数あります)、一部でJavaのバージョンを11から17に上げた際に&lt;a class="link" href="https://github.com/TIBCOSoftware/jasperreports" target="_blank" rel="noopener"
>Jasperreports&lt;/a>を使った帳票の出力で報告された問題がありました。このライブラリはPDFの出力のために利用しているのですが、レイアウトに問題はなかったものの、表の中の表示文字数が少し減ったという問題がありました。幸い、これは大きい問題ではなかったのでまずは対応なしとなりそうですが場合によっては致命的かもしれません。&lt;/p>
&lt;p>おそらくこのような問題が発生したら、依存しているライブラリのバージョンをJava 17に対応したものにあげれば解消できるのではないかと思いますが、まだ17に対応していないライブラリがある可能性もあるので、事前に依存関係の方をチェックしておいた方が胃良いでしょう。&lt;/p>
&lt;h2 id="spring-boot-3">Spring Boot 3
&lt;/h2>&lt;p>Java 17は今年に11のサポートが終了するということで必須としていましたが、Spring Boot 3(Spring Framework 6)の場合は去年の12月にリリースされたばかりなので今回はあえて移行を試す必要はありませんでした。ただ、Spring Boot 3からちょうどJava 17が最低バージョンになり、以前からサーバレスの&lt;a class="link" href="https://ja.wikipedia.org/wiki/Google_App_Engine" target="_blank" rel="noopener"
>GAE&lt;/a>上で起動しているプロジェクトもあったので、起動時間を減らすために&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html" target="_blank" rel="noopener"
>Spring Native&lt;/a>を試してみたいと思っていたためでもあります。Spring NativeはSpring Boot 3から正式にサポートされることになったので。&lt;/p>
&lt;p>また、Spring Boot 3で依存関係が変わったり、プロパティの記述方法が変わったりするケースがあるとしても、自分が扱っているアプリケーションはマイクロサービスなので比較的に影響が少ないと予測できたからです。おそらくモノリシックで、Springの様々な機能に依存している場合は移行が難しい場合もあるかなと思います。なので、もし移行を考えている場合はなるべくリリースノートなどを確認しておいた方が良いでしょう。&lt;/p>
&lt;p>Spring Boot 2系から3系の移行は、基本的に&lt;a class="link" href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide" target="_blank" rel="noopener"
>公式のマイグレーションガイド&lt;/a>を参照すると良いのですが、マイグレーションガイドだけではわからないことや、Spring Frameworkの依存関係の変化により他のライブラリに影響が出ることがあります。なので自分の場合はどのように対応したかを少し紹介したいと思います。&lt;/p>
&lt;h3 id="constructorbinding">@ConstructorBinding
&lt;/h3>&lt;p>&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/properties/ConstructorBinding.html" target="_blank" rel="noopener"
>@ConstructorBinding&lt;/a>は、&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/properties/ConfigurationProperties.html" target="_blank" rel="noopener"
>@ConfigurationProperties&lt;/a>を付けたクラスにアプリケーションプロパティファイルから読み込んだ値をコンストラクタインジェクションするためのアノテーションです。現在のプロジェクトではAWSのS3のバケット名やメールのテンプレート、他のAPIを呼び出すためのエンドポイントなどを&lt;code>application.yaml&lt;/code>に記載して読み込むようにしています。&lt;/p>
&lt;p>ここで、Spring Boot 3だと&lt;code>@ConstructorBinding&lt;/code>なしでもプロパティを読み込むようになって、そもそもこのアノテーション自体がDeprecatedになっています。なので、最初はコンパイルエラーとなりますが、&lt;code>@ConstructorBinding&lt;/code>を削除するだけで問題なく動作するようになりました。最も簡単な対応でした。&lt;/p>
&lt;h3 id="tracingの変更">Tracingの変更
&lt;/h3>&lt;p>現在のアプリケーションでは、他のマイクロサービスのAPIを呼び出す際に&lt;a class="link" href="https://github.com/openzipkin/brave" target="_blank" rel="noopener"
>Brave&lt;/a>を使ってヘッダに&lt;code>Trace Context&lt;/code>を載せています。この場合、同じTrace IDが連携されるのでログの確認がやりやすくなりますね。今までは&lt;a class="link" href="https://spring.io/projects/spring-cloud-sleuth" target="_blank" rel="noopener"
>Spring Cloud Sleuth&lt;/a>を通じてBraveをDIしていましたが、これがSpring Boot 3になくなり(Spring Bootに統合）、&lt;a class="link" href="https://micrometer.io/" target="_blank" rel="noopener"
>Micrometer&lt;/a>の新しいAPIを利用することになったらしいです。&lt;/p>
&lt;p>つまり、既存のSpring Cloud SleuthによるDIは使えなくなり、依存関係も変化があるということです。まずは、DIを担当していた&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/3.0.1/api/org/springframework/boot/actuate/autoconfigure/tracing/BraveAutoConfiguration.html" target="_blank" rel="noopener"
>BraveAutoConfiguration&lt;/a>が&lt;a class="link" href="https://github.com/spring-projects/spring-boot/tree/v3.0.2/spring-boot-project/spring-boot-actuator" target="_blank" rel="noopener"
>Spring Boot Actuator&lt;/a>に移りました。なので、もうSpring Cloud Sleuthはいらなくなります。&lt;/p>
&lt;p>ただ、Spring Boot Actuatorだけだと&lt;code>BraveAutoConfiguration&lt;/code>によるDIはできません。なので以下のようにブリッジの依存関係を追加する必要があります。(バージョンはSpring Bootのものが使われる)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>implementation(&lt;span style="color:#e6db74">&amp;#34;io.micrometer:micrometer-tracing-bridge-brave&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>依存関係が変わるので、&lt;code>application.yaml&lt;/code>の設定も変更が必要になります。既存では、以下のように記載していました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spring&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sleuth&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">propagation&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">w3c&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Micrometerに移行したので、このように変更します。実際は、以下の設定はデフォルトなので記載しなくても問題はありませんが、メンテナンス時に現在の設定がわかりやすいように記載しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">management&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tracing&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">propagation&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">w3c&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、最もつまづいた部分はユニットテストでした。テストを実行してみると、なぜか以下のようなエラーメッセージが出ていました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &lt;span style="color:#e6db74">&amp;#39;brave.Tracing&amp;#39;&lt;/span> available: expected at least &lt;span style="color:#ae81ff">1&lt;/span> bean which qualifies as autowire candidate. Dependency annotations: &lt;span style="color:#f92672">{}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Spring Cloud Sleuthを使っていた頃はユニットテスト時もDIができていたのですが、なぜか&lt;code>BraveAutoConfiguration&lt;/code>によるDIが聞かない状態です。ローカルで起動した場合は同じエラーにならないので、おそらくテスト時にだけAutoConfigurationが呼ばれてないように思われます。&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/TestConfiguration.html" target="_blank" rel="noopener"
>@TestConfiguration&lt;/a>などを使って、直接Bean登録をする方法もあるかと思いますが、調査してみると&lt;a class="link" href="https://www.baeldung.com/spring-boot-3-observability#testing-observations" target="_blank" rel="noopener"
>Micrometerにはテスト用のライブラリが用意されている&lt;/a>ので、それを使うことにしました。このライブラリがリリースされたのは2022年の12月なので、なかなか情報を見つけるのが難しいです。とにかく、以下のようにライブラリを追加することでDIの問題は解消できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>testImplementation(&lt;span style="color:#e6db74">&amp;#34;io.micrometer:micrometer-tracing-test&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回はライブラリの追加だけで解消できたのですが、新しいライブラリの情報はこちらで調べないとなかなかわからないというのが問題でしたね。他のライブラリの場合も同じ問題があるかもしれないので、もしAutoConfigurationによりDIされるはずのBeanが見つからないとのエラーが出る場合は、テスト用のライブラリが追加されてないか確認するのが良いかもしれません。&lt;/p>
&lt;p>追加で、&lt;a class="link" href="https://www.datadoghq.com/ja/" target="_blank" rel="noopener"
>Datadog&lt;/a>の場合もMicrometerの設定の記載方法が全体的に変わったためか、一部プロパティの記載方法が変わっています。以前の場合は以下のように記載していました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">management&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">export&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">datadog&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiKey&lt;/span>: &lt;span style="color:#ae81ff">${API_KEY}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">step&lt;/span>: &lt;span style="color:#ae81ff">1m&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これが以下のように変わります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">management&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">datadog&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">export&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enabled&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">api-key&lt;/span>: &lt;span style="color:#ae81ff">${API_KEY}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">step&lt;/span>: &lt;span style="color:#ae81ff">1m&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にもMicrometerの機能を使っている場合、既存のSpring Boot 2と比べプロパティの設定方法が変わってないか確認した方がいいでしょう。&lt;/p>
&lt;h3 id="jakarta-ee">Jakarta EE
&lt;/h3>&lt;p>Spring Framework 6はOracleの&lt;code>Java EE&lt;/code>からEclipseの&lt;code>Jakarta EE&lt;/code>に移行しているので、コンパイルが通らない場合があります。主に&lt;a class="link" href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html" target="_blank" rel="noopener"
>HttpServletRequest&lt;/a>などsevlet系や&lt;a class="link" href="https://docs.oracle.com/javaee/7/api/javax/validation/Valid.html" target="_blank" rel="noopener"
>@Valid&lt;/a>などvalidation系パッケージがよく使われているかと思います。これらはimport時のパッケージ名を変更することで対応できます。例えば、以下のようなパッケージを使っている場合だとします。&lt;/p>
&lt;ul>
&lt;li>javax.servlet&lt;/li>
&lt;li>javax.validation&lt;/li>
&lt;/ul>
&lt;p>これらは以下のように変更します。&lt;/p>
&lt;ul>
&lt;li>jakarta.servlet&lt;/li>
&lt;li>jakarta.validation&lt;/li>
&lt;/ul>
&lt;p>パッケージ名が変わっただけで、中身は変わっていないので、簡単な対応となります。&lt;/p>
&lt;h3 id="springdoc">springdoc
&lt;/h3>&lt;p>&lt;a class="link" href="https://springdoc.org/" target="_blank" rel="noopener"
>springdoc-openapi&lt;/a>を使ってAPIドキュメントを生成している場合、既存のバージョンだとSpring Boot 3と互換性がないようです。CIでは&lt;code>/v3/api-docs&lt;/code>から取得したJSONを解析してS3にドキュメントをアップロードするようになっていますが、Spring Boot 3だと404エラーとなっていました。&lt;/p>
&lt;p>幸い、これも依存関係を変更することで対応ができます。以前は以下のように依存関係を追加していました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>implementation(&lt;span style="color:#e6db74">&amp;#34;org.springdoc:springdoc-openapi-ui:1.6.14&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>implementation(&lt;span style="color:#e6db74">&amp;#34;org.springdoc:springdoc-openapi-kotlin:1.6.14&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、&lt;a class="link" href="https://springdoc.org/v2/" target="_blank" rel="noopener"
>springdoc-openapiのv2&lt;/a>に変更するだけで良いです。Kotlinのサポートも含まれるので、以下のみで問題なく動きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>implementation(&lt;span style="color:#e6db74">&amp;#34;org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで404エラーは発生することなく、S3へのドキュメントのアップロードもできます。&lt;/p>
&lt;h3 id="liquibase">Liquibase
&lt;/h3>&lt;p>Spring Frameworkとの直接的な関係がある訳ではないのですが、Spring Bootのバージョンを上げたことにより影響を受けたのでこちらのケースも紹介します。DBのマイグレーションのためにGradleのプラグインとして&lt;a class="link" href="https://www.liquibase.org/" target="_blank" rel="noopener"
>Liquibase&lt;/a>を使っている場合、バージョンによっては以下のようなエラーが出る場合があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>SLF4J: No SLF4J providers were found.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SLF4J: Defaulting to no-operation (NOP) logger implementation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SLF4J: See https://www.slf4j.org/codes.html#noProviders for further details.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SLF4J: Class path contains SLF4J bindings targeting slf4j-api versions 1.7.x or earlier.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SLF4J: Ignoring binding found at [jar:file:/root/.gradle/caches/modules-2/files-2.1/ch.qos.logback/logback-classic/1.2.11/4741689214e9d1e8408b206506cbe76d1c6a7d60/logback-classic-1.2.11.jar!/org/slf4j/impl/StaticLoggerBinder.class]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SLF4J: See https://www.slf4j.org/codes.html#ignoredBindings for an explanation.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Exception in thread &amp;#34;main&amp;#34; java.lang.ClassCastException: class org.slf4j.helpers.NOPLogger cannot be cast to class ch.qos.logback.classic.Logger (org.slf4j.helpers.NOPLogger and ch.qos.logback.classic.Logger are in unnamed module of loader &amp;#39;app&amp;#39;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at liquibase.integration.commandline.Main.setupLogging(Main.java:233)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at liquibase.integration.commandline.Main.run(Main.java:145)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at liquibase.integration.commandline.Main.main(Main.java:129)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはおそらく、Spring Boot 3から&lt;a class="link" href="https://www.slf4j.org/" target="_blank" rel="noopener"
>SLF4J&lt;/a>のバージョンが2系になったためですね。Liquibaseのプラグインでは今まで&lt;a class="link" href="https://logback.qos.ch/index.html" target="_blank" rel="noopener"
>Logback&lt;/a>を使ってマイグレーションの状況を出力していたのですが、このLogbackのバージョンが1.2だったのでSLF4Jの2系と互換性がなかったのです。Logbackの1.3から互換性があるらしいので、それ以前のバージョンを使っている場合はこちらも合わせてバージョンを上げておく必要があるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>何とかJavaとSpring Bootのバージョンアップには成功していますが、前述した通り、これはあくまで自分が開発しているアプリケーションがマイクロサービスで、依存関係が比較的少なかったからできたことなのではないかと思います。モノリシックなアプリケーションだったり、より複雑な依存関係を持っているアプリケーションならここに記載したこと以外の部分でも問題が発生する可能性は高いでしょう。&lt;/p>
&lt;p>ただ、Springの場合はいずれSpring Boot 2のサポートが切れ、3系に移行するしかない状況が来るかもしれませんが、その時は十分マイグレーションの実例も出てくるのではないかと思います。Javaの場合は11から17に上げる場合なら大きく問題はないかと思いますが、8から移行する場合はJava 9で導入された&lt;a class="link" href="https://www.oracle.com/webfolder/technetwork/jp/javamagazine/Java-JA18-LibrariesToModules.pdf" target="_blank" rel="noopener"
>Module&lt;/a>で問題が起こる可能性もあるかと思いますので、慎重に行うべきかなと思います。&lt;/p>
&lt;p>嬉しいことに、まだNative化までは試してないのですが、JVM上でもアプリケーションの起動時間が減少していることを確認できました。ローカルで起動した場合、Java 11 &amp;amp; Spring Boot 2だと31秒がかかり、Java 17 &amp;amp; Spring Boot 3だと23秒がかかっていたので、断定はできないものの全体的な性能の向上もある程度は期待できるのではないかという気がします。正確なデータはまだ取れていないので、今後の課題として残しておきますが、ありがたいことですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinはどう書いたらいいか</title><link>https://retheviper.github.io/posts/kotlin-how-to-kotlin-like/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-how-to-kotlin-like/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinはどう書いたらいいか" />&lt;p>自分がJavaからKotlinに転向してからもう2年ほどが経ちます。しかし、いまだにKotlinでできることは無限にあって、新しい発見は終わることがないと感じています。Kotlinという言語自体のバージョンアップが早く、色々と機能が追加されて続けているのでまだしばらくこの発見も続きそうですね。&lt;/p>
&lt;p>そんな中で思うことなのですが、Intellijを使っていると自動的にJavaのコードを変換してくれたり、Javaの書き方をそのまま流用しても問題になることは少ないものの、やはりKotlinならではのコードを書きたいという欲求も湧いてきます。つまり、「Kotlinらしき書き方」をしたいと思ってしまうのです。&lt;/p>
&lt;h2 id="korlinらしき書き方って">Korlinらしき書き方って？
&lt;/h2>&lt;p>「Kotlinらしき書き方」とは一体どういうものなのでしょうか。まずはその定義が必要ですね。いろいろな捉え方があるかと思いますが、私は基本的に「Kotlinの仕様や機能を最大限に活かすこと」なのではと思っています。つまり、スタンダードライブラリのAPI、Scope Function, Extensionなどを積極的にコードに取り入れることです。そうすることでコードを書く時間は短くなり、より効率が上がるだろうと私は思っています。&lt;/p>
&lt;p>ただ、そういう概念を言葉で述べるだけでは曖昧なところがあるので、コードを持って例を挙げた方がいいでしょう。例えば、以下のような関数を実装する必要があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">numbers&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// TODO
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この関数を通じて行いたい処理は、「0〜10の数字をStringに変換してListとして返す」ことだとしましょう。その場合、実装の一例として以下のようなコードを提示できるかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">numbers&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> list = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> i = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (i &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list.add(i.toString())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> list.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map.html" target="_blank" rel="noopener"
>kotlin.collections.map()&lt;/a>を使ったら、同じコードを以下のように変換することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">numbers&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ae81ff">0.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>).map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>map()&lt;/code>のような関数が初めて登場した際は、あまり直感的にその処理の意味を把握できないということから「可読性に欠ける」という評価もあったようです。上記の二つのコードを比べると、場合によっては&lt;code>while&lt;/code>ループでの処理がわかりやすいと感じる方もいらっしゃるかなと思います。今は&lt;code>map()&lt;/code>が多くのプログラミング言語で採用している関数であり、期待できる関数の実行結果も常識化していますが、古典的なコードに慣れている人からしたら「ループで何かを行う」というコードの方がわかりやすいかもです。&lt;/p>
&lt;h2 id="可読性として">「可読性」として
&lt;/h2>&lt;p>しかし、果たしてより高度な処理を行う場合も「長いコードの方が可読性は良い場合もある」と断定できるのでしょうか。ここでまた、違う例を挙げてみましょう。例えば、&lt;code>Listの数字を全て掛け算した結果を返す&lt;/code>関数を実装する必要があるとします。例えば以下のようなコードを書くことができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">multiply&lt;/span>(numbers: List&amp;lt;Int&amp;gt;): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (numbers.isEmpty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalAccessException(&lt;span style="color:#e6db74">&amp;#34;List is empty&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> acc = numbers[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (numbers.size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> acc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ((index, &lt;span style="color:#66d9ef">value&lt;/span>) &lt;span style="color:#66d9ef">in&lt;/span> numbers.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (index &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> acc &lt;span style="color:#f92672">*=&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> acc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードでは当初の目的は果たしていますが、「可読性」という観点からするとどうでしょうか。関数のシグニチャーだけでなく、関数で行なっている処理全体に目を通さないと、何が起こっているかわからないのではないでしょうか？&lt;/p>
&lt;p>この関数で行なっている処理を一つ一つ読んでみると、「リストが空の場合はエラーを返す」、「リストの要素が一つの場合はそれを返す」、「リストが空でなく、要素が一つでもない場合は後続の処理を行う」、「最初の要素をとり、リストの要素をループしながら最初の要素以外を全て掛け算する」という情報が込められています。&lt;/p>
&lt;p>ここでExtensionと&lt;code>kotlin.collections&lt;/code>の関数を使って同じ処理を行う関数を実装してみると、コードは大きく変わります。以下がそのサンプルコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;Int&amp;gt;.multiply(): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reduce { acc, e &lt;span style="color:#f92672">-&amp;gt;&lt;/span> acc * e }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>map()&lt;/code>の場合と同じく、&lt;code>reduce()&lt;/code>という関数が何をするかがわからない場合もあるかと思います。しかし、その関数が「要素を一つに減らす」ことであり、その中で行なっている「減らし方は掛け算」ということを理解すれば良いだけなので、こちらの方がその意図を把握しやすいのではないでしょうか。先ほどの関数は、処理全体をいくつかの単位で分けて理解する必要があったということから考えると、可読性の面ではこちらの方がより優秀だと言えるのではないかと私は思っています。&lt;/p>
&lt;p>また、&lt;code>List&lt;/code>に拡張関数として定義することで、まるで元からついていたメソッドのように使えるのも良い点でしょう（IDEから自動補完に出てくるはずなので）。&lt;/p>
&lt;h2 id="工数として">「工数」として
&lt;/h2>&lt;p>コードを書くのは工数がかかる行為です。なので、同じ機能をする関数を書くとしても、毎回全ての処理を書くより共通化できる部分は分離し、再利用するのが常識のようなものです。そのため多くのライブラリやフレームワークが存在していますね。&lt;/p>
&lt;p>プログラミング言語の使用や機能をよく理解し、それらを活用するということも本質的にはライブラリやフレームワークを使うことと変わらないものです。先のように、「Listの要素を一つにまとめる」処理を毎回自前で書くとしたら、かなりの時間が必要となるでしょう。&lt;/p>
&lt;p>ここで他の例をまた挙げます。例えば以下のようなデータがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> version: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DBの中に履歴を残したい場合はversionや枝番など名称の列を持たせ、同じIDのデータをいくつか挿入する場合があるかと思います。そしてその場合、最新のデータのみを処理したいケースもありますね。上記の例だと、&lt;code>Data(1, 2)&lt;/code>と&lt;code>Data(2, 3)&lt;/code>のみを取得したいということです。&lt;/p>
&lt;p>最初からクエリで最新のデータのみを取得できるといいのですが、外部APIのレスポンスの場合はそのようにフィルタされたデータでない場合もあります。なのでこちらでversionがmaxのデータをフィルタする処理を書くとします。例えば以下のようなコードを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">maxVersions&lt;/span>(list: List&amp;lt;Data&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = mutableListOf&amp;lt;Data&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ((index, &lt;span style="color:#66d9ef">value&lt;/span>) &lt;span style="color:#66d9ef">in&lt;/span> list.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (index &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> last = result[result.size - &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">value&lt;/span>.id &lt;span style="color:#f92672">==&lt;/span> last.id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">value&lt;/span>.version &amp;gt; last.version) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.remove(last)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可読性の問題は一旦置いといて、このようなコードを書くときの工数はどうでしょうか。慣れてしまえば簡単なのかもしれませんが、初めてこの処理を書く人の立場からしたらかなりの工数がかかり、関数が期待通りに動作するかの検証を含めるとさらに工数が必要となりそうだと思います。慣れている場合でも、常にこのようなコードを的確に書けるかどうかが疑問です。&lt;/p>
&lt;p>それに対して、スタンダードライブラリを使った例を考えてみます。以下のように、メソッドチェーンによって簡単に同じことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> maxVersions = list.groupBy { &lt;span style="color:#66d9ef">it&lt;/span>.id }.map { &lt;span style="color:#66d9ef">it&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>.maxBy { &lt;span style="color:#66d9ef">it&lt;/span>.version } }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで使われている&lt;code>groupBy()&lt;/code>、&lt;code>map()&lt;/code>、&lt;code>maxBy()&lt;/code>はそれぞれ「ValueがListのMapを作る」、「要素を違う形にマッピングする」、「Listの要素のうちmaxの値を探す」という関数なので、ここだけでなく色々な場面で活用できる関数となっています。このように便利な関数を使いこなし、さらに組み合わせることでより複雑な処理でも簡単に書くことができるという点をみると、スタンダードライブラリの機能を理解するのは工数の面でもかなり効率を上げられることになるのではないかと思います。&lt;/p>
&lt;h2 id="注意点">注意点
&lt;/h2>&lt;p>ここまではKotlinの仕様や機能を活かすと可読性と工数という二つの観点から、メリットがあるという話をしてきました。しかし、どんなことでもメリットがあればデメリットもあるものですね。&lt;/p>
&lt;p>当たり前ながら、どんな機能でも単純に「それができる」という理由で乱用するとむしろ逆効果が出るケースがあります。例えば以下のような例を考えられます。二つのデータクラスがあって、&lt;code>Data&lt;/code>から&lt;code>Request&lt;/code>にマッピングする必要があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> version: Int?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Request&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> version: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Data&lt;/code>のフィールドはnullableとなっていますが、&lt;code>Request&lt;/code>の場合はそうではないです。このようにビジネスロジック上はnullになることはなくても、実装上の都合によってnullableにするケースもありますね。その場合、どうやってマッピングしたらいいでしょうか。例えば以下のような例があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Request&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> version: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span>(&lt;span style="color:#66d9ef">data&lt;/span>: Data): Request {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Request(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = requireNotNull(&lt;span style="color:#66d9ef">data&lt;/span>.id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${Data::id.name}&lt;/span>&lt;span style="color:#e6db74"> should not be null.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version = requireNotNull(&lt;span style="color:#66d9ef">data&lt;/span>.version) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${Data::version.name}&lt;/span>&lt;span style="color:#e6db74"> should not be null.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここではcompanion objectを利用して&lt;code>Request&lt;/code>のインスタンスを生成しながら、データのマッピングを行うようにしています。そこで、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require-not-null.html" target="_blank" rel="noopener"
>requireNotNull()&lt;/a>を利用したバリデーションを行い、nullだった場合はエラーメッセージを出力するようにしていますね。&lt;/p>
&lt;p>ここまでは良い実装だとして、問題はエラーメッセージの方です。どのパラメータがnullだったかわかるようにしていますが、そこで&lt;code>Data&lt;/code>のフィールドをRefelctionで取得し、そのフィールド名をStringに埋め込むようにしています。エラーが発生した時には意図的に動作するとしても、果たして性能の劣るRefelctionを使うまでのことだったでしょうか。&lt;/p>
&lt;p>このように、言語が提供する機能を活用する場合は適切な場面を判断する必要があります。ここで紹介した&lt;code>map()&lt;/code>や&lt;code>reduce()&lt;/code>、&lt;code>groupBy()&lt;/code>なども便利で簡単な実装ができるようにしてくれる優秀な関数ですが、これらの関数の実装をみるとそれぞれが一つのループを必ず行い新しいCollectionを生成するという処理を行なっているということを理解すれば、メソッドチェーンで複数の関数を利用する場合は性能に影響を及ぼす可能性もあるということがわかるでしょう。他にも可読性の面でもわかりにくくなったり、別の関数として分離した方が良いコードが一つの関数内でいくつも繰り広げられることになる可能性もあるかと思います。&lt;/p>
&lt;p>なので、「曖昧な理解」や「慣性」としてこれらの機能を利用するという行為にはリスクがあるということを理解し、どのような実装をするかは常に悩むべきではないかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>すでに何回か、「Kotlinで書いてみた」というタイトルで、Kotlinならこういう書き方ができるというポストを載せていて、今回の記事もまたそれらと大きく離れた題ではないです。また、ある意味ここで挙げたことはプログラマなら基本的に熟知しておくべき常識のようなもので、今更な感があるのかもしれません。&lt;/p>
&lt;p>それでもあえて記事として書いている理由は、基本こそ大事だという自分の考えゆえでもあります。経験を積んでいくと発展する部分もありますが、逆に変な習慣がついてしまいなかなか直せないところも出てくるものですので。自分はそうでないかという警戒を兼ねて、一度は基本に戻り今の自分と照らし合わせてみるのもまた一つの勉強になるのではないかと思います。ちょうど年末ということもありますが。&lt;/p>
&lt;p>少し遅れてしまいましたが、2022年のポストはこれにて終わりとなります。来年は自分も、ここに訪れるみなさんにも成長のある一年になることをお祈りします。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>ifでの分岐を考える</title><link>https://retheviper.github.io/posts/kotlin-if-to-non-if/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-if-to-non-if/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post ifでの分岐を考える" />&lt;p>ほとんどの言語で、特定の条件に合致した場合にのみ実行する処理を書くには、&lt;code>if&lt;/code>のように分岐処理のための構文を使うのが当たり前のように考えられています。言語によっては構文ではなく式として扱われたり、&lt;code>switch&lt;/code>や三項演算子のような他の選択肢も存在しますが、基本的に「条件とそれに従う処理」を書く機能として本質は変わらないものですね。&lt;/p>
&lt;p>分岐処理に限った話ではありませんが、便利な道具というのは時に危険性を伴うこともあります。&lt;code>if&lt;/code>を使う場合、最初の実装ではわかりやすく簡単に目的を達成できますが、維持保守の観点からするとあまり良くない選択になるケースもありますね。たとえば条件が増えたり変わるなどコードに変更が必要となった場合は修正がすべてのケースを網羅しているかどうかがわからなくなったり、ユニットテストが困難になったりするなどが考えられます。&lt;/p>
&lt;p>なので少なくとも&lt;code>if&lt;/code>の処理をよりシンプルにしたり、もしくはデザインパターンなどで分岐の構文を使わず同じ処理ができるように改善する必要が出てくることもあるかなと思います。そうすることで、コードリーディングはより難しくなるとしても、維持保守の観点からはより良いコードになる可能性もあるでしょう。&lt;/p>
&lt;p>もちろん、完全に&lt;code>if&lt;/code>をなくするというのは不可能に近い話で、そこまでする必要もありません。道具自体に罪はなく、あくまで使い方が問題になるだけですので。ここではあくまで、&lt;code>if&lt;/code>を使ったコードをどういう風にリファクタできるか、それだけに集中したいと思います。（初心者向けな感じで）&lt;/p>
&lt;h2 id="if文の例">if文の例
&lt;/h2>&lt;p>まずは、以下の関数をご覧ください。コードと価格を渡したら、内部ではコードに合わせて元の価格から割引の値を返すというものです。極めて単純化してはいますが、ECサイトのプロモーションなどでこのような処理が存在することもあるかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#ae81ff">0.1&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#ae81ff">0.15&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (amount &amp;lt; &lt;span style="color:#ae81ff">1000&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>すでにどのように処理をリファクタすれば良いか、一目でわかる方もいらっしゃるかなと思いますが、ここでは色々な観点でどうコードを変えられるかを述べたいので、一つ一つ項目を挙げて説明したいと思います。&lt;/p>
&lt;h2 id="関数のリファクタ">関数のリファクタ
&lt;/h2>&lt;p>まずは関数内の処理をどう変えられるかを考えてみます。コードをより単純化して可読性を向上したり、処理の漏れをなくしたり、共通化できたり処理の単位が曖昧な場合は分離するなどいろいろな方法が考えられるはずです。&lt;/p>
&lt;h3 id="標準ライブラリ">標準ライブラリ
&lt;/h3>&lt;p>上記の関数では&lt;code>if&lt;/code>の中にさらに&lt;code>if&lt;/code>が入っている構造となっているのがわかります。このようなネストは深くなれば深くなるほど良いコードとは言えませんね。なのでまずはここから直していきましょう。&lt;/p>
&lt;p>&lt;code>if&lt;/code>のネストを一つ減らす方法として、標準ライブラリを用いた方法を考えられます。標準ライブラリでなくでも関数として分離するという選択もありますが、標準ライブラリに処理を委任することでこの関数の負担がまず減るかなと思います。&lt;/p>
&lt;p>Kotlinには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-at-least.html" target="_blank" rel="noopener"
>coerceAtLeast()&lt;/a>という関数があり、パラメータとして渡された値をミニマムとして返すという働きをします。なので、&lt;code>amount&lt;/code>が1000以下の場合は&lt;code>amount&lt;/code>自身を、それ以外は1000を返すという処理はこの関数を使うことで単純化できます。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#ae81ff">0.1&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#ae81ff">0.15&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>) &lt;span style="color:#75715e">// 閾値を超えない値となる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>単純に標準ライブラリを使用しただけですが、ネストが一つなくなりより単純なコードになりました。また、ここでの修正により閾値の修正が必要になった場合でも、1箇所だけを修正すると良いというメリットもありますね。&lt;/p>
&lt;p>他にも標準ライブラリで処理ができそうな場所は積極的に利用したり、似たような処理が繰り返されるところがあったら切り出して自前のライブラリとして分離しておくことも良い選択になるでしょう。&lt;/p>
&lt;h3 id="when">when
&lt;/h3>&lt;p>もう一つのリファクタとしては、&lt;code>if&lt;/code>を&lt;code>when&lt;/code>(他の言語の&lt;code>switch&lt;/code>)に入れ替えるという方法を考えられます。&lt;code>when&lt;/code>は結果的に同じ機能をするので、常に&lt;code>if&lt;/code>の代替として良いというわけではありません。しかし、ifの条件が一律であれば、&lt;code>when&lt;/code>を選ぶのは良い選択になる場合があります。&lt;/p>
&lt;p>先ほどの&lt;code>if&lt;/code>で分岐する条件は、あくまで&lt;code>code&lt;/code>という文字列がどのような値となっているか比較することだけですね。他には特に条件がないので、&lt;code>when&lt;/code>を用いた方がブランチを文字列だけで収めるのでより単純化つ明瞭なコードになります。たとえば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (code) { &lt;span style="color:#75715e">// codeの値を比較するだけの分岐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (amount * &lt;span style="color:#ae81ff">0.1&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (amount * &lt;span style="color:#ae81ff">0.15&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>if&lt;/code>を&lt;code>when&lt;/code>に変えただけで、全体的に短くなってより読みやすいコードになっているかと思います。このように、&lt;code>if&lt;/code>の条件文がどのようなものかをみて、&lt;code>when&lt;/code>に変えるのも場合によっては良い選択の一つになり得るかなと思います。&lt;/p>
&lt;h3 id="拡張関数">拡張関数
&lt;/h3>&lt;p>Kotlinのような言語には、拡張関数で既存のクラスにメソッドを追加する機能がありますね。同じような処理が2箇所以上繰り返されているなら関数として分離を考慮すべきで、その関数を拡張関数として定義することも場合によっては考えられます。&lt;/p>
&lt;p>ここでは&lt;code>code&lt;/code>が&lt;code>Facebook&lt;/code>か&lt;code>Twitter&lt;/code>かによる分岐がありますが、やりたいことは&lt;code>amount&lt;/code>に特定のパーセンテージをかけて返すことですね。なので、パーセンテージを求める関数を定義しておいた方が良いでしょう。&lt;/p>
&lt;p>パーセンテージを求めるのはここでしか使わないとしたら&lt;code>private&lt;/code>な関数として定義しても良いのですが、より汎用的な使い方ができるようにしたいなら、以下のような拡張関数を定義するのもありでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// パーセントを求める拡張関数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">infix&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.percentOf(amount: Int): Int = (amount * &lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> percentOf amount &lt;span style="color:#75715e">// 10パーセントの値を返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span> percentOf amount &lt;span style="color:#75715e">// 15パーセントの値を返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先のほどのコードと比べ、拡張関数を定義することで処理の共通化ができたことと共に、「パーセントを計算する」という意図がコードでより明確に表れているようになっているのではないかと思います。&lt;/p>
&lt;h3 id="map">Map
&lt;/h3>&lt;p>&lt;code>if&lt;/code>や&lt;code>when&lt;/code>を使わない場合でも分岐ができる場合はあります。たとえば&lt;code>Map&lt;/code>を活用する方法ですね。&lt;code>code&lt;/code>によって違う値を掛け算したいので、&lt;code>code&lt;/code>をKeyに、掛けたい値をValueとするMapを定義しておくことです。たとえば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コードと割引率
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> discountPercentages = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> to &lt;span style="color:#ae81ff">10&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> to &lt;span style="color:#ae81ff">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 割引率が定義してあったら掛け算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> discountPercentages[code]&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Mapにないcodeの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法では全ての分岐を網羅することはできなくなりますね。&lt;code>code&lt;/code>の値ががMapのKeyに含まれてない場合の処理が必要となるからです。ここでクロージャを用いると&lt;code>code&lt;/code>の値が&lt;code>Instagram&lt;/code>の場合の処理もMapに含めることができます。たとえば以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Valueを(Int) -&amp;gt; Intに変える
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> discountRules = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> to { amount: Int &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> percentOf amount },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> to { amount: Int &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span> percentOf amount },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> to { amount: Int &lt;span style="color:#f92672">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> discountRules[code]&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">it&lt;/span>(amount) } &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mapを利用する方法が条件分岐より良い方法だとは言い切れないのですが、コード別の割引率を他の関数でも参照する必要があるなど、複数の関数やクラスを跨いで共通の値を保持しておきたい場合は考えられる方法の一つになるかなと思います。この場合は、Map一つを修正するだけで全体の処理で整合性が保証されるコードになるという効果がありますね。&lt;/p>
&lt;h2 id="oop的な考え方">OOP的な考え方
&lt;/h2>&lt;p>今までは単純に関数内部の処理をどう変えていくかについて述べましたが、より高度な方法ももちろんあります。OOPの考え方として捉えると、先ほどの関数は「割引額を求める」責任がありますが、その中で「割引」の定義そのものと、その計算式まで持っていることになります。なので、責任を分離していく必要がありますね。&lt;/p>
&lt;p>この修正に処理は一見より複雑なものになっていくと感じる場合もあるかと思いますが、これはOOPに原則である&lt;a class="link" href="https://ja.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener"
>SOLID&lt;/a>を考慮したものでもあります。長期的な観点からすると、このような方法をとった方がより維持保守には向いていることになるでしょう。&lt;/p>
&lt;h3 id="interface抽出">interface抽出
&lt;/h3>&lt;p>まずは「割引ポリシー」を&lt;code>insterface&lt;/code>として分離します。この割引ポリシーを実装するクラスで実際のポリシーに従う割引額を計算するイメージです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicy&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> NONE: DiscountPolicy = &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">DiscountPolicy&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとはこの&lt;code>interface&lt;/code>を実装するクラスを、コード別に定義しておきます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FacebookDiscountPolicy&lt;/span> : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">10&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TwitterDiscountPolicy&lt;/span> : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">15&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">InstagramDiscountPolicy&lt;/span> : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやって割引ポリシーを定義しておくと、&lt;code>getDiscountAmount()&lt;/code>は以下のように変えられるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> discountPolicy = &lt;span style="color:#66d9ef">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> FacebookDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> TwitterDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> InstagramDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicy&lt;/span>.NONE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> discountPolicy.calculate(amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="factory">Factory
&lt;/h3>&lt;p>先ほどの&lt;code>interface&lt;/code>抽出で割引ポリシー自体は分離できたものの、&lt;code>getDiscountAmount()&lt;/code>ではまだ「割引ポリシーを生成する」という責任を持っています。これもまた別の役割として分離ができるでしょう。ここは以下のように割引ポリシーを生成する&lt;code>Factory&lt;/code>を定義しておくと良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicyFactory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountPolicy&lt;/span>(code: String): DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> FacebookDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> TwitterDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> InstagramDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicy&lt;/span>.NONE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最終的に、&lt;code>getDiscountAmount()&lt;/code>は以下のように修正できます。&lt;code>interface&lt;/code>の抽出や&lt;code>Factory&lt;/code>の作成でコードの量は増えましたが、この関数の責任はより軽くなり、割引ポリシーの追加や修正が必要な場合でも柔軟な対応ができるようになりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> discountPolicy = &lt;span style="color:#a6e22e">DiscountFactory&lt;/span>.getDiscountPolicy(code)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> discountPolicy.calculate(amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="enum">Enum
&lt;/h3>&lt;p>割引ポリシーを生成するために&lt;code>Factory&lt;/code>を使う代わりに、&lt;code>Enum&lt;/code>を使うこともできます。先ほどの&lt;code>DiscountPolicy&lt;/code>を継承して、クラスではなく列挙定数として扱う方法です。たとえば以下のようなものが定義できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicies&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> code: String) : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FACEBOOK(&lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">10&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TWITTER(&lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">15&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INSTAGRAM(&lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fromCode&lt;/span>(code: String): DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> values().find { &lt;span style="color:#66d9ef">it&lt;/span>.code &lt;span style="color:#f92672">==&lt;/span> code } &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicy&lt;/span>.NONE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の&lt;code>Enum&lt;/code>を利用する場合、&lt;code>getDiscountAmount()&lt;/code>は以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> discountPolicy = &lt;span style="color:#a6e22e">DiscountPolicies&lt;/span>.fromCode(code)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> discountPolicy.calculate(amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Enum&lt;/code>の場合、&lt;code>fromCode()&lt;/code>で&lt;code>code&lt;/code>による分岐そのものが必要なくなり、割引ポリシを追加したい場合でも列挙定数を追加することで拡張も容易にできるので&lt;code>Factory&lt;/code>よりも良い方法ではないかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最初に断っておいたように、全ての&lt;code>if&lt;/code>をなくすのは不可能に近い話で、そうする必要もありません。しかしその&lt;code>if&lt;/code>が行っている処理の本質、責任、可読性のような要素は注意深く観察する必要があり、最初は&lt;code>if&lt;/code>でとりあえず動くコードを作ったあとは他の方法で改善できるかどうか振り返ってみる必要はあるかなと思います。&lt;/p>
&lt;p>こういう自分も常に綺麗なコードを書いているわけではないのですが、たまにはこうやって初心者の気持ちで自分の書いたコードを振り返ってみるという姿勢は常に必要なのではという気持ちにもなります。良いコードを書くのは常に難しいものですね。でも、難しいことを最初にやっておいた方が後に後悔しないことにもつながるだろうと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinだけでファイルサーバを作ってみた</title><link>https://retheviper.github.io/posts/kotlin-compose-web/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-compose-web/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinだけでファイルサーバを作ってみた" />&lt;p>世の中にはさまざまなプログラミング言語があり、それぞれの特徴も明確で、言語ごとにできる・できないことも違うケースが多いですね。企業ならエンジニアの採用や費用など現実的な観点から技術選定をするので、プロジェクトにおいてどの言語を使うかは明確かつ一般的な基準があるかと思います。しかし、個人のレベルだとチームでの作業を考慮すべきでもなく、その人の好みや慣れというものから言語を選ぶ傾向があるのではないかと思います。なので、割とマイナーな言語やフレームワークを使うケースもあるでしょう。&lt;/p>
&lt;p>自分がまさにそうであって、個人的に使うために実装するアプリや自動化のスクリプトなどは、なるべくKotlinやPythonで作成しています。特にKotlinの場合、仕事でも使っているので最も慣れているからでもありますが、さまざまなフレームワークや言語自体の特徴によりサーバサイドというジャンルやJVMという環境に限らずいろいろなことにチャレンジできるのが魅力的で好きです。&lt;/p>
&lt;p>というわけで、今回もプライベートでちょっと変わった形でウェブアプリを一つ作ってみた、という話です。どこが変わっているかというと、表題にも書いてある通りですが、「Kotlin」だけでファイルサーバのアプリを実装した話となります。&lt;/p>
&lt;h2 id="背景">背景
&lt;/h2>&lt;p>まず、どんなアプリをなぜ作ったかから述べないとですね。私の実家には、以前から使っていたWindowsのパソコンがあります。組み立てたのはおよそ8年ほど前のことで、最近は自分が実家に帰ることも少ないのであまり使われてないです。ただ、今のPC(Mac)からファイルを送ったりもらったりして使うことがあります。&lt;/p>
&lt;p>ここでファイルのやりとりには、今までMicrosoft社の&lt;a class="link" href="https://www.microsoft.com/ja-jp/microsoft-365/onedrive/online-cloud-storage" target="_blank" rel="noopener"
>OneDrive&lt;/a>を使っていました。片方で必要なファイルをOneDriveのフォルダにコピーしておくと、そのファイルがクラウドにアップロードされ、自動的に同期される方式ですね。これでも問題は全然なく安定的に使ってはいましたが、ふと思うとクラウドを経由するというステップが無駄だという気がしました。また、同期の前後でファイルをコピーしたり移動したりすることもめんどい作業になっています。&lt;/p>
&lt;p>ここで、自分でインターネット越しでファイルのやり取りができるアプリを作ってみたらどうかと思ったわけです。すでに自分が思っているような機能を提供している何らかのサービスはあるかもしれませんが、そこまで複雑なものでもないので、数日で作れるような気がしましたのでとりあえずチャレンジしてみることにしました。（SFTPというオプションもありましたが、GUIで楽にしたかったので却下です）&lt;/p>
&lt;h2 id="要件">要件
&lt;/h2>&lt;p>さて、作りたいものがあったらやることは決まっています。いつものことですが、アプリを作る前に簡単に要件を決めておきます。まず、機能的には以下のようなことができれば良いかなと思いました。&lt;/p>
&lt;ul>
&lt;li>サーバアプリを起動すると、クライアントからサーバのストレージにアクセスできる&lt;/li>
&lt;li>サーバのパスを指定したらその中身（ファイルとフォルダ）が見える&lt;/li>
&lt;li>フォルダをクリックすると表示中のパスが変わる&lt;/li>
&lt;li>ファイルをクリックするとダウンロードできる&lt;/li>
&lt;li>パスにファイルをアップロードできる&lt;/li>
&lt;/ul>
&lt;p>機能が決まったらそれを実現するための技術の番ですね。ここでは、何よりもKotlinで全て解決したい！という考えで、技術選定は全てKotlinを中心にしています。&lt;/p>
&lt;p>まずFrontendでは、ちょうどこないだ&lt;a class="link" href="https://www.jetbrains.com/lp/compose-desktop/" target="_blank" rel="noopener"
>Compose for Desktop&lt;/a>で簡単なアプリを作ったとこのブログに書いたことがありましたが、&lt;a class="link" href="https://compose-web.ui.pages.jetbrains.team/" target="_blank" rel="noopener"
>Compose for Web&lt;/a>というものもあったので、今回はこれを使ってみるとどうかなと思いました。これに関しては言語を統一したいという理由が最も大きいのですが、他にはFrontendの経験や知識があんまりないので少しでも触れてみた技術を使いたかったという理由もあります。&lt;/p>
&lt;p>Backendのフレームワークは&lt;a class="link" href="https://ktor.io/" target="_blank" rel="noopener"
>Ktor&lt;/a>にすることとしました。普段はSpringをやっているのでこちらの場合もあまり本格的な経験があるわけではありませんが、以前触れてみた感覚だとアプリの起動がはやく、実装も簡単だったので採用。また同じく、最も大きい理由はKotlin用ということです。&lt;/p>
&lt;p>大きくはこの二つで、他にも当然色々とライブラリなどが必要となるわけですが、ここは実装を進めながら必要なものがKotlin製かJetBrainsのものかを基準に選んで実装することにしました。もしくは実装において参考となるだろう公式のドキュメントに出てくるものを採用するという方針です。&lt;/p>
&lt;h2 id="frontend">Frontend
&lt;/h2>&lt;p>Frontendでは、先に述べた通りCompose for Webを使いました。やはり初めてということもあったのですが、まだ新しい技術だったり、そもそも自分がFrontendに対してあまりわかってないということもあったので最も工数がかかった部分です。ここについては、肌で感じたことを良かった点・思ったことと違った点・問題だった点という三つの軸で分けて述べていきたいと思います。&lt;/p>
&lt;h3 id="良かった点">良かった点
&lt;/h3>&lt;p>良かった点としては、やはりComposeでデスクトップアプリを作ってみた経験を活かした実装ができたというところです。Composeでは&lt;a class="link" href="https://developer.android.com/jetpack/compose/state#state-in-composables" target="_blank" rel="noopener"
>&lt;code>remember&lt;/code>と&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>&lt;/a>を組み合わせて状態を管理したり、&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Composable" target="_blank" rel="noopener"
>@Composable&lt;/a>をつけた関数の単位で画面の構成要素を分けて実装することができますが、ここでもそれは同じでした。&lt;/p>
&lt;p>なので、「指定したパスをブラウズ」する機能を実装した時、「一つ前のパスに戻る機能を追加したいな」と思ったときはそのパスを保持するために状態にパスを持たせたり、サーバから取得したパスの中身のオブジェクト（ファイルやフォルダなど）を画面に描画するためのコンポーネントを一つの&lt;code>@Composable&lt;/code>関数として定義して使ったりなどが思ったよりも簡単にできたわけです。&lt;/p>
&lt;p>他にもKotlinなのでCoroutineが簡単に使えたり、サーバサイドと同じリポジトリにソースコードを作成できるというところも良いところでした。特に後者の場合、GradleでKotlinのプラグインを&lt;code>multiplatform&lt;/code>にすることでFrontendではJavaScriptにコンパイルされ、サーバサイドではいつも通りJVMのバイトコードにコンパイルされるようにできるという点がお気に入りです。&lt;/p>
&lt;h3 id="思ったことと違った点">思ったことと違った点
&lt;/h3>&lt;p>自分の考えが甘かったのですが、Desktopとはかなり違うところがありました。何かというと、言語としてはKotlinを使うとしても、HTMLやCSSを排除することはできないという点です。ここでもやはり&lt;code>div&lt;/code>や&lt;code>form&lt;/code>のようなタグを使ったり、タグにマウスオーバ時のカーソルを変えるためにタグの&lt;code>attr&lt;/code>を変更する必要がありました。例えば、以下はファイルアップロードのコンポーネントですが、Kotlinで書いているだけで実際はHTMLをそのまま書いているような感覚です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Composable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">FileUploadForm&lt;/span>(currentPath: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Div {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Form(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$API&lt;/span>&lt;span style="color:#e6db74">_URL&lt;/span>&lt;span style="color:#e6db74">$ENPOINT&lt;/span>&lt;span style="color:#e6db74">_UPLOAD&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attrs = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method(&lt;span style="color:#a6e22e">FormMethod&lt;/span>.Post)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> encType(&lt;span style="color:#a6e22e">FormEncType&lt;/span>.MultipartFormData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target(&lt;span style="color:#a6e22e">FormTarget&lt;/span>.Blank)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HiddenInput {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name(&lt;span style="color:#e6db74">&amp;#34;target&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span>(currentPath)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Input(&lt;span style="color:#a6e22e">InputType&lt;/span>.File) { name(&lt;span style="color:#e6db74">&amp;#34;file&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Input(&lt;span style="color:#a6e22e">InputType&lt;/span>.Submit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここは完全に他のプラットフォームでのComposeを使うというよりは、Kotlinようにラップされたクラスを提供するだけという印象が強く、やはりある程度Frontendの知識が必要となる部分ではないかと思っています。なので、&lt;a class="link" href="https://reactjs.org/" target="_blank" rel="noopener"
>React&lt;/a>や&lt;a class="link" href="https://vuejs.org/" target="_blank" rel="noopener"
>Vue.js&lt;/a>などメジャーなFrontendのフレームワークの知識がある場合にはあまりComposeを選ぶ理由はなさそうな気がしています。&lt;/p>
&lt;p>他には、いつもとは違ってKotlin/JSとKotlin/JVMが共存するプロジェクトとなっているためか、intellij上の自動補完やビルド時の挙動が少し違う感覚があります。例えば、Gradleで依存関係を変更してもすぐに反映されなかったり…&lt;/p>
&lt;h3 id="問題だった点">問題だった点
&lt;/h3>&lt;p>意外と問題になったのは、プロジェクトのビルドでした。Compose for Webでは&lt;code>index.html&lt;/code>ファイルとWebpackなどを使ってビルドされた&lt;code>js&lt;/code>ファイルを使うことになり、ビルド自体はGradleのコマンドひとつで簡単にできるものですが、どうやら内部的に&lt;a class="link" href="https://yarnpkg.com/" target="_blank" rel="noopener"
>yarn&lt;/a>などを使っているようですが、intellijで生成したプロジェクトのデフォルト設定ではビルド時にエラーが出ることが多かったです。&lt;/p>
&lt;p>調べてみると自分のようなエラーが出る場合、&lt;a class="link" href="https://github.com/Kotlin/kotlinx-datetime/issues/193" target="_blank" rel="noopener"
>ビルドできない場合はKotlinのバージョンが&lt;code>v1.6.20&lt;/code>以降だと解消される&lt;/a>らしいのですが、問題はComposeのバージョンでした。このアプリを実装した時点の最新は&lt;a class="link" href="https://github.com/JetBrains/compose-jb/releases/tag/v1.1.1" target="_blank" rel="noopener"
>v1.1.1&lt;/a>なのですが、これだと対応しているKotlinのバージョンが&lt;code>v1.6.10&lt;/code>までです。なので、自分の場合は&lt;code>v1.2.0&lt;/code>のベータ版を使ってKotlinのバージョンを&lt;code>v1.7.10&lt;/code>にしてから解消できました。これはマイナーなプロジェクトのハマりどころと言えるものかもしれないですね。&lt;/p>
&lt;p>また、HTTPクライアントとしては&lt;a class="link" href="https://ktor.io/docs/getting-started-ktor-client.html" target="_blank" rel="noopener"
>Ktor Client&lt;/a>を使っていますが、大容量のファイルをアップロードする場合を想定して&lt;code>form&lt;/code>タグでMultipartのデータを直接送るよりHTTPクライアントを使う方法を取ろうとするとうまくいかなかったです。Ktor ClientはMultiplatform対応のものなので、クライアントの宣言時に&lt;a class="link" href="https://ktor.io/docs/http-client-engines.html" target="_blank" rel="noopener"
>どのEngineを使うかを選択できる&lt;/a>のですが、Kotlin/JSで使えるEngineだと&lt;a class="link" href="https://ktor.io/docs/request.html#binary" target="_blank" rel="noopener"
>公式で紹介している内容&lt;/a>通りに実装しても&lt;code>File&lt;/code>オブジェクトを直接扱えないので送信ができませんでした。ここは今後の改善に期待するか、Websocketなどを使うなど他の方法を取る必要がありそうです。&lt;/p>
&lt;h2 id="backend">Backend
&lt;/h2>&lt;p>次にBackendですが、こちらは自分の慣れている分野で、Ktor自体については他のポストでも述べたことがあり、技術的な面の話よりはロジック面で試行錯誤をしたことを中心に述べていきたいと思います。&lt;/p>
&lt;h3 id="ファイルツリーのブラウズ">ファイルツリーのブラウズ
&lt;/h3>&lt;p>このアプリにはまずファイルをブラウズする機能があるので、クライアントで指定したパスを探索して、その中にあるコンテンツ（ファイルとフォルダ）を返す必要があります。問題は、JSONの構造をどうするかですね。ここではまず一つの方法を試してみてから判断することにしました。&lt;/p>
&lt;h4 id="全取得する">全取得する
&lt;/h4>&lt;p>最初は、以下のような形で実装をしようと思いました。パスを指定したら、その配下にある全てのフォルダをたどり、親子関係をネストで表現する形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Documents&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;children&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;SomeDocument.pdf&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;file&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1391482&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;mimeType&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;application/pdf&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Images&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;children&amp;#34;&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようなファイルツリー返すために、サーバ側のコードは以下のようなものを使いました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ルートとなるパスを指定すると、子要素（ファイルとフォルダ）を全て取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> files = &lt;span style="color:#a6e22e">Files&lt;/span>.list(root)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#66d9ef">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathをJSONオブジェクトとして加工する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Path&lt;/span>.toFileTree(): FileTree {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> FileTree(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">this&lt;/span>.fileName.toString(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.fileSize(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#a6e22e">FileType&lt;/span>.DIRECTORY &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">FileType&lt;/span>.FILE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> children = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.list(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#66d9ef">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walk-java.nio.file.Path-java.nio.file.FileVisitOption...-" target="_blank" rel="noopener"
>Files.walk()&lt;/a>を使うと、指定したパスを基準にネストされているファイルツリーを全て&lt;code>Stream&amp;lt;Path&amp;gt;&lt;/code>として取得してくれますが、それだと上記のJSONの形として加工するのが簡単ではないです。一度取得した結果をもとに、親子関係を追跡しながらJSONオブジェクトとしてまとめるにはかなり複雑な処理になるっでしょう。&lt;/p>
&lt;p>なので、ここでは&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#list-java.nio.file.Path-" target="_blank" rel="noopener"
>Files.list()&lt;/a>を使って指定したパスに含まれた要素を取得し、その要素がディレクトリの場合はさらに子要素として取得するように再帰を使って子要素を再度取得するという形としてまとめています。単純な処理ですが、効率的になりましたね。&lt;/p>
&lt;p>ただ、この方法で思った通りのファイルツリーをJSONとして返すことはできましたが、問題がありました。まず、指定したパスがルートに近くなればなるほど探索にかかる時間が長くなり、レスポンスも遅く慣ればJSONのサイズも大きくなるという問題がありました。また、JSONを受け取ったところで、Frontendで描画をするにも難点がありそうな気がしました。というわけで、この案はまず廃棄して、二つ目の方法を取ることにしました。&lt;/p>
&lt;h4 id="ネストさせない">ネストさせない
&lt;/h4>&lt;p>次に試した方法は、指定したパスのみに処理を制限することでした。何かというと、JSONオブジェクトのネストを無くして、指定したパスにどんなファイルとフォルダが含まれているかだけをリストとして返すということです。つまり、以下のような形になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Documents&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Images&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうなると、中のフォルダを辿る必要がなくなるのでレルポンスも早く、軽くなるわけです。最初からちゃんと考えるべきだったのですが、こちらの方がFrontendとしても実装が楽であって、さらにサブパスのフォルダにアクセスしたい場合はそのパスを再度Backendに送ればいいだけですね。コードとしては再帰を使わなくなったくらいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> files = &lt;span style="color:#a6e22e">Files&lt;/span>.list(root)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#66d9ef">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathをJSONオブジェクトとして加工する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Path&lt;/span>.toFileTree(): FileTree {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> FileTree(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">this&lt;/span>.fileName.toString(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.fileSize(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#a6e22e">FileType&lt;/span>.DIRECTORY &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">FileType&lt;/span>.FILE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルアップロード">ファイルアップロード
&lt;/h3>&lt;p>ファイルアップロードについては、Mutlipartとして送られているデータをどう扱うかですが、これはKtorらしく簡単な処理で対応できました。以下のコードが実際の実装となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// router
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>post(ENPOINT_UPLOAD) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Multipartデータを受信
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> multipart = call.receiveMultipart()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイル保存先のパス
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> path = &lt;span style="color:#a6e22e">Path&lt;/span>.of(ROOT_DIRECTORY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> multipart.forEachPart { part &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (part) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ルートでないパスを指定した場合は保存先を更新
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">PartData&lt;/span>.FormItem &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (part.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;target&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = path.resolve(part.&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルデータを保存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">PartData&lt;/span>.FileItem &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> file = &lt;span style="color:#a6e22e">Files&lt;/span>.createFile(path.resolve(part.originalFileName&lt;span style="color:#f92672">!!&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> part.streamProvider().use { input &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.newOutputStream(&lt;span style="color:#66d9ef">file&lt;/span>).use { output &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input.copyTo(output)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// どちらでもない場合は一旦出力
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Unknown part: &lt;/span>&lt;span style="color:#e6db74">$part&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 処理の終わったデータはdispose
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> part.dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、個人的にはストレージアクセスのある処理に対してはNIOを使いたいので、はじめは&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/nio/file/Files.html#copy-java.io.InputStream-java.nio.file.Path-java.nio.file.CopyOption...-" target="_blank" rel="noopener"
>Files.copy()&lt;/a>を使おうと思ったのですが、なぜかファイルの保存処理を以下のような作成するとうまくいかなったです。Coroutineとの相性に何か問題があるのかもしれないですので、ここは注意ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> file = &lt;span style="color:#a6e22e">Files&lt;/span>.createFile(path.resolve(part.originalFileName&lt;span style="color:#f92672">!!&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Files&lt;/span>.copy(part.streamProvider(), &lt;span style="color:#66d9ef">file&lt;/span>) &lt;span style="color:#75715e">// ファイルが保存されない
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルダウンロード">ファイルダウンロード
&lt;/h3>&lt;p>ファイルダウンロードの場合も、ロジックは特にないので、ほとんどKtorのみのコードとなっています。自分の好みでPathを使っているくらいですのでコードだけを紹介します。ひとつ注意すべきところは、アップロードする時もそうですが、ファイル名を返すときにURLパスとしてエンコードすることですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">get&lt;/span>(ENDPOINT_DOWNLOAD) {&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> filepath = call.request.queryParameters[&lt;span style="color:#e6db74">&amp;#34;filepath&amp;#34;&lt;/span>] &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> path = &lt;span style="color:#a6e22e">FileService&lt;/span>.getFullPath(filepath) &lt;span style="color:#75715e">// ルートディレクトリからのフルパスを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">Files&lt;/span>.notExists(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.BadRequest, &lt;span style="color:#e6db74">&amp;#34;File not found&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.response.header(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#a6e22e">HttpHeaders&lt;/span>.ContentDisposition,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#a6e22e">ContentDisposition&lt;/span>.&lt;span style="color:#a6e22e">Attachment&lt;/span>.withParameter(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = &lt;span style="color:#a6e22e">ContentDisposition&lt;/span>.&lt;span style="color:#a6e22e">Parameters&lt;/span>.FileName,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> = path.fileName.toString().encodeURLPath()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ).toString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respondFile(path.toFile())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="注意すべきところ">注意すべきところ
&lt;/h3>&lt;p>まず、一つのプロジェクトにKotlin/JSとKotlin/JVMを両立する場合、&lt;code>dependencies&lt;/code>として記述するものに対しては&lt;code>build.gradle.kts&lt;/code>ファイルで以下のように指定することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>kotlin {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sourceSets {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Kotlin/JSの依存関係
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> jsMain &lt;span style="color:#66d9ef">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(compose.web.core)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(compose.runtime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Kotlin/JVMの依存関係
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> jvmMain &lt;span style="color:#66d9ef">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-core-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-auth-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Composeを使うためには&lt;code>plugin&lt;/code>として指定する必要があり、これがプロジェクト全体の依存関係に追加されることになっていました。なので、アプリの作りとしてはまずFrontendのComposeをビルドし、サーバを起動したらビルドしたファイルをstaticとして提供する構造になっていますが、Backendの起動にもComposeのランタイムが必要になります。このランタイムを追加してくれないと、エラーが吐き出され、Ktorが起動できなくなっています。何かKotlin/JSのみの依存関係にpluginを追加する他の方法があるかもしれませんが、とりあえずはJVMの依存関係に以下のようにランタイムを追加することで問題は解消できました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jvmMain &lt;span style="color:#66d9ef">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-core-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-auth-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> implementation(compose.runtime) &lt;span style="color:#75715e">// Composeランタイム
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="その他">その他
&lt;/h2>&lt;p>Kotlin/JSとKotlin/JVMを一つのプロジェクトとして扱う場合に、&lt;code>common&lt;/code>というパッケージを設けることで、コードの共有ができるのが何より嬉しかったところです。例えば、JSONオブジェクトをdata classとして定義してcommonパッケージに置くことで、FrontendとBackendの両方で同じオブジェクトを使うことができます。他にももちろんEnumやconstを共有できたりするので、実装がかなり楽でした。&lt;/p>
&lt;p>また、今回は採用しなかったのですが、Ktor Serverの場合&lt;a class="link" href="https://ktor.io/docs/type-safe-routing.html#resource_classes" target="_blank" rel="noopener"
>Type-safe Routing&lt;/a>というものに対応しているので、うまく活用できたらかなり良さそうな気がしました。これはKtor Clientでも&lt;a class="link" href="https://ktor.io/docs/type-safe-request.html#define_route" target="_blank" rel="noopener"
>Type-safe Request&lt;/a>として対応しているので、FrontendとBackend両方で使える機能です。またKtorを使う機会があったら、ぜひ使ってみたいと思っています。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ファイルアップロードが思った通り改善できなかったので、アプリの完成はまだ少し先のことになりそうですが、かなり面白い経験となりました。Kotlinでできることは色々とあるので、また何か作ってみたいものがあればチャレンジしてみたくなります。ただ、やはりまだ成熟してない技術なので、思ってもなかったところで問題が発生したりリファレンスがあまりないという点ではまだプロダクションレベルでは使えないものかなという気がします。&lt;/p>
&lt;p>アプリ全体のコードはGitHubにて公開していますので、&lt;a class="link" href="https://github.com/retheviper/FileTransporter" target="_blank" rel="noopener"
>こちら&lt;/a>から参照できます。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinでデスクトップアプリを作ってみた</title><link>https://retheviper.github.io/posts/kotlin-compose-desktop/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-compose-desktop/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinでデスクトップアプリを作ってみた" />&lt;p>バックエンドの開発をしていると、テストの自動化では対応できない場合もありますね。理想的なシナリオとしては、ユニットテストから全てのシナリオを想定したインテグレーションテストまでを全部作成でき、開発・企画に属するものがそれらを理解しきっていることだろうとは思いますが、現実ではなかなか難しいものです。特に、サービスが成長していきながら技術的負債を解消しようとしたり、新しい機能を足したり、昔は対応できなかった改修が必要となったり、運用上のイレギュラー対応が必要となったりなどで最初の仕様は変わり続けていき、改修を行うエンジニアや運用する側でも今の状態がどうで、どう変わるべきかを判断するのは難しくなりがちなのだから、と自分は理解しています。&lt;/p>
&lt;p>なので、少なくとも今のアプリがちゃんと想定通りに動くかどうかを人の手で検証する必要が出てくるケースも十分にあり得るものです。そしてそうなった場合はどうやってテストを行うかを考える必要もありますね。テストの方法も色々あり、小さい機能単位でユニットテストを行い、最終的にはインテグレーションテストやシナリオテストまで上がっていくと良いはずですが、その全部を自動化するのが難しいケースもあるかと思います。例えばテストするためのデータのパターンを色々と用意する必要があったり、エンジニアが完全に仕様を把握してなかったりなどの場合もありますね。なので、人の手によるテスト（モンキーテスト的な）が必要となる場面も存在すると思います。&lt;/p>
&lt;p>今回はその「人の手によるテスト」を手伝うために、テストツールを作った話です。自分の扱っているシステムはマイクロサービスの一つであり、業務仕様が複雑でさまざまなパターンで機能をテストする必要がありました。なのでエンジニアとしては実装を進めながら、同時に業務仕様に詳しい人にさまざまなパターンのデータを使ってテストができるツールを作ることになったわけです。&lt;/p>
&lt;h2 id="目標と設計技術選定">目標と設計、技術選定
&lt;/h2>&lt;p>実は以前から、リポジトリにはすでにテストツールが存在していました。しかし調べたところ、作られて2年以上放置されていて、Ruby on railsという自分が全く触れたことも（興味を持ったことも）ないフレームワークで作られているという問題がありました。これだと、自分がRubyを勉強して既存のツールを改修するという手もあったかもしれませんが、以下の理由から一から作り直そうと思いました。&lt;/p>
&lt;ol>
&lt;li>KotlinエンジニアがRubyアプリをメンテするのは良くない&lt;/li>
&lt;li>ドキュメント化が進んでなく、使い方が不便&lt;/li>
&lt;/ol>
&lt;p>そう決めてからは、テストを行いたい側（企画）からの要請を受け、ツールに要求される仕様としての機能をまとめることに。テストが行えるツールという確実な目標があったので、仕様は極めて単純です。要求事項としてツールに揃うべき機能は以下のようなものでした。&lt;/p>
&lt;ul>
&lt;li>テストデータのファイルを読み込ませる&lt;/li>
&lt;li>バックエンドのアプリのAPIを呼び出す&lt;/li>
&lt;li>APIの実行結果をファイルに書き込む&lt;/li>
&lt;/ul>
&lt;p>テストツールとしては上記に挙げている要求事項を満たしているならテストツールとしては合格というわけです。しかし、実際のテストを行いたい側がまずエンジニアではなく、今後もエンジニアではない人がツールを触る可能性があります。そこまでを考慮して、以下の追加的な目標を立てました。&lt;/p>
&lt;ul>
&lt;li>環境構築をしなくても使えるようにする&lt;/li>
&lt;li>手順書がなくても使えるくらい簡単なものに仕上げる&lt;/li>
&lt;/ul>
&lt;p>ここまで決めたら、次に要求されている機能の細部を掘り下げていきます。設計書を書くほどでもないですが、土台となる設計のようなものです。&lt;/p>
&lt;ul>
&lt;li>データの読み込みと書き込み
&lt;ul>
&lt;li>ツールを使える人はSQLが使える=テーブル（表）が読める&lt;/li>
&lt;li>テーブルの形でデータの入出力ができた方がわかりやすい&lt;/li>
&lt;li>テストデータはCSVで読み込む&lt;/li>
&lt;li>API実行結果もCSVに書き込む&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>APIコールができる
&lt;ul>
&lt;li>HTTPクライアントでGET・POSTする&lt;/li>
&lt;li>APIコールにはトークンが必要
&lt;ul>
&lt;li>トークンはセキュリティ問題でソースコードに埋め込むのはNG&lt;/li>
&lt;li>しかし毎回入力するのはめんどくさい&lt;/li>
&lt;li>アプリを実行して最初はトークンを入力し、次回からはそのトークンを使い回すようにする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>本番以外の環境が対象
&lt;ul>
&lt;li>複数の環境があるのでどれかを選択できるようにする&lt;/li>
&lt;li>これも毎回入力はめんどくさい&lt;/li>
&lt;li>最初に一回だけ選択できるようにしたい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>そして自分の立てた目標を、上記の要求事項を達成できるかどうかを考えながら振り返ってみます。環境構築をしなくても使えるなら、実行可能な一つのバイナリとして提供した方が良いでしょう。また、使い方が簡単な方だと、やはりGUIを含めた方が良いですね。特にGUIを採用したら要求事項に対してもかなり良い感じで機能を完成できると思いました。&lt;/p>
&lt;p>例えばファイルの読み込みや書き込みにはパスの指定が必要で、トークンと環境の選択も入力が必要な項目で、CLIだとやはり不便です。エンジニアではない人が触るとしたら尚更ですね。Windowsユーザなら、コマンドラインも考慮しなければならないかもしれません。その反面、GUIだとファイルパスならダイアログ、トークンの入力もテキストポックス、環境の選択ならプールダウンメニューで対応できます。なので、「バイナリの実行で起動できるGUIのアプリを作る」という結論を出しています。&lt;/p>
&lt;h2 id="compose-for-desktop">Compose for Desktop
&lt;/h2>&lt;p>テストツールの仕様と技術的な要件が決まったら次は技術選定になりますがね。まずどの言語を使うかについてですが、自分以外でも同じチーム、つまりKotlinエンジニアがこれからもメンテを行うことになる可能性が高いのでKotlinにしました。Kotlinを使うことで、機能の実現で必要なライブラリの選定も楽になりますね。すでにテスト対象のバックエンドアプリで使っているHTTPクライアントがあるので、一部のコードはそのまま移植しても良いはずです。また、同じライブラリを使うことでメンテもより簡単になるでしょう。&lt;/p>
&lt;p>あとはGUIですが、今回は&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-desktop/" target="_blank" rel="noopener"
>Compose for Desktop&lt;/a>を使うことにしました。KotlinはJavaと互換性があるので、当然&lt;a class="link" href="https://ja.wikipedia.org/wiki/Swing" target="_blank" rel="noopener"
>Swing&lt;/a>や&lt;a class="link" href="https://openjfx.io/" target="_blank" rel="noopener"
>JavaFX&lt;/a>などJavaのGUIツールキットをそのまま使うという選択肢もあります。他にも&lt;a class="link" href="https://github.com/edvin/tornadofx" target="_blank" rel="noopener"
>TornadoFX&lt;/a>という選択肢があったりもしますが、今回あえてComposeを選んだのはいくつかの理由があります。&lt;/p>
&lt;p>まずは個人的にモバイルに興味があって以前から興味を持っていたので、今回本格的にこれでアプリを作ってみたいという願望もありましたが、今後もKotlinエンジニアの手でメンテが行われるとすると、やはりモバイルの経験があるか、少なくとも興味を持つ方が多いだろうという点です。Composeはまだ正式リリースされて1年ほどしか経ってない新しいものですが、最近流行っているいわゆる「宣言型」のフレームワークなので、少なくともAndroidアプリの開発ではメインストリームになる可能性が高いだろうという判断からでした。&lt;/p>
&lt;p>また、Composeはモバイルのみでなく、そもそもマルチプラットフォーム向けに開発されたものなので、Windows/Mac/Linuxの環境を問わず実行可能なバイナリをビルドできるという点でも魅力的だったです。これならテスターがどんなOSを使っていても同じ感覚でツールを使えて、&lt;/p>
&lt;p>ただ、やはり今まであまり接したことのない技術なので勉強はもちろん試行錯誤などもあったので、テストツールを作りながらこれは覚えておいた方が良いなと思ったところをいくつか挙げてみようと思います。&lt;/p>
&lt;h3 id="状態管理">状態管理
&lt;/h3>&lt;p>&lt;a class="link" href="../swift-ui-first-impression-2/" >SwiftUIのポスト&lt;/a>の時も触れた状態管理ですが、Composeでも同じくGUIを扱うことになるので、状態管理が大事となります。今回はアプリとしての画面がひとつしかないので、複数の画面にまたがって状態を管理する必要はないかなと思いましたが、それでもやはり処理を行うためにはアプリ全体で共有する状態として管理が必要なものがいくつかありました。&lt;/p>
&lt;p>ただ、上記ポストでも述べた通り、SwiftUIとComposeとは状態管理の方式が少し違います。SwiftUIでは状態がどこで使われるかによって明確に使われるアノテーションやクラスなどが変わっていたなら、Composeでは大体&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary?hl=ja#remember%28kotlin.Function0%29" target="_blank" rel="noopener"
>remember()&lt;/a>と&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState?hl=ja" target="_blank" rel="noopener"
>&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>&lt;/a>の組み合わせで事足りることになります。画面の構成要素の最小単位をComposeではWidgetでも使い方が同じだということは、SwiftUIと比べると定義するのは簡単ですが、使い方には少し注意が必要だなという感覚でした。&lt;/p>
&lt;p>まず、Composeでの状態は、以下のような三つの方法で定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Delegateで定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> isOn: Boolean &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#66d9ef">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 直接値を書き換えできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>isOn = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 分解宣言で定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>isOff: Boolean, setIsOff: (Boolean) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#66d9ef">true&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 参照と更新が分離される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (isOff) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setIsOff(&lt;span style="color:#f92672">!is&lt;/span>Off) &lt;span style="color:#75715e">// toggle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// MubtableState&amp;lt;T&amp;gt;として扱う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> isNotOff: MutableState&amp;lt;Boolean&amp;gt; = remember { mutableStateOf(&lt;span style="color:#66d9ef">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ラッパーになっているので、値を更新するためにはvalueにアクセスする必要がある
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>isNotOff.&lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#f92672">!is&lt;/span>&lt;span style="color:#a6e22e">NotOff&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでDelegateで&lt;code>var&lt;/code>として定義した場合は最も使いやすくなりますが、Intellij上ではコンパイルエラーになりがちです。なぜかというと、Delegateを使うためには&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#%28androidx.compose.runtime.MutableState%29.setValue%28kotlin.Any,kotlin.reflect.KProperty,kotlin.Any%29" target="_blank" rel="noopener"
>androidx.compose.runtime.setValue&lt;/a>と&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#%28androidx.compose.runtime.State%29.getValue%28kotlin.Any,kotlin.reflect.KProperty%29" target="_blank" rel="noopener"
>androidx.compose.runtime.getValue&lt;/a>をimportする必要がありますが、これが自動で行われないからです。最初このエラーの理由がわからなかったり、忙しい場合にいちいちimport文を書いていくが面倒だったりでかなり使わなくなるケースも多いかなという気がします。ただこれは、まだIntellijでのCompose対応が完璧ではないのが原因なので、これはいずれ解消されると期待できるでしょう。&lt;/p>
&lt;p>分解宣言で値の参照と更新を別々で使うのは、どこで使うか悩ましいケースもあるかなと思いますが、Composeの一部Widgetに状態を渡す場合に使われる場面があります。代表的なものが&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField%28kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors%29" target="_blank" rel="noopener"
>TextField&lt;/a>で、これはコードを見るとすぐにその目的がわかります。実際のコードで、以下のように使われます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>text: String, updateText: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TextField(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onValueChange = setValue, &lt;span style="color:#75715e">// TextFieldに文字を入力するとその値でtextを更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span> = text &lt;span style="color:#75715e">// textの値をTextFieldに表示する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後に&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>として定義するケースですが、直接的な値の更新ができないので最も使い方としては不便なのですが、実際は最も多く使われるのではないかと思います。なぜかというと、アプリ全体で状態を共有するなど複数のWidgetをまたがって使う場合は、以下のようにclassの中にフィールドとして&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>を定義することになるからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// アプリ全体で共有するためにクラスに状態を定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> isOn: MutableState&amp;lt;Boolean&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはもちろん別途&lt;a class="link" href="https://kotlinlang.org/docs/properties.html#getters-and-setters" target="_blank" rel="noopener"
>getter/setter&lt;/a>をclassに定義しておくと、中のvalueにアクセスしなくても直接プロパティにアクセスする感覚で使えます。イメージ的には以下のようなものですね。これだと状態として管理したい項目が増えれば増えるほどコードの量が増えてしまう面倒さがあるというのが短所かなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _isOn: MutableState&amp;lt;Boolean&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isOn: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = _isOn.&lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>) { _isOn.&lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、Composeでの状態には定義する方法が色々あり、それぞれの特徴があるわけなのでどの場面で使うかによって適切な定義の方法を考えるのが何よりも大事だという印象です。&lt;/p>
&lt;h3 id="swingawt">Swing/AWT
&lt;/h3>&lt;p>Compose for Desktopの特徴の一つは、Swingや&lt;a class="link" href="https://en.wikipedia.org/wiki/Abstract_Window_Toolkit" target="_blank" rel="noopener"
>AWT&lt;/a>に対する互換性があるという点です。最初は&lt;a class="link" href="https://github.com/JetBrains/compose-jb/blob/master/tutorials/Tray_Notifications_MenuBar_new/README.md" target="_blank" rel="noopener"
>Macのトレイ、メニューバー、通知&lt;/a>にも対応していたので基本的な機能は全て揃っているのではないかと思いましたが、実はそうでもなく、一部の機能はSwingやAWTの機能を借りて実装することになるケースもありました。実際、私の作ったテストツールでも一部SwingとAWTの機能を使っているところがあります。&lt;/p>
&lt;p>例えばファイル選択機能がそうです。CSVを読み込むためにファイル選択のダイアログを表示したかったのですが、ComposeのWigdetではまだ対応できてないので、やむを得なくAWTの&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/FileDialog.html" target="_blank" rel="noopener"
>FileDialog&lt;/a>を使う必要がありました。以下がその実装の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 選択したファイル名を状態として保持する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> fileName &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// AWTのファイル選択ダイアログを使う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>FileDialog(ComposeWindow()).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 選択できるのはCSVのみにしたい
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> setFilenameFilter { _, name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> name.endsWith(&lt;span style="color:#e6db74">&amp;#34;.csv&amp;#34;&lt;/span>, ignoreCase = &lt;span style="color:#66d9ef">true&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isVisible = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルが選択された場合は状態を更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (!&lt;span style="color:#66d9ef">file&lt;/span>.isNullOrBlank()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileName = &lt;span style="color:#66d9ef">file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これでも十分ではない場合もありました。フォルダのみを選択できるようにしたい場合に&lt;code>FileDialog&lt;/code>はあまり良い選択ではなかったのです。名前からそうですが、あくまでファイルの選択を想定したものであるため、フォルダのみを選択できるようにはできなかったのです。なので、フォルダのみを選択できるようにするためには、Swingの力も借りる必要があります。その場合は、以下のように実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 選択したフォルダのパスを状態として保持する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> selectedPath &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Swingのファイル選択ダイアログをディレクトリのみ選択できるように設定して定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> fileChooser = JFileChooser().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dialogTitle = &lt;span style="color:#e6db74">&amp;#34;Choose Directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileSelectionMode = &lt;span style="color:#a6e22e">JFileChooser&lt;/span>.DIRECTORIES_ONLY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ダイアログを表示する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (fileChooser.showOpenDialog(ComposeWindow()) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">JFileChooser&lt;/span>.APPROVE_OPTION) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ダイアログで選択したパスが状態として保持しているパスと違う場合、選択したディレクトリの絶対パスを状態として更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> path = fileChooser.selectedFile.absolutePath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (selectedPath &lt;span style="color:#f92672">!=&lt;/span> path) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectedPath = path
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回はこの二つユースケースのみSwingやAWTが登場していませんでしたが、どんなアプリを実装するかによって他のAPIも色々と使う必要性が出てくるかも知れないという良い一例になっている気がします。まだComposeはリリースされて1年ほどしか経っていないので、今後のバージョンアップでより多彩なWidgetが追加されることに期待ですね。&lt;/p>
&lt;h3 id="ビルド">ビルド
&lt;/h3>&lt;p>Composeを選んだ理由の一つのバイナリのビルドができるという点ですが、これはかなり満足度が高かったです。&lt;code>gradle&lt;/code>を使って、コマンドひとつで実行可能なバイナリが生成されます。Macでビルドして見ると、他のアプリと同じくパッケージが生成されます。中を見ると、実行に必要なJREと依存関係のJarが含まれていて、ネイティブではなくJVM上で起動される構造になっていました。&lt;/p>
&lt;p>バイナリをビルドするときのオプションには色々なものがあり、OSの種類(Windows, Mac, Linux)によって違うアイコンを使ったり、基本的には含まれないモジュールを含むように指定したりすることができました。以下が実際のビルド時のオプションのサンプルです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>compose.desktop {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> application {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mainClass = &lt;span style="color:#e6db74">&amp;#34;com.testtool.MainKt&amp;#34;&lt;/span> &lt;span style="color:#75715e">// 実行時のメインクラスを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> nativeDistributions {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> packageName = &lt;span style="color:#e6db74">&amp;#34;Test Tool&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> packageVersion = &lt;span style="color:#e6db74">&amp;#34;1.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modules(&lt;span style="color:#e6db74">&amp;#34;java.sql&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;java.naming&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// デフォルトでは含まれないパッケージを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> macOS {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iconFile.&lt;span style="color:#66d9ef">set&lt;/span>(project.&lt;span style="color:#66d9ef">file&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;misc/appicon/icon-mac.icns&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> windows {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iconFile.&lt;span style="color:#66d9ef">set&lt;/span>(project.&lt;span style="color:#66d9ef">file&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;misc/appicon/icon-win.ico&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ビルド時は注意が必要です。ビルドするとき、Composeでは内部的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/14/docs/specs/man/jpackage.html" target="_blank" rel="noopener"
>jpackage&lt;/a>を使うので、まずJava 15以上が必要となります。また、CPUのアーキテクチャによって違うJDKをインストールするようになっているため、ビルドするマシンと違うのアーキテクチャのCPUを使っているマシンをターゲットにすることはできません。&lt;/p>
&lt;p>つまり、自分の使用のMacだとApple Silicon用のバイナリが生成され、IntelチップのMacだとx64用のバイナリが生成されるということです。実際ComposeでApp Storeにアプリを提出した人もいるらしいのですが、Rosettaで起動できるということでIntelチップのMacを使ってビルドしているとのことでした。Universal Binaryを作りたい場合は、JDKそのものがまずUniversal Binaryとして提供されることを待つしかなさそうです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回はデスクトップアプリの中でもかなり制限された機能と単純なロジックしかないシンプルなものを作ったので、もしこれからまたComposeを使ってさまざまな機能を持つように実装するとしたら(マルチウィンドウやダークモード対応、ナビゲーションなど)また色々と発見があるかも知れない気がしています。個人的にはかなりためになる経験で、思ったより実装もそこまで難しくなかったので、ツールの機能を拡張するか新しいツールを作ってみるチャンスがあるとしたら再度Composeを使ってみたいなと思いました。&lt;/p>
&lt;p>まだリリースされてからそう長くもなく、足りない機能や情報も多かったり競合のフレームワークが色々とあるので未来はどうなるかわからないものですが、自分のようにKotlinをメインとしているエンジニアで、GUIに興味がある方なら一度はComposeを使って見ることをお勧めしたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>data classのListをCSVにする</title><link>https://retheviper.github.io/posts/kotlin-write-csv/</link><pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-write-csv/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post data classのListをCSVにする" />&lt;p>アプリを書いていると、DBに保存した形とは違う形でデータを読み込んだり出力するケースが多いです。代表的に、多くのバックエンドアプリで採用しているREST APIがそうですね。APIの入力値と戻り値は、DBに保存されている形とは一致しないケースが多く、必要(リクエストを送信してきた側の都合)に合わせて適切にパラメータを受け取り、レスポンスを返すようになっています。そして時と場合によっては、人間が楽に読める形としてデータをまとめる必要もあります。そういった場合はExcelファイルやCSV、PDFといったいろいろなものを想定できますね。&lt;/p>
&lt;p>今回のポストも場合も人が読める形のファイルとして、特にCSVを扱う場合にKotlin側の実装をどうやっていくかに関するものです。&lt;/p>
&lt;h2 id="kotlinでcsvを扱う">KotlinでCSVを扱う
&lt;/h2>&lt;p>KotlinのCSV読み込み/書き込みのライブラリとして&lt;a class="link" href="https://github.com/doyaaaaaken/kotlin-csv/" target="_blank" rel="noopener"
>kotlin-csv&lt;/a>があり、JVMだけでなくKoltin/JSの場合でもこのライブラリを使って簡単にCSVを扱えます。更に&lt;a class="link" href="https://github.com/blackmo18/kotlin-grass" target="_blank" rel="noopener"
>kotlin-grass&lt;/a>というライブラリもあり、&lt;code>kotlin-csv&lt;/code>との組み合わせででCSVのデータを簡単にdata classのListとしてまとめることもできますね。読み込みの際に指定できるデータのフォーマットやカスタムマッピングオプションなどの機能も豊富にあり、かなり使いやすく良いライブラリとなっています。&lt;/p>
&lt;p>しかし、実は&lt;code>kotlin-csv&lt;/code>を使うときに問題が一つあります。先に述べた通りCSVにデータの出力そのものは可能なものとなっているのですが、読み込みの時にdata classへのマッピングには別のライブラリが必要であったように、data classのリストを書き込むには追加の処理が必要となります。これは、kotlin-csvの書き込み用のメソッドが以下のようになっているからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">writeAll&lt;/span>(rows: List&amp;lt;List&amp;lt;Any?&amp;gt;&amp;gt;, targetFile: File, append: Boolean = &lt;span style="color:#66d9ef">false&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">open&lt;/span>(targetFile, append) { writeRows(rows) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>rows&lt;/code>が書き込みで使うデータとなりますが、型が&lt;code>List&amp;lt;List&amp;lt;Any?&amp;gt;&amp;gt;&lt;/code>になっているので、列のデータを一つの行としてListに定義し、それをさらにListに格納することでCSVのデータ全体を定義する必要があります。これはつまり、data classのリストを書き込むためには、フィールド一つ一つを列として定義し、それらをListとしてまとめる必要があるということです。また、CSVには一般的にヘッダが含まれますが、&lt;code>List&amp;lt;List&amp;lt;Any?&amp;gt;&amp;gt;&lt;/code>の形だと最初の行にヘッダのみを定義した行は必要となることでもありますね。&lt;/p>
&lt;p>一見複雑に見えますが、&lt;a class="link" href="https://kotlinlang.org/docs/reflection.html" target="_blank" rel="noopener"
>reflection&lt;/a>を利用すると、data classのフィールド名とその値を得ることができますので、それを利用してdata classのListをこのメソッドに適した形に変えられます。これをヘッダを作る方法と、data classの値を行に変更する二つの段階で分けて説明していきます。&lt;/p>
&lt;h3 id="data-classからヘッダを作る">data classからヘッダを作る
&lt;/h3>&lt;p>まずはヘッダを作ります。ヘッダを作るには、data classからフィールドを取得し、そのフィールドの名前のみを取得するといいでしょう。&lt;code>id&lt;/code>というフィールドがあるとしたら、ヘッダもそのまま&lt;code>id&lt;/code>になるということです。フィールド名とは別の名前をつけたい場合はアノテーションを活用する方法を考えられますが、まずはフィールド名をそのまま使う方法から述べたいと思います。&lt;/p>
&lt;p>Kotlinのdata classから、フィールドを取得する方法が3つがあります。まずは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/members.html" target="_blank" rel="noopener"
>KClass.members&lt;/a>があります。ただ、これだとメソッドを含め、全てのメンバーを持ってくることになります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> members = Data&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.members
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(members)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String, fun Line_2.Data.component1(): kotlin.Int, fun Line_2.Data.component2(): kotlin.String, fun Line_2.Data.copy(kotlin.Int, kotlin.String): Line_2.Data, fun Line_2.Data.equals(kotlin.Any?): kotlin.Boolean, fun Line_2.Data.hashCode(): kotlin.Int, fun Line_2.Data.toString(): kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>フィールド名が現れているのでこれも使える方法の一つではありますが、やはりdata classだと基本的に&lt;code>equals()&lt;/code>, &lt;code>hashCode()&lt;/code>, &lt;code>copy()&lt;/code>, &lt;code>toString()&lt;/code>, &lt;code>componentN()&lt;/code>のようなメソッドが
できてしまうので、これらをフィルタする必要があります。例えば、以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> memberProperties = Data&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.members.filterNot { &lt;span style="color:#66d9ef">it&lt;/span>.name.contains(&lt;span style="color:#e6db74">&amp;#34;component&amp;#34;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;copy&amp;#34;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;equals&amp;#34;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hashCode&amp;#34;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;toString&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(memberProperties)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、フィルタをしなくてももっと簡単にフィールドのみを抽出できる方法もあります。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/member-properties.html" target="_blank" rel="noopener"
>memberProperties&lt;/a>を使うことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> memberProperties = Data&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(memberProperties)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法にも問題はあります。取得したフィールドの順番が、data classに定義した通りにならなく、アルファベット順になるということです。以下の例を見ると、nameとageの順で定義したフィールドが、ageとnameの順になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> name: String, &lt;span style="color:#66d9ef">val&lt;/span> age: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> memberProperties = Person&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(memberProperties) &lt;span style="color:#75715e">// name, age順にならない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [val Line_11.Person.age: kotlin.Int, val Line_11.Person.name: kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでどうしてもフィールドを定義した順に取得したい場合、data classのコンストラクタを使う方法があります。まずはコンストラクタを使った方法ですが、これはdata classに、自動的にコンストラクタがフィールドを定義した順番通りのパラメータを持つように生成されるということを利用した方法です。以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> parameters = Person&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.primaryConstructor&lt;span style="color:#f92672">!!&lt;/span>.parameters.mapNotNull { &lt;span style="color:#66d9ef">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(parameters) &lt;span style="color:#75715e">// [name, age]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多少強引な方法ではありますが、これでフィールドとして使うフィールド名は取得できました。では、次にアノテーションを使う場合を見ていきましょう。&lt;/p>
&lt;h4 id="アノテーションを使う場合">アノテーションを使う場合
&lt;/h4>&lt;p>フィールド名をそのままヘッダとして利用したくない場合は、アノテーションを活用できます。フィールドとしてStringを持つアノテーションを定義して、ヘッダを読み取るときにそのフィールドにつけたアノテーションを取得するという方法です。例えば、以下のようなアノテーションを定義したとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Target&lt;/span>(&lt;span style="color:#a6e22e">AnnotationTarget&lt;/span>.PROPERTY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">annotation&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CsvHeaderName&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>アノテーションは、以下のようにdata classで使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@CsvHeaderName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;名前&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@CsvHeaderName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;年齢&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> age: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてこのdata classのアノテーションを取得していきます。&lt;code>memberProperties&lt;/code>でフィールドを取得した場合、そのフィールドからアノテーションの一覧(アノテーションは複数存在できるので)を取得し、そこから先に定義した&lt;code>CsvHeaderName&lt;/code>のみをフィルタします。あとはアノテーションがあるかどうかをみて、どちらの値を使うかを決めればいいですね。以下のコードが、そのサンプルです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> datas = listOf(Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> headers = datas.first()&lt;span style="color:#f92672">!!::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.map { &lt;span style="color:#66d9ef">property&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name = &lt;span style="color:#66d9ef">property&lt;/span>.annotations.filterIsInstance&amp;lt;CsvHeaderName&amp;gt;().firstOrNull() &lt;span style="color:#75715e">// アノテーションはないケースもある
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> name&lt;span style="color:#f92672">?.&lt;/span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">property&lt;/span>.name &lt;span style="color:#75715e">// アノテーションがnullの場合は、フィールド名を使う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(headers) &lt;span style="color:#75715e">// [年齢, 名前]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>primaryConstructor&lt;/code>のパラメータで取得した場合でも、やり方は大きく変わりません。この場合は、コンストラクタのパラメータを基準にループしながら一致するフィールドを探すという処理が追加されるだけです。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> fieldNames = seeds.first()&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.primaryConstructor&lt;span style="color:#f92672">!!&lt;/span>.parameters.mapNotNull { &lt;span style="color:#66d9ef">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> headers = fieldNames.mapNotNull { name &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// パラメータと一致するフィールドを対象に処理を行う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> datas.first()&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.find { &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> name }&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">property&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> headerName = &lt;span style="color:#66d9ef">property&lt;/span>.annotations.filterIsInstance&amp;lt;CsvHeaderName&amp;gt;().firstOrNull()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headerName&lt;span style="color:#f92672">?.&lt;/span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">property&lt;/span>.name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで、ヘッダのデータはできました。次は、このヘッダに合わせて下に出力する行としてdata classをListに変換するのみですね。&lt;/p>
&lt;h3 id="data-classをlistに変える">data classをListに変える
&lt;/h3>&lt;p>ヘッダの処理で既にやっていたように、data classをListに変換する場合でも処理は大きく変わりません。違う点は、フィールドから実際のデータを取得するだけですね。ここでは、コンストラクタからパラメータを取得した場合を想定してコードを書きましょう。&lt;/p>
&lt;p>Kotlinのreflectionでフィールドの値を取得する場合はJavaと変わらなくて、取得したフィールドにdata classのインスタンスを渡すだけとなります。ただ、フィールドがnullの場合は考慮する必要があります。nullになってしまうと、その列自体がスキップされ、最終的に出力されたCSVのデータで列がずれる場合があるからです。なので、空白のStringを指定するなどで、行ごとの長さ(Listのサイズ)を合わせる必要があります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>datas.map { d &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fieldNames.mapNotNull { name &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.find { &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> name }&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">field&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span>.call(d) &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// フィールドの値を取得し、nullのばいは空白にする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここで時間や日付を扱う場合、フォーマッタを利用したいケースがあるかと思います。例えば、アプリの中では&lt;code>LocalTime&lt;/code>として扱っているが、CSVとしては&lt;code>HH:mm&lt;/code>のような形で出力したい場合や、&lt;code>LocalDate&lt;/code>を&lt;code>yy/MM/dd&lt;/code>にしたい場合などですね。ここでフォーマット自体は、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>を使うだけですが、問題は取得したフィールドがどの型であるかの判定です。&lt;/p>
&lt;p>Kotlinのreflectionで取得したフィールドは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property1/" target="_blank" rel="noopener"
>KProperty1&lt;/a>という型になっています。ここでどうやって元の型を取得するかが問題ですね。このクラスは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-callable/" target="_blank" rel="noopener"
>KCallable&lt;/a>というインタフェースを実装していて、ここには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-callable/return-type.html" target="_blank" rel="noopener"
>returnType&lt;/a>というプロパティがあります。これで&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-type/" target="_blank" rel="noopener"
>KType&lt;/a>というインタフェースが取得できるようになるので、これを持って判定をおこ泣くことになります。&lt;/p>
&lt;p>しかし、名前から分かるように、&lt;code>KType&lt;/code>はKotlinの型に関するインタフェースとなっています。比較したい&lt;code>LocalDate&lt;/code>や&lt;code>LocalTime&lt;/code>などのクラスはJavaのものなので、直接的な比較ができないですね。幸い、JavaのクラスでもKotlinで参照できる&lt;code>Ktype&lt;/code>として変換することはできます。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> localDateKType: KType = LocalDate&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、あとは分岐によって適切なフォーマッタを使うだけですね。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>datas.map { d &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fieldNames.mapNotNull { name &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.find { &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> name }&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">field&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span>.call(d)&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">field&lt;/span>.returnType) { &lt;span style="color:#75715e">// タイプによる分岐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> LocalDate&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> dateFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> timeFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalDateTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> dateTimeFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalDateTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここでもう一つ注意しなければならないのは、nullableなフィールドのKTypeは別のものになるということです。つまり、上記のコードでは、以下のようなdata classのフィールドは分岐処理でフォーマッタが働かなくなるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// どのフィールドもフォーマットされない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DateTimes&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> date: LocalDate?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> time: LocalTime?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> dateTime: LocalDateTime?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合は、&lt;code>KType&lt;/code>を作るときにnullableであることを指定することで簡単に解決できます。あとは分岐で、両方チェックするようにするだけです。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>datas.map { d &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fieldNames.mapNotNull { name &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.find { &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> name }&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">field&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span>.call(d)&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">field&lt;/span>.returnType) { &lt;span style="color:#75715e">// nullableでもnullableではない場合でも分岐でフォーマットする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> LocalDate&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(), LocalDate&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(nullable = &lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> dateFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(), LocalTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(nullable = &lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> timeFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalDateTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(), LocalDateTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(nullable = &lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> dateTimeFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalDateTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは、ヘッダと、data classから取得した値のリストを結合して&lt;code>kotlin-csv&lt;/code>の&lt;code>writeAll()&lt;/code>に渡すだけですね。一つ、値は上記のコードで既に&lt;code>List&amp;lt;List&amp;lt;Any&amp;gt;&amp;gt;&lt;/code>の形となっていますが、ヘッダは&lt;code>List&amp;lt;String&amp;gt;&lt;/code>なので、ヘッダは更にListに入れる必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ヘッダ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> header = &lt;span style="color:#75715e">// 省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 実際のデータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> rows = datas.map { &lt;span style="color:#75715e">/** 省略 */&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>csvWriter().writeAll(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows = listOf(headers) + rows,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetFile = targetFile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでヘッダが先に行に書き込まれ、次の行からはdata classのフィールドに格納した実際の値が出力されることになりました。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>この度軽く「KotlinなんだからKotlin制のライブラリを使おう」と、軽い気持ちで採用したライブラリが想定していたものと違ったので困っていましたが、幸いJavaを使っていた時に&lt;a class="link" href="https://poi.apache.org/" target="_blank" rel="noopener"
>Apache POI&lt;/a>を使って似たような機能をするライブラリを作ってみた経験があったのでその知識を活かせたと言えます。当時はまだ駆け出しのエンジニア(今もそうと思っていますが)だったので大変苦労した思い出でもありますが、今はその経験があってこそ対処できたようなものなので大変ありがたい経験だったなと思いました。&lt;/p>
&lt;p>上記のコードに対してはちょっとしたライブラリを作ってみたので、またどこかで活用してみたいものですね。色々と改善して、のちにMaven Repositoryのようなところでも公開できるようになったらなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>SwiftUIを触ってみた〜その2〜</title><link>https://retheviper.github.io/posts/swift-ui-first-impression-2/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/swift-ui-first-impression-2/</guid><description>&lt;img src="https://retheviper.github.io/images/swift.webp" alt="Featured image of post SwiftUIを触ってみた〜その2〜" />&lt;p>前回に続いて、今回はSwiftUIを触りながら感じたことについて述べたいと思います。自分のように、今までバックエンドの実績しかないエンジニアがGUIを作るとしたら、画面のレイアウトや色合い、画面間の繊維など「今までなかった概念」で混乱することも多いかなと思います。そしてその中でも特に難しい、うまく扱えない機能などもあるかなと思います。&lt;/p>
&lt;p>自分の場合、プロダクションレベルのコードを書いたことはないものの、以前から&lt;a class="link" href="https://reactnative.dev/" target="_blank" rel="noopener"
>React Native&lt;/a>, &lt;a class="link" href="https://flutter.dev/" target="_blank" rel="noopener"
>Flutter&lt;/a>, &lt;a class="link" href="https://developer.android.com/jetpack/compose" target="_blank" rel="noopener"
>Jetpack Compose&lt;/a>には少し触れたことがあったためSwiftUIで「画面を構成する方式」については少し理解しているつもりでした。しかし、やはりバックエンドでは存在しない機能がありました。&lt;/p>
&lt;p>今回はそのSwiftUIの話となりますが、中でも私が注目した機能もしくは概念について述べたいと思います。&lt;/p>
&lt;h2 id="swiftui">SwiftUI
&lt;/h2>&lt;p>まずは、SwiftUIそのものに対して簡単に紹介しましょう。SwiftUIはいわゆる宣言型(Declarative)UIのフレームワークで、&lt;a class="link" href="https://ja.reactjs.org/" target="_blank" rel="noopener"
>React&lt;/a>や&lt;a class="link" href="https://vuejs.org/" target="_blank" rel="noopener"
>Vue&lt;/a>などのフロントエンドからの影響が見えます。要するに、画面を構成する要素(Widget, Component, Materialなどフレームワークやライブラリによって呼び方は様々ですが)を一つのオブジェクトとして「宣言」し、それらの要素の組み合わせによって一つの画面を完成するという形になっているということです。このような宣言型UIはSwiftUIだけでなく、モバイルに限定してもReact NativeやFlutter、Jetpack Composeなど様々なフレームワークやライブラリで採択しているものでもあります。&lt;/p>
&lt;p>そして、要素の実装についてもフレームワークやライブラリによって色々と方法が分かれますが、SwiftUIでは、個別の要素はViewといい、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"
>View&lt;/a>というprotocolをstructとして実装していきます。なので、一覧を表示する画面であれば、一つの行としてデータを表示するView、その行をリストとして表示するためのView、さらに一覧の上や下にメニューを表示するViewなどが一つ一つのstructとして定義されていく形ということです。&lt;/p>
&lt;p>このような画面の作り方は、フレームワークのパラダイム・コンセプトとして決まってあるものなので、それに従って実装を進めることには私のようにバックグラウンドが全く違うエンジニアでも特に問題はないかなと思います。&lt;/p>
&lt;p>ただ、実際のアプリを作るとしましょう。画面に対してはフレームワークで提示する通り要素を実装して作ったとしたら、アプリを実行してなんらかの処理を行うためにはバックエンドを繋げるか、アプリ内でなんらかの処理を行うかなど「ロジック」とつなげる必要があるはずです。ここで常にとは言い難いのですが、バックエンドでは見慣れない概念が出てくる場合があります。「状態」というものです。&lt;/p>
&lt;h2 id="状態">状態
&lt;/h2>&lt;p>バックエンドのアプリを実装している場合は、リクエストがあり、それに対してのレスポンス（HTTPステータスのみだとしても）がある、という明確なプロセスがありますね。この一連の処理には、「途中で変化する」という概念はありません。この場合のデータは永続化されるか、処理が終了するまでの一時的な物が多いです。&lt;/p>
&lt;p>しかし、画面の世界だと話は変わってきます。多くのモバイルアプリではスライダ、ボタン、テキストボックスなどいろいろな要素で構成されてあり、それらの要素に関する状態が常に変わってくるケースもあるのです。ファイルをダウンロードしている状態を表示するためのプログレスバーがあるとしたら、単純に進行状況を見せるとしたら一つのスレッドを割り当てて処理するだけで良いでしょう。&lt;/p>
&lt;p>ここで一つ、もしダウンロードに「一時停止」のような機能があったらどうでしょうか。プロセスが進行中にボタンを押下したら止まり、再度押下したら再開されるような機能です。他にも色々と考慮すべきものはあるかと思いますが、この「停止している」「再開した」という概念をどこかに記憶しておく必要はあるでしょう。つまり、画面においてのユーザの入力に対して、なんらかの処理を実際に行うまで記憶しておくための機構が必要ということですね。&lt;/p>
&lt;p>SwiftUIでももちろん、状態を管理するためのものがあります。ただ、ユースケースで考えると画面の要素(View)一つに限って必要なものか、それとも複数の要素において必要なものか、複数の画面（アプリ全体）にかけて必要なものかという、スコープによって必要な状態は違うものになります。View一つで必要なものをアプリ全体で管理する必要もなければ、複雑になりがちだからですね。なので、ここではそのスコープ別に状態を管理するためにどんなものがあるのかについて述べていきたいと思います。&lt;/p>
&lt;h3 id="個別viewの状態">個別Viewの状態
&lt;/h3>&lt;p>まずは最も小さい単位、Viewの場合です。先に述べた、一覧の画面が良い例になりそうですね。Appleのチュートリアルでは、以下のような一覧の画面を作ることになります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list.webp"
width="860"
height="1756"
srcset="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list_hu_1c7ca1e08ae2c8c0.webp 480w, https://retheviper.github.io/posts/swift-ui-first-impression-2/view_list_hu_8ffacc504fdf94ab.webp 1024w"
loading="lazy"
alt="List View"
class="gallery-image"
data-flex-grow="48"
data-flex-basis="117px"
>&lt;/p>
&lt;p>この画面では右上のボタンを押すことで、一覧に表示するアイテムをフィルタリングできる機能があります。たとえば一部の行にハートマークがついてありますが、これは「お気に入り」を意味していて、そのお気に入りとして登録したものだけをフィルタするか、アイテムのカテゴリでフィルタするかなどの機能が入っています。&lt;/p>
&lt;p>そしてこの画面では、「フィルタするカテゴリ」や「お気に入りだけを表示する」を状態として扱っていますが、この状態は他の画面では知る必要がないデータとなっています。この場合に使えるのが、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/state" target="_blank" rel="noopener"
>@State&lt;/a>です。コードとしては、以下のようになっています。(一部省略)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 一覧画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// お気に入りだけを表示するかどうか&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> showFavoritesOnly = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィルタするカテゴリ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> filter = FilterCategory.all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// カテゴリの種類&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">FilterCategory&lt;/span>: String, CaseIterable, Identifiable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> all = &lt;span style="color:#e6db74">&amp;#34;ALL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> lakes = &lt;span style="color:#e6db74">&amp;#34;Lakes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> rivers = &lt;span style="color:#e6db74">&amp;#34;Rivers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> mountains = &lt;span style="color:#e6db74">&amp;#34;Mountains&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> id: FilterCategory { &lt;span style="color:#66d9ef">self&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// アイテムにフィルタを適用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> filteredLandmarks: [Landmark] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modelData.landmarks.filter { landmark &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">!&lt;/span>showFavoritesOnly &lt;span style="color:#f92672">||&lt;/span> landmark.isFavorite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (filter == .all &lt;span style="color:#f92672">||&lt;/span> filter.rawValue == landmark.category.rawValue )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NavigationView {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// アイテムの表示部&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(selection: &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>selectedLandmark) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(filteredLandmarks) { landmark &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NavigationLink {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkDetail(landmark: landmark)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkRow(landmark: landmark)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toolbar {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ToolbarItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ツールバーにフィルタを適用するためのボタンを追加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Menu {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 選択できるカテゴリ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Picker(&lt;span style="color:#e6db74">&amp;#34;Category&amp;#34;&lt;/span>, selection: &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>filter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ForEach(FilterCategory.allCases) { category &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Text(category.rawValue).tag(category)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .pickerStyle(.inline)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// お気に入りだけを表示するかどうかのトグル&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Toggle(isOn: &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>showFavoritesOnly) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#e6db74">&amp;#34;Favorites only&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#e6db74">&amp;#34;heart.fill&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } label: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#e6db74">&amp;#34;Filter&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#e6db74">&amp;#34;slider.horizontal.3&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、一つのViewにおいて状態を管理するためには、&lt;code>@State&lt;/code>を使うことになります。&lt;/p>
&lt;h3 id="親子関係のviewが共有する状態">親子関係のViewが共有する状態
&lt;/h3>&lt;p>さて、一つのViewでの状態を管理することはできましたが、次に気になるのは複数のView、特に親子関係になるView間でどうやって状態を共有できるかです。たとえば先ほどの一覧画面だと、一つ一つの行がViewになっているものなのですが、&lt;/p>
&lt;p>実は、親のViewから子Viewに状態を渡すというのは、すでに先ほどのコードに表れています。「お気に入りだけを表示するかどうか」のトグルがあるのですが、ここで&lt;code>isOn&lt;/code>に親の状態を渡していますね。ただ、トグル時の挙動を&lt;code>@State&lt;/code>で定義したBooleanと結びつけるために&lt;code>isOn&lt;/code>として渡す際、&lt;code>$&lt;/code>をつけることに注目する必要があります。&lt;code>$&lt;/code>をつけることで、Booleanではなく、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/binding" target="_blank" rel="noopener"
>&lt;code>Binding&amp;lt;Boolean&amp;gt;&lt;/code>&lt;/a>という形でプロパティを渡すことになります。こうしてラッパーを渡すことで、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/toggle/" target="_blank" rel="noopener"
>Toggle&lt;/a>の中でも親の状態を変更できるようになります。&lt;code>Toggle&lt;/code>は確かに一覧の画面とは別のViewになりますが、押下するたびに親の状態である&lt;code>showFavoritesOnly&lt;/code>の値が変わるということです。&lt;/p>
&lt;p>後でまた関連したポストを書きたいと思いますが、Jetpack Composeでも何となく似たような形で状態の管理ができる方法があります。例えば、&lt;code>@State&lt;/code>のように簡単な状態を管理するためには以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// true/falseの状態
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> toggle: Boolean &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#66d9ef">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> toggle {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;On!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toggle = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Off!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toggle = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のような書き方はいわゆる&lt;a class="link" href="https://kotlinlang.org/docs/delegation.html" target="_blank" rel="noopener"
>Delegation&lt;/a>によるもので、&lt;code>mutableStateOf&amp;lt;T&amp;gt;&lt;/code>が返すのは&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState" target="_blank" rel="noopener"
>&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>&lt;/a>ですが、&lt;code>by&lt;/code>を使うことで実際は&lt;code>Boolean&lt;/code>そのものを扱うようになります。&lt;/p>
&lt;p>そして&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>を分解し、以下のように状態と、状態を変化させる処理の処理を指定することもできます。これもまた、先ほどの&lt;code>Binding&lt;/code>のような役割をするようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// テキストの状態と値の変更
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>content: String, onValueChange: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// テキストフィールドに状態を表示し、変化があった場合は状態を変更させる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>TextField(&lt;span style="color:#66d9ef">value&lt;/span> = content, onValueChange = onValueChange)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやって他の要素に状態の変更を可能にするためには、基本的にその状態をラップしているオブジェクトを利用するという考えは、SwiftUIでもJetpack Composeでも一緒のようです。ただ、&lt;code>$&lt;/code>というキーワードを使ってラッパーにアクセスできるSwiftと、状態のオブジェクトをどうやって宣言するかを考える必要のあるKotlinの違いがまた面白いポイントです。&lt;/p>
&lt;h3 id="アプリ全体で共有する状態">アプリ全体で共有する状態
&lt;/h3>&lt;p>さて、次はもっと大きい単位としての状態について述べたいと思います。アプリの画面は色々とあり、仲には親子の関係ではない場合もあります。Appleのチュートリアルのアプリをまたの例としてあげますと、以下のように、タブが分かれている場合が代表的なものと言えるかもしれません。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu.webp"
width="732"
height="1466"
srcset="https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu_hu_ad810ee18d225a12.webp 480w, https://retheviper.github.io/posts/swift-ui-first-impression-2/view_menu_hu_bf40d4aa3c0c0ae2.webp 1024w"
loading="lazy"
alt="Menu View"
class="gallery-image"
data-flex-grow="49"
data-flex-basis="119px"
>&lt;/p>
&lt;p>ここで、下にある「Featured」や「List」をタッチすることにより表示される画面が変わるわけですが、この二つの画面は親子といえる関係ではありません。以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ContentView&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> selection: Tab = .featured
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Tab&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> featured
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// タブメニュー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TabView(selection: &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>selection) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Featured画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CategoryHome()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tabItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#e6db74">&amp;#34;Featured&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#e6db74">&amp;#34;star&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tag(Tab.featured)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// LandmarkList画面&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tabItem {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Label(&lt;span style="color:#e6db74">&amp;#34;List&amp;#34;&lt;/span>, systemImage: &lt;span style="color:#e6db74">&amp;#34;list.bullet&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .tag(Tab.list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要件によっては、この対等な関係にある画面間でも状態を共有する必要はあります。たとえば、ショッピングのアプリを作るとしたら、自分のアカウントの画面を開いている場合でもカートに入れている商品の情報は維持される必要がありますね。このように、現在表示している画面とは関係なく、アプリ全体で共有する状態が必要な場面があります。&lt;/p>
&lt;p>この場合は、どうしたらいいでしょうか？もちろん、起点となるViewがあるので、そこに&lt;code>@State&lt;/code>を定義しておくというのも一つの方法かもしれません。ただ、状態として管理したい項目が増えれば増えるほど複雑になりがちですね。起点のViewには複数の&lt;code>@State&lt;/code>が必要となり、画面ごとにそれらを渡す必要があります。だとすると、やはり一つのオブジェクトに状態をまとめて置いて使いまわしたいものです。&lt;/p>
&lt;p>Appleのチュートリアルでもそれを提示していて、画面間で共有するデータとしてLandmarkのデータと、ユーザのプロフィールをまとめて共有できるオブジェクトとして提供する方法があります。まずは、以下がその状態のオブジェクトのコードとなります。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ModelData&lt;/span>: ObservableObject {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> landmarks: [Landmark] = load(&lt;span style="color:#e6db74">&amp;#34;landmarkData.json&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @Published &lt;span style="color:#66d9ef">var&lt;/span> profile = Profile.&lt;span style="color:#66d9ef">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでアプリ内でLandmarkの情報はjsonから読み取ったものとなっていて、プロフィールはEnumとなっています。そして&lt;a class="link" href="https://developer.apple.com/documentation/combine/observableobject" target="_blank" rel="noopener"
>ObservableObject&lt;/a>というプロトコールが使われているのが見えますね。&lt;code>ObservableObject&lt;/code>を使うことで、このModelDataというクラスは変更される状態を保持し、値の変更があった場合はそれを参照する画面に通知する&lt;code>Publisher&lt;/code>として機能することになります。そしてそれぞれの状態となるプロパティについては、&lt;a class="link" href="https://developer.apple.com/documentation/combine/published" target="_blank" rel="noopener"
>@Published&lt;/a>をつけることで状態として指定することになります。&lt;/p>
&lt;p>こうして状態を保持するためのオブジェクトを定義したら、次はアプリ内でどうやって使用するかですね。チュートリアルでは、以下のようにアプリのメインとなるstructに以下のように定義しています。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>@main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarksApp&lt;/span>: App {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ModelDataを状態のオブジェクトとして宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @StateObject &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> modelData = ModelData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> body: some Scene {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WindowGroup {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ContentView()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .environmentObject(modelData) &lt;span style="color:#75715e">// メイン画面に状態オブジェクトを渡す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードでわかるように、アプリでは定義しておいた状態オブジェクトを&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/stateobject" target="_blank" rel="noopener"
>@StateObject&lt;/a>をつけて、メイン画面に渡すことで使うようになります。ちなみにこうやって&lt;code>View&lt;/code>として定義された画面にならどんなものでも&lt;code>environmentObject()&lt;/code>に状態オブジェクトを渡すことができるので、画面の一部だけをプレビューとして表示する場合でも、プレビューに表示する画面に状態オブジェクトを渡すことで動作を試すこともできます。例えば、先ほどのLandmarkの一覧画面のプレビューだと、以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarkList_Previews&lt;/span>: PreviewProvider {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> previews: some View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .environmentObject(ModelData()) &lt;span style="color:#75715e">// 状態オブジェクトを渡す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうして状態オブジェクトを画面に渡したら、中では使うだけです。&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/environmentobject" target="_blank" rel="noopener"
>@EnvironmentObject&lt;/a>というアノテーションを使って、状態を持つオブジェクトを宣言するだけで自動的にオブジェクトはDIされ、その画面で使えるようになります。また一覧の画面の話となりますが、以下のコードを見てください。&lt;code>landmarks&lt;/code>のデータを使って一覧を表示しているのがわかります。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 状態オブジェクト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @EnvironmentObject &lt;span style="color:#66d9ef">var&lt;/span> modelData: ModelData
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 状態オブジェクトからデータを取り出しフィルタを適用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> filteredLandmarks: [Landmark] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modelData.landmarks.filter { landmark &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#f92672">!&lt;/span>showFavoritesOnly &lt;span style="color:#f92672">||&lt;/span> landmark.isFavorite)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (filter == .all &lt;span style="color:#f92672">||&lt;/span> filter.rawValue == landmark.category.rawValue )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、Jetpack Composeの場合はこのような方法ではなく、オブジェクトそのものを&lt;code>remember&lt;/code>するように使うようです。例えば以下のような形になります。そもそも要素を作成するアプローチが違うのが理由の一つなのかもしれませんね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// アプリ全体で共有する状態
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ApplicationState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> environment: MutableState&amp;lt;Environment&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> hash: MutableState&amp;lt;String&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 状態の初期化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@Composable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">rememberApplicationState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> environment: MutableState&amp;lt;Environment&amp;gt; = mutableStateOf(&lt;span style="color:#a6e22e">Environment&lt;/span>.PRODUCTION),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hash: MutableState&amp;lt;String&amp;gt; = mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): ApplicationState {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> remember(environment, hash) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ApplicationState(environment, hash)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 状態の定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> appState = rememberApplicationState()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="永続化できる状態">永続化できる状態
&lt;/h3>&lt;p>今までの状態は、アプリが実行中のみ有効なものでした。それだけでも十分な場合もありますが、場合によっては状態を永続化したい場合もあるでしょう。例えば、学習用のアプリだとしたらどこまで進行したかなどを保存しておきたいかなと思います。このような種のデータは、アプリを再起動しても変わらないことを期待しますね。&lt;/p>
&lt;p>もちろん、この場合のためにDBがあり、ネットワーク機能のあるアプリならサーバ側にデータを保存したりするでしょう。ただ、この場合は「状態」とは言えないものですね。なぜなら、状態は画面の更新を伴うものだからです。画面をタッチした回数を、画面に表示しながら同時に保存しておきたい場合は毎回DBの更新と参照で実装したくない場合もあるかなと思います。そこで使えるのが、&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/appstorage" target="_blank" rel="noopener"
>@AppStorage&lt;/a>です。これを使うことで、画面の更新と永続化を同時に行うことができます。&lt;/p>
&lt;p>また、チュートリアルによると、いくつかデフォルトとして保存されているデータに関してもこのアノテーションでアクセスできるようにになっています。一覧画面に表示される「お気に入り」ボタンの例ですが、ボタンのアイコンを&lt;code>@AppStorage&lt;/code>から参照するようになっています。コードは以下です。（一部省略）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">FavoriteButton&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ボタンはハートのアイコンとして表示する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @AppStorage(&lt;span style="color:#e6db74">&amp;#34;Favorite.iconType&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> iconType: IconType = .heart
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたか。自分の感想としては、やはり今まで自分が触れてきた分野とは全く違う概念やアプローチが多かったので、大変興味深いと思いつつ、「これであっているのか」という疑問もかなり湧いてくるような経験となっています。全く経験のない分野に足を踏み入れるのは常にそういうものなのかもしれませんが。&lt;/p>
&lt;p>ただこれで、ある程度アプリを作る場合にどうやって処理を行うべきかについての疑問の一つは解けたような気がします。本当は画面を作る分、他にも色々と新しい概念が出てきたり、画面のレイアウトやUXの観点で色々と難しいものが出てくるかもしれませんが、とにかく「動く」ものを作れそうな気はしますね。何卒自分のようにバックエンドのみを経験してきた形にとって参考できるような記事となっていればと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>SwiftUIを触ってみた〜その1〜</title><link>https://retheviper.github.io/posts/swift-ui-first-impression-1/</link><pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/swift-ui-first-impression-1/</guid><description>&lt;img src="https://retheviper.github.io/images/swift.webp" alt="Featured image of post SwiftUIを触ってみた〜その1〜" />&lt;p>今までの自分のキャリアを振り返ってみると、仕事としての経験はバックエンドばかりで、画面側の実装にはあまり関わったことがありません。しかし、スタンドアロンのアプリを作るためには、ウェブ・モバイル・デスクトップを問わず画面が必要となるので、いつかは画面側の実装もできるようになる必要があるかなと常に思っているところです。&lt;/p>
&lt;p>画面を作るといっても、どんな分野のエンジニアとしてキャリアパスを考えているか、どのような企業で働きたいか、慣れている言語は何であるかなど色々と考慮すべき要素は多いのですが、自分の場合はKotlinに慣れているのもあり、ウェブ・モバイル・デスクトップアプリに全部対応できるという点から&lt;a class="link" href="https://www.jetbrains.com/lp/compose-mpp" target="_blank" rel="noopener"
>Jectpack Compose&lt;/a>を、また普段からMacとiPhone、iPadといったApple社の製品をよく使っている上、KotlinからのSwift入門が比較的簡単ということで&lt;a class="link" href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener"
>SwiftUI&lt;/a>を勉強したいと思っています。&lt;/p>
&lt;p>さて、言語とフレームワークを決めてからは実践ですね。&lt;a class="link" href="https://developer.apple.com/tutorials/swiftui" target="_blank" rel="noopener"
>公式のチュートリアル&lt;/a>が充実していたので、まずはこちらの方をすすめながら感じたSwiftやSwiftUIで印象的だった部分についてまとめてみたいと思います。もちろん、自分は仕事としてモバイルアプリの実装に関わったことがないのでコンテンツとしては粗末なものとなるかなと思いますが、もし自分のようにKotlinのバックグラウンドからSwiftに触れてみようと思っている方や、バックエンドのみのキャリアからGUIに初めて触れる方、もしくはKotlinとSwiftのどちらかに興味を持っている方には参考になる内容となればと思います。&lt;/p>
&lt;h2 id="swift">Swift
&lt;/h2>&lt;p>まずは言語そのものから。KotlinとSwiftはよく似ているという話を聞くことがありますが、正確に「どこが」というのはやはり触れてみる前はわからないものです。似ているという表現は共通点があるという意味なので、何に基準を置くかによって挙げられる共通点は色々と変わってくるものだからです。&lt;/p>
&lt;p>例えば、言語デザインの観点でOOP志向的で、関数型的な要素があり、GCが存在する、ということでも共通点は発見できます。もしくは、言語の使用としてキーワードや書き方の印象が似ているという意味にもなれますね。細かくは、セミコロンを使わなくて良いという点も挙げられますね。&lt;/p>
&lt;p>なので、まずは上記のチュートリアルを進行しながら、肌で感じた感覚から、Kotlinに比べたSwiftはどのようなものだったかを述べていきたいと思います。&lt;/p>
&lt;h3 id="kotlinに似ているもの">Kotlinに似ているもの
&lt;/h3>&lt;p>では、まずKotlinに似ているなと感じたところから述べていきます。似ているとしても、あくまで「肌の感触」なものなので、厳密には違う仕様になっているものも多いのですが、ここでの基準は「Kotlinでできたことをどれほど近い感覚で再現できるか」となっていますので（といっても個人的な感想ですが）、参考までに。&lt;/p>
&lt;h4 id="computed-properties">Computed properties
&lt;/h4>&lt;p>まず、プロパティの話からです。Kotlinではdata classを定義するとき、プロパティを以下のような二つの方法で定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> age: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> isAdult: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = age &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>age&lt;/code>はインスタンスを作成するときに固定される単純な値となりますが、&lt;code>isAdult&lt;/code>はgetterとして定義した処理(&lt;code>age&lt;/code>が18以上かどうかという)の結果を返すように定義する形ですね。このような処理を伴うプロパティは、Swiftでも同じく&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID259" target="_blank" rel="noopener"
>Computed Properties&lt;/a>を通じて定義することができました。同じような処理を行う場合、以下のように定義できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> age: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isAdult: Bool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> age &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだ一つしたあげてないのですが、これだけでもなんとなく「KotlinとSwiftが似ている」の意味が少しは見えてきた気がしますね。処理を伴うプロパティを扱える、という仕様がそうですが、型の定義もそうで、キーワードは少し違うけど大体似たような感覚でコードが読めるというところがそうです。&lt;/p>
&lt;p>ただ、やはり違う部分もありますね。data classに対して、SwiftはGoやRustのようにstructを使えるというところがそうかなと思います。もちろんSwiftにもClassはあるので、目的によってどれかを選ぶようになるらしいです。という面では、またなんとなくKotlinでdata classとclassを分けて使うという点と似ているような気もしますね。&lt;/p>
&lt;h4 id="extension">Extension
&lt;/h4>&lt;p>次は、拡張です。Kotlinではオブジェクトについて、そのオブジェクトの外にメソッドやプロパティを定義することができますね。これらを拡張関数や拡張プロパティと呼び、以下のように定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> Student.isUnderAge: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = age &amp;lt; &lt;span style="color:#ae81ff">18&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前このブログでも述べたことのある&lt;a class="link" href="https://www.amazon.co.jp/dp/B08WXCRVD2/ref=dp-kindle-redirect?_encoding=UTF8&amp;amp;btkr=1" target="_blank" rel="noopener"
>Effective Kotlin&lt;/a>で提示されている活用方法ですが、ユースケースやドメインによって違う処理が必要となった場合は、class内に全てのメソッドやプロパティをを定義するよりはこのような拡張を使って、パッケージごとに定義することでアクセス制限を設ける方法があります。&lt;/p>
&lt;p>同じようなことがSwiftでもできますが、書き方はやはり少し違いました。上記のようなプロパティをSwiftで同じ方法で実装する場合、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extension&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isUnderAge: Bool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> age &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにSwiftには&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Extensions.html" target="_blank" rel="noopener"
>Extension&lt;/a>が別途キーワードとして存在していて、新しくclassやstructを定義するかのような感覚で関数やプロパティを付け加えることができます。個人的な感想としてはRustの&lt;a class="link" href="https://doc.rust-jp.rs/book-ja/ch05-03-method-syntax.html" target="_blank" rel="noopener"
>メソッド&lt;/a>と似ている形で、一つの&lt;code>extension&lt;/code>の中にまとめられるところがむしろKotlinより整頓された感覚なので良さげですね。Kotlinの場合、一つのオブジェクトに対しての拡張が複数あると少し汚くも見えるので…&lt;/p>
&lt;h4 id="string-interpolation">String Interpolation
&lt;/h4>&lt;p>Javaの場合でもそうで、多くの言語では文字列と、違う変数として格納してある値を一つの文字列にまとめる場合は&lt;code>format()&lt;/code>を使うか、文字列に変換して結合するケースが多いかなと思います。Kotlinでもそのような使い方はもちろんできますが、&lt;a class="link" href="https://kotlinlang.org/docs/basic-types.html#string-templates" target="_blank" rel="noopener"
>String template&lt;/a>があるので、簡単に文字列の中で違う値を埋め込むことができます。例えば以下のようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> world = &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(&lt;span style="color:#e6db74">&amp;#34;Hello, &lt;/span>&lt;span style="color:#e6db74">$world&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Swiftでも&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html#ID292" target="_blank" rel="noopener"
>String Interpolation&lt;/a>があるので、同じことができます。少し書き方が変わっているのですが、機能的にはほぼ一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> world = &lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#34;Hello, &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>world&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="arguments">Arguments
&lt;/h4>&lt;p>Kotlinでは、関数のパラメータにデフォルト値を設定することで、簡単にオーバーロードを実現でき、そのパラメータが渡されてない場合の処理にも対応できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// timesに指定した数値分、stringを標準出力する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>(string: String, times: Int = &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(times) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello, &lt;/span>&lt;span style="color:#e6db74">$string&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// timesに値を指定しなくても関数を呼び出せる
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、どのパラメータに値を指定したいかを明確にするときや、関数に定義されたパラメータの順番に関係なく値を指定したい場合など色々な場面で&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>Named Arguments&lt;/a>を使うことができますね。例えば&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/join-to-string.html" target="_blank" rel="noopener"
>joinToString()&lt;/a>には&lt;code>separator&lt;/code>、&lt;code>limit&lt;/code>、&lt;code>truncated&lt;/code>など6つのパラメータがあるのですが、デフォルト値が指定されていて、Named Argumentsにより以下のような使い方が可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;D&amp;#34;&lt;/span>).joinToString(prefix = &lt;span style="color:#e6db74">&amp;#34;[&amp;#34;&lt;/span>, postfix = &lt;span style="color:#e6db74">&amp;#34;]&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Named ArgumentはKotlinにおいてはオプションで、基本的にはJava同様、関数に定義されてあるパラメータの順番に合わせて値を渡すだけでも問題ありません。しかし、Swiftではこれが逆になっていて、sturctのインスタンスを作る場合や関数を呼び出す場合は基本的にパラメータは基本的にNamed Argumentsのような形で渡す必要があります。これを&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID166" target="_blank" rel="noopener"
>Argument Label&lt;/a>と読んでいるそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>(string: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>string&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(string: &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// Function Argument Labelでstringを指定&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、これもKotlinと同様、デフォルト値を指定することができ、その場合はパラメータを省略することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>(string: String, times: Int = &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> count = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">repeat&lt;/span> { &lt;span style="color:#75715e">// Kotlinのdo-whileループ的なもの&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>string&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (count &lt;span style="color:#f92672">&amp;lt;=&lt;/span> times)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(string: &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// timesを省略している&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、アンダースコアを使うことでArgument Labelを省略できるようにもなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">printHello&lt;/span>(&lt;span style="color:#66d9ef">_&lt;/span> string: String, times: Int = &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> count = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">repeat&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>string&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (count &lt;span style="color:#f92672">&amp;lt;=&lt;/span> times)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printHello(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// stringを省略&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>関数を定義する側からしたらあまり似ていないような気もするのですが、呼び出す側としてはかなり似たような形でコードが書けるのが特徴的かなと思います。&lt;/p>
&lt;h4 id="range">Range
&lt;/h4>&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html#:~:text=values%20using%20the-,rangeTo%28%29,-function%20from%20the" target="_blank" rel="noopener"
>rangeTo()&lt;/a>を使って、簡単に数値の範囲を定義することができます。この関数は&lt;a class="link" href="https://kotlinlang.org/docs/keyword-reference.html#operators-and-special-symbols" target="_blank" rel="noopener"
>operator&lt;/a>として定義されているので、&lt;code>..&lt;/code>で簡単に使えます。こうやって定義したRangeでは、最小値と最大値の取得や、Listに変換するなど色々なことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Rangeの定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> min = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> max = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> range = min&lt;span style="color:#f92672">..&lt;/span>max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 最小値と最大値の取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(range.start) &lt;span style="color:#75715e">// 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(range.endInclusive) &lt;span style="color:#75715e">// 20
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RangeをListにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> intList = range.toList() &lt;span style="color:#75715e">// [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Swiftでも&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html#ID73" target="_blank" rel="noopener"
>Range Operator&lt;/a>を使って範囲を定義することができます。こちらも形は似ていて、&lt;code>...&lt;/code>となります。ドットの数がKotlinより一つ多いという点を除くと全く同じ感覚で、最小値と最大値もまた名前が違うだけでプロパティとして取得できるという点もまた一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Rangeの定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> min = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> max = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> range = min...max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 最小値と最大値の取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(range.lowerBound) &lt;span style="color:#75715e">// 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(range.upperBound) &lt;span style="color:#75715e">// 20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RangeをArrayにする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> array = Array(range) &lt;span style="color:#75715e">// [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記のコードを見ると気付きにくいところですが、Range実装については両言語での扱いが少し違うところがあります。Kotlinでは&lt;code>rangeTo()&lt;/code>の戻り値が、元の値の型に合わせて&lt;code>InteRange&lt;/code>や&lt;code>LongRange&lt;/code>のようなものとなっていて、最小値と最大値をプロパティで取得する場合も&lt;code>rangeTo&lt;/code>に渡された二つの値の型と一緒です。&lt;/p>
&lt;p>しかし、Swiftの&lt;a class="link" href="https://developer.apple.com/documentation/swift/range" target="_blank" rel="noopener"
>Range&lt;/a>は&lt;code>Range&amp;lt;Bound&amp;gt;&lt;/code>という型で、当然Rangeから取得できる最小値や最大値も&lt;a class="link" href="https://developer.apple.com/documentation/swift/rangeexpression/bound/" target="_blank" rel="noopener"
>Bound&lt;/a>の型となっています。IntやLongとはまた別の型になるので、場合によっては注意して使う必要があるかもしれません。&lt;/p>
&lt;h3 id="swiftだけのもの">Swiftだけのもの
&lt;/h3>&lt;p>今まではKotlinユーザの観点から、Kotlinとどれだけ同じ感覚でコードを書けるか、ということを述べていましたが、ここからは少し間隔が違うなと思ったところを少しまとめてみようと思います。&lt;/p>
&lt;h4 id="メソッドプロパティコールでの省略">メソッド・プロパティコールでの省略
&lt;/h4>&lt;p>Kotlinでは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply()&lt;/a>のように自分自身を指しているのが明確な場合、&lt;code>this&lt;/code>を省略することができます。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> age: Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> studentA = Student(name = &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>).apply { age = &lt;span style="color:#ae81ff">18&lt;/span> } &lt;span style="color:#75715e">// Student(name=A, age=18)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、&lt;code>this&lt;/code>を使う場合か、明確に対象importしているなど特定のケースを除くとKotlinでは基本的に&lt;code>Class.method()&lt;/code>のような形でどのクラスのメンバを呼び出しているかを表記するのが原則ですね。&lt;/p>
&lt;p>しかし、Swiftの場合は少し状況が違います。もっとゆるい感じで、コンパイラを基準に対象が明確であれば、&lt;code>.method()&lt;/code>のような形で省略できるような感覚です。以下はSwiftUIのチュートリアルで提示しているコードの一部を抜粋したものですが、&lt;code>filter&lt;/code>が&lt;code>FilterCategory&lt;/code>というenumであるため、&lt;code>.all&lt;/code>という形で三項演算子の中で使われていることを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">LandmarkList&lt;/span>: View {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @State &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> filter = FilterCategory.all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">FilterCategory&lt;/span>: String, CaseIterable, Identifiable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> all = &lt;span style="color:#e6db74">&amp;#34;ALL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> lakes = &lt;span style="color:#e6db74">&amp;#34;Lakes&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> rivers = &lt;span style="color:#e6db74">&amp;#34;Rivers&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> mountains = &lt;span style="color:#e6db74">&amp;#34;Mountains&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> id: FilterCategory { &lt;span style="color:#66d9ef">self&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> title: String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> title = filter == .all ? &lt;span style="color:#e6db74">&amp;#34;Landmarks&amp;#34;&lt;/span> : filter.rawValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> showFavoritesOnly ? &lt;span style="color:#e6db74">&amp;#34;Favorite &lt;/span>&lt;span style="color:#e6db74">\(&lt;/span>title&lt;span style="color:#e6db74">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> : title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="protocol">Protocol
&lt;/h4>&lt;p>Swiftでは&lt;a class="link" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" target="_blank" rel="noopener"
>Protocol&lt;/a>というものがあり、JavaやKotlinのinterfaceと大体同じ感覚で使えます。ここまでだとあまり差はないように思いますが、実際にはstructやclass、enumなどを定義するときには、必要に応じでprotocolを採用(adopt)する必要があるというところが体験できる違いかなと思います。&lt;/p>
&lt;p>例えば、Kotlinで一つのdata classを定義するとしたら、以下のようなメンバが自動て追加されます。&lt;/p>
&lt;ul>
&lt;li>equals()&lt;/li>
&lt;li>hashCode()&lt;/li>
&lt;li>toString()&lt;/li>
&lt;li>componentN()&lt;/li>
&lt;li>copy()&lt;/li>
&lt;/ul>
&lt;p>しかし、Swiftのstruct, class, enumなどにはこのようなメンバは基本的に追加されません。なので、必要なメンバがあればそれに関するprotocolを採用し、実装する必要があります。例えばハッシュ値が使いたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/hashable" target="_blank" rel="noopener"
>Hashable&lt;/a>、
Jsonなどに変換するためには&lt;a class="link" href="https://developer.apple.com/documentation/swift/codable" target="_blank" rel="noopener"
>Codable&lt;/a>、Listでループしたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/identifiable" target="_blank" rel="noopener"
>Identifiable&lt;/a>、enumの全ケースを網羅してループしたい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/caseiterable" target="_blank" rel="noopener"
>CaseIterable&lt;/a>、同一化を比較したい場合は&lt;a class="link" href="https://developer.apple.com/documentation/swift/equatable" target="_blank" rel="noopener"
>Equatable&lt;/a>を採用するなどです。&lt;/p>
&lt;p>もちろんJavaやKotlinでも必要に応じてintefaceやannotationを使う必要はありますが、SwiftだとKotlinで気軽に使える機能がstructやclassなどを定義した時点では揃ってない可能性があるので、ここは気をつけるべきところですね。&lt;/p>
&lt;h4 id="some">some
&lt;/h4>&lt;p>Swiftでは少し変わった感覚のキーワードがあるます。そのキーワードの説明するために、まずは以下のようなprotocolとstructの定義があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protocol&lt;/span> &lt;span style="color:#a6e22e">Something&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">GoodThing&lt;/span>: Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">define&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s good thing!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようなコードがある場合、変数の型宣言や関数の戻り値で少し独特なキーワードを使うことができます。&lt;code>some&lt;/code>というものです。実際使う時は、以下のようなコードとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> good: some Something = GoodThing()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">returnSomething&lt;/span>() -&amp;gt; some Something {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> GoodThing()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これだけでは&lt;code>some&lt;/code>というキーワードが一体どんなものかわからないですね。ここでKotlinの概念を持ってくるとどうでしょうか。実は、Kotlinでもこれによく似た機能があります。&lt;code>&amp;lt;T extends Something&amp;gt;&lt;/code>です。KotlinやJavaの経験がある型ならこれで十分に何を意味しているかがしっくり来るかなと思います。&lt;/p>
&lt;p>つまり、&lt;code>some&lt;/code>はとあるprotocolを満足する何かしらのインスタンスを示すものです。Swiftではそれを満足するオブジェクトであってもprotocolを直接変数の型や関数の戻り値として定義して直接使うことはできない場合があります。その場合に&lt;code>some&lt;/code>を使うことで問題を回避できます。JavaやKotlinでinterfaceを使って、その具体的な実装は問わなく使うのと一緒だと言えます。このキーワードのおかげで、SwiftUIでは&lt;a class="link" href="https://developer.apple.com/documentation/swiftui/view" target="_blank" rel="noopener"
>View&lt;/a>を満足して入れば画面を構成するどんなコンポーネントとして扱えるようになります。&lt;/p>
&lt;p>ただ、interfaceを扱うのとは概念的に同じだとしても、コードを書く側の感覚としては全く違うのでここは注意しなければならないと思います。&lt;/p>
&lt;h4 id="compiler-control-statements">Compiler Control Statements
&lt;/h4>&lt;p>Swiftには&lt;a class="link" href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#ID538" target="_blank" rel="noopener"
>Compiler Control Statements&lt;/a>という仕様があり、コンパイル時の処理を指定できます。例えば、SwiftUIのチュートリアルでは一つのアプリを実装して、OSによって違う機能を実現するためにこれを利用しているケースがあります。以下がその例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// watchOSで起動する場合は、通知を使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#if&lt;/span> &lt;span style="color:#75715e">os&lt;/span>(&lt;span style="color:#75715e">watchOS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WKNotificationScene(controller: NotificationController.&lt;span style="color:#66d9ef">self&lt;/span>, category: &lt;span style="color:#e6db74">&amp;#34;LandmarkNear&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// macOSで起動する場合は、設定を使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#if&lt;/span> &lt;span style="color:#75715e">os&lt;/span>(&lt;span style="color:#75715e">macOS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Settings {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LandmarkSettings()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合もAndroidでアプリを実装する場合はこのような設定が必要になる場面もあるかもしれませんが、バックエンドの経験上ではコードによりコンパイラをコントロールするというケースはあまりなかったので、かなり新鮮な感覚でした。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたか。SwiftUIの話をするつもりが、Swiftのことだけでかなりの量になってしまったので、SwiftUIについては次のポストで述べようかなと思っています。しかし、Swiftだけでもかなり興味深いところが多かったので、やはりチュートリアルを触ってみて色々な経験ができたので良い選択をしたかなと思います。&lt;/p>
&lt;p>また、やはりKotlinとSwiftがなんとなく似ている部分があるのは感覚的には確かなので、やはりどちらかの経験があると残りの片方への入門もしやすくなるのかなという感覚はあります。これは外国語の教育（自分の専攻です）でいうスキーマ、いわゆるバックグラウンドの知識ある故のことだろうなと思うと、少しうれしくもなりますね。やはりKotlinやってよかったなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Google Cloud認定Professional Cloud Developerについて</title><link>https://retheviper.github.io/posts/gcp-certification-professional-cloud-developer/</link><pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/gcp-certification-professional-cloud-developer/</guid><description>&lt;img src="https://retheviper.github.io/images/gcp.webp" alt="Featured image of post Google Cloud認定Professional Cloud Developerについて" />&lt;p>この度は&lt;a class="link" href="https://cloud.google.com/certification/cloud-developer" target="_blank" rel="noopener"
>Professional Cloud Developer&lt;/a>の資格を取得しました。去年は特に資格を取得してないので、久々の資格取得となります。今までは主にAWSを使っていたので関連した資格を取得するのが良いかなと思っていましたが、GCPのサービスがもっと知りたいというのもあり、AWSの資格と比べどう違うかも気になったための受験となります。&lt;/p>
&lt;p>前回もそうであったように、無事資格の取得ができましたので、今回のポストではどのように試験の準備をしたかなどについて簡単に述べたいと思います。&lt;/p>
&lt;h2 id="試験はどんな感じか">試験はどんな感じか
&lt;/h2>&lt;p>以前、&lt;a class="link" href="../aws-certification-associate-developer" >AWSの資格&lt;/a>に関する記事を書いたことがありますが、プロバイダが違ってもCloudというプラットフォームが提供するサービスの根本は変わらないので、試験もまたそのような感覚です。基本的にIaaSやPaaSのようなサービスの概念や、バックエンドサービスのクラウドでのデプロイと構成の経験があれば試験の準備はそう難しくないかなと感じました。&lt;/p>
&lt;p>受験は遠隔監視とオンサイト監視の二つを選べ、前者は自宅での受験、後者はテストセンターでの受験となります。自分の場合はオンサイト監視が平日しか選べなかったため遠隔監視を選んでいます。AWSの試験の時もそうでしたが、遠隔監視の場合は受験できる部屋の準備をきちんとする必要があります。準備に必要なものは&lt;a class="link" href="https://kryterion.force.com/support/s/article/Launching-your-Online-exam?language=en_US" target="_blank" rel="noopener"
>KRYTERIONのサイト&lt;/a>に明示されているので、事前にチェックした方が良いです。個人的にはこの要件に合わせて部屋を片付けるのもかなり大変なものだったので、オンサイト監視の方が楽だろうと思いました。&lt;/p>
&lt;p>遠隔監視での試験はKRYTERIONが提供する専用のブラウザを使って進行します。ブラウザが起動すると他のアプリは最小化され、外部モニタを繋いでいる場合はそのモニタの画面が黒くなります。私の場合はApple Silicon Macを使っているので互換性の方が気になりましたが、問題なく実行できました。&lt;a class="link" href="https://www.kryteriononline.com/systemcheck/#" target="_blank" rel="noopener"
>システムチェック&lt;/a>のサイトも提供しているので、自分のPCで受験できるかはこちらでも確認したほうが良いでしょう。また、生体認証情報の登録が必要となりますが、こちらは単純に写真を撮るだけです。当日は試験が始まる前に登録した生体認証を確認し、監視官の指示の元に部屋の様子を見せたり身分証明書を提示するなどの簡単な手続きがあります。&lt;/p>
&lt;p>他の資格の場合はその場や当日で結果がわかるケースも多かったかなと思いますが、GCPの資格は認定のメールが届くまで1週間ほどの時間がかかっています。満点や得点がわからないという特徴を踏まえて考えてみると、受験当時のさまざまな状況を考慮して総合的に判断するのではないかと思っています。受験専用のブラウザを使うことになっているので、おそらくキー入力やカメラの映像なども全部録画されていたのではないかと思います。&lt;/p>
&lt;h2 id="どうやって準備したか">どうやって準備したか
&lt;/h2>&lt;p>まずはUdemyから模擬試験を検索してみました。中には英語になっているものと日本語版がありますが、どれもレビューに書いてある通りで、実際のテストと比べ簡単な問題が多いです。自分の場合は5回分を提供する英語の方を4周してどれも8割以上の正解を記録しましたが、本番ではより難しい（模擬試験では問われてないものやより複雑な）問題が多かったため、これだけでは不十分と思いました。&lt;/p>
&lt;p>模擬試験は&lt;a class="link" href="https://docs.google.com/forms/d/e/1FAIpQLSc_67KaPnNwQrLZ7kuhw-aubz7gMAwY6DQwRJYcW0qlG-iajA/viewform" target="_blank" rel="noopener"
>公式の方&lt;/a>もあり、こちらは比較的に実際のテストに近い問題が多いので（こく一部ですが、ほぼそのままの問題もあります）こちらの方を問題で問われる各サービスのドキュメントを調べながら勉強した方が良いかなと思います。&lt;/p>
&lt;p>模擬試験の他にはKubernetesの問題が多いという情報があり、実際に使ったことがなかったのでそちらを中心に色々調べたことが多かったです。そのほかはテストやデプロイの概念（Blue-Greenやカナリアなど）を一度チェックしているくらいです。&lt;/p>
&lt;h2 id="何を問われるか">何を問われるか
&lt;/h2>&lt;p>&lt;a class="link" href="https://cloud.google.com/certification/guides/cloud-developer/hip-local-case-study?hl=ja" target="_blank" rel="noopener"
>HipLocalのケーススタディ&lt;/a>を参考にして準備をした方が良いです。HipLocalに関する問題自体は全体の割合として高くないものの、このケーススタディを用いた問題の場合は、模擬試験で問われる問題以外でもいろいろなパターンがありますので試験の前にケーススタディに合わせてどうやってマイグレーションを行ったらいいかをGCPのサービスと照らし合わせながら確認した方が良いかと思います。&lt;/p>
&lt;p>一つ、HipLocalのケーススタティを全て覚えておく必要はありません。個人的にはここがかなり気になっていたところなのですが、実際のテストではブラウザの右側にケーススタディが提示されていたのでそれを参考して問題を解くことができました。ブラウザに表示された内容ではHipLocal以外のケーススタディが提示される可能性もあるように書いてありましたが、おそらく他のテストでも似たようなパターンの問題があるためそのような記述があるのかなという感覚です。&lt;/p>
&lt;p>問われる問題の範囲や詳細に対しては他のブログでも見つけることができ、自分としては詳細までは覚えてないので詳しくは述べませんが、やはりKubernetesに関する問題が多い感覚で、次にはストレージやサーバレスに関する問題が多かったかなと思います。そのほか、印象に残ったものは&lt;a class="link" href="https://cloud.google.com/anthos" target="_blank" rel="noopener"
>Anthos&lt;/a>や&lt;a class="link" href="https://istio.io/" target="_blank" rel="noopener"
>istio&lt;/a>が言及された問題があったことです。どちらも名前しか聞いてないくらいだったので、その問題に対しては正解となっているかどうかすらわかりませんでした。&lt;/p>
&lt;h2 id="受かったあとは">受かったあとは
&lt;/h2>&lt;p>Google Cloud Certification Perks Webstoreから特典をもらえるコードがメールで送られてきました。もらえる特典の種類は随時変わるらしく、他のブログではBluetooth Speakerなどをもらえると書いてありましたが、私の場合は以下から選ぶようになっていました。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/gcp-certification-professional-cloud-developer/perk.webp"
width="3292"
height="1996"
srcset="https://retheviper.github.io/posts/gcp-certification-professional-cloud-developer/perk_hu_e22aceceeb41a1e.webp 480w, https://retheviper.github.io/posts/gcp-certification-professional-cloud-developer/perk_hu_27c75d25e235bc6f.webp 1024w"
loading="lazy"
alt="Google Cloud Certification Perks Webstore"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;p>私はジッパーフードの方を選びたかったのですが、今回はサイズを2XLしか選べなかったので、今回はジッパーのない方を選んでいます。欲しいものが特になかったら、寄付できるオプションもありますのでそちらを選んでも良いかもですね。&lt;/p>
&lt;p>資格の認証は&lt;a class="link" href="https://www.accredible.com/" target="_blank" rel="noopener"
>Accredible&lt;/a>というサイトから確認できます。こちらのサイトではAWSやOracleの資格を&lt;a class="link" href="https://www.credly.com/" target="_blank" rel="noopener"
>Credly&lt;/a>で確認できたように、認定の証明をサイトにリンクできたり、Linkedinなどに共有できる機能があります。認定書はPDFとしてダウンロードもできました。&lt;/p>
&lt;p>一つ、AWSの場合は資格の有効期限が3年となっていましたが、GCPの場合は2年となっていました。クラウドだとやはりサービスの仕様が変わることも多く、新しいサービスが導入される場合も多いので有効期限を設けていること自体は当たり前とは思いますが、勉強すべき量と受験料($200)を考えると少し短い感覚です。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>受験後に模擬試験とあまりにも違う問題が多かったため今回こそ落ちたのではないかという不安があり、のちに合格したというメールを受けてもやはり実感があまりありませんでした。ただ、それはあくまで自分が模擬試験で問われるもののみを覚えていただけなのが原因な気もします。&lt;/p>
&lt;p>実際の問題は問題と選択肢を注意深く読むことで正解が見えてくるものもあったり、GCPのドキュメントを確認していたらわかるようなことも多いので、まずは公式の&lt;a class="link" href="https://cloud.google.com/certification/guides/cloud-developer" target="_blank" rel="noopener"
>認定資格ガイド&lt;/a>に提示されてある内容を中心に各サービスのドキュメントを一読することをお勧めします。模擬試験はあくまで模擬試験なので、良い点数が取れたからと油断したら落ちる可能性も十分にあり得るのではないかと思います。&lt;/p>
&lt;p>問題の難易度に関しては、やはりどうしても自分が以前取得したAWSの資格と比較してしまいますが、そちらはアソシエイトレベルのものだったため、こちらの資格の方が難しい感覚ではありました。個人的には合格してからも本当にプロフェッショナルを名乗るにはより勉強が必要なのではないかという気がするくらいでした。ただ、普段からGCPのサービスを色々と利用してオンプレからのマイグレーション経験がある方ならそこまで難しくないのかもしれませんので、油断だけしないなら、十分受かる資格なのではないかなと思っています。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>BackendでCoroutineを使う</title><link>https://retheviper.github.io/posts/server-side-coroutine/</link><pubDate>Sun, 05 Jun 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/server-side-coroutine/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.webp" alt="Featured image of post BackendでCoroutineを使う" />&lt;p>Androidアプリのように、GUIを使う場合にはマルチスレッドで処理するのはもはや常識のようなものです。シングルスレッドだと何か思い処理が行われる間に画面が固まるからです。他にもプログレスバーのようにリアルタイムで変化されるコンポーネントの状態を更新したり、チャット、通知の表示などさまざまな場面でスレッドを分けて処理する必要がある場合が多いですね。&lt;/p>
&lt;p>ただ、バックエンドの処理においては少し事情が違うものです。そもそもGUIを考慮する必要がないということもありあすが、サーバでは一つのリクエストに対しての処理を「順次的に」行う場合が多いため、マルチスレッドを利用した処理の分散の利点を活かすのはなかなか難しいものです。&lt;a class="link" href="https://www.reactive-streams.org" target="_blank" rel="noopener"
>Reactive Streams&lt;/a>のようなものもありますが、これは一つのリクエストを分散するというより少ないリソースで多くのリクエストに対する処理を行うためのものなので、一つの処理を分散して効率を上げたいという場合にはあまりふさわしくないものですね。&lt;/p>
&lt;p>もちろん、だからと言ってバックエンドにおいて分散処理が全く必要ないというわけではありません。確かに一つのリクエストに対しての処理を行う中でも、処理によってスレッドを分けて性能向上を期待できる場面があります。例えば後続の処理と関係のない処理を途中に挟んでい場合では、別スレッドで処理したくなりますね。&lt;/p>
&lt;p>なので、今回は&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%AB%E3%83%BC%E3%83%81%E3%83%B3" target="_blank" rel="noopener"
>Coroutine&lt;/a>を使ったバックエンドでの処理の分散するという一例を紹介したいと思います。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="apiの呼び出しを並列化する">APIの呼び出しを並列化する
&lt;/h2>&lt;p>まず並列化で効率を上げられるケースとして、バッチ処理を考えられます。バッチ処理では、条件に当てはまるデータを複数抽出し、それぞれのデータに対して同じ処理を繰り返すことが多いですね。このように個別のデータに対しての処理が独立的に実行されるものであり、並行して走っても特に問題はないという場合は十分その処理を分散できるものです。&lt;/p>
&lt;p>仕事ではGoで作成されたサーバから定期的に日付を基準にDBから処理対象のデータを抽出し、そのデータを配列にしてループしながらKotlinで作成されたサーバのAPIを呼び出すようになっています。また、KotlinサーバでもBackendのAPIを呼び出すケースがあり、これもまたループでデータの参照を行っている状態です。サービスが成長するにつれて、処理にかかる時間によりAPI呼び出しがタイムアウトになるなどパフォーマンスの問題が出てきたので、このループの中でのAPI呼び出しを並列化することで処理にかかる時間を減らすことにします。&lt;/p>
&lt;h2 id="実装してみる">実装してみる
&lt;/h2>&lt;p>まずはCoroutineにより、ループの中でのAPIの呼び出しを実現してみます。上述したとおり、実際の仕事で使えるかどうかを検証してみたく書いたコードなので、各サーバの処理は大して変わらないものとなっています。まずループの中で互いのAPIを呼び出すような処理を書き、呼び出される側では5秒を待ってレスポンスを送るようになっています。これをCoroutineを利用して並列化していきます。&lt;/p>
&lt;h3 id="go">Go
&lt;/h3>&lt;p>まず、以下のような処理があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">callResults&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Response&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;response&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">CallKotlinServer&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gin&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServer] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">results&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">callResults&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tries&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">tries&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServer] before request with id: &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Post&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>) &lt;span style="color:#75715e">// KotlinサーバにPOSTでリクエストを送る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;failed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span> = &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServer] after request with id: &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span> = append(&lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span>: &lt;span style="color:#a6e22e">i&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Result&lt;/span>: &lt;span style="color:#a6e22e">result&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServer] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">JSON&lt;/span>(&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusOK&lt;/span>, &lt;span style="color:#a6e22e">results&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは&lt;a class="link" href="https://gin-gonic.com" target="_blank" rel="noopener"
>Gin&lt;/a>を使ったサーバのサンプルで、handlerの部分です。この関数の中ではAPIが呼び出されると、10回のループの中でKotlinサーバにリクエストを送ります。そして帰ってきたAPI呼び出しの結果を持ってレスポンスのstructを作成して、最終的には10回の実行結果をまとめてJSONとして返す構造となっています。&lt;/p>
&lt;p>ここでKotlin側が返すレスポンスは5秒かかるため、ループの回数が多くなれば多くなるほどレスポンスが帰ってくるのも遅くなります。ログを吐くようにしているので、サーバのログを確認するとリクエストからレスポンスに50秒がかかっているのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:31 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:31 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:36 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:36 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:41 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:41 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:46 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:46 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:51 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:51 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:56 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:49:56 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:01 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:01 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:06 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:06 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:11 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:11 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:16 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:16 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:21 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:50:21 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServer&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>GIN&lt;span style="color:#f92672">]&lt;/span> 2022/06/05 - 18:50:21 | &lt;span style="color:#ae81ff">200&lt;/span> | 50.250251292s | 127.0.0.1 | GET &lt;span style="color:#e6db74">&amp;#34;/api/v1/call-kotlin-server&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="goroutineで並列化する1">Goroutineで並列化する(1)
&lt;/h4>&lt;p>では、以上の処理を並列化することにします。Goには&lt;a class="link" href="https://go-tour-jp.appspot.com/concurrency/1" target="_blank" rel="noopener"
>Goroutine&lt;/a>が基本的に含まれています。使い方は単純で、実行したい関数の前に&lt;code>go&lt;/code>のキーワードをつけるだけですね。ただ、レスポンスでは10回の実行結果を待ってから返す必要があるのですが、goroutineでAPIの呼び出しをするとメインスレッドが先に終わってしまう可能性があります。&lt;/p>
&lt;p>というわけで、ループの中でのAPIの呼び出しにgoroutineを使い、さらにそのgoroutineが全て終了してから結果を返すようにします。goには&lt;code>sync&lt;/code>というパッケージに&lt;a class="link" href="https://pkg.go.dev/sync#WaitGroup" target="_blank" rel="noopener"
>WaitGroup&lt;/a>があり、goroutineの終了を待つことができるようになっています。また、goroutineをループの中で実行する場合、順番はランダムになるのでレスポンスを返す際は一度ソートをかけるようにします。以上を考慮して実装した結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">CallKotlinServerAsync&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gin&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServerAsync] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">results&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">callResults&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tries&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">group&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>{} &lt;span style="color:#75715e">// WaitGroupを定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">tries&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">group&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// ループごとに実行するgoroutineの数を追加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) { &lt;span style="color:#75715e">// goroutineでAPIの呼び出す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServerAsync] before request with id: &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Post&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;failed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span> = &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServerAsync] after request with id: &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span> = append(&lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span>: &lt;span style="color:#a6e22e">i&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Result&lt;/span>: &lt;span style="color:#a6e22e">result&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">group&lt;/span>.&lt;span style="color:#a6e22e">Done&lt;/span>() &lt;span style="color:#75715e">// waitGroupにgoroutineの終了を設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">group&lt;/span>.&lt;span style="color:#a6e22e">Wait&lt;/span>() &lt;span style="color:#75715e">// 全てのgoroutineが終了するのを待つ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Slice&lt;/span>(&lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">ID&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>].&lt;span style="color:#a6e22e">ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServerAsync] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">JSON&lt;/span>(&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusOK&lt;/span>, &lt;span style="color:#a6e22e">results&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように修正して実行した結果のログは以下のとおりです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:30 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 18:52:35 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsync&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>GIN&lt;span style="color:#f92672">]&lt;/span> 2022/06/05 - 18:52:35 | &lt;span style="color:#ae81ff">200&lt;/span> | 5.012657333s | 127.0.0.1 | GET &lt;span style="color:#e6db74">&amp;#34;/api/v1/call-kotlin-server-async&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>10回のループがほぼ同時に実行されたため、レスポンスまで5秒ほどかかっているのがわかります。そしてやはりgoroutineの実行が順番に行われてないことがわかりますね。なので、実行の順番が重要でなくても、結果は順番を守って返す必要がある時はやはりソートが必要ということがわかります。&lt;/p>
&lt;h4 id="goroutineで並列化する2">Goroutineで並列化する(2)
&lt;/h4>&lt;p>場合によっては並列化できるからって、全ての処理を同時に走らせるのは危険な時もあります。上記のコードの場合、リクエストの数は10となっていますが、もしそれより多くのリクエストが必要か、さらに重い処理のAPIを呼び出す場合はどうでしょうか。Go側はリクエストを投げるだけなので処理の負荷はあまり変わらないものですが、APIを呼び出されている側としてはかなりの負荷になるはずです。&lt;/p>
&lt;p>だとすると、やはり並列の数を制限する必要があるはずです。例えば並列の数を2にすると、リクエストは2件づつ送られるのでリクエストの全体の数がいくら増えても負荷は一定に保てます。同時に全てのリクエストを送るよりは遅くなりますが、リソースの状況を見ながら並列数を増やすだけで柔軟に対応ができるので、外部設定ファイルなどで並列数を指定できるようにするとアプリのビルドなしでも柔軟に対応ができるというメリットもありますね。&lt;/p>
&lt;p>スレッドを使う場合だと、このような処理をするためにはかなり複雑な処理を書くことになるはずです。例えば、並列数に合わせてスレッドを定義して、さらにスレッドごとに割り当てる処理を分けなければならないですね。今は10件のリクエストを想定しているので、スレッドごとに5件づつというふうにリクエストを分けるだけで対応ができますが、リクエスト数をスレッド数で割った結果を考慮してループする要素数を適宜分割するような処理をまず足す必要があります。&lt;/p>
&lt;p>しかし、実はgoroutineを使うとそのような複雑な処理をまた足す必要はないです。goroutineでは&lt;a class="link" href="https://go-tour-jp.appspot.com/concurrency/2" target="_blank" rel="noopener"
>Channel&lt;/a>を利用して、同時に実行されるgoroutineの数を指定できます。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">CallKotlinServerAsyncDual&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gin&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServerAsyncDual] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">results&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">callResults&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">tries&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">concurrency&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#75715e">// goroutineの同時実行数を指定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">group&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">WaitGroup&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">guard&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">chan&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}, &lt;span style="color:#a6e22e">concurrency&lt;/span>) &lt;span style="color:#75715e">// 同時実行数でChannelを定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">tries&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">group&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">guard&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}{} &lt;span style="color:#75715e">// Channelに実行を一つたす&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServerAsyncDual] before request with id: &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Post&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;failed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span> = &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">Result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServerAsyncDual] after request with id: &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span> = append(&lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span>: &lt;span style="color:#a6e22e">i&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Result&lt;/span>: &lt;span style="color:#a6e22e">result&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">group&lt;/span>.&lt;span style="color:#a6e22e">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">guard&lt;/span> &lt;span style="color:#75715e">// Channelを準備させる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }(&lt;span style="color:#a6e22e">i&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">group&lt;/span>.&lt;span style="color:#a6e22e">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Slice&lt;/span>(&lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">ID&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">results&lt;/span>.&lt;span style="color:#a6e22e">Response&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>].&lt;span style="color:#a6e22e">ID&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[CallKotlinServerAsyncDual] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">JSON&lt;/span>(&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">StatusOK&lt;/span>, &lt;span style="color:#a6e22e">results&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Channelには指定した数分だけ送信すると、Channelから値を受信するまでは新しいgoroutineの実行はブロックされます。なので、実際に実行してみると、意図通り最大2件づつのリクエストが送信されているのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:10 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:10 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:10 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:15 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:15 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:15 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:15 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:21 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:21 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:21 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:21 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:26 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:26 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:26 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:26 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:31 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:31 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:31 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:31 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:36 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:36 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022/06/05 19:56:36 &lt;span style="color:#f92672">[&lt;/span>CallKotlinServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>GIN&lt;span style="color:#f92672">]&lt;/span> 2022/06/05 - 19:56:36 | &lt;span style="color:#ae81ff">200&lt;/span> | 25.194952625s | 127.0.0.1 | GET &lt;span style="color:#e6db74">&amp;#34;/api/v1/call-kotlin-server-async-dual&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kotlin">Kotlin
&lt;/h3>&lt;p>まずは順次処理する場合のコードから見ていきます。基本的にGoの場合と同じ処理をKotlin側にも用意していて、特に変わったものはありません。以下がそのコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">callGoServer&lt;/span>(): List&amp;lt;CallGoServerDto&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServer] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> tries.map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServer] before request with id: &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> goServerClient.call(&lt;span style="color:#66d9ef">it&lt;/span>) &lt;span style="color:#f92672">?:&lt;/span> CallGoServerDto(&lt;span style="color:#66d9ef">it&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;failed&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// GoのAPIを呼び出す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .also { result &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServer] after request with id: &lt;/span>&lt;span style="color:#e6db74">${result.id}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.also {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServer] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Curlで実行してみた結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:33.429 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:33.430 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:38.483 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:38.483 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:43.490 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:43.491 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:48.498 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:48.499 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:53.509 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:53.510 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:58.518 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:06:58.518 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:03.530 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:03.531 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:08.538 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:08.539 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:13.552 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:13.553 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:18.561 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:18.562 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:23.570 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:07:23.570 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServer&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こちらもGoの時と同じく、リクエストからレスポンスまで50秒ほどかかっているのがわかります。これをCoroutineを持って並列化していきましょう。&lt;/p>
&lt;h4 id="coroutineで並列化する1">Coroutineで並列化する(1)
&lt;/h4>&lt;p>Goと違って、KotlinのCoroutineは言語の基本仕様ではありません。なので、依存関係をまず追加する必要があります。ただ、公式の説明では&lt;code>coroutine-core&lt;/code>だけを追加すると対応できそうなイメージですが、SpringのようにReactive Streamが必要な場合は&lt;code>coroutine-reactor&lt;/code>を依存関係に追加する必要があります。&lt;/p>
&lt;p>依存関係を追加した上で、コードを直していきます。ここではSpring Bootを使っていて、Controllerの関数を&lt;code>suspend&lt;/code>にすることができるので、Contollerから呼び出している関数にもsuspendにしていきます。また、coroutineでの処理はスコープの指定が必要なのでループの周りを&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" target="_blank" rel="noopener"
>coroutineScope&lt;/a>で包むようにします。その後は&lt;code>map&lt;/code>関数の中で&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" target="_blank" rel="noopener"
>async&lt;/a>としてAPIの呼び出しを行い、&lt;code>map&lt;/code>した結果は&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html" target="_blank" rel="noopener"
>Deferred&lt;/a>として帰ってくるので&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/await-all.html" target="_blank" rel="noopener"
>awaitAll&lt;/a>で終了を待ちます。説明では複雑ですが、以下のコードをみるとわかりやすいかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">callGoServerAsync&lt;/span>(): List&amp;lt;CallGoServerDto&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServerAsync] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> coroutineScope { &lt;span style="color:#75715e">// coroutineとして処理する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> tries.map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> async { &lt;span style="color:#75715e">// 並列に実行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServerAsync] before request with id: &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> goServerClient.call(&lt;span style="color:#66d9ef">it&lt;/span>) &lt;span style="color:#f92672">?:&lt;/span> CallGoServerDto(&lt;span style="color:#66d9ef">it&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;failed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.awaitAll() &lt;span style="color:#75715e">// APIの呼び出し結果を待つ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .also {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.forEach { result &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServerAsyncDual] after request with id: &lt;/span>&lt;span style="color:#e6db74">${result.id}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServerAsyncDual] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、APIを呼び出している関数(&lt;code>goServerClient.call()&lt;/code>)もsuspendにしておく必要があります。ここではSpringの&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="noopener"
>RestTemplate&lt;/a>を使い、以下のような関数を定義しておきました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> client = RestTemplate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> header = HttpHeaders().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>(&lt;span style="color:#a6e22e">HttpHeaders&lt;/span>.CONTENT_TYPE, &lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON_VALUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">call&lt;/span>(id: Int): CallGoServerDto? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> request = HttpEntity(CallGoServerRequest(id), header)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> client.postForObject(&lt;span style="color:#e6db74">&amp;#34;http://localhost:8800/api/v1/some-process&amp;#34;&lt;/span>, request, CallGoServerDto&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.java)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにコードを修正して実行してみると、Goの時と同じく並列で10件のリクエストが送られているのがわかります。ただ、違う点としてはgoroutineと違って実行の順番が保証されているというところですね。この特徴があるため、Kotlinの場合はレスポンスのソートが必要ないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.934 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.939 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.939 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.939 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.940 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.940 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.940 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.941 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.941 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.941 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:52.941 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-1&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsync&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:46:57.951 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="coroutineで並列化する2">Coroutineで並列化する(2)
&lt;/h4>&lt;p>上記のコードもGoの時と同じく、リクエストを同時に全部送っているのは問題になる可能性があるので、同時に送信するリクエストの数を制限することにします。Goでもそうであったように、KotlinでもCoroutineの同時実行の数を制限する仕組みがあります。&lt;a class="link" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-semaphore/index.html" target="_blank" rel="noopener"
>Semaphore&lt;/a>というものです。&lt;/p>
&lt;p>Sempaphoreに数値を指定し、asyncの中でSemaphoreに指定した数で実行数を制限することで並行実行数を制限するような形です。以下がそのコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">callGoServerAsyncDual&lt;/span>(): List&amp;lt;CallGoServerDto&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServerAsyncDual] start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> semaphore = Semaphore(&lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#75715e">// 同時実行数を制限するためのSempahoreの定義
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tries.map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> semaphore.withPermit { &lt;span style="color:#75715e">// asyncの同時実行数をSemaphoreに指定した数値に制限
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServerAsyncDual] before request with id: &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> goServerClient.call(&lt;span style="color:#66d9ef">it&lt;/span>) &lt;span style="color:#f92672">?:&lt;/span> CallGoServerDto(&lt;span style="color:#66d9ef">it&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;failed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.awaitAll()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .also {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.forEach { result &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServerAsyncDual] after request with id: &lt;/span>&lt;span style="color:#e6db74">${result.id}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info(&lt;span style="color:#e6db74">&amp;#34;[CallGoServerAsyncDual] done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>書き方が少し違うだけで、Goとほぼ同じ感覚でasyncの処理を制限できるコードが出来ました。特にコンパイルエラーが出ることはないので勘違いしやすいところではないかと思います。&lt;code>async{ semaphore.withPermit{ } }&lt;/code>の順番をちゃんと守る必要がありますので注意しましょう。実行結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:50.361 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-6&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:50.365 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-6&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:50.366 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>nio-8900-exec-6&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:55.369 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:50:55.369 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:00.377 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:00.379 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:05.386 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:05.386 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:10.393 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-2&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:10.393 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> before request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.404 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.404 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> after request with id: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2022-06-05 20:51:15.405 INFO &lt;span style="color:#ae81ff">60551&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>atcher-worker-8&lt;span style="color:#f92672">]&lt;/span> c.e.c.d.service.CallGoServerService : &lt;span style="color:#f92672">[&lt;/span>CallGoServerAsyncDual&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ログを吐く場所が微妙だったのですが、リクエストを送っている時間をみると、5秒置きで2つづつを送信しているのがわかります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>あまりCoroutineに詳しくないゆえ、もっと良い書き方はあったかなと思いますが(goroutineの実行順を決めておく、&lt;code>WaitGroup.Done()&lt;/code>は&lt;code>defer&lt;/code>で定義する、Kotlinのログ出力箇所を調整するなど)、これで簡単にAPIの呼び出しを並列化することができるというのがわかったので個人的にはかなり満足しています。Jetpack Composeを少し触りながらcoroutineに触れたことはあったものの、こうやって仕事で必要となり調査と検証をしてみたのは初めてだったのでかなりの収穫を得たと言えますね。また、各言語においての感想は以下の通りです。&lt;/p>
&lt;ul>
&lt;li>Go
&lt;ul>
&lt;li>依存関係の追加なしで使えるのはメリット&lt;/li>
&lt;li>Kotlinのようにsuspendやscopeを意識しなくていいので便利&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Kotlin
&lt;ul>
&lt;li>asyncでも実行順が保証されているのはメリット&lt;/li>
&lt;li>goroutineよりは注意点が多い&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>二つの言語を比べると一長一短があるという感覚ですが、どれも応用が難しいものではないので、すぐにプロダクションコードにも適用できそうなものが書けるのは確かに良いものという印象を受けました。これからもcoroutineを使って性能向上ができる箇所はないか、色々と試してみたくなるものです。ちなみに、この記事に載せてあるコードを全体のソースは&lt;a class="link" href="https://github.com/retheviper/AsyncServerExample" target="_blank" rel="noopener"
>こちらのリポジトリ&lt;/a>から参照できます。&lt;/p>
&lt;p>では、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>厳密にいうと、Coroutineによる処理はマルチスレッドによる並列化とは概念的には違うものですが、実装と結果の取得という面では感覚が大きく変わらないので、ConcurrencyとParallelismによる違いなどの理論的な話は割愛しています。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Kotlinのこれからを語る</title><link>https://retheviper.github.io/posts/kotlin-prospect/</link><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-prospect/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinのこれからを語る" />&lt;p>1年ほどサーバサイドKotlinを扱いながら、ふと「今のKotlinはどこまできていて、これからはどうなるんだろう」と思うようになりました。色々な観点があると思いますが、とりあえず市場においてどれほどの需要があり、展望（これからも積極的に採用され続けそう、苦戦しそうなどの）はどうかなど、いわゆるkotlinという言語の「ステータス」について自分が感じていることについて考えてみたくなったというわけです。&lt;/p>
&lt;p>最近のトレンドを見ると、一つの言語において専門家になるというよりはさまざまな言語を使いこなせる、いわゆる&lt;code>Polyglot&lt;/code>なプログラマが求められていて、常識みたいになっているとも言われているようです。確かに私自信もその経験があるかどうかは関係なく、案件によりさまざまな言語に触れるケースを多くみています。そして今は充実したドキュメントや記事をインターネットに溢れていて、UdemyやCourseraなど良質の講義を提供するサイトも色々とあるので経験がない言語だとしても入門が難しくてできないとは言えない時代になっている感覚でもあります。なので、自分が現在使っている言語がメインストリームに属してあるかどうかの問題は以前よりは重要でなくなった、といえるかもしれません。&lt;/p>
&lt;p>ただ、立場や観点によっては一つの言語に集中したい場合もあるかと思います。例えば学生や、未経験からエンジニアに転職しようとする人にいきなり二つ以上の言語を扱えるように注文するのは難しいことでしょう。エンジニアの追求する技術においてもそうです。フロントエンドエンジニアがいきなり今すぐ使う予定でもないGoやJavaのようなバックエンドで使われる言語を勉強する必要はないはずです。そして会社としては、複数の言語を扱えるエンジニアを求めるということは採用において非常に厳しい条件となるはずです。なので、依然として市場において一つの言語のステータスというのは無視できないものなのではないかと私は思っています。&lt;/p>
&lt;p>というわけで、今回は多少主観的な観点からの話になりますが、他の言語や分野で、Kotlinという言語の展望について考えてみたことを述べたいと思います。それでは、どうぞ。&lt;/p>
&lt;h2 id="vs-java">vs Java
&lt;/h2>&lt;h3 id="better-javaという捉え方">Better javaという捉え方
&lt;/h3>&lt;p>Kotlin(JVM)をJavaと比べると、コンパイル結果がバイトコードを生成するため、「Javaと互換性が完璧であり、性能もまた変わらない」というのが世間一般でいうKotlinの評価ではないかと思います。その上拡張関数やCoroutine、スコープ関数、Null安全性などさまざまな機能が揃っているので、表面上は&lt;code>better java&lt;/code>と読んでも良いのではないかと思わせる面もあります。それに、JavaのバージョンアップでJVMの改良が行われると、結局それもKotlinの改善につながることとなりますね。Javaも1.8以降は半年に1回のリリース政策によりバージョンアップが早くなっていまずが、まだアプリケーションエンジニアの立場からするとKotlinと比べ惜しいところもなくはないかなと思います。&lt;/p>
&lt;p>ここまでの話だと、Kotlinは完璧にJavaを代替できる言語であるかのように聞こえます。つまり、これからは全くJavaを使う理由はなくて、何もかもKotlinに移行するという選択肢しかないかのようにですね。しかし、業界の事情はどうなのでしょうか。&lt;/p>
&lt;p>まずJavaの歴史から考えてみましょう。Javaは長い間、「世界で最もよく使われる言語」であって、他の言語が人気を得た今でもTop 5に入るほどの人気な言語となっています&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。そしてこれが示唆するのは、単純に今の人気、つまり、「これからも使われる可能性」だけの話ではなく、「今まで使われた回数」が圧倒的に高いということも意味するという点です。今まで作られた多くのシステムやアプリケーションがJava基盤になっているので、余程のことがない限りは維持保守や機能の拡張においてJavaのエンジニアを求めることになるでしょう。&lt;/p>
&lt;p>また、こういう側面もあります。JVM言語としてJavaのメリットを活かしつつ、より発展したコードを書けるというコンセプトで登場した言語はKotlinだけではないということです。今までClojure・Scala・Groovyなどさまざまな言語が登場し、それぞれの言語がそれなりの需要や分野を確保・拡張できてはいるものの、そのうちどれも「Javaを超えた」という評価をもらってはいないのが現状かと思います。同じくKotlinの場合も、その立場が他のJVM言語と大きく変わっているとは言えないものではないでしょうか。なので、「JVM言語だ」「Javaよりモダンだ」という特徴は、少なくともKotlinが今後Javaを超えられるという根拠にはならないかと思っています。&lt;/p>
&lt;p>モバイルではAndroidの言語としてJavaよりKotlinを採用する例が多くなっているかと思いますが、これはOracleとGoogleの訴訟絡みでJavaを1.8しか使えなかったことも理由の一つかと思います。現在Javaがよく使われているWebの場合、OpenJDKのバージョンに特に法理的な問題もなく、Java 17からはOracleJDKも無償で利用できるようになったので、モバイルとはまた状況は違うのではないかと個人的には思っています。&lt;/p>
&lt;p>もちろん、上記の問題はJetbrainsでもその点は最初から認識していたため、最初からKotlinがJavaと相互運用できる言語として設計した部分はあります。なので、あくまで既存のJavaアプリケーションをKotlinでリプレイスする、というよりは、部分的な移行から新規開発で占有率を徐々に上げていくことを目標としているのではないかと思います。その戦略は十分に納得できるもので、あとは企業の方でJavaとKotlinという二つの言語を同時に運用することに抵抗がなければ、Javaを使っていた場合でも問題なくKotlinを受け入れられると思います。実際、自分の場合でもJavaからKotlinの移行は全く問題ありませんでした。&lt;/p>
&lt;h3 id="kotlinも強くなる">Kotlinも強くなる
&lt;/h3>&lt;p>最近のフレームワークやライブラリの方をみると、まだKotlinがモバイル以外の分野での認知度は劣るものの、少しづつJavaがメインストリームであった分野で採用されているケースが増えてきているような気もします。例えば、自分が仕事で使っている&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.kotlin" target="_blank" rel="noopener"
>Spring boot&lt;/a>、&lt;a class="link" href="https://github.com/FasterXML/jackson-module-kotlin" target="_blank" rel="noopener"
>Jackson&lt;/a>、&lt;a class="link" href="https://github.com/awslabs/aws-sdk-kotlin" target="_blank" rel="noopener"
>AWS SDK&lt;/a>などウェブアプリケーションで有名なものがKotlinに対応していて、他にも&lt;a class="link" href="https://www.jooq.org/doc/latest/manual/getting-started/jooq-and-kotlin/" target="_blank" rel="noopener"
>jOOQ&lt;/a>、&lt;a class="link" href="https://jooby.io/v1/doc/lang-kotlin/" target="_blank" rel="noopener"
>jooby&lt;/a>、&lt;a class="link" href="https://javalin.io/" target="_blank" rel="noopener"
>Javalin&lt;/a>のようにJavaとKotlinの両方に対応しているものも増えています。&lt;/p>
&lt;p>もしくは、Javaで存在していたライブラリをKotlin向けに調整したものもあります。例えば&lt;a class="link" href="https://tornadofx.io/" target="_blank" rel="noopener"
>TornadoFX&lt;/a>、&lt;a class="link" href="https://github.com/grpc/grpc-kotlin" target="_blank" rel="noopener"
>gRPC&lt;/a>、&lt;a class="link" href="https://github.com/ReactiveX/RxKotlin" target="_blank" rel="noopener"
>RxKotlin&lt;/a>のようなものがそうです。そして、最初からKotlin専用として設計されたものも少なくないです。&lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>Kotlin Serialization&lt;/a>、&lt;a class="link" href="https://github.com/cbeust/klaxon" target="_blank" rel="noopener"
>Klaxon&lt;/a>、&lt;a class="link" href="https://github.com/Netflix/dgs-framework" target="_blank" rel="noopener"
>DGS&lt;/a>、&lt;a class="link" href="https://www.ktorm.org/" target="_blank" rel="noopener"
>Ktorm&lt;/a>、&lt;a class="link" href="https://github.com/kotest/kotest" target="_blank" rel="noopener"
>Kotest&lt;/a>、&lt;a class="link" href="https://github.com/mockk/mockk" target="_blank" rel="noopener"
>MockK&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>、&lt;a class="link" href="https://litote.org/kmongo/" target="_blank" rel="noopener"
>KMongo&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/xodus" target="_blank" rel="noopener"
>Xodus&lt;/a>、&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>、&lt;a class="link" href="https://github.com/Kodein-Framework/Kodein-DI" target="_blank" rel="noopener"
>Kodein-DI&lt;/a>などがそうですね。なので、Javaの世界に寄生していた数年前とは違って、Kotlinだけでもウェブアプリケーションを十分構築できるレベルまできているのではないか、というのが自分の考えです。&lt;/p>
&lt;p>結論として、まだ二つの言語を比べると、Javaの方が圧倒的に規模はでかく、知名度でも上にあるのですが、Kotlinも競争できる力を身につけてきたので、これからは十分状況が変わる可能性がある、と思っています。&lt;/p>
&lt;h2 id="vs-go">vs Go
&lt;/h2>&lt;h3 id="早いの美徳">「早い」の美徳
&lt;/h3>&lt;p>仕事でGoを使っている立場からすると、Kotlinに比べGoの優越な側面はやはり「とにかく早い」ということではないかと思います。基本的にネイティブにコンパイルされる言語なのでランタイム性能も優秀なはずですが、コンパイルもビルドもとにかく早いのは確かに良いなと思いました。特に、コードの修正後にユニットテストで検証してみることが多いのですが、Kotlinのプロジェクトと比べるととにかく早いのでストレスがないですね。(Kotlinの場合は使っているウェブフレームワークがSpringで、テストケースがより多い、ビルド時にはシングルスレッドでやっているということもありますが)&lt;/p>
&lt;p>そのほかにもGitHubのパッケージをそのまま使えたり、別途ライブラリを使わなくてもstructをすぐにJSONとして扱える(&lt;code>omitempty&lt;/code>とかも便利な場面がある)なところは印象的で、かなりウェブ開発に特化されているなという印象までありました。ネイティブなのでビルドして生成されるバイナリのサイズが小さいのも良いですね。これらの特徴からして、最近トレンドとなっているサーバレスやマイクロサービスなどおいてはKotlinよりGoを採用した方が有利な面が多いかなと思います。&lt;/p>
&lt;p>まだサーバがクラウド上のVMに移行したばかりの頃は、JVMを使う言語の問題はだいたいマシンスペックの向上により無視できました。しかし、サーバレスとマイクロサービスアーキテクチャが流行りながらJVMの特徴が再び問題となってきていますね。まずサーバレスだと、JVMが完璧にロードされるまで時間がかかるる上に、さらにコールドスタートにも時間がかかります&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。また、マイクロサービスにおいては、JVMが占めるヒープメモリとストレージが増えることでインスタンスごとのコストが増えるという問題が挙げられています。&lt;/p>
&lt;h3 id="kotlin--遅い">Kotlin != 遅い
&lt;/h3>&lt;p>このような問題に対して、サーバレスだと&lt;a class="link" href="https://site.kotless.io/" target="_blank" rel="noopener"
>Kotless&lt;/a>のようなフレームワークが開発されていたり、&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>を利用してネイティブビルドができる&lt;a class="link" href="https://ja.quarkus.io/" target="_blank" rel="noopener"
>Quarkus&lt;/a>や&lt;a class="link" href="https://github.com/spring-projects-experimental/spring-native" target="_blank" rel="noopener"
>Spring Native&lt;/a>が開発されるなど、JVM言語でも最近のトレンドに合わせて改善が行われていはいます。&lt;/p>
&lt;p>ランタイム性能という面では、JITによる最適化でJVM言語でもGoには劣らないという面もありますね。ベンチマークを見ると&lt;a class="link" href="https://programming-language-benchmarks.vercel.app/go-vs-kotlin" target="_blank" rel="noopener"
>Kotlin/JVMとの比較&lt;/a>や&lt;a class="link" href="https://www.lambrospetrou.com/articles/kotlin-http4k-graalvm-native-and-golang/" target="_blank" rel="noopener"
>Kotlin/Native&lt;/a>でわかるように、Goに対してKotlinが性能で劣る部分もあれば、優位にある部分もあるのがわかります。&lt;/p>
&lt;p>また、&lt;a class="link" href="https://go.dev/blog/intro-generics" target="_blank" rel="noopener"
>Go 1.18でジェエリックが導入&lt;/a>されていますが、&lt;a class="link" href="https://planetscale.com/blog/generics-can-make-your-go-code-slower" target="_blank" rel="noopener"
>ジェネリックにより遅くなる可能性がある&lt;/a>という話もあり、これからもしGoに新しい機能が追加されるとしたら、それがコンパイル速度やランタイム性能に影響を及ぼす可能性もあるかなと思います。&lt;/p>
&lt;p>なので、KotlinとGoという二つの言語で考えると、少なくともパフォーマンスという観点だけではGoにこだわる必要はないかなと思います。しかし、アプリケーションの開発において言語を選ぶ基準はパフォーマンスだけでなく、生産性やクラウドで対応している言語、エンジニアが確保できるかなど色々な側面があるので、Goの代わりにKotlinを選んだほうが効率的だとは言えないのも事実です。自分が転職を決めた時も、サーバサイドではGoのエンジニアを募集している企業の方がKotlinより多かったのですが、単純にパフォーマンスが基準だとしたらこのようなことにはならなかったでしょう。Googleが推している言語であるとか、パフォーマンスだけでなく生産性の面でも優れているなどさまざまな理由が複合的に作用した結果だと言えるものかと思います。&lt;/p>
&lt;h3 id="それでも有利なのは">それでも有利なのは
&lt;/h3>&lt;p>あとは、そもそもの知名度の問題ですね。Kotlinにおいて、ネイティブイメージのビルドができ、性能が劣らないとしても、多くの場合はKotlinをモバイル(Android限定)用の言語だと認識しているのが一般的かなと思います。なので、このような認識がエンジニアと企業で変わらない限り、これからもGoの方がサーバサイドでは市場において優位に立つという状況がしばらくは続くのではないかと思っています。&lt;/p>
&lt;p>他にも、Goはその書きやすさからや入門のしやすさの人気もあると思いますが、それを踏まえると比較的書き方が複雑なKotlinの方が劣るのではないかという推測もできそうですね。自分にとってはKotlinの書き方が簡潔で良い感覚ですが、Goの書き方を簡潔だと思っている方もいるようです。確かに、キーワードが少なく、それらを覚えるのに労力が比較的少ないなら、よりロジックに集中した書き方ができるはずですね。Goで作られたアプリやCLIツールなどが増えているのも、そのような特徴からのものなのではないでしょうか。自分の場合は簡単なツールを作るときはPythonで書くのを好みますが、同じく気軽にコードが書ける稼働かの観点でいうと、KotlinよりGoが優れているとも言える気がします。なので、個人の趣味やサイドプロジェクトなどでよく使われ、それがまた人気につながるだろうと思うと、Goを好むエンジニアが増えるのもおかしくはないですね。&lt;/p>
&lt;h2 id="vs-rust">vs Rust
&lt;/h2>&lt;h3 id="最強の性能">最強の性能？
&lt;/h3>&lt;p>GCがないので同じネイティブでありながらもGoより性能が優秀だというRustですが、これもまたKotlinと同じく、知名度の問題で苦戦しているところがあるかなと思います。そもそもC/C++を代替するのが開発の目的でもあったため仕方ないのかもしれませんが、どちらかというとエンベデッドで使われるイメージがどうしてもあるような気がしますね。意外と&lt;a class="link" href="https://www.figma.com/" target="_blank" rel="noopener"
>Figma&lt;/a>、&lt;a class="link" href="https://1password.com/jp/" target="_blank" rel="noopener"
>1Password&lt;/a>、&lt;a class="link" href="https://discord.com/" target="_blank" rel="noopener"
>Discord&lt;/a>、&lt;a class="link" href="https://www.dropbox.com/" target="_blank" rel="noopener"
>Dropbox&lt;/a>、&lt;a class="link" href="https://www.mozilla.org/ja/" target="_blank" rel="noopener"
>Mozilla&lt;/a>、&lt;a class="link" href="https://line.me/ja/" target="_blank" rel="noopener"
>Line&lt;/a>、&lt;a class="link" href="https://www.npmjs.com/" target="_blank" rel="noopener"
>npm&lt;/a>、&lt;a class="link" href="https://www.cloudflare.com/ja-jp/" target="_blank" rel="noopener"
>Cloudflare&lt;/a>などさまざまな組織で採用されていて、&lt;a class="link" href="https://github.com/ogham/exa" target="_blank" rel="noopener"
>exa&lt;/a>、&lt;a class="link" href="https://github.com/sharkdp/bat" target="_blank" rel="noopener"
>bat&lt;/a>、&lt;a class="link" href="https://github.com/Wilfred/difftastic" target="_blank" rel="noopener"
>difftastic&lt;/a>、&lt;a class="link" href="https://github.com/ClementTsang/bottom" target="_blank" rel="noopener"
>bottom&lt;/a>などのCLIツールから&lt;a class="link" href="https://yew.rs/" target="_blank" rel="noopener"
>yew&lt;/a>、&lt;a class="link" href="https://seed-rs.org/" target="_blank" rel="noopener"
>seed&lt;/a>、&lt;a class="link" href="https://dioxuslabs.com/" target="_blank" rel="noopener"
>Dioxus&lt;/a>、&lt;a class="link" href="https://rocket.rs/" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://github.com/http-rs/tide" target="_blank" rel="noopener"
>tide&lt;/a>、&lt;a class="link" href="https://github.com/poem-web/poem" target="_blank" rel="noopener"
>poem&lt;/a>のようなGUIやウェブフレームワークなどがたくさん開発されていますが、これもまた特に調査してみないとわからないくらいです。&lt;/p>
&lt;p>さまざまなベンチマークでその性能が検証されていて、使ってみたエンジニアからも評判の高いものとなっているRustですが、やはり知名度が低いので、企業からも採用するのはかなり難しい判断になるでしょう。実際Jetbrainsの去年の設問では&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/rust/#Rust_how-do-you-use-rust" target="_blank" rel="noopener"
>Rustは趣味もしくは個人用途、サイドプロジェクトで使う&lt;/a>と答えた割合のエンジニアが多かったのを見ると、やはり企業の需要はあまりようです。ただ、逆にいうと、このようにRustに好意的なエンジニアが増え、さまざまなプロジェクトで使われ始めるといつか市場の状況も変わっていく可能性もあるということです。先ほど述べたGoのケースのように、比較的に歴史の短い若い言語でも十分その価値を立証できるのであれば市場でもメインストリームに合流できます。なので、Rustの未来はむしろ明るく、これからが期待される言語だと個人的には思っています。ただ、人気を得た後も、ウェブアプリケーションを開発するよりは今まで通りエンベデッド・システムプログラミングに特化していきそうな気がしますね。&lt;/p>
&lt;h3 id="kotlinをネイティブにしたら">Kotlinをネイティブにしたら
&lt;/h3>&lt;p>RustをKotlinとの比較をするとしたら、Kotlin/Nativeがあるので、言語自体でできることはそう変わらないものの、Rustがエンベデッドやシステムプログラミングという分野でC/C++を代替していく傾向があるのに対して、これといった成果があまり見当たらないというのが問題かなと思います。特にKotlin/NativeはLLVM基盤なので、GraalVMによるネイティブコンバイるができるウェブフレームワークが登場している今はますますそのポジションが曖昧なものになっている気もします。Object-CやC/C++とのinteropができると言われていますが、そのようなユースケースだとそもそもObject-CやC/C++といった言語を使った方が色々と有利なのではないでしょうか。もちろん、Rustには所有権のような概念があり、他の言語と比べプログラミングが難しいとされているので、Kotlin/Nativeを採用した方がコーディングは楽になるかもしれません。でも、Nativeを追求するならやはりパフォーマンスが重視される場面が多いので、そこではGCのあるKotlinが不利な気がしますね。このような面からすると、やはりKotlin/Nativeのポジショニングが難しそうな気がします。&lt;/p>
&lt;p>結論としては、Kotlin(JVM)とRustはそれぞれ特化した分野が違っていて、大きな変化がない限り互いの領域を蝕むことなく発展していきそうです。どちらかというとKotlin/Nativeが直接的なライバルになる可能性はありますが、そもそものポジショニングが曖昧なところがあるので、Nativeがどうしても必要な場面ではRustが使われる可能性が高いのではないか、という気がしています。&lt;/p>
&lt;h2 id="vs-python">vs Python
&lt;/h2>&lt;h3 id="万能ツール">万能ツール
&lt;/h3>&lt;p>ここ数年で最も人気を得ている言語の一つ、Pythonの場合は、Kotlinと比べて見るとどうでしょうか。まず自分の場合だと、日常での自動化や簡単なツールを作る場面ではPythonの方をよく使っていて、本格的なウェブアプリケーションを開発するとしたらKotlinを選ぶことが多いです。もちろん、なんでもできる言語なので大規模のアプリケーションを作るのにPythonがNGというわけではないです。実際Uber、Google、PayPal、Netflixなど有種の企業がPythonを使っていて、あの有名なInstagramのサーバサイドもPythonで書かれていると言われていますね。&lt;/p>
&lt;p>ただやはり、PythonはデータサイエンスやAIといった分野でよく使われているイメージがあり、使いやすく、そこまで性能が求められていない場面でなら良いものの、個人的にはその限界が明確であることが問題かなという気もします。本格的な業務用のアプリを開発した経験がないのであくまで印象と推測の話となりますが、Pythonをサーバサイドに取り入れている企業は大概がスタートアップであって、サービスが古くなるとインタープリター言語特有のメンテが難しくなるという問題が出てくる可能性が高いではないかと思いますね。JavaScriptの例もありますが、Pythonのタイプヒントはあくまでヒントであって、TypeScriptのようにコンパイルタイムで検出できるエラーを確実にわかるわけでもないです。あとは性能ですが、&lt;a class="link" href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener"
>GIL&lt;/a>のような問題もあります。このような問題を認識しているため、検証用のアプリ(プロトタイプ)をPythonで書いてから他の言語に移行するという例もあるのかなと思ったりしています。&lt;/p>
&lt;h3 id="pythonだけの領域でもないが">Pythonだけの領域でもないが
&lt;/h3>&lt;p>逆にKotlinでいうと、Jupyterを使えるなど&lt;a class="link" href="https://kotlinlang.org/docs/data-science-overview.html#kotlin-libraries" target="_blank" rel="noopener"
>Kotlinでもデータサイエンスに使える&lt;/a>のですが、すでにPythonが市場支配的な言語になっているところでどこまで伸びるかが問題な気がしますね。JetBrainsが主張するように、Pythonと比べ「静的型付け、Null安全性、パフォーマンス」というのは確かにKotlinが持つメリットではあるのですが、そもそものユーザ数が増える何かがないと占有率を上げるのはかなり難しくないのではないかと思います。Pythonは入門が簡単なので講座も多く、実際エンジニアではない人も使うケースが多いのですが、Kotlinはまだそのような面では弱い印象ですね。&lt;/p>
&lt;p>以上のことからして、Pythonは依然としてデータサイエンスなど元々強かった分野に対してはこれからも需要が大きく変わることはなさそうです。ウェブという分野では競合になる可能性はありますが、どちらかというとKotlinを採用した方がより安定した開発ができるので大規模なアプリの開発ではKotlin、小規模ではPythonという形になるのではないかと思います。もちろん、大規模のアプリを開発するにあたってはまたの選択肢があるのでKotlinではない他の言語が採用される可能性の方が高そうですが、あくまで二つの言語を比べた場合の話となります。&lt;/p>
&lt;h2 id="vs-javascript">vs JavaScript
&lt;/h2>&lt;h3 id="多芸多才">多芸多才
&lt;/h3>&lt;p>一つの言語でなんでもできちゃう言語が何かというと、過去はJava、少し前はPython、そして今はなんといってもJavaScriptではないかと思います。フロントエンド、バックエンド、モバイル、データサイエンスなどさまざまな分野で活躍している言語ですね。ランタイムの性能が問題となっている部分に対しても&lt;a class="link" href="https://deno.land/" target="_blank" rel="noopener"
>Deno&lt;/a>のような新しいランタイムが登場したり、V8エンジンの持続的な改善によりだんだん補完されていって、静的型付けに関してもTypeScriptの台頭によって解決されています。まさに無敵の言語のようにも見えます。&lt;/p>
&lt;p>フロントエンドにおいてはJavaScript以外は考えられない&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>というのもあり、&lt;a class="link" href="https://webassembly.org/" target="_blank" rel="noopener"
>WebAssembly&lt;/a>のような技術も発達していますが、これはまたウェブの画面描画だけでなく違う方向に向かっているような感じなので、これから何かあって(あるとは思いませんが)色々な分野で使われなくなるとしてもJavaScriptそのものが使われなくなることはないでしょう。そして同じ意味で、Kotlinがそのような分野に進出するのもかなりハードルが高いと思います。&lt;/p>
&lt;h3 id="kotlinでフロントエンド">Kotlinでフロントエンド？
&lt;/h3>&lt;p>Kotlinで言えば、Kotlin/JVMとKotlin/Native以外に3つの軸として存在しているのが&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>であり、JetBrainsの発信を見るとそこそこ力を入れている感覚ではあります。他にも、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-mpp/" target="_blank" rel="noopener"
>Compose Multiplatform&lt;/a>を通じて、モバイルだけでなくウェブやデスクトップアプリにおいてもKotlinでGUIを作成できるようになったので、なるべく自分のサイドプロジェクトなどではKotlinで完結したいと思っている私の場合はこちらも応援したいと思っています。ただ、まだモバイル以外ではそこまでメジャーではなく、新しい技術の問題(ライブラリの不足、バージョンアップによる変化が激しいなど)が考えられるのでしばらくは様子見な感じですね。あと自分のような特殊な目的がない場合は、個人でも企業側としても無理して採用すべきメリットが薄いという問題もあるかなと思います。&lt;/p>
&lt;p>バックエンドだとKotlinが競合になる可能性はまだ十分ではないかと思います。特に、今までJavaが採用されていた分野だと主にJVMの安定性や数値計算の精度など検証された安全性というものがあるので、これから言語を変えるとしたらKotlinを採用する確率が高いのではないかと思っているところですが、そのような分野だと、最初からJavaScriptによるバックエンドの採用は考えない可能性が高そうです。スタートアップのようにエンジニアの求人が難しく、使われる技術の数を減らしてなるべく工数の削減しようとするか、Pythonのようにプロトタイプのアプリを作るかなどの特殊な状況ではない限り積極的にバックエンドの言語としてJavaScriptを採用する例はあまりなさそうな気がしていて、これからもおそらくそれは大きく変化していく気はしません。ただ、自分のようにKotlinで何もかも解決したい、という方がJavaScript側にもいらっしゃるとしたら、そこはまた話が変わってくるかもしれませんね。フロントエンド、バックエンド、モバイル、デスクトップまで対応したい場合にはJavaScript以上のものがないので、その会社や個人の目的次第でJavaScriptが採用される可能性は高く、そのような状況こそKotlinは採用されない可能性が高いかなと思います。&lt;/p>
&lt;h2 id="vs-dart">vs Dart
&lt;/h2>&lt;h3 id="guiの最強者">GUIの最強者？
&lt;/h3>&lt;p>Dartの場合は、言語そのものというよりは&lt;a class="link" href="https://flutter.dev/" target="_blank" rel="noopener"
>Flutter&lt;/a>が最近熱いですね。最初はモバイルでクロスプラットフォーム開発ができるということで注目されたものですが、Dartに対してはFlutterの最大の競合は&lt;a class="link" href="https://reactnative.dev/" target="_blank" rel="noopener"
>React Native&lt;/a>だと言えるかなと思いますが、それも最近のトレンドを見ると少しづつ逆転してきているような気がします。もちろんこれはあくまでも「クロスプラットフォーム用のフレームワーク」という基準での比較であり、実際は色々と複雑な事情があるでしょう。例えば、フロントエンドエンジニアがモバイルの開発も担当していて、フロントエンドのライブラリとしてはReactを使っているなどの状況を考えると、ここでいきなりFlutterを採用する可能性は低くなるはずですので。&lt;/p>
&lt;p>自分が思うにDartの最大の問題は、その最初の意図(JavaScriptを代替するという)はともかく、言語そのものの印象が薄いということです。少しだけ触ってみた感覚では、いわゆるC-Family言語としての馴染みはあっても、特段ここが魅力的だというところはあまり感じ取れなかったです。それが今はFlutterのおかがで使用率は上がってきていますが、それ以外の分野ではどうかなという疑問がまだあります。&lt;/p>
&lt;h3 id="可能性は他にもあるかもだけど">可能性は他にもあるかもだけど
&lt;/h3>&lt;p>ただ、以前からGoogleの次世代OSである&lt;a class="link" href="https://fuchsia.dev/" target="_blank" rel="noopener"
>Fuchsia&lt;/a>ではメインの開発環境となるという噂もあり、FuchsiaそのものがどんなOSになるかはまだ不明な状態ですが、もし噂通りAndroidの次世代のOSになるとしたら、ネイティブの開発そのものがDartによるものにもなり得る可能性はありますね。もしそうなると、ChromeOSを含めレガシーの環境を捨てることになるので、公式の開発の言語にKotlinを指定した時とは比べ物にならないインパクトがあることを想定すると、なかなか想像できない事態です。&lt;/p>
&lt;p>もちろんDartもプログラミング言語なので、これからのフレームワークやライブラリの開発次第でいくらでも状況は変わる可能性があります。&lt;a class="link" href="https://github.com/yissachar/awesome-dart" target="_blank" rel="noopener"
>こちらのリポジトリ&lt;/a>を参照すると、サーバサイドのフレームワークもすでにいくつか存在しているので、自分の考えているKotlinで全てを解決する、という目標においてはむしろDartの方がやりやすい可能性がありますね。Kotlinの方だと&lt;a class="link" href="https://kotlinlang.org/lp/mobile/" target="_blank" rel="noopener"
>Kotlin/Multiiplatform Mobile&lt;/a>がありますが、これはどちらかというとビジネスロジックの共通化を目標としているものなので、結局iOSのコードを書く必要があります。もちろん、一部の企業でやっているように「UIはFlutterで、ビジネスロジックはネイティブで」ということもできるかとは思いますが、あまりメジャーなやり方にならないかなと思います。実際、Swiftの場合も&lt;a class="link" href="https://vapor.codes/" target="_blank" rel="noopener"
>Vapor&lt;/a>のようなフレームワークがあり、サーバサイドでも十分使えるということをアピールしていますが、採用しているエンジニアや企業が限りなく少ないというのを見ると、単純に「できる」だけでは十分ではなさそうですので。&lt;/p>
&lt;h3 id="モバイルでも強くなっていく">モバイルでも強くなっていく
&lt;/h3>&lt;p>特に今年開催された&lt;a class="link" href="https://io.google/2022/intl/ja/" target="_blank" rel="noopener"
>Google I/O&lt;/a>で確認できるように、Flutter 3ではさらにパフォーマンスの向上やFlutter Desktopの正式リリースなど様々な面での発展を見せていて、これからもFlutterの未来は明るく見えます。Flutterを採用している企業も増えてきているので、このような発展の恩恵を受け入れるのは結局時間の問題に過ぎない気がします。もちろん、ネイティブアプリの開発においても需要はこれからもあり得ると思いますが、クロスプラットフォームアプリでも事足りる分野が増えてくるとしたら、どちらがメインストリームになるかは目に見えるようなものですね。&lt;/p>
&lt;p>このような状況では、今の占有率においてKotlinのホームグラウンドとなっていると言っても過言ではないモバイルの分野で、Flutterの成長ぶりはある意味、Kotlinにおいては脅威のようなものではないかという気がします。なので、これからKotlinならではのメリットをより強化していく必要がありそうですね。先の述べたKotlin/Multiplatform Mobileのようなものが、その役割をしてくれるのではないかと期待しています。そのほかでも、Kotlinでできることは多いので、分野を問わない連携を強化していくと十分Kotlinを利用するメリットはこれからも出てくるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回は、いつもと違って自分の考えが中心になる記事なので、色々と偏った判断があるかもしれませんが、とりあえずKotlinエンジニアとしての感想をまとめてみました。もちろん、自分の知見が足りてなく、モバイルやフロントエンド、データサイエンティスト、DevOpsエンジニアなど色々な分野で活躍されている方からしたら色々と間違っているか、的確ではない情報や判断も目立つかなとも思います。&lt;/p>
&lt;p>ただ、一人のエンジニアとして、ただの時流を淡々と見つめているよりは、目指す目標に対して使っている技術や興味のいくものに注目し、自分なりの判断をしてみるのもまた必要なものではないかという気がして、このような記事を作成することになりました。また、このような記事を作成することで、この後に色々な変化があって自分の展望がどれだけあっているか、実際と比べてみるのもまた有意義な振り返りとなりそうな気もします。&lt;/p>
&lt;p>今回はあまり情報がなく、Twitterにでもつぶやいたら良いかも知れない雑談に近いものですが、少しでもここでKotlinのことを改めて認識できたという方がいらっしゃるなら幸いです。&lt;/p>
&lt;p>では、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a class="link" href="https://spectrum.ieee.org/top-programming-languages" target="_blank" rel="noopener"
>IEEE Spectrum&lt;/a>、&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE&lt;/a>、&lt;a class="link" href="https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-programming-scripting-and-markup-languages" target="_blank" rel="noopener"
>Stack Overflow&lt;/a>、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/#Main_programming-languages" target="_blank" rel="noopener"
>Jetbrains&lt;/a>の調査結果を参照しました。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Warm(アイドルインスタンスを常に立ち上げておく)で対応できる部分ではありますが、スケールアウトするとコールドスタートが必要となる場合があり、インスタンスを立ち上げておくことでコストがかかる問題は避けられないですね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>Dartのような言語でJavaScriptを代替しようとした歴史がありますが、今は失敗していて、JavaScriptがより高度化した今はTypeScriptのようなスーパーセットやJavaScriptにトランスパイルできる言語でないとフロントエンドの言語を代替するのは難しいかと思われます。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>PyQtで字幕翻訳ツールを作ってみた</title><link>https://retheviper.github.io/posts/python-qt-app/</link><pubDate>Sun, 01 May 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/python-qt-app/</guid><description>&lt;img src="https://retheviper.github.io/images/python.webp" alt="Featured image of post PyQtで字幕翻訳ツールを作ってみた" />&lt;p>最近友人がYoutubeのチャンネルを始めました。主に海外のYoutubeのチャンネルにアップされてあるドラマのメイキングやインタビュー動画などに字幕をつけて配信するというチャンネルですが、そこで毎回字幕を作るのはかなりめんどくさい作業なので、ちょっとしたコマンドaliasとして作成して提供することにしました。元の動画には原語の字幕がついていて、編集用ツールでそれを読み込むことができるらしいので動画だけでなく字幕もダウンロードするコマンドを作成しています。これなら翻訳した字幕ファイルを編集ツールで読み込んで使えるので、かなり作業量が減りました。&lt;/p>
&lt;p>ただ、チャンネルの登録者数が増えながら、中には色々な国からの人もいたようで、友人から「自動翻訳を使って多国語の字幕を追加できる手段が欲しい」という依頼が来ました。簡単なツールを作れば良さそうだったので、早速ツールを作って公開することになったので、今回はそのツールを作った話をしたいと思います。&lt;/p>
&lt;h2 id="設計">設計
&lt;/h2>&lt;p>まずは友人の要望と、技術スタック、アプリの基本設計を行いました。といっても、複雑なことはあまりしたくなかったので、（友人の）やりたいことをベースに、自分がやってみたいことを混ぜたくらいのレベル感です。&lt;/p>
&lt;h3 id="字幕">字幕
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtube-dl.org/" target="_blank" rel="noopener"
>youtube-dl&lt;/a>や&lt;a class="link" href="https://github.com/yt-dlp/yt-dlp" target="_blank" rel="noopener"
>yt-dlp&lt;/a>を使ってYouTubeの動画をダウンロードする際、元の動画に字幕がついてある場合はオプションを追加することで字幕も落とせます。Youtubeで字幕をダウンロードすると、多くの場合ファイル形式が&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/API/WebVTT_API" target="_blank" rel="noopener"
>WebVTT&lt;/a>になるので、とりあえず&lt;code>.vtt&lt;/code>形式のファイルに対応する必要があると思いました。他のフォーマットまで対応するには時間がかかりそうだったので、まずはこれのみにします。&lt;/p>
&lt;p>幸い、実際の字幕ファイルを落としてみたところ、フォーマットはシンプルで(&lt;a class="link" href="https://ja.wikipedia.org/wiki/SubRip" target="_blank" rel="noopener"
>SubRip&lt;/a>とほぼ一緒)、翻訳は字幕が表示される時間の次の行の文字列と、その行のインデックスとともに取ればなんとか入れ替えができそうな気がしました。実際のファイルは以下のようなフォーマットで作成されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-vtt" data-lang="vtt">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">WEBVTT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">00:01.000&lt;/span> &lt;span style="color:#f92672">--&amp;gt;&lt;/span> &lt;span style="color:#e6db74">00:04.000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>液体窒素を絶対に飲まないでください。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">00:05.000&lt;/span> &lt;span style="color:#f92672">--&amp;gt;&lt;/span> &lt;span style="color:#e6db74">00:09.000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- それはあなたの胃に穴をあけます。
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- あなたは死ぬ可能性があります。
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="言語翻訳api">言語翻訳API
&lt;/h3>&lt;p>翻訳についてはGoogle翻訳もありますが、友人の要請によって&lt;a class="link" href="https://papago.naver.com/" target="_blank" rel="noopener"
>Papago&lt;/a>を使うことにしました。幸いAPIを無料で利用できて、PythonのサンプルコードやAPIの詳細も提供されていたのであまり利用は難しくはい感じでした。事前にPostmanでAPIを実行してみてからこちらを採用することにしました。&lt;/p>
&lt;h3 id="技術">技術
&lt;/h3>&lt;p>まずPythonで作ることにしました。この規模の小さいアプリは、Kotlinがメインの私でもPythonで書きたいと思っています。JVMだと起動が遅くなるのもあり、テキストを扱うだけでCPUの処理がクリティカルな作業でもないためパフォーマンスを考慮する必要もあまりありません。そして既にPythonでファイルを読み込んだり、ファイルを編集するなど色々とCLI用のツールを作っていたので「ファイルを読み込んで、編集して、保存する」という最重要の機能がすぐに実装できそうと思いました。&lt;/p>
&lt;p>ただ、自分が使うものならCLI上でも十分使えますが、友人が使うものなのGUIを実装することにしました。Pythonは&lt;code>.py&lt;/code>ファイルで渡すと、Pythonとスクリプトのdependencyのインストールが必要となるなどエンジニアではない人が触るには不便なところがあるので、成果物は&lt;a class="link" href="https://pyinstaller.org/en/stable/" target="_blank" rel="noopener"
>PyInstaler&lt;/a>などで実行できるバイナリにします。&lt;/p>
&lt;p>GUIに関しては&lt;a class="link" href="https://pysimplegui.readthedocs.io/en/latest/" target="_blank" rel="noopener"
>PySimpleGUI&lt;/a>を使ったことがありますが、今回は違うフレームワークを使ってみたいと思いました。PythonのGUIフレームワークといえば&lt;a class="link" href="https://docs.python.org/ja/3/library/tkinter.html" target="_blank" rel="noopener"
>tkinter&lt;/a>や&lt;a class="link" href="https://kivy.org" target="_blank" rel="noopener"
>Kivy&lt;/a>、&lt;a class="link" href="https://www.wxpython.org/" target="_blank" rel="noopener"
>wxPython&lt;/a>、&lt;a class="link" href="https://www.libavg.de/site/" target="_blank" rel="noopener"
>Libavg&lt;/a>など様々なものがあるのですが、中でも&lt;a class="link" href="https://www.qt.io/" target="_blank" rel="noopener"
>Qt&lt;/a>がPythonだけでなく色々と使われているので、PythonのコードだけでなくC++のコードでも参考できる例が多いのではないかと思い&lt;a class="link" href="https://wiki.python.org/moin/PyQt" target="_blank" rel="noopener"
>PyQt&lt;/a>の方を選びました。&lt;/p>
&lt;p>プロダクションレベルのものを作るならまた色々と基準を持って検討してみたかもしれませんが、このような趣味レベルのコードを書く場合はなるべく手軽に書ける、サンプルの多いものを選ぶのがちょうど良いかもですね。効率というのも大事なので。&lt;/p>
&lt;h2 id="コード">コード
&lt;/h2>&lt;h3 id="ファイル読み込み">ファイル読み込み
&lt;/h3>&lt;p>まずはファイルを読み込むところから始めます。&lt;code>.vtt&lt;/code>ファイルはヘッダーに字幕の情報（言語コードなど）が書かれていて、その次からは字幕が表示される時間と字幕の文字列が繰り返されます。&lt;/p>
&lt;p>素直に全行を読み込んでも良いかもですが、翻訳のAPIを呼び出すときに一日で利用できる文字数の制限というのがあったので、極力リクエストにのせるデータは減らしたかったです。なので、後で入れ替えするためのもとのファイルのデータと、翻訳のためAPIのリクエストパラメータにのせる二つのデータにわけで読み込むようにしました。いかがそのコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># get original contents from vtt file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_content&lt;/span>(self, file_path: str):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exported_contents: dict[int, str] &lt;span style="color:#f92672">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> source
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(file_path, &lt;span style="color:#e6db74">&amp;#39;r&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> file:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> original_contents: list[str] &lt;span style="color:#f92672">=&lt;/span> file&lt;span style="color:#f92672">.&lt;/span>readlines()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> index, line &lt;span style="color:#f92672">in&lt;/span> enumerate(original_contents):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> content &lt;span style="color:#f92672">=&lt;/span> line&lt;span style="color:#f92672">.&lt;/span>strip()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> source &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span> &lt;span style="color:#f92672">and&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Language:&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> content:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> source &lt;span style="color:#f92672">=&lt;/span> content&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">&amp;#39;:&amp;#39;&lt;/span>)[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>strip()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#e6db74">&amp;#39;--&amp;gt;&amp;#39;&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#f92672">in&lt;/span> content &lt;span style="color:#f92672">and&lt;/span> content &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exported_contents[index] &lt;span style="color:#f92672">=&lt;/span> content
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> original_contents, exported_contents
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>APIのパラメータには元の言語(source)と、翻訳したい言語(target)が必要となるので、Global変数として字幕のヘッダにある言語情報を&lt;code>source&lt;/code>に格納、翻訳したい行はインデックスと文字列をdictionaryとして格納します。そして最終的に元のデータと、翻訳対象のデータを返します。&lt;/p>
&lt;h3 id="翻訳apiの呼び出し">翻訳APIの呼び出し
&lt;/h3>&lt;p>抽出したデータのうち、翻訳対象のデータを渡してAPIを呼び出す部分です。APIには「1秒当たり10件のリクエストを許容」するという制約があり、翻訳した文字列を一行づつ送って翻訳してもらいながら、リクエストごとに120msを待つようにしました。基本的には&lt;a class="link" href="https://docs.python-requests.org/en/latest/" target="_blank" rel="noopener"
>Requests&lt;/a>を使ってPOSTしているだけですが、もしエラーが返ってきたときはalertを表示してアプリを即終了するようにしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># send translate request to papago and get translated message&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">send_request&lt;/span>(self, contents: dict[int, str]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> translated_contents: dict[int, str] &lt;span style="color:#f92672">=&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headers &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;X-Naver-Client-Id&amp;#39;&lt;/span>: client_id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;X-Naver-Client-Secret&amp;#39;&lt;/span>: client_secret,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Content-Type&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;application/x-www-form-urlencoded; charset=UTF-8&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> index, content &lt;span style="color:#f92672">in&lt;/span> contents&lt;span style="color:#f92672">.&lt;/span>items():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> payload &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;text&amp;#39;&lt;/span>: content,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;source&amp;#39;&lt;/span>: source,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;target&amp;#39;&lt;/span>: target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response &lt;span style="color:#f92672">=&lt;/span> requests&lt;span style="color:#f92672">.&lt;/span>post(api_url, headers&lt;span style="color:#f92672">=&lt;/span>headers, data&lt;span style="color:#f92672">=&lt;/span>payload)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>status_code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body &lt;span style="color:#f92672">=&lt;/span> response&lt;span style="color:#f92672">.&lt;/span>json()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> translated_text: str &lt;span style="color:#f92672">=&lt;/span> body[&lt;span style="color:#e6db74">&amp;#39;message&amp;#39;&lt;/span>][&lt;span style="color:#e6db74">&amp;#39;result&amp;#39;&lt;/span>][&lt;span style="color:#e6db74">&amp;#39;translatedText&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> translated_contents[index] &lt;span style="color:#f92672">=&lt;/span> translated_text
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># wait for API&amp;#39;s limitation(only 10 request per second allowed)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">0.12&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msgBox &lt;span style="color:#f92672">=&lt;/span> QMessageBox()&lt;span style="color:#f92672">.&lt;/span>critical(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Error&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response&lt;span style="color:#f92672">.&lt;/span>json()[&lt;span style="color:#e6db74">&amp;#39;errorMessage&amp;#39;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buttons&lt;span style="color:#f92672">=&lt;/span>QMessageBox&lt;span style="color:#f92672">.&lt;/span>StandardButton&lt;span style="color:#f92672">.&lt;/span>Abort
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> msgBox &lt;span style="color:#f92672">==&lt;/span> QMessageBox&lt;span style="color:#f92672">.&lt;/span>StandardButton&lt;span style="color:#f92672">.&lt;/span>Abort:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">255&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> translated_contents
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルの保存">ファイルの保存
&lt;/h3>&lt;p>ロジックとしてはここが最後です。元のファイルのある場所に翻訳された字幕ファイルを保存するために、元のファイルのパス、翻訳したものに入れ替えるための元のデータ、そしてAPIで翻訳した結果のデータを渡します。&lt;/p>
&lt;p>基本的に翻訳したデータにはインデックスがkeyとして入っているので、そのキーを持って元のデータを入れ替えていきます。ここでヘッダには元の言語のコードが入っているので、翻訳した言語のコードに入れ替えます。そしてファイル名にも同じく言語のコードが入っているので、これもまた変えておきます。&lt;/p>
&lt;p>全てのデータが入れ替えられ、ファイル名を決めたら保存して終了です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># write translated contents to file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">write_result&lt;/span>(self, file_path: str, original_contents: list[str], translated_contents: dict[int, str]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> contents &lt;span style="color:#f92672">=&lt;/span> original_contents&lt;span style="color:#f92672">.&lt;/span>copy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> index, content &lt;span style="color:#f92672">in&lt;/span> translated_contents&lt;span style="color:#f92672">.&lt;/span>items():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Language:&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> content:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> contents[index] &lt;span style="color:#f92672">=&lt;/span> content&lt;span style="color:#f92672">.&lt;/span>replace(source, target) &lt;span style="color:#f92672">+&lt;/span> line_separator
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> contents[index] &lt;span style="color:#f92672">=&lt;/span> content &lt;span style="color:#f92672">+&lt;/span> line_separator
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> root &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>dirname(file_path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file_name &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>basename(file_path)&lt;span style="color:#f92672">.&lt;/span>replace(source, target)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target_file_path &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>join(root, file_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(target_file_path, &lt;span style="color:#e6db74">&amp;#39;w&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> file:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file&lt;span style="color:#f92672">.&lt;/span>writelines(contents)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルドロップダウン">ファイルドロップダウン
&lt;/h3>&lt;p>せっかくGUIを使っているので、&lt;a class="link" href="https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QListWidget.html" target="_blank" rel="noopener"
>QListWidget&lt;/a>にファイルをDrag &amp;amp; Dropすると勝手にファイル名が画面に表示され、翻訳対象にもなるようにしたかったです。ここはあまり自分がQtに詳しくないので、ネットで検索したものを流用しました。&lt;/p>
&lt;p>基本的にはファイルをDrag &amp;amp; Dropすると、拡張子が&lt;code>.vtt&lt;/code>の場合にリストに追加されます。ここでファイルのフルパスを得ることができるのですが、画面上はファイル名だけを見えるようにして、フルパスは別のグローバル変数に格納するようにしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># drop down file list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FileListView&lt;/span>(QListWidget):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">__init__&lt;/span>(self, parent&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> super(FileListView, self)&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">__init__&lt;/span>(parent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>setAcceptDrops(&lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">dragEnterEvent&lt;/span>(self, event):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> event&lt;span style="color:#f92672">.&lt;/span>mimeData()&lt;span style="color:#f92672">.&lt;/span>hasUrls:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> event&lt;span style="color:#f92672">.&lt;/span>accept()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> event&lt;span style="color:#f92672">.&lt;/span>ignore()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">dragMoveEvent&lt;/span>(self, event):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> event&lt;span style="color:#f92672">.&lt;/span>mimeData()&lt;span style="color:#f92672">.&lt;/span>hasUrls:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> event&lt;span style="color:#f92672">.&lt;/span>accept()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> event&lt;span style="color:#f92672">.&lt;/span>ignore()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">dropEvent&lt;/span>(self, event):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> event&lt;span style="color:#f92672">.&lt;/span>mimeData()&lt;span style="color:#f92672">.&lt;/span>hasUrls:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> event&lt;span style="color:#f92672">.&lt;/span>accept()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> url &lt;span style="color:#f92672">in&lt;/span> event&lt;span style="color:#f92672">.&lt;/span>mimeData()&lt;span style="color:#f92672">.&lt;/span>urls():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file_path &lt;span style="color:#f92672">=&lt;/span> url&lt;span style="color:#f92672">.&lt;/span>toLocalFile()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> file_path&lt;span style="color:#f92672">.&lt;/span>endswith(&lt;span style="color:#e6db74">&amp;#39;.vtt&amp;#39;&lt;/span>) &lt;span style="color:#f92672">and&lt;/span> str(file_path) &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#f92672">in&lt;/span> original_files:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># add file path to list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> original_files&lt;span style="color:#f92672">.&lt;/span>append(str(file_path))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># add file name to file list view&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>addItem(file_path&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span>)[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> event&lt;span style="color:#f92672">.&lt;/span>ignore()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイル削除">ファイル削除
&lt;/h3>&lt;p>リストにファイルを追加したら削除したい場合もあるかと思ったので、リストからファイルを選択してボタンを押すとリストから消えるようにしたかったです。これは以下のようなコードで実現しています。ボタンをクリックすると、リストで選択したものが消え、翻訳対象（フルパス）からも消えるようにしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># create remove button&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">create_remove_button&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> button &lt;span style="color:#f92672">=&lt;/span> QPushButton()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> button&lt;span style="color:#f92672">.&lt;/span>setText(&lt;span style="color:#e6db74">&amp;#39;Remove file&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> button&lt;span style="color:#f92672">.&lt;/span>clicked&lt;span style="color:#f92672">.&lt;/span>connect(self&lt;span style="color:#f92672">.&lt;/span>remove_file)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> button
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># remove file from file list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">remove_file&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> original_files
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> selected_item &lt;span style="color:#f92672">in&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>list_view&lt;span style="color:#f92672">.&lt;/span>selectedIndexes():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> index &lt;span style="color:#f92672">=&lt;/span> selected_item&lt;span style="color:#f92672">.&lt;/span>row()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>list_view&lt;span style="color:#f92672">.&lt;/span>takeItem(index)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> original_files&lt;span style="color:#f92672">.&lt;/span>pop(index)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="言語選択">言語選択
&lt;/h3>&lt;p>元の字幕ファイルの言語はヘッダから抽出できるのですが、どの言語に翻訳したいかは自分で選べるようにしました。ここは翻訳APIの使用を参考にして、翻訳可能な言語のコードをdictionaryとしています。あえてdictionaryとしている理由は、&lt;a class="link" href="https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QComboBox.html" target="_blank" rel="noopener"
>QComboBox&lt;/a>のアイテムは画面に見えるものなので実際の言語名にしたかったからです。アイテムがdictionaryのキーとなっているので、選択したアイテムに対応するvalueが翻訳したい言語となるようにしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># languages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>supported_language_code: dict[str, str] &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Korean&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;ko&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;English&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;en&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Japanese&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;ja&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Chinese(China)&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;zh-CN&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Chinese(Taiwan)&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;zh-TW&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Vietnamese&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;vi&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Indonesian&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;id&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Thailand&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;th&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;German&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;de&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Russian&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;ru&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;Spanish&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;es&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;French&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;fr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># create drop down menu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">create_target_language_selector&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> label &lt;span style="color:#f92672">=&lt;/span> QLabel()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> label&lt;span style="color:#f92672">.&lt;/span>setText(&lt;span style="color:#e6db74">&amp;#39;Select target language&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector &lt;span style="color:#f92672">=&lt;/span> QComboBox()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector&lt;span style="color:#f92672">.&lt;/span>addItems(supported_language_code&lt;span style="color:#f92672">.&lt;/span>keys())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selector&lt;span style="color:#f92672">.&lt;/span>textActivated&lt;span style="color:#f92672">.&lt;/span>connect(self&lt;span style="color:#f92672">.&lt;/span>set_target_language)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> label, selector
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># set translate target language when dropdown menu selected&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">set_target_language&lt;/span>(self, selectd: str):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> supported_language_code
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target &lt;span style="color:#f92672">=&lt;/span> supported_language_code[selectd]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="翻訳ボタン">翻訳ボタン
&lt;/h3>&lt;p>最後に翻訳ボタンを追加して、実際の翻訳はボタンを押下した時に行われるようにしました。ボタンを押すと、翻訳対象のファイルのパスをループしながらデータの読み込み、元の言語と翻訳したい言語が違うと翻訳APIの呼び出し、結果の保存という作業を行うようになっています。念の為処理が行われる間はこのボタンを非活性化するという処理も追加しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># create translate button&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">create_translate_button&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>translate_button &lt;span style="color:#f92672">=&lt;/span> QPushButton()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>translate_button&lt;span style="color:#f92672">.&lt;/span>setText(&lt;span style="color:#e6db74">&amp;#39;Translate&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>translate_button&lt;span style="color:#f92672">.&lt;/span>clicked&lt;span style="color:#f92672">.&lt;/span>connect(self&lt;span style="color:#f92672">.&lt;/span>translate_files)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>translate_button&lt;span style="color:#f92672">.&lt;/span>setDisabled(&lt;span style="color:#66d9ef">False&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># read vtt file and do translate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">translate_files&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>translate_button&lt;span style="color:#f92672">.&lt;/span>setDisabled(&lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> file_path &lt;span style="color:#f92672">in&lt;/span> original_files:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> original_contents, exported_contents &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>get_content(file_path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> source &lt;span style="color:#f92672">==&lt;/span> target:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> translated_contents &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>send_request(exported_contents)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>write_result(file_path, original_contents, translated_contents)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>translate_button&lt;span style="color:#f92672">.&lt;/span>setDisabled(&lt;span style="color:#66d9ef">False&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実際作ったツールで重要な部分は以上で、全体のソースコードは&lt;a class="link" href="https://github.com/retheviper/PythonTools/blob/master/PapagoVtt/papago_vtt.py" target="_blank" rel="noopener"
>こちらから&lt;/a>確認できます。&lt;/p>
&lt;h2 id="改善したい">改善したい
&lt;/h2>&lt;p>こうやってとりわけ欲しい機能は実現できたのですが、まだ自分がPyQtに慣れてないのもあり、ロジック上でも少し改善したいところは残っていますので、いくつかを挙げてみました。&lt;/p>
&lt;h3 id="テキストをまとめて翻訳する">テキストをまとめて翻訳する
&lt;/h3>&lt;p>翻訳APIの仕様上、リクエストは1秒で10回となっているため、&lt;code>sleep&lt;/code>を入れて一つのリクエスト毎に120msを待つようになっています。I/Oが発生することを考慮するともっと間隔を短くしてよかったかもしれませんが、そもそもの問題は、読み込んだファイルのデータから一行づつ翻訳のリクエストを送っているところです。短い動画でも字幕は数百行となるケースがあるので、こうなった場合は全体の翻訳が終わるまで処理にかなり時間がかかってしまいますね。&lt;/p>
&lt;p>なので、最初はリクエストパラメータに翻訳したいデータを全て送る（dictionaryのvalueを一つのstrにjoinして）方法も考えてみましたが、APIの仕様として明示されてないだけで、リクエストパラメータのサイズには制限があるようでした。だとすると、翻訳したいデータをいくつかのchunkに分けて送るという方法があると思いますが、こうなった場合は最後にファイルを保存するときに入れ替えるデータの行をどうやって判断するか、それをうまく処理するための方法が悩ましくなります。&lt;/p>
&lt;p>この処理のためファイルを翻訳するまでの時間がかなり長くなるので、いつかは解消したいものですが、翻訳した結果をうまくまとめて保存できる方法が思いつくまでは少し時間がかかりそうです。&lt;/p>
&lt;h3 id="プログレスバーを追加する">プログレスバーを追加する
&lt;/h3>&lt;p>今の作りだと、シングルスレッドであるため、一つのファイルに対して処理が行われている間は画面が固まってしまうという問題があります。そもそも処理が遅いので、かなり長い時間を固まっていますが、これはUXの観点ではあまり良くないですね。また、処理がどこまで終わっているかもわからないので、プログレスバーを追加して、一つのファイルおよび全体のリストでどれぐらいの処理が行われているかを視覚化したいと思っています。&lt;/p>
&lt;p>ただ、プログレスバーを追加する場合、スレッドをわけ、さらに何を基準にプログレスバーを動いていくかというロジックを考えなければならないので、そこもまた時間がかかりそうですね。&lt;/p>
&lt;h3 id="ボタンの非活性化">ボタンの非活性化
&lt;/h3>&lt;p>翻訳対象のファイルが追加される前と処理の途中ではボタンを非活性化したいのですが、これもまだうまく実装されていません。処理中に画面が固まってしまうからか、処理の前後でボタンを非活性化するという処理も思い通りにならなかったのでこちらも直したいと思っています。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回はGUIを中心に色々と新しいチャレンジができたので、かなり面白い作業となっています。そしてやはり元がサーバサイドだからか、UI/UXの観点では考慮しきれなかった問題が出てきたり、画面を実装するためにも色々と試行錯誤があったのでこれは良い勉強になっています。PythonとPyQtが優秀だったのでできたものなのですが、これをまたJetpack Composeなどで書き換えてみるとどうなるかなという好奇心もありますね。やはり、普段やってみてないことに挑戦してみるのは自分がエンジニアとして成長するための良い糧となるような気がします。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>JVM言語経験者がGoを触る時のハマりどころ</title><link>https://retheviper.github.io/posts/jvm-to-go/</link><pubDate>Sun, 17 Apr 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jvm-to-go/</guid><description>&lt;img src="https://retheviper.github.io/images/go.webp" alt="Featured image of post JVM言語経験者がGoを触る時のハマりどころ" />&lt;p>JavaとPython、そして少しのJavaScriptの経験してなかった私が、転職先でGoとKotlinを触って1年が経ちました。最近のプログラミング言語は大体収斂進化している傾向があるので、一つの言語ができれば大体他の言語もできる、もしくは読めるようになると言います。&lt;/p>
&lt;p>しかし、言語が違うということは、その設計思想が違うということなので、同じ結果を期待して書いたつもりのコードが全く思い通りにならないケースもあります。理由は大きく二つ、「あの言語ではこうだったから、この言語でもそうだろう」という慣性と「これはこの言語の特別な仕様だろう」という思い込みなのではないかと思います。（実際私がそうでしたが）&lt;/p>
&lt;p>というわけで、今回はJava/Kotlinをバックグラウンドとして持つエンジニアがGoを触るときの落とし穴的な部分を一部紹介したいと思います。あくまで個人的な経験によるものなのですが、これからGoでコードを書くことになる方には少しでも参考になればと思います。&lt;/p>
&lt;h2 id="time">time
&lt;/h2>&lt;p>Goでは時間を扱うためのスタンダードライブラリとして&lt;a class="link" href="https://pkg.go.dev/time" target="_blank" rel="noopener"
>time&lt;/a>が存在していて、以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 現在時間を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 時間を指定して取得(2022-04-01 12:30:00 +0000 UTC)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">someDay&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Date&lt;/span>(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">UTC&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java/Kotlinだとこれに対応するAPIとして&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/package-summary.html" target="_blank" rel="noopener"
>java.time&lt;/a>がありますね。Goと比べて違う点は、「時間」のみでなく、もっと細かい単位でクラスを分けているというところと言えますでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 年度&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Year year &lt;span style="color:#f92672">=&lt;/span> Year.&lt;span style="color:#a6e22e">now&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 年月&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>YearMonth yearMonth &lt;span style="color:#f92672">=&lt;/span> YearMonth.&lt;span style="color:#a6e22e">now&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 年月日&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LocalDate date &lt;span style="color:#f92672">=&lt;/span> LocalDate.&lt;span style="color:#a6e22e">now&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 時間&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LocalDateTime time &lt;span style="color:#f92672">=&lt;/span> LocalDateTime.&lt;span style="color:#a6e22e">now&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、違う点はここだけではありません。当然ながら、言語が違うとライブラリの実装も変わってくるものなので、処理の結果も違うケースがありますね。代表的には、「月」単位の時間を扱う時、実装によってはGoでは意図通りの範囲にならないケースがあります。例えば以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">getOneMonthBefore&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span>) &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 月に -1 を指定して返す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">AddDate&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一件なんの問題もなさそうなコードですが、一部のケースで以下のような問題が発生します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">date&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Date&lt;/span>(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">31&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">UTC&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">oneMonthBefore&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">getOneMonthBefore&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">date&lt;/span>) &lt;span style="color:#75715e">// 2022-03-03&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードの結果が「2月28日」でなく、「3月3日」になるのは、処理が以下のように行われるからです。&lt;/p>
&lt;ol>
&lt;li>&lt;code>2022-03-31&lt;/code>から1ヶ月前の&lt;code>2022-02-31&lt;/code>になる&lt;/li>
&lt;li>&lt;code>2022-02-31&lt;/code>という日付は存在しないので、2月の末日から日付の補正を行う&lt;/li>
&lt;li>2月の末日である28日から、31日の差分ほど日付をプラスする&lt;/li>
&lt;/ol>
&lt;p>というわけで「基準となる月より先月の日付が少ない場合」にこのような結果を得られるわけです。ただ、月末から1ヶ月前というものは、意図としては&lt;code>2022-02-28&lt;/code>を期待するはずですね。人間の思う処理と、実際のコードが算出する結果が違うというのは十分にあり得る状況ですが、&lt;a class="link" href="https://pkg.go.dev/time#Time.AddDate" target="_blank" rel="noopener"
>AddDate&lt;/a>のドキュメントでは上記のような処理になるという話は特に言及されてないので誤解する可能性もあるのかなと思います。&lt;/p>
&lt;p>また、Java/Kotlinで使っている&lt;code>LocalDate&lt;/code>の場合は期待通り&lt;code>2022-02-28&lt;/code>になるので、Java/Kotlinの経験のあるエンジニアが無意識的にこのような問題を起こすコードを書く可能性もあるかなと思います。ちなみに、&lt;code>LocalDate&lt;/code>を使ったコードがGoと違う結果になるのは、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/LocalDate.html#minusMonths-long-" target="_blank" rel="noopener"
>minusMonth()&lt;/a>では最後に以下のメソッドを呼び出すからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> LocalDate &lt;span style="color:#a6e22e">resolvePreviousValid&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> year, &lt;span style="color:#66d9ef">int&lt;/span> month, &lt;span style="color:#66d9ef">int&lt;/span> day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (month) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> day &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">min&lt;/span>(day, IsoChronology.&lt;span style="color:#a6e22e">INSTANCE&lt;/span>.&lt;span style="color:#a6e22e">isLeapYear&lt;/span>(year) &lt;span style="color:#f92672">?&lt;/span> 29 : 28);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 4:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 6:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 9:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 11:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> day &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">min&lt;/span>(day, 30);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LocalDate(year, month, day);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、Goでも3月31日から1ヶ月前の日付が2月28日になるという処理を期待したい場合は、以下の二つの方法を考慮した方がいいかなと思います。&lt;/p>
&lt;ol>
&lt;li>LocalDateと同じく、閏年と月別の末尾を考慮した処理を足す&lt;/li>
&lt;li>&lt;code>AddDate()&lt;/code>で得られた月が基準となるtimeと同じ月である場合、先月の末日を返す&lt;/li>
&lt;/ol>
&lt;p>前者の場合は月を計算した後、上記の&lt;code>resolvePreviousValid()&lt;/code>と同じ処理を足すことで実現でき、後者の場合は、以下のように末日を取得することが可能なので参考にしてください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">date&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">date&lt;/span>.&lt;span style="color:#a6e22e">AddDate&lt;/span>(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">UTC&lt;/span>) &lt;span style="color:#75715e">// 3月0日を指定すると2月28日になる&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="map">map
&lt;/h2>&lt;p>Goで変数を宣言する方式は以下の二つがありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 型だけを宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">intSlice&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 初期化と共に宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">stringSlice&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make([]&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>問題は、宣言の仕方によって要素を足す場合に問題が起こり得るということです。先にsliceの例を見ましょう。&lt;code>var&lt;/code>で宣言した場合でも&lt;code>make()&lt;/code>で初期化した場合でも&lt;a class="link" href="https://pkg.go.dev/builtin#append" target="_blank" rel="noopener"
>append&lt;/a>を使った要素の追加には問題がありません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">intSlice&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// sliceに値を追加する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">intSlice&lt;/span> = append(&lt;span style="color:#a6e22e">intSlice&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// [1]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、mapの場合は&lt;code>var&lt;/code>で宣言すると問題が起こる可能性があります。以下のコードは、nil pointerとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">stringMap&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>]&lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">stringMap&lt;/span>[&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>] = &lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span> &lt;span style="color:#75715e">// panic: assignment to entry in nil map&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは&lt;code>var&lt;/code>で宣言した変数は基本的にnilになるからですね。nilのmapに要素を追加しようとしたのでエラーが発生するのは当たり前ですが、Goland(Intellij)上では警告も表示されず、コンパイルも無事通るので実際にコードを実行するまでこのコードが動くかどうかはわかりません。むしろ、sliceを先に扱っていたなら、nilでもappendできるので「Goではこれでいいのかな」と思い込みやすいかなと思います。&lt;/p>
&lt;p>JavaやKotlinでもインスタンスを生成していないMapに対して要素を足すことはできないのですが、ここはJavaやKotlinの週間というよりは「Goの特殊性」と考えてしまうケースだと思いますので、要注意なところなのではないかと思います。&lt;/p>
&lt;h2 id="switch">switch
&lt;/h2>&lt;p>Goの&lt;a class="link" href="https://gobyexample.com/switch" target="_blank" rel="noopener"
>switch&lt;/a>はJavaとよく似ています。ただ、形が似ているだけで、決定的な違いがあります。まずはJavaのswitchから見ていきましょう。以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">switch&lt;/span> (i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 0:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;zero&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 1:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;one&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 2:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;two&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;else&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaのswitchは、&lt;code>break&lt;/code>を明示的に書かない限り、条件が一致するcaseに分岐されたとしても、その下のcaseでも流れてしますね。なので、上記のコードを実行した結果は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>two
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>else
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは&lt;code>when&lt;/code>式になり、&lt;code>break&lt;/code>なしでも条件と一致するコードブロックを実行することで処理は終了します。例えば以下のようなコードを書くとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> i = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">when&lt;/span> (i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;zero&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;one&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;two&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;else&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実行した結果はJavaと違うのがわかります。省略されているだけで、一つの枝ごとに処理が&lt;code>break&lt;/code>するからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>one
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでGoのswitchの場合はどうなるかを見ていきましょう。形上はJavaと似ていますが、結果もそうでしょうか？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;zero&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;one&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;two&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;else&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードを実行した結果は、Kotlinと同じです。つまり、「one」と出力されるということです。これはGoのswitchもまた、Kotlinと同じく枝ごとに&lt;code>break&lt;/code>するからです。なので、Javaの場合と同じ結果が欲しい場合は、&lt;code>fallthrough&lt;/code>を追加し、次の枝に進むということを明示的に書く必要があります。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;zero&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fallthrough&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;one&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fallthrough&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;two&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fallthrough&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;else&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの経験がある場合、スタイルが似ているのでつい挙動も同じだろうと思って&lt;code>fallthrough&lt;/code>を省略してしまうというケースもあり得るかなと思います。ここは言語が違うだけ使用も違うということなので、要注意ですね。&lt;/p>
&lt;h2 id="if">if
&lt;/h2>&lt;p>Goではif文の条件がおかしいと思われる場合、コンパイルが通りません。例えば以下の例を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Role&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SystemAdmin&lt;/span> = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Operator&lt;/span> = &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Developer&lt;/span> = &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Role&lt;/span> &lt;span style="color:#a6e22e">Role&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SystemAdminかDeveloperではない場合はエラーを返す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">checkRunnableUser&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Role&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">SystemAdmin&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Role&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">Developer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;user is not runnable&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Test_checkRunnableUser&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>{&lt;span style="color:#a6e22e">Name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Role&lt;/span>: &lt;span style="color:#a6e22e">Operator&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">checkRunnableUser&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unexpected error: %s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードをコンパイルしようとする場合、Goland(Intellij)では条件に警告が表示され、コンパイルすると&lt;code>suspect or: u.Role != SystemAdmin || u.Role != Developer&lt;/code>というエラーメッセージが表示されるのを確認できます。エラーメッセージでもわかるように、これはif文の条件が間違っているからですね。「UserのRoleがSystemAdminかDeveloperの場合のみ許容する」という要件を満たすためには、&lt;code>or&lt;/code>ではなく&lt;code>and&lt;/code>を使う必要があります。なので、if文の条件を以下のように修正すると意図通りに動くし、IDE上の警告やコンパイル時のエラーも発生しなくなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SystemAdminかDeveloperではない場合はエラーを返す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">checkRunnableUser&lt;/span>(&lt;span style="color:#a6e22e">u&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Role&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">SystemAdmin&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Role&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">Developer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;user is not runnable&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの場合だと、Intellijでは条件が怪しいという警告は表示されるものの、Kotlinと同じくコンパイル時のエラーは発生しません。なので実行はできるようになりますが、警告の出ている箇所を確認していないと実際に実行してみるまでロジックが間違えていることには気づかなくなりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> Role {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SYSTEM_ADMIN, OPERATOR, DEVELOPER
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>(String name, Role role) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">checkRunnableUser&lt;/span>(User user) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (user.&lt;span style="color:#a6e22e">role&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> Role.&lt;span style="color:#a6e22e">SYSTEM_ADMIN&lt;/span> &lt;span style="color:#f92672">||&lt;/span> user.&lt;span style="color:#a6e22e">role&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> Role.&lt;span style="color:#a6e22e">DEVELOPER&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;user is not runnable&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkRunnableUser(&lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, Role.&lt;span style="color:#a6e22e">SYSTEM_ADMIN&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、問題は同じ処理をKotlinで書いてみると、Intellijで警告が出ることもなく、コンパイルも通るということです。Javaのケースと同じくランタイムでエラーが発生するコードになりますが、警告すら表示されないのでコードを注意深く確認しないと意図通りに動作している理由が何かを見逃しやすくなっているのではないかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Role&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SystemAdmin(&lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Operator(&lt;span style="color:#ae81ff">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Developer(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> name: String, &lt;span style="color:#66d9ef">val&lt;/span> role: Role)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">checkRunnableUser&lt;/span>(user: User) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (user.role &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">Role&lt;/span>.SystemAdmin &lt;span style="color:#f92672">||&lt;/span> user.role &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">Role&lt;/span>.Developer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalAccessException(&lt;span style="color:#e6db74">&amp;#34;user is not runnable&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkRunnableUser(User(name = &lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, role = &lt;span style="color:#a6e22e">Role&lt;/span>.Operator))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルタイムでエラーを事前に検知できるという点は確かにGoのコンパイラの方が優秀かなと思います。ただ、KotlinやJavaに慣れている場合、条件がおかしいということに気づくより、「&lt;code>const&lt;/code>を使っているせいか」「switchを使うべきか」など、問題の本質に気づかないようになる可能性もあるのではないかと思います。&lt;/p>
&lt;p>これは、そもそも正しく条件を書くことが何よりも大事であることでありながら、他の言語で形成された習慣で違う言語のコードを書くと問題を起こし得るということを実例として適切ではないかと思いますね。&lt;/p>
&lt;h2 id="range-loop">Range loop
&lt;/h2>&lt;p>Goのループにはfor文しかないですが、indexを利用する伝統的な形以外でも&lt;a class="link" href="https://go.dev/tour/moretypes/16" target="_blank" rel="noopener"
>Range&lt;/a>でのループがあります。以下のような形で使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">pow&lt;/span> = []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>, &lt;span style="color:#ae81ff">32&lt;/span>, &lt;span style="color:#ae81ff">64&lt;/span>, &lt;span style="color:#ae81ff">128&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">pow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;2**%d = %d\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じ結果を出すコードをKotlinで書くとしたら、以下のようになるかと思います。一目でわかりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// kotlin
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> pow = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>, &lt;span style="color:#ae81ff">32&lt;/span>, &lt;span style="color:#ae81ff">64&lt;/span>, &lt;span style="color:#ae81ff">128&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> ((i, v) &lt;span style="color:#66d9ef">in&lt;/span> pow.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;2**&lt;/span>&lt;span style="color:#e6db74">$i&lt;/span>&lt;span style="color:#e6db74"> = &lt;/span>&lt;span style="color:#e6db74">$v&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Goにはポインタがあり、Range loopでポインタを使おうとすると問題が発生するケースがあります。例えば以下の例をみましょう.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">pow&lt;/span> = []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>, &lt;span style="color:#ae81ff">32&lt;/span>, &lt;span style="color:#ae81ff">64&lt;/span>, &lt;span style="color:#ae81ff">128&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 新しいスライスにpowの参照を格納&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ppow&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">pow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ppow&lt;/span> = append(&lt;span style="color:#a6e22e">ppow&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">v&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ppowの値を出力&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">ppow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;2**%d = %d\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">v&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>想定通りだと、&lt;code>ppow&lt;/code>にはそれぞれ&lt;code>1, 2, 4, 8, 16, 32, 64, 128&lt;/code>の参照が格納されるべきでしょう。しかし、このコードを実行してみると、実際には&lt;code>128&lt;/code>と全て同じ値となっています。Range loopないで参照している値が全部同じアドレスを参照することになるからです。&lt;/p>
&lt;p>なので、ポインタを使うスライスを用いてループの処理をする場合は、以下のように&lt;code>v&lt;/code>を再代入するか、indexによる参照で問題を回避する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">pow&lt;/span> = []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>, &lt;span style="color:#ae81ff">32&lt;/span>, &lt;span style="color:#ae81ff">64&lt;/span>, &lt;span style="color:#ae81ff">128&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 新しいスライスにpowの参照を格納&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">ppow&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">pow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#75715e">// ここでvの値をコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ppow&lt;/span> = append(&lt;span style="color:#a6e22e">ppow&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">v&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ppowの値を出力&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">ppow&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;2**%d = %d\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">v&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>うっかりRange loopを使ってしまうと、ポインタを使うスライスを用いてループの処理をする場合に問題が発生する可能性があるので、気をつけたいですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>幾つかの例を挙げましたが、まだ自分もGoでアプリを書いた歴も短く、言語に対しての理解も深くないのでこれからも色々と問題に遭遇する可能性はあるのかなと思います。その度はまたこうやってブログに載せていきたいと思います。ブログのネタができるという面では嬉しいですが、失敗からのポストは結局自分が辛くなることなので、うれしくはないですね…&lt;/p>
&lt;p>とにかくここであげた問題は全て自分が経験したものですが、大事なのは、違う言語に挑戦するときは自分の持つバックグラウンドの知識を活かしながらも、それを偏見にしたいこと、そして先走らないことかなと思いました。Goに限らず、新しいものに触れるときは常に注意しないと、という感じですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinプログラマが見たRust</title><link>https://retheviper.github.io/posts/rust-first-impression/</link><pubDate>Sun, 27 Mar 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/rust-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/rust.webp" alt="Featured image of post Kotlinプログラマが見たRust" />&lt;p>Rustの勉強を始めたい、と思ったのはおよそ2年前のことです。当時はJavaとPythonを主に触っていたので、パフォーマンスがクリティカルな部分では対応しきれない部分があると思い、ネイティブにコンパイルされる言語に触れてみる必要があると思いました。そしてできれば、GCのなくポインタを扱う言語でアプリを書いてみたら、本業と言えるJavaの理解もより深くなるのではないかと思った次第です。&lt;/p>
&lt;p>そこで候補として考えたのがGoとRustです。ただ、Goは世間の評価はともかく、自分の立場からすると少し追求している目標とずれているところがあるなと思いました。特に転職してからGoとKotlinという言語を並行で触っていると、良くも悪くも自分がやりたいことがなんなのかわかってきた気分にもなったのです。&lt;/p>
&lt;p>そこで、そろそろ次の候補として考えていたRustに触れてみたいと思った次第です。これもまた、世間の評価は置いといて、実際自分に合うかどうかを確認してみたくなりました。最近は色々な言語が扱える&lt;a class="link" href="https://medium.com/@guestposts_92864/what-is-a-polyglot-programmer-and-why-you-should-become-one-e5629bf720c2" target="_blank" rel="noopener"
>Polyglot Programmer&lt;/a>の時代だという概念もあり、多くのプログラミング言語が互いの良いところを吸収しながらどれも似たようなものになったという評価もありますが、私の場合は、あくまで自分に合うのは何かを探るという感覚としてRustという新しい言語を接してみたいと思っています。&lt;/p>
&lt;p>なので、今回はまずこちらの&lt;a class="link" href="https://doc.rust-jp.rs/book-ja/title-page.html" target="_blank" rel="noopener"
>The Rust Programming Language&lt;/a>を読みながら、興味深かった部分について、自分が今まで経験してみた他のプログラミング言語と比べながら感想を述べたいと思います。ドキュメントが長く、自分の理解もまだ浅いのでまずは一部だけを紹介しましょう。&lt;/p>
&lt;h2 id="loop">Loop
&lt;/h2>&lt;p>Rustでは伝統の&lt;code>for&lt;/code>と&lt;code>while&lt;/code>以外にも、ループの条件を指定しない(無限ループ)&lt;code>loop&lt;/code>というのがありました。特定の条件でループを終了したい場合のみ、&lt;code>break&lt;/code>することで終了できます。例えば以下のような形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他の言語だと、普通は&lt;code>while(true)&lt;/code>のような形が多いかと思います。例えばPythonは以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> true:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># do something&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinやJavaでも事情は変わりません。以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合だと、拡張関数があるので&lt;code>loop&lt;/code>というものを定義したらどうかと思いましたが、そうするとコンパイラ上でループだと認識されないので、&lt;code>break&lt;/code>を書くとコンパイルエラーとなります。なので以下のように拡張関数と作ることはできませんでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loop {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#75715e">// コンパイルエラー
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">loop&lt;/span>(doSomething: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doSomething()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合は、&lt;code>for&lt;/code>に条件式を書かないことでシンプルな無限ループを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的に&lt;code>while(true)&lt;/code>や条件式を指定しない&lt;code>for&lt;/code>は、慣習でしかなく、直感的な理解を招くものではないと思いますので、&lt;code>loop&lt;/code>というキーワードを設けた方がコードの可読性という面ではよりわかり安いものなのではないかと思いました。細かい部分ではありますが、一回仕様としてとして決まるとなかなか変更できないものなので、どんなキーワードを使うかを決めるということも言語の設計においては大事だという気がします。&lt;/p>
&lt;h2 id="array">Array
&lt;/h2>&lt;p>Rustでは配列のindexを基準に一部を抽出するとき、以下のような書き方をします。参照(&lt;code>&amp;amp;&lt;/code>)を利用して定義する必要があって、標準出力する形も少し独特ですね。また、indexを指定して切り出したものは「所有権のない別のデータ型」として定義されています。ここで切り抜いた配列の一部を、Rustでは&lt;code>slice&lt;/code>と呼んでいるらしいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> slice &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>arr[&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{:?}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, slice); &lt;span style="color:#75715e">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pythonでもかなり似たような感じでコードが書けます。以下は上記と同じ挙動をするコードの例です。ただ、ここで切り抜いた&lt;code>slice&lt;/code>のデータ型は同じく&lt;code>list&lt;/code>になるというのがRustとの違いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>list &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>slice &lt;span style="color:#f92672">=&lt;/span> list[&lt;span style="color:#ae81ff">1&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(slice) &lt;span style="color:#75715e"># [1, 2]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合は、&lt;a class="link" href="https://kotlinlang.org/docs/collections-overview.html#list" target="_blank" rel="noopener"
>List&lt;/a>の関数に&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html" target="_blank" rel="noopener"
>Range&lt;/a>オブジェクトを渡すことで同じことができます。少し問題になるのは、Kotlin特有の&lt;code>Range&lt;/code>の書き方がどのような範囲を示すのか覚えてないとその範囲が分かりづらいということです。幸い、ここはIntellij Idea 2021.3のアップデートで&lt;a class="link" href="https://blog.jetbrains.com/idea/2021/10/intellij-idea-2021-3-eap-5/#inline_hints_for_ranges" target="_blank" rel="noopener"
>ヒントを表示&lt;/a>してくれるようになったので、これ以前のバージョンを使っている場合はアップデートした方が良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> subList = list.slice((&lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">2&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(subList) &lt;span style="color:#75715e">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> subListUntil = list.slice((&lt;span style="color:#ae81ff">1&lt;/span> until &lt;span style="color:#ae81ff">3&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(subListUntil) &lt;span style="color:#75715e">// [1, 2]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの場合は、インデックスの範囲を&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/List.html#subList-int-int-" target="_blank" rel="noopener"
>List.subList()&lt;/a>に渡すことで同じことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(0, 1, 2, 3, 4);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> subList &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">subList&lt;/span>(1, 3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(subList); &lt;span style="color:#75715e">// [1, 2]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合は、Pythonと全く同じ方法で定義ができますね。また、配列からインデックスの範囲を指定して切り取ったviewを&lt;code>slice&lt;/code>と呼ぶのはRustと一緒です。ただ、Goのsliceはarrayと違って、可変長ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">arr&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">slice&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">arr&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">slice&lt;/span>) &lt;span style="color:#75715e">// [1 2]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="immutability">Immutability
&lt;/h2>&lt;p>Rustでの変数の宣言は基本的に&lt;code>let&lt;/code>一つで、不変になります。もちろん可変できる変数を定義するのは不可能ではなくて、以下のように&lt;code>mut&lt;/code>キーワードを使うことで値を再代入することはできます。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;The value of x is: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, x); &lt;span style="color:#75715e">// The value of x is: 5
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;The value of x is: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, x); &lt;span style="color:#75715e">// The value of x is: 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他のプログラミング言語だと、変数の宣言時にその変数の可変性をあらかじめキーワードで表現するようになっているケースが多いかと思います。もしくは、基本的に変数は可変で、不変にしたい場合にだけ特別なキーワードを使うとかですね。しかし、Rustでは変数は基本的にimmutableであるというのが特徴的です。GCのない言語として、メモリの安全性を確保するための工夫がここで現れていると言っていいでしょうか。&lt;/p>
&lt;p>もちろん、Pythonのように変数の宣言と再代入の区別が付かないケースもありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#34;The value of x is: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(x)) &lt;span style="color:#75715e"># The value of x is: 5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#34;The value of x is: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(x)) &lt;span style="color:#75715e"># The value of x is: 6&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合は不変だと&lt;code>val&lt;/code>、可変だと&lt;code>var&lt;/code>で宣言するようになっていますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> x = &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x = &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#75715e">// コンパイルエラー
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> y = &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>y = &lt;span style="color:#ae81ff">7&lt;/span> &lt;span style="color:#75715e">// OK
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの場合は、Rustと逆です。&lt;code>final&lt;/code>をつけない場合、基本的に再代入ができる構造ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> 6 &lt;span style="color:#75715e">// OK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> 6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>y &lt;span style="color:#f92672">=&lt;/span> 7 &lt;span style="color:#75715e">// コンパイルエラー&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合は、変数をimmutableにできる方法はないようですね。なので、再代入は自由ですが、逆にJavaの&lt;code>final&lt;/code>のようなキーワードが欲しい気分にもなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">x&lt;/span> = &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>) &lt;span style="color:#75715e">// 6&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="shadowing">Shadowing
&lt;/h2>&lt;p>これは全く予想できなかった部分ですが、Rustのドキュメントには変数にシャドーイングを使えると紹介されています。&lt;code>mut&lt;/code>キーワードをつけると再代入は可能なので、それで良いのではという気もしますが、変数を不変にしながら、違うデータ型として定義し直す場合などに使えるという説明でした。&lt;/p>
&lt;p>Rustではシャドーイングを使って以下のようなコードを作成できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// 12
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;The value of x is: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, x); &lt;span style="color:#75715e">// The value of x is: 12
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pythonの場合も似たようなことができます。同じ挙動をするコードを以下のように書くと、問題なく動きます。変数の宣言と再代入が厳密に区別されない故のことかと思いますが、形的にはRustと全く一緒と言えますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#34;The value of x is: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(x)) &lt;span style="color:#75715e"># The value of x is: 12&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合、シャドーイングは一部の場合のみ可能です。関数の引数と、その関数で宣言している変数名が一致する場合ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">shadow&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> value = &lt;span style="color:#66d9ef">value&lt;/span> + &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">// Name shadowed: value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#66d9ef">value&lt;/span>) &lt;span style="color:#75715e">// valの方が出力される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaでは、シャドーイングができないです。ただ、以下のような形は可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Clazz&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setValue&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">=&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合、少し複雑になります。以下の例をみると、&lt;code>x&lt;/code>の宣言と代入を2回していますが、スコープが分かれてあるから可能なことです。Kotlinのケースと似ているとも言えますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Before the decision block, x:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span>) &lt;span style="color:#75715e">// Before the decision block, x: 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;After the decision block, x:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span>) &lt;span style="color:#75715e">// After the decision block, x: 0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、以下のようにif文での&lt;code>x&lt;/code>に対して再代入することで挙動が変わります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Before the decision block, x:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span>) &lt;span style="color:#75715e">// Before the decision block, x: 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span> = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">x&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;After the decision block, x:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span>) &lt;span style="color:#75715e">// After the decision block, x: 2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように他の言語だとなるべく使わないように誘導しているシャドーイングですが、Rustでは一つの機能として紹介しているのが面白いところでした。これもまた、後述する「所有権」というものと強く関係しているような気がします。&lt;/p>
&lt;h2 id="ownership">Ownership
&lt;/h2>&lt;p>他の言語と比べたときに、Rustならではの特徴と言えるものは所有権ではないでしょうか。今まで私はGCのない言語を触ってみたことがないので、これはかなり興味深い概念でした。例えばKotlinの場合はNativeでコンパイルする場合、&lt;a class="link" href="https://blog.jetbrains.com/kotlin/2021/05/kotlin-native-memory-management-update/#kn-gc" target="_blank" rel="noopener"
>参照カウント&lt;/a>を使うと言われています。JavaやPython, Goの場合はGCが働いて参照されていないオブジェクトが占めているメモリを解放することになりますね。&lt;/p>
&lt;p>しかし、Rustでは定数、不動小数点数、論理値、文字というスカラー型を除いた全ての参照型に関しては「一度使われたらメモリは解放される」「スコープを外れたら解放される」という原則を持っているようです。参照型とスカラー型という区分はJavaのプリミティブ型と参照型の関係を思い出させるところがありますね。より積極的かつ攻撃的なメモリ解放が行われるという違いはありますが。&lt;/p>
&lt;p>基本的には一回使った変数に対しては2回使えなかったり、値の変更ができないかと思った方が良い、ということかなと思いますが、他にも色々と興味深いものがありました。&lt;/p>
&lt;h3 id="move">Move
&lt;/h3>&lt;p>所有権と関係する概念で、ムーブがあります。変数とデータが実際どうやって相互作用するかによるものらしいです。早速下のコードを見ていきましょう。なんの問題もなさそうなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> s2 &lt;span style="color:#f92672">=&lt;/span> s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;s1 = &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">, s2 = &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, s1, s2); &lt;span style="color:#75715e">// s1 = hello, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記の&lt;code>String literal&lt;/code>を&lt;code>String&lt;/code>に変えたら問題が起こります。以下のコードを見ましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> s2 &lt;span style="color:#f92672">=&lt;/span> s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">, world!&amp;#34;&lt;/span>, s1);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、コンパイルしようとすると以下のようなエラーが発生します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>error&lt;span style="color:#f92672">[&lt;/span>E0382&lt;span style="color:#f92672">]&lt;/span>: use of moved value: &lt;span style="color:#e6db74">`&lt;/span>s1&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --&amp;gt; src/main.rs:4:27
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> | let s2 &lt;span style="color:#f92672">=&lt;/span> s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | -- value moved here
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> | println!&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;{}, world!&amp;#34;&lt;/span>, s1&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | ^^ value used here after move
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> note: move occurs because &lt;span style="color:#e6db74">`&lt;/span>s1&lt;span style="color:#e6db74">`&lt;/span> has type &lt;span style="color:#e6db74">`&lt;/span>std::string::String&lt;span style="color:#e6db74">`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>which does not implement the &lt;span style="color:#e6db74">`&lt;/span>Copy&lt;span style="color:#e6db74">`&lt;/span> trait
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、&lt;code>s1&lt;/code>のデータが&lt;code>s2&lt;/code>に移動したのでもう使えないということです。なので、二つの変数に同じデータを保証したい場合は、明示的に値をコピーする必要があります。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> s2 &lt;span style="color:#f92672">=&lt;/span> s1.clone();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;s1 = &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">, s2 = &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, s1, s2); &lt;span style="color:#75715e">// s1 = hello, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なぜこうなっているかというと、Rustでは変数がスコープの外に移動するときにメモリの解放が起こりますが、ここで複数の変数が同じポインタを使っている場合は二重解放が起こる危険があるからと説明されています。また、&lt;code>String literal&lt;/code>と違って&lt;code>String&lt;/code>はimmutableではないので、s1の再代入でs2のデータまで変わってしまうという問題を防ぐための意図もあるような気がします。&lt;/p>
&lt;p>実際このような代入が問題となる言語のケースもありますね。例えばPythonの方を見ましょう。二つの変数が同じポインタを使っているので、再代入で両方とも値が変更されたのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s2 &lt;span style="color:#f92672">=&lt;/span> s1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#34;s1 = &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">, s2 = &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(s1, s1)) &lt;span style="color:#75715e"># s1 = hello, s2 = hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(&lt;span style="color:#e6db74">&amp;#34;s1 = &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">, s2 = &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(s1, s1)) &lt;span style="color:#75715e"># s1 = world, s2 = world&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JavaではStringをimmutableとして扱っているため、s1の値を再代入してもs2に影響はありません。KotlinもJVMの場合は、基本的にJVMのバイトコードを生成するためか同じ挙動をします。以下をご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> s1 = &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> s2 = s1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(&lt;span style="color:#e6db74">&amp;#34;s1 = &lt;/span>&lt;span style="color:#e6db74">$s1&lt;/span>&lt;span style="color:#e6db74">, s2 = &lt;/span>&lt;span style="color:#e6db74">$s2&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// s1 = hello, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s1 = &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(&lt;span style="color:#e6db74">&amp;#34;s1 = &lt;/span>&lt;span style="color:#e6db74">$s1&lt;/span>&lt;span style="color:#e6db74">, s2 = &lt;/span>&lt;span style="color:#e6db74">$s2&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// s1 = world, s2 = hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの場合も前述した通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> s2 &lt;span style="color:#f92672">=&lt;/span> s1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;s1 = %s, s2 = %s&amp;#34;&lt;/span>, s1, s2)); &lt;span style="color:#75715e">// s1 = hello, s2 = hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;s1 = %s, s2 = %s&amp;#34;&lt;/span>, s1, s2)); &lt;span style="color:#75715e">// s1 = world, s2 = hello&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goでも変数はimmutableとして定義できませんが、この再代入により値が変わる可能性があるものに対しては安全性を担保されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">s1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">s2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">s1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;s1 = %s, s2 = %s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">s1&lt;/span>, &lt;span style="color:#a6e22e">s2&lt;/span>)) &lt;span style="color:#75715e">// s1 = hello, s2 = hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">s1&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;s1 = %s, s2 = %s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">s1&lt;/span>, &lt;span style="color:#a6e22e">s2&lt;/span>)) &lt;span style="color:#75715e">// s1 = world, s2 = hello&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Rustで明示的にコピーをしない場合はデータそのものが移動してしまうというのは確かにコーディング時には気を使わないといけないものですが、幸いコンパイルタイムで確認できる問題であり、他の言語を扱うときには思わぬ挙動をする可能性がある習慣を矯正してくれる可能性もあるかなと思うと、良い仕様ではなイカという気もしますね。&lt;/p>
&lt;h2 id="closure">Closure
&lt;/h2>&lt;p>Rustではclosureを関数内の関数として定義することももちろん可能ですが、&lt;code>|val| val + x&lt;/code>の形式で書きます。他の言語でlambdaと呼ばわれているものですね。多少は独特な書き方な気もしますが、型の省略が可能なのが他の言語と比べ便利なものな気がします。もちろん型の明示的な表記もできるので、以下のような使い方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// i32の引数を必要とする場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> closure_annotated &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">|&lt;/span>i: &lt;span style="color:#66d9ef">i32&lt;/span>&lt;span style="color:#f92672">|&lt;/span> -&amp;gt; &lt;span style="color:#66d9ef">i32&lt;/span> { i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> closure_inferred &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">|&lt;/span>i &lt;span style="color:#f92672">|&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;closure_annotated: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, closure_annotated(i)); &lt;span style="color:#75715e">// closure_annotated: 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;closure_inferred: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, closure_inferred(i)); &lt;span style="color:#75715e">// closure_inferred: 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 引数がない場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> one &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;closure returning one: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, one()); &lt;span style="color:#75715e">// closure returning one: 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pythonの場合は以下のように書くことができますね。もちろん、関数の中に関数を定義することもできますが、lambdaを使った方がが便利なのかなと思います。ただ、&lt;a class="link" href="https://docs.python.org/3/library/typing.html" target="_blank" rel="noopener"
>3.5から型ヒントを使える&lt;/a>ようになっていて、コンパイルタイムで確実にエラーをチェックしたい場合は明示的に型を書いたほうが良さげな気はします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>closure &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">lambda&lt;/span> x : x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(closure(&lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでも簡単に定義はできるものですが、少なくとも引数の型は書く必要があります。もしくは、変数に型を指定することが必要ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> closure = { x: Int &lt;span style="color:#f92672">-&amp;gt;&lt;/span> x + &lt;span style="color:#ae81ff">1&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(closure(&lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#75715e">// 2
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaではメソッド内にメソッドを定義することができなく、1.8から追加された&lt;code>Functional Interface&lt;/code>を使う必要があります。また10からは&lt;code>var&lt;/code>で型推論を使えるようになりましたが、Functional Interfaceをvarとして宣言するのはできないという制約があります。他の言語と比べると最も制約が多いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Function&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> closure &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(closure.&lt;span style="color:#a6e22e">apply&lt;/span>(1)); &lt;span style="color:#75715e">// 2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Goの場合は関数内に関数を定義するのは不可能ではないものの、他の言語のlambdaのような書き方はできず、匿名関数として定義ができます。また型を明示する必要があるので、名前を除いて完全な関数を定義して変数に代入しているようなものになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">closure&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">closure&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#75715e">// 2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、closureにおいてRustの特徴はもう一つあります。closureを引数とする関数を定義するときの書き方です。closureに対してgenericを使って、whereというキーワードで関数の中にclosureを書いていくような形です。他の言語だとclosureが引数でも書き方は大きく変わらないのですが、Rustでは全く違う形になっているのが興味深いですね。例えば以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Fというclosureを引数とする関数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">apply_to_3&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>F&lt;span style="color:#f92672">&amp;gt;&lt;/span>(f: &lt;span style="color:#a6e22e">F&lt;/span>) -&amp;gt; &lt;span style="color:#66d9ef">i32&lt;/span> &lt;span style="color:#a6e22e">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Fはi32を受け取ってi32を返すclosure
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> F: Fn(&lt;span style="color:#66d9ef">i32&lt;/span>) -&amp;gt; &lt;span style="color:#66d9ef">i32&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> double &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">|&lt;/span>x&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;3 doubled: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, apply_to_3(double)); &lt;span style="color:#75715e">// 3 doubled: 6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>まだドキュメントの半分の読んでなく、実際に何かしらのアプリを作ってみたわけでもないので今回のポストだけでは十分ではないというのは十分承知のつもりですが、久々に違う言語を学びながら、色々と興味深いところが多かったのでひとまず感想を書いてみました。&lt;/p>
&lt;p>噂ではRustのコンパイラは優秀で、そのコンパイラの指示通りにアプリを組むだけでのかなり勉強になる瞬間が多いというのと、言語自体の設計が良いという話だったので、これからも勉強しながら気づいたことや感じたこと、学んだことについてブログにまとめていきたいと思います。今回のポストだけでの企画として終わらせたくないので、今年はこれで頑張っていきたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Effective Kotlinを読む</title><link>https://retheviper.github.io/posts/effective-kotlin/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/effective-kotlin/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Effective Kotlinを読む" />&lt;p>今回は久々に本を読んだのでそれに関する感想を少し書こうと思います。転職前は主にJavaを扱っていたため、&lt;a class="link" href="https://www.amazon.co.jp/Effective-Java-%E7%AC%AC3%E7%89%88-%E3%82%B8%E3%83%A7%E3%82%B7%E3%83%A5%E3%82%A2%E3%83%BB%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF-ebook/dp/B099922DML/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=1OT3QRYCGG9BB&amp;amp;keywords=Effective&amp;#43;Java&amp;amp;qid=1645265607&amp;amp;sprefix=effective&amp;#43;kotlin%2Caps%2C753&amp;amp;sr=8-1" target="_blank" rel="noopener"
>Effective Java&lt;/a>を読み自分の書いたコードを振り返って見たことがありました。転職後はKotlinという違う言語を触るようになったものの、やはりJVMで動く言語であり、現在使っているフレームワークもSpringから変わってないので基本的には同じ観点でコードを作成すると良いのかなと思っていました。しかし、Kotlinに触れてから1年が経った今、やはり言語が違うとコードを作成するときの週間も一度は見直す必要があるのではないかと思っています。&lt;/p>
&lt;p>そこで、ちょうど&lt;a class="link" href="https://www.amazon.co.jp/Effective-Kotlin-Best-practices-English-ebook/dp/B08WXCRVD2/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=2HVT6TZYJL65A&amp;amp;keywords=effective&amp;#43;kotlin&amp;amp;qid=1645264802&amp;amp;sprefix=effective&amp;#43;kotli%2Caps%2C230&amp;amp;sr=8-1" target="_blank" rel="noopener"
>Effective Kotlin&lt;/a>という本を発見したので早速読んでみました。そして今回のポストではその内容について色々と書こうと思います。&lt;/p>
&lt;p>ちなみに、この本自体は出版されて少し経つので、ネット上でもたまにその内容やPDFの資料などを発見することあができました。例えば、この本で「可読性」のチャプタに関しての話は[こちらのブログ]の方によく整理されてあるので、参考にしてください。&lt;/p>
&lt;h2 id="全体的な印象">全体的な印象
&lt;/h2>&lt;p>個人的に&lt;code>Effective Java&lt;/code>は上級者向けの本で、ある程度Javaでアプリを書いたこと経験のある人でないと理解が難しいところが多かったかなと思います。例えば、「&lt;code>try-finally&lt;/code>を
&lt;code>try-with-resource&lt;/code>に代替した方がいい」とか、「&lt;code>Stream&lt;/code>で副作用のない関数を書く方法」などが紹介されていますが、これらはやはりある程度Javaという言語の設計と仕様に対する基盤知識を必要とするものですね。&lt;/p>
&lt;p>それに比べ、&lt;code>Effective Kotlin&lt;/code>には初心者向けの内容も結構あります。例えば、そもそものオブジェクト志向が何かのような内容がありました。ただそれだけではどう思っても&lt;code>Effective Java&lt;/code>を意識したような題名が意味をなくすと判断したからか（前書きでも&lt;code>Effective Java&lt;/code>を言及しています）他には「ベストプラクティス」として書かれているものも多いです。&lt;/p>
&lt;p>そして当たり前ながら、Kotlinにおいても有効なことは&lt;code>Effective Java&lt;/code>と重なっているような部分もあります。例えば、オブジェクトのインスタンスを作るときはfactory methodを書いた方が良いとかがそうですね。&lt;/p>
&lt;p>ただ、Kotlinのバージョンアップの速さに追いついてないと感じるところがあったり（これは出版物の限界でもありますが）、上級者向けの内容は多少十分ではない感覚でしたので、どちらかというとジュニア向けの感覚ではあります。&lt;/p>
&lt;h2 id="興味深い">興味深い
&lt;/h2>&lt;p>ジュニア向けといいつつ、自分もまだジュニア（の気持ち）であるため、興味深いと思ったところもありました。ここでその一部を紹介したいと思います。&lt;/p>
&lt;h3 id="single-responsibility-principle">Single responsibility principle
&lt;/h3>&lt;p>いわゆる&lt;a class="link" href="https://ja.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener"
>SOLID&lt;/a>に触れるパートです。Kotlinでは拡張関数を用いることで、単一責任の原則を守れるという主張をしていました。まず以下のようなケースがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">isPassing&lt;/span>(): Boolean =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calculatePointsFromPassedCourses() &amp;gt; &lt;span style="color:#ae81ff">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">qualifiesForScholarship&lt;/span>(): Boolean =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calculatePointsFromPassedCourses() &amp;gt; &lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculatePointsFromPassedCourses&lt;/span>(): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>isPassing()&lt;/code>は&lt;code>accreditations&lt;/code>というモジュールで、&lt;code>qualifiesForScholarship()&lt;/code>は&lt;code>scholarship&lt;/code>というモジュールで使われるとします。そしたら、&lt;code>Student&lt;/code>というクラスがこれらの関数を持つのは単一責任としてどうか、ということですね。&lt;/p>
&lt;p>なので、モジュール別にこれらの関数を拡張関数として定義することが良いとのことでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// scholarship module
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>.qualifiesForScholarship(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// accreditations module
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>.calculatePointsFromPassedCourses(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしくは&lt;code>calculatePointsFromPassedCourses()&lt;/code>を外に出す方法を考えられるでしょう。しかし、この場合はこれらの二つのメソッド専用のprivateメソッドとしてつかえません。なので、&lt;/p>
&lt;ol>
&lt;li>どのモジュールでも使える共通関数を作っておく&lt;/li>
&lt;li>department別にhelper関数を作っておく&lt;/li>
&lt;/ol>
&lt;p>とかの方法も考えられます。&lt;/p>
&lt;p>確かに、よく考えると拡張関数の良いところは「interfaceの実装ややスーパークラスの継承なし」でも簡単に処理を追加できるということなので、このような使い方をするのがユースケース別に処理を分けられて良さげな気がします。特に拡張関数を使うと、関数を配置するパッケージと可視性の制御が効くというところが個人的には新しい発見でした。&lt;/p>
&lt;h3 id="consider-defining-a-dsl-for-complex-object-creation">Consider defining a DSL for complex object creation
&lt;/h3>&lt;p>オブジェクトの作成時の複雑な処理はDSLを使いましょう、というパートです。Kotlinですでに提供している例としたら、HTMLがありますね。以下のような形で定義することになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>body {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> div {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a(&lt;span style="color:#e6db74">&amp;#34;https://kotlinlang.org&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target = &lt;span style="color:#a6e22e">ATarget&lt;/span>.blank
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +&lt;span style="color:#e6db74">&amp;#34;google&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +&lt;span style="color:#e6db74">&amp;#34;Some content&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>確かにKtorのようなフレームワークでもよく使われている物なので、ある程度需要はあるのかなという気がしました。Kotlinだと高階関数を作るのが難しくはないので、十分挑戦できるところでもありますね。&lt;/p>
&lt;p>ただ、DSL特有の書き方を確立し、その書き方をエンジニアに共有することや最初の設計と維持管理が難しそうな気がするので、アプリの縮小が求められる今のご時世に果たして合うかとうかは少し疑問ののころところでした。&lt;/p>
&lt;p>個人的に何かのライブラリやフレームワークを作るとしたら、挑戦してみたいなと思いました。&lt;/p>
&lt;h2 id="まあそうだよねって思ったところ">まあそうだよねって思ったところ
&lt;/h2>&lt;p>なんとなくそうではないかと思っていたところを（もしくはどこかで聞いて理論的な部分は忘れたけど、無意識的のうちに習慣化されていた部分を）文として親切に整理してくれているようなパートもありました。なのでもう一度自分の考えを再確認できたといえるところでしょうか。&lt;/p>
&lt;h3 id="do-not-repeat-common-algorithms">Do not repeat common algorithms
&lt;/h3>&lt;p>「スタンダードライブラリで解決できる一般的なアルゴリズムを自前のコードで書くな」というパートです。理由は以下の通りです。&lt;/p>
&lt;ol>
&lt;li>呼び出しの方がコードを書くより時間が短くかかる&lt;/li>
&lt;li>わかりやすい名前になっている&lt;/li>
&lt;li>コードがわかりやすくなる&lt;/li>
&lt;li>最適化が効く&lt;/li>
&lt;/ol>
&lt;p>私自身もなるべくスタンダートライブラリを活用した方が良いと思っていたので、ここはすぐに納得できました。自分で書いた処理が果たして最適化されたものかどうかもわからないし、業務使用以外のロジックを触るのは避けたいという理由でした。&lt;/p>
&lt;p>この本では、以下のようなコードを上げています。自前のロジックを書いた場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> percent = &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &amp;gt; &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &amp;lt; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-in.html" target="_blank" rel="noopener"
>coerceIn()&lt;/a>を使うことでシンプルにできます。以下がその例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> percent = number.coerceIn(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinには特にスタンダードラリブラリに良い関数が多いので、自前のロジックを書くよりは一度どんなAPIがあるのかを確認した方が良いケースが個人的には多かった気がします。そしてそれが納得できる理由が書いてあってよかったと思います。&lt;/p>
&lt;h3 id="implementing-your-own-utils">Implementing your own utils
&lt;/h3>&lt;p>スタンダードライブラリで解消できる問題以外で、プロジェクトに必要な共通の処理はユーティリティ関数として作っておきましょうってパートです。ユーティリティはクラスでなく、拡張関数として作ったら以下のようなメリットがあるらしいです。&lt;/p>
&lt;ul>
&lt;li>関数は状態を持たないので副作用がない&lt;/li>
&lt;li>トップレベル関数と比べると型が決まっているので使い勝手がいい&lt;/li>
&lt;li>引数よりはクラスについた形が直観的&lt;/li>
&lt;li>オブジェクトに関数をまとめるより必要な機能を探しやすい&lt;/li>
&lt;li>特定のクラスに従属されるので親クラスのものか、子クラスのものか悩まない&lt;/li>
&lt;/ul>
&lt;p>確かにJavaを使っていた時は、私もいわゆるSingleton Patternでユーティリティクラスを作ったり、DIして使えるクラスを定義しておいて、staticメソッドを書いていました。Kotlinだと、ユーティリティクラスなしでも特定のクラスに関数を追加することができるのでより使い勝手がよくなります。&lt;/p>
&lt;p>例えば、同じことをするとしても、拡張関数で書く場合とユーティリティクラスを作る場合のコードは以下のような違いがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 拡張関数を使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> isEmptyByExtension = &lt;span style="color:#e6db74">&amp;#34;Text&amp;#34;&lt;/span>.isEmpty()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ユーティリティクラスを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> isEmptyByUtilClass = &lt;span style="color:#a6e22e">TextUtils&lt;/span>.isEmpty(&lt;span style="color:#e6db74">&amp;#34;Text&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ユーティリティクラスを使う場合はまず、「どのユーティリティクラスの関数を使うか」を考えなければならないです。それに比べ、拡張関数はIDEでも自動補完ですぐ欲しい関数を見つけることができるので、より直観的なものになっていますね。&lt;/p>
&lt;p>他にも具体的なクラスにのみ追加ができたりするので、より安全な使い方ができるというのも良いところですね。色々と拡張関数は使い道が多いなという、再発見ができたと言えるところでしょうか。&lt;/p>
&lt;h3 id="builder-pattern">Builder pattern
&lt;/h3>&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>named arguments&lt;/a>が使えて、Builderパターンがいらないというパートです。KotlinでもBuilderパターンを使うことが技術的に不可能ではないが、named parameterを使った方が良い理由としては以下が挙げられています。&lt;/p>
&lt;ul>
&lt;li>より短い&lt;/li>
&lt;li>より綺麗&lt;/li>
&lt;li>使い方がシンプル&lt;/li>
&lt;li>スレッドセーフ&lt;/li>
&lt;/ul>
&lt;p>私自身も、Javaで使っていたのでKotlinでもBuilderパターンが必要かなと思ったことがありますが、いらないという結論を出しています。上記で挙げた理由ももちろん妥当ですが、Builderパターンだとインスタンスを生成するときに必須パラメータが揃っているかどうかを判断するのが難しくなるという理由からでした。&lt;/p>
&lt;p>例えば本に出てくるBuilderパターンの例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Pizza&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> size: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> cheese: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> olives: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> bacon: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Builder&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> size: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> cheese: Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> olives: Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> bacon: Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">setCheese&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>: Int): Builder = apply { cheese = &lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">setOlives&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>: Int): Builder = apply { olives = &lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">setBacon&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>: Int): Builder = apply { bacon = &lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">build&lt;/span>() = Pizza(size, cheese, olives, bacon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このBuilderは以下のような使い方ができると思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> villagePizza = &lt;span style="color:#a6e22e">Pizza&lt;/span>.Builder(&lt;span style="color:#e6db74">&amp;#34;L&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setCheese(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setOlives(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setBacon(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし以下の場合でもビルドはできますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> villagePizza = &lt;span style="color:#a6e22e">Pizza&lt;/span>.Builder(&lt;span style="color:#e6db74">&amp;#34;L&amp;#34;&lt;/span>).build()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もし&lt;code>cheese&lt;/code>、&lt;code>olives&lt;/code>、&lt;code>bacon&lt;/code>が&lt;code>0&lt;/code>を許容しない作りになっていると、これを修正するのは大変なことになるでしょう。もしくは、パラメータが複雑な作りのオブジェクトだったらデフォルト値を設定するか、強制null check(&lt;code>!!&lt;/code>)などを入れるか…より複雑になるだけですね。&lt;/p>
&lt;p>しかし、named parameterを使うと簡単に解決できる問題です。デフォルト値を指定しない&lt;code>val&lt;/code>だったら、それが必須項目であるということもわかりやすいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> myFavorite = Pizza(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#e6db74">&amp;#34;L&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cheese = &lt;span style="color:#ae81ff">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> olives = &lt;span style="color:#ae81ff">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bacon = &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="consider-factory-functions-instead-of-constructors">Consider factory functions instead of constructors
&lt;/h3>&lt;p>Javaでも最近は色々とfactory functionを導入していて、簡単にimmutableなオブジェクトを作りやすくなりました。Kotlinでもコンストラクタの作成や、named parameterによるインスタンスの生成が色々と便利ではあるものの、それでもfactory functionが良いケースがあるというパートです。理由は以下の通りです。&lt;/p>
&lt;ul>
&lt;li>関数には名前があるので、どうやってオブジェクトが生成されるかわかる
&lt;ul>
&lt;li>&lt;code>ArrayList(3)&lt;/code>よりは&lt;code>ArrayList.withSize(3)&lt;/code>がわかりやすい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>戻り値としてサブタイプのオブジェクトを指定できる
&lt;ul>
&lt;li>具体的な実装を時と場合によって違う形にすることができる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>呼び出されるたび新しいオブジェクトを作るわけではない
&lt;ul>
&lt;li>&lt;code>Connections.createOrNull()&lt;/code>のようにnullを返すこともできる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>まだ存在しないオブジェクトを提供できる
&lt;ul>
&lt;li>プロキシなしで動くようなオブジェクトを作るなどで応用できる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>オブジェクトの外に作ることで可視性を制御できる&lt;/li>
&lt;li>&lt;code>inline&lt;/code>にできるので、&lt;a class="link" href="https://kotlinlang.org/docs/inline-functions.html#reified-type-parameters" target="_blank" rel="noopener"
>reified&lt;/a>にもできる&lt;/li>
&lt;li>インスタンスを作るのが複雑なオブジェクトの手間を省く&lt;/li>
&lt;li>スーパークラスやプライマリコンストラクタを呼び出さずにインスタンスを生成できる&lt;/li>
&lt;/ul>
&lt;p>こちらも読みながらなるほどと納得しました。特に私の場合でも、Service層のDTOとController層のResponseなどのオブジェクト間のマッピングではfactory functionを導入してコードを再使用性を高められたと思っていたので、良い判断だったなと今は思っています。&lt;/p>
&lt;p>他に、factory functionを作る方法としても以下のようなものが提示されてありました。一般的にはcompanion object内に定義しておくことが多いかと思いますが、他の方法も必要であれば考慮したいものですね。&lt;/p>
&lt;h4 id="companion-object">companion object
&lt;/h4>&lt;p>Javaのstaticメソッドのようなパターン。最もわかりやすいですね。以下のような形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyLinkedList&lt;/span>&amp;lt;T&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> head: T,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> tail: MyLinkedList&amp;lt;T&amp;gt;?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#66d9ef">vararg&lt;/span> elements: T): MyLinkedList&amp;lt;T&amp;gt;? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Usage
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> list = &lt;span style="color:#a6e22e">MyLinkedList&lt;/span>.of(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>factory functionは大体以下の規則を持って命名されるという説明もありました。&lt;/p>
&lt;h5 id="from">from
&lt;/h5>&lt;p>一つのパラメータを渡し、タイプを変える時（自分自身のインスタンスを返す）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> date: Date = &lt;span style="color:#a6e22e">Date&lt;/span>.from(instant)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="of">of
&lt;/h5>&lt;p>複数のパタメータを渡し、それを束ねたタイプに変換するとき&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> faceCards: Set&amp;lt;Rank&amp;gt; = &lt;span style="color:#a6e22e">EnumSet&lt;/span>.of(JACK, QUEEN, KING)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="valueof">valueOf
&lt;/h5>&lt;p>&lt;code>of&lt;/code>の冗長な形&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> prime: BigInteger = &lt;span style="color:#a6e22e">BigInteger&lt;/span>.valueOf(&lt;span style="color:#a6e22e">Integer&lt;/span>.MAX_VALUE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="instance--getinstance">instance / getInstance
&lt;/h5>&lt;p>Singletonのインスタンス取得（パラメータが同じだと常に同じインスタンスが帰ってくる）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> luke: StackWalker = &lt;span style="color:#a6e22e">StackWalker&lt;/span>.getInstance(options)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="createinstance--newinstance">createInstance / newInstance
&lt;/h5>&lt;p>instance / getInstanceは似ているが、常に新しいインスタンスを返す&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> newArray = &lt;span style="color:#a6e22e">Array&lt;/span>.newInstance(classObject, arrayLen)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="gettype">getType
&lt;/h5>&lt;p>instance / getInstanceと似ているが、違うタイプのインスタンスを返すとき&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> fs: FileStore = &lt;span style="color:#a6e22e">Files&lt;/span>.getFileStore(path)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="newtype">newType
&lt;/h5>&lt;p>createInstance / newInstanceに似ているが、違うタイプのインスタンスを返す時&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> br: BufferedReader = &lt;span style="color:#a6e22e">Files&lt;/span>.newBufferedReader(path)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="extension">extension
&lt;/h4>&lt;p>クラスにからのcompanion objectを定義しておいて、外部から拡張関数でfactory functionを付ける形です。元のクラスをいじらなくても良くなるし、パッケージと可視性の制御など拡張関数の持つ特徴を活用できますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Tool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> { &lt;span style="color:#75715e">/*...*/&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Tool&lt;/span>.&lt;span style="color:#a6e22e">Companion&lt;/span>.createBigTool( &lt;span style="color:#75715e">/*...*/&lt;/span> ): BigTool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="top-level">top-level
&lt;/h4>&lt;p>スタンダードライブラリに含まれている、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html" target="_blank" rel="noopener"
>listOf()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/set-of.html" target="_blank" rel="noopener"
>setOf()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-of.html" target="_blank" rel="noopener"
>mapOf()&lt;/a>のようなものです。&lt;/p>
&lt;p>よく使うタイプに関しては使い勝手がいいので便利なものの、IDEの自動補完などに現れたら混乱するケースもあるので命名は慎重にする必要がある、とのことでした。&lt;/p>
&lt;h4 id="fake-constructor">fake constructor
&lt;/h4>&lt;p>Pascal Caseを使って、関数をコンストラクタに見せかけるものです。Kotlinのスタンダードライブラリとしては、以下のようなものがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#ae81ff">4&lt;/span>) { &lt;span style="color:#e6db74">&amp;#34;User&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> } &lt;span style="color:#75715e">// [User0, User1, User2, User3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは実際は以下のような関数ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">init&lt;/span>: (index: Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): List&amp;lt;T&amp;gt; = MutableList(size, &lt;span style="color:#66d9ef">init&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">MutableList&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">init&lt;/span>: (index: Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> list = ArrayList&amp;lt;T&amp;gt;(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(size) { index &lt;span style="color:#f92672">-&amp;gt;&lt;/span> list.add(&lt;span style="color:#66d9ef">init&lt;/span>(index)) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはinterfaceに対してコンストラクタを作る必要があったり、&lt;code>reified&lt;/code>タイプの引数が必要な時に考慮できるものらしいです。&lt;/p>
&lt;p>他にもfake constructorを作る方法があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Tree&lt;/span>&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">invoke&lt;/span>(size: Int, generator: (Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): Tree&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Usage
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Tree(&lt;span style="color:#ae81ff">10&lt;/span>) { &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この場合constructor referenceではコードが複雑になる問題があるらしいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> f: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#f92672">::&lt;/span>Tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Fake Constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> d: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#f92672">::&lt;/span>Tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Invoke in companion object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> g: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#a6e22e">Tree&lt;/span>.Companion&lt;span style="color:#f92672">::&lt;/span>invoke
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なのでfake constructorを使うとしたら、関数として定義したほうがよさそうです。&lt;/p>
&lt;h4 id="factory-class">factory class
&lt;/h4>&lt;p>別途Factoryというクラスを置いてインスタンスを返すようにする方法ですね。Javaではinterfaceでそのようなことをするケースがありますが（&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/List.html#of%28E%29" target="_blank" rel="noopener"
>List.of()&lt;/a>みたいな）、Kotlinでも良いのか？という疑問が湧きました。結論から言いますと、「factoryクラスは状態を持つことが可能」なため、場合によっては考慮しても良いとのことです。これは思ったより活用できそうな可能性がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> surname: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StudentsFactory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> nextId = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>(name: String, surname: String) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student(nextId&lt;span style="color:#f92672">++&lt;/span>, name, surname)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> factory = StudentsFactory()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> s1 = factory.next(&lt;span style="color:#e6db74">&amp;#34;Marcin&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Moskala&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(s1) &lt;span style="color:#75715e">// Student(id=0, name=Marcin, Surname=Moskala)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> s2 = factory.next(&lt;span style="color:#e6db74">&amp;#34;Igor&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Wojda&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(s2) &lt;span style="color:#75715e">// Student(id=1, name=Igor, Surname=Wojda)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ざっくりなまとめとなりますが、以上が私のこの本で得られた知識への感想となります。新しい発見もあり、自分の習慣が間違ってなかったということを人の説明で補ってもらったような気にもなり、かなり興味深かったです。&lt;/p>
&lt;p>ただやはり、Kotlinがまだ新しい言語であり、いろいろなパラダイムを吸収しているためか、&lt;code>Effective Java&lt;/code>のようなレベルの高い作法に対する議論は少し足りてないような気がしていて、そこは多少残念に思います。まあ、こう思うようになったということ自体が、少しは自分が成長した証拠でもあるかなという生意気な想像もしてみるのですが。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>今年のブログの話</title><link>https://retheviper.github.io/posts/renew-blog/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/renew-blog/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.webp" alt="Featured image of post 今年のブログの話" />&lt;p>すでに気づいている方もいらっしゃるかと思いますが、2年ぶりにブログのテーマを変えました。正確にはテーマだけでなく、静的ページ生成ツールを&lt;a class="link" href="https://jekyllrb.com/" target="_blank" rel="noopener"
>Jekyll&lt;/a>から&lt;a class="link" href="https://gohugo.io/" target="_blank" rel="noopener"
>Hugo&lt;/a>に変えました。こういうのが気軽にできるので、最初からブログをGithub Pagesで公開したことは本当によかったなと今は思っています。&lt;/p>
&lt;p>サイトの生成ツールを変えたことで各ポストのURLにも変化があり、もしお気に入りなどに設定しておいた方には申し訳ないことをしましたが、それを踏まえても改善できたところが多いと思いますので、ご了承ください。&lt;/p>
&lt;p>さて、今回はそんなブログの刷新に関する話となりますが、大きくわけて「ブログがどう変わったか」と「これからブログでやっていきたいこと」について述べさせていただきたいと思います。&lt;/p>
&lt;h2 id="uxの改善">UXの改善
&lt;/h2>&lt;p>UXの観点で改善されたことは、ブログ刷新での第一順位の目標でもありました。他にも色々とあるかと思いますが、まずは以下のようなものがあります。&lt;/p>
&lt;h3 id="画面遷移の改善">画面遷移の改善
&lt;/h3>&lt;p>以前のブログはメインから個別のポストに遷移するときにアニメーションが含まれていました。（ポスト一覧を表示するところでも同じものが使われていました）画面遷移時にアニメーションを入れるというのはもうトレンドとしては古いものでもあり、何より画面遷移が遅いような感覚があるので改善したかったです。なので、今回は反応が早くしてみました。&lt;/p>
&lt;h3 id="検索機能">検索機能
&lt;/h3>&lt;p>タグとカテゴリ、そしてアーカイブがあれば十分かなと思いましたが、キーワードでポストを探したい時もありますね。以前は検索機能を付けようとしてもうまくいかなかったので、ちゃんと検索のできるテーマを採用しました。&lt;/p>
&lt;h3 id="デザイン">デザイン
&lt;/h3>&lt;p>個人的にはダークモードが好きで、全体的に黒いテーマを選ぼうかなと思いましたが、幸いボタンを押すだけでダークモードへの転換ができるテーマがあったので、こちらを選びました。もっと良いのは、このダークモードはシステムの設定と連動されるということです。なので、ダークモードが好みではない場合は白い画面を見ることができます。一つ残念なのは、コードブロックのスタイルはまたブログとは別ということですが…これはのちに何か方法があったら対応したいと思います。&lt;/p>
&lt;p>他には、モバイル画面でもちゃんと画像が見えたり、メニューやレイアウトなども色々とモダンなデザインになったのが嬉しいところです。&lt;/p>
&lt;h3 id="ポスト表示">ポスト表示
&lt;/h3>&lt;p>以前はポストの一覧から、ポストの画像をクリックするとそのポストの詳細画面に遷移するのではなく、画像が拡大されるという問題があ理ましたがそれを改善できました。そしてポストごとに読みにかかる大まかな時間を表示できるようになったので、記事を読まれる方にもどれを読むか参考するに良い情報を提供できているかと思います。&lt;/p>
&lt;h2 id="内部的な変化">内部的な変化
&lt;/h2>&lt;p>さて、今までは主にUXの観点からの話でしたが、実は上記で挙げた項目は単純にJekyllのテーマを変えるだけでも対応ができるものでした。それをあえてHUGOに変えてまでブログの刷新を追求した理由を今から話したいと思います。&lt;/p>
&lt;h3 id="管理がしやすい">管理がしやすい
&lt;/h3>&lt;p>Jekyllの場合、一つのテーマがRubyで書かれた一つのアプリを扱うようなものだったので、Gemfileの依存関係のアップデートが必要だったり、ローカルでサーバを起動するまで時間がかかったり、テーマを変えるたびに色々と設定や構成をいじる必要がありました。HUGOの場合、そのような問題はほとんどありませんでした。テーマはGithubのリポジトリをサブモジュールとしてインポートすることができて、あとはコンテンツと基本的な設定をいじるだけです。なので、実際に時間がかかったのは添付画像などリソースのパスが変わったための対応などを除くと、1時間ほどだったような気がします。&lt;/p>
&lt;p>また、以前は画像が一つのフォルダに集約されていたため、ポストの添付する画像を管理するのががかなり面倒臭い作業でしたが、今はポストごとに別フォルダを使用していて、そのフォルダに画像を入れるだけなので管理がより簡単になりました。なので、今後は画像の添付も以前よりは積極的にやっていこうと思います。&lt;/p>
&lt;p>HUGOはGoで書かれてあるため、ローカルでサーバを起動するのが早いのも良いところです。&lt;/p>
&lt;h3 id="カスタマイズが楽">カスタマイズが楽
&lt;/h3>&lt;p>以前は自動でRSSフィードを作ってくれる機能があるものの、全体のポストが対象となっていませんでした。テーマやJekyllの設定をいじれば解消できる問題だったとは思いますが、前述した通り、テーマが一つのアプリのようなものなので、カスタマイズが簡単ではありません。それに比べ、HUGOはより単純なものとなっていてテーマや設定のカスタマイズも簡単にできます。今もメニューは元々テーマの設定を変えるだけでカスタマイズできるものもありますが、一部は自分の方で修正したものもあります。どれも時間があまりかからなく、すぐにできるのが魅力的でした。&lt;/p>
&lt;p>&lt;a class="link" href="https://gohugo.io/content-management/shortcodes/" target="_blank" rel="noopener"
>shortcode&lt;/a>でHTMLとJavaScriptの添付をテンプレート化できるのも個人的にはHUGOの魅力ではないかと思います。使い勝手がいいので、色々と活用できそうなところが多いですね。&lt;/p>
&lt;h2 id="これからは">これからは
&lt;/h2>&lt;p>ブログの生成ツールを変えて物理的に良くなったところの話ができたので、次はそのブログで何をしていきたいかを述べたいと思います。&lt;/p>
&lt;p>最初は意欲も溢れていて、さまざまな技術に触れてそこで自分が学んだことや感じたこと、そして試行錯誤など多彩な記事を書いていたと思います。今振り返ってみると「当時の自分はこんなにもわかってないものが多かったのか」と、恥ずかしくなる瞬間もありますが、少なくとも今よりはもっと力を入れていた気がします。&lt;/p>
&lt;p>個人的に、このブログの更新は少なくとも月に2回を目指しているのですが、気持ちだけが先走ってあまり読む価値のないポストもいくつか書いてきたのではないかと反省しています。&lt;/p>
&lt;p>なので、今年はいくつかの技術を実際使ってみるという目標をたて、それらに関する記事を書いていきたいと思います。今のところは以下のようなものを考えています。&lt;/p>
&lt;h3 id="jetpack-compose">Jetpack Compose
&lt;/h3>&lt;p>新年の目標としても挙げていたものですが、実は去年から少しづつ触っている状態で、今年は実際にAndroidとデスクトップアプリケーションを作ってみたいと思っています。ちょうど去年は&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-mpp/" target="_blank" rel="noopener"
>Compose Multiplatform&lt;/a>も正式リリースしているので、時期的にちょうどいいかと思います。&lt;/p>
&lt;p>SwiftUIの方も、&lt;a class="link" href="https://developer.apple.com/documentation/Xcode/About-Continuous-Integration-and-Delivery-with-Xcode-Cloud" target="_blank" rel="noopener"
>XCode Cloud&lt;/a>の発表や&lt;a class="link" href="https://developer.apple.com/support/unlisted-app-distribution/" target="_blank" rel="noopener"
>リンクでのアプリ公開が可能になったり&lt;/a>、&lt;a class="link" href="https://www.apple.com/jp/swift/playgrounds/" target="_blank" rel="noopener"
>Swift Playgrounds&lt;/a>でアプリのビルドが可能になったことにより興味を持っている状態ではありますが、まずは自分が仕事でKotlinを使っていて、Composeの方をある程度使いこなせるようになってから挑戦してみた方がいいかなと思っているところです。&lt;/p>
&lt;p>せっかくMacを使っているので、一度はSwiftでアプリを作ってみないとですね。&lt;/p>
&lt;h3 id="svelte">Svelte
&lt;/h3>&lt;p>会社の方では&lt;a class="link" href="https://nuxtjs.org/" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>を使っているので、こちらでも良いかと思いましたが、結局自分が画面を触ることになるのはプライベートでしかチャンスがない気がしたので、興味本意で選んだのが&lt;a class="link" href="https://svelte.dev/" target="_blank" rel="noopener"
>Svelte&lt;/a>です。&lt;/p>
&lt;p>まだ技術としては成熟したものではない気はしますが、そろそろ&lt;a class="link" href="https://kit.svelte.dev/" target="_blank" rel="noopener"
>Sveltekit&lt;/a>のようなものも登場していて、何よりも学習にかかる時間や効率を考えたときに、自分が画面を作るとしたら最も生産性が高くなりそうな技術だなと思いました。まぁ、これは実際触ってみないとわからないものですが…&lt;/p>
&lt;p>他に理由としては、&lt;a class="link" href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-web-frameworks" target="_blank" rel="noopener"
>Stackoverflow Survey&lt;/a>で最も愛されたウェブフレームワークに選定されたから、というのもあります。多くのエンジニアが好きという技術は、まずその理由が知りたくなりますので。（同じ理由で、Rustも触ってみたいと思っています）&lt;/p>
&lt;h3 id="quarkus">Quarkus
&lt;/h3>&lt;p>会社で使っているSpring bootのビルドとテスト、デプロイにかかる時間を短くしたいのですが、その対策としてQuarkusへの移行を考慮しています。稼働中のサービスのフレームワークを変えるということはかなりのリスキーなことではありますが、成功した場合は生産性も上がり起動速度やメモリのようなメリットがかなりでかい気がしているので、いつになるかはわかりませんが、ぜひ挑戦してみたいタスクとして設定しています。移行に成功しても失敗しても、色々と勉強になりそうではありますね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ブログの外見は変わり、十分成功的な移行になったと思いますので、次はその中身を充実にしていくのが課題ですね。今まで通り、一人前のエンジニアになりたいという気持ちを忘れず、少しづつでも前に進むような（そして読まれる方にも役立つような）ポストを書けたらなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinでデータの逆転グルーピング</title><link>https://retheviper.github.io/posts/kotlin-reverse-groupping/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-reverse-groupping/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinでデータの逆転グルーピング" />&lt;p>DBを設計する時と、最終的にアプリで活用するデータの形は大きく変わるケースがあります。特に後から機能を付け加えるとそうなりますね。もちろん正規化などを通じてより効率的にデータを保存する方法を考える必要のあるDBと、データをいかに加工して使うかを工夫するアプリの違いによるものもありますが、アプリの改修が続くと同じデータでも活用する箇所や表現の仕方が変わってくるからでもあるかなと思います。&lt;/p>
&lt;p>そういうわけで、今回はそのようなケースで一つ活用できる方法をご紹介したいと思います。アルゴリズムというわけでもありませんし、より効率的な方法はあるかなと思いますが、応用すれば結構色々な場所で使えそうな方法ではないかと思います。&lt;/p>
&lt;h2 id="シナリオ">シナリオ
&lt;/h2>&lt;p>例えば以下のようなシナリオがあるとします。&lt;/p>
&lt;ol>
&lt;li>社員はA、Bという二つの部署に配属される&lt;/li>
&lt;li>社員が部署に配属される日付はそれぞれ&lt;/li>
&lt;/ol>
&lt;p>この場合、データの作りには色々な観点があるかと思いますが、まず部署の配属日を基準にデータを作るとしたら、部署の種類、配属日とその日付に配属となった社員のリストを持つような形になるかと思います。Kotlinのコードとして表現するとしたら以下のような形ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DepartmentType&lt;/span> { A, B }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Department&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> departmentType: DepartmentType,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> date: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> employers: List&amp;lt;Employer&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Employer&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで社員の3人がいて、それぞれ部署Aと部署Bに配属された日付が違うケースがあるとしましょう。データとしては、以下のようなものです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>社員番号&lt;/th>
&lt;th>部署A配属&lt;/th>
&lt;th>部署B配属&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上記のデータを持って、先ほどの部署のデータを実際のリストとして作るとしたら以下のようになるかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> departments = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#a6e22e">DepartmentType&lt;/span>.A,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#a6e22e">DepartmentType&lt;/span>.A,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#a6e22e">DepartmentType&lt;/span>.B,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#a6e22e">DepartmentType&lt;/span>.B,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">3&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、これを社員を基準に、それぞれの部署に配属された日付をデータとして加工するにはどうしたら良いでしょうか。社員番号と部署に配属となった日付の二つを持つような形です。例えば、コードで表現すると以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JoinedDates&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> employerId: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> departmentA: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> departmentB: LocalDate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、やりたいことは先ほどの&lt;code>departments&lt;/code>を、最終的に以下のようなデータにしたいということですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> JoinedDates(employerId=EmployerId(value=1), departmentA=2022-01-01, departmentB=2022-01-01),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> JoinedDates(employerId=EmployerId(value=2), departmentA=2022-01-01, departmentB=2022-02-01),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> JoinedDates(employerId=EmployerId(value=3), departmentA=2022-02-01, departmentB=2022-02-01)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>データの整列の基準がひっくり返されるので、どうしたら良いかと悩ましくなる場面です。今回は、これを解決した自分の方法を紹介したいと思います。&lt;/p>
&lt;h2 id="ロジック">ロジック
&lt;/h2>&lt;p>Departmentを基準に考えるとEmployerのデータが複数になりますが、これを逆転させて、Employerを基準に複数のDepartmentを持つという形に加工したいというのが今回の要件です。だとすると、考えられるロジックは以下がポイントかなと思います。&lt;/p>
&lt;ol>
&lt;li>EmployerのID単位でまとめる&lt;/li>
&lt;li>EmployerごとにDepartmentをType別に分けた配列を持たせる&lt;/li>
&lt;/ol>
&lt;p>まずはネスとしているEmployerのリストに入り、そのIDを抽出する必要がありますね。このIDは重複させたくないので、MapのKeyにしておくと良さげです。&lt;/p>
&lt;p>あとは、そのMapにEmployerのIDがKeyとして存在するかどうかで以下の処理をすると良いでしょう。&lt;/p>
&lt;ol>
&lt;li>Keyが存在しない場合は、新しくDepartmentのタイプとその日付をinsert&lt;/li>
&lt;li>Keyが存在する場合は、そのvalueを取り出してDepartmentのタイプと日付を追加&lt;/li>
&lt;/ol>
&lt;p>なので、一回DepartmentのListをMapに変換して、さらにJoinedDatesのListに変換することとなります。ちょうど上記の分岐については、&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#compute-K-java.util.function.BiFunction-" target="_blank" rel="noopener"
>compute()&lt;/a>を活用するとできるので、中間データとしてのMapがどんな形になるかを考えると良いかなと思います。&lt;/p>
&lt;p>私の場合はMapの方がデータを取りやすいので、最終的には以下のような処理となりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;Department&amp;gt;.toJoinedDates(): List&amp;lt;JoinedDates&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 中間データ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> tempMap = mutableMapOf&amp;lt;Int, Map&amp;lt;DepartmentType, LocalDate&amp;gt;&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.forEach { department &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Departmentのタイプとその日付のPair
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> departmentJoined = department.departmentType to department.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> department.employers.forEach { employer &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// EmployerのIDがKeyとして存在したら足して、なかったらMapを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> tempMap.compute(employer.id) { _, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span>&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">value&lt;/span> + departmentJoined } &lt;span style="color:#f92672">?:&lt;/span> mapOf(departmentJoined)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 中間データをJoinedDatesのListに変えて返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> tempMap.map { (id, department) &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JoinedDates(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employerId = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentA = department.getValue(&lt;span style="color:#a6e22e">DepartmentType&lt;/span>.A),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentB = department.getValue(&lt;span style="color:#a6e22e">DepartmentType&lt;/span>.B)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="共通ロジック化">共通ロジック化
&lt;/h2>&lt;p>ジェネリックを使ったclassとして上記のロジックを一部分離すれば、似たようなケースで色々使い回せるのではないかと思いましたので、以下のようなコードも書いてみました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Aggregator&lt;/span>&amp;lt;T, K, V, R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> tempMap = mutableMapOf&amp;lt;T, Map&amp;lt;K, V&amp;gt;&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// データの追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(key: T, &lt;span style="color:#66d9ef">value&lt;/span>: Pair&amp;lt;K, V&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tempMap.compute(key) { _, existingValue &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> existingValue&lt;span style="color:#f92672">?.&lt;/span>let { existingValue + &lt;span style="color:#66d9ef">value&lt;/span> } &lt;span style="color:#f92672">?:&lt;/span> mapOf(&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定したListとして取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getList&lt;/span>(transfer: (T, Map&amp;lt;K, V&amp;gt;) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): List&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> tempMap.map { transfer(&lt;span style="color:#66d9ef">it&lt;/span>.key, &lt;span style="color:#66d9ef">it&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これの場合は以下のような使い方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> aggregator = Aggregator&amp;lt;Int, DepartmentType, LocalDate, JoinedDates&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// データの追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>departments.forEach { a &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.employers.forEach { b &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aggregator.add(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = b.id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> = a.departmentType to a.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listの結果を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> joinedDates = aggregator.getList { id, joinedDate &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JoinedDates(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employerId = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentA = joinedDate.getValue(&lt;span style="color:#a6e22e">DepartmentType&lt;/span>.A),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentB = joinedDate.getValue(&lt;span style="color:#a6e22e">DepartmentType&lt;/span>.B)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>汎用性はあるものの、呼び出し元のコードが増えたり、指定している型の意味や意図がよくわからないので適切なKDocやコメントがないと少しわかりにくいところがデメリットかもしれませんね。ただ大事なのは中間データの型と&lt;code>compute()&lt;/code>による分岐処理なので、そこだけをうまく取り出して他でも応用できるかなと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>サーバサイドKoltinだと、多くの場合にデータを&lt;code>List&lt;/code>として扱うのが普通かなと思いますが、場合によっては&lt;code>Map&lt;/code>を使うのもロジックを書いていく中では良い選択になるかと思います。特に、今回紹介した&lt;code>compute()&lt;/code>以外でも、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-or-put.html" target="_blank" rel="noopener"
>getOrPut()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/get-or-default.html" target="_blank" rel="noopener"
>getOrDefault()&lt;/a>などの機能が便利なので色々と活用できる場面が多いかなと思います。この処理は&lt;a class="link" href="../exposed-mapping-record-to-object" >前回のポスト&lt;/a>でも似たようなものを紹介したことがありますので、興味のある方はそちらも参考にしてください。&lt;/p>
&lt;p>プログラミング言語が提供するスタンダードライブラリは色々と見逃しやすいところがあるかなと思いますが、よくドキュメントや自動補完で一覧に登場する関数に注目すると、こういう風に必要なものがいきなり現れることもあるかと思います。まだ私もKotlinを触って1年ほどしか経ってないひよこなものなので、これからもどんどん新しい発見があると嬉しいなと思いますね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>個人的な2022年のロードマップ</title><link>https://retheviper.github.io/posts/my-roadmap-in-2022/</link><pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/my-roadmap-in-2022/</guid><description>&lt;img src="https://retheviper.github.io/images/map.webp" alt="Featured image of post 個人的な2022年のロードマップ" />&lt;p>このブログを書き始めてから、今年で4年目となります。振り返ってみるとブログを書き始めた頃はSEとして主にSIerの基盤チームの仕事をしていたので、インフラやライブラリを含めさまざまな技術に触れることが多かったのですが、去年に転職をして本格的に業務系エンジニアとしてバックエンドを担当することになり触れる技術や興味などにも変化があったかなと思います。なので、今回は振り返りを兼ねて今年のロードマップに関して少し述べたいと思います。&lt;/p>
&lt;p>過去分のポストを振り返ってみると最初は主にJava、Spring、Linux、Jenkinsなどに関するものが多かったのですが、最近はやはりKotlinで使えるさまざまなフレームワークなどに興味が移っている感覚です。基本的にJavaでもKotlinでもJVM言語であることは同じなのでできることや分野は大差なく、転職してからも使っているフレームワークはSpringなのですが、Kotlinの開発元であるJetBrains社がいろいろなフレームワークを開発しているのもあり自然にそれらに興味を持つようになっていますね。&lt;/p>
&lt;h2 id="sophomore-jinxを克服する">Sophomore jinxを克服する
&lt;/h2>&lt;p>Sophomore jinxは日本語で「2年目のジンクス」といわれている言葉です。大学2年目になると新入生だった頃と比べ、成績が下がり熱意が消えるというということを指す言葉らしいです。これの意味を拡張して、1年目に新人王などに選ばれた選手がその次の年からは成績が悪化したり、人気の映画の続編が面白くなかったりする場合など最初より何か劣化した場合を指すことになっているとか。&lt;/p>
&lt;p>自分の場合はエンジニアになってから4年目になるのですが、確かに2年目からは1年目の時と比べ熱意はなくなっている気がします。だからと言って新しい技術に興味がなくなったり、プログラミング自体が飽きたという訳ではありませんが、前はやりたいことがあったらずっとモニタと睨めっこしながら徹夜でコードを書いたりしていたのに、今はとてもそういう気にならないというのが違うところですね。年を取ったためかとも思いますが、&lt;/p>
&lt;p>これについては自己分析とやりたいこと、そしてできることを冷静に整理して少しづつでも何か成果物を出せるようにしないと思っています。去年もそうでしたが、このようなポストを書くのはそのためでもあります。計画しているもの全てを成せるとは思いませんが、多くの目標の一部でも達成した方が最初から少ない数の目標を立てるよりは良いのかなという気がしています。なので、まずは「やるかどうかわからないけどアンテナは張っておく」という感覚でいろいろな技術に目を通しておこうかなと思っています。&lt;/p>
&lt;h2 id="frontend">Frontend
&lt;/h2>&lt;p>私はJavaScriptとTypeScriptの基礎を研修やUdemyの講座で学んだくらいのレベルで、フロントエンドの仕事をあまりやることがなかったです。しかし、昨今のウェブアプリの開発においてのトレンドをみるとやはりフロントエンドの技術を一つは学んでおいた方が良さげな気もしますし、バックエンドの役割を吸収しているような気配すらするなという気がしますね。何より、エンドユーザにとって画面のないアプリは想像できないので、今まで自分が使うためのAPIやライブラリ、コマンドラインアプリだけでなく本格的にGUIを活用した何かを作ってみるべき時が来たかなと思っています。&lt;/p>
&lt;p>何よりフロントエンドの場合、数年前はいろいろなライブラリとフレームワークが存在してどれを使った方がいいか全くわからない状況でしたが、最近は3強だといわれていた中でもAngularを抜いたReactとVueのみが生き残り、さらにそれらを基盤にしたフレームワークが登場するなど、そろそろ技術の成熟期と言ってもいい時代になったのではないかと思いますので、React基盤の&lt;a class="link" href="https://nextjs.org" target="_blank" rel="noopener"
>Next.js&lt;/a>か、Vue基盤の&lt;a class="link" href="https://nuxtjs.org" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>のどちらかを選べばよい時期なのではと思います。私自身も今年はそのうちのどちらかに触れてみたいなと思っています。&lt;/p>
&lt;p>せっかくなので&lt;a class="link" href="https://nestjs.com" target="_blank" rel="noopener"
>NestJS&lt;/a>のようなJavaScript用のサーバサイドフレームワークにも触れてみるのは良いかもしれませんが、サーバサイドというバックグラウンドがある自分にとってはまずはフロントエンドのみでちょうどよいチャレンジかなと思ったりもします。後述しますが、バックエンドではまた別に触ってみたいものもありますのでなおさらですね。&lt;/p>
&lt;h2 id="quarkus">Quarkus
&lt;/h2>&lt;p>個人的にはSpringを長く使っていたので、新しいフレームワークを使ってみたいという願望があります。一つのフレームワークに慣れると、それを使い続けるのも選択肢としては悪くないと思いますが、新しい技術にはメリットもデメリットもあるものなので、少なくとも触れてみる必要はあるかなと思います。なので去年は&lt;a class="link" href="https://quarkus.io" target="_blank" rel="noopener"
>Quarkus&lt;/a>と&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>Ktor&lt;/a>の二つを触ってみました。&lt;/p>
&lt;p>個人的にはJetBrainsのプロダクトに信用を持っていて、Kotlin向けという点でもKtorは悪くなかったと思ったのですが、機能が不十分であるところや、アーキテクチャで悩ましいところがあるという面で躊躇しています。一方でQuarkusはネイティブにコンパイルでき、Springのライブラリを一部そのまま使えたり、そもそもSpringとあまり変わらない感覚でコードをサクサク書けそうなイメージなので本格的に使用してみたいと思っています。最大の問題はやはり、ネイティブの場合ビルドにかなり時間がかかるということですが、これはCIとの連携をうまくやっていくしかないかもしれませんね。&lt;/p>
&lt;h2 id="fastapi">FastAPI
&lt;/h2>&lt;p>いきなりPythonになりますが、&lt;a class="link" href="https://fastapi.tiangolo.com" target="_blank" rel="noopener"
>FastAPI&lt;/a>にも触れてみたいと思っています。以前から違う分野に転職をするとしてもバックエンドはやり続く可能性が高いと思い、いろいろな言語とフレームワークを触ってみたいと思っていました。その候補としては&lt;a class="link" href="https://expressjs.com/ja" target="_blank" rel="noopener"
>Express&lt;/a>、&lt;a class="link" href="https://rocket.rs" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://vapor.codes" target="_blank" rel="noopener"
>Vapor&lt;/a>などがあって、これらを全部触ってみた後、最も自分の好みに合ったものをプライベートで使い続けようと思っていたのです。&lt;/p>
&lt;p>そんな中、Pythonは普段もたまに簡単な自動化のスクリプトを作るなどの目的で使っているので、&lt;a class="link" href="https://www.djangoproject.com" target="_blank" rel="noopener"
>Django&lt;/a>を触ってみようかと思っていたところ、最近はFastAPIで爆速の開発ができるという話を聞いて興味を持つようになりました。今もKotlinとSpringで開発はできますが、シンプルなプロジェクトならこういった軽いオプションが一つあっても悪くなさそうな気がします。インタープリタ言語なので起動も早く、&lt;a class="link" href="https://www.techempower.com/benchmarks" target="_blank" rel="noopener"
>Techempowerのベンチマーク&lt;/a>でも意外と悪くないパフォーマンスを見せてくれているのも魅力的ですが、&lt;a class="link" href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener"
>Swagger&lt;/a>と&lt;a class="link" href="https://github.com/Redocly/redoc" target="_blank" rel="noopener"
>ReDoc&lt;/a>によるドキュメンテーションが自動で行われるというところがかなり良さげです。なんでもサクッと作れそうな感じがしますね。&lt;/p>
&lt;p>また、直接使わないとしてもコードが綺麗で勉強になる噂を聞いているので、少なくとも一度はコードを読んでみたくなります。&lt;/p>
&lt;h2 id="swiftui-and-jetpack-compose">SwiftUI and Jetpack Compose
&lt;/h2>&lt;p>個人的に本当にやりたかった分野は、GUIを持つアプリを作り上げることです。エンジニアという職業を持つ前から作ったのも&lt;a class="link" href="https://openjfx.io" target="_blank" rel="noopener"
>JavaFX&lt;/a>によるデスクトップアプリでしたので。最近はJavaScriptだけでも&lt;a class="link" href="https://www.electronjs.org" target="_blank" rel="noopener"
>Electron&lt;/a>や&lt;a class="link" href="https://reactnative.dev" target="_blank" rel="noopener"
>React Native&lt;/a>などを使ってなんでもできるという時代にはなっていますが、せっかくJavaとKotlinができるようになったので、ネイティブアプリを作ってみた方が良さそうな気がします。&lt;/p>
&lt;p>以前&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>が発表されてまもない時期に、一度React Nativeと一緒にチュートリアルだけ触れてみたことがあるのですが、当時にもFlutterのいわゆる「宣言型GUI」というものに魅力を感じていたのでこれからモバイルをやるとしたらFlutterかなと悩んでいました。最近はモバイルだけでなく、デスクトップアプリやウェブアプリまで作れるようになったのでなおさらでしたね。&lt;/p>
&lt;p>しかし、&lt;a class="link" href="https://developer.apple.com/xcode/swiftui" target="_blank" rel="noopener"
>SwiftUI&lt;/a>と&lt;a class="link" href="https://developer.android.com/jetpack/compose?hl=ja" target="_blank" rel="noopener"
>Jetpack Compose&lt;/a>というものが登場してからは完全にこちらに傾きました。どうしても同時にマルチプラットフォームアプリが開発できるという面ではFlutterが有利だとは思いますが、それと似たような感覚でネイティブのUIが作れられるようになったのでもう悩む必要がないかなという気がします。&lt;/p>
&lt;p>特に、SwiftUIだとMac用のデスクトップアプリを作ることもできますが、Jetpack Composeならデスクトップアプリだけでなくウェブアプリも作ることができて、さらに&lt;a class="link" href="https://kotlinlang.org/docs/kmm-getting-started.html" target="_blank" rel="noopener"
>Kotlin Multiplatform Mobile&lt;/a>を使うとビジネスロジックの共有ができるようになるのでこちらの方が自分の場合にはより合うのではないかという気がしています。自分に合うというのは、私がめんどくさがり屋なので一つの言語で全てを解決したいという願望を持っているというだけの話ですが…とにかく一度使ってみて、よかったらフロントエンドでもJetpack Composeを使ってみるのはありかなと思っています。&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>という選択肢もありますが、こちらはまた次の機会で。&lt;/p>
&lt;p>ただこれらのデメリットは、やはりどれもまだ完成されてない技術ということですね。分野を問わず新しい技術のジレンマでもありますが、新技術がどれだけ良くてもそれだけでは完全ではない（もしくはかなり不便）という場面が出てくる可能性があるので、当面は少し様子を見ながらシンプルなアプリを作ってみることから初めてみようと思います。Flutterという良い先例があるので、良さげな機能はすぐに吸収してくれるという期待もあります。&lt;/p>
&lt;h2 id="oracle-cloud">Oracle Cloud
&lt;/h2>&lt;p>他のクラウドと比べかなり後発したためか、無料プランでもメモリ1GBのVMインスタンスを二つも提供するという破格の政策で知られたOracle Clouですが、2021年からはさらに選べるVMインスタンスにARM（&lt;a class="link" href="https://www.oracle.com/jp/cloud/compute/arm" target="_blank" rel="noopener"
>Ampere A1&lt;/a>というオプションを追加しています。&lt;/p>
&lt;p>Ampereが既存のAMDやIntel製CPUを使うインスタンスと比べて目立つのはやはり性能です。ARMだと互換性の問題がありx86と比べ利用率が下がると思ったためか、無料プランでも4つのOCPU、24GBのメモリという良い性能のインスタンスを提供しています。無料のインスタンスを2つまで作ることができるので、2つのOCPUと12GBのメモリという構成を2つのインスタンスに分けて指定することもできます。&lt;/p>
&lt;p>個人的には既存の無料で使えるインスタンスが1つのOCPU、1GBのメモリというオプションだったので、Javaアプリのビルドなどヘビーな作業には向いてないのが惜しいところでした。なので&lt;a class="link" href="https://mattermost.com" target="_blank" rel="noopener"
>Mattermost&lt;/a>のサーバとして使うなど軽い感じでしか使い道がなかったのですが、Ampereの導入でCI用サーバなどに使える道もできたかなと思います。Oracle Cloudのホームページで紹介していること以外でも、他の&lt;a class="link" href="https://jiuyu.medium.com/oracle-cloud-ampere-a1-cpu-benchmarks-6464ef43593d" target="_blank" rel="noopener"
>ベンチマーク&lt;/a>を参照するとCPU性能は期待しても良さそうな気がします。無料でOracle DBも提供されているのでそちらを使うか、それともVMインスタンスを一つDB用に使うか、GCPやAWSの無料サービスと組み合わせて使うとかでも色々できそうな気がします。&lt;/p>
&lt;p>ただ、やはり互換性が気になっていたのですが、個人的にはApple Silicon搭載Macを使ってみながら「意外と悪くない」という結論に至っています。プログラミング言語などはすでにARM対応済みのものが多く、サーバで使うとしたら&lt;a class="link" href="https://www.ffmpeg.org" target="_blank" rel="noopener"
>FFmpeg&lt;/a>、&lt;a class="link" href="https://imagemagick.org/index.php" target="_blank" rel="noopener"
>ImageMagick&lt;/a>、&lt;a class="link" href="http://www.graphicsmagick.org" target="_blank" rel="noopener"
>GraphicsMagick&lt;/a>などを使うケースもあるかなと思いますが、どれもARMバージョンをインストールもしくはビルドできるので特に問題はなさそうです。&lt;/p>
&lt;p>他に問題なら、今の所VMインスタンスを作ろうとしてもハードウェアが十分ではないのか、2つのOCPU以上のスペックでは作れないというのが問題ですね。時間が解決してくれる問題かもしれませんが、いつになったらインスタンスを自由に作れるかわからないというのは確かに問題と言えるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>意欲がないといいつつ、これだけやってみたいものが多いというのはまだ自分がエンジニアとして気持ちが死んでいるわけではないからよかったなと思わせます。本当は意欲がないというより「面倒臭いだけ」と訂正するべきかもですね…&lt;/p>
&lt;p>というわけで、色々とやりたいことだけを並べてみましたが、今年はそろそろ何か実際使えるアプリを作り出すのを第一の目標にしたいと思っています。何か作ってみるだけでも間違いなく良い経験、良い経歴になるはずなので。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Apple Silicon Macに移行する</title><link>https://retheviper.github.io/posts/move-to-apple-silicon/</link><pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/move-to-apple-silicon/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.webp" alt="Featured image of post Apple Silicon Macに移行する" />&lt;p>M1 Macが発売されてもう1年以上が経ちます。最初は流石に&lt;a class="link" href="https://ja.wikipedia.org/wiki/Rosetta" target="_blank" rel="noopener"
>Rosetta&lt;/a>があるとはいえ、ネイティブアプリが少なく問題が起こったり性能が低下するケースも少なくなかったので、すぐにApple Silicon Macを購入しようとは思わなかったのです。それが今はネイティブアプリも増え、OSのアップデートもあったので十分移行しても良いタイミングになっている気がしました。そして今年、M1 ProとM1 Maxを搭載した新しいMacが発表され、既存のintelチップ搭載モデルと比べメリットが多いと思ったので購入を決めることになりました。&lt;/p>
&lt;p>新しいMacについてはチップの性能という面でも、改善されたハードウェア（ディスプレイやスピーカ、キーボードなど）という面でもかなり良いものになっている印象はありますが、ここではあえてそれらについては述べません。多くのベンマークやレビューなどで明らかになっていることが多いと思いますので、ここではintel機からの移行経験に関して述べさせてください。&lt;/p>
&lt;h2 id="移行方法">移行方法
&lt;/h2>&lt;p>まず、Apple Silicon Macに移行を決めてから、以下のような基準を立てました。&lt;/p>
&lt;ul>
&lt;li>既存のMacからマイグレーションする&lt;/li>
&lt;li>なるべくネイティブアプリを使う&lt;/li>
&lt;/ul>
&lt;p>マイグレーションをすると決めた理由は、現在利用中のアプリの設定を最初から見直したくないものが多かったからです。アーキテクチャが違うのでマイグレーションを行わない方と比べ何か問題になる可能性もあるかと思いましたが、実際使用中の今までは特に問題はなかったので、最初から全てをやり直すということがめんどくさい場合はマイグレーションをしても良さそうです。&lt;/p>
&lt;p>また、移行には「移行アシスタント」を使いました。この場合、選べる移行の方法は以下の通りです。&lt;/p>
&lt;ul>
&lt;li>TimeMachine&lt;/li>
&lt;li>Macから移行
&lt;ul>
&lt;li>Wi-Fiを使う&lt;/li>
&lt;li>Thunderboltケーブルで接続&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>TimeMachineを使うと最新の状態が反映されないので、使っているMacから移行することにしました。また、データのコピーにかかる時間が最も短いというのでThunderboltで二つのMacを直結して移行を行なっています。移行には時間は思ったよりそう掛からなく、終わった直後の状態は既存のものと変わらなかったです。&lt;/p>
&lt;p>移行後はApple Siliconネイティブアプリを使いたいので、アプリの情報を一つ一つ確認してUniversalではないものからバイナリを切り替えていくことにしました。&lt;/p>
&lt;h2 id="バイナリの確認">バイナリの確認
&lt;/h2>&lt;p>まずマイグレーションが終わった時点で、インストールされているアプリがApple Siliconネイティブであるかどうかを見分ける方法は以下があります。&lt;/p>
&lt;ul>
&lt;li>Finderから「情報を見る」&lt;/li>
&lt;li>アクティビティモニタの「種類」をみる&lt;/li>
&lt;li>「このMacについて」→「システムレポート」→「ソフトウェア」→「アプリケーション」から探す&lt;/li>
&lt;li>&lt;a class="link" href="https://isapplesiliconready.com" target="_blank" rel="noopener"
>Is Apple Silicon ready?&lt;/a>から探してみる&lt;/li>
&lt;/ul>
&lt;p>他にもintell版のアプリの場合は最初実行時にRosettaをインストールするか確認するダイアログが出るのでそれで確認するという方法もあります。主にターミナルで使うプログラミング言語などがそうですね。ただ、一度でもRosettaをインストールしたらintell版のバイナリでもダイアログなしで実行されてしまうので、全体の移行が終わるまではRosettaをインストールしない方が良いかと思います。&lt;/p>
&lt;h2 id="アプリケーションの切り替え">アプリケーションの切り替え
&lt;/h2>&lt;p>以下はUniversal Binary(IntelとApple Siliconの両方に対応)を提供しているので、Intel機から移行した場合でも特に何もしなくて良いです。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.google.com/intl/ja/chrome" target="_blank" rel="noopener"
>Chrome&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.microsoft.com/ja-jp/edge" target="_blank" rel="noopener"
>Edge&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.mozilla.org/ja/firefox/new/" target="_blank" rel="noopener"
>Firefox&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/edgeview-2/id1206246482" target="_blank" rel="noopener"
>EdgeView2&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://movistprime.com/en" target="_blank" rel="noopener"
>Movist Pro&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/amphetamine/id937984704" target="_blank" rel="noopener"
>Amphetamine&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/id1265704574" target="_blank" rel="noopener"
>Bandizip&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://obsidian.md" target="_blank" rel="noopener"
>Obsidian&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/magnet-%E3%83%9E%E3%82%B0%E3%83%8D%E3%83%83%E3%83%88/id441258766" target="_blank" rel="noopener"
>Magnet&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://crystalidea.com/macs-fan-control/download" target="_blank" rel="noopener"
>Macs Fan Control&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/istat-menus/id1319778037" target="_blank" rel="noopener"
>iStat Menus&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/%E3%83%A6%E3%83%8B%E3%82%B3%E3%83%BC%E3%83%B3-%E5%BA%83%E5%91%8A%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%BF%85%E9%A0%88%E3%82%A2%E3%83%97%E3%83%AA/id1231935892" target="_blank" rel="noopener"
>ユニコーン&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-remote-desktop/id1295203466" target="_blank" rel="noopener"
>Microsoft Remote Desktop&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-word/id462054704" target="_blank" rel="noopener"
>Microsoft Word&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-powerpoint/id462062816" target="_blank" rel="noopener"
>Microsoft PowerPoint&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-excel/id462058435" target="_blank" rel="noopener"
>Microsoft Excel&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-onenote/id784801555" target="_blank" rel="noopener"
>Microsoft OneNote&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-outlook/id985367838" target="_blank" rel="noopener"
>Microsoft Outlook&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一つ、Macs Fan Controlの場合、私はメニューバーにCPUの温度を表示するために使っているのですが、温度を表示する項目を選択する際にintell機だと「CPU PECI」を選べる方が一般的かなと思いますが、Apple Siliconだとそのような項目がありません。しばらく全体的な温度をみたところ、「CPU Performance Core」が最も温度が高いように見えたので、温度を確認したい場合はそれを選んでおいた方がいいかなと思います。&lt;/p>
&lt;h3 id="バイナリを切り替える必要があるケース">バイナリを切り替える必要があるケース
&lt;/h3>&lt;p>以下はApple Silicon用のバイナリを別途提供しているので、ホームページからダウンロードして既存のアプリを上書きするだけで対応できました。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.notion.so/desktop" target="_blank" rel="noopener"
>Notion Desktop&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener"
>Docker Desktop&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.postman.com/downloads/" target="_blank" rel="noopener"
>Postman&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://zoom.us/download" target="_blank" rel="noopener"
>Zoom&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.webex.com/ja/downloads.html" target="_blank" rel="noopener"
>Webex&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/jgraph/drawio-desktop/releases" target="_blank" rel="noopener"
>draw.io&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ただ、DockerはデスクトップアプリそのものはApple Siliconネイティブを使うとしても、イメージがamd64のみ対応するというケースも多いので、ここは色々と検証が必要かなと思います。私の環境ではまだMySQL（5.7）がApple Siliconに対応してなかったのですが、特に問題なく動いています。&lt;/p>
&lt;h2 id="homebrew">Homebrew
&lt;/h2>&lt;p>Rosettaを使って既存のintell版バイナリを使うこともできるらしいのですが、Apple Siliconに対応したバージョンはインストールされるパスが違うし（既存は&lt;code>/usr/local&lt;/code>、Apple Silicon版は&lt;code>/opt/homebrew&lt;/code>）、Apple Silicon版だとインストールされるパッケージは基本的にApple Siliconネイティブになるか、intell版でも新しくビルドしてくれるらしいので、使っていたintell版を消して新しくインストールし直すことにしました。&lt;/p>
&lt;p>アンインストールとインストールは、別に何も意識する必要はありませんでした。公式ホームページに出ている通り、以下のコマンドを実行するだけで良いです。自動でintell版を消してくれて、新しくインストールする場合はApple Silicon版になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># アンインストール&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/bin/bash -c &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># インストール&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/bin/bash -c &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、homebrewでインストールしたパッケージ関しては自分の場合はとりあえず全部削除しておいて、後で必要になったらそれだけインストールしようという方針でしたが、以下のコマンドで使っていたパッケージのリストがバックアップできるらしいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>/usr/local/homebrew/bin/brew bundle dump
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="開発環境">開発環境
&lt;/h2>&lt;p>開発環境の構築に関しては色々なケースがあるので、こちらで別途説明します。&lt;/p>
&lt;h3 id="jetbrains-ide">JetBrains IDE
&lt;/h3>&lt;p>JetBrains社の製品（+ Android Studio）なら&lt;a class="link" href="https://www.jetbrains.com/ja-jp/toolbox-app" target="_blank" rel="noopener"
>Toolbox&lt;/a>で簡単に管理ができるのですが、このアプリ自体もApple Silicon対応のバイナリに変える必要があります。&lt;/p>
&lt;p>ToolboxをApple Siliconネイティブに切り替えた後は、メニューからIDEをアンインストール後に再インストールするだけです。もしToolboxを使ってない場合は、使っているIDEのバイナリをダウンロードし直す必要があります。&lt;/p>
&lt;p>ちなみに、ToolboxからインストールされるIDEは&lt;code>~/Applications/JetBrains Toolbox&lt;/code>の配下にLauncherが置かれ、それをシステムレポートなどで確認するとintel版のバイナリになっています。ただ、実行時はちゃんとApple Siliconネイティブになっているので（アクティビティモニタから確認可能）安心してください。&lt;/p>
&lt;h3 id="visual-studio-code">Visual Studio Code
&lt;/h3>&lt;p>&lt;a class="link" href="https://code.visualstudio.com/download" target="_blank" rel="noopener"
>Visual Studio Code&lt;/a>の場合は、Universal/Intel/Apple Silicon用のバイナリを全部提供していました。多分あえてIntelバージョンをインストールしてなかったら、自然にUniversalにアップデートされていたのではないかと思います。&lt;/p>
&lt;p>あえてUniversalを使う必要はなく、サイズが小さいのでApple Siliconバージョンをダウンロードしたほうがいいかなと思います。&lt;/p>
&lt;p>また、最近はモブプロなどでVisual Studio Live Shareを使うケースが多いかなと思いますが、こちらはまだApple Siliconに対応していません。こちらはGitHubのissueで&lt;a class="link" href="https://github.com/MicrosoftDocs/live-share/issues/4527#issuecomment-984823885" target="_blank" rel="noopener"
>今後対応する予定&lt;/a>だというので、当面は待つしかないですね。&lt;/p>
&lt;h3 id="java">Java
&lt;/h3>&lt;p>Javaの場合、intellだとどのベンダのものを選んでも大差ないですが、Apple Siliconだと少し話が変わってきます。なぜかというと、ベンダ別にApple Siliconに対応しているJDKのバージョンが違うからです。Rosettaを使っていない場合、「bad CPU type in executable」というエラーが発生するので、インストールされているバージョンが&lt;/p>
&lt;p>各ベンダ別のApple Silicon対応済みのLTSバージョンのJDKの一覧は以下の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>JDK&lt;/th>
&lt;th>対応バージョン&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a class="link" href="https://docs.aws.amazon.com/corretto/latest/corretto-17-ug/downloads-list.html" target="_blank" rel="noopener"
>Amazon Corretto&lt;/a>&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://www.azul.com/downloads/?version=java-11-lts&amp;amp;os=macos&amp;amp;architecture=arm-64-bit&amp;amp;package=jdk" target="_blank" rel="noopener"
>Azul Zulu&lt;/a>&lt;/td>
&lt;td>1.8, 11, 17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://bell-sw.com/pages/downloads/#/java-11-lts" target="_blank" rel="noopener"
>Bellsoft Liberica&lt;/a>&lt;/td>
&lt;td>1.8, 11, 17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://adoptium.net" target="_blank" rel="noopener"
>Eclipse Temurin&lt;/a>&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://docs.microsoft.com/ja-jp/java/openjdk/download" target="_blank" rel="noopener"
>Microsoft&lt;/a>&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://www.oracle.com/java/technologies/downloads/#jdk17-mac" target="_blank" rel="noopener"
>Oracle Java SE&lt;/a>&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://sap.github.io/SapMachine" target="_blank" rel="noopener"
>SapMachine&lt;/a>&lt;/td>
&lt;td>11, 17&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上記のJDKのうち、一部はintellijでもダウンロードできるものとなっていて、intellij上ではApple Silicon対応バージョンを&lt;code>aarch64&lt;/code>と表示していますのでインストール時は必ず確認しましょう。&lt;/p>
&lt;p>他にも&lt;a class="link" href="https://developers.redhat.com/products/openjdk/download" target="_blank" rel="noopener"
>Red Hat&lt;/a>や&lt;a class="link" href="https://www.ibm.com/support/pages/java-sdk-downloads-version-110" target="_blank" rel="noopener"
>IBM Semeru&lt;/a>などがありますが、こちらの場合はApple Silicon用のJDKを提供していません。&lt;/p>
&lt;p>最近はどのJDKを選んでも特に問題はないかと思いますので、17を選ぶならOracleのでも良いし、他も好みで選んでも良さそうな気がします。私の場合はずっとAdpotOpenJDKを使っていたので、今回もTemurinを選びました。ただ、Temurinだと11がApple Siliconに対応してないので、そこはZuluを選んでいます。インストールにはhomebrewを使いました。&lt;/p>
&lt;p>Apple Siliconとは直接的な関係はないですが、以下のコマンドで使うJDKのバージョンを簡単に切り替えできるのでさまざまなベンダのJDKを使ってみるのもありかもですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export JAVA_HOME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>/usr/libexec/java_home -v 11&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ java -version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openjdk version &lt;span style="color:#e6db74">&amp;#34;11.0.13&amp;#34;&lt;/span> 2021-10-19 LTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OpenJDK Runtime Environment Zulu11.52+13-CA &lt;span style="color:#f92672">(&lt;/span>build 11.0.13+8-LTS&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OpenJDK 64-Bit Server VM Zulu11.52+13-CA &lt;span style="color:#f92672">(&lt;/span>build 11.0.13+8-LTS, mixed mode&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ export JAVA_HOME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>/usr/libexec/java_home -v 17&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ java -version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openjdk version &lt;span style="color:#e6db74">&amp;#34;17.0.1&amp;#34;&lt;/span> 2021-10-19
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OpenJDK Runtime Environment Temurin-17.0.1+12 &lt;span style="color:#f92672">(&lt;/span>build 17.0.1+12&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OpenJDK 64-Bit Server VM Temurin-17.0.1+12 &lt;span style="color:#f92672">(&lt;/span>build 17.0.1+12, mixed mode&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>GraalVMの場合は、まだApple Siliconに対応していません。ただ2020年からGithubの&lt;a class="link" href="https://github.com/oracle/graal/issues/2666" target="_blank" rel="noopener"
>issue&lt;/a>がオープンの状態であって、Linux+aarch64に対応したバイナリは提供している状態なので、いずれはリリースされるかと思います。&lt;/p>
&lt;h3 id="kotlin">Kotlin
&lt;/h3>&lt;p>Kotlinは1.5.30から&lt;a class="link" href="https://kotlinlang.org/docs/whatsnew1530.html#apple-silicon-support" target="_blank" rel="noopener"
>Apple Siliconサポート&lt;/a>が発表されていますが、これはKotlin/Nativeに関するものなのでKotlin/JVMの場合だとJavaの方だけ気をつけたらいいと思います。こちらもhomebrewでインストールし、特に問題はありませんでした。&lt;/p>
&lt;h3 id="gradle">Gradle
&lt;/h3>&lt;p>Gradleの場合はv6.8.3を使うプロジェクトがあったので、Javaの設定が終わった後にビルドしてみると以下のようなエラーが出ました。（依存関係やプロジェクトの設定によってエラーの種類は変わる可能性があるかと思います）&lt;/p>
&lt;h4 id="java-17で実行した場合">Java 17で実行した場合
&lt;/h4>&lt;p>Java 17(Temurin)で実行した場合、Gradleそのものが実行時にエラーを吐きます。おそらくrefelction関係でdeprecatedになっていたAPIを使っているのが問題になったのではないかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;gt; java.lang.IllegalAccessError: class org.gradle.internal.compiler.java.ClassNameCollector &lt;span style="color:#f92672">(&lt;/span>in unnamed module @0x8f1317&lt;span style="color:#f92672">)&lt;/span> cannot access class com.sun.tools.javac.code.Symbol$TypeSymbol &lt;span style="color:#f92672">(&lt;/span>in module jdk.compiler&lt;span style="color:#f92672">)&lt;/span> because module jdk.compiler does not export com.sun.tools.javac.code to unnamed module @0x8f1317
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="java-11で実行した場合">Java 11で実行した場合
&lt;/h4>&lt;p>Java 11で実行するとコンパイルまでは行われるようですが、テスト（junit）の実行で以下のような問題が起こりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>*** java.lang.instrument ASSERTION FAILED ***: &lt;span style="color:#e6db74">&amp;#34;result&amp;#34;&lt;/span> with message agent load/premain call failed at src/java.instrument/share/native/libinstrument/JPLISAgent.c line: &lt;span style="color:#ae81ff">422&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FATAL ERROR in native method: processing of -javaagent failed, processJavaStart failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Process &lt;span style="color:#e6db74">&amp;#39;Gradle Test Executor 1679&amp;#39;&lt;/span> finished with non-zero exit value &lt;span style="color:#ae81ff">134&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>調べてみると、Gradleはv6.9からApple Siliconに対応したようだったので、ラッパーを最新にバージョンアップ。&lt;code>gradle/wrapper/gradle-wrapper.properties&lt;/code>のバージョン指定を変えるだけでも対応できますが、以下のコマンドを使っています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./gradlew wrapper --gradle-version&lt;span style="color:#f92672">=&lt;/span>7.3.1 --distribution-type&lt;span style="color:#f92672">=&lt;/span>bin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>いきなりv6.8.3からv7.3.1にアップデートしたのですが、テストまで正常終了しています。このプロジェクトはKotlin + Spring bootの構成なので、もし同じような構成のプロジェクトがあるとしたらJava/Kotlin/Gradleのバージョンアップをおこなってからアプリのビルドを試してみましょう。&lt;/p>
&lt;h3 id="ruby--python--go">Ruby / Python / Go
&lt;/h3>&lt;p>RubyとPythonに関してはmacOS上ですでにインストール済みの状態ですが、バージョンやプロジェクトの設定などによっては問題が起こる可能性もあるのでhomebrewでインストールしました。このブログで使っている&lt;a class="link" href="https://jekyllrb.com" target="_blank" rel="noopener"
>jekyll&lt;/a>はrubyをインストールし直したので同じくインストールし直す必要がありました。こちらもhomebrewでインストールができ、既存のプロジェクトにおいてはなんの問題もなく実行することができました。&lt;/p>
&lt;p>Pythonの場合、既存のプロジェクトのパッケージを再インストールする必要がありました。でも&lt;code>requirements.txt&lt;/code>があれば特に問題にはならないくらいです。&lt;/p>
&lt;p>Goの場合も1.16からApple Siliconに対応しているので、特にバージョンの指定が必要なケースでなければ、homebrewで最新をインストールしても良いかなと思います。ただ、既存のプロジェクトのGOROOTやGOPATHの問題があるので、ホームページから別途ダウンロードして設定する必要のあるケースもあるかと思います。&lt;/p>
&lt;h2 id="rosettaを使うしかないケース">Rosettaを使うしかないケース
&lt;/h2>&lt;p>多くのアプリがApple Siliconに対応してきましたが、バージョンアップそのものが終わったり、Rosettaを通じて問題なく動く（からApple Silicon対応は後回しにするという政策の）アプリに関してはネイティブのバイナリが存在しない場合もあるので、仕方なくRosettaを使うしかないかなと思います。&lt;/p>
&lt;p>ソースコードをダウンロードして、ローカルでビルドするという方法もあるかと思いますが、使われているSwiftのバージョンが低い場合はXCodeですぐにビルドできない場合もあったりしました。いつかはRosettaのサボートも終わりそうなので、長期的な観点ではこのようなアプリは他のものに代替した方が良いかもしれません。&lt;/p>
&lt;h3 id="mattermost">Mattermost
&lt;/h3>&lt;p>&lt;a class="link" href="https://mattermost.com/download" target="_blank" rel="noopener"
>Mattermost&lt;/a>はSlackと似たようなコミュニケーションツールで、サーバにインストールすることで無料利用ができるしマークダウンのサポートが優秀だったりするのでプライペートでよく使っています。ただ残念なことに、こちらはまだApple Silicon用の正式リリース版がないようです。&lt;/p>
&lt;p>正式リリースの予定はあるようなのでバージョンアップまでintell版を使うという選択肢もありますが、&lt;a class="link" href="https://github.com/mattermost/desktop/releases" target="_blank" rel="noopener"
>GitHubのリポジトリ&lt;/a>を見るとUniversalとApple Silicon用のバイナリのベータ版も存在しているので、どうしてもRosettaを使いたくない場合はこちらを選んでみても良いかもしれません。&lt;/p>
&lt;h3 id="keyboardcleantool">KeyboardCleanTool
&lt;/h3>&lt;p>&lt;a class="link" href="https://folivora.ai/keyboardcleantool" target="_blank" rel="noopener"
>KeyboardCleanTool&lt;/a>は、アプリを実行している間に全てのキー入力を無視するという単純なツールです。キーボードが汚れて拭きたいときによく使っていますね。残念ながらこちらもまだApple Siliconに対応していません。同じ会社で開発している&lt;a class="link" href="https://folivora.ai" target="_blank" rel="noopener"
>BetterTouchTool&lt;/a>はUniversalバイナリで提供されていますが、その対応ができたのも11月のことなので他の製品が全部Apple Siliconに対応するにはかなり時間がかかるかもしれません。&lt;/p>
&lt;p>このようなアプリは特にネイティブにならなくても困らないものなので、Apple Siliconネイティブ対応はかなり優先順位が低い感がありますね。&lt;/p>
&lt;h2 id="onedrive">OneDrive
&lt;/h2>&lt;p>Microsoft社の製品にしてはかなり珍しいケースですが、対応が遅れていますね。ただ、今月&lt;a class="link" href="https://techcommunity.microsoft.com/t5/microsoft-onedrive-blog/onedrive-sync-for-native-arm-devices-now-in-public-preview/ba-p/3031668" target="_blank" rel="noopener"
>PreviewとしてUniversalバージョンが利用できる&lt;/a>ようになったらしいので、もうすぐApple Siliconネイティブ版が出るかもしれません。その際にはApp Storeで自動的にアップデートされるはずなので、待つだけですね。&lt;/p>
&lt;h2 id="flutter">Flutter
&lt;/h2>&lt;p>Dartは&lt;a class="link" href="https://medium.com/dartlang/announcing-dart-2-14-b48b9bb2fb67" target="_blank" rel="noopener"
>v2.14からNative対応&lt;/a>しているのですが、Flutterはまだ未対応らしく、公式を見ても&lt;a class="link" href="https://github.com/flutter/flutter/wiki/%e3%85%85Developing-with-Flutter-on-Apple-Silicon" target="_blank" rel="noopener"
>Rossettaを推奨&lt;/a>しています。なのでRosettaを入れて実行した方が早いですね。&lt;/p>
&lt;p>他に、&lt;code>flutter doctor&lt;/code>を実行していくつか問題が出るケースがあるかと思います。そういう場合は以下の手順で対応できました。&lt;/p>
&lt;ul>
&lt;li>&lt;code>cmdline-tools component is missing&lt;/code>と出る場合
&lt;ul>
&lt;li>Android Studioから&lt;code>Appearance &amp;amp; Behavior&lt;/code> -&amp;gt; &lt;code>System Settings&lt;/code> -&amp;gt; &lt;code>Android SDK&lt;/code> -&amp;gt; &lt;code>SDK Tools&lt;/code> -&amp;gt; &lt;code>Android SDK Command-Line Tools&lt;/code>にチェックを入れる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>CocoaPods installed but not working&lt;/code>と出る場合
&lt;ul>
&lt;li>&lt;code>brew install cocoapods&lt;/code>でインストール&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>移行が終わって本格的にApple Silicon Macを使ったのはまだ一週間経たないくらいの短い期間ですが、思ったより移行がスムーズで、ネイティブ対応済みのアプリも多かったので、M1が発表された直後の私のように互換性に疑問を持った方がいるとしたら（十分な事前調査を前提として）新しいMacに移行するのもありかも知れないと思います。&lt;/p>
&lt;p>最初はAppleが公式的に全てのMacをApple Siliconに移行するまで2年という計画を立てたという話をしていましたが、ユーザとしてはより時間がかかるのではないかと思っていました。しかし、実際に触ってみると、今でも十分移行ができる状態になっていると思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで和暦を使う</title><link>https://retheviper.github.io/posts/kotlin-japanese-era/</link><pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-japanese-era/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinで和暦を使う" />&lt;p>帳票などで、たまに和暦を処理する必要な時がありますね。例えば元号を表記するとか、和暦の年度を表記するなどの場合があるかと思います。Kotlin(JVM)の場合、西暦だとJavaのAPIの&lt;code>Date&lt;/code>や&lt;code>LocalDate&lt;/code>などのAPIを使うと簡単ですが、和暦が必要となるのはごく一部のケースなので方法がなかなか分かりづらいかと思います。なので、今回はKotlinで和暦を扱う方法について少しまとめてみました。&lt;/p>
&lt;h2 id="japanseera--japanesedate">JapanseEra / JapaneseDate
&lt;/h2>&lt;p>Javaでは、1.8から和暦で日付を扱える&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseDate.html" target="_blank" rel="noopener"
>JapaneseDate&lt;/a>及び元号を扱える&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseEra.html" target="_blank" rel="noopener"
>JapaneseEra&lt;/a>というAPIを提供しています。なので&lt;code>JapaneseDate&lt;/code>のインスタンスを作り、そこから&lt;code>JapaneseEra&lt;/code>を取得することで簡単に元号の情報を取得できるようになります。実際の使い方は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 現在日付のJapaneseDateを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> japaneseDate = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// JapaneseEraの取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> japaneseEra = japaneseDate.era
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>JapaneseDate&lt;/code>の場合、&lt;code>LocalDate&lt;/code>と同じく&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/chrono/ChronoLocalDate.html" target="_blank" rel="noopener"
>ChronoLocalDate&lt;/a>を継承しているのでインスタンスを作成する方法はそう変わりません。なので、以下のようなこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// LocalDateをJapaneseDateに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> japaneseDateFromLocalDate = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.from(&lt;span style="color:#a6e22e">LocalDate&lt;/span>.now())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 特定の日付を指定してJapaneseDate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> japaneseDateFromSpecificDate = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.of(&lt;span style="color:#ae81ff">2000&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">31&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="元号を日本語で表記する">元号を日本語で表記する
&lt;/h2>&lt;p>和暦を扱う場合にやりたいことは大きく二つかと思います。一つは、元号を文字列として扱うこと、そしてもう一つは、和暦での年度を数字として扱うことです。まずは、元号を文字列として取得できる方法について説明します。&lt;/p>
&lt;p>まず上記で紹介した通り、&lt;code>JapaneseDate&lt;/code>のインスタンスを取得した上で、さらにそのオブジェクトが保持している&lt;code>JapaneseEra&lt;/code>を取得する必要があります。その後、&lt;code>JapaneseEra.getDisplayName()&lt;/code>という関数に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/TextStyle.html" target="_blank" rel="noopener"
>TextStyle&lt;/a>と&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/Locale.html" target="_blank" rel="noopener"
>Locale&lt;/a>を指定して文字列を取得することができます。前者は文字の出力型を指定する列挙型定数で、後者は言語の指定と思ってください。&lt;/p>
&lt;p>&lt;code>TextStyle&lt;/code>の場合、以下のような値があります。他の言語だと指定したものによって出力がかなり変わってくるかもしれませんが、日本語の場合は&lt;code>FULL&lt;/code>と&lt;code>NARROW&lt;/code>だけで十分ではないかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>定数&lt;/th>
&lt;th>出力例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>FULL&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>FULL_STANDALONE&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>NARROW&lt;/code>&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>NARROW_STANDALONE&lt;/code>&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SHORT&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SHORT_STANDALONE&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>Locale&lt;/code>の場合、&lt;code>Locale.JAPAN&lt;/code>や&lt;code>Locale.JAPANESE&lt;/code>のどちらを指定しても結果は同じです。ただ、実装としては以下のようになるのでなるべく&lt;code>Locale.JAPAN&lt;/code>を使った方が良さそうです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Locale&lt;/th>
&lt;th>作られるBaseLocaleの設定&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>JAPAN&lt;/code>&lt;/td>
&lt;td>&lt;code>language = ja, region = JP&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>JAPANESE&lt;/code>&lt;/td>
&lt;td>&lt;code>language = ja&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以下はこれらの定数を渡して元号を文字列として取得する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> today = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> era = today.era
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元号を漢字で取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> eraName = era.getDisplayName(&lt;span style="color:#a6e22e">TextStyle&lt;/span>.FULL, &lt;span style="color:#a6e22e">Locale&lt;/span>.JAPAN) &lt;span style="color:#75715e">// 令和
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元号だけでなく、年度までも合わせて表記したい場合もあるかと思います。その場合に使えるものは&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>です。これも&lt;code>JapaneseDate&lt;/code>が実質&lt;code>LocalDate&lt;/code>と同じく&lt;code>ChronoLocalDate&lt;/code>を継承しているから可能なことですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 日付を日本語で表記する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> formatter = &lt;span style="color:#a6e22e">DateTimeFormatter&lt;/span>.ofPattern(&lt;span style="color:#e6db74">&amp;#34;Gy年&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Locale&lt;/span>.JAPAN)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> todayString = formatter.format(&lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now()) &lt;span style="color:#75715e">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしJava 1.8以前のバージョンを使うなどで&lt;code>LocalDate&lt;/code>や&lt;code>JapaneseDate&lt;/code>が使えなく、&lt;code>java.util.Date&lt;/code>の方を使うしかない場合は、以下のような方法で年号と年度の取得が可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> format = SimpleDateFormat(&lt;span style="color:#e6db74">&amp;#34;Gy年&amp;#34;&lt;/span>, Locale(&lt;span style="color:#e6db74">&amp;#34;Ja&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;JP&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;JP&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> year = format.format(Date()) &lt;span style="color:#75715e">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>java.util.Date&lt;/code>を使う場合は、&lt;code>Locale&lt;/code>に第3引数の&lt;code>variant&lt;/code>まで指定する必要があるので、既存の列挙型として定義されたものは使えません。&lt;/p>
&lt;p>また、&lt;code>Locale.ENGLISH&lt;/code>などに設定すると、&lt;code>JapaenseDate&lt;/code>を使っている場合でも取得した結果は&lt;code>AD2021年12月5日&lt;/code>になります。&lt;/p>
&lt;h3 id="合字で表記する">合字で表記する
&lt;/h3>&lt;p>年号については、Unicodeで合字を取得して使いたい場合もあるかと思います。その場合は、以下のようにUnicodeのMapなどを定義しておいて取得するのが良いかと思います。拡張関数などを定義するのも良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> eraUnicodeMap = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.MEIJI to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u337e&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// ㍾
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.TAISHO to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u337d&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// ㍽
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.SHOWA to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u337c&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// ㍼
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.HEISEI to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u337b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// ㍻
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.REIWA to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u32ff&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#75715e">// ㋿
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> era = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now().era
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元号を合字で取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> eraUnicode = eraUnicodeMap[era] &lt;span style="color:#75715e">// ㋿
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のサンプルでは&lt;code>JapaneseEra&lt;/code>が列挙型なのでそのままキーとしていますが、&lt;code>JapaneseEra&lt;/code>は数値としての情報も持っているのでそちらを使う方法もあるでしょう。それぞれの値に対する数値は以下の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>JapaneseEra&lt;/th>
&lt;th>数値&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MEIJI&lt;/td>
&lt;td>-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TAISHO&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SHOWA&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HEISEI&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>REIWA&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>2021年から2022年の3月の場合は令和3年なので、&lt;code>JapaneseEra.REIWA.value&lt;/code>の値が年度だと勘違いされやすいかなと思います。実際の年度の情報は&lt;code>JapaneseDate&lt;/code>の方にあるので注意しましょう。&lt;/p>
&lt;h2 id="年度を数字で表示する">年度を数字で表示する
&lt;/h2>&lt;p>&lt;code>JapaneseEra&lt;/code>は元号を得るために使う列挙型定数のクラスなので、これ自体は&lt;code>JapaneseDate&lt;/code>の日付情報を持っていません。なので参照できる情報は、あくまでも元となる&lt;code>JapaneseDate&lt;/code>が属した元号の情報のみです。&lt;/p>
&lt;p>なので数値としての年度は、列挙型の&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/temporal/ChronoField.html" target="_blank" rel="noopener"
>ChronoField&lt;/a>を&lt;code>JapaneseDate.get()&lt;/code>に渡して取得する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> today = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.of(&lt;span style="color:#ae81ff">2010&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">31&lt;/span>) &lt;span style="color:#75715e">// 平成22年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 年度をIntとして取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> year = today.&lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#a6e22e">ChronoField&lt;/span>.YEAR) &lt;span style="color:#75715e">// 2010
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> yearOfHeisei = today.&lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#a6e22e">ChronoField&lt;/span>.YEAR_OF_ERA) &lt;span style="color:#75715e">// 22
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは&lt;code>JapaneseDate&lt;/code>が&lt;code>LocalDate&lt;/code>と違って、直接&lt;code>year&lt;/code>をgetterで取得できないからです。実際オブジェクトの中を覗いてみると、&lt;code>LocalDate&lt;/code>は年月日をintとshortのフィールドとして保持していることに対して、&lt;code>JapaneseDate&lt;/code>は&lt;code>LocalDate&lt;/code>とint型の&lt;code>yearOfEra&lt;/code>を持っていて、&lt;code>get(ChronoField.YEAR_OF_ERA)&lt;/code>を通じてはじめて&lt;code>yearOfEra&lt;/code>を取得できることになります。getterを用意していないのはおそらく&lt;code>LocalDate&lt;/code>と&lt;code>yearOfEra&lt;/code>という二つの概念があるからなのではないかと思います。もちろん、Kotlinなのでこれは簡単に拡張関数を書くことでgetterを作ることはできますね。&lt;/p>
&lt;p>また、日付のオブジェクトとして&lt;code>LocalDate&lt;/code>を使っている場合は場合は&lt;code>ChronoField.YEAR_OF_ERA&lt;/code>を渡しても西暦の年度が返ってくるので、和暦を使うために&lt;code>JapaneseDate&lt;/code>を使っているかどうかをまず確認しましょう。&lt;/p>
&lt;h3 id="年度を2桁の文字で表示する">年度を2桁の文字で表示する
&lt;/h3>&lt;p>厳密に言って和暦とは関係のないことですが、年度を取得して使う場合、一貫して先端に「0」のついた2桁の文字列として扱いたい場合もあるかと思います。&lt;code>JapaneseDate&lt;/code>を通じて年度を取得した場合は&lt;code>Int&lt;/code>型になるので、1〜9の間は1桁の数字となるわけですが、これを01〜09に表示したい場合は以下の方法が使えます。&lt;/p>
&lt;h4 id="decimalformatを利用する">DecimalFormatを利用する
&lt;/h4>&lt;p>一つは、JavaのAPIである&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/text/DecimalFormat.html" target="_blank" rel="noopener"
>DecimalFormat&lt;/a>を使うことです。小数点の範囲などをわかりやすく指定できるので個人的には好むやり方です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> today = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now() &lt;span style="color:#75715e">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 数字を表示するためのフォーマットを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> decimalFormat = DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;00&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> year = decimalFormat.format(today) &lt;span style="color:#75715e">// 03
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="stringformatを利用する">String.formatを利用する
&lt;/h4>&lt;p>もう一つの方法は、Kotlinのスタンダードライブラリの機能である&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/format.html" target="_blank" rel="noopener"
>String.format()&lt;/a>を使うことです。性能注視なら、こちらの方法が良いかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> today = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now() &lt;span style="color:#75715e">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 数字を表示するためのフォーマットを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> year = &lt;span style="color:#e6db74">&amp;#34;%02d&amp;#34;&lt;/span>.format(today) &lt;span style="color:#75715e">// 03
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="番外kotlinx-datetime">番外：kotlinx-datetime
&lt;/h2>&lt;p>Kotlinには元々日付や時間を扱うAPIがなかったのですが、2020年から&lt;a class="link" href="https://github.com/Kotlin/kotlinx-datetime" target="_blank" rel="noopener"
>kotlinx-datetime&lt;/a>を提供しています。なのでKotlin/JSやKotlin/Nativeなど、JVM上で動かない場合でも日付を扱える公式のAPIができたわけですが、いくつかの懸念があるのでこれを導入するには検討が必要かと思います。&lt;/p>
&lt;h3 id="pre-releaseの段階">Pre-releaseの段階
&lt;/h3>&lt;p>&lt;code>kotlinx-datetime&lt;/code>はまだpre-releaseの段階で、2021年10月に&lt;code>v0.3.1&lt;/code>がリリースされています。なので色々とバグがあったり、思い通りにならない可能性があります。また、開発途中のものなので仕方ありませんが、現時点で提供している機能も&lt;code>java.time&lt;/code>のAPIに比べて少なく、簡単に年号の計算などができるわけではありません。今は必要最低限の機能だけを提供していると思って良いでしょう。&lt;/p>
&lt;h3 id="マルチプラットフォーム向け">マルチプラットフォーム向け
&lt;/h3>&lt;p>Kotlinのスタンダードライブラリ、及び&lt;code>kotlinx&lt;/code>として提供されるライブラリはマルチプラットホームを考慮した実装となっているため、プラットホームが違っても同じ使い方ができるというメリットがありますが、かえってデメリットになる場合もあります。実際、&lt;code>kotlinx-datetime&lt;/code>のJVMの実装は内部的に&lt;code>jata.time&lt;/code>のAPIに依存しているため、JVMだけを使う場合はあえて導入する必要がないともいえます。&lt;/p>
&lt;p>また、プラットフォームごとに実装が違うということはどこかで予期せぬ例外が発生したり、期待した結果にならないケースも発生しえる、ということにもなるかと思います。&lt;/p>
&lt;h2 id="javatimeの懸念">java.timeの懸念
&lt;/h2>&lt;p>&lt;code>JapaneseEra&lt;/code>では明治以前（慶応など）の元号は使えませんが、おそらくその理由は和暦でグレゴリウス暦が使われたのは明治からだったという歴史的な背景があるのではないかと思います。また、&lt;code>JapaneseDate&lt;/code>でも明治6年(西暦1873年1月1日)以前の日付を指定すると以下のように例外が発生します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Exception in thread &lt;span style="color:#e6db74">&amp;#34;main&amp;#34;&lt;/span> java.time.DateTimeException: JapaneseDate before Meiji &lt;span style="color:#ae81ff">6&lt;/span> is not supported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at java.base/java.time.chrono.JapaneseDate.&amp;lt;init&amp;gt;&lt;span style="color:#f92672">(&lt;/span>JapaneseDate.java:333&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at java.base/java.time.chrono.JapaneseDate.of&lt;span style="color:#f92672">(&lt;/span>JapaneseDate.java:257&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、単純に帳票を作るなどのケースでなく、歴史的な研究のための日付計算ではここで紹介した方法は使えないケースもあるかと思います。&lt;/p>
&lt;p>また、JDKのバージョンなどの問題があるためか、&lt;code>JapaneseEra.REIWA&lt;/code>の取得ができなく、エラーとなるケースがあるので注意する必要があります。この場合でも&lt;code>value&lt;/code>の値の取得は問題ないので、少し可読性は低下しながら分岐などの判定に定数をそのまま使うのは避けたほうが良さそうです。（正確な理由はわかりませんが…）&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたか。少し興味本位で調べ始めたもののまとめではありますが、本業の方で実際に必要な処理でもあり、これをどうやって拡張関数として落とせるかということも考えられる良い機会となったかなと思っています。&lt;/p>
&lt;p>また、JavaのAPIに関しては&lt;a class="link" href="https://qiita.com/yamadamn/items/56e7370bae2ceaec55d5" target="_blank" rel="noopener"
>Javaバージョン別の改元(新元号)対応まとめ&lt;/a>という良い記事があったので、興味のある方はご一読ください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその３</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-3/</link><pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-3/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinの隠されたコストーその３" />&lt;p>Kotlinの隠されたコスト、その最後の記事となります。今までの記事もかなり興味深かったですが、今回はさらにKotlinならではの機能に触れているので、Kotlinそのものに対する理解も含めてみる必要があり、さらに深い内容となっているかと思います。&lt;/p>
&lt;p>今回のアジェンダは、「委譲プロパティ」と「rangeを使ったループ」になります。この記事は&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-3-3bf6e0dbf0a4" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 3&lt;/a>の内容を要約したものです。&lt;/p>
&lt;h2 id="委譲プロパティ">委譲プロパティ
&lt;/h2>&lt;p>&lt;a class="link" href="https://kotlinlang.org/docs/delegated-properties.html" target="_blank" rel="noopener"
>委譲プロパティ&lt;/a>とは、&lt;code>getter&lt;/code>と&lt;code>setter&lt;/code>が&lt;code>委譲(delegate)&lt;/code>というオブジェクトによって実装された&lt;a class="link" href="https://kotlinlang.org/docs/properties.html" target="_blank" rel="noopener"
>プロパティ&lt;/a>を指します。これによって再利用可能なカスタムプロパティを作ることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> p: String &lt;span style="color:#66d9ef">by&lt;/span> Delegate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>委譲オブジェクトはプロパティの設定と読み込みのため&lt;code>getValue()&lt;/code>と&lt;code>setValue()&lt;/code>を実装する必要があります。そしてこれらの関数はプロパティのメタデータ（プロパティ名）とオブジェクトのインスタンスを引数として必要とします。&lt;/p>
&lt;p>クラスが委譲プロパティとして定義されると、コンパイラは下記のようなコードを生成します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@NotNull&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Delegate p$delegate &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Delegate();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: 生成されたフィールド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> KProperty&lt;span style="color:#f92672">[]&lt;/span> $$delegatedProperties &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> KProperty&lt;span style="color:#f92672">[]&lt;/span>{(KProperty)Reflection.&lt;span style="color:#a6e22e">mutableProperty1&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> MutablePropertyReference1Impl(Reflection.&lt;span style="color:#a6e22e">getOrCreateKotlinClass&lt;/span>(Example.&lt;span style="color:#a6e22e">class&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;p&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;getP()Ljava/lang/String;&amp;#34;&lt;/span>))};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@NotNull&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String &lt;span style="color:#a6e22e">getP&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">p$delegate&lt;/span>.&lt;span style="color:#a6e22e">getValue&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, $$delegatedProperties&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setP&lt;/span>(&lt;span style="color:#a6e22e">@NotNull&lt;/span> String var1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics.&lt;span style="color:#a6e22e">checkParameterIsNotNull&lt;/span>(var1, &lt;span style="color:#e6db74">&amp;#34;&amp;lt;set-?&amp;gt;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">p$delegate&lt;/span>.&lt;span style="color:#a6e22e">setValue&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, $$delegatedProperties&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>, var1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一部staticプロパティのメタデータがクラスに追加されます。そして毎回値の設定と読み込みが発生するたびにコンストラクタによる初期化が起こります。&lt;/p>
&lt;h3 id="委譲インスタンス">委譲インスタンス
&lt;/h3>&lt;p>上記サンプルでは新しい委譲のインスタンスがプロパティの実装のため生成されています。委譲がstatefulの場合にこのようになります。たとえはローカルで計算されたプロパティを使うなどの場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StringDelegate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> cache: String? = &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getValue&lt;/span>(thisRef: Any?, &lt;span style="color:#66d9ef">property&lt;/span>: KProperty&amp;lt;*&amp;gt;): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> result = cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = someOperation()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>またコンストラクタに追加のパラメータが渡されると、新しい委譲のインスタンスが必要となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> nameView &lt;span style="color:#66d9ef">by&lt;/span> BindViewDelegate&amp;lt;TextView&amp;gt;(&lt;span style="color:#a6e22e">R&lt;/span>.id.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>statelessであり、すでに渡されたオブジェクトのインスタンスとプロパティ名を保ちたいだけなら委譲クラスに&lt;code>object&lt;/code>をつけてsingletonにする方法があります。たとえば下記のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">FragmentDelegate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getValue&lt;/span>(thisRef: Activity, &lt;span style="color:#66d9ef">property&lt;/span>: KProperty&amp;lt;*&amp;gt;): Fragment? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> thisRef.fragmentManager.findFragmentByTag(&lt;span style="color:#66d9ef">property&lt;/span>.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また既存のオブジェクトを拡張して委譲することもできます。つまり、&lt;code>getValue()&lt;/code>や&lt;code>setValue()&lt;/code>を拡張関数として定義することもできるということです。Kotlinではすでに&lt;code>Map&lt;/code>と&lt;code>MutableMap&lt;/code>に拡張関数として委譲するパターンを使っています。（プロパティ名をキーで使っています）&lt;/p>
&lt;p>もし一つのクラス内でローカルの委譲インスタンスに複数のプロパティを保持して再利用したいなら、そのクラスのコンストラクタでインスタンスを初期化しましょう。&lt;/p>
&lt;p>Kotlin 1.1以降、&lt;a class="link" href="https://kotlinlang.org/docs/delegated-properties.html#local-delegated-properties" target="_blank" rel="noopener"
>関数内のローカル変数を委譲プロパティにする&lt;/a>こともできます。この場合、委譲は後で初期化できます。&lt;/p>
&lt;p>クラスに定義された委譲プロパティごとにオーバーヘッドとメタデータの追加が発生するのでなるべくプロパティを再利用できるようにした方が良いでしょう。また、定義したい項目が多い場合に、果たして委譲プロパティが良い選択肢であるかを考慮すべきです。&lt;/p>
&lt;h3 id="ジェネリック委譲">ジェネリック委譲
&lt;/h3>&lt;p>委譲関数はジェネリックでも定義できます。なので委譲クラスをさまざまな型のプロパティとして定義することもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> maxDelay: Long &lt;span style="color:#66d9ef">by&lt;/span> SharedPreferencesDelegate&amp;lt;Long&amp;gt;()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記のようにprimitiveをジェネリック委譲を使う場合、&lt;code>boxing&lt;/code>と&lt;code>unboxing&lt;/code>が値の指定と読み込みで発生することに注意する必要があります。これはプロパティがnon-nullの場合でも起こることです。&lt;/p>
&lt;p>なのでnon-nullなprimitive型の委譲プロパティを定義する場合はジェネリックで定義を避けたほうが良いです。&lt;/p>
&lt;h3 id="スタンダード委譲lazy">スタンダード委譲（lazy()）
&lt;/h3>&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" target="_blank" rel="noopener"
>Delegates.notNull()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html" target="_blank" rel="noopener"
>Delegates.observable()&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html" target="_blank" rel="noopener"
>lazy()&lt;/a>のような委譲のための標準機能が存在しています。&lt;/p>
&lt;p>&lt;code>lazy()&lt;/code>は読み込み専用の委譲プロパティのための関数です。初めて読み込みが発生する際、プロパティを初期化するた目にlambdaを指定できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> dateFormat: DateFormat &lt;span style="color:#66d9ef">by&lt;/span> lazy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SimpleDateFormat(&lt;span style="color:#e6db74">&amp;#34;dd-MM-yyyy&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Locale&lt;/span>.getDefault())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはその値が実際に読み込まれるまで高いコストの初期化を遅延させるという、パフォーマンスと可読性の側面で優れた方法です。&lt;/p>
&lt;p>ただ、&lt;code>lazy()&lt;/code>はinline関数ではなく、引数として渡されたlambdaは別の&lt;code>Function&lt;/code>クラスとしてコンパイルされ、戻り値の委譲オブジェクトもまたinline化されないことには注意する必要があります。&lt;/p>
&lt;p>そして&lt;code>lazy()&lt;/code>関数で見逃しやすいのは&lt;code>mode&lt;/code>という引数で戻り値の委譲タイプを決められるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">lazy&lt;/span>(initializer: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): Lazy&amp;lt;T&amp;gt; = SynchronizedLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">lazy&lt;/span>(mode: LazyThreadSafetyMode, initializer: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): Lazy&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (mode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LazyThreadSafetyMode&lt;/span>.SYNCHRONIZED &lt;span style="color:#f92672">-&amp;gt;&lt;/span> SynchronizedLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LazyThreadSafetyMode&lt;/span>.PUBLICATION &lt;span style="color:#f92672">-&amp;gt;&lt;/span> SafePublicationLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LazyThreadSafetyMode&lt;/span>.NONE &lt;span style="color:#f92672">-&amp;gt;&lt;/span> UnsafeLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mode&lt;/code>を指定していない場合、デフォルトとしては&lt;code>LazyThreadSafetyMode.SYNCHRONIZED&lt;/code>が使われますが、これは複数のスレッドで初期化ブロックが安全に実行されることを保証するためにコストの高い&lt;code>double-checked lock&lt;/code>を行います。&lt;/p>
&lt;p>シングルスレッドしかプロパティに対するアクセスがないというのがわかっているなら、無駄なロックは下げた方がいいでしょう。こういう場合は&lt;code>LazyThreadSafetyMode.NONE&lt;/code>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> dateFormat: DateFormat &lt;span style="color:#66d9ef">by&lt;/span> lazy(&lt;span style="color:#a6e22e">LazyThreadSafetyMode&lt;/span>.NONE) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SimpleDateFormat(&lt;span style="color:#e6db74">&amp;#34;dd-MM-yyyy&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Locale&lt;/span>.getDefault())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ranges">Ranges
&lt;/h2>&lt;p>&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html" target="_blank" rel="noopener"
>Ranges&lt;/a>で限定された範囲の値のセットを定義できます。この値は&lt;code>Comparable&lt;/code>なものならなんでも指定できますね。そして、この表現式を使うと&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-closed-range/" target="_blank" rel="noopener"
>ClosedRange&lt;/a>というインタフェースの実装ができることになります。&lt;/p>
&lt;h3 id="包含テスト">包含テスト
&lt;/h3>&lt;p>rangeを使って範囲内に特定の値が含まれているかどうかを&lt;code>in&lt;/code>や&lt;code>!in&lt;/code>を使って検知することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rangeはnon-nullなprimitive型（&lt;code>Int&lt;/code>, &lt;code>Long&lt;/code>, &lt;code>Byte&lt;/code>, &lt;code>Short&lt;/code>, &lt;code>Float&lt;/code>, &lt;code>Double&lt;/code>, &lt;code>Char&lt;/code>）に対する最適化が行われるので、コンパイルされた結果は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(1 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> i &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、オーバーヘッドや追加オブジェクトの割り当てなどは起こらないです。しかし、primitiveではない場合はどうでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (name &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Alfred&amp;#34;&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Alicia&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlin 1.1.50以前はコンパイル時に&lt;code>ClosedRange&lt;/code>オブジェクトが常に生成されました。しかし、1.1.50からは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(name.compareTo(&lt;span style="color:#e6db74">&amp;#34;Alfred&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(name.compareTo(&lt;span style="color:#e6db74">&amp;#34;Alicia&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">System&lt;/span>.&lt;span style="color:#66d9ef">out&lt;/span>.println(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rangeはまた、&lt;code>when&lt;/code>の条件式でも使えます。&lt;code>if-else&lt;/code>より可読性が良くなりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> message = &lt;span style="color:#66d9ef">when&lt;/span> (statusCode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">200.&lt;/span>.&lt;span style="color:#ae81ff">299&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;OK&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">300.&lt;/span>.&lt;span style="color:#ae81ff">399&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Find it somewhere else&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Oops&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、rangeを使う場合、特定の値が含まれているかどうかをチェックするとき、指定された範囲とそれを使うコードの間に間があるとコストがかかることになります。たとえば以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> myRange &lt;span style="color:#66d9ef">get&lt;/span>() = &lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">rangeTest&lt;/span>(i: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> myRange) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はコンパイルすると&lt;code>IntRange&lt;/code>オブジェクトが追加されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> IntRange &lt;span style="color:#a6e22e">getMyRange&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IntRange(1, 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">rangeTest&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getMyRange&lt;/span>().&lt;span style="color:#a6e22e">contains&lt;/span>(i)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはプロパティのgetterを&lt;code>inline&lt;/code>として定義しても同じです。なのでなるべくrangeが使われるテストの方に直接書くことでオブジェクトが追加されない要因した方が良いです。また、primitiveではないオブジェクトを使う場合は定数として定義し、&lt;code>ClosedRange&lt;/code>のインスタンスを再利用する方法があります。&lt;/p>
&lt;h3 id="forループ">forループ
&lt;/h3>&lt;p>&lt;code>Float&lt;/code>と&lt;code>Double&lt;/code>を除いたprimitive型の範囲をループで使うのも良い選択です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルされた結果にはオーバーヘッドが発生しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">byte&lt;/span> var2 &lt;span style="color:#f92672">=&lt;/span> 11; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> var2; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>逆順にループしたい場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/down-to.html" target="_blank" rel="noopener"
>downTo()&lt;/a>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> downTo &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これにもまた、オーバーヘッドは発生しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">byte&lt;/span> var1 &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">==&lt;/span> var1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">--&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/until.html" target="_blank" rel="noopener"
>until&lt;/a>を使って特定の値未満にループするのも良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> until size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前は少しコストがかかることになりましたが、Kotlin 1.1.4以降は以下のようなコードが生成されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> var2 &lt;span style="color:#f92672">=&lt;/span> size; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> var2; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、そのほかは最適化があまり効いてないケースもあります。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/reversed.html" target="_blank" rel="noopener"
>reversed()&lt;/a>を使う例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> (&lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>).reversed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルされたコードがあまり綺麗とは言えません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>IntProgression var10000 = &lt;span style="color:#a6e22e">RangesKt&lt;/span>.reversed((IntProgression)(new IntRange(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int i = var10000.getFirst();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int var3 = var10000.getLast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int var4 = var10000.getStep();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(var4 &amp;gt; &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &amp;gt; var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(i &amp;lt; var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">System&lt;/span>.&lt;span style="color:#66d9ef">out&lt;/span>.println(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">==&lt;/span> var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">+=&lt;/span> var4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>IntRange&lt;/code>オブジェクトが範囲を再定義するため生成され、さらに&lt;code>IntProgression&lt;/code>オブジェクトが逆順に要素を整列するために生成されます。&lt;/p>
&lt;p>&lt;code>progression&lt;/code>を作るのに二つ以上の関数が使われていると、二つ以上のオブジェクトを作るようなオーバーヘッドが発生することになります。&lt;/p>
&lt;p>上記のルールは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/step.html" target="_blank" rel="noopener"
>step()&lt;/a>を使う場合も同じで、&lt;code>step 1&lt;/code>を指定しても状況は変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span> step &lt;span style="color:#ae81ff">2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに、生成されたコードで最後の値を読み込む時、&lt;code>IntProgression&lt;/code>オブジェクトの最後の要素と&lt;code>step()&lt;/code>で指定した範囲を考慮して追加の処理が行われます。上記のサンプルだと最後の要素は&lt;code>9&lt;/code>です。&lt;/p>
&lt;p>なので、&lt;code>for&lt;/code>を利用したループをするときはなるべく&lt;code>..&lt;/code>、&lt;code>downTo()&lt;/code>、&lt;code>until()&lt;/code>を利用してオーバーヘッドを避けた方が良いでしょう。&lt;/p>
&lt;h3 id="foreachループ">forEachループ
&lt;/h3>&lt;p>&lt;code>for&lt;/code>ループの代わりに、rangeに対してinline拡張関数の&lt;code>forEach()&lt;/code>を使う場合も結果はあまり変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>).forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、&lt;code>forEach()&lt;/code>は&lt;code>Iterable&lt;/code>に対してのみ最適化されてないです。これはつまり、iteratorを生成する必要があるということを意味します。なので、コンパイルされると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Iterable $receiver$iv &lt;span style="color:#f92672">=&lt;/span> (Iterable)(&lt;span style="color:#66d9ef">new&lt;/span> IntRange(1, 10));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Iterator var1 &lt;span style="color:#f92672">=&lt;/span> $receiver$iv.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(var1.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> element$iv &lt;span style="color:#f92672">=&lt;/span> ((IntIterator)var1).&lt;span style="color:#a6e22e">nextInt&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element$iv);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは今までのサンプルよりもコストのかかるものです。&lt;code>IntRange&lt;/code>オブジェクトを生成するだけでなく、&lt;code>IntIterator&lt;/code>オブジェクトも生成しているからです。primitiveではない場合はさらにコストがかかるでしょう。&lt;/p>
&lt;p>なので、rangeを使ったループが必要な場合は&lt;code>forEach()&lt;/code>より&lt;code>for&lt;/code>ループを使ってオーバーヘッドを減らした方が良いです。&lt;/p>
&lt;h3 id="collectionインデックスループ">collectionインデックスループ
&lt;/h3>&lt;p>Kotlinのスタンダードライブラリは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/indices.html" target="_blank" rel="noopener"
>indices&lt;/a>という拡張プロパティで配列と&lt;code>Collection&lt;/code>のインテックスを提供します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> list.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(list[i])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>indices&lt;/code>のコンパイルされた結果は良い最適化を見せてくれます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List list &lt;span style="color:#f92672">=&lt;/span> CollectionsKt.&lt;span style="color:#a6e22e">listOf&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> var2 &lt;span style="color:#f92672">=&lt;/span> ((Collection)list).&lt;span style="color:#a6e22e">size&lt;/span>(); i &lt;span style="color:#f92672">&amp;lt;&lt;/span> var2; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object var3 &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(var3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>IntRange&lt;/code>オブジェクトが作られてないです。では、自前で実装してみるとどうなるのでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> SparseArray&amp;lt;*&amp;gt;.indices: IntRange
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = &lt;span style="color:#ae81ff">0&lt;/span> until size()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">printValues&lt;/span>(map: SparseArray&amp;lt;String&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> map.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(map.valueAt(i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>拡張プロパティとして定義してコンパイルすると、あまり効率的ではないコードになっていることがわかります。&lt;code>IntRange&lt;/code>オブジェクトが作られてます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> static &lt;span style="color:#66d9ef">final&lt;/span> void printValues(&lt;span style="color:#a6e22e">@NotNull&lt;/span> SparseArray map) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Intrinsics&lt;/span>.checkParameterIsNotNull(map, &lt;span style="color:#e6db74">&amp;#34;map&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IntRange var10000 = &lt;span style="color:#a6e22e">RangesKt&lt;/span>.until(&lt;span style="color:#ae81ff">0&lt;/span>, map.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int i = var10000.getFirst();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int var2 = var10000.getLast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#66d9ef">receiver&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>iv = map.valueAt(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">System&lt;/span>.&lt;span style="color:#66d9ef">out&lt;/span>.println(&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#66d9ef">receiver&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>iv);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">==&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合は代わりに&lt;code>until()&lt;/code>と&lt;code>for&lt;/code>ループを使った方が良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">printValues&lt;/span>(map: SparseArray&amp;lt;String&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> until map.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(map.valueAt(i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたか。個人的にはあまり委譲プロパティを使ったことがなく、そもそもの理解を兼ねてかなり勉強になりました。また、rangeに関しても、Javaでの習慣でテストクラスのフィールドとして定義していろいろな関数で使い回していましたが、まさかそれがよりコストのかかることだとは思ってなかったので少しショックでした。&lt;/p>
&lt;p>また、改めてKotlinで提供している機能とAPIに対して正しく理解する必要があると思いました。そして&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%83%E3%82%AB%E3%83%A0%E3%81%AE%E5%89%83%E5%88%80" target="_blank" rel="noopener"
>オッカムの剃刀&lt;/a>でも話しているように、なるべくシンプルなロジックとコードを追求する必要があるとも思いましたね。intellijのメニューのうち、&lt;code>Tools &amp;gt; Kotlin &amp;gt; Show Kotlin Bytecode&lt;/code> でいつでもJavaのコードにdecomplieされたコードを確認できるので、最新だとどのように変換されるのかを確認してみながらコードを最適化を行なった方が良いかもしれません。&lt;/p>
&lt;p>今月はいつもの、自分の経験や仮説を紹介するようなポストでなく、ほぼ翻訳のみになってしまいましたが、私自身としてはかなり貴重な知識を得られたと思っています。またの機会で何か良いものがあったら、是非とも紹介させていただきたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその２</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-2/</link><pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-2/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinの隠されたコストーその２" />&lt;p>今回はまたKotlinの隠されたコストに対するポストです。今となってはあまり気にすることはないかもしれませんし（検証は必要そうですが、バージョンアップごとにコンパイラが生成するコードを追うのは大変そうですね…）、極限のチューニングをするよりもマシンスペックを上げた方がよい時代になったとはいうものの、この記事で紹介していることをコーディングの習慣として身につけておくと良いかなと思います。&lt;/p>
&lt;p>前回は高階関数とLambda、そしてcompanion objectに関する記事を紹介しました。今回はローカル関数、Null安定性、Varargsに隠されたKotlinのコストについて述べます。この記事は&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-2-324a4a50b70" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 2&lt;/a>の内容を要約したものです。&lt;/p>
&lt;h2 id="ローカル関数">ローカル関数
&lt;/h2>&lt;p>関数内に定義した関数を「ローカル関数」と言います。これらローカル関数は、アウター関数（ローカル関数が定義された関数）の範囲にアクセスできます。例えば以下だと、&lt;code>sumSquare&lt;/code>で&lt;code>someMath&lt;/code>のパラメータにアクセスしているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">someMath&lt;/span>(a: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">sumSquare&lt;/span>(b: Int) = (a + b) * (a + b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sumSquare(&lt;span style="color:#ae81ff">1&lt;/span>) + sumSquare(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ローカル関数は基本的にLambdaと似ていますが、他に制限があります。ローカル関数そのものと、ローカル関数を含む関数もまた&lt;code>inline&lt;/code>として定義できません。なので関数の呼び出しにかかるコストを避ける方法がありません。&lt;/p>
&lt;p>コンパイルされたローカル関数は&lt;code>Function&lt;/code>オブジェクトに変わります。なので前回の記事で述べた「インライン化してないLambda」と同じ問題を持っています。上記のコードをJavaのコードで表すと以下のような形になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">someMath&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Function1 sumSquare$ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Function1(1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: 生成されたメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: ブリッジメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object var1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Integer.&lt;span style="color:#a6e22e">valueOf&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">invoke&lt;/span>(((Number)var1).&lt;span style="color:#a6e22e">intValue&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">invoke&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (a &lt;span style="color:#f92672">+&lt;/span> b) &lt;span style="color:#f92672">*&lt;/span> (a &lt;span style="color:#f92672">+&lt;/span> b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sumSquare$.&lt;span style="color:#a6e22e">invoke&lt;/span>(1) &lt;span style="color:#f92672">+&lt;/span> sumSquare$.&lt;span style="color:#a6e22e">invoke&lt;/span>(2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Lambdaと比べ一つ性能が劣化されない点があります。関数のインスタンスが呼び出し元からわかるので、ジェネリックなインタフェースを使わず、匿名クラスになりメソッドが直接呼び出されます。これは外の関数からローカル関数を呼び出す際に、&lt;code>casting&lt;/code>や&lt;code>boxing&lt;/code>が発生しないということを意味します。実際のBytecodeを見ると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ICONST_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKEVIRTUAL be/myapplication/MyClassKt$someMath$1.invoke (I)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ICONST_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKEVIRTUAL be/myapplication/MyClassKt$someMath$1.invoke (I)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IADD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IRETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでメソッドが2回呼び出されていますが、メソッドの引数も戻り値も&lt;code>int&lt;/code>型になっていて、&lt;code>boxing&lt;/code>と&lt;code>unboxing&lt;/code>がないのを確認できます。&lt;/p>
&lt;p>ただ、依然としてメソッドが呼び出されるたびに&lt;code>Function&lt;/code>オブジェクトのインスタンスを生成していますが、ローカル関数をvalue caputeなしのものに代替することでこの問題は回避できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">someMath&lt;/span>(a: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">sumSquare&lt;/span>(a: Int, b: Int) = (a + b) * (a + b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sumSquare(a, &lt;span style="color:#ae81ff">1&lt;/span>) + sumSquare(a, &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにすることで、&lt;code>Function&lt;/code>オブジェクトのインスタンスは再利用できるようなものになります。こうすることで既存のprivate関数に比べ、ローカル関数のデメリットは追加のクラス（メソッドを含む）を生成するということだけになります。&lt;/p>
&lt;p>ローカル関数はprivate関数の代替として、アウター関数の変数にアクセスできるというメリットがあります。ただこれによって&lt;code>Function&lt;/code>オブジェクトを生成するというコストがかかりますので、non-capturingにする工夫が必要です。&lt;/p>
&lt;h2 id="null安全性">Null安全性
&lt;/h2>&lt;p>Kotlinの最も良い機能の一つは明視的にnullになり得る型とそうでない型を区別できるということです。これによってコンパイラがランタイムで予期せぬ&lt;code>NullPointerException&lt;/code>を投げるのを防止できます。&lt;/p>
&lt;h3 id="non-nullパラメータのランタイムでのチェック">Non-nullパラメータのランタイムでのチェック
&lt;/h3>&lt;p>例えば以下のような関数があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>(who: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">$who&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはJavaのコードで以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>(&lt;span style="color:#a6e22e">@NotNull&lt;/span> String who) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics.&lt;span style="color:#a6e22e">checkParameterIsNotNull&lt;/span>(who, &lt;span style="color:#e6db74">&amp;#34;who&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String var1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> who;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(var1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>@NotNull&lt;/code>アノテーションが追加され、Java側にnullが渡されてはいけないということを知らせています。&lt;/p>
&lt;p>しかし、アノテーションは呼び出し側にnull safetyを強制するものではありません。なのでstaticメソッドを呼び出してパラメータをもう一度確認しています。この関数は&lt;code>IllegalArgumentException&lt;/code>を投げて呼び出し元の修正を簡単にします。&lt;/p>
&lt;p>publicな関数には常にnon-nullなパラメータに対して&lt;code>Intrinsics.checkParameterIsNotNull()&lt;/code>でのチェックがが追加されますが、privateな関数に対しては追加されません。なぜなら、Kotlinクラスはnull safeであることをコンパイラが保証するからです。&lt;/p>
&lt;p>このNullチェックによるパフォーマンスへの影響は無視しても良いほどでテストにも有用ですが、ビルド時にもっと時間がかかる原因になります。これに対してはコンパイラのオプションに&lt;code>-Xno-param-assertions&lt;/code>を追加するか、&lt;a class="link" href="https://www.guardsquare.com/proguard" target="_blank" rel="noopener"
>ProGuard&lt;/a>のルールに以下の設定を追加することでランタイムNullチェックをなくすことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span>assumenosideeffects &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">kotlin&lt;/span>.&lt;span style="color:#a6e22e">jvm&lt;/span>.&lt;span style="color:#a6e22e">internal&lt;/span>.&lt;span style="color:#a6e22e">Intrinsics&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">checkParameterIsNotNull&lt;/span>(java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">Object&lt;/span>, java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ上記のルールを追加する場合、AndroidのProGuardのOptimization設定が有効になっているかのチェックがまず必要です。この設定はデフォルトでは無効になっています。&lt;/p>
&lt;h3 id="nullable-primitive型">Nullable primitive型
&lt;/h3>&lt;p>まず先に覚えておくべきことは、nullableで宣言したprimitive型は常にJavaの&lt;code>int&lt;/code>や&lt;code>float&lt;/code>などの代わりに&lt;code>Integer&lt;/code>、&lt;code>Float&lt;/code>といった&lt;code>boxed reference&lt;/code>型が使われるので追加のコストが発生するということです。&lt;/p>
&lt;p>&lt;a class="link" href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/autoboxing.html" target="_blank" rel="noopener"
>autoboxing&lt;/a>とnull-safetyを無視するのでJavaでは&lt;code>Integer&lt;/code>でも&lt;code>int&lt;/code>でもコードはあまり変わらないJavaに対して、Kotlinだとnullableに対して安全なコードを書くように強制しているので、non-nullの方を使った方が良いというのが明確にわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a: Int, b: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a + b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a: Int?, b: Int?): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (a &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) + (b &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、なるべくコードの可読性と性能を考慮してnon-nullの方を選んだ方が良いです。&lt;/p>
&lt;h3 id="配列">配列
&lt;/h3>&lt;p>Kotlinには、以下の3通りの配列があります。&lt;/p>
&lt;ul>
&lt;li>&lt;code>IntArray&lt;/code>、&lt;code>FloatArray&lt;/code>のようなもの：primitive型の配列。&lt;code>int[]&lt;/code>、&lt;code>float[]&lt;/code>のような型にコンパイルされる。&lt;/li>
&lt;li>&lt;code>Array&amp;lt;T&amp;gt;&lt;/code>：non-nullオブジェクトの型が指定された配列。primitiveに対して&lt;code>boxing&lt;/code>が起こりえる。&lt;/li>
&lt;li>&lt;code>Array&amp;lt;T?&amp;gt;&lt;/code>：nullableオブジェクトの型が指定された配列。明確に&lt;code>boxing&lt;/code>が起こる。&lt;/li>
&lt;/ul>
&lt;p>もしnon-nullなprimitive型の配列が必要な場合は、なるべく&lt;code>Array&amp;lt;Int&amp;gt;&lt;/code>の代わりに&lt;code>IntArray&lt;/code>を使いましょう。&lt;/p>
&lt;h2 id="varargs">Varargs
&lt;/h2>&lt;p>KotlinではJavaとは書き方が少し違いますが、&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#variable-number-of-arguments-varargs" target="_blank" rel="noopener"
>可変長引数&lt;/a>を定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">printDouble&lt;/span>(&lt;span style="color:#66d9ef">vararg&lt;/span> values: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values.forEach { println(&lt;span style="color:#66d9ef">it&lt;/span> * &lt;span style="color:#ae81ff">2&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaと同じく、&lt;code>vararg&lt;/code>はコンパイルされると指定した型の配列になります。そして上記の関数は以下のように、３つの方法で呼び出すことができます。&lt;/p>
&lt;h3 id="複数のパラメータを渡す">複数のパラメータを渡す
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>printDouble(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinのコンパイラはこれを新しい配列の生成と初期化に変えます。これはJavaと一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>printDouble(new int[]{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはつまり新しい配列を作るためのオーバヘッドがあるということです。ただJavaと変わらないやり方です。&lt;/p>
&lt;h3 id="配列を渡す">配列を渡す
&lt;/h3>&lt;p>Javaでは配列をそのまま渡すことができますが、Kotlinだとそれができず、&lt;code>spread operator&lt;/code>を使う必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> values = intArrayOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(*values)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaでは配列の参照が&lt;code>as-is&lt;/code>として関数に渡され、新しい配列の割り当ては起こりません。しかし、Kotlinの&lt;code>spread operator&lt;/code>は以下のようなことをします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> values &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span>{1, 2, 3};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(Arrays.&lt;span style="color:#a6e22e">copyOf&lt;/span>(values, values.&lt;span style="color:#a6e22e">length&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列のコピーが関数に渡されるので、より安全なコードといえます。呼び出し側には影響なしで、配列を修正できますので。しかしメモリを追加的に消費してしまいます。&lt;/p>
&lt;h3 id="配列と他の引数を混ぜて渡す">配列と他の引数を混ぜて渡す
&lt;/h3>&lt;p>&lt;code>spread operator&lt;/code>の良い点は、配列と他の引数を混ぜて渡すこともできるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> values = intArrayOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(&lt;span style="color:#ae81ff">0&lt;/span>, *values, &lt;span style="color:#ae81ff">42&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はどうコンパイルされるか気になりませんか？結果はかなり面白いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> values &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span>{1, 2, 3};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IntSpreadBuilder var10000 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IntSpreadBuilder(3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000.&lt;span style="color:#a6e22e">add&lt;/span>(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000.&lt;span style="color:#a6e22e">addSpread&lt;/span>(values);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000.&lt;span style="color:#a6e22e">add&lt;/span>(42);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(var10000.&lt;span style="color:#a6e22e">toArray&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列を新しく生成するだけでなく、一時的なビルダオブジェクトを使って配列の最終的なサイズを計算しています。なので配列を渡す時よりもコストは追加されます。&lt;/p>
&lt;p>なので、呼び出される回数の多くパフォーマンスが重要なコードに対してはなるべく可変長引数より実際の配列をパラメータとして使った方が良いです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたか。個人的にprivate関数をよく使うので、よりスコープを制限できるという面でローカル関数を積極的に使いたいと思っていましたが、ここでも隠されたコストがあるというというのは興味深かったです。primitive型についてはJavaがそうだったので、なんとなく&lt;code>boxing&lt;/code>が起こるんじゃないかなと思っていたものの、nullableに対してのみそうだというのも面白かったですね。逆に、primitiveのままになるnon-null型に対してはどうやってチェックが走るのだろうという新しい疑問もありました。（例えば&lt;code>int&lt;/code>だとデフォルト値の&lt;code>0&lt;/code>が常に割り当てられるので）&lt;/p>
&lt;p>あと、配列の場合はJavaでも&lt;code>IntStream&lt;/code>、&lt;code>DoubleStream&lt;/code>などがあったのでなんとなくすぐ理解ができましたが、まさか&lt;code>varargs&lt;/code>で渡したパラメータに対して色々とコストが追加されるとは思わなかったです。そもそもあまり配列を使わないので、可変長引数を使う場面もなかったのですが…よく使わないものほど重要なことを忘れやすそうなので、これは覚えておかないとですね。色々と勉強になりました。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその１</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-1/</link><pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-1/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinの隠されたコストーその１" />&lt;p>Kotlinは便利ですが、何が便利かというと代表的に挙げられるものがたくさんのシンタクスシュガーではないかと思います。同じJVM言語のJavaと比べ、多くの場合でコード量が劇的に減るのが嬉しいという評価も多いものですね。しかし、この便利さの裏には隠されたコスト（性能面での）があるという話があります。今回はそれについて説明している良い記事を見つけたので、共有したいと思います。ただ、翻訳よりは要約に近いものなので、そこはご了承ください。&lt;/p>
&lt;p>ちなみにここで紹介している記事（&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 1&lt;/a>）は、2017年に作成された（Kotlinがまだ1.1だったころ）ので、1.5にまでバージョンアップを成している今からすると、コンパイラの改善などで少し状況が違うケースもあるかと思いますが、述べている内容のレベルが高いので一度は目を通してみても良いかなと思います。また、記事で紹介しているKotlinのBytecodeに対しても、直接最近のKotlinが生成しているコードと比較してみるのも面白いかもですね。&lt;/p>
&lt;p>また、今回紹介している記事は&lt;code>Part 1&lt;/code>ですが、そのほかにも&lt;code>Part 2&lt;/code>や&lt;code>Part 3&lt;/code>の記事がありますので、今後も順次紹介させていただきたいと思います。では、まず&lt;code>Lambda表現式とcompanion object&lt;/code>編を、どうぞ。&lt;/p>
&lt;h2 id="高階関数とlambda表現式">高階関数とLambda表現式
&lt;/h2>&lt;p>例えば以下のような関数を定義しておいたとしましょう。渡されたパラメータをDBのトランザクションの中で実行し、実行結果の行数を返すものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">transaction&lt;/span>(db: Database, body: (Database) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.beginTransaction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = body(db)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.setTransactionSuccessful()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.endTransaction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数は、Lambdaを渡して以下のように使えますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> deletedRows = transaction(db) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.delete(&lt;span style="color:#960050;background-color:#1e0010">“&lt;/span>Customers&lt;span style="color:#960050;background-color:#1e0010">”&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinはJava 1.6のJVMから使えますが、Java 1.6のJVMではLambdaに対応していないのです。なので、Kotlinはその互換性を維持するためにLambda（匿名関数も）を&lt;code>Function&lt;/code>というオブジェクトを生成することで対応しています。&lt;/p>
&lt;h3 id="functionオブジェクト">Functionオブジェクト
&lt;/h3>&lt;p>では、実際コンパイルされたLambda（body）がJavaのコードとしてはどうなっているかをみていきましょう。（ここでは、Intellij/Android Studioの&lt;code>Show Kotlin Bytecode&lt;/code>の&lt;code>Decompile&lt;/code>機能を使っています）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass$myMethod$1&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Function1 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: 生成されたメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: ブリッジメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object var1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Integer.&lt;span style="color:#a6e22e">valueOf&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">invoke&lt;/span>((Database)var1));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">invoke&lt;/span>(&lt;span style="color:#a6e22e">@NotNull&lt;/span> Database it) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics.&lt;span style="color:#a6e22e">checkParameterIsNotNull&lt;/span>(it, &lt;span style="color:#e6db74">&amp;#34;it&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> it.&lt;span style="color:#a6e22e">delete&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Customers&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを見るとわかりますが、Lambda（匿名関数）を使う場合、コンパイルされた結果としては基本的に3、4個のメソッドが追加で生成されるということになります。ここで追加された&lt;code>Function&lt;/code>オブジェクトのインスタンスは、必要な時にだけ生成されます。正確には、以下のような動作をします。&lt;/p>
&lt;ul>
&lt;li>value captureがある場合、毎回パラメータが渡されるたび&lt;code>Function&lt;/code>のインスタンスが生成され、GCの対象になる&lt;/li>
&lt;li>value captureがない場合、&lt;code>Function&lt;/code>はSingletonとしてインスタンスが生成され再利用できる&lt;/li>
&lt;/ul>
&lt;p>先ほどのコードでは、value captureがないため、Lambdaの呼び出し元は以下のようなコードとしてコンパイルされます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">transaction&lt;/span>(db, (Function1)MyClass$myMethod$1.&lt;span style="color:#a6e22e">INSTANCE&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、value captureのある高階関数を繰り返し呼び出す場合はGCによる性能の低下を考えれます。&lt;/p>
&lt;h3 id="boxingオーバーヘッド">Boxingオーバーヘッド
&lt;/h3>&lt;p>Lambdaに対応しているJava 1.8以降のバージョンでは、&lt;code>Function&lt;/code>インタフェースを複数提供していることでなるべくboxing/unboxingを避けようとしています。しかし、Kotlinでコンパイルされた場合はgenericを利用しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/** 引数を一つ受け取る関数 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Function1&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">in&lt;/span> P1, &lt;span style="color:#66d9ef">out&lt;/span> R&amp;gt; : Function&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/** 引数を受け取り関数を実行する */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">invoke&lt;/span>(p1: P1): R
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらをみてわかるのは、高階関数でパラメータとして渡された関数を呼び出す時に、その関数にprimitiveタイプの値が存在する場合（パラメータ、もしくは戻り値）boxing/unboxingが起こるということです。先ほどのコンパイルされたLambdaにおいて、戻り値が&lt;code>Integer&lt;/code>としてboxingされたのを確認できましたね。&lt;/p>
&lt;p>primitiveタイプを使用するLambdaをパラメータとしてとる高階関数は、参照回数が少なければあまり意識しなくてもよいコストになりますが、そうでない場合は性能に影響があると推定できます。&lt;/p>
&lt;h3 id="inline関数">Inline関数
&lt;/h3>&lt;p>幸い、Kotlinでは&lt;code>inline&lt;/code>と言うキーワドを提供しています。これを使うと高階関数をインライン化できますね。インライン化されると呼び出し元のコードに&lt;code>Function&lt;/code>の中身を直接含ませてコンパイルします。なので、インライン化された場合は以下のような面で性能の向上を考えられます。&lt;/p>
&lt;ul>
&lt;li>Functionオブジェクトのインスタンスが生成されない&lt;/li>
&lt;li>primitiveタイプを使う関数に対してboxing/unboxingが起こらない&lt;/li>
&lt;li>メソッドカウントが増えない（Androidの場合、アプリが参照できるメソッドの数字に制限がある）&lt;/li>
&lt;li>関数の呼び出しが増えない（CPU依存が高く、呼び出される頻度の高いコードのパフォーマンスの改善を期待できる）&lt;/li>
&lt;/ul>
&lt;p>インライン化された場合のコードを確認してみましょう。&lt;code>transaction&lt;/code>関数が消え、&lt;code>db.delete&lt;/code>を直接呼び出しているのがわかります。また、戻り値の&lt;code>result&lt;/code>もWrapperクラスからprimitiveタイプになっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>db.&lt;span style="color:#a6e22e">beginTransaction&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> result$iv &lt;span style="color:#f92672">=&lt;/span> db.&lt;span style="color:#a6e22e">delete&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Customers&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#a6e22e">setTransactionSuccessful&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#a6e22e">endTransaction&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、&lt;code>inline&lt;/code>キーワードを使うときは以下のことを考慮しなければならないです。&lt;/p>
&lt;ul>
&lt;li>インライン関数は自分自身を直接呼び出したり、他のインライン関数から呼び出せない&lt;/li>
&lt;li>クラスに定義されたpublicなインライン関数はそのクラスのpublic関数とフィールドのみアクセスできる&lt;/li>
&lt;li>コンパイルされたコードが大きくなる（繰り返し参照される場合はより大きくなる）&lt;/li>
&lt;/ul>
&lt;p>なるべく高階関数をインライン化し、必要であれば長いコードブロックをインラインではない関数に写した方がいいです。また、性能が大事なところでは呼び出された関数をインライン化することも考えられます。&lt;/p>
&lt;h2 id="companion-object">Companion object
&lt;/h2>&lt;p>Kotlinではクラスがstaticなフィールドやメソッドを定義できません。その代わりに&lt;code>companion object&lt;/code>を使うことになっていますね。&lt;/p>
&lt;h3 id="クラスのprivateフィールドをcompanion-objectからアクセスする">クラスのprivateフィールドをcompanion objectからアクセスする
&lt;/h3>&lt;p>以下のような例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> hello = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">newInstance&lt;/span>() = MyClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードがコンパイスされると、&lt;code>companion object&lt;/code>はSingletonクラスになります。なので、クラスのprivateフィールドに外部クラスからアクセスできるようにする必要があり、コンパイラが&lt;code>getter&lt;/code>、&lt;code>setter&lt;/code>を追加で生成することになるということです。生成されたメソッドは&lt;code>companion object&lt;/code>から参照されることになります。以下を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass.access$getHello$p (Lbe/myapplication/MyClass;)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ISTORE 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaだとこれを避けるためにアクセス制限を&lt;code>package&lt;/code>単位にすることができましたが、Kotlinではそのようなキーワードがないですね。&lt;code>public&lt;/code>や&lt;code>internal&lt;/code>を使う場合も&lt;code>getter&lt;/code>と&lt;code>setter&lt;/code>は基本的に生成されます。また、これらのメソッドはinstanceメソッドであり、staticメソッドよりもコストが高いですね。なので、最適化のためフィールドのアクセス制限を変えるということは避けた方が良いです。&lt;/p>
&lt;p>もし&lt;code>companion object&lt;/code>からクラスのフィールドに頻繁なアクセスが発生するとしたら、この隠れているメソッドの呼び出しを避けるためにフィールドの値をキャッシュするという方法も考慮できます。&lt;/p>
&lt;h3 id="companion-objectの定数にアクセスする">Companion objectの定数にアクセスする
&lt;/h3>&lt;p>Kotlinでは、クラス内のstaticな定数は&lt;code>companion object&lt;/code>の中に定義するのが一般的です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> TAG = &lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(TAG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見シンプルで良さげなコードですが、Kotlin 1.2.40以前の場合だとかなり裏のコードは汚くなっています。&lt;/p>
&lt;h4 id="kotlin-1240以前の場合">Kotlin 1.2.40以前の場合
&lt;/h4>&lt;p>&lt;code>companion object&lt;/code>に定義されたprivateな定数にアクセスする場合、上記のようなこと（&lt;code>getter&lt;/code>を利用する）が起こります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GETSTATIC be/myapplication/MyClass.Companion : Lbe/myapplication/MyClass$Companion;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass$Companion.access$getTAG$p (Lbe/myapplication/MyClass$Companion;)Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ASTORE 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>問題はこれだけではありません。生成されたメソッドは実際の値を返すわけでなく、instanceメソッドとして生成された&lt;code>getter&lt;/code>を呼び出すことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESPECIAL be/myapplication/MyClass$Companion.getTAG ()Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>定数が&lt;code>public&lt;/code>になっている場合はダイレクトにアクセスできるようになりますが、依然として&lt;code>getter&lt;/code>メソッドを通して値にアクセスことになります。&lt;/p>
&lt;p>そして定数の値を格納するために、Kotlinコンパイラは&lt;code>companion object&lt;/code>ではなく、それを持つクラスの方に&lt;code>private static final&lt;/code>フィールドを生成します。さらに&lt;code>companion object&lt;/code>からこのフィールドにアクセスするため、またのメソッドを生成することとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass.access$getTAG$cp()Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こういう長い道のりで、やっと値を読み込むことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GETSTATIC be/myapplication/MyClass.TAG : Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まとめると、Kotlin 1.2.40以前のバージョンを使っている場合は以下のようになります。&lt;/p>
&lt;ul>
&lt;li>&lt;code>companion object&lt;/code>から静的メソッドを呼び出す
&lt;ul>
&lt;li>&lt;code>companion object&lt;/code>からinstanceメソッドを呼び出す
&lt;ul>
&lt;li>クラスのstaticメソッドを呼び出す
&lt;ul>
&lt;li>staticフィールドから値を読み込む&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>これをJavaのコードで表現すると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String TAG &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Companion companion &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Companion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 生成されるメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String &lt;span style="color:#a6e22e">access$getTAG$cp&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> TAG;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Companion&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String &lt;span style="color:#a6e22e">getTAG&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> MyClass.&lt;span style="color:#a6e22e">access$getTAG$cp&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 生成されるメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String &lt;span style="color:#a6e22e">access$getTAG$p&lt;/span>(Companion c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> c.&lt;span style="color:#a6e22e">getTAG&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Companion.&lt;span style="color:#a6e22e">access$getTAG$p&lt;/span>(companion));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>よりコストの低いBytecodeを生成することも可能ですが、それは簡単ではないです。&lt;/p>
&lt;p>まず&lt;code>const&lt;/code>キーワードを使ってコンパイルタイム定数を定義することでメソッドの呼び出しをなくすことができます。しかし、KotlinではprimitiveかStringに対してのみ可能な方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> TAG = &lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(TAG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または&lt;code>@JvmField&lt;/code>を使ってJavaのアプローチを取る方法を考えられます。こうすることで&lt;code>getter&lt;/code>や&lt;code>setter&lt;/code>が生成されず、フィールドに直接アクセスができるようになります。ただ、&lt;code>@Jvm&lt;/code>系のアノテーションはJavaとの互換性のためのものであるのでこれが果たして良い方法かどうかを考えた方が良いでしょう。そして&lt;code>public&lt;/code>なフィールドのみ可能な方法です。&lt;/p>
&lt;p>Androidの開発の場合だと、&lt;code>Parcelable&lt;/code>オブジェクトを自前で実装する場合のみ有効な方法に思われます。例えば以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span>() : Parcelable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JvmField&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> CREATOR = creator { MyClass(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(parcel: Parcel) : &lt;span style="color:#66d9ef">this&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">writeToParcel&lt;/span>(dest: Parcel, flags: Int) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">describeContents&lt;/span>() = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後の方法として、&lt;a class="link" href="https://developer.android.com/studio/build/shrink-code" target="_blank" rel="noopener"
>ProGuard&lt;/a>やR8のようなツールを使ってBytecodeの最適化を狙うという方法があるでしょう。&lt;/p>
&lt;h4 id="kotlin-1240以降の場合">Kotlin 1.2.40以降の場合
&lt;/h4>&lt;p>Kotlinn 1.2.40からは、&lt;code>companion object&lt;/code>に定義された値はメインクラスの方に格納されるということには変わりがありませんが、メソッドの生成と呼び出しなしで直接アクセスができるようになりました。これをJavaのコードとして表現すると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String TAG &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Companion companion &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Companion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Companion&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(TAG);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、上記のように&lt;code>companion object&lt;/code>にメソッドが一つもない場合は、ProGuardやR8によるツールと使うとクラス自体が消えることで最適化されます。&lt;/p>
&lt;p>ただ、&lt;code>companion object&lt;/code>に定義さえたメソッドの場合はコストが少しかかります。フィールドがメインクラスの方に格納されてあるため、&lt;code>companion object&lt;/code>に定義されたprivateフィールドにアクセスするためには依然として生成されたメソッドを経由することになります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回は人の書いた記事を読んだだけですが、かなり勉強になる内容でした。特に私個人としては、intellijを使っていると何を基準に&lt;code>inline&lt;/code>キーワードを使った方がいいという警告が出るのか悩ましい場面がありましたが、それが少し理解できました。&lt;code>companion object&lt;/code>に関する話も、今は問題が解決されたものの、何も考えず「定数だから&lt;code>companion object&lt;/code>だな」と思っていた自分を反省することになりましたね。そしてこの後の記事でも面白い内容が色々と出てくるので、またの機会でぜひ紹介したいと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>色々な言語でやってみた（ソート編）</title><link>https://retheviper.github.io/posts/languages-comparsion-sorting/</link><pubDate>Wed, 10 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/languages-comparsion-sorting/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.webp" alt="Featured image of post 色々な言語でやってみた（ソート編）" />&lt;p>今はどんなプログラミング言語を選んでもできることはあまり違わなく、まさに好みで選んでもいいと思えるくらいの時代となっていると思います。特に、&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>のようなトランスパイラーやFlutterのようなフレームワークも続々と登場している時代なので、こういう傾向はこれからもどんどん加速していくのではないかと思います。&lt;/p>
&lt;p>しかしそのような変化がある一方で、今現在はプログラマに一人が扱えるプログラミング言語の数に対する要求も増えいている状況ではないかと思います。実際の業務ではさまざまな理由で使われる言語が決まっていて、自分が今まで触ったことのないものでも使えるようになる必要があり、一人のエンジニアが固定されたポジションでなく、さまざまな分野にかけて実装を行うケースもありますしね。いわゆる&lt;a class="link" href="https://en.wikipedia.org/wiki/Polyglot_%28computing%29" target="_blank" rel="noopener"
>Polyglot&lt;/a>の時代とも言えます。&lt;/p>
&lt;p>なので、少なくともいろいろな言語の特徴を把握しておくということが大事になっているのではないかと思います。そして、そのような必要によるものでなくても、自分が普段接してない言語のコンセプトに触れてみることで、メインとなる言語への理解が深まることもあるのではないのかなと思ったりもします。これはどんな言語でもできることはあまり変わらないということともある意味通じているのですが、他の言語のコンセプトを受け入れた新しいAPIや機能を導入したり、そのようなライブラリが登場する場合もあるので。&lt;/p>
&lt;p>さて、前置きが長くなりましたが、ということで、これからはたまにとある操作をするときにいろいろな言語ではどうやってできるのか、そしてそうした場合の特徴などを簡単に比べてみたいと思います。今回は、配列のソートになります。&lt;/p>
&lt;h2 id="javascript">JavaScript
&lt;/h2>&lt;p>JavaScriptでは&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" target="_blank" rel="noopener"
>Array.prototype.sort()&lt;/a>で配列のソートができます。なので、以下のようなコードを使えます。シンプルですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">sort&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、元の配列の値は変更せず、新しくソートされた配列を作りたい場合は以下の方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [...&lt;span style="color:#a6e22e">a&lt;/span>].&lt;span style="color:#a6e22e">sort&lt;/span>() &lt;span style="color:#75715e">// aをコピーしてソート
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここで気づいた方もいらっしゃると思いますが、ソートされた値が期待通りにはなっていません。本当なら、&lt;code>1, 22, 44, 300, 5000&lt;/code>になるのが普通でしょう。ここで昇順に値をソートしたい場合は、ソートの方法を自前で作成する必要があります。例えば以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">sort&lt;/span>((&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span>) =&amp;gt; &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>sort()&lt;/code>では、引数として渡す&lt;code>compareFunction&lt;/code>（引数が二つ、戻り値はnumber）の戻り値の結果によって、以下のことが起こります。&lt;/p>
&lt;ul>
&lt;li>0より小さいと、aのインデックスをbの先に置く&lt;/li>
&lt;li>0だと、aとbは変更しない&lt;/li>
&lt;li>0より大きいと、bのインデックスをaの先に置く&lt;/li>
&lt;/ul>
&lt;p>これはJavaをやっていた方だと、&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html" target="_blank" rel="noopener"
>Comparator&lt;/a>と同じだなとすぐわかる内容ですね。アロー関数の形もJavaのLambdaに似ているので、あまり違和感なく適応できるかと思います。かなりシンプルなのですが、number型の配列に対しては自前の&lt;code>compareFunction&lt;/code>が必要となるということは大事なので、気を付ける必要はあるでしょう。&lt;/p>
&lt;p>配列のインデックスを反転したい場合は、&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse" target="_blank" rel="noopener"
>Array.prototype.reverse()&lt;/a>を使うだけで良いです。この場合はnumberの配列でも自前の&lt;code>compareFunction&lt;/code>が必要ないので、便利ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">reverse&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[ &lt;span style="color:#ae81ff">5000&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span> ]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="java">Java
&lt;/h2>&lt;p>では、次にJavaの方も見ていきましょう。先に述べた通り、&lt;code>Comparator&lt;/code>を使うと簡単にソートの方法を実装できるので、基本的には同じです。ただ、Javaの場合だとそもそも&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#sort-java.util.Comparator-" target="_blank" rel="noopener"
>List.sort()&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Collections.html#sort-java.util.List-" target="_blank" rel="noopener"
>Collections.sort()&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Arrays.html#sort-int:A-" target="_blank" rel="noopener"
>Arrays.sort()&lt;/a>、[Stream.sorted()]など方法が色々あり、ソートしたいCollectionやArrayなどが&lt;code>Immutable&lt;/code>であるかどうか、&lt;code>Comparator&lt;/code>や&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html" target="_blank" rel="noopener"
>Comparable&lt;/a>を自前で実装するか、それともスタンダードライブラリに用意されてあるものを使うかなどのさまざまな選択肢も考慮する必要があるということですね。&lt;/p>
&lt;p>色々な選択肢がある中で、もっとも簡単なのは、&lt;code>Collections.sort()&lt;/code>や&lt;code>Arrays.sort()&lt;/code>を使う方法かなと思います。これを使う場合、primitive型やStringのListは短いコードでソートができるという（そして標準機能という）メリットがありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>() {{ add(22); add (1); add(44); add(300); add(5000); }};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22, 1, 44, 300, 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> Collections.&lt;span style="color:#a6e22e">sort&lt;/span>(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>1, 22, 44, 300, 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、&lt;code>List.sort()&lt;/code>が簡単です。&lt;code>Comparator&lt;/code>を引数として渡す必要がありますが、昇順・降順でソートしたい場合は既に用意されてあるメソッドを呼び出すだけですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>() {{ add(22); add (1); add(44); add(300); add(5000); }};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22, 1, 44, 300, 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> a.&lt;span style="color:#a6e22e">sort&lt;/span>(Comparator.&lt;span style="color:#a6e22e">naturalOrder&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>1, 22, 44, 300, 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに&lt;code>Comparator&lt;/code>で使える既定のソート方法は以下があります。&lt;/p>
&lt;ul>
&lt;li>昇順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#naturalOrder--" target="_blank" rel="noopener"
>naturalOrder()&lt;/a>&lt;/li>
&lt;li>降順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#reverseOrder--" target="_blank" rel="noopener"
>reverseOrder()&lt;/a>&lt;/li>
&lt;li>逆順: &lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Comparator.html#reversed--" target="_blank" rel="noopener"
>reversed()&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>また、&lt;code>Comparator&lt;/code>は、&lt;code>Collections.sort()&lt;/code>の引数としても使えます。なので、降順にソートしたい場合は以下のようなコードを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>() {{ add(22); add (1); add(44); add(300); add(5000); }};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22, 1, 44, 300, 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> Collections.&lt;span style="color:#a6e22e">sort&lt;/span>(a, Comparator.&lt;span style="color:#a6e22e">reverseOrder&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>5000, 300, 44, 22, 1&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、元のListの値を変更せず、新しくソートされた結果を取得したい場合は、元のListをコピーする方法もありますが、もう一つの方法として&lt;code>Stream&lt;/code>を使う方法を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(22, 1, 44, 300, 5000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22, 1, 44, 300, 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> a.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">sorted&lt;/span>().&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>1, 22, 44, 300, 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Stream&lt;/code>でソートする場合でも、&lt;code>Comparator&lt;/code>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(22, 1, 44, 300, 5000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>22, 1, 44, 300, 5000&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jshell&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> a.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">sorted&lt;/span>(Comparator.&lt;span style="color:#a6e22e">reverseOrder&lt;/span>()).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#f92672">==&amp;gt;&lt;/span> &lt;span style="color:#f92672">[&lt;/span>5000, 300, 44, 22, 1&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、DTOのListをソートしたい場合は、DTOが&lt;code>Comparable&lt;/code>を継承するという方法も考えられますが、多くの場合はソート時の条件が明確にわかる&lt;code>Comparator&lt;/code>を実装したいいかなと思います。汎用性や柔軟性を考えても、&lt;code>Comparable&lt;/code>の場合、条件が変わるとクラスを修正する必要があるので、&lt;code>Comparator&lt;/code>を使った方が無難かなと思います。&lt;/p>
&lt;p>Arrayの場合、&lt;code>Arrays.sort()&lt;/code>を利用してソートできる（もちろん&lt;code>Comparator&lt;/code>も使えます）上に、ListやStreamに変換することもできるので上記の方法をそのまま使えます。なので選択肢はもっと多いわけですが、便利な（好みに合う）方法を選ぶといいかなと思います。個人的には&lt;code>Arrays.sort()&lt;/code>に&lt;code>Comparator&lt;/code>を渡した方が可読性という面で良さそうな気がします。&lt;/p>
&lt;h2 id="kotlin">Kotlin
&lt;/h2>&lt;p>Sytax Sugarをたくさん提供しているKotlinらしく、選べるソートのオプションがたくさんあります。なので、少しまとめてみました。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Orderの種類&lt;/th>
&lt;th>ソート結果&lt;/th>
&lt;th>fun&lt;/th>
&lt;th>備考&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Natural&lt;/td>
&lt;td>呼び出し元&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort.html" target="_blank" rel="noopener"
>Array/MutableList.sort()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-descending.html" target="_blank" rel="noopener"
>Array/MutableList.sortDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reverse.html" target="_blank" rel="noopener"
>Array/MutableList.reverse()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Array&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array.html" target="_blank" rel="noopener"
>Array.sortedArray()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array-descending.html" target="_blank" rel="noopener"
>Array.sortedArrayDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reversed-array.html" target="_blank" rel="noopener"
>Array.reveredArray()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted.html" target="_blank" rel="noopener"
>Array/List.sorted()&lt;/a>&lt;/td>
&lt;td>昇順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-descending.html" target="_blank" rel="noopener"
>Array/List.sortedDescending()&lt;/a>&lt;/td>
&lt;td>降順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/as-reversed.html" target="_blank" rel="noopener"
>List/MutableList.asRevered()&lt;/a>&lt;/td>
&lt;td>逆順&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Custom&lt;/td>
&lt;td>呼び出し元&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-by.html" target="_blank" rel="noopener"
>Array/MutableList.sortBy()&lt;/a>&lt;/td>
&lt;td>昇順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort-by-descending.html" target="_blank" rel="noopener"
>Array/MutableList.sortByDescending()&lt;/a>&lt;/td>
&lt;td>降順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by.html" target="_blank" rel="noopener"
>Array/Iterable.sortedBy()&lt;/a>&lt;/td>
&lt;td>昇順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by-descending.html" target="_blank" rel="noopener"
>Array/Iterable.sortedByDescending()&lt;/a>&lt;/td>
&lt;td>降順、selector((T) -&amp;gt; R)必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>Array&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-array-with.html" target="_blank" rel="noopener"
>Array.sortedArrayWith()&lt;/a>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/" target="_blank" rel="noopener"
>Comparator&lt;/a>必要&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>List&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-with.html" target="_blank" rel="noopener"
>Array/Iterable.sortedWith()&lt;/a>&lt;/td>
&lt;td>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparator/" target="_blank" rel="noopener"
>Comparator&lt;/a>必要&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>かなり多い選択肢があるように見えますが、こうやって表としてまとめてみるとまぁまぁわかりそうな気はします。自前の比較処理を書く必要があるか、ソートした結果が元の配列かどうか、そしてArrayになるかListになるかなどいくつかの基準で分けられるということが分かれば大体どれを使った方がいいか悩む必要はないかなと思います。&lt;/p>
&lt;p>なので、まずやりたいことを明確にした上で、どのAPIを使うかを選んで書くだけです。以下はListから、ソートされた新しいListを作成する例です。それぞれ昇順と降順の場合となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> a = listOf(&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> b = a.sorted()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[1, 22, 44, 300, 5000]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> c = a.sortedDescending()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[5000, 300, 44, 22, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、data classの配列をソートしたい場合は&lt;code>sortBy&lt;/code>や&lt;code>sortedBy&lt;/code>を使えます。ここで引数に必要なのは&lt;code>(T) -&amp;gt; R&lt;/code>型のselectorですが、単純にどれを基準にソートするかを指定すれば良いだけですので実装は簡単です。以下の例を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> number: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> a = listOf(Data(&lt;span style="color:#ae81ff">22&lt;/span>), Data(&lt;span style="color:#ae81ff">1&lt;/span>), Data(&lt;span style="color:#ae81ff">44&lt;/span>), Data(&lt;span style="color:#ae81ff">300&lt;/span>), Data(&lt;span style="color:#ae81ff">5000&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> b = a.sortedBy { &lt;span style="color:#66d9ef">it&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Data(number=1), Data(number=22), Data(number=44), Data(number=300), Data(number=5000)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> c = a.sortedByDescending { &lt;span style="color:#66d9ef">it&lt;/span>.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[Data(number=5000), Data(number=300), Data(number=44), Data(number=22), Data(number=1)]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、より複雑な比較の条件を指定したい場合はJavaの場合と同じく、&lt;code>Comparator&lt;/code>を実装すると良いでしょう。やはりJavaと似ているようで、より単純化した（そしてそのせいで選択肢は増えた）感覚ですね。&lt;/p>
&lt;h2 id="swift">Swift
&lt;/h2>&lt;p>Swiftでは、シンプルに元のCollectionをソートするかソートされた新しいCollectionを作るかの選択肢しかないようです。あまり変わったことはないですが、元のCollectionをソートする場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">var&lt;/span> a = [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a: [Int] = &lt;span style="color:#ae81ff">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">0&lt;/span>] = &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">1&lt;/span>] = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">2&lt;/span>] = &lt;span style="color:#ae81ff">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">3&lt;/span>] = &lt;span style="color:#ae81ff">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">4&lt;/span>] = &lt;span style="color:#ae81ff">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>&amp;gt; a.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span>&amp;gt; print(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして新しいCollectionを作成したい場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">let&lt;/span> a = [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a: [Int] = &lt;span style="color:#ae81ff">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">0&lt;/span>] = &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">1&lt;/span>] = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">2&lt;/span>] = &lt;span style="color:#ae81ff">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">3&lt;/span>] = &lt;span style="color:#ae81ff">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">4&lt;/span>] = &lt;span style="color:#ae81ff">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>&amp;gt; &lt;span style="color:#66d9ef">let&lt;/span> b = a.sorted()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b: [Int] = &lt;span style="color:#ae81ff">5&lt;/span> values {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">0&lt;/span>] = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">1&lt;/span>] = &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">2&lt;/span>] = &lt;span style="color:#ae81ff">44&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">3&lt;/span>] = &lt;span style="color:#ae81ff">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="color:#ae81ff">4&lt;/span>] = &lt;span style="color:#ae81ff">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span>&amp;gt; print(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Swiftのソートが独特なのはどうやってソートするか、その方法を指定する時です。&lt;a class="link" href="https://developer.apple.com/documentation/swift/array/2296801-sort" target="_blank" rel="noopener"
>sort()&lt;/a>でも&lt;a class="link" href="https://developer.apple.com/documentation/swift/array/2296815-sorted" target="_blank" rel="noopener"
>sorted()&lt;/a>でも引数として&lt;code>areInIncreasingOrder&lt;/code>という関数を渡すことができるようになっていますが、JavaScriptやJava、Kotlinで使われていた&lt;code>compareFunction&lt;/code>や&lt;code>Comparator&lt;/code>の戻り値が数字であったことに対して、&lt;code>areInIncreasingOrder&lt;/code>はpredicate型として戻り値がBoolになっています。なので以下のような形でソートの方法を指定可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> students: Set = [&lt;span style="color:#e6db74">&amp;#34;Kofi&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Abena&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Peter&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Kweku&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Akosua&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> descendingStudents = students.sorted(by: &lt;span style="color:#f92672">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(descendingStudents) &lt;span style="color:#75715e">// &amp;#34;[&amp;#34;Peter&amp;#34;, &amp;#34;Kweku&amp;#34;, &amp;#34;Kofi&amp;#34;, &amp;#34;Akosua&amp;#34;, &amp;#34;Abena&amp;#34;]&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、classのフィールドを基準にソートしたい場合は以下の方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span> { &lt;span style="color:#66d9ef">var&lt;/span> number = &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> datas = [Data(number: &lt;span style="color:#ae81ff">1&lt;/span>), Data(number: &lt;span style="color:#ae81ff">3&lt;/span>), Data(number: &lt;span style="color:#ae81ff">4&lt;/span>), Data(number: &lt;span style="color:#ae81ff">2&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> descending = datas.sorted { $0.number &lt;span style="color:#f92672">&amp;gt;&lt;/span> $1.number }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dump(descending)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> descending: [Data] = 4 values {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> [0] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> number = 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> [1] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> number = 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> [2] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> number = 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> [3] = {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> number = 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="go">Go
&lt;/h2>&lt;p>Goにはジェネリックがないからか、&lt;a class="link" href="https://pkg.go.dev/sort" target="_blank" rel="noopener"
>sort&lt;/a>というパッケージに、sliceの種類によってソート用のfuncが色々と用意されています。例えば以下のようなものがあります。&lt;/p>
&lt;ul>
&lt;li>func Float64s(x []float64)&lt;/li>
&lt;li>func Ints(x []int)&lt;/li>
&lt;li>func Strings(x []string)&lt;/li>
&lt;/ul>
&lt;p>なので、structのsliceではい場合はこれらの中でどれかを選んでソートすることになりますね。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">int&lt;/span>{&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Ints&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>) &lt;span style="color:#75715e">// [1 22 44 300 5000]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>structの場合は、以下のような方法が使えます。ソートの基準がまた&lt;code>bool&lt;/code>になっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">people&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Gopher&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">55&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Vera&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">24&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Slice&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">Name&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>].&lt;span style="color:#a6e22e">Name&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>) &lt;span style="color:#75715e">// [{Alice 55} {Bob 75} {Gopher 7} {Vera 24}]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>面白いのは、Goのソートには&lt;a class="link" href="https://pkg.go.dev/sort#SliceStable" target="_blank" rel="noopener"
>sort.SliceStable()&lt;/a>というものが別に存在しているということです。これは&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%AE%89%E5%AE%9A%E3%82%BD%E3%83%BC%E3%83%88" target="_blank" rel="noopener"
>安定ソート&lt;/a>を行うもので、その定義に関してはWikiでは以下のように述べています。&lt;/p>
&lt;blockquote>
&lt;p>同等なデータのソート前の順序が、ソート後も保存されるものをいう。つまり、ソート途中の各状態において、常に順位の位置関係を保っていることをいう。&lt;/p>&lt;/blockquote>
&lt;p>つまり、安定ソートの場合、ソートの基準となる値が同等の要素間の元の位置関係（インデックス）が保証されるということですね。その結果が実際どうなるのかを見てみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">people&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Elizabeth&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Alice&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">75&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Bob&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Colin&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;Elizabeth&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">SliceStable&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">Age&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>].&lt;span style="color:#a6e22e">Age&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>) &lt;span style="color:#75715e">// [{Alice 25} {Bob 25} {Colin 25} {Elizabeth 25} {Alice 75} {Alice 75} {Bob 75} {Elizabeth 75}]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードの実行結果でわかるように、&lt;code>Alice 25&lt;/code>、&lt;code>Bob 25&lt;/code>、&lt;code>Colin 25&lt;/code>、&lt;code>Elizabeth 25&lt;/code>と&lt;code>Alice 75&lt;/code>, &lt;code>Bob 75&lt;/code>, &lt;code>Elizabeth 75&lt;/code>の元の順が維持されたままソートされたのがわかります。ここでもし&lt;code>sort.Slice()&lt;/code>を使うと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Slice&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>].&lt;span style="color:#a6e22e">Name&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">people&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>].&lt;span style="color:#a6e22e">Name&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">people&lt;/span>) &lt;span style="color:#75715e">// [{Alice 25} {Alice 75} {Alice 75} {Bob 75} {Bob 25} {Colin 25} {Elizabeth 75} {Elizabeth 25}]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安定ソートはそうでないソートに比べ性能が劣る可能性が高いので（元のインデックスをまで考慮しているので）、一つの値を基準にソートしても問題ない場合は&lt;code>sort.Slice()&lt;/code>でも十分な気がしますが、そうでない場合は安定ソートを考慮する必要がありそうですね。&lt;/p>
&lt;h2 id="python">Python
&lt;/h2>&lt;p>Pythonでは&lt;a class="link" href="https://docs.python.org/3/library/stdtypes.html#list.sort" target="_blank" rel="noopener"
>list.sort()&lt;/a>か、&lt;a class="link" href="https://docs.python.org/3/library/functions.html#sorted" target="_blank" rel="noopener"
>sorted()&lt;/a>を使えます。他の言語でも大体同じだったので命名だけでも推測が可能かと思いますが、前者は元のlistをソートするもので、後者は新しいlistを作り出すものです。&lt;/p>
&lt;p>まず&lt;code>list.sort()&lt;/code>は、以下のように使えます。他の言語とあまり変わらないですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a&lt;span style="color:#f92672">.&lt;/span>sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> print(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>それに対して、&lt;code>sorted()&lt;/code>は以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> sorted(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> print(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">22&lt;/span>, &lt;span style="color:#ae81ff">44&lt;/span>, &lt;span style="color:#ae81ff">300&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、これらの関数では&lt;code>key&lt;/code>や&lt;code>reverse&lt;/code>のようなパラメータを指定することで、どれを基準にソートするか、逆順にソートするかなどを指定できます。Pythonらしいシンプルさですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">__init__&lt;/span>(self, number):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>number &lt;span style="color:#f92672">=&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">__repr__&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> repr((self&lt;span style="color:#f92672">.&lt;/span>number))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datas &lt;span style="color:#f92672">=&lt;/span> [Data(&lt;span style="color:#ae81ff">1&lt;/span>), Data(&lt;span style="color:#ae81ff">3&lt;/span>), Data(&lt;span style="color:#ae81ff">2&lt;/span>), Data(&lt;span style="color:#ae81ff">4&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datas&lt;span style="color:#f92672">.&lt;/span>sort(key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">lambda&lt;/span> data: data&lt;span style="color:#f92672">.&lt;/span>number) &lt;span style="color:#75715e"># [1, 2, 3, 4]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sorted(datas, key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">lambda&lt;/span> data: data&lt;span style="color:#f92672">.&lt;/span>number, reverse&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>) &lt;span style="color:#75715e"># [4, 3, 2, 1]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="番外stable-sort">番外：Stable sort
&lt;/h2>&lt;p>Goのソート方法の中で少し安定ソートの話が出ましたが、ここで比較した他の言語だとGoのように安定ソートとそうでないソートのどれを使うかという選択肢がなかったので、それぞれの言語での安定ソートはどうやって扱われているのかを表にしてみました。以下をご覧ください。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>言語&lt;/th>
&lt;th>stable&lt;/th>
&lt;th>non-stable&lt;/th>
&lt;th>備考&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Go&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>funcによって選べられる&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Java&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>Streamはnon-stable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>JavaScript&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>ブラウザのバージョンによる&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Python&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kotlin&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>SequenceでもStable&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Swift&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>⭕️&lt;/td>
&lt;td>&lt;code>stableを保証できない&lt;/code>と表現&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>多くの言語が安定ソートに対応していますが、少しづつ仕様が違う場合がありました。例えばJavaの場合、Streamによるソートは安定ソートではないため、安定ソートの結果を保証したい場合は既にソートされたCollectionを使うことをおすすめしています。Kotlinの場合はStreamに似たSequenceを使う場合でも、&lt;code>stateful&lt;/code>なためか、安定ソートに対応していました。&lt;/p>
&lt;p>また、JavaScriptの場合はブラウザのバージョンによって違いますが、最新のブラウザを使っている場合は大抵安定ソートに対応していました。ただ、JavaScirptを使った案件の場合はIEも対象ブラウザとして考慮される場合があるのですが、IEだと安定ソートに対応していないので確認が必要かなと思います。&lt;/p>
&lt;p>Swiftの場合はまだソート時のデフォルト値をstableにするかどうかを検討している中で、APIとしてもGoのようにstableとそうでないものを分離するかどうかを検討しているらしいです。またどのアルゴリズムを使うかについて議論しているらしく、しばらくは安定ソートを期待できないかと思います。&lt;/p>
&lt;p>KotlinとPythonはどの場合でも安定ソートとなるので、悩み事が一つ減るのが嬉しいですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回は色々な言語のソートについて調べてみましたが、いかがでしたか。一度ソートしたデータはその後の要素に対するアクセスが早くなるので、チューニングの観点からは必要なものかと思います。そしてこうやって色々な言語のソートのAPIを調べてみると、その言語の設計思想や発展の過程のようなものが少し見えるようで面白く、勉強にもなりますね。個人的にはあまり意識してなかった安定ソートがかなり勉強になりました。&lt;/p>
&lt;p>これからもこうやって色々な言語の使用やAPI、同じことをする場合の各言語による違いなどを比べてみたいと思います。時間と体力が十分であればの話ではありますが…！&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Quarkusを触ってみた</title><link>https://retheviper.github.io/posts/quarkus-first-impression/</link><pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/quarkus-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/quarkus.webp" alt="Featured image of post Quarkusを触ってみた" />&lt;p>Spring MVCは良いフレームワークではありますが、最近流行りの&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9" target="_blank" rel="noopener"
>マイクロサービス&lt;/a>には向いてないという批判もあります。理由としては、アプリの起動時間が遅い、サイズが大きい、メモリの使用量が多いなどの問題が挙げられていますね。アプリの起動速度が遅い場合は、変更があった場合の素早い反映が期待できません。アプリのサイズが大きいのとメモリ使用量が多いとインスタンスが増えれば増えるほどコストが高くなるということになりますね。また、これはマイクロサービスだけの話でもないです。サーバレスアプリで、あえてJavaScirptやPythonのようなインタプリタ言語を採用しているのも同じ理由があってこそですね。&lt;/p>
&lt;p>では、これらの問題はどうやって回避できるのでしょうか。そもそもの問題から考えると、全てが全てSpringに局限する問題でもないはずです。他のフレームワークに比べてSpringの起動時間が決して早いとは言えなかったり、メモリの使用量が多いという問題があるのは確かですが、JVMをベースにしている言語を使う限り、ある程度は仕方ない問題にも見えます。JVM言語においてはそのアプリの起動時間、サイズ、メモリ使用量のどれにもJVMが占める割合を含めて考える必要があるからですね。&lt;/p>
&lt;p>ただ、これらの問題を解決できる方法が全くないわけでもありません。今回紹介するのが、その答えとして開発されている&lt;a class="link" href="https://quarkus.io" target="_blank" rel="noopener"
>Quarkus&lt;/a>です。&lt;/p>
&lt;h2 id="quarkusとは">Quarkusとは
&lt;/h2>&lt;p>Quarkusは、&lt;a class="link" href="https://www.redhat.com/ja/technologies/linux-platforms/enterprise-linux" target="_blank" rel="noopener"
>RHEL&lt;/a>で有名なRed Hatが作ったJava用のウェブフレームワークです。公式ホームページの説明が何よりも正確だと思いますので、以下の文を確認してください。&lt;/p>
&lt;blockquote>
&lt;p>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.&lt;/p>&lt;/blockquote>
&lt;p>Javaのアプリを&lt;code>Kubernetes Native&lt;/code>として作成できる、というのがこのフレームワークの正体性です。Javaと説明していますが、もちろんKotlinのような他のJVM言語も使えるので、そのような言語を使っている場合でも導入を考えられます。&lt;/p>
&lt;p>ここで&lt;code>Kubernetes Native&lt;/code>という言葉が気になりますが、これは単純にコンテナを作ることに特化されている、という表現ではないと思います。Spring Boot 2.3から導入された&lt;a class="link" href="https://spring.io/blog/2020/08/14/creating-efficient-docker-images-with-spring-boot-2-3" target="_blank" rel="noopener"
>Docker Image作成機能&lt;/a>があり、Googleが提供している&lt;a class="link" href="https://github.com/GoogleContainerTools/jib" target="_blank" rel="noopener"
>Jib&lt;/a>のようなライブラリでいくらでもJavaアプリケーションをコンテナ化することができますし、そのほかにもコンテナを作る方法はいくらでもあります。なので、ここで&lt;code>Kubernetes Native&lt;/code>という表現をあえて使っているのは、Kubernetesに特化したものとして設計されているということを意味すると思った方が自然でしょう。&lt;/p>
&lt;p>では、一体何を持って&lt;code>Kubernetes Native&lt;/code>と言えるのでしょう。インフラストラクチャの観点でいう&lt;code>Kubernetes Native&lt;/code>は、Kubernetesだけで完結するアーキテクチャを指しているようです。Kubernetesで完結するということは、それに合わせて最適化しているということと同じ意味合いでしょう。アプリケーションの観点からしてもそれは大きく違わないはずです。まず、Quarkusでは以下のような特徴があると紹介されています。&lt;/p>
&lt;ul>
&lt;li>Nativeコンパイルができる&lt;/li>
&lt;li>起動速度が速い&lt;/li>
&lt;li>メモリ使用量が少ない&lt;/li>
&lt;/ul>
&lt;p>Nativeコンパイルができるということは、JVMを使用する必要がなくなるということなので、先に挙げた三つの問題を全部解消できます。だとすると、マイクロサービスやサーバレスのみでなく、コンテナ単位でのデプロイでもかなり有利になりますね。そして、JVMを使った場合でも他のフレームワークに比べて起動速度とメモリ使用量で優位にあると言われているので、これが本当だとNativeコンパイルしない場合でも十分メリットがあると思われます。&lt;/p>
&lt;h2 id="実際触ってみると">実際触ってみると
&lt;/h2>&lt;p>特徴として挙げられているもの全てが魅力的ではありますが、実際そのフレームワークを使ってみないとわからないこともあります。なので、ちょっとしたサンプルを作り触ってみました感想について少し述べたいと思います。&lt;/p>
&lt;h3 id="起動速度">起動速度
&lt;/h3>&lt;h4 id="spring-bootの場合">Spring Bootの場合
&lt;/h4>&lt;p>Springの起動速度は、DIしているクラスによって大きく異なるので、ここでは&lt;a class="link" href="https://start.spring.io" target="_blank" rel="noopener"
>Spring initializr&lt;/a>から以下の項目のみ設定したアプリケーションを使って起動してみました。&lt;/p>
&lt;ul>
&lt;li>Project: Gradle&lt;/li>
&lt;li>Language: Kotlin&lt;/li>
&lt;li>Spring Boot: 2.5.5&lt;/li>
&lt;li>Packaging: War&lt;/li>
&lt;li>Java: 11&lt;/li>
&lt;li>Dependencies: なし&lt;/li>
&lt;/ul>
&lt;p>そしてローカルでは、Oracle JDK 17を使って起動しています。気のせいかもしれませんが、Java 11を使っていた時より起動が早いような気がしますね。とりわけ、上記通りの設定を済ましたアプリを起動してみると、以下のような結果となりました。（ローカルマシンの情報は消しています）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> . ____ _ __ _ _
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /&lt;span style="color:#ae81ff">\\&lt;/span> / ___&lt;span style="color:#e6db74">&amp;#39;_ __ _ _(_)_ __ __ _ \ \ \ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">( ( )\___ | &amp;#39;&lt;/span>_ | &lt;span style="color:#e6db74">&amp;#39;_| | &amp;#39;&lt;/span>_ &lt;span style="color:#ae81ff">\/&lt;/span> _&lt;span style="color:#e6db74">`&lt;/span> | &lt;span style="color:#ae81ff">\ \ \ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> &lt;span style="color:#ae81ff">\\&lt;/span>/ ___&lt;span style="color:#f92672">)&lt;/span>| |_&lt;span style="color:#f92672">)&lt;/span>| | | | | &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">(&lt;/span>_| | &lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39; |____| .__|_| |_|_| |_\__, | / / / /
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> =========|_|==============|___/=/_/_/_/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> :: Spring Boot :: (v2.5.5)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:21.472 INFO 48844 --- [ main] com.example.demo.DemoApplicationKt : Starting DemoApplicationKt using Java 17 on Local.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:21.475 INFO 48844 --- [ main] com.example.demo.DemoApplicationKt : No active profile set, falling back to default profiles: default
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.058 INFO 48844 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.067 INFO 48844 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.068 INFO 48844 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.53]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.117 INFO 48844 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.118 INFO 48844 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 607 ms
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">2021-10-17 19:10:22.335 INFO 48844 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &amp;#39;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-17 19:10:22.342 INFO &lt;span style="color:#ae81ff">48844&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span> main&lt;span style="color:#f92672">]&lt;/span> com.example.demo.DemoApplicationKt : Started DemoApplicationKt in 1.129 seconds &lt;span style="color:#f92672">(&lt;/span>JVM running &lt;span style="color:#66d9ef">for&lt;/span> 1.396&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JVMの起動に1.396秒、アプリの起動に1.129秒がかかっていますね。何も依存関係がないので、おそらくこれが自分のマシンでは最速の起動時間と言えるのではないかと思います。これが実際の業務用のアプリとなると、アプリの起動だけで10秒以上かかることもあリますね。一回の起動では10秒でもあまり問題になることはありませんが、ローカルでのテストではテストごとにアプリが起動するような&lt;/p>
&lt;h4 id="quarkus-nativeの場合">Quarkus Nativeの場合
&lt;/h4>&lt;p>では、Quarkusの場合を見ていきたいと思います。まずNativeコンパイルができるというので、&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>を利用してビルドしてみました。実際のビルドはGradleのタスクとして実行できて（固有のパラメータは必要ですが）、簡単です。そしてそれを実行してみた結果が以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>__ ____ __ _____ ___ __ ____ ______
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --/ __ &lt;span style="color:#ae81ff">\/&lt;/span> / / / _ | / _ &lt;span style="color:#ae81ff">\/&lt;/span> //_/ / / / __/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -/ /_/ / /_/ / __ |/ , _/ ,&amp;lt; / /_/ /&lt;span style="color:#ae81ff">\ \ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&lt;span style="color:#ae81ff">\_&lt;/span>__&lt;span style="color:#ae81ff">\_\_&lt;/span>___/_/ |_/_/|_/_/|_|&lt;span style="color:#ae81ff">\_&lt;/span>___/___/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,395 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> quarkus-sample 1.0.0-SNAPSHOT native &lt;span style="color:#f92672">(&lt;/span>powered by Quarkus 2.3.0.Final&lt;span style="color:#f92672">)&lt;/span> started in 0.018s. Listening on: http://0.0.0.0:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,397 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> Profile prod activated.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,397 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> Installed features: &lt;span style="color:#f92672">[&lt;/span>cdi, config-yaml, kotlin, resteasy-reactive, resteasy-reactive-jackson, smallrye-context-propagation, vertx&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>0.018秒がかかっています。ビルドしたプロジェクトの構造が単純であるのもありますが、それでもこの起動速度は確かに速いですね。これなら確かにマイクロサービスだけでなく、リクエストの多いサーバレスアプリケーションでも十分使えると思います。&lt;/p>
&lt;h4 id="quarkus-jvmの場合">Quarkus JVMの場合
&lt;/h4>&lt;p>Springの場合と同じく、Oracle JDK 17を利用して起動してみました。Quarkusには開発モードというものがあり、サーバを起動したまま修正ができるのですが、ここではあえてJarを作って起動しています。余談ですが、Springでは依存関係を全部含む場合はwarになりますが、Quarkusではuber-jarと言っているのが面白いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>__ ____ __ _____ ___ __ ____ ______
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --/ __ &lt;span style="color:#ae81ff">\/&lt;/span> / / / _ | / _ &lt;span style="color:#ae81ff">\/&lt;/span> //_/ / / / __/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -/ /_/ / /_/ / __ |/ , _/ ,&amp;lt; / /_/ /&lt;span style="color:#ae81ff">\ \ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&lt;span style="color:#ae81ff">\_&lt;/span>__&lt;span style="color:#ae81ff">\_\_&lt;/span>___/_/ |_/_/|_/_/|_|&lt;span style="color:#ae81ff">\_&lt;/span>___/___/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,897 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> quarkus-sample 1.0.0-SNAPSHOT on JVM &lt;span style="color:#f92672">(&lt;/span>powered by Quarkus 2.3.0.Final&lt;span style="color:#f92672">)&lt;/span> started in 0.761s. Listening on: http://0.0.0.0:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,905 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> Profile prod activated.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,906 INFO &lt;span style="color:#f92672">[&lt;/span>io.quarkus&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>main&lt;span style="color:#f92672">)&lt;/span> Installed features: &lt;span style="color:#f92672">[&lt;/span>cdi, config-yaml, kotlin, resteasy-reactive, resteasy-reactive-jackson, smallrye-context-propagation, vertx&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回は0.761秒がかかりました。Nativeと比べると確かに数十倍も遅くなっていますが、それでもSpringと比べ速い方ですね。&lt;/p>
&lt;p>こうやってアプリの起動が速くなると、ローカルで開発するときもユニットテストが早くなるので即座で確認ができるというメリットもあるかと思います。特にSpringで[RestTemplate]や&lt;a class="link" href="https://spring.pleiades.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/reactive/server/WebTestClient.html" target="_blank" rel="noopener"
>WebTestClient&lt;/a>などを使ったテストケースを書くとテストごとにアプリを起動することになるので、テストケースが増えれば増えるほどかかる時間が多いのが辛いものですね。なので、起動が速いと同じようなテストをQuarkusで書いてもかなり時間が節約できそうです。&lt;/p>
&lt;h3 id="springからの移行が簡単">Springからの移行が簡単
&lt;/h3>&lt;p>最初あまり意識してなかった部分ですが、Quarkusの良い点の一つは、Springからの移行が簡単ということです。アプリを新規に開発するときや既存のアプリのフレームワークを変更する場合には、技術選定において色々と考慮すべきものや観点があると思いますが、その中でいくつかを取り上げると「いかに工数を減らせるか」、「エンジニアを募集しやすいか」などがあるのはないかと思います。こういう観点からすると、現在のエンジニアにとって全く新しい技術だったり、業界であまり使われてない技術だったりすると会社としてもエンジニアとしても大変でしょう。こういう問題があるので、企業にとって新しい技術の導入は難しくなっていると思います。&lt;/p>
&lt;p>なので、新しい技術でありながらも業界でよく使われているものと似ているという点は、エンジニアの学習コストを減らせるのでかなりのメリットと言えるでしょう。では、実際のコードを観ながら、SpringのコードをQuarkusに移行するとした場合はどうなるかを見ていきたいと思います。&lt;/p>
&lt;h4 id="springの場合">Springの場合
&lt;/h4>&lt;p>まず、クエリパラメータにIDを渡し、Personというレコードのデータを取得するAPIがあるとしましょう。Springなら、以下のようなコードになるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RestController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RequestMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonController&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GetMapping&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#a6e22e">PresonResponse&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonService&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> repository.findById(id).let { &lt;span style="color:#a6e22e">PersonDto&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="ktorの場合">Ktorの場合
&lt;/h4>&lt;p>Quarkusのコードを見る前に、まず同じコードをこのブログでも紹介したことのある&lt;a class="link" href="https://ktor.io/" target="_blank" rel="noopener"
>Ktor&lt;/a>で書くとどうなるかをまず見ていきたいと思います。これでSpringと全く違うフレームワークを選ぶという場合の比較ができるでしょう。&lt;/p>
&lt;p>Ktorもよいフレームワークではありますが、フレームワークそのものの設計思想はSpringと異なるので、既存のアプリを移行するとしたら色々と考慮すべきものが多いです。例えば、基本的にDIに対応していないのでライブラリを別途導入する必要がありますね。&lt;/p>
&lt;p>以下は、上記のSpringと同じAPIを、DIライブラリとして&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>を導入して実装したKtorの例です。かなり違う構造になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// DIの設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> personModule = module {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single { PersonService(&lt;span style="color:#66d9ef">get&lt;/span>()) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single { PersonRepository() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Koinをアプリにインストール
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> install(Koin) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modules(personModule)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ルーティングをモジュール化して設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> configureRouting()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ルータにControllerを登録
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.configureRouting() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> personController()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Route&lt;/span>.personController() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Serviceのインジェクション
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PersonService &lt;span style="color:#66d9ef">by&lt;/span> inject()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/person&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#a6e22e">PresonResponse&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Service
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonService&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> repository.findById(id).let { &lt;span style="color:#a6e22e">PersonDto&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="quarkusの場合">Quarkusの場合
&lt;/h4>&lt;p>では、続いてQuarkusでAPIを作成した場合のコードを見ていきましょう。QuarkusでAPIを作成する方法は&lt;a class="link" href="https://resteasy.github.io" target="_blank" rel="noopener"
>RESTEasy&lt;/a>と&lt;a class="link" href="https://quarkus.io/guides/reactive-routes" target="_blank" rel="noopener"
>Reactive Routes&lt;/a>の二つのパターンがありますが、どちらを使った場合でもアプリの作成そのものに大きい違いはないので、ここではRESTEasyを使った実装を紹介したいと思います。まずは以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Path&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonController&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GET&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#a6e22e">PresonResponse&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ApplicationScoped&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonService&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> repository.findById(id).let { &lt;span style="color:#a6e22e">PersonDto&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Springのコードど比較して、使っているアノテーションの種類が違うだけで、ほぼ同じ感覚で実装ができるのがわかります。なので、Ktorの場合のようにアーキテクチャを考え直す必要もなく、移行も簡単になるわけですね。また、RESTEasyを使う場合、ReactiveのAPIを作りやすいというメリットもあります。Reactiveだと&lt;a class="link" href="https://smallrye.io/smallrye-mutiny/" target="_blank" rel="noopener"
>Mutiny&lt;/a>を使うことになりますが、Uni/Multiの概念がMono/Fluxと1:1対応していると思って良いので、Spring WebFluxや他のReactive Streamを触ったことのある方ならすぐに適応できそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Path&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonController&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GET&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(id: Int): Uni&amp;lt;PersonResponse&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">Uni&lt;/span>.createFrom().item(service.getPerson(id).let { &lt;span style="color:#a6e22e">PresonResponse&lt;/span>.from(&lt;span style="color:#66d9ef">it&lt;/span>) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KtorやSpring WebFluxのRouter Functionのような書き方もそれなりの良い点はあるかと思いますが、やはりSpring MVCのような書き方に慣れている人も多いだろうし、そのような書き方で特に問題になることもないので、新しいフレームワークだとしてもこのように既存のものと同じような感覚でコードを書けるというのもそのフレームワークを選択しやすくする一つのセールズポイントになるのではないかと思います。例えば&lt;a class="link" href="https://nestjs.com/" target="_blank" rel="noopener"
>NestJS&lt;/a>のように、JavaScript用のフレームワークでもSpring MVCに似たようなコードを書けるのですが、おそらくこれもまたSpringを触った経験のあるエンジニアにアピールするためでしょう。&lt;/p>
&lt;p>こういう面からすると、すでにSpringの経験があるエンジニアならすぐにQuarkusに移行できて、既存のSpringプロジェクトも簡単に移行できそうなので良さそうです。&lt;/p>
&lt;h2 id="懸念">懸念
&lt;/h2>&lt;p>Quarkusを実際触ってみて、最も良いと思われたのは上記の通りですが、Nativeでアプリをビルドしながら、いくつかの懸念もあると感じました。例えば以下のようなものがあります。&lt;/p>
&lt;h3 id="nativeのビルドは遅い">Nativeのビルドは遅い
&lt;/h3>&lt;p>Nativeで起動速度が早くなるのは確かに良いところですが、問題はビルド自体は遅いということです。当然ながら、Nativeとしてビルドするということは、最初から全てのコードをマシンコードとしてコンパイルするということを意味します。JVM用のバイトコードはどの環境でも同じですが、マシンコードはそうではないので、そのプラットフォームに合わせたコードを生成するのに時間がかかるのは当然のことですね。例えば、ローカルでテストに使ったプロジェクトをNativeイメージとしてビルドした場合は以下のような時間がかかりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./gradlew build -Dquarkus.package.type&lt;span style="color:#f92672">=&lt;/span>native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; Task :quarkusBuild
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>building quarkus jar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> classlist: 2,311.58 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>cap&lt;span style="color:#f92672">)&lt;/span>: 3,597.91 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> setup: 5,450.32 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>19:22:21,827 INFO &lt;span style="color:#f92672">[&lt;/span>org.jbo.threads&lt;span style="color:#f92672">]&lt;/span> JBoss Threads version 3.4.2.Final
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>clinit&lt;span style="color:#f92672">)&lt;/span>: 779.71 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>typeflow&lt;span style="color:#f92672">)&lt;/span>: 14,308.32 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>objects&lt;span style="color:#f92672">)&lt;/span>: 16,140.38 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>features&lt;span style="color:#f92672">)&lt;/span>: 1,145.40 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> analysis: 33,857.15 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> universe: 1,718.32 ms, 5.14 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>parse&lt;span style="color:#f92672">)&lt;/span>: 2,635.36 ms, 5.14 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>inline&lt;span style="color:#f92672">)&lt;/span>: 7,363.76 ms, 5.99 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>compile&lt;span style="color:#f92672">)&lt;/span>: 26,314.40 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> compile: 40,954.87 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> image: 10,493.47 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> write: 2,111.59 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">[&lt;/span>total&lt;span style="color:#f92672">]&lt;/span>: 97,207.01 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BUILD SUCCESSFUL in 1m 43s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CIでビルドを行っていたり、頻繁にアプリの修正とデプロイが必要な場合にこれでかなりボトルネックになる可能性もあるかと思います。マシンパワーが十分か、デプロイまでの時間があまり気にならない場合は問題にならないと思いますが、起動速度が大事であるなら、その分ビルドに時間がかかると結局は同等のトレードオフになるだけですね。こういう場合はJarとしてビルドする時間や、他のフレームワークを使ってビルド〜起動までにかかる時間を測定してから判断した方が良いかなと思います。&lt;/p>
&lt;h3 id="ピークパフォーマンス">ピークパフォーマンス
&lt;/h3>&lt;p>一般的にCやC++のような言語と比べ、Java(JVM言語)は性能で劣るという話は常識のように受け入れられています。しかし、全ての状況においてそういうわけでもありません。適切なアルゴリズム、アプリケーションのデザインなど言語そのものとは無関係と言えることが理由な場合もありますが、言語の特性を考えてもそういうケースがあるということです。なぜなら、CやC++のようなネイティブコードを生成する言語と、JVM言語のコンパイラの特性が違うからです。&lt;/p>
&lt;p>仮想マシンを挟み、バイトコードをマシンコードにもう一度変換する必要があるJVM言語と比べ、最初からマシンコードを生成する言語の方が性能が優秀であることは当然です。実際それは数値としても表れていて、Javaが登場した当時には性能問題で色々と批判を受けていたらしいですね。今はJavaが比較的性能が大事であるサーバサイドアプリケーションを作成する場合によく採用されていますが、これも「ハードウェアの発展がある」からと言われるケースも多いです。&lt;/p>
&lt;p>ただ、全ての場合においてJVMを挟むアプリケーションがNativeより遅いわけでもありません。なぜなら、コンパイルには「最初から全てコンパイルしておく」&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E4%BA%8B%E5%89%8D%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9" target="_blank" rel="noopener"
>AOT&lt;/a>だけでなく、「必要に応じてコンパイルする」&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%AE%9F%E8%A1%8C%E6%99%82%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9" target="_blank" rel="noopener"
>JIT&lt;/a>の方式もあるからです。&lt;/p>
&lt;p>JVMではJITによりバイトコードの分析と最適化を行い、マシンコードを生成することでより良い性能のコーどを作り出すと言われています。ここで最適化とは、利用頻度の高いメソッドや定数などを含めてオーバヘッドを減らすことを含みます。このような最適化が行われたコードをマシンコードに変換するとしたら、当然性能がより良くなることを期待できますね。ただ、ITは全ての場合に動作してくれるわけでもありません。コンパイルには時間とマシンパワーが必要なので、一度しか利用されないコードをいちいちマシンコードに変換するのは無駄なことですね。なので、JITでコンパイルされるコードは、そのコードの利用頻度により決定されます。よくJavaのマイクロベンチマークで使われている&lt;a class="link" href="https://github.com/openjdk/jmh" target="_blank" rel="noopener"
>JMH&lt;/a>でテストを行うとき、事前にウォーミングアップをおこなっているのも、JITによる最適化でベンチマークの精度を上げるための工夫です。&lt;/p>
&lt;h4 id="検証してみると">検証してみると
&lt;/h4>&lt;p>実際NativeかJVMかによってどれくらいランタイム性能が違うのか気になったので、ループで10万件のデータを作って返すだけのServiceを作成して処理時間を計測してみました。ここでControllerの戻り値に&lt;a class="link" href="https://smallrye.io/smallrye-mutiny/getting-started/creating-multis" target="_blank" rel="noopener"
>Multi&lt;/a>を使ったせいか、APIが呼び出されるたびにレスポンスまでの時間が大きく変化していたので、測定しているのはリクエストからレスポンスまでの時間より「forループによるデータの生成にかかった時間」を計測していると理解してください。&lt;/p>
&lt;p>NativeビルドとJarの実行に使ったのはどれもGraalVM CE 21.3.0(OpenJDK 11)で、処理時間の測定はKotlinの&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.system/measure-time-millis.html" target="_blank" rel="noopener"
>measureTimeMillis&lt;/a>で取得した値をログに吐くという方法を使っています。&lt;/p>
&lt;p>まずNativeで起動した場合の結果です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:14,061 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-6&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">89&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:15,630 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-1&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">52&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:17,079 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-15&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">106&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:18,174 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-5&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">49&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:19,523 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-11&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">50&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:20,468 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-4&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">50&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:21,739 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-7&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">124&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:23,113 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-12&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">53&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:24,073 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-13&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">49&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:25,308 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-2&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">53&lt;/span> ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、以下がJVMで起動した場合の結果です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:32,240 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-8&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">163&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:35,057 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-6&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">33&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:39,418 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-11&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">40&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:42,211 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-3&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">25&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:44,149 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-10&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">38&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:46,283 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-2&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">24&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:48,262 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-20&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">22&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:49,854 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-12&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">26&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:51,552 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-23&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">23&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:52,967 INFO &lt;span style="color:#f92672">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>vert.x-eventloop-thread-7&lt;span style="color:#f92672">)&lt;/span> measured time was &lt;span style="color:#ae81ff">51&lt;/span> ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>やはりJITが関与しているせいか、JVMでは最初の実行で時間がかかっていて、その次から大幅に処理速度が早くなっているのがわかります。GraalVMのコンパイラのバージョンアップでさらにパフォーマンスが向上する可能性はあると思われますが、それはJVMの場合でも同じなので、どうしてもランタイムのピークパフォーマンスが大事な場合はJVMの利用を考慮しても良いかなと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>本当はメモリ使用量などをより正確に測る必要があると思いますが、それに関してはすでに&lt;a class="link" href="https://medium.com/swlh/springboot-vs-quarkus-a-real-life-experiment-be70c021634e" target="_blank" rel="noopener"
>記事があったので&lt;/a>、ここでは割愛します。結論から言いますと、確かにメモリ使用量はヒープを含めQuarkusの方が少ないですが、CPU使用量の最大値とLatencyにおいてはSpring Bootの方が優れているのを確認しました。ただ、ここはQuarkusの方が歴史が短いためであるということもありそうですね。&lt;/p>
&lt;p>とりあえず触ってみた感覚では、確かにKubernetes nativeと言えるだけのものではあると思われます。Nativeビルドしてみると、Jarと比べアプリのサイズ自体は大きくなるものの（倍ほど）、JDKがいらなくなるというのも良いですね。JDKのサイズはAdoptOpenJDKを基準におよそ300MBくらいです。インスタンスが一つの場合だとしたらあまり問題になりそうではないですが、もしインスタンスが増えるとしたらJDKだけでも必要なストレージのサイズが乗数で増えることになるので、Nativeにしたくもなるかなと思います。&lt;/p>
&lt;p>そのほかにも、さまざまなライブラリやフレームワークの組み合わせができるし、Spring Securityなどをそのまま用いることができるのも魅力的です。Springの経験のあるエンジニアなら誰でもすぐに慣れそうなので、会社の立場からも他のフレームワークを使う場合に比べ比較的エンジニアの募集に負担がなくなるのでは、と思ったりもします。&lt;/p>
&lt;p>Spring WebFluxやKtorもよかったのですが、また新しい強者が現れてどれを使うか悩ましい時代になりましたね。本当は&lt;a class="link" href="https://rocket.rs/" target="_blank" rel="noopener"
>Rocket&lt;/a>も触ってみたいんですが、果たして今年内にできるかどうか…&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Java 17は何が変わったか</title><link>https://retheviper.github.io/posts/java-enter-to-17/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-enter-to-17/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Java 17は何が変わったか" />&lt;p>今月は新しいLTSバージョンであるJava 17のリリースがありました。まだJava 1.8を使っている案件も多いかなと思いますが、Java 1.8は2022年まで、Java 11は2023年までのサポートとなるので、いずれにせよJava 17に移行する必要はあるかなと思います。特にJava 9からモジュールが導入されたため、8からの移行はかなり大変だったらしいですが、11から移行する場合はそれほどでもないと言われているので、今からでも17では何が変わっているか、目を通しておくのもそう悪くはないでしょう。&lt;/p>
&lt;p>現時点では&lt;a class="link" href="https://adoptium.net" target="_blank" rel="noopener"
>Eclipse Temurin&lt;/a>(旧AdoptOpenJDK)、&lt;a class="link" href="https://www.azul.com/downloads/" target="_blank" rel="noopener"
>Zulu&lt;/a>などの有名JDKはほとんどが17のリリースを完了しているか、対応の最中にありますね。また、&lt;a class="link" href="https://www.itmedia.co.jp/news/articles/2109/15/news147.html" target="_blank" rel="noopener"
>Oracle JDK 17は無料に&lt;/a>なったので、こちらを選ぶもの悪くない選択肢の一つかもしれません。&lt;/p>
&lt;p>また、こういう無料化やJDKの多様化のみでなく、GoogleとOracleの訴訟の件もGoogleの勝利で終わったので、AndroidでもJava 17を使える可能性ができた以上、これからJava 17を使える場面は増えてくるかもしれません。実際、まだ遠い話ではあります、Springを使う場合、2022年の&lt;a class="link" href="https://spring.io/blog/2021/09/02/a-java-17-and-jakarta-ee-9-baseline-for-spring-framework-6" target="_blank" rel="noopener"
>Spring 6はJava 17がベースラインとなる&lt;/a>らしいですね。なので、Java 11は採択されてなかった現場でも、サポート期間などを考慮して17に転換する可能性はあると思います。&lt;/p>
&lt;p>というわけで、今回はそんなJava 17では何が変わったかを述べていきますが、大きく分けて新しい予約語の追加、新しい書き方など言語スペックとして変わったものと、新しく追加されたAPIという二つの観点でその変化を辿っていきたいと思います。案件によってはJava 1.8から17に移行するケースもあるかと思いますが、9〜11までの間にあった変更事項や新しいAPIなどはこのブログでも扱っていて、他でも参考にできるサイトが多いと思いますので、今回は8~11までの変化については割愛し、11〜17の間の変化だけを扱うことにさせてください。&lt;/p>
&lt;h2 id="言語スペック">言語スペック
&lt;/h2>&lt;h3 id="new-macos-rendering-pipeline-17">New macOS Rendering Pipeline (17)
&lt;/h3>&lt;p>macOSでは長い間、SwingなどJavaの2Dレンダリングに&lt;a class="link" href="https://www.opengl.org/" target="_blank" rel="noopener"
>OpenGL&lt;/a>を使っていましたが、新しい&lt;a class="link" href="https://developer.apple.com/metal/" target="_blank" rel="noopener"
>Metal framework&lt;/a>を導入しながら、10.14からOpenGLは&lt;code>deprecated&lt;/code>となりました。&lt;/p>
&lt;p>従ってJava側でも、Metalを利用する新しいグラフィック・レンダリング・パイプラインを実装するという&lt;a class="link" href="https://openjdk.java.net/projects/lanai/" target="_blank" rel="noopener"
>Project Lanai&lt;/a>が進められていましたが、17から&lt;a class="link" href="https://openjdk.java.net/jeps/382" target="_blank" rel="noopener"
>New macOS Rendering Pipeline&lt;/a>という名で導入されました。JavaであまりGUIを使うことないのでは？と思いがちかと思いますが、intellijのようなJavaベースのIDEでも画面描画で性能向上があるという噂です。ただ、intellijでは基本的に&lt;a class="link" href="https://confluence.jetbrains.com/display/JBR/JetBrains&amp;#43;Runtime" target="_blank" rel="noopener"
>Jetbrains Runtime&lt;/a>を使っていて、現時点ではそれがJava 17に対応していないので少し待つ必要はあります。&lt;/p>
&lt;h3 id="macosaarch64-port-17">macOS/AArch64 Port (17)
&lt;/h3>&lt;p>17からはM1など、&lt;a class="link" href="https://openjdk.java.net/jeps/391" target="_blank" rel="noopener"
>Apple Siliconを搭載した新しいMacに対応&lt;/a>しました。&lt;a class="link" href="https://www.azul.com/downloads/" target="_blank" rel="noopener"
>Zulu&lt;/a>などの他のJDKでは独自に対応してるケースもありましたが、OpenJDK(OracleJDK)で対応したことで、これをベースとする&lt;a class="link" href="https://adoptium.net/" target="_blank" rel="noopener"
>Eclipse Temurin&lt;/a>や&lt;a class="link" href="https://www.microsoft.com/openjdk" target="_blank" rel="noopener"
>Microsoft Build of OpenJDK&lt;/a>のような他のJDKでも自然にARMベースMacでネイティブとして使えるということになると思います。&lt;/p>
&lt;h3 id="record-17">Record (17)
&lt;/h3>&lt;p>14からPreviewとして導入された&lt;code>Record&lt;/code>が、17ではstableになり正式に導入されました。指定したフィールドを&lt;code>private final&lt;/code>にして、コンストラクタ、&lt;code>getter&lt;/code>、&lt;code>toString&lt;/code>、&lt;code>hashcode&lt;/code>、&lt;code>equals&lt;/code>などを自動生成してくれるものです。最初は&lt;code>Lombok&lt;/code>の&lt;a class="link" href="https://projectlombok.org/features/Data" target="_blank" rel="noopener"
>@Data&lt;/a>のようなものかと思いきや、実際は&lt;a class="link" href="https://projectlombok.org/features/Value" target="_blank" rel="noopener"
>@Value&lt;/a>に近いものになっていますね。値はコンストラクタでしか渡せなくて、後から変更はできなくなります。こういうところは、フィールドを&lt;code>val&lt;/code>として指定したKotlinの&lt;code>data class&lt;/code>に近い感覚でもあります。なので、実際の使用例を見ると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Recordの定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">MyRecord&lt;/span>(String name, &lt;span style="color:#66d9ef">int&lt;/span> number) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスの作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MyRecord myRecord &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MyRecord(&lt;span style="color:#e6db74">&amp;#34;my record&amp;#34;&lt;/span>, 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// フィールドの取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String myRecordsName &lt;span style="color:#f92672">=&lt;/span> myRecord.&lt;span style="color:#a6e22e">name&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> myRecordsNumber &lt;span style="color:#f92672">=&lt;/span> myRecord.&lt;span style="color:#a6e22e">number&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>Named Arguments&lt;/a>に対応しているのですが、Javaではまだそのような機能がないので、&lt;code>Record&lt;/code>だとフィールドが多くなるとどれがどれだかわからなくなりそうな気はします。これに対してKotlin側で&lt;code>Record&lt;/code>を使う場合、何らかのラッパークラスを作って対応するなどの方法は考えられますね。もしくは普通に&lt;code>setter&lt;/code>をもつDTOを定義するか、builderパターンを利用する方が良いでしょう。&lt;/p>
&lt;p>また、&lt;code>Record&lt;/code>では&lt;code>getter&lt;/code>名もフィールド名そのままになるという特徴もありますが、自動生成されるコンストラクタをカスタマイズするときも少し書き方が違うという特徴があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">MyRecord&lt;/span>(String name, &lt;span style="color:#66d9ef">int&lt;/span> number) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// コンストラクタにバリデーションをつける例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> MyRecord {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (name.&lt;span style="color:#a6e22e">isBlank&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、&lt;code>Record&lt;/code>として定義しても実際は&lt;code>Class&lt;/code>が作られることになるので、以下のようなこともできます。&lt;/p>
&lt;ul>
&lt;li>コンストラクタを追加する&lt;/li>
&lt;li>&lt;code>getter&lt;/code>をオーバライドする&lt;/li>
&lt;li>インナークラスとして&lt;code>Record&lt;/code>を定義する&lt;/li>
&lt;li>インターフェイスを実装する&lt;/li>
&lt;/ul>
&lt;p>また、&lt;code>Reflection&lt;/code>でもクラスが&lt;code>Record&lt;/code>であるかどうかを判定する&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Class.html#isRecord%28%29" target="_blank" rel="noopener"
>isRecord&lt;/a>も追加されています。&lt;/p>
&lt;h3 id="text-blocks-15">Text Blocks (15)
&lt;/h3>&lt;p>Javaでは長い間、HTMLやJSON、SQLなどをリテラルとして使うためにはエスケープや文字列の結合などを使う必要がありました。これはあまり可読性という面でよくなく、コードの修正も難しくなる問題がありましたね。例えば、HTMLを表現するとしたら以下のようなことをしていたかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String html &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;lt;html&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34; &amp;lt;body&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34; &amp;lt;h1&amp;gt;This is Java&amp;#39;s new Text block!&amp;lt;/h1&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34; &amp;lt;/body&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;lt;/html&amp;gt;\n&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SELECT \&amp;#34;EMP_ID\&amp;#34;, \&amp;#34;LAST_NAME\&amp;#34; FROM \&amp;#34;EMPLOYEE_TB\&amp;#34;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;WHERE \&amp;#34;CITY\&amp;#34; = &amp;#39;INDIANAPOLIS&amp;#39;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ORDER BY \&amp;#34;EMP_ID\&amp;#34;, \&amp;#34;LAST_NAME\&amp;#34;;\n&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>幸い、15から&lt;a class="link" href="https://openjdk.java.net/jeps/378" target="_blank" rel="noopener"
>Text Blocks&lt;/a>が導入され、他の言語のように簡単かつ可読性の高い文字列を定義することができるようになりました。これを使うとエスケープを意識しなくて良いので、複数行でなくても色々な分野で有効活用できそうですね。&lt;code>Text Blocks&lt;/code>を使って上記のコードを変えると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String html &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;html&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;body&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;h1&amp;gt;This is Java&amp;#39;s new Text block!&amp;lt;/h1&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;/body&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;/html&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> SELECT &amp;#34;EMP_ID&amp;#34;, &amp;#34;LAST_NAME&amp;#34; FROM &amp;#34;EMPLOYEE_TB&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> WHERE &amp;#34;CITY&amp;#34; = &amp;#39;INDIANAPOLIS&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ORDER BY &amp;#34;EMP_ID&amp;#34;, &amp;#34;LAST_NAME&amp;#34;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは全く同じ書き方で同じことができるので、ここでは割愛します。&lt;/p>
&lt;h3 id="sealed-class-17">Sealed Class (17)
&lt;/h3>&lt;p>JDK 15からPreviewで導入された&lt;a class="link" href="https://openjdk.java.net/jeps/409" target="_blank" rel="noopener"
>sealed classes&lt;/a>が、Stableとなりました。&lt;code>class&lt;/code>や&lt;code>interface&lt;/code>を&lt;code>sealed&lt;/code>にすれば、それを拡張・実装できるクラスやインターフェイスを限定できるようになります。こうすることで、ライブラリなどで勝手に拡張して欲しくないクラスやインターフェイスを守ることができますね。また、将来的には&lt;code>sealed&lt;/code>として定義されてあるクラスの子クラスを&lt;code>switch&lt;/code>の&lt;code>case&lt;/code>に指定するときは全部のケースが指定されているかどうかをコンパイラがチェックするようにするとかの話もあるようです。以下は、&lt;code>sealed&lt;/code>クラスが&lt;code>permits&lt;/code>キーワードを使って継承できるクラスを指定する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Shape&lt;/span> permits Circle, Rectangle, Square, WeirdShape { }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでも&lt;a class="link" href="https://kotlinlang.org/docs/sealed-classes.html" target="_blank" rel="noopener"
>Sealed Classes&lt;/a>は存在していますが、&lt;code>interface&lt;/code>を&lt;code>sealed&lt;/code>にするためには1.5以降を使う必要があって、拡張・実装できるクラスやインターフェイスを指定するわけではなく、コンパイルされたモジュール以外で&lt;code>sealed&lt;/code>として定義されているクラスやインターフェイスを拡張・実装できない仕様となっています。なので書き方的には、以下のようになります。より簡単ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">IOError&lt;/span>(): Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FileReadError&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> f: File): IOError()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DatabaseError&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> source: DataSource): IOError()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">RuntimeError&lt;/span> : Error
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、Javaの場合は&lt;code>Record&lt;/code>と同じく、このクラスが&lt;code>sealed&lt;/code>であるかどうかを判定する&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Class.html#isSealed%28%29" target="_blank" rel="noopener"
>isSealed&lt;/a>が追加されています。&lt;/p>
&lt;h3 id="switch-expressions-14">Switch Expressions (14)
&lt;/h3>&lt;p>Java 12からPreviewで&lt;a class="link" href="https://openjdk.java.net/jeps/361" target="_blank" rel="noopener"
>Switch Expressions&lt;/a>が導入され、14からはStableになっています。従来の&lt;code>switch&lt;/code>を改善したもので、以下のようなことができるようになりました。&lt;/p>
&lt;ul>
&lt;li>&lt;code>case&lt;/code>をまとめて指定できる&lt;/li>
&lt;li>&lt;code>case&lt;/code>の処理をラムダのような書き方で記述できる&lt;/li>
&lt;li>&lt;code>case&lt;/code>の処理を戻り値にして、&lt;code>switch&lt;/code>を式として使える&lt;/li>
&lt;/ul>
&lt;p>例えば、&lt;code>day&lt;/code>というenumの値を見て、int値を返すメソッドを実装するとしましょう。従来の方法では以下のようになるはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> numLetters;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">switch&lt;/span> (day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> MONDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> FRIDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> SUNDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#f92672">=&lt;/span> 6;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> TUESDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#f92672">=&lt;/span> 7;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> THURSDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> SATURDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#f92672">=&lt;/span> 8;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> WEDNESDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#f92672">=&lt;/span> 9;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;Wat: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> day);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の処理は新しい&lt;code>switch&lt;/code>では以下のように書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> numLetters &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> MONDAY, FRIDAY, SUNDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 6;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> TUESDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 7;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> THURSDAY, SATURDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 8;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> WEDNESDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 9;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinだと以下のようになるはずですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> numLetters = &lt;span style="color:#66d9ef">when&lt;/span> (day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Day&lt;/span>.MONDAY, &lt;span style="color:#a6e22e">Day&lt;/span>.FRIDAY, &lt;span style="color:#a6e22e">Day&lt;/span>.SUNDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Day&lt;/span>.TUESDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Day&lt;/span>.THURSDAY, &lt;span style="color:#a6e22e">Day&lt;/span>.SATURDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Day&lt;/span>.WEDNESDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>when&lt;/code>だとargumentなしでも使えて分岐を条件文によるものにすることもできるなどの特徴もあるので、使い勝手はJavaの&lt;code>switch&lt;/code>よりいいかなと思います。ただ、Javaでもバージョンアップと共に後述する機能も追加されてあるので、今後Kotlinのように色々と改良が行われる可能性はあるかと思いますね。&lt;/p>
&lt;h3 id="pattern-matching-for-instanceof-16--switch-17">Pattern Matching for instanceof (16) / switch (17)
&lt;/h3>&lt;p>Java 14からは、&lt;a class="link" href="https://openjdk.java.net/jeps/394" target="_blank" rel="noopener"
>Pattern Matching for instanceof&lt;/a>が導入され、16ではStableになりましt。今までは&lt;code>instanceof&lt;/code>を使ってオブジェクトのインスタンスの種類を判定した後、そのインスタンスの種類にあった処理を行うには以下のようにキャストが必要でしたね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">formatter&lt;/span>(Object o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String formatted &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;unknown&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;int %d&amp;#34;&lt;/span>, (Integer) i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一度どれのインスタンスかわかった上でさらにキャストをする必要はあるのはだるいし、ミスをしたら例外の原因にもなり得る問題がありますね。なので、&lt;code>Pattern Matching&lt;/code>を利用して、キャストをなくすことができるようになりました。&lt;code>instanceof&lt;/code>を使った条件文の中に、キャストする変数名を指定しておくと、&lt;code>if&lt;/code>分の中でそのまま自動にキャストされた変数を使えるようになります。なので、以下のようなことができるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">formatter&lt;/span>(Object o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String formatted &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;unknown&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;int %d&amp;#34;&lt;/span>, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> Long l) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;long %d&amp;#34;&lt;/span>, l);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> Double d) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;double %f&amp;#34;&lt;/span>, d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;String %s&amp;#34;&lt;/span>, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> formatted;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに、17からはPreviewとして&lt;a class="link" href="https://openjdk.java.net/jeps/406" target="_blank" rel="noopener"
>Pattern Matching for switch&lt;/a>が導入されています。これを使うと、&lt;code>instanceof&lt;/code>なしで、&lt;code>switch&lt;/code>文を使ったよりシンプルな処理を書けるようになります。これを先に紹介した&lt;code>Switch Expressions&lt;/code>と組み合わせることで、上記の処理は以下に変えることが可能になります。かなりシンプルになったのがわかりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">formatterPatternSwitch&lt;/span>(Object o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Integer i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;int %d&amp;#34;&lt;/span>, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Long l &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;long %d&amp;#34;&lt;/span>, l);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Double d &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;double %f&amp;#34;&lt;/span>, d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> String s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;String %s&amp;#34;&lt;/span>, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> o.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="packaging-tool-16">Packaging Tool (16)
&lt;/h3>&lt;p>実行できるバイナリを生成する&lt;a class="link" href="https://openjdk.java.net/jeps/392" target="_blank" rel="noopener"
>Packaging Tool&lt;/a>が導入されています。これを使うと、Java runtimeとライブラリ、それぞれのOSにあった実行ファイルが一つのパッケージになる機能です。Java runtimeが含まれるということはOSのJavaのバージョンに関係なく実行できるものになるという意味なので、Javaのバージョンを固定したり、複数のアプリでそれぞれ違うバージョンのJavaを使って起動したい場合は役立つ機能かもしれません。&lt;/p>
&lt;h2 id="api">API
&lt;/h2>&lt;p>Java 17からは、APIドキュメントから、新しく追加されたAPIの一覧だけを見られるタブができたということです。今回は11以降に追加されたもののみですが、今後新しいLTSバージョンがリリースすると、17以降のものをこちらから確認できそうですね。新しいAPIの一覧は&lt;a class="link" href="https://download.java.net/java/early_access/jdk17/docs/api/new-list.html" target="_blank" rel="noopener"
>こちら&lt;/a>から確認できます。&lt;/p>
&lt;p>ここで全てのAPIの詳細まで探るのは難しいと思いますので、個人的に興味深いと思ったのを一部紹介したいと思います。&lt;/p>
&lt;h3 id="serial-14">@Serial (14)
&lt;/h3>&lt;p>&lt;code>java.io&lt;/code>パッケージに、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serial.html" target="_blank" rel="noopener"
>Serial&lt;/a>というアノテーションが追加されました。これは&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html" target="_blank" rel="noopener"
>Serializable&lt;/a>を実装したクラスで、そのシリアライズのメカニズムを&lt;code>@Override&lt;/code>するような機能のようです。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SerializableClass&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Serializable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> ObjectStreamField&lt;span style="color:#f92672">[]&lt;/span> serialPersistentFields;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> serialVersionUID;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">writeObject&lt;/span>(ObjectOutputStream stream) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">readObject&lt;/span>(ObjectInputStream stream) &lt;span style="color:#66d9ef">throws&lt;/span> IOException, ClassNotFoundException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">readObjectNoData&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ObjectStreamException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object &lt;span style="color:#a6e22e">writeReplace&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ObjectStreamException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object &lt;span style="color:#a6e22e">readResolve&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ObjectStreamException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このアノテーションをつけることで、コンパイルタイムでエラーをキャッチできるのも特徴的です。例えば、このアノテーションを以下のようなクラスのメンバに使う場合はコンパイルエラーとなります。&lt;/p>
&lt;ul>
&lt;li>Serializableを実装してないクラス&lt;/li>
&lt;li>Enumのように、Serializeの効果がないクラス&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Externalizable.html" target="_blank" rel="noopener"
>Externalizable&lt;/a>を継承しているクラス&lt;/li>
&lt;/ul>
&lt;p>このようなアノテーションが追加されたことによって、JacksonやGsonなどのライブラリの実装にも何か影響があるかもしれません。&lt;/p>
&lt;h3 id="string">String
&lt;/h3>&lt;p>同じ文字列だとしても、Javaでは&lt;code>java.lang.String&lt;/code>、Kotlinでは&lt;code>kotlin.text.String&lt;/code>を使うことになるので、Kotlinを使う場合はあまりJavaのAPIを使うことはないかと思います（また、JavaでのString関連のAPIは、Kotlinだと&lt;code>deprecated&lt;/code>になるケースが多いです）。なので、ここでは新しいAPIと、Kotlinで同じような処理をするために使える方法を中心に紹介します。&lt;/p>
&lt;h4 id="formatted-15">formatted (15)
&lt;/h4>&lt;p>Javaでは&lt;code>String.format()&lt;/code>をで文字列をフォーマットとして使うことができました。多くの場合、文字列は&lt;code>+&lt;/code>を使うよりフォーマットを使った方が性能が良いと言われていて、よく使っていたものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;formatted string&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 15以前&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String formattedString &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;this is %s&amp;#34;&lt;/span>, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 15以降&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String newFormattedString &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is %s&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">formatted&lt;/span>(name);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Koltinだと&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/format.html" target="_blank" rel="noopener"
>String.format&lt;/a>と&lt;a class="link" href="https://kotlinlang.org/docs/basic-syntax.html#string-templates" target="_blank" rel="noopener"
>String Templates&lt;/a>が使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> name = &lt;span style="color:#e6db74">&amp;#34;formatted string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Format
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> formattedString = &lt;span style="color:#e6db74">&amp;#34;this is %s&amp;#34;&lt;/span>.format(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String Template
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> templateString = &lt;span style="color:#e6db74">&amp;#34;this is &lt;/span>&lt;span style="color:#e6db74">$name&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="indent-12">indent (12)
&lt;/h4>&lt;p>&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#indent%28int%29" target="_blank" rel="noopener"
>indent&lt;/a>では、対象の文字列に引数で指定した分のwhite spaceを入れます。引数が&lt;code>int&lt;/code>型なので、負数を渡すことでwhite spaceを減らすこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String nonIndent &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデントを追加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String indented10 &lt;span style="color:#f92672">=&lt;/span> nonIndent.&lt;span style="color:#a6e22e">indent&lt;/span>(10); &lt;span style="color:#75715e">// &amp;#34; A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデントを削除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String indented5 &lt;span style="color:#f92672">=&lt;/span> indented10.&lt;span style="color:#a6e22e">indent&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>5); &lt;span style="color:#75715e">// &amp;#34; A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合は、インデントを追加するための&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/prepend-indent.html" target="_blank" rel="noopener"
>prependIndent&lt;/a>や代替するするための&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/replace-indent.html" target="_blank" rel="noopener"
>replaceIndent&lt;/a>などがあり、渡すパラメータも文字列となるのでJavaのものとは少し使い方が違います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> nonIndent = &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデントを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> prepended = nonIndent.prependIndent(&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>) &lt;span style="color:#75715e">// &amp;#34; A&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデントを代替（なかった場合は追加）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> replaced = prepended.replaceIndent(&lt;span style="color:#e6db74">&amp;#34;|||||&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// &amp;#34;|||||A&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="stripindent-15">stripIndent (15)
&lt;/h4>&lt;p>&lt;code>Text Block&lt;/code>で複数行の文字列を扱う場合、ソースコード上の可読性の都合で任意のインデントを入れたら実際のデータとしては扱いづらい場合もあるはずです。ここでインデントを削除するためののものが&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#stripIndent%28%29" target="_blank" rel="noopener"
>stringIndent&lt;/a>です。&lt;/p>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html" target="_blank" rel="noopener"
>trimIndent&lt;/a>が同じ役割をしています。&lt;/p>
&lt;h4 id="transform-12">transform (12)
&lt;/h4>&lt;p>文字列に対して&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener"
>Function&lt;/a>を実行するという単純なAPIです。&lt;code>replace&lt;/code>では不可能な、条件による処理などが必要なときに使えそうです。実装を見ると極めて単純です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>R&lt;span style="color:#f92672">&amp;gt;&lt;/span> R &lt;span style="color:#a6e22e">transform&lt;/span>(Function&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> String, &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> R&lt;span style="color:#f92672">&amp;gt;&lt;/span> f) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> f.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは文字列でも&lt;code>map&lt;/code>・&lt;code>filter&lt;/code>・&lt;code>reduce&lt;/code>のような高階関数が使えるのでこれらを使うこともできますね。もしくは以下のような拡張関数を定義することで同じことができるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">R&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">String&lt;/span>.transform(f: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): R = f(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="translateescapes-15">translateEscapes (15)
&lt;/h4>&lt;p>エスケープになっている一部の文字をリテラルに変えてくれる機能です。こちらはコードを見た方が理解が早いかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this\\nis\\nmutli\\nline&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String escapeTranslated &lt;span style="color:#f92672">=&lt;/span> string.&lt;span style="color:#a6e22e">translateEscapes&lt;/span>() &lt;span style="color:#75715e">// &amp;#34;this\nis\nmutli\nline&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前は&lt;code>Matcher&lt;/code>と正規式を組み合わせるなど独自の処理を書くか、ライブラリに依存していたと思いますので、こういうのができると嬉しいですね。変換されるエスケープ文字は以下の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Escape&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Translation&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>\b&lt;/code>&lt;/td>
&lt;td>backspace&lt;/td>
&lt;td>U+0008&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\t&lt;/code>&lt;/td>
&lt;td>horizontal tab&lt;/td>
&lt;td>U+0009&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\n&lt;/code>&lt;/td>
&lt;td>line feed&lt;/td>
&lt;td>U+000A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\f&lt;/code>&lt;/td>
&lt;td>form feed&lt;/td>
&lt;td>U+000C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\r&lt;/code>&lt;/td>
&lt;td>carriage return&lt;/td>
&lt;td>U+000D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\s&lt;/code>&lt;/td>
&lt;td>space&lt;/td>
&lt;td>U+0020&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\&amp;quot;&lt;/code>&lt;/td>
&lt;td>double quote&lt;/td>
&lt;td>U+0022&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\'&lt;/code>&lt;/td>
&lt;td>single quote&lt;/td>
&lt;td>U+0027&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\\&lt;/code>&lt;/td>
&lt;td>backslash&lt;/td>
&lt;td>U+005C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\0 - \377&lt;/code>&lt;/td>
&lt;td>octal escape&lt;/td>
&lt;td>code point equivalents&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\&amp;lt;line-terminator&amp;gt;&lt;/code>&lt;/td>
&lt;td>continuation&lt;/td>
&lt;td>discard&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Kotlinでは似たようなAPIがないので、必要なら独自の処理を書いた方が良さそうです。（ライブラリは知らず…）&lt;/p>
&lt;h3 id="mapentrycopyof-17">Map.Entry.copyOf (17)
&lt;/h3>&lt;p>&lt;code>Map.Entry&lt;/code>のコピーを作成します。コピーしたエントリは元のMapとは何の関係もないデータとなります。以下のようなサンプルコードを&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.Entry.html" target="_blank" rel="noopener"
>公式ドキュメント&lt;/a>から提示していますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> entries &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">entrySet&lt;/span>().&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">map&lt;/span>(Map.&lt;span style="color:#a6e22e">Entry&lt;/span>::copyOf).&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに&lt;code>Map&lt;/code>そのもののコピーは、10から追加された&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html#copyOf%28java.util.Map%29" target="_blank" rel="noopener"
>copyOf&lt;/a>でできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> copiedMap &lt;span style="color:#f92672">=&lt;/span> Map.&lt;span style="color:#a6e22e">copyOf&lt;/span>(map);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinだと、&lt;code>Entry&lt;/code>のコピーは以下のようにできます。型は&lt;code>List&amp;lt;MutableMap.MutableEntry&amp;lt;K, V&amp;gt;&amp;gt;&lt;/code>となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Map.Entryを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> entriesJava = map.entries.map { &lt;span style="color:#a6e22e">Map&lt;/span>.&lt;span style="color:#a6e22e">Entry&lt;/span>.copyOf(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// KotlinのMap.Entryを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> entriesKotlin = map.entries.toSet()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、Kotlinでの&lt;code>Map&lt;/code>のコピー方法は以下のようにできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> copiedMap = map.toMap()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="stream">Stream
&lt;/h3>&lt;h4 id="mapmulti-16">mapMulti (16)
&lt;/h4>&lt;p>16からStreamに&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html#mapMulti%28java.util.function.BiConsumer%29" target="_blank" rel="noopener"
>mapMulti&lt;/a>というメソッドが追加されました。基本的には「Streamの要素に1:Nの変換を適用して結果をStreamを返す」という処理なので、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html#flatMap%28java.util.function.Function%29" target="_blank" rel="noopener"
>flatMap&lt;/a>に似ていますが、以下のケースでは&lt;code>flatMap&lt;/code>を使う場合より良いと言われています。&lt;/p>
&lt;ul>
&lt;li>要素を減らす場合&lt;/li>
&lt;li>要素をStreamに変換するのが難しい場合&lt;/li>
&lt;/ul>
&lt;p>まずはオブジェクトがネストされているCollectionに対して&lt;code>flatMap&lt;/code>を使う場合を考えてみましょう。要素を減らすケースでは、&lt;code>flatMap&lt;/code>でまず全ての要素を展開し、&lt;code>filter&lt;/code>を使って条件に合う要素だけを取る必要があります。ここで要素を展開するには、全ての要素を&lt;code>Stream&lt;/code>に変換しなければならないので、全ての要素のグループに対して&lt;code>Stream&lt;/code>のインスタンスを作ることになります。また、オブジェクトがネストしている場合は、その個別の要素に対してどうやって&lt;code>Stream&lt;/code>に変換するか、処理の中で定義する必要があります。&lt;/p>
&lt;p>問題は&lt;code>Stream&lt;/code>のインスタンスを毎回作るためオーバヘッドが発生することにもなるし、要素がさまざまな型のオブジェクトである場合は&lt;code>Stream&lt;/code>に変換する処理を書くのも大変ということです。例えば以下のようなListがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> numbers &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(List.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2L), 3, List.&lt;span style="color:#a6e22e">of&lt;/span>(4, 5L, 6), List.&lt;span style="color:#a6e22e">of&lt;/span>(7L), 8L);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このListから、&lt;code>Integer&lt;/code>のみを抽出して別のListにしたい場合はどうしたら良いでしょうか。まず&lt;code>flatMap&lt;/code>を使うとしたら、以下のような処理を書くことになるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> integers &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">flatMap&lt;/span>( &lt;span style="color:#75715e">// 要素をStreamに変換する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (it &lt;span style="color:#66d9ef">instanceof&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> l) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> StreamSupport.&lt;span style="color:#a6e22e">stream&lt;/span>(l.&lt;span style="color:#a6e22e">spliterator&lt;/span>(), &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(it &lt;span style="color:#f92672">-&amp;gt;&lt;/span> it &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer) &lt;span style="color:#75715e">// Integerのみを取る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(it &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (Integer) it) &lt;span style="color:#75715e">// ObjectからIntegerへキャスト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを&lt;code>mapMulti&lt;/code>を使って処理する場合は以下のようになります。よりシンプルになりましたね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MultiMapper&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">expandIterable&lt;/span>(Object e, Consumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (e &lt;span style="color:#66d9ef">instanceof&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i.&lt;span style="color:#a6e22e">forEach&lt;/span>(ie &lt;span style="color:#f92672">-&amp;gt;&lt;/span> expandIterable(ie, c));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (e &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.&lt;span style="color:#a6e22e">accept&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> integers &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">mapMulti&lt;/span>(MultiMapper::expandIterable).&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/new-list.html#:~:text=java.util.stream.Stream.mapMultiToInt%28BiConsumer%3C%3F%20super%20T%2C%20%3F%20super%20IntConsumer%3E%29" target="_blank" rel="noopener"
>mapMultiToInt&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/new-list.html#:~:text=java.util.stream.Stream.mapMultiToLong%28BiConsumer%3C%3F%20super%20T%2C%20%3F%20super%20LongConsumer%3E%29" target="_blank" rel="noopener"
>mapMultiToLong&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/new-list.html#:~:text=java.util.stream.Stream.mapMultiToDouble%28BiConsumer%3C%3F%20super%20T%2C%20%3F%20super%20DoubleConsumer%3E%29" target="_blank" rel="noopener"
>mapMultiToDouble&lt;/a>などのメソッドも追加されていますので、数字を扱う場合はこちらを使った方が便利でしょう。例えば、上記の&lt;code>mapMulti&lt;/code>を&lt;code>mapMultiToInt&lt;/code>で書く場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MultiMapper&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">expandIterable&lt;/span>(Object e, IntConsumer c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (e &lt;span style="color:#66d9ef">instanceof&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i.&lt;span style="color:#a6e22e">forEach&lt;/span>(ie &lt;span style="color:#f92672">-&amp;gt;&lt;/span> expandIterable(ie, c));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (e &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.&lt;span style="color:#a6e22e">accept&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> integers &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">mapMultiToInt&lt;/span>(MultiMapper::expandIterable).&lt;span style="color:#a6e22e">boxed&lt;/span>().&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mapMultiToInt&lt;/code>の戻り値は&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/IntStream.html" target="_blank" rel="noopener"
>IntStream&lt;/a>なので、&lt;code>Stream&amp;lt;Integer&amp;gt;&lt;/code>に変換するために&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/IntStream.html#boxed%28%29" target="_blank" rel="noopener"
>boxed&lt;/a>を呼び出し、&lt;code>Consumer&lt;/code>が&lt;code>IntConsumer&lt;/code>に変わり、&lt;code>mapMulti&lt;/code>の型指定が変わるなど少しの違いがあります。&lt;/p>
&lt;p>Kotlinではそもそも&lt;code>flatMap&lt;/code>を&lt;code>Stream&lt;/code>として扱わないので、そもそもの処理を違う観点から考える必要があります。幸い、KotlinのCollectionには色々なAPIがあるので、そこまで難しくはないです。例えば、オブジェクトのインスタンスを基準に要素を集約したい場合は以下のようなコードを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;B&amp;#39;&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>, setOf(&lt;span style="color:#e6db74">&amp;#34;D&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;E&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;F&amp;#34;&lt;/span>), listOf(&lt;span style="color:#e6db74">&amp;#39;G&amp;#39;&lt;/span>), &lt;span style="color:#e6db74">&amp;#39;H&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> result: List&amp;lt;String&amp;gt; = list.flatMap {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> Iterable&amp;lt;*&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.filterIsInstance&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listOf(&lt;span style="color:#66d9ef">it&lt;/span>).filterIsInstance&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// [A, C, D, F]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Javaでは&lt;code>List.of(1, 2L)&lt;/code>でListを作成した場合、1はint、2LはLongとして扱われますが、Kotlinでは&lt;code>listOf(1, 2L)&lt;/code>が&lt;code>List&amp;lt;Long&amp;gt;&lt;/code>となってしまうので、そもそもの型に注意する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2L&lt;/span>), &lt;span style="color:#ae81ff">3&lt;/span>, setOf(&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5L&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>), listOf(&lt;span style="color:#ae81ff">7L&lt;/span>), &lt;span style="color:#ae81ff">8L&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> result = list.flatMap {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> Iterable&amp;lt;*&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.filterIsInstance&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listOf(&lt;span style="color:#66d9ef">it&lt;/span>).filterIsInstance&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// [3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="tolist16">toList(16)
&lt;/h4>&lt;p>Streamの終端処理として使用頻度の高い「Listに集計する」をシンタックス・シュガーとして作ったような感覚のメソッドです。ここはKotlinの機能をJavaが受け入れたような気もしますね。処理の結果として生成されるListは&lt;code>Unmodifiable&lt;/code>です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;D&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 旧&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> upper &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">map&lt;/span>(String::toUpperCase).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toUnmodifiableList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> lower &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">map&lt;/span>(String::toLowerCase).&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは基本的にCollectionで高階関数を呼び出した結果が&lt;code>Unmodifiable&lt;/code>なListになるのですが、&lt;code>stream&lt;/code>に変換して使うこともできるので、場合によっては便利なのかもしれませんね。&lt;/p>
&lt;h3 id="collectorsteeing-12">Collectors.teeing (12)
&lt;/h3>&lt;p>Collectorsに、二つの&lt;code>Collector&lt;/code>を結合する&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html#teeing%28java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction%29" target="_blank" rel="noopener"
>teeing&lt;/a>というメソッドが追加されました。ちなみに&lt;code>Tee&lt;/code>は二つの水道管を接続して一つにしてくれる「T字継手」の意味を持つらしいです。引数に二つの&lt;code>Collector&lt;/code>と、それを結合する処理の&lt;code>BiFunction&lt;/code>を指定する形となっています。&lt;/p>
&lt;p>例えば以下のような&lt;code>Stream&lt;/code>があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">Member&lt;/span>(String name, &lt;span style="color:#66d9ef">boolean&lt;/span> enabled) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member1, enabled=false],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member2, enabled=true],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member3, enabled=false],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member4, enabled=true],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream&lt;span style="color:#f92672">&amp;lt;&lt;/span>Member&lt;span style="color:#f92672">&amp;gt;&lt;/span> members &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(1, 4).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(it &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Member(&lt;span style="color:#e6db74">&amp;#34;Member&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> it, it &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを&lt;code>teeing&lt;/code>を使って、&lt;code>Member&lt;/code>の&lt;code>enabled&lt;/code>を基準に二つのListに分けるとしたら以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member2, enabled=true],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member4, enabled=true]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* ],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member1, enabled=false],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member3, enabled=false]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Member&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> members.&lt;span style="color:#a6e22e">collect&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">teeing&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">filtering&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Member::enabled,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">filtering&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Predicate.&lt;span style="color:#a6e22e">not&lt;/span>(Member::enabled),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (list1, list2) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(list1, list2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinではそもそも&lt;code>collect&lt;/code>する必要がないので、&lt;code>Collection&lt;/code>の高階関数を使った処理をした方が良いでしょう。（Javaでもそうした方がわかりやすいような…）&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがだったでしょうか。さすがに全ての変更事項を整理するのは難しかったので、目立っている変化だけをいくつか取り上げてみましたが、それでもかなりの量ですね。ただ確かなのは、Java 17が11よりもさらにモダンな言語になったバージョンであるので、Javaを使っている案件なら十分導入する価値がありそうです。また、Java 15からは11に比べてG1GCの改良による&lt;a class="link" href="https://www.optaplanner.org/blog/2021/01/26/HowMuchFasterIsJava15.html" target="_blank" rel="noopener"
>性能向上もあった&lt;/a>ようですので、性能という面でも良いですね。&lt;/p>
&lt;p>Kotlinを使っている場合でも、APIだけを見るとあまりメリットはないかもしれませんが、JVMを使っている限り性能向上などの恩恵を受けることはできると思われるので、導入を考慮しても良いかなと思います。また次のLTSでは色々と面白いAPIが続々と登場するかもしれませんしね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その三〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-3/</link><pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-3/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinで書いてみた〜その三〜" />&lt;p>JavaからKotlinに移行したものの立場から言うと、Kotlinはスタンダードライブラリだけでも色々な関数を提供しているので、Javaに比べてかなり生産性が上がるといえますが、逆にいまいち関数の有効な使い方がわからなかったり、どうやって処理を書いたら「Kotlinらしい」かわからない場合もあるかと思います。なのでもう3回目のポストになりますが、今回もKotlinで色々とコードを書いてみて、そのうち良さそうなものをいくつか共有します。&lt;/p>
&lt;h2 id="listの要素をスワップ">Listの要素をスワップ
&lt;/h2>&lt;p>Listの要素の順番を変える方法はソートなどを含め色々とありますが、二つの要素をスワップ（インデックスを交換）したい場合もあるかと思います。こういう時に活用できる拡張関数を考えてみました。&lt;/p>
&lt;h3 id="インデックスがわかる場合">インデックスがわかる場合
&lt;/h3>&lt;p>スワップしたい要素のインデックスがわかる場合は、そのインデックスを交換すればいいだけですね。ここでインデックスの交換は、二つの変数の値をスワップすることと変わらないです。変数の値を交換するのは伝統的には以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> a = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> b = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> c = a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b = c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もう少しKotlinらしい方法では、&lt;code>also&lt;/code>を用いたものがあります。その方法だと、必要な処理は以下のようにもっとシンプルになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> a = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> b = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = b.also { b = a }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これと同じく、Listの要素をスワップする処理を拡張関数で書くとしたらと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.swapByIndex(indexFrom: Int, indexTo: Int): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toMutableList().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[indexFrom] = &lt;span style="color:#66d9ef">this&lt;/span>[indexTo].also { &lt;span style="color:#66d9ef">this&lt;/span>[indexTo] = &lt;span style="color:#66d9ef">this&lt;/span>[indexFrom] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.toList()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="インデックスがわからない場合">インデックスがわからない場合
&lt;/h3>&lt;p>スワップしたい要素のインデックスがわからない場合もありますが、これも結局インデックスを持って値をスワップすることになるので、まずインデックスを抽出する処理だけを足せば良いかなと思います。&lt;/p>
&lt;p>インデックスを取得する方法は、要素を渡して取得する&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index-of.html" target="_blank" rel="noopener"
>indexOf&lt;/a>とPredicateを渡して取得する&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index-of-first.html" target="_blank" rel="noopener"
>indexOfFirst&lt;/a>があるので、これらを活用することにします。あとはこれらの方法で取得したインデックスを、先に実装しておいた拡張関数に渡すだけで良いです。例えば以下のような実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// indexOf(element)を使うケース
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.swapByElement(from: T, to: T): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swapByIndex(indexOf(from), indexOf(to))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// indexOfFirst(predicate)を使うケース
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.swapByCondition(from: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Boolean, to: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Boolean): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swapByIndex(indexOfFirst { from(&lt;span style="color:#66d9ef">it&lt;/span>) }, indexOfFirst { to(&lt;span style="color:#66d9ef">it&lt;/span>) })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="時間を数字に">時間を数字に
&lt;/h2>&lt;p>&lt;code>java.time&lt;/code>パッケージの&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>のようなオブジェクトは、コード上で時間を扱うには便利ですが、ファイルに書き込むなどでフォーマットを変更する必要がある時もあります。つまり、&lt;code>yyyy-MM-dd&lt;/code>ではなく&lt;code>yyyyMMddhhmmss&lt;/code>のような形にしたい場合があるということです。こういうときは、簡単にInt型に変更できる拡張関数を書いておくと便利でしょう。例えば以下のようなものを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">LocalDate&lt;/span>.toInt(): Int = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$year$monthValue$dayOfMonth&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">31&lt;/span>) &lt;span style="color:#75715e">// 2021-12-31
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(date.toInt()) &lt;span style="color:#75715e">// 20211231
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうする場合、以下のように月や日付が一桁のものになってしまうケースもあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// 2021-09-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(date.toInt()) &lt;span style="color:#75715e">// 202191
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この問題を解決するには、まず月や日付を二桁の文字列に変える必要がありますね。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">LocalDate&lt;/span>.toInt(): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$year${monthValue.toString().padStart(2, &amp;#39;0&amp;#39;)}${dayOfMonth.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// 2021-09-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(date.toInt()) &lt;span style="color:#75715e">// 20210901
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これでも完璧とはいえません。&lt;code>LocalDate&lt;/code>のみでなく&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>, &lt;code>YearMonth&lt;/code>など、&lt;code>java.time&lt;/code>パッケージに属する他のオブジェクトも使いたい場合には、全てのオブジェクトに対して同じような拡張関数を書く必要があるからです。&lt;/p>
&lt;p>幸い、&lt;code>LocalDate&lt;/code>、&lt;code>LocalDateTime&lt;/code>、&lt;code>YearMonth&lt;/code>は共通的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/temporal/Temporal.html" target="_blank" rel="noopener"
>Temporal&lt;/a>というインタフェースを継承しているので、&lt;code>Temporal&lt;/code>に拡張関数を追加することで問題は解決できます。&lt;/p>
&lt;p>そしてこれらの実装クラスで扱っている時間の範囲はオブジェクトごとに違うので、実装も変える必要がありますね。これらのオブジェクトはどれも時間を数字として表現しているので、まず&lt;code>toString&lt;/code>で文字列に変換した後、数字だけを抽出することです。&lt;code>String&lt;/code>は&lt;code>CharSequence&lt;/code>を継承しているので、&lt;code>filter&lt;/code>で数字だけを抽出すると良いでしょう。そうすると、以下のような方法が使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Temporal&lt;/span>.toDigit(): Long = toString().filter { &lt;span style="color:#66d9ef">it&lt;/span>.isDigit() }.toLong()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> yearMonth = &lt;span style="color:#a6e22e">YearMonth&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#75715e">// 2021-08
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(yearMonth.toDigit()) &lt;span style="color:#75715e">// 202108
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> dateTime = &lt;span style="color:#a6e22e">LocalDateTime&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#75715e">// 2021-10-02T10:10:10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(dateTime.toDigit()) &lt;span style="color:#75715e">// 20211002101010
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Stringのフォーマットで数字に変換する場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int.html" target="_blank" rel="noopener"
>toInt&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-long.html" target="_blank" rel="noopener"
>toLong&lt;/a>でループが一回発生するだけですが、CharSequenceとして扱う場合はループが2回発生するという違いがあるので性能的には前者が良いはずですが、時間を扱うくらいではそこまでループは長くないので気にするほどではないかと思います。&lt;/p>
&lt;h2 id="要素の一部を合算">要素の一部を合算
&lt;/h2>&lt;p>Listの値を一つに集約したい（合算値を出したい）場合があります。&lt;code>sum&lt;/code>を使っても良いですが、これはそもそも要素が数字ではないと難しいですね。例えば要素が以下のようなクラスとなっているケースはどうしたら良いでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> amount: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> price: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="合算したい値が一つの場合">合算したい値が一つの場合
&lt;/h3>&lt;p>合算したい値が一つだけの場合は、&lt;code>sumOf&lt;/code>で合算したい値だけを指定すれば良いです。以下は、&lt;code>Data&lt;/code>クラスの&lt;code>amount&lt;/code>だけを合算したい場合に使える方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(Data(&lt;span style="color:#e6db74">&amp;#34;data1&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>), Data(&lt;span style="color:#e6db74">&amp;#34;data2&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#ae81ff">200&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> totalAmount = list.sumOf { &lt;span style="color:#66d9ef">it&lt;/span>.amount }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="合算したい値が複数の場合">合算したい値が複数の場合
&lt;/h3>&lt;p>ここで&lt;code>amount&lt;/code>のみでなく、&lt;code>price&lt;/code>も合算したい場合はどうすれば良いでしょう。同じく&lt;code>sumOf&lt;/code>を&lt;code>price&lt;/code>にも使うことで実装はできますが、同じListに対してループが2回も発生するのあまり効率的ではありません。こういうときは、素直にそれぞれの合算値を変数として宣言しておいて&lt;code>forEach&lt;/code>ループの中で値を足していく方が効率が良いでしょう。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> totalAmount = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> totalPrice = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> totalAmount &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> totalPrice &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.price
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もう一つの方法は、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold.html" target="_blank" rel="noopener"
>fold&lt;/a>を使う方法です。&lt;code>fold&lt;/code>は&lt;code>reduce&lt;/code>と似たようなもので、初期値(initial)を指定できるという違いがありますが、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reduce-to.html" target="_blank" rel="noopener"
>reduceTo&lt;/a>のようにこの初期値の型はListの要素とは違うものに指定できます。そして関数を実行した結果はinitialと同じ型になるので、これを応用すると&lt;code>Data&lt;/code>のリストを二つの値(&lt;code>Pair&lt;/code>)に&lt;code>reduce&lt;/code>することもできます。例えば上記の処理は&lt;code>fold&lt;/code>を使うと以下のようにワンライナで実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>totalAmount, totalPrice) = list.fold(&lt;span style="color:#ae81ff">0&lt;/span> to &lt;span style="color:#ae81ff">0&lt;/span>) { acc, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (acc.first + &lt;span style="color:#66d9ef">value&lt;/span>.amount) to (acc.second + &lt;span style="color:#66d9ef">value&lt;/span>.price)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>fold&lt;/code>を使う場合、合算したい値が三つある場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-triple/" target="_blank" rel="noopener"
>Triple&lt;/a>を使うこともできますし、さらに値が多い場合は専用のクラスを作ることで対応もできるかと思います。ただ、こうする場合、合算した値を&lt;code>val&lt;/code>として宣言できるというメリットはありますが、ループごとにインスタンスが作成されるので合算したい項目が増えれば増えるほど性能的にはあまり良くない可能性が高いので場合によって適切なものを選ぶ必要がありそうですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがだったでしょうか。私はずっとJavaでコードを書いていたので、完全にKotlinに転向した今でもついJavaらしいコードを書いてしまうのではないか、と思う時があります。元を辿ると、「Javaらしいコード」や「Kotlinらしいコード」がそもそも何であるかを考えなければならないとは思いますが、それでも、確かに言語が違うとその言語に合わせて自分のコーディングスタイルも変化する必要はあるのではないかと思います。そうすることで、より良いコードが書けるようになりそうな気がしていますので。&lt;/p>
&lt;p>というわけで、これからもKotlinならではの、Kotlinに特化したコードを書くための工夫はこれからも続きます。特に今月はJava 17もリリースされたので、新しいAPIの一覧を眺めてKotlinではどう活用できるか考えてみたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>WebFluxのFunctional Enpointに対する小考察</title><link>https://retheviper.github.io/posts/spring-webflux-dividing-router-and-handler/</link><pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-webflux-dividing-router-and-handler/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post WebFluxのFunctional Enpointに対する小考察" />&lt;p>前回、&lt;a class="link" href="../spring-webflux-router/" >WebFluxではFunctional Endpointを使うべきか&lt;/a>というポストを書いたことがありますが、今回は&lt;code>Controller&lt;/code>/&lt;code>Service&lt;/code>と&lt;code>Router&lt;/code>/&lt;code>Handler&lt;/code>のパターン間の比較ではなく、&lt;code>Functional Endpoint&lt;/code>を使う場合に、どんな形で実装をしていくべきかについて少し考えたことを述べようと思います。&lt;/p>
&lt;p>実際の業務でWebFluxを使っているわけではないので、さまざまなパターンがあるかなとは思いますが、この&lt;code>Functional Endpoint&lt;/code>を使う場合に考慮すべきものが、&lt;code>Router Function&lt;/code>(以下&lt;code>Router&lt;/code>)と&lt;code>Handler Function&lt;/code>(以下&lt;code>Handler&lt;/code>)をどう分けるかについての問題かと思います。&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>は概念的には別のものではありますが、実装としては一つのクラスにまとめでもアプリは問題なく動くので、フレームワークの仕様や思想というよりかは、アプリのアーキテクチャに関する内容に近いますね。&lt;/p>
&lt;p>なので、今回は&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>を分けた場合と分けない場合について、いくつかの観点から考えてみたいと思います。&lt;/p>
&lt;h2 id="routerとhandlerは分離するべきか">RouterとHandlerは分離するべきか
&lt;/h2>&lt;p>Spring MVCの場合、&lt;code>Controller&lt;/code>と&lt;code>Service&lt;/code>を明確に分けるのが常識のようになっています。アーキテクチャとしてもそうですが、フレームワークの思想（デザインの観点）としてもそうですね。&lt;/p>
&lt;p>こういう前例があるので、同じくSpring Frameworkに属するWebFluxの場合でも、&lt;code>Functional Endpoint&lt;/code>という新しい概念を導入するとしても、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>を分ける必要があると思いがちかなと思います。一見、&lt;code>Controller ≒ Router, Service ≒ Handler&lt;/code>という対応関係が成立するようにも見えて、ネットで検索できるサンプルコードも多くがそのような構造で書かれています。&lt;/p>
&lt;p>しかし、実際のアプリを&lt;code>Functional Endpoint&lt;/code>を持って書くとしたら、いくつか考えなければならないことがあると思います。例えば、そもそも&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>はそれぞれ&lt;code>Controller&lt;/code>と&lt;code>Service&lt;/code>に一対一の対応関係であるという前提は確かであるか？もしそうでなければ、あえてMVCのパターンに合わせる必要があるのか？実装においてはどう影響するのか？などがあるかと思います。なので、今回はこれらの観点から&lt;code>Functional Endpoint&lt;/code>について述べていきます。&lt;/p>
&lt;h2 id="対応関係について">対応関係について
&lt;/h2>&lt;p>Springの&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-fn-overview" target="_blank" rel="noopener"
>公式ドキュメント&lt;/a>では、WebFluxの&lt;code>Functional Endpoint&lt;/code>の紹介において以下のようなサンプルコードを提示しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository = &lt;span style="color:#f92672">..&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> handler = PersonHandler(repository)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> route = coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accept(APPLICATION_JSON).nest {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/person/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>getPerson)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/person&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>listPeople)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POST(&lt;span style="color:#e6db74">&amp;#34;/person&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>createPerson)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonHandler&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">listPeople&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createPerson&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>公式のサンプルとして&lt;code>Handler&lt;/code>が別のクラスになっているのを見ると、やはり&lt;code>Controller ≒ Router, Service ≒ Handler&lt;/code>という対応関係が成立するようにも見えます。&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html" target="_blank" rel="noopener"
>@RestController&lt;/a>や&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html" target="_blank" rel="noopener"
>@Service&lt;/a>と違って、&lt;code>@Router&lt;/code>や&lt;code>@Handler&lt;/code>というアノテーションは存在しないことに注目する必要があります。これはつまり、Springというフレームワークの思想としては&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>を必ず分ける必要はない、ということを意味しているのではないでしょうか。&lt;/p>
&lt;p>なので、少なくともアプリケーションのアーキテクチャという観点からして&lt;code>Controller ≒ Router, Service ≒ Handler&lt;/code>という対応関係が成立する、という結論を出すのは難しいのではないかと思います。&lt;/p>
&lt;p>では、実際&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>をあえてアノテーションを使ってDIをするとしたら、どうなるのでしょうか。サンプルとしては、以下のような形が一般的かなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonRouter&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> handler: PersonHandler) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">route&lt;/span>(): RouterFunction&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accept(APPLICATION_JSON).nest {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/person/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>getPerson)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/person&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>listPeople)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POST(&lt;span style="color:#e6db74">&amp;#34;/person&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>createPerson)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonHandler&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">listPeople&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createPerson&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPerson&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>クラスそのものを&lt;code>@Component&lt;/code>として登録する必要がある&lt;code>Contoller&lt;/code>に対して、&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/RouterFunction.html" target="_blank" rel="noopener"
>RouterFunction&lt;/a>は&lt;code>Functional Interface&lt;/code>なのでそれを実装したメソッドを&lt;code>@Bean&lt;/code>として登録する必要があります。そしてSpringで&lt;code>@Bean&lt;/code>をアプリケーションに登録するのは一般的に&lt;code>@Congifuration&lt;/code>が担当するので自然にRouterのアノテーションもそうなります。&lt;code>Handler&lt;/code>は普通に&lt;code>@Component&lt;/code>として登録することになりますね。&lt;/p>
&lt;p>こうなった場合、クラスやその実装を見て&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>を分離しているのはわかりますが、アノテーションだけだと違和感を感じられますね。実装は簡単なのでそれぞれに対応するアノテーションを作るのが難しいわけでもないようですが、なぜこのような構造になっているのでしょうか。&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-programming-models" target="_blank" rel="noopener"
>公式のドキュメント&lt;/a>では、以下のような説明があります。&lt;/p>
&lt;blockquote>
&lt;p>The big difference with annotated controllers is that the application is in charge of request handling from start to finish versus declaring intent through annotations and being called back.&lt;/p>&lt;/blockquote>
&lt;p>つまり、「アノテーションをつけたContoller」と「Functional Endpoint」の違いは、前者が「アノテーションでコールバックと意図を表す」に対して、後者は「リクエストのハンドリングを開始から終了まで担当する」ということです。プログラミングモデルとしてこのような観点の差があるので、アノテーションがないのは当たり前なのかもしれません。そして結果的に、&lt;code>Controller ≒ Router, Service ≒ Handler&lt;/code>という対応関係は、少なくともプログラミングモデルという観点では当てはならないと考えられます。&lt;/p>
&lt;h2 id="責任の分散という側面で">責任の分散という側面で
&lt;/h2>&lt;p>アノテーションの実装を見ると、&lt;code>@Controller&lt;/code>と&lt;code>@Service&lt;/code>を分けているのがフレームワークのアーキテクチャや思想によるものであることがより明確になります。それぞれのアノテーションの実装は、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Target&lt;/span>(value&lt;span style="color:#f92672">=&lt;/span>TYPE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Retention&lt;/span>(value&lt;span style="color:#f92672">=&lt;/span>RUNTIME)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> Controller
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Target&lt;/span>(value&lt;span style="color:#f92672">=&lt;/span>TYPE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Retention&lt;/span>(value&lt;span style="color:#f92672">=&lt;/span>RUNTIME)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> Service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>両方とも実装が同じであるので、極端的にいうと&lt;code>Controller&lt;/code>に&lt;code>@Service&lt;/code>をつけても機能的には同一ということになります。そして&lt;code>@Service&lt;/code>では、以下のようなコメントでこのアノテーションが存在する理由をあくまで「デザインパターンに基盤を置いている」ことを明示しています。&lt;/p>
&lt;blockquote>
&lt;p>Indicates that an annotated class is a &amp;ldquo;Service&amp;rdquo;, originally defined by Domain-Driven Design (Evans, 2003) as &amp;ldquo;an operation offered as an interface that stands alone in the model, with no encapsulated state.&amp;rdquo;
May also indicate that a class is a &amp;ldquo;Business Service Facade&amp;rdquo; (in the Core J2EE patterns sense), or something similar. This annotation is a general-purpose stereotype and individual teams may narrow their semantics and use as appropriate.&lt;/p>&lt;/blockquote>
&lt;p>なので、アプリケーションデザインの観点からすると&lt;code>Controller&lt;/code>はリクエストを受信、レスポンスを返す、エンドポイントを&lt;code>Service&lt;/code>につなぐという義務だけを持ち、&lt;code>Service&lt;/code>はビジネスロジックを処理する義務を持つと考えられます。同じ観点から考えると、アノテーションはないものの、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>もまた同じ義務を持つように書くこともできるでしょう。&lt;/p>
&lt;p>ただ、問題は「リクエストのハンドリングを開始から終了まで担当する」という定義です。先程のサンプルコードをよく見ると、Handlerのメソッドはどれも&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerRequest.html" target="_blank" rel="noopener"
>ServerRequest&lt;/a>を引数として、戻り値は&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerResponse.html" target="_blank" rel="noopener"
>ServerResponse&lt;/a>になっています。これはつまり、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>をあえて別のクラスとして分割するとしても、リクエストとレスポンスまでを&lt;code>Handler&lt;/code>で処理することを意味します。&lt;/p>
&lt;p>ここで「&lt;code>Controller&lt;/code>/&lt;code>Service&lt;/code>の場合と同じく、&lt;code>Handler&lt;/code>の引数と戻り値だけを変えて良いのでは？」と考えられます。しかし、それこそフレームワークの思想に反することです。&lt;code>ServerRequest&lt;/code>と&lt;code>ServerResponse&lt;/code>のJavaDocでは、以下の通り「&lt;code>ServerRequest&lt;/code>と&lt;code>ServerResponse&lt;/code>は&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/HandlerFunction.html" target="_blank" rel="noopener"
>HandlerFunction&lt;/a>でハンドリングする」ことを明示しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Represents a server-side HTTP request, as handled by a {@code HandlerFunction}.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;Access to headers and body is offered by {@link Headers} and
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * {@link #body(BodyExtractor)}, respectively.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @author Arjen Poutsma
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @author Sebastien Deleuze
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @since 5.0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ServerRequest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Represents a typed server-side HTTP response, as returned
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * by a {@linkplain HandlerFunction handler function} or
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * {@linkplain HandlerFilterFunction filter function}.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @author Arjen Poutsma
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @author Juergen Hoeller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @author Sebastien Deleuze
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @since 5.0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ServerResponse&lt;/span> {
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のことでわかるように、WebFluxでは&lt;code>ServerRequest&lt;/code>と&lt;code>ServerResponse&lt;/code>は&lt;code>HandlerFunction&lt;/code>で扱うようにデザインされています。なので、既存の&lt;code>Service&lt;/code>のように、&lt;code>Handler&lt;/code>がビジネスロジック「のみ」を扱うというのはそれが実装として可能かどうか以前の問題になるのです。&lt;/p>
&lt;p>ただ、「責任の分散」という観点からして、責任によってクラスを分けるという発想は間違っているわけではないですね。なのでビジネスロジックを担当するクラスを&lt;code>Handler&lt;/code>と分離して運用するケースは考えられますが、必ずしもクラスを分ける基準が&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>である必要はないのではないかと思われます。&lt;/p>
&lt;h2 id="テストの観点で">テストの観点で
&lt;/h2>&lt;p>JavaでJUnitなどを用いてユニットテストを作る場合、テスト自体はユースケース単位で作成しますが、それらのテストはクラス単位でまとめるというケースが多いかなと思います。なので同じ観点でユニットテストを書く場合、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>が分けられているとしたら当然ユニットテストもその単位で分けられるでしょう。&lt;/p>
&lt;p>ただ、こうする場合の問題は、テスト自体があまり意味を持たなくなる可能性があるということです。まず&lt;code>Router&lt;/code>は単純にエンドポイントと&lt;code>Handler&lt;/code>をつなぐ役割しか持たなくなるので、そのテストも「想定通りの&lt;code>HadlerFunction&lt;/code>を呼び出しているのか」に限るものになります。そして&lt;code>Handler&lt;/code>の場合、&lt;code>ServerRequest&lt;/code>を受信して&lt;code>ServerResponse&lt;/code>を発するので、テストが非常に難しくなるという問題があります。&lt;/p>
&lt;p>なぜ&lt;code>ServerRequest&lt;/code>を受信して&lt;code>ServerResponse&lt;/code>を発するのが問題になるかというと、&lt;code>ServerRequest&lt;/code>のインスタンスを生成するのが難しく、&lt;code>ServerResponse&lt;/code>の場合でもレスポンスボディーを抽出するのが難しいからです。なので、&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/reactive/server/WebTestClient.html" target="_blank" rel="noopener"
>WebTestClient&lt;/a>で行うことになるかと思いますが、&lt;code>WebTestClient&lt;/code>を使う場合はエンドポイントとHTTPメソッドなどを利用して実際のAPIを呼び出すことになるので、結果的に&lt;code>Handler&lt;/code>のテストをするつもりが&lt;code>Router&lt;/code>のテストまでふくむしかないということになります。こうするとクラス単位でテストケースをまとめることが難しいだけでなく、&lt;code>Router&lt;/code>のみのテストも実質的には意味をなくすということになります。&lt;/p>
&lt;h2 id="ではどうすればいいか">ではどうすればいいか
&lt;/h2>&lt;p>今まで論じた3つの観点からすると、&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>は別のクラスにする理由もあまりなく、むしろ別クラスに色々と問題が生じるように見えます。しかし、これが必ずしもエンドポイントに対するルーティングとビジネスロジックを分離する必要はない、ということではないかと思います。先に述べた通り、クラスを分ける基準を&lt;code>Router&lt;/code>と&lt;code>Handler&lt;/code>にしないだけで良いかなと思います。例えば、以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonRouter&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">route&lt;/span>(): RouterFunction&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/person/{id}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ServerResponse&lt;/span>.ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.findById(&lt;span style="color:#66d9ef">it&lt;/span>.pathVariable(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>).toLong())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { record &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PersonDto(record.id, record.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ).awaitSingle()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Handler&lt;/code>で、&lt;code>Body&lt;/code>を作る箇所以外はビジネスロジックと言えるものがあまりありません。なので、ここでは&lt;code>Body&lt;/code>だけを分離して別のクラス（&lt;code>Service&lt;/code>）に一任しても良さそうです。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonRouter&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">route&lt;/span>(): RouterFunction&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/person/{id}&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ServerResponse&lt;/span>.ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(service.getPersonById(&lt;span style="color:#66d9ef">it&lt;/span>.pathVariable(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>).toLong()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .awaitSingle()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PersonService&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPersonById&lt;/span>(id: Long): Mono&amp;lt;PersonDto&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.findById(id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { PersonDto(&lt;span style="color:#66d9ef">it&lt;/span>.id, &lt;span style="color:#66d9ef">it&lt;/span>.name) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうすると、&lt;code>Router&lt;/code>から直接&lt;code>Repository&lt;/code>にアクセスこともなくなり、今まで挙げていたさまざまな問題も解消できるようになりますね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ここで提示した方法でビジネスロジックを分けるのは可能だとして、その方法をとった場合に残る疑問はあります。これは果たして&lt;code>Functional&lt;/code>なのか？&lt;code>Functional Endpoint&lt;/code>は&lt;code>Lambda-based&lt;/code>と説明されてあるが、&lt;code>Lambda&lt;/code>が使われないので設計意図とは違う形になってないか？そもそもSpring MVCとは違うコンセプトのフレームワークなので既存とは違うアプローチが必要なのでは？などなど。&lt;/p>
&lt;p>これらの問題を判断するのはなかなか難しいですが、個人的には新しい技術だからといって常に新しい方法論を適用するということは難しく、既存の良い体系があるのならそれに従うのもそう間違っていることとは思いません。Springの公式ドキュメントでは「すでに問題なく動いているSpring MVCアプリケーションにあえてWebFluxを導入する必要はない(If you have a Spring MVC application that works fine, there is no need to change)」と述べていますが、これと同じく、既存の検証されてあるアーキテクチャがあるのならばそれをそのまま適用するもの悪くないのではと思います。まぁ、そもそもWebFluxを導入するところでMVCパターンを使うとしたらこういうことを気にする理由すら無くなるのですが…むしろこのようなプログラミングモデルが増えていくと今後は新しいアーキテクチャが生まれそうな気もしますね。今回のポストを書きながらはそういういうものを感じました。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KtorでRole-based Authorizationを実装する</title><link>https://retheviper.github.io/posts/ktor-role-based-authorization/</link><pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ktor-role-based-authorization/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.webp" alt="Featured image of post KtorでRole-based Authorizationを実装する" />&lt;p>前回、Ktorを紹介しながら、Ktorにはまだ&lt;code>Role-based Authorization&lt;/code>に対応してないので、自前でそのような機能を実装する必要がある、と述べました。Ktorはまだ歴史が短く、SpringやDjango、Railsのように幅広く使われているフレームワークでもないので、おそらく他に比べ実のアプリケーションを作るにあたっては必要な機能が十分でない可能性がありますね。なので、こうやって必要な機能がない場合は直接その機能を実装するしかないです。&lt;/p>
&lt;p>幸い、Ktorでは機能を&lt;a class="link" href="https://ktor.io/docs/plugins.html" target="_blank" rel="noopener"
>Plugin&lt;/a>といい、モジュール単位で追加できるため、必要な機能を実装するのもそのPluginを作ることでできるようになります。ただ、モジュールを利用するということは、機能単位の管理がやりやすくなるものの、そのモジュールはどうやって機能するか、また、どういうお作法が必要となるかを知る必要がありますね。&lt;/p>
&lt;p>今回はネット上に公開されてある&lt;a class="link" href="https://medium.com/@shrikantjagtap99/role-based-authorization-feature-in-ktor-web-framework-in-kotlin-dda88262a86a" target="_blank" rel="noopener"
>記事&lt;/a>を参考にしながら、KtorのRole-based Authorizationを&lt;code>Plugin&lt;/code>として実装してみました。そこで、今回のポストではこういう自作の&lt;code>Plugin&lt;/code>がどうやってKtorの機能として動作するか、どうやって実装するのかについて述べたいと思います。&lt;/p>
&lt;h2 id="role-based-authorizationとは">Role-based Authorizationとは
&lt;/h2>&lt;p>まずは、そもそも&lt;code>Role-based Authorization&lt;/code>とは何か、からですね。これは、ウェブアプリケーションでよく言われている「認可」の方式のうち、ユーザの&lt;code>Role&lt;/code>（役割）に基づいて、APIの実行を制御するものです。例えばECサイトの場合、商品に対して問い合わせをするのは認証されたユーザなら誰でもできるべきですが、「お知らせを書く」や「商品の在庫数を変更する」などの機能はその権限を持つユーザ（Admin）に限定すべきですね。なので、ここで「一般ユーザ」と「管理者」などの&lt;code>Role&lt;/code>を設け、APIに対してのリクエストが発生した際にその&lt;code>Role&lt;/code>をまず確認し、その権限のあるユーザのみがAPIを実行できるようにする、というのが&lt;code>Role-based Authorization&lt;/code>の基本的な概念です。&lt;/p>
&lt;p>これを実現するために既存のアプリに導入する必要のあるものは、大きく分けて&lt;code>Role&lt;/code>の概念と、それを元にリクエストをフィルタリングする機構の二つです。前者の場合はどんなロールがあり、どういう形でユーザに紐付けるかを考えればいいだけなので、テーブルやカラムを追加して既存のユーザの情報と紐づけるだけですみます。しかし、後者はまずフレームワークでどうやってリクエストをフィルタするか、まずその構造から理解する必要がありますね。なんので、まずはKtorでリクエストを扱う方法に対して紹介したいと思います。&lt;/p>
&lt;h2 id="pipelineとfeature">PipelineとFeature
&lt;/h2>&lt;p>Ktorの特徴のうち、最も重要と言えるものは、&lt;a class="link" href="https://ktor.io/docs/pipelines.html" target="_blank" rel="noopener"
>Pipeline&lt;/a>の概念です。この&lt;code>Pipeline&lt;/code>に対して、公式では以下のように説明しています。&lt;/p>
&lt;blockquote>
&lt;p>The pipeline is a structure containing a sequence of functions (blocks/lambdas) that are called one after another, distributed in phases topologically ordered, with the ability to mutate the sequence and to call the remaining functions in the pipeline and then return to current block.&lt;/p>&lt;/blockquote>
&lt;p>この説明だけでは理解が難しいものですが、要するに、Ktorにおいての処理の単位のことを指していると言ってもよいものです。&lt;code>Pipeline&lt;/code>ではAPIのコールからレスポンスまで一連の流れとしての処理を定義することができます。なので&lt;code>Pipeline&lt;/code>として実現されている代表的な機能は&lt;code>Router&lt;/code>、リクエストに対してのハンドリングを定義する機能（Springの&lt;code>Controller&lt;/code>に対応するもの）となります。&lt;/p>
&lt;p>また、&lt;code>Pipeline&lt;/code>は拡張できるものなので、その形式に合わせて新しい&lt;code>Pipeline&lt;/code>を実装することでモジュール(公式の表現では&lt;code>Plugin&lt;/code>)を実現するのもできます。これらのモジュールを実装し、アプリケーションにインストールすることで、そのモジュールの機能を利用できるようになるのがKtorの特徴です。例えば、kotlin公式のJSON Mapperである&lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>kotlinx.serialization&lt;/a>をアプリケーションに追加するためには以下のようなコードを書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(ContentNegotiation) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> json()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで呼び出している&lt;code>install&lt;/code>関数の実装を見ると、以下のようになっています。&lt;code>feature&lt;/code>(モジュール)と、そのモジュールの設定となる&lt;code>configure&lt;/code>が引数になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">P&lt;/span> : &lt;span style="color:#a6e22e">Pipeline&lt;/span>&amp;lt;*, &lt;span style="color:#a6e22e">ApplicationCall&lt;/span>&amp;gt;, &lt;span style="color:#a6e22e">B&lt;/span> : &lt;span style="color:#a6e22e">Any&lt;/span>, &lt;span style="color:#a6e22e">F&lt;/span> : &lt;span style="color:#a6e22e">Any&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">P&lt;/span>.install(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> feature: ApplicationFeature&amp;lt;P, B, F&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configure: &lt;span style="color:#a6e22e">B&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit = {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): F
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先ほどの&lt;code>kotlinx.serialization&lt;/code>をインストールするために使っていたコードでは、&lt;code>feature&lt;/code>として&lt;code>ContentNegotiation&lt;/code>を渡し、その設定として&lt;code>json&lt;/code>を使うという設定をしているのだなという推測ができますね。実際、&lt;code>ContentNegotiation&lt;/code>の実装は、以下のような形となっています。一部のコードは省略していますが、クラスの中には&lt;code>Configuration&lt;/code>というクラスと、&lt;code>ApplicationFeature&lt;/code>を継承した&lt;code>companion object&lt;/code>を中に持っているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ContentNegotiation&lt;/span> &lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> registrations: List&amp;lt;ConverterRegistration&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> acceptContributors: List&amp;lt;AcceptHeaderContributor&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> checkAcceptHeaderCompliance: Boolean = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Configuration type for [ContentNegotiation] feature
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Configuration&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Implementation of an [ApplicationFeature] for the [ContentNegotiation]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> Feature : ApplicationFeature&amp;lt;ApplicationCallPipeline, Configuration, ContentNegotiation&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の実装でわかるように、&lt;code>Pipeline&lt;/code>として機能するためにはモジュールの設定のための&lt;code>Configuration&lt;/code>というクラスと、モジュールとして機能するための&lt;code>ApplicationFeature&lt;/code>を継承した&lt;code>companion object&lt;/code>が必要であることがわかります。なので、この構造を持ったクラスを定義できれば、自作のモジュールをアプリケーションに実装できるということがわかりますね。&lt;/p>
&lt;h2 id="pluginの実装">Pluginの実装
&lt;/h2>&lt;p>では、実際に&lt;code>Pipeline&lt;/code>として、リクエストに対する認可を判定する機能を作るとしましょう。まずはロールを定義します。&lt;code>enum&lt;/code>が良さそうですね。ここではシンプルに管理者と一般ユーザの2種を作ってみます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Role&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ADMIN(&lt;span style="color:#e6db74">&amp;#34;ADMIN&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> USER(&lt;span style="color:#e6db74">&amp;#34;USER&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのロールは、テーブルなどで管理する必要もありますが、ログイン中のユーザ情報から取得する必要もありますね。認可のためには、ログイン中のユーザにとあるロールが与えられているかどうかの確認が必要となるからです。なので、&lt;code>io.ktor.auth.Principal&lt;/code>を継承したユーザの情報もクラスとして作り、ログインに成功した時はこのクラスにユーザのロールを格納することにします（方法は認可とは関係ないのでここでは割愛させてください）。以下はユーザの情報を格納するための簡単な例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UserPrincipal&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> username: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> roles: Set&amp;lt;Role&amp;gt; = emptySet()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : Principal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に、ロールでアクセスを制限する関数を作ります。&lt;code>Router&lt;/code>のエンドポイントに、どのロールの場合にアクセスできるかを指定するようなイメージです。例えば以下のような形で使えたらいいかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 管理者のみアクセスできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> withRole(&lt;span style="color:#a6e22e">Role&lt;/span>.ADMIN) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/admin&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#e6db74">&amp;#34;This is admin page&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 一般ユーザがアクセスできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> withRole(&lt;span style="color:#a6e22e">Role&lt;/span>.USER) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/user&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#e6db74">&amp;#34;This is user page&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Router&lt;/code>の使い方でわかるように、&lt;code>Pipeline&lt;/code>でのコードブロック（関数）はネストが可能なのでこのように一つのレイヤーを挟むのも可能です。ここで追加した&lt;code>withRole&lt;/code>という関数でロールを確認し、APIにアクセスできるかどうかを判定するようにしたら良いでしょう。&lt;/p>
&lt;h3 id="authorizedrotueselectorの実装">AuthorizedRotueSelectorの実装
&lt;/h3>&lt;p>まずは&lt;code>RouteSelector&lt;/code>を実装します。これは、&lt;code>routing&lt;/code>の中にこれから作る認可の関数がネストできるようにするためのものです。もっともシンプルな実装は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AuthorizedRouteSelector&lt;/span>() : RouteSelector() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">evaluate&lt;/span>(context: RoutingResolveContext, segmentIndex: Int) = &lt;span style="color:#a6e22e">RouteSelectorEvaluation&lt;/span>.Constant
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="child-routeの実装">child routeの実装
&lt;/h3>&lt;p>先に実装した&lt;code>AuthorizedRouteSelector&lt;/code>を利用して、実際に&lt;code>child route&lt;/code>として機能する関数を作ります。この&lt;code>child route&lt;/code>は&lt;code>Router&lt;/code>の下にネストすることになるので、&lt;code>Route&lt;/code>の拡張関数を作ることにします。引数としては判定のためのロールと、その下にネストするエンドポイントの関数を設定できるようにすれば良いでしょう。実装は以下のようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Route&lt;/span>.withRole(&lt;span style="color:#66d9ef">val&lt;/span> role: Role, build: &lt;span style="color:#a6e22e">Route&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit): Route {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> authorizedRoute = createChild(AuthorizedRouteSelector())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> application.feature(RoleBaseAuthorizer).interceptPipeline(&lt;span style="color:#66d9ef">this&lt;/span>, role)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> build()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> authorizedRoute
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで実装しているものは、まず&lt;code>AuthorizedRouteSelector&lt;/code>で&lt;code>child route&lt;/code>を作り、その後&lt;code>Pipeline&lt;/code>をインターセプトして、ユーザが指定したロールに該当するかどうかを判定します。問題なければ&lt;code>build&lt;/code>を実行させますが、これがネストしている&lt;code>child route&lt;/code>になります。最後に、エンドポイントをネストできるように先ほど作成した&lt;code>child route&lt;/code>のインスタンスを返します。&lt;/p>
&lt;p>&lt;code>Pipeline&lt;/code>をインターセプトする時に呼び出している&lt;code>RoleBaseAuthorizer&lt;/code>は、別途クラスとして作ることにします。これを&lt;code>Feature&lt;/code>として作ることになります。&lt;/p>
&lt;h3 id="認可処理のモジュールの実装">認可処理のモジュールの実装
&lt;/h3>&lt;p>では、本格的に認可の処理を担当するモジュール（&lt;code>Feature&lt;/code>）を実装することにします。先に述べた通り、&lt;code>Configuration&lt;/code>と&lt;code>Feature&lt;/code>を内部に持ったクラスを作ります。ここで&lt;code>Configuration&lt;/code>は、ログイン中のユーザからどうやってロールの情報を取得するかの設定ができるクラスにします。こうすることで、以下のようなことが可能になるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Application&lt;/span>.main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// RoleBaseAuthorizerをFeatureとしてインストール
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> install(RoleBaseAuthorizer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン中のユーザの情報からロールを取得する方法をConfigurationとして指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> getRoles { (&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> UserPrincipal).roles }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Configuration&lt;/code>では、ログイン中のユーザ情報となる&lt;code>UserPrincipal&lt;/code>から&lt;code>roles&lt;/code>を取得する、という関数を渡します。これを持って、&lt;code>RoleBaseAuthorizer&lt;/code>では&lt;code>withRole&lt;/code>関数で指定したロールとユーザのロールを比較するようにします。&lt;/p>
&lt;p>認可のモジュールの設定方法のイメージができたので、次に&lt;code>RoleBaseAuthorizer&lt;/code>を実装します。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RoleBaseAuthorizer&lt;/span>(config: Configuration) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Configuration&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> userRoles: (Principal) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Set&amp;lt;Role&amp;gt; = { emptySet() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン中のユーザの情報からロールの取得方法をセット
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getRoles&lt;/span>(roles: (Principal) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Set&amp;lt;Role&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userRoles = roles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> getRoles = config.userRoles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">interceptPipeline&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pipeline: ApplicationCallPipeline,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> role: Role
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Pipelineの位置付け
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pipeline.insertPhaseAfter(&lt;span style="color:#a6e22e">ApplicationCallPipeline&lt;/span>.Features, &lt;span style="color:#a6e22e">Authentication&lt;/span>.ChallengePhase)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pipeline.insertPhaseAfter(&lt;span style="color:#a6e22e">Authentication&lt;/span>.ChallengePhase, AuthorizationPhase)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インターセプト時の処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pipeline.intercept(AuthorizationPhase) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン中のユーザの情報を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> principal = call.authentication.principal&amp;lt;UserPrincipal&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> AuthorizationException(&lt;span style="color:#e6db74">&amp;#34;Missing principal&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザ情報からロールを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> roles = getRoles(principal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (roles.none { role }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン中のユーザのロールに、アクセス可能なロールが含まれてない場合の処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> Feature : ApplicationFeature&amp;lt;ApplicationCallPipeline, Configuration, RoleBaseAuthorizer&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> key = AttributeKey&amp;lt;RoleBaseAuthorizer&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;RoleBaseAuthorizer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> AuthorizationPhase = PipelinePhase(&lt;span style="color:#e6db74">&amp;#34;Authorization&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">install&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pipeline: ApplicationCallPipeline,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configure: &lt;span style="color:#a6e22e">Configuration&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ): RoleBasedAuthorization {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> configuration = Configuration().apply(configure)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> RoleBaseAuthorizer(configuration)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先に説明した通り、&lt;code>Configuration&lt;/code>ではユーザのロール情報を取得する関数を設定し、保存します。そして&lt;code>interceptPipeline&lt;/code>では、その関数を持って&lt;code>Pipeline&lt;/code>をインターセプトし、ロールの検証を行うようにします。&lt;/p>
&lt;p>また、&lt;code>interceptPipeline&lt;/code>では、引数として渡された&lt;code>Pipeline&lt;/code>の位置付けを設定する必要があります。上記のコードでは、「認証の後」に位置付けしています。その後のロジックは、色々な方法があると思いますので、ここでは割愛させていただきます。&lt;/p>
&lt;p>他に、&lt;code>Feature&lt;/code>の場合は、&lt;code>RoleBaseAuthorizer&lt;/code>が独立したモジュールとして使える設定を行います。単純に名前をつけてインスタンスを返すような、お作法的なものですね。&lt;/p>
&lt;p>ここまでの実装が終わったら、一通り認可に関するモジュールの作成は終わります。ただ、&lt;code>interceptPipeline&lt;/code>の処理としてユーザのロールが、APIにアクセスできない場合の処理として考えられることは二つほどあります。&lt;/p>
&lt;h4 id="レスポンスを返して終了">レスポンスを返して終了
&lt;/h4>&lt;p>まず考えられる方法は、適当なレスポンスを返し、そこで処理を終了させることです。この場合、以下のように実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (roles.none { role }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンスを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> call.respond(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status = &lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.Forbidden,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message = &lt;span style="color:#e6db74">&amp;#34;permission not granted: &lt;/span>&lt;span style="color:#e6db74">$role&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Pipelineの終了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> finish()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで注意すべきことは、レスポンスを返すだけで&lt;code>Pipeline&lt;/code>は終わらないということです。レスポンスを返し処理を止めたい場合は必ず&lt;code>finish()&lt;/code>を呼び出して、&lt;code>Pipeline&lt;/code>を終了させましょう。&lt;/p>
&lt;h4 id="exceptionを投げる">Exceptionを投げる
&lt;/h4>&lt;p>もう一つの方法は、例外を投げる方法ですね。例えば以下のようにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 認可されてない場合の例外
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AuthorizationException&lt;/span>(&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> message: String) : Exception(message)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (roles.none { role }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> AuthorizationException(&lt;span style="color:#e6db74">&amp;#34;permission not granted: &lt;/span>&lt;span style="color:#e6db74">$role&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例外を投げる場合は、当然&lt;code>Pipeline&lt;/code>の処理が止まることになりますが、アプリケーションのログでも例外になるのであまり良くないですね。幸い、KtorにもSpringの&lt;code>ExceptionHandler&lt;/code>のような機能があるので、それを活用したら適切な例外のハンドリングが可能になります。例えば以下のようなことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 認可されてない場合のレスポンス
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AuthFailedResponse&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> reason: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 例外のハンドリング
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>install(StatusPages) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exception&amp;lt;Throwable&amp;gt; { cause &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (cause) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 認可の場合の処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> AuthorizationException &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status = &lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.Forbidden,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message = AuthFailedResponse(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reason = cause.message
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでアプリケーションのログも綺麗になりますし、他の例外処理に対しても&lt;code>when&lt;/code>の分岐を増やすだけで対応ができるようになります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最初に思っていたことよりも膨大な内容を扱うことになったので、いつもより説明が大雑把な気もしますが、これで&lt;code>Pipeline&lt;/code>とそれを応用した自作モジュールの実装についての説明は一通りできたかなと思います。なので、これを応用すれば、他のモジュールを追加するのもそう難しくなさそうな気がしますね。深堀すると色々また出そうな気がしますが、それについては機会があればまた今度のポストのネタにしましょう。（正直あまり詳しくありませんので…）&lt;/p>
&lt;p>個人的には、このようにRole-based Authorizationの機能を作りながら知った。一連の処理を&lt;code>Pipeline&lt;/code>という単位で扱うという概念ががかなり新鮮で、良いと思いました。処理に対してのインターセプトはSpringでもできるのですが、処理の流れ自体を一つの単位として扱えるならより色々なことができそうな気もしますね。まだKtorに触れたばかりなので、詳しいことはもっと時間をかけてゆっくり調べる必要がありそうですが。&lt;/p>
&lt;p>確かなのは、Ktorはかなり魅力的なフレームワークであるということです。最初はSpringなど、既存の有名なフレームワークと比べ色々と機能が足りない認証だったのですが、こうやって簡単にモジュールを作れるとしたら意外と問題ないかもしれない、という気がします。もちろんそれでも、プロダクションレベルのものを作るにはまだ色々と検証が必要そうな認証はありますが。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>ExposedでOneToManyをどうマッピングするか</title><link>https://retheviper.github.io/posts/exposed-mapping-record-to-object/</link><pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/exposed-mapping-record-to-object/</guid><description>&lt;img src="https://retheviper.github.io/images/exposed.webp" alt="Featured image of post ExposedでOneToManyをどうマッピングするか" />&lt;p>DBのテーブルとして、1:Nのリレーションは珍しいものではありません。例えば、ECサイトで会員登録をし、複数の配送先を設定できるようにするとしたら、この会員情報のテーブルに配送先のカラムを追加するよりは、配送先のテーブルを分離して別に管理した方がデータの持ち方としては合理的で安全なはずです。そして分離した配送先のテーブルは、会員情報のテーブルとN:1の関係になるのが一般的でしょう。&lt;/p>
&lt;p>ただ、データの持ち方が優先的なDBと、そのデータを処理して形にするアプリケーションでは事情が違いますね。例えば上記の通り、一つの会員情報のレコードに対して複数の配送先のレコードが存在し得る場合、SQLでデータを表現すると、以下のような形になるはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>|-----------|-------------|-----------------|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| member.id | member.name | mailing.address |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-----------|-------------|-----------------|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 1 | John | Tokyo |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 1 | John | New York |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 1 | John | Beijing |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 2 | Simpson | Osaka |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 2 | Simpson | Nagoya |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-----------|-------------|-----------------|
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかしアプリケーションではこのような形でデータを扱うことはあまりないですね。一つのレコードに対して複数のレコードが含まれるということは、Kotlinだと以下のように表現するのが一般的かと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Member&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> mailingAdress: List&amp;lt;String&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして普通は、このようなオブジェクトをJSONの形にしてREST APIのレスポンスとして使う場合が多いですね。なので、先程のレコードをJSONにした場合は以下のようになるはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;members&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;mailingAddress&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Tokyo&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;New York&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Beijing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Simpson&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;mailingAddress&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Osaka&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Nagoya&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで問題は、オブジェクトをJSONに変えることはそう難しくないのですが（&lt;a class="link" href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener"
>Jackson&lt;/a>, &lt;a class="link" href="https://github.com/google/gson" target="_blank" rel="noopener"
>Gson&lt;/a>, &lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>Kotlin Serialization&lt;/a>のようなライブラリがすでにありますし）&lt;/p>
&lt;p>では、このような場合、DBから取得したレコードをどうやってオブジェクトにマッピングしたら良いのでしょう。JPAのようなORMを使う場合、クラスにテーブル間の関係を表すフィールドとアノテーションを適切に使うことでレコードへのマッピングは自動に行われますが、&lt;a class="link" href="https://www.jooq.org" target="_blank" rel="noopener"
>jOOQ&lt;/a>や&lt;a class="link" href="https://querydsl.com" target="_blank" rel="noopener"
>Querydsl&lt;/a>, &lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>, &lt;a class="link" href="https://www.ktorm.org" target="_blank" rel="noopener"
>Ktorm&lt;/a>のようなORMで、DSLを使ってSQLを書く場合はデータのマッピングを手動で行う必要があります。そして取得したデータは行の配列という形になるので、どうマッピングしたら（効率が）いいかは少し悩ましいところです。&lt;/p>
&lt;p>なので、今回はExposedのDSLを使って取得したOne to Manyのレコードを、コード上でどうやってオブジェクトにマッピングするかについて考えたことを述べたいとお思います。&lt;/p>
&lt;h2 id="テーブルごとにselectする">テーブルごとにSelectする
&lt;/h2>&lt;p>もっとも簡単な方法は、そもそもレコードの取得時に個別のテーブルに対してSelectしてからマッピングすることですね。個別のテーブルに対してクエリを発行するので、書き方としては明瞭になるというメリットもあります。例えば、以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// まずはMemberテーブルをSelectし、オブジェクトにマッピングする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> member = &lt;span style="color:#a6e22e">Member&lt;/span>.select { &lt;span style="color:#a6e22e">Member&lt;/span>.id eq id }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .first()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemberDto(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = row[&lt;span style="color:#a6e22e">Member&lt;/span>.id].&lt;span style="color:#66d9ef">value&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = row[&lt;span style="color:#a6e22e">Member&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> role = listOf(row[&lt;span style="color:#a6e22e">Mailing&lt;/span>.role])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// MailingテーブルをSelectし、リストにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> mailingAddress = Mailing
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .select { &lt;span style="color:#a6e22e">Mailing&lt;/span>.memberId eq member.id }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Mailing&lt;/span>.address] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オブジェクトのコピーを作り配送先のデータをマッピング
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> member.copy(mailingAddress = mailingAddress)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もっとも簡単で、コードとしてもわかりやすい方法ではありますが、トランザクションの観点からするとあまりよくない方法ですね。Exposedでは、&lt;code>transaction&lt;/code>ブロックに包むことでトランザクションの単位を制御できるものの、一回で済ませるクエリの発行が複数になるという問題があります。ここではMemberテーブルを照会するたびにMailingテーブルも照会することになるので1回のクエリが追加されているだけですが、もしMemberテーブルに1:Nの関係となっているテーブルが増えれば増えるほどクエリの発行数も増えることになるでしょう。そして今回は一つのレコードに対してのコードとなっていますが、照会対象のMemberテーブルのレコードが増えれば増えるほど発行されるクエリの数も多くなります。&lt;/p>
&lt;p>また、オブジェクトのインスタンスを作っておいて、わざわあコピーするというのもあまり効率が良いとは言えません。これもまたクエリの数が増える問題と同じく、照会対象のレコードが増えれば増えるほど生成されるオブジェクトのインスタンスも増えることになるという訳ですね。なので、全く性能や効率を考えてないコードと言えます。&lt;/p>
&lt;h2 id="joinしてマッピングする">joinしてマッピングする
&lt;/h2>&lt;p>関係のあるデータを複数のテーブルを跨いで取得するには、やはり&lt;code>join&lt;/code>が効率的でしょう。これならまず発行されるクエリの数は個別のテーブルに対してSelectする時に比べ、劇的に減ります。アルゴリズムでよく使われる表現の&lt;a class="link" href="https://vmm.dev/ja/cci/cci-0.md" target="_blank" rel="noopener"
>Big O記法&lt;/a>で表現すると、前者は&lt;code>O(N^2)&lt;/code>であり、これは&lt;code>O(1)&lt;/code>と表現できるはずです。&lt;/p>
&lt;p>ならばデータを取得する際に、クエリとしては&lt;code>join&lt;/code>を使うのが理想的なのはわかりますが、問題はそうやって取得したデータをどう加工するかです。先に述べましたが、取得したデータのうち重複するものがあるからですね。そしてこれが重複しているかどうかはクエリを実行した結果を取得して、確認するまではわかりません。&lt;/p>
&lt;p>ここで考えられる方法は三つほどありますので、一つづつ紹介していきます。&lt;/p>
&lt;h3 id="reduce">reduce
&lt;/h3>&lt;p>まずはクエリの結果として取得した行を、それぞれオブジェクトにマッピングした後、&lt;code>reduce&lt;/code>でまとめる方法です。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Member&lt;/span>.leftJoin(Mailing)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .select { (&lt;span style="color:#a6e22e">Member&lt;/span>.id eq id) and (&lt;span style="color:#a6e22e">Mailing&lt;/span>.memberId eq &lt;span style="color:#a6e22e">Member&lt;/span>.id) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// とりあえずオブジェクトにマッピングする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> MemberDto(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Member&lt;/span>.id].&lt;span style="color:#66d9ef">value&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Member&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailingAddress = listOf(&lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Mailing&lt;/span>.address])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.reduce { acc, memberDto &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オブジェクトを一つに集約させる（mailingAddressは累計）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> acc.copy(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailingAddress = acc.mailingAddress + memberDto.mailingAddress
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このやり方で考えられる問題は、まず行数分のオブジェクトのインスタンスが作られるということです。このクエリとして取得しようとしているMemberのレコードは一つのみですが、そのレコードに紐づくMailingのレコードが多ければ多いほど件数は増え、当然生成されるオブジェクトの数も多くなります。また、マッピングだけでなく、&lt;code>reduce&lt;/code>でもオブジェクトをコピーしているので、やはり行数分のオブジェクトが生成されていると考えられます。オブジェクトのインスタンス数は行数x2になる訳ですね。&lt;/p>
&lt;p>そしてもう一つの問題は、Memberのレコードを複数取得する場合、全部一つのオブジェクトにまとまってしまうという問題がありますね。なので、このやり方だと一つのレコードを取得する場合のみしか適応できなくなります。&lt;/p>
&lt;h3 id="groupby">groupBy
&lt;/h3>&lt;p>取得したレコードを、一度Mapに変換するとどうでしょうか。KotlinのCollectionには&lt;code>groupBy&lt;/code>というメソッドがあり、keyとvalueのマッピング方法を指定すると、一つのkeyに&lt;code>List&lt;/code>形式のvalueになります。Mapなので、keyでMemberのオブジェクトをマッピングしておいて、valueとしてはMailingのレコードをまとめておくと良いでしょう。keyは同じものだと上書きされるので、取得したいMemberのレコードが複数の場合でも問題ないはずです。コードでは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Member&lt;/span>.leftJoin(Mailing)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .select { (&lt;span style="color:#a6e22e">Member&lt;/span>.id eq id) and (&lt;span style="color:#a6e22e">Mailing&lt;/span>.memberId eq &lt;span style="color:#a6e22e">Member&lt;/span>.id) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// keyはMemberオブジェクトのマッピング、valueではMailingのレコードを集約
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .groupBy({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemberDto(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Member&lt;/span>.id].&lt;span style="color:#66d9ef">value&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Member&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, { &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Mailing&lt;/span>.address] })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// keyのオブジェクトにMailingのレコードを設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .map { (key, &lt;span style="color:#66d9ef">value&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key.copy(mailingAddress = &lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この方法だと、今まで照会した他の方法で考えられる問題をだいぶ解消できそうな気がしますね。ただ、気になるのは、&lt;code>groupBy&lt;/code>の引数がLambdaであることです。引数として関数を渡すということは、ループしながらその関数を実行することになるという意味なので、&lt;code>reduce&lt;/code>の時と同じ量のインスタンスが作られる可能性がありそうですね。なので、&lt;code>groupBy&lt;/code>の実装を見ていきたいと思います。中のコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">K&lt;/span>, &lt;span style="color:#a6e22e">V&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Iterable&lt;/span>&amp;lt;T&amp;gt;.groupBy(keySelector: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> K, valueTransform: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> V): Map&amp;lt;K, List&amp;lt;V&amp;gt;&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> groupByTo(LinkedHashMap&amp;lt;K, MutableList&amp;lt;V&amp;gt;&amp;gt;(), keySelector, valueTransform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>groupBy&lt;/code>の実装では、&lt;code>groupByTo&lt;/code>という関数に自分の引数と、作られるMapのインスタンスを渡しているだけですね。では、さらに&lt;code>groupByTo&lt;/code>の中身を見ていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">K&lt;/span>, &lt;span style="color:#a6e22e">V&lt;/span>, &lt;span style="color:#a6e22e">M&lt;/span> : &lt;span style="color:#a6e22e">MutableMap&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">K&lt;/span>, &lt;span style="color:#a6e22e">MutableList&lt;/span>&amp;lt;&lt;span style="color:#a6e22e">V&lt;/span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#a6e22e">Iterable&lt;/span>&amp;lt;T&amp;gt;.groupByTo(destination: M, keySelector: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> K, valueTransform: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> V): M {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (element &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> key = keySelector(element)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> list = destination.getOrPut(key) { ArrayList&amp;lt;V&amp;gt;() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list.add(valueTransform(element))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで確かになっていることは、やはり最初のCollectionの要素数分、&lt;code>keySelector&lt;/code>と&lt;code>valueTransform&lt;/code>を実行しているということです。Mapに変えることになるので、&lt;code>reduce&lt;/code>の時とは違ってMemberレコードがいくつあっても一つに集約されるような事態は起こらないと考えられますが、依然としてオブジェクトのインスタンスが複数できてしまうという問題はあります。なので、また他の方法を探してみましょう。&lt;/p>
&lt;h3 id="map">Map
&lt;/h3>&lt;p>最後に考えられるのは、Selectした行をMapにまとめるのではなく、外部にMapを宣言し、それを利用することです。Mapには、&lt;code>compute&lt;/code>という関数があり、引数として渡したkeyに対してどんな処理をするか（どんなvalueを作って入れるか）を指定できます。例えば、指定したkeyに対してvalueが存在しない場合は要素として追加し、存在する場合はそのvalueを変えるなどの処理ができるようになります。なので、これをうまく使うとインスタンスの生成問題を解決できる気がしますね。&lt;/p>
&lt;p>トランザクションとは関係のないMapをまず宣言し、Selectしたデータに対して&lt;code>compute&lt;/code>を実行することにします。&lt;code>compute&lt;/code>では指定したkey（Memberのidなど）がMapの中にない場合にMemberのインスタンスを作成するようにして、すでにある場合はそのオブジェクトにMailingのデータを追加するようにすれば良いでしょう。そしてループが終わったらMapのvalueのみを取得すると良いですね。&lt;/p>
&lt;p>以上のことを、コードで表すと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// オブジェクトをまとめるためのMap（keyはMember.id）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> helperMap = mutableMapOf&amp;lt;Int, MemberDto&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Member&lt;/span>.leftJoin(Mailing)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .select {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#a6e22e">Member&lt;/span>.id eq id) and (&lt;span style="color:#a6e22e">Mailing&lt;/span>.memberId eq &lt;span style="color:#a6e22e">Mailing&lt;/span>.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> helperMap.compute(&lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Member&lt;/span>.id].&lt;span style="color:#66d9ef">value&lt;/span>) { key, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// valueがnullではない場合、コピーしてmailingAddressを累計
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>&lt;span style="color:#f92672">?.&lt;/span>copy(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailingAddress = &lt;span style="color:#66d9ef">value&lt;/span>.mailingAddress + &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Mailing&lt;/span>.address]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// valueがnullの場合はインスタンスを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ) &lt;span style="color:#f92672">?:&lt;/span> MemberDto(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = key,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Member&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailingAddress = listOf(&lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">Mailing&lt;/span>.address])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// valueをListに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> helperMap.map { &lt;span style="color:#66d9ef">it&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>いかがでしょうか。これで重複するデータなく、インスタンスの作成も最低限に抑えることができたかと思います。もちろん、mailingAddressを追加するたびにコピーが発生するという問題はありますが、ここは専用のsetterなどを作っておくことで回避できると思います。&lt;/p>
&lt;p>一つ注意しなくてはならないのは、ここで使っているMapをフィールドとして宣言したりするとデータの整合性やアプリケーションのメモリ使用量に響くということです。なので必ずメソッドの中でのみMapのインスタンスが作成されるようにする必要があります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>DSLを使ってクエリを直接作成する場合、JPAのようなORMの問題とされているN+1(必ず連関しているテーブルもjoinしてくる)のような問題を回避できますが、直接オブジェクトへのマッピングも書かなくてはならないという短所がありますね。個人的にクエリを書くのは楽しくないですが、クエリをコードとして管理でき、必要なクエリだけを書けるというところでDSLの方が良い点もあると思います。テーブルの構造や処理によってはORMが勝手にクエリもマッピングもしてくれるのが楽ではありますが。&lt;/p>
&lt;p>ただ、ORMでどうやってデータを取得するかの問題だけでなく、ここで扱った「重複するデータをどう違う形のデータに加工するか」の問題は、必ずしもDBからレコードを取得する場合のみのことに限らないので（例えば他のAPIを読んだ結果としてもそんなデータはあり得ますね）、色々方法を考えておく必要はありそうです。今の時点ではMapを利用した方法がもっとも良さそうな気がしますが、他にもっと効率的な方法があるかもしれませんしね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Ktorを触ってみた</title><link>https://retheviper.github.io/posts/ktor-first-impression/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ktor-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/ktor.webp" alt="Featured image of post Ktorを触ってみた" />&lt;p>サーバサイド言語としてのKotlinは普及しつつありますが、Kotlinを使う場合でもウェブフレームワークとして使われるのはやはりSpringが多いかと思います。理由としては会社ごとの事情というものもあるはずですが、一般的な理由としてはJavaエンジニアにとってKotlinは馴染みやすい物であっても、フレームワークの場合はそうでなく、Springほど検証されたフレームワークはないからということからでしょう。いまだにStrutsを使っていて、Springに移行しようとするところもありますしね。&lt;/p>
&lt;p>KotlinはJavaと完璧（に近い）互換性があるので、Javaで書かれてあるアプリをそのままKotlinに移行しても大した問題はありません。Javaより生産性が高い上にSpringだけでなくJackson、Apache POI、JUnit、Jacocoなどの数多くのライブラリをそのまま使えるのは確かにメリットであって、企業側としてKotlinの導入を検討する理由は確かにそこにあると思います。Javaエンジニアはその数が多いので、エンジニアを募集し安くなるというところもメリットの一つと言えるでしょう。&lt;/p>
&lt;p>ただ、Kotlinを使う場合に長期的にはKotlinで書かれたライブラリやフレームワークを導入することを検討した方が良いかもしれません。コンパイルした結果として生成されるByte codeがJavaと全く一緒だとしても、そもそものソースコードが違う言語なので、使う側のコード（クライアントコード）としては不便なところがあったり、Kotlinに最適化されてない場合もある可能性があるからです。また、KotlinはJVMだけでなく、ネイティブにコンパイルすることもできるので、ネイティブなアプリを作りたい場合はJavaに依存しないAPIを選ぶ必要があるでしょう。&lt;/p>
&lt;p>ということで、今回はJetBrains制のウェブフレームワーク、Ktorと、Ktorと一緒に使えるORMのExposedを少し触ってみて、Springと比べながら紹介したいと思います。&lt;/p>
&lt;h2 id="ktor">Ktor
&lt;/h2>&lt;p>Ktorは、JetBrainsで開発しているマイクロサービス向けの軽量ウェブフレームワークです。&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>公式ホームページ&lt;/a>の紹介にも色々書いてありますが、特にSpringと比べて以下の特徴があるかと思います。&lt;/p>
&lt;h3 id="軽量">軽量
&lt;/h3>&lt;p>Springも軽量とは言われているものの、起動が遅いので、実装する側としてはあまり軽量だという感覚はないです。Springで書かれたアプリケーションの起動が遅いのは、起動時にさまざまなアノテーションを読み込み、DIや設定などを完璧に終わらせているというフレームワークそのもののアーキテクチャに起因しているのではないかと思います。なのでDIされるオブジェクトをLate initにするなどで起動速度を短縮させるテクニックなどが知られていますね。&lt;/p>
&lt;p>しかし、Ktorは起動がかなり早いです。同一規模のアプリをSpringとKtorの両方で作成してベンチマークした訳ではないので正確な数値に関しては割愛しますが、体験だと数倍は早いですね。例えば、In memoryタイプのH2と基本的なCRUDを実装したSpring WebFluxアプリケーションの場合、自分のPCで起動に2.7秒ほどかかりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-07-18 15:08:25.150 INFO &lt;span style="color:#ae81ff">29047&lt;/span> --- &lt;span style="color:#f92672">[&lt;/span>main&lt;span style="color:#f92672">]&lt;/span> c.r.s.SpringWebfluxSampleApplicationKt : Started SpringWebfluxSampleApplicationKt in 2.754 seconds &lt;span style="color:#f92672">(&lt;/span>JVM running &lt;span style="color:#66d9ef">for&lt;/span> 3.088&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じ構成でKtorのアプリを実装した場合、起動には1秒もかからなかったです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-07-18 15:09:29.683 &lt;span style="color:#f92672">[&lt;/span>main&lt;span style="color:#f92672">]&lt;/span> INFO ktor.application - Application started in 0.747 seconds.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはおそらく基本的にDIをしなく、アノテーションをあまり使わない（Reflectionを使わない）構造やKtorそのものはREST APIを作成するための必要最低限の機能だけを揃っているのが理由かと思われます。&lt;/p>
&lt;p>アプリの起動が早いというのは、テストにかかる時間を短縮させられるという面でもメリットといえますが、サーバレスなアプリにも適しているということにもなるでしょう。私もAWSのLambdaやAzureのFunctionsなどを触った経験がありますが、この場合にJavaやKotlinの使用を考慮したことはありません。サーバレスの場合、アプリが常に稼働中ではないので、リクエストが発生したたびにアプリを起動しなければならないです。なので起動の遅いSpringはそもそもの考慮対象にならなかったですね。Ktorを使う場合は起動速度が大幅に短縮できるので、JVMの起動速度が許されるというならば、サーバレスアーキテクチャで導入を検討できるレベルになっていると思います。&lt;/p>
&lt;h3 id="拡張可能">拡張可能
&lt;/h3>&lt;p>Ktorが軽量であることとも繋がる話ですが、必要な機能があればプラグイン（モジュール）を追加したり、自分で実装する必要はあります。コードとしては、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> embeddedServer(Netty, port = &lt;span style="color:#ae81ff">8080&lt;/span>, host = &lt;span style="color:#e6db74">&amp;#34;127.0.0.1&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(CORS)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(Compression)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(Sessions) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cookie&amp;lt;MyCookie&amp;gt;(&lt;span style="color:#e6db74">&amp;#34;MY_COOKIE&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> install(ContentNegotiation) { &lt;span style="color:#75715e">// kotlinx.serialization
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> json()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.start(wait = &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、Ktorの導入直後はモジュールの管理や開発のスピード感という側面ではマイナスになる部分もあるかなと思います。特にまだSpring Securityでは基本的に提供している&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%AD%E3%83%BC%E3%83%AB%E3%83%99%E3%83%BC%E3%82%B9%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E5%88%B6%E5%BE%A1" target="_blank" rel="noopener"
>Role-Based Authorization&lt;/a>などの機能が公式プラグインとして提供されてないので自前の処理を書くしかないという部分もあります。個人的には、モジュール化そのものは慣れたらメリットになる可能性の方が高いと思いますが、導入初期としてはSpringに比べ不利なところなのではないかと思います。&lt;/p>
&lt;p>特にKtorはDIに対応していなく、JetBrains公式のモジュールもないので、DIをするためには&lt;a class="link" href="https://github.com/IVIanuu/injekt" target="_blank" rel="noopener"
>Injekt&lt;/a>, &lt;a class="link" href="https://kodein.org/Kodein-DI/?6.3/ktor" target="_blank" rel="noopener"
>Kodein&lt;/a>, &lt;a class="link" href="https://insert-koin.io" target="_blank" rel="noopener"
>Koin&lt;/a>などをディペンデンシーとして追加する必要があります。ただ、アーキテクチャによってはDIが必要なく、&lt;code>object&lt;/code>で代替することもできると思いますので、どんなアーキテクチャにするかはよく考えて決める必要があるかなと思います。&lt;/p>
&lt;h3 id="coroutine対応">Coroutine対応
&lt;/h3>&lt;p>Spring WebFluxもそうでしたが、最近は多くのウェブフレームワークに非同期・ノンブロッキング対応が行われていますね。PaaSが普及され簡単にインフラの構築ができ、ハードウェアが安くなった今でもソフトウェアで性能を改善できる箇所があるならそれは十分価値があると思っています。だとすると、非同期・ノンブロッキング対応のフレームワークを導入するということも良い選択ではないかと思います。&lt;/p>
&lt;p>Ktorではルーティングの実装として、&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/-route/index.html" target="_blank" rel="noopener"
>Route&lt;/a>の&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/route.html" target="_blank" rel="noopener"
>route&lt;/a>、もしくは&lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/get.html" target="_blank" rel="noopener"
>get&lt;/a>, &lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/post.html" target="_blank" rel="noopener"
>post&lt;/a>, &lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/put.html" target="_blank" rel="noopener"
>put&lt;/a>, &lt;a class="link" href="https://api.ktor.io/ktor-server/ktor-server-core/ktor-server-core/io.ktor.routing/delete.html" target="_blank" rel="noopener"
>delete&lt;/a>などのfunctionを呼び出すことになります。これはSpring WebFluxのRouter/Hanlder Functionとよく似ていますね。コードで表すと、以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/hello&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respondText(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてこのHttpメソッドごとの関数のbodyを実装することになりますが、これが基本的に&lt;code>suspend&lt;/code>となっています。これはつまり、実装する側で特に意識しなくてもコードは非同期になるということですね。Spring WebFluxの場合も、Coroutineを使うと簡単に実装ができましたが、&lt;code>suspend&lt;/code>すら意識しなくて良いというところはKtorならではのメリットなのではという気がします。&lt;/p>
&lt;h3 id="テスト">テスト
&lt;/h3>&lt;p>&lt;code>ktor-server-test-host&lt;/code>や&lt;code>kotlin-test&lt;/code>、JUnitなどを使ってテストが可能です。Springでもユニットテストは色々な書き方があるかと思いますが、よりKotlinらしき書き方になっているだけで、基本的にテストの仕方が大きく変わったりはしません。例えば、&lt;code>Get&lt;/code>をのレスポンスをテストするためには以下のようなコードを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withTestApplication(Application&lt;span style="color:#f92672">::&lt;/span>module) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handleRequest(&lt;span style="color:#a6e22e">HttpMethod&lt;/span>.Get, &lt;span style="color:#e6db74">&amp;#34;api/v1/web/members/&lt;/span>&lt;span style="color:#e6db74">$id&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assertEquals(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">actual&lt;/span> = response.status(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expected = &lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assertEquals(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">actual&lt;/span> = response.content,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expected = &lt;span style="color:#a6e22e">Json&lt;/span>.encodeToString(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemberResponse(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userId = userId,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exposed">Exposed
&lt;/h2>&lt;p>Ktorで使える、Kotlinで書かれたORMは代表的に&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>があります。Javaの&lt;a class="link" href="https://www.jooq.org" target="_blank" rel="noopener"
>jOOQ&lt;/a>がそうであったように、SQL DSLを使うことでクエリをコードで書くような感覚で（実施はDSLを解釈してSQLは自動生成されますが）使えるというところが良いです。例えば、Userというテーブルからレコードを取得する場合のコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> userInUsa: List&amp;lt;User&amp;gt; = transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UserTable&lt;/span>.select {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UserTable&lt;/span>.deleted eq &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">UserTable&lt;/span>.id],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">UserTable&lt;/span>.name],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> country = &lt;span style="color:#66d9ef">it&lt;/span>[&lt;span style="color:#a6e22e">UserTable&lt;/span>.country]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.filter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.country = &lt;span style="color:#a6e22e">Country&lt;/span>.USA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、ExposedでははDAOパターンも使えるので、DAOパターンでクエリを書くとしたら以下のようなことができます。JPAやR2DBCと似たような感覚で使えそうですね。(デメリットもおそらく同じかと思いますが)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> userInGermany: List&amp;lt;User&amp;gt; = transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">User&lt;/span>.find { (&lt;span style="color:#a6e22e">UserTable&lt;/span>.country eq &lt;span style="color:#a6e22e">Country&lt;/span>.GERMANY) and (&lt;span style="color:#a6e22e">UserTable&lt;/span>.deleted eq &lt;span style="color:#66d9ef">false&lt;/span>)}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、Exposedの特徴は、テーブルをコードとして定義することでDBに反映させることができるということです。今まで&lt;a class="link" href="https://www.liquibase.org" target="_blank" rel="noopener"
>Liquibase&lt;/a>や&lt;a class="link" href="https://flywaydb.org" target="_blank" rel="noopener"
>Flyway&lt;/a>でDBの形状管理をやっていたことが多かったのですが、個人的に実際のDBとアプリケーションのテーブル定義に乖離があるケースを考えるとこうやってコードの中に定義した方が、データのオーナーという観点からもかなり良いのではないかと思います。特に、頻繁なテーブル定義の修正があったり、マイクロサービスが多いケースではかなり開発が便利になるのではないかと思います。&lt;/p>
&lt;p>Exposedのテーブル定義は、以下のようにできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">Member&lt;/span> : IntIdTable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> userId: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;user_id&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> password: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;password&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">255&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> deleted: Column&amp;lt;Boolean&amp;gt; = bool(&lt;span style="color:#e6db74">&amp;#34;deleted&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> createdBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#e6db74">&amp;#34;created_by&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> createdDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#e6db74">&amp;#34;created_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastModifiedBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#e6db74">&amp;#34;last_modified_by&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastModifiedDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#e6db74">&amp;#34;last_modified_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして実際発行されるSQLは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> &lt;span style="color:#e6db74">&amp;#34;MEMBER&amp;#34;&lt;/span> (ID INT AUTO_INCREMENT &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span>, DELETED BOOLEAN &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, CREATED_BY VARCHAR(&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, CREATED_DATE DATETIME(&lt;span style="color:#ae81ff">9&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, LAST_MODIFIED_BY VARCHAR(&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, LAST_MODIFIED_DATE DATETIME(&lt;span style="color:#ae81ff">9&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, USER_ID VARCHAR(&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;NAME&amp;#34;&lt;/span> VARCHAR(&lt;span style="color:#ae81ff">16&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>, PASSWORD VARCHAR(&lt;span style="color:#ae81ff">255&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで、JPAやR2DBCの場合、Auditableクラスを定義して、エンティティがそれを継承することでカラムを共有したり、Spring Securityに連携することができましたが、Exposedでも似たようなことができました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Audit&lt;/span> : IntIdTable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> deleted: Column&amp;lt;Boolean&amp;gt; = bool(&lt;span style="color:#e6db74">&amp;#34;deleted&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> createdBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#e6db74">&amp;#34;created_by&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> createdDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#e6db74">&amp;#34;created_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastModifiedBy: Column&amp;lt;String&amp;gt; = varchar(&lt;span style="color:#e6db74">&amp;#34;last_modified_by&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastModifiedDate: Column&amp;lt;LocalDateTime&amp;gt; = datetime(&lt;span style="color:#e6db74">&amp;#34;last_modified_date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">Member&lt;/span> : Audit() { &lt;span style="color:#75715e">// Auditのカラムも含めてテーブルが作成される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> userId: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;user_id&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> password: Column&amp;lt;String&amp;gt; = varchar(name = &lt;span style="color:#e6db74">&amp;#34;password&amp;#34;&lt;/span>, length = &lt;span style="color:#ae81ff">255&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MyBatisなどに慣れている場合は少し適応に時間が必要かもしれませんが、基本的にはテーブルの定義を除くとほぼSQLの発行をKotlinのコードで書くことになるという感覚なので、便利になるかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>以上で、簡単なCRUDアプリをKtor + Exposedで実装してみた後の感想と紹介を少し書いてみました。まとめると、かなりサクサクコードを書けて性能も良いので、マイクロサービスに特化している構成ではないかと思いました。また、冒頭に述べた通り、ピュアなKotlin制のフレームワークであることも良いですね。Ktorの紹介でもKotlin Multiplatformに基づいていてどのプラットフォームにもアプリをデプロイできると強調していますので、色々なところで活用ができるかと思います。&lt;/p>
&lt;p>まだSpringと他のJavaライブラリに比べ足りないモジュールや機能もありますが、Exposed以外でも&lt;a class="link" href="https://www.ktorm.org" target="_blank" rel="noopener"
>Ktorm&lt;/a>のようなORMがあるなどKotlin制のライブラリの開発も進めていて、IntellijでもKtorのサポートは強力なので今後も発展を期待できそうであります。個人的にまだ仕事で使うことには無理があっても、自作アプリなどを作りたい時は導入をぜひ検討したいと思いました。Kotlinでできることがだんだん増えてきていて、嬉しいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その二〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-2/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-2/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinで書いてみた〜その二〜" />&lt;p>&lt;a class="link" href="../kotlin-code-in-my-style-1" >前回&lt;/a>に続いて、今回も簡単にKotlinで色々書いてみましたのでその紹介となります。Kotlinではスタンダードライブラリや言語仕様として提供している機能がかなり多いので、これらを使いこなすだけでも生産性やコードのクォリティが大幅に上がるのではないかと思います。なので、今回もJava的な書き方を、Kotlinではどんな方法で効率よく実現できるかを中心に紹介したいと思います。&lt;/p>
&lt;p>もちろんKotlinでは基本的にJavaの書き方でも全く問題なく動くコードを書けますが、Kotlinならではのコードに変えた方がより簡単で短いコードを書ける場合が多く、色々と手間を省けることができるので（そして大抵の場合、スタンダードライブラリの実装の方が自分の書いたコードよりクォリティ高いような…）こういう工夫はする価値が十分にあるのではないかと思います。&lt;/p>
&lt;p>なので、今回は自分が調べたKotlinの小技を少し紹介したいと思います。&lt;/p>
&lt;h2 id="sequentialなデータを作成する">Sequentialなデータを作成する
&lt;/h2>&lt;p>よくユニットテストなどでテスト用データを作成して使う場合がありますね。こういう時に必要となるデータの種類は色々とあるかと思いますが、複数のレコードを番号をつけて順番に揃えた感じのものを作りたい場合もあると思います。例えばData01、Data02、Data03…といったデータを作りたい場合ですね。&lt;/p>
&lt;p>この場合は、ループでデータを作り、Listにまとめるというのが一般的ではないかと思います。例えば以下のような例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// テスト用データを作成する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createTestDatas&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テスト用データのリスト
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> testDatas = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 10件のデータを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> until &lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testDatas.add(&lt;span style="color:#e6db74">&amp;#34;テスト&lt;/span>&lt;span style="color:#e6db74">$i&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// read-onlyに変換して返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> testDatas.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、どちらかというとこれはJavaのやり方に近いので、まずはこれをベースに、Kotlinらしきコードではどうやって同じことができるかを考えてみたいと思います。&lt;/p>
&lt;h3 id="repeat">repeat
&lt;/h3>&lt;p>まず考えられる方法は、ループの単純化ですね。サイズが10のリストを作りたいということは、ループが10回であることなので、それに相応しい関数を使います。例えば&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html" target="_blank" rel="noopener"
>repeat&lt;/a>がありますね。&lt;code>repeat&lt;/code>を使うと、スコープ内のパラメータとしてインデックスが渡されるので、簡単に&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createTestDatas&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> testDatas = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 10回繰り返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> repeat(&lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testDatas.add(&lt;span style="color:#e6db74">&amp;#34;テスト&lt;/span>&lt;span style="color:#e6db74">$i&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> testDatas.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に考えたいのは、&lt;code>MutableList&lt;/code>を&lt;code>Immutable&lt;/code>に変えることです。テストで使うデータとしては問題ない場合はありますが、変更する必要のないデータをそのまま&lt;code>Mutable&lt;/code>にしておくのはあまり良い選択ではありませんね。なので、データの作成を最初から&lt;code>List&lt;/code>にできる方法を取りたいものです。&lt;/p>
&lt;p>ここでは二つの道があって、最初からサイズを指定した&lt;code>List&lt;/code>を宣言するか、ループの範囲、つまり&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html#range" target="_blank" rel="noopener"
>Range&lt;/a>を指定する方法があります。&lt;/p>
&lt;h3 id="list">List
&lt;/h3>&lt;p>まずはサイズを指定した&lt;code>List&lt;/code>を作る方法からみていきましょう。インスタンスの作成時に、サイズと要素に対してのイニシャライザを引数として渡すことで簡単に指定したサイズ分の要素を作ることができます。例えば、上で紹介したコードは&lt;code>List&lt;/code>を使うことで以下のように変えることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createTestDatasByList&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(&lt;span style="color:#ae81ff">10&lt;/span>) { &lt;span style="color:#e6db74">&amp;#34;テスト&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この方法は、実は先に紹介した方法と根本的に違うものではありません。実装としては、以下のようになっているので、Syntax sugarとして使えるということがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SinceKotlin&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1.1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@kotlin&lt;/span>.&lt;span style="color:#66d9ef">internal&lt;/span>.InlineOnly
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>(size: Int, &lt;span style="color:#66d9ef">init&lt;/span>: (index: Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): List&amp;lt;T&amp;gt; = MutableList(size, &lt;span style="color:#66d9ef">init&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SinceKotlin&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1.1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@kotlin&lt;/span>.&lt;span style="color:#66d9ef">internal&lt;/span>.InlineOnly
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">MutableList&lt;/span>(size: Int, &lt;span style="color:#66d9ef">init&lt;/span>: (index: Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> list = ArrayList&amp;lt;T&amp;gt;(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(size) { index &lt;span style="color:#f92672">-&amp;gt;&lt;/span> list.add(&lt;span style="color:#66d9ef">init&lt;/span>(index)) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも&lt;code>List&lt;/code>を使う場合は、&lt;code>itnit&lt;/code>としてどんな関数を渡すかによって、&lt;code>step&lt;/code>の設定などができるのも便利ですね。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#ae81ff">5&lt;/span>) { &lt;span style="color:#e6db74">&amp;#34;Test&lt;/span>&lt;span style="color:#e6db74">${ it * 2 }&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [Test0, Test2, Test4, Test6, Test8]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#ae81ff">5&lt;/span>) { (&lt;span style="color:#66d9ef">it&lt;/span> * &lt;span style="color:#ae81ff">2&lt;/span>).let { index &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$index&lt;/span>&lt;span style="color:#e6db74"> は偶数&amp;#34;&lt;/span> } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [0 は偶数, 2 は偶数, 4 は偶数, 6 は偶数, 8 は偶数]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、結果的に作られる&lt;code>List&lt;/code>のインスタンスは&lt;code>MutableList&lt;/code>なので、生成したデータをread-onlyにしたい場合はまたこれを&lt;code>toList()&lt;/code>などで変換する必要があるという問題があります。&lt;/p>
&lt;h3 id="range">Range
&lt;/h3>&lt;p>では、もう一つの方法をまた試してみましょう。Kotlinでは数字の範囲を指定することだけで簡単に&lt;code>Range&lt;/code>オブジェクトを作成することができます。&lt;code>Range&lt;/code>を使う場合、上記のコードは以下のように変えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Rangeを使ってテストデータを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createTestDatasByRange&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ae81ff">0.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>).map { &lt;span style="color:#e6db74">&amp;#34;テスト%it&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>List&lt;/code>の時とは違って、&lt;code>Range&lt;/code>には&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-int-range" target="_blank" rel="noopener"
>IntRange&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-long-range" target="_blank" rel="noopener"
>LongRange&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-char-range" target="_blank" rel="noopener"
>CharRange&lt;/a>などがあり、引数の数字や文字を調整することで簡単にアレンジができるということも良いです。&lt;/p>
&lt;p>また、一般的に性能は&lt;code>List&lt;/code>より&lt;code>Range&lt;/code>の方が良いようです。以下のようなコードでベンチマークした際、大抵&lt;code>Range&lt;/code>の方が&lt;code>List&lt;/code>の倍ぐらい早いのを確認できました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> kotlin.system.measureTimeMillis
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> name: String, &lt;span style="color:#66d9ef">val&lt;/span> Num: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark { list() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark { range() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">benchmark&lt;/span>(function: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(measureTimeMillis { function() })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">list&lt;/span>() =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(&lt;span style="color:#ae81ff">200000&lt;/span>) { Person(&lt;span style="color:#e6db74">&amp;#34;person&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">range&lt;/span>(): List&amp;lt;Person&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ae81ff">0.&lt;/span>.&lt;span style="color:#ae81ff">200000&lt;/span>).map { Person(&lt;span style="color:#e6db74">&amp;#34;person&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一つ気にしなくてはならないのは、&lt;code>Range&lt;/code>の場合は基本的に値が1づつ増加することになっているので、&lt;code>for&lt;/code>や&lt;code>List&lt;/code>のような&lt;code>step&lt;/code>の条件が使えません。なので場合によってどちらを使うかは考える必要があります。&lt;/p>
&lt;h2 id="check">Check
&lt;/h2>&lt;p>Validationなどで、パラメータの値を確認しなければならない場合があります。Kotlinでは&lt;code>Nullable&lt;/code>オブジェクトとそうでないオブジェクトが分けられているので、Javaと違って引数に&lt;code>null&lt;/code>が渡される場合はコンパイルエラーとなりますが、ビジネスロジックによってはそれ以外のことをチェックする必要もあり、自前のチェックをコードで書くしかないです。&lt;/p>
&lt;p>まず、お馴染みのJavaのやり方を踏襲してみると、以下のようなコードを書くことができるでしょう。関数の引数と、その戻り値のチェックが含まれている例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: String): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (parameter.isBlank()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;文字列が空です&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = someRepository.find(parameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;結果がnullです&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで少し違う言語の例をみていきたいと思います。Kotlinとよく似ていると言われているSwiftの場合、ここで&lt;a class="link" href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#grammar_if-statement" target="_blank" rel="noopener"
>Guard Statement&lt;/a>を使うのが一般的のようです。チェックのための表現が存在することで、ビジネスロジックとチェックが分離されるのが良いですね。Swiftをあまり触ったことがないので良い例にはなっていないかもしれませんが、イメージ的には以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: String) &lt;span style="color:#66d9ef">throws&lt;/span> -&amp;gt; String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#f92672">!&lt;/span>parameter.isEmpty &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ValidationError.invalidArgument
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> result = someRepository.find(parameter) &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ValidationError.notFound
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じく、Kotlinでもチェックのための表現とビジネスロジックが分離できれば、コードの意味がより明確になるはずです。Kotlinではどうやってそれを実現できるのでしょうか。例えば以下のようなことを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: String?): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> checkedParameter = requireNotNull(parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;文字列がnullです&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = someRepository.find(checkedParameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> checkNotNull(result) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;結果がnullです&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require-not-null.html" target="_blank" rel="noopener"
>requireNotNull&lt;/a>は、渡された引数が&lt;code>null&lt;/code>である場合は&lt;code>IllegalArgumentException&lt;/code>を投げ、そうでない場合は引数を&lt;code>non-null&lt;/code>タイプとして返します、明確に&lt;code>null&lt;/code>チェックをしていることが解るだけでなく、以降チェックがいらないので便利です。また、&lt;code>lazy message&lt;/code>として&lt;code>IllegalArgumentException&lt;/code>が発生した時のメッセージを指定できるのも良いですね。&lt;/p>
&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html" target="_blank" rel="noopener"
>checkNotNull&lt;/a>の場合も機能的には&lt;code>requireNotNull&lt;/code>と変わらないですが、&lt;code>null&lt;/code>の場合に投げる例外が&lt;code>IllegalStateException&lt;/code>となります。なので、用途に合わせてこの二つを分けて使えますね。&lt;/p>
&lt;p>他に使えるものとしては&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html" target="_blank" rel="noopener"
>require&lt;/a>があります。こちらは条件式を渡すことで、&lt;code>null&lt;/code>チェック以外のこともできます。なので、以下のコードのように、&lt;code>Int&lt;/code>型のデータに対して範囲をチェックするということもできるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> require(parameter &amp;gt; &lt;span style="color:#ae81ff">100&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$parameterは大きすぎます&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、&lt;a class="link" href="https://kotlinlang.org/docs/null-safety.html#elvis-operator" target="_blank" rel="noopener"
>Elvis operator&lt;/a>を使う方法もありますね。この場合は、&lt;code>null&lt;/code>の場合にただ例外を投げるだけでなく、代替となる処理を書くことができますので色々と活用できる余地があります。例えば以下のようなことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: String?): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> checkedParameter = parameter &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = someRepository.find(checkedParameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> CustomException(&lt;span style="color:#e6db74">&amp;#34;結果がnullです&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="listの分割">Listの分割
&lt;/h2>&lt;p>とある条件と一致するデータをListから抽出したい場合は、&lt;code>filter&lt;/code>のようなoperationを使うことでできます。しかし、条件が二つだとどうすればいいでしょうか。正確には、一つのリストに対して、指定した条件に一致する要素とそうでない要素の二つのリストに分離したい場合です。&lt;/p>
&lt;p>こういう場合はとりあえず下記のように2回ループさせる方法があると思いますが、これはあまり効率がよくないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> origin = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 奇数を抽出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> odd = origin.filter { &lt;span style="color:#66d9ef">it&lt;/span> % &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 偶数を抽出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> even = origin.filter { &lt;span style="color:#66d9ef">it&lt;/span> % &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ループを減らすためには、あらかじめ宣言したリストに対してループの中で分岐処理を行うという方法があるでしょう。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> origin = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 奇数と偶数のリストを宣言しておく
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> odd = mutableListOf&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> even = mutableListOf&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ループ処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>origin.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span> % &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd.add(&lt;span style="color:#66d9ef">it&lt;/span>) &lt;span style="color:#75715e">// 奇数のリストに追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even.add(&lt;span style="color:#66d9ef">it&lt;/span>) &lt;span style="color:#75715e">// 偶数のリストに追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>幸い、この状況にぴったりな方法をKotlinのスタンダードライブラリが提供しています。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html" target="_blank" rel="noopener"
>partition&lt;/a>というoperationです。このopreationを使うと、元のリストの要素を条件に一致するものとそうでないもので分割してくれます。&lt;/p>
&lt;p>また、&lt;code>partition&lt;/code>戻り値は&lt;code>Pair&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;/code>なので、&lt;a class="link" href="https://kotlinlang.org/docs/destructuring-declarations.html" target="_blank" rel="noopener"
>destructuring-declaration&lt;/a>と組み合わせることでかなり短いコードになります。実際のコードは以下のようになるりますが、かなりスマートですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> origin = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>odd, even) = origin.partition { &lt;span style="color:#66d9ef">it&lt;/span> % &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> } &lt;span style="color:#75715e">// 条件に一致するものと一致しないものでリストを分離
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>Kotlinは便利ではありますが、言語自体が提供する便利さ（機能）が多いゆえに、APIの使い方を正しく活用できるかどうかでコードのクォリティが左右される部分が他の言語と比べ多いような気がしています。さらにバージョンアップも早く、次々と機能が追加されるのでキャッチアップも大事ですね。&lt;/p>
&lt;p>でも確かに一つづつKotlinでできることを工夫するうちに、色々とできることが増えていく気もしていますね。研究すればするほど力になる言語を使うということは嬉しいことです。ということで、これからもKotlinで書いてみたシリーズは続きます。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Sequenceは常にいいか</title><link>https://retheviper.github.io/posts/kotlin-collection-and-sequence/</link><pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-collection-and-sequence/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Sequenceは常にいいか" />&lt;p>とある処理を書く方法が色々ある場合は、どれを選んだ方がもっとも良いかと悩ましくなります。こういう場合は、コードの読みやすさやコードの長さ、予想される問題のようなさまざまな観点からそれぞれの方式を比較してどれを選ぶか判断することになりますね。ただ、このような観点から判断するのは多くの場合「書き方が全く違う」場合に有効であって、そもそも似たようなコードを書くことになる場合は他の観点からも考える必要があります。ほんの少しだけ違うから、見た目だけでは違いがわからない場合。こういう時はそのAPIの内部、メカニズムからちゃんと考えて選ぶ必要がありますね。&lt;/p>
&lt;p>そういう意味で、今回はKotlinのCollectionの処理に使える方法の二つ、「Collectionのoperation直接使う」場合と「Sequenceに変換してから処理する」場合の違いに関して述べたいと思います。&lt;/p>
&lt;h2 id="処理方式の違い">処理方式の違い
&lt;/h2>&lt;p>Javaでは、Collectionの要素を持って処理をする方法は色々とありますが、大きく分けて1.8以前の方法(&lt;code>for&lt;/code>や&lt;code>while&lt;/code>などを利用したループ)と1.8以降の方法(&lt;code>Stream&lt;/code>を使った方法)があると言ってもいいのではないかと思います。この二つの方法はそもそもベースとなっているパラダイムそのものが違うので、コードを書くスタイルから大きく違います。例えば同じ処理をしたい場合でも、以下のコードで確認できるように、見た目が完全に違います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// forループの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterEven&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Integer i : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(i.&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> 3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Streamを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterEvenStream&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i.&lt;span style="color:#a6e22e">toString&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">limit&lt;/span>(3)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Streamを使った処理の場合はoperationを積み重ねて行く形をしていますが、これは現代の関数型プログラミングに対応している言語ならどれも持っているAPIといえます。例えばKotlin, 公式的には呼び方が色々あるようですが、一部では&lt;code>Functional function&lt;/code>という名で呼ばれているようで、今回はこの操作方式、Functional functionについて述べたいと思います。&lt;/p>
&lt;p>KotlinではCollectionでもこのようなopreationがあり、Kotlin版のStreamとも言える&lt;a class="link" href="https://kotlinlang.org/docs/sequences.html" target="_blank" rel="noopener"
>Sequence&lt;/a>でも同様の操作できるようになっています。また、JavaのStreamをそのまま使うこともできるので、Functional functionを使った処理は三つがあるといえますね。それぞれの使い方もあまり変わりません。なので以下のようなコードで同じ処理ができますが、それが帰って悩ましくなるところでもあります。「どれを使ったらいい？」とですね。例えば同じ処理をしたい場合でも、Kotlinでは以下のように色々な方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collectionの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">filterEven&lt;/span>(): List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>).filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }.map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }.take(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Sequenceを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">filterEvenSequence&lt;/span>: List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>).asSequence().filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }.map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }.take(&lt;span style="color:#ae81ff">3&lt;/span>).toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// JavaのStream APIを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">filterEvenStream&lt;/span>(): List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>).stream().filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }.map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }.limit(&lt;span style="color:#ae81ff">3&lt;/span>).collect(&lt;span style="color:#a6e22e">Collectors&lt;/span>.toList())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは見た目ではあまり違いがわからないですね。処理やロジックが大きく変わる訳でもありません。使い方があまり変わらなく、結果としても同じようなものを期待できるとしたら、やはり次に気にすべきは「性能」ではないかと思います。特にCollectionよりもSequenceの方がより性能がいいという話もありますので、それならなるべくSequenceを使った方が絶対良いはずですね。&lt;/p>
&lt;p>しかし、それを事実と受け止めるとしたら、いくつかの疑問が残ります。常にSequenceの方が性能で有利だとしたら、なぜCollectionからFunctional functionを呼び出す時は内部でSequenceに変換するようにするのでなく、わざわざ&lt;code>asSequence()&lt;/code>を呼び出して明示的な変換をさせるのでしょうか？もしくはなぜCollectionでもFunctional functionを呼び出せるようにしているのでしょうか？これはつまり、SequenceがCollectionよりも性能がよくなるのは「とある条件下に限る」ということではないでしょうか。なので、今回は主に性能の観点から、CollectionとSequenceの違いについて述べましょう。&lt;/p>
&lt;h3 id="lazy-evaluation">Lazy evaluation
&lt;/h3>&lt;p>KotlinのSequenceは、元々JavaのStreamと同じ名前になる予定だったそうです。これはただの偶然ではなく、実際の処理もStreamに似ているからです。何が似ているかというと、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1" target="_blank" rel="noopener"
>Lazy evaluation&lt;/a>という概念です。これは簡単に言いますと、「なるべく処理を遅延させる = 必要とされるまでは処理をしない」ということですね。そして多くの場合、Sequenceを使うとこのLazy evaluationのおかげで性能がよくなるという話があります。これはつまり、Sequenceは処理を遅延することでCollectionより良い性能を期待できる、ということになるでしょう。&lt;/p>
&lt;p>しかし、単純に処理を遅延させることががなぜ性能を向上させる事になるのか、すぐに納得は行きません。まず、ループ処理の中で「必要によって処理をするかどうかを決定する」という概念がピンと来ないですね。我々が認識しているループ処理とは、対象となるデータモデルの全要素を巡回しながら処理をするという意味ですので。&lt;/p>
&lt;p>だからSequenceを使った方が性能がよくなると言っても、パフォーマンスはさまざまな要素によって劣化も向上もするものなので、その話だけを信じて全ての処理をSequenceに変えるということは危ないです。そもそもSequenceがそんなに良いものであれば、全てのIterableなオブジェクトをなぜSequenceとして処理しないか、という疑問も湧いてきますね。なので、まずはCollectionとSequenceでFunctional functionがどう違うか、コードどそれを実行した結果で説明したいと思います。&lt;/p>
&lt;h4 id="eager-evaluationのcollection">Eager evaluationのCollection
&lt;/h4>&lt;p>CollectionでのFunctional functionは、Eager evalutionと言われています。これはLazy evaluationの逆で、必要とされてなくてもとりあえず処理を行っておくということです。こうする場合期待できることは、メモリ上にすでに処理の結果が残っていて、複数回呼ばれた場合はそのキャッシュを使うことができるということですね。&lt;/p>
&lt;p>Eager evaluationだと、Functional functionが呼ばれるたび、その全要素に対しての処理をまず行うことになります。例えば、以下のような処理を書いたとしましょう。&lt;code>onEach()&lt;/code>は処理の流れを視覚化するためのものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;Found even: &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;Now &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74"> is String&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .take(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74"> has taken&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを実行した結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">2&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">4&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">6&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">8&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">10&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> has taken
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、CollectionでのFunctional functionでは以下のような順で処理します。&lt;/p>
&lt;ol>
&lt;li>Listからfilterのpredicateに当てはまる要素を探し、その結果でListを作る&lt;/li>
&lt;li>filterされたListの要素をmapし、その結果でListを作る&lt;/li>
&lt;li>mapされたListの要素からtakeする&lt;/li>
&lt;/ol>
&lt;p>これを絵で表現すると以下の通りです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing.webp"
width="990"
height="377"
srcset="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing_hu_ec94070916856771.webp 480w, https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing_hu_2ef2c57bd4002cda.webp 1024w"
loading="lazy"
alt="Kotlin List Processing"
class="gallery-image"
data-flex-grow="262"
data-flex-basis="630px"
>
&lt;em>出典：Kotlin公式ドキュメント - &lt;a class="link" href="https://kotlinlang.org/docs/sequences.html#iterable" target="_blank" rel="noopener"
>Sequences&lt;/a>&lt;/em>&lt;/p>
&lt;h5 id="collectionのopreation">Collectionのopreation
&lt;/h5>&lt;p>Collectionでの処理は上記の通りですが、実装としてはどうでしょうか。ここではCollectionでの&lt;code>map()&lt;/code>のコードを見ていきたいと思います。コードとしては以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">R&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Iterable&lt;/span>&amp;lt;T&amp;gt;.map(transform: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): List&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mapTo(ArrayList&amp;lt;R&amp;gt;(collectionSizeOrDefault(&lt;span style="color:#ae81ff">10&lt;/span>)), transform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mapTo()&lt;/code>という関数に、元のCollectionのサイズで新しくインスタンスを作成した&lt;code>ArrayList&lt;/code>とLambdaを渡しています。ちなみに&lt;code>collectionSizeOrDefault()&lt;/code>という関数は、以下のような実装となっています。Collectionである場合はそのサイズを、そうでない場合（Sequenceなど）はデフォルトとして10のサイズを持つListになるということがわかりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Iterable&lt;/span>&amp;lt;T&amp;gt;.collectionSizeOrDefault(default: Int): Int = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> Collection&amp;lt;*&amp;gt;) &lt;span style="color:#66d9ef">this&lt;/span>.size &lt;span style="color:#66d9ef">else&lt;/span> default
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>mapTo()&lt;/code>という関数の中では、元のCollectionをループしながら新しいListにLambdaの実行結果を追加するという実装となっています。実際のコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">R&lt;/span>, &lt;span style="color:#a6e22e">C&lt;/span> : &lt;span style="color:#a6e22e">MutableCollection&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#a6e22e">Iterable&lt;/span>&amp;lt;T&amp;gt;.mapTo(destination: C, transform: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): C {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (item &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destination.add(transform(item))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、一つのFunctional functionが呼ばれるたびにListに対するループが発生し、さらに新しいListを作ることになるということです。なので上記のサンプルコードの場合だとループは6回、Listの作成は4回であるといえます。&lt;code>onEach()&lt;/code>を除外するとしてもループは3回なので、かなり多い印象ですね。&lt;/p>
&lt;p>ここで考えられるものは、「Sequenceの方が性能がいい」という話は、Sequenceを使った場合にこのようなループ回数やListの作成を減らせられるということになるのではないか、ということですね。Sequenceではどんな処理をしていて、実際にこのようなループやListを作る回数などを減らしているということでしょうか。同じ処理を書いた場合にSequenceではどのようなことが起きるかを見ていきましょう。&lt;/p>
&lt;h4 id="lazy-evaluationのsequence">Lazy evaluationのSequence
&lt;/h4>&lt;p>Collectionは、&lt;code>asSequence()&lt;/code>を呼び出すことで簡単にSequenceによる処理に変換することができます。ただ、このコードを実際に走らせるためにはJavaのStreamと同じく終端処理が必要となるのがポイントです。これも「必要とされるまでは実際の処理を行わない」Lazy evaluationの特徴といえます。例えば以下のようなコードを書いたとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .asSequence() &lt;span style="color:#75715e">// Sequenceに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;Found even: &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;Now &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74"> is String&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .take(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74"> has taken&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList() &lt;span style="color:#75715e">// Collectionに再変換（終端処理で処理を走らせる）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを実行した結果は以下の通りです。Collectionの場合と結果は同じであるものの、処理の順番が変わっていることを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">2&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">4&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">6&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> has taken
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、そもそも8と10に対しての処理は行われてないということです。これはCollectionで全要素に対して一つのFunctional functionの処理が終わったあと、次のFunctional functionが実行される構造に対して、Sequenceは一つの要素に対しての全ての処理が終わったあと次の要素に対して同じ処理を繰り返しているということです。言葉で表現すると複雑ですが、以下のような順になっているということです。&lt;/p>
&lt;ol>
&lt;li>Listの要素にfilterを当てる&lt;/li>
&lt;li>要素がfilterのpredicateに当てはまるものなら次の処理に移行する&lt;/li>
&lt;li>filterされた要素をmapする&lt;/li>
&lt;li>mapされた要素をtakeする&lt;/li>
&lt;li>次の要素に対して同じ処理を繰り返す&lt;/li>
&lt;/ol>
&lt;p>これを絵で表現すると以下の通りです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing.webp"
width="990"
height="427"
srcset="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing_hu_d963addcd7927c3e.webp 480w, https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing_hu_9e5cd744ff6be128.webp 1024w"
loading="lazy"
alt="Kotlin Sequence Processing"
class="gallery-image"
data-flex-grow="231"
data-flex-basis="556px"
>
&lt;em>出典：Kotlin公式ドキュメント - &lt;a class="link" href="https://kotlinlang.org/docs/sequences.html#sequence" target="_blank" rel="noopener"
>Sequences&lt;/a>&lt;/em>&lt;/p>
&lt;p>処理の順番や仕組みが違うので、Collectionの時とは実装もかなり違うだろうと予想ができますね。では、こちらの実装を見ていきましょう。&lt;/p>
&lt;h5 id="sequenceでのoperation">Sequenceでのoperation
&lt;/h5>&lt;p>Collectionと同じく、Sequenceの&lt;code>map()&lt;/code>の実装を覗いてみましょう。先程のコードでSequenceの&lt;code>map()&lt;/code>は中間処理であり、新しいCollectionを作り出すわけではないということはわかりました。実装を見ると、以下のようになっていて、処理結果が反映されたSequenceを返しているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">R&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.map(transform: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): Sequence&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> TransformingSequence(&lt;span style="color:#66d9ef">this&lt;/span>, transform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、内部で&lt;code>TransformingSequence&lt;/code>という新しいSequenceのインスタンスを作成しているのがわかりますね。このクラスの実装は以下の通りです。ここでループごとにLambdaの実行が行われていますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TransformingSequence&lt;/span>&amp;lt;T, R&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constructor&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> sequence: Sequence&amp;lt;T&amp;gt;, &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> transformer: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R) : Sequence&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">iterator&lt;/span>(): Iterator&amp;lt;R&amp;gt; = &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">Iterator&lt;/span>&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> iterator = sequence.iterator()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>(): R {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> transformer(iterator.next())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">hasNext&lt;/span>(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> iterator.hasNext()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">E&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">flatten&lt;/span>(iterator: (R) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Iterator&amp;lt;E&amp;gt;): Sequence&amp;lt;E&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> FlatteningSequence&amp;lt;T, R, E&amp;gt;(sequence, transformer, iterator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のコードの実行結果と実装でわかるように、Sequenceを使う場合は一つの要素を単位として処理を行っていくので、CollectionでFunctional functionを使う場合に発生し得る不要な処理(毎回Listを生成する、前要素に対してmapを行うなど)を減らせると期待できます。なので元のCollectionが大きい場合やoperationが多い場合はSequenceの方がより良いように見えます。&lt;/p>
&lt;p>ただ、性能の観点で考えると、CollectionとSequenceの違いはもう一つ考慮すべきところがあります。それはデータ構造の違いです。&lt;/p>
&lt;h2 id="stateless">Stateless
&lt;/h2>&lt;p>JavaのStreamでもそうでしたが、Sequenceは状態(State)を持たないのが特徴です。ここで状態を持たないということは、持っている要素の数や順番などに対しての情報がないということを意味します。なぜかというと、SequenceがIteratorに基づいているものだからです。そしてそれが原因で、処理の種類によってCollectionよりも性能は劣る可能性もまたあります。&lt;/p>
&lt;p>先に使っていたサンプルコードを持って考えてみましょう。サンプルコードでは、Sequenceの終端処理としてListを返すために&lt;code>toList()&lt;/code>を呼び出していました。これは、「状態を持たない」ものから「状態を持つ」ものに変換することですね。簡単なやり方としては、MutableなListを作って、全要素を一つづつ&lt;code>add()&lt;/code>していく方法があるでしょう。実際はどうでしょうか？まずは&lt;code>toList()&lt;/code>のコードをみてみましょう。以下がその実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.toList(): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.toMutableList().optimizeReadOnlyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まずMutableなListに変換して、さらに読み込み専用（Immutable）のListに変換しているように見えます。さらにMutable Listに変えているところの実装をみてみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.toMutableList(): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> toCollection(ArrayList&amp;lt;T&amp;gt;())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ArrayListのインスタンスを作って、それを&lt;code>toCollection()&lt;/code>に渡していますね。ここで&lt;code>toCollection()&lt;/code>はSequenceをCollectionに帰る時の共通処理で、型を指定にするため引数にListを渡しているようです。さらに&lt;code>toCollection()&lt;/code>の実装をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">C&lt;/span> : &lt;span style="color:#a6e22e">MutableCollection&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.toCollection(destination: C): C {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (item &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destination.add(item)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここまでたどり着いてわかったのは、やはりSequenceの要素を一つ一つListの中に入れているということですね。ただ、単純な処理ではありますが、ここでは「Listに要素を足していく」ということ自体に注目する必要があります。&lt;/p>
&lt;p>先に述べた通り、Sequenceは自分が持つ要素の数をわからないので、Listのインスタンスを作る時はサイズを「仮定」して処理するしかないです。そして基本的にMutableなListでは、現在のサイズよりも多くの要素を追加する必要がある時、内部のArrayより大きいサイズのArrayを新しく作り、そこに要素をコピーしていくことを繰り返します。そしてこれを全要素が揃うまで繰り返していきますね。ということは、Sequenceの要素が多ければ多いほどArrayのインタンス作成とコピーが多くなるということになります。&lt;/p>
&lt;p>そしてコピーが全部終わった場合、実際の要素数よりArrayのサイズが大きい場合もありますね。その場合、メモリを無駄に使うだけでなく、実際のサイズもわからなくなるので、サイズを要素数に合わせて再調整する必要があります。&lt;code>toList()&lt;/code>の実装で最後に&lt;code>optimizeReadOnlyList()&lt;/code>を呼び出しているのは、おそらくその理由でしょう。&lt;code>optimizeReadOnlyList()&lt;/code>の実装は以下の通りです。やはりサイズを再調整していますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.optimizeReadOnlyList() = &lt;span style="color:#66d9ef">when&lt;/span> (size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> listOf(&lt;span style="color:#66d9ef">this&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでわかるように、Sequenceを使って処理したあと、Collectionにまとめるなら要素数が多ければ多いほどCollectionよりも性能が劣化する可能性は確かに存在します。CollectionでFunctional functionを呼び出す際にListを作るとしても、すでに要素数はわかっているので、Listのサイズが合わないためのArrayの生成とコピーの処理は不要ですね。なのでCollectionとSequenceのどちらを選ぶかの問題はFunctional functionを呼び出す回数や処理の種類だけでなく、要素の数まで考える必要がありそうです。&lt;/p>
&lt;p>ただ、要素数が多い場合でも、終端処理の種類によってはSequenceの方が有利になる可能性もなくはないです。例えば&lt;code>forEach()&lt;/code>や&lt;code>onEach()&lt;/code>など、個別の要素に対して処理を行うだけの場合は依然としてSequenceの方で良い性能を期待できるでしょう。&lt;/p>
&lt;p>要素数が多い場合に性能に影響する処理としてもう一つ考えられるのは、Sequenceを使う場合でも呼び出せるFunctional functionの中で明らかに「状態を必要とする」ものがあるということです。例えば以下の一覧のようなものです。&lt;/p>
&lt;ul>
&lt;li>どんな要素が含まれているかわかる必要がある
&lt;ul>
&lt;li>&lt;code>distinct()&lt;/code>&lt;/li>
&lt;li>&lt;code>average()&lt;/code>&lt;/li>
&lt;li>&lt;code>min()&lt;/code>&lt;/li>
&lt;li>&lt;code>max()&lt;/code>&lt;/li>
&lt;li>&lt;code>take()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要素の順番をわかる必要がある
&lt;ul>
&lt;li>&lt;code>indexOf()&lt;/code>&lt;/li>
&lt;li>&lt;code>mapIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>flatMapIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>elementAt()&lt;/code>&lt;/li>
&lt;li>&lt;code>filterIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>foldIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>forEachIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>reduceIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>scanIndexed()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>これらの処理をSequenceではどうしているのでしょうか。まずはその実装を覗いてみる必要がありそうですね。ここでは&lt;code>sort()&lt;/code>の方をみていきたいと思います。実装は以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span> : &lt;span style="color:#a6e22e">Comparable&lt;/span>&amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.sorted(): Sequence&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">iterator&lt;/span>(): Iterator&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> sortedList = &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#a6e22e">@sorted&lt;/span>.toMutableList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sortedList.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sortedList.iterator()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>単純ですが、Sequenceを一度Listに変換してsortした後、またSequenceに変えて返していますね。ここでListに変えるために呼び出している関数は&lt;code>toMutableList()&lt;/code>なので、結局&lt;code>toList()&lt;/code>を呼び出す場合と同じようなことが起きるということです。なので、状態を必要とする操作の場合は要素数が多ければ多いほど性能はCollectionより劣化しやすい、ということがわかります。&lt;/p>
&lt;p>ただ、逆に状態が必要にならない場合は、Collectionと違って中間結果のListを作成しなくなるので、依然としてSequenceが良い性能を見せるだろうと思えます。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>だいぶ話が長くなりましたが、性能の観点でどれを選ぶべきか、という話の結論としては、「どんな処理をするか」によるということになりますね。簡単に整理すると、以下のようになるかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>条件&lt;/th>
&lt;th>おすすめ&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>処理が複雑&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>処理した結果としてCollectionが必要&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ループするだけ&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>処理に状態が必要&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>要素数が多い&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>要素数が少ない&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>もちろんこれらの条件が複数ある場合も十分考えられるので、必要な処理が何かをよく考えてどちらを使うかを慎重に考える必要がありそうです。多くの場合とりあえずCollectionを使うという方針だとしても特に問題はなさそうな気はしますが…&lt;/p>
&lt;p>この度はKotlinにおいてのSequenceを紹介しましたが、実はイラストを含めてわかりやすく説明している&lt;a class="link" href="https://typealias.com/guides/when-to-use-sequences" target="_blank" rel="noopener"
>いつSequenceを使うべきか&lt;/a>という良い記事があるので、Sequenceについてより深く理解したい方にはこちらを参考した方が良さそうな気がします。&lt;/p>
&lt;p>また、ここではKotlinのAPIでの処理のみを紹介しましたが、JavaのStreamを使う場合、Sequenceと違って&lt;code>parallelStream()&lt;/code>を呼び出すことができます。なので並列で処理しても良い場合には、CollectionとSequenceのみでなく、Streamを使うことを検討するのもありですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>WebFluxではFunctional Enpointを使うべきか</title><link>https://retheviper.github.io/posts/spring-webflux-router/</link><pubDate>Sun, 30 May 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-webflux-router/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post WebFluxではFunctional Enpointを使うべきか" />&lt;p>以前、&lt;a class="link" href="../spring-webflux/" >Spring WebFluxに関するポストを書いたこと&lt;/a>があって、そこで少しだけMVCパターン(&lt;code>Controller&lt;/code>/&lt;code>Service&lt;/code>)と&lt;code>Functional Endpoint&lt;/code>(&lt;code>Router&lt;/code>/&lt;code>Handler&lt;/code>)に関して触れました。結論だけ先に述べますと、Functional Endpointの導入はMVCパターンは長く使われている良いパターンでありますが、性能や関数型プログラミングには適してないのという問題があるので、それを改善するためのものだといえます。&lt;/p>
&lt;p>さて、その説明だけだと、Spring WebFluxを使う際にはなるべくFunctional Endpointを使うべきな気もします。しかし、実際はどうでしょうか？例えば、従来のSpring MVCと同じくController/Serviceを使う場合は本当にRouter/Handlerを使う時と比べ性能が劣るのか？また、Functional Endpointを使う際に考慮すべき、「MVCパターンにはなかった問題」はないか？といったことを考えられます。&lt;/p>
&lt;p>なので、今回はその二つのパターンを用いて、Spring WebFluxによるサーバサイドアプリケーションを実装するときに考えたいことを少しまとめてみました。&lt;/p>
&lt;h2 id="プログラミングのパラダイムとして">プログラミングのパラダイムとして
&lt;/h2>&lt;p>SpringのMVCパターンは、アノテーションによるメタプログラミングとオブジェクト指向といった昔ながらの考え方に基づいたパラダイムに近いといえます。もちろん、AOPやDIといったSpring Framework特有の特徴はありますが、&lt;a class="link" href="https://www.reactive-streams.org" target="_blank" rel="noopener"
>Reactive Streams&lt;/a>の実現体である&lt;code>Mono&lt;/code>/&lt;code>Flux&lt;/code>で書かれたWebFluxのコードと比べたら、まだ伝統的な書き方に近いという感覚はありますね。&lt;/p>
&lt;p>ここでオブジェクト指向と関数型のうち、どれが良いかという議論はしません。また、Javaは元々オブジェクト指向の言語としてデザインされましたが、1.8以降はFunctional Interfaceの導入である程度関数型プログラミングができるようになりましたし、Kotlinでもそれは大きく変わらないことです。なので、Spring MVCとSpring WebFluxのうちどれかを選ぶということがコードをオブジェクト指向として書くか、関数型として書くかという結論にもなりません。&lt;/p>
&lt;p>しかし、Spring WebFluxでは、MVCパターンとFunctional Endpointのどれかを選べるという点からして、どちらかのパラダイムに寄せた書き方はできるというのも事実です。ここでどれを取るかを判断するには、コードを書く人同士の合意がもっとも重要なのではないかと思います。なぜかというと、結局プログラミングのパラダイムというものは何よりもプログラミングの「効率」のために発展してきたからです。&lt;/p>
&lt;p>なので、ここでの判断基準は「如何に読みやすいか」「如何に早く成果を出せるか」など、実利的なものとなるべきでしょう。例えば、すでにサービスとして機能しているアプリケーションの同時実行性能を向上させたい場合は、MVCパターンとして書いた方がすぐにサービスを立ち上げられるので良いと思ったら、それで理由は十分かと思います。もしくは、すでにFunctional Endpointに慣れているプログラマが多い場合は積極的にそれを導入するとかですね。つまり、私の観点からすると、プログラミングのパラダイムは実務者の立場からすると効率により選択するべきものではないかと思います。&lt;/p>
&lt;p>では、Contorller/ServiceのパターンとRouter/Handlerのパターンの実際はどう違うのかを、コードを通じて見ていきたいと思います。&lt;/p>
&lt;h3 id="mvcパターンで書く場合">MVCパターンで書く場合
&lt;/h3>&lt;p>Spring WebFluxのMVCパターン、つまりContoller/Serviceのパターンは、その名の通り既存のSpring MVCと比べあまり変わらない感覚で書くことができます。なので、例えば以下のようなコードを書くとしたら、これだけではSpring MVCとの違いがあまりわからないくらいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RestController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HelloController&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: HelloService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GetMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(): ResponseEntity =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResponseEntity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(service.getHello())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HelloService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getHello&lt;/span>(): String = &lt;span style="color:#e6db74">&amp;#34;Hello Spring WebFlux&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Spring WebFluxでは、DB接続を含め完全なノンブロッキングを実現するためには[R2DBC]のようなノンブロッキング対応のAPIを使う必要があります。これはつまり、&lt;code>Reactive Stream&lt;/code>を使う必要があるとのことであって、必然的にその実現体であるMono/Fluxを使う必要があるということです。&lt;/p>
&lt;p>なので、とりあえずRepositoryからMono/Fluxを取得し、Reactive Stream固有の書き方に合わせてコードを書いていくしかないということになります。問題は、Reactive Streamはその名前から普通にJavaのStreamの感覚で扱えば良い印象ですが、実際の処理はそう簡単じゃないということです。例えば、JPAやMyBatisのような既存のブロッキングベースのAPIを使う場合は、Serviceのメソッドでは以下のようなコードを書くことになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ユーザIDでユーザ情報とメール送信履歴を取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMemberWithMailRecord&lt;/span>(memberId: Int): MemberWithMailRecord {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザ情報を取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> member = memberRepository.getMember(id = memberId) &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザが作成したメール送信履歴を取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> mailRecord = mailRecordRepository.getMailRecord(memberId = memberId) &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザ情報とメール送信履歴を合わせて返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = member,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = mailRecord
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Mono/Fluxを返すAPIを使う場合は、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMemberWithMailRecord&lt;/span>(memberId: Int): Mono&amp;lt;MemberWithMailRecord&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memberRepository.getMember(id = memberId)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(&lt;span style="color:#a6e22e">Mono&lt;/span>.error(RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .zipWith(mailRecordRepository.getMailRecord(memberId = memberId).switchIfEmpty(&lt;span style="color:#a6e22e">Mono&lt;/span>.error(RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = &lt;span style="color:#66d9ef">it&lt;/span>.t1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = &lt;span style="color:#66d9ef">it&lt;/span>.t2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>やっていることは同じでも、果たしてこれが書きやすく、読みやすいコードであるかどうかは悩ましいですね。他にもFluxで取得したデータをListに変えたい場合、取得したMonoのデータでさらにMonoを取得したい場合など、より複雑な処理が必要な場面ではますます書き方は複雑になります。&lt;/p>
&lt;p>幸い、Kotlinには&lt;a class="link" href="https://kotlinlang.org/docs/coroutines-overview.html" target="_blank" rel="noopener"
>Coroutines&lt;/a>があるので、このような複雑な書き方をより簡単に書くことはできます。Corutinesを適用したら、Mono/Fluxを使う場合でも上記のコードは以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMemberWithMailRecord&lt;/span>(memberId: Int): MemberWithMailRecord {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> member = memberRepository.getMember(id = memberId).awaitFirstOrNull() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> mailRecord = mailRecordRepository.getMailRecord(memberId = memberId).awaitFirstOrNull() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = member,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = mailRecord
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Coroutinesを使う場合はスコープの指定が必要となるのが一般的ですが、実際はControllerのメソッドまでを&lt;code>suspend&lt;/code>として定義しておくと良いみたいです。ただ、既存のプロジェクトをSpring MVCからWebFluxに移行する場合にこうやって多くの処理をsuspendメソッドにすると、ユニットテストの方を直すのが大変になる可能性もあるのでそこは要注意です。&lt;/p>
&lt;h3 id="functional-endpointで書く場合">Functional Endpointで書く場合
&lt;/h3>&lt;p>続いて、Functional Endpontを使う場合のコードです。MVCパターンの問題としてアノテーションがあげられていますが、Router/Handlerでもアノテーションを使うことはできますし、アプリケーションのアーキテクチャによっては必然的にクラスを分けてアノテーションで管理することになるのが一般的かなと思います。なので、そのようなケースではRouterを&lt;code>@Bean&lt;/code>として登録したり、Handlerも&lt;code>@Component&lt;/code>として定義する場合もあります。そういう場合は、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HelloRouter&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> handler: HelloHanlder) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>(): router {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/hello&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>getHello)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HelloHandler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getHello&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServerResponse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(&lt;span style="color:#a6e22e">Mono&lt;/span>.Just(&lt;span style="color:#e6db74">&amp;#34;Hello Spring WebFlux&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Functional Endpointを使う場合の特徴は、RouterはあくまでエンドポイントとHandlerをつなぐ役割をするだけなので、Handlerで&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerRequest.html" target="_blank" rel="noopener"
>ServerRequest&lt;/a>を受け取り&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerResponse.html" target="_blank" rel="noopener"
>ServerResponse&lt;/a>を返す処理までを書くことになるということです。MVCパターンではRestControllerの戻り値としてResponseEntityや自分で定義したクラスを自由に指定でるし、Serviceではビジネスロジックだけを担当するパターンが多いのを考えるとかなり独特であるといえます。&lt;/p>
&lt;p>このようにServerRequestとServerResponseを使うため、HandlerはServiceと比べビジネスロジック部分が一回層が深くなった形になります。ServerResponseのbodyでロジックを書いて、それを返す形ですね。例えば以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServerResponse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(memberRepository.getMember(id = request.PathVariable(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(&lt;span style="color:#a6e22e">Mono&lt;/span>.error(RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .zipWith(mailRecordRepository.getMailRecord(memberId = request.PathVariable(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>)).switchIfEmpty(&lt;span style="color:#a6e22e">Mono&lt;/span>.error(RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = &lt;span style="color:#66d9ef">it&lt;/span>.t1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = &lt;span style="color:#66d9ef">it&lt;/span>.t2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合でもでもCoroutinesを使うことはもちろんできます。Corutinesを使う場合は、以下のような書き方ができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> member = memberRepository.getMember(id = memberId).awaitFirstOrNull() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find member&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> mailRecord = mailRecordRepository.getMailRecord(memberId = memberId).awaitFirstOrNull() &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Can&amp;#39;t find mailRecord&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ServerResponse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .bodyValueAndAwait(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Mono&lt;/span>.just(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemberWithMailRecord(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> member = &lt;span style="color:#66d9ef">it&lt;/span>.t1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mailRecord = &lt;span style="color:#66d9ef">it&lt;/span>.t2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="性能">性能
&lt;/h2>&lt;p>MVCパターンの問題としてあげられるものの一つとして、アノテーションがあります。アノテーションを使うということは、必然的にリフレクションを使うことになるので、自然に性能の低下にもつながるという話ですね。これだけみると、WebFluxではMVCパターンよりもFunctional Endpointを使ったほうが性能でも有利であるように見えます。しかし実際はどうでしょうか？&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-programming-models" target="_blank" rel="noopener"
>Springの公式ドキュメント&lt;/a>では、Functional Enddpointのことを&lt;code>lightweight(軽量)&lt;/code>とは表現しているものの、それ以外に性能がどうという話は一切述べてないです。多くの場合、性能の比較はSpring MVCとSpring WebFluxを対象としていて、WebFluxでのMVCパターンとFunctional Endpointのケースはあまり探せませんでした。なので、ここでは簡単にベンチマークを行うことで二つのパターンでの性能の違いを検証してみました。&lt;/p>
&lt;p>ベンチマークツールとしては、Jmeterを使うこともできましたが、短いコマンドで測定ができるのもあり、今回は&lt;a class="link" href="https://httpd.apache.org/docs/2.4/en/programs/ab.html" target="_blank" rel="noopener"
>Apache HTTP server benchmarking tool&lt;/a>を使ってテストを実施しています。&lt;/p>
&lt;h3 id="使ったコード">使ったコード
&lt;/h3>&lt;p>性能測定として知りたいのは「実装パターンで性能が変わるか」ということなので、あえてDB接続は排除しました。比較のために作ったサンプルアプリケーションでは、単純にデータを生成する共通のロジックと、それを返すだけのContoller/Service, Router/Hanlderのセットで構成されています。&lt;/p>
&lt;h4 id="共通">共通
&lt;/h4>&lt;p>データを生成するロジックそのものは共通で、単純にループでListを生成するようにしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 固定値のデータを生成し返すクラス
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">DataCreationUtil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1970年1月1日から2021年12月31日まで
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> data: List&amp;lt;Person&amp;gt; = (&lt;span style="color:#ae81ff">0.&lt;/span>.&lt;span style="color:#ae81ff">18992&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Person(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#66d9ef">it&lt;/span>.toLong(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#e6db74">&amp;#34;Person&lt;/span>&lt;span style="color:#e6db74">${it}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> birth = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.ofEpochDay(&lt;span style="color:#66d9ef">it&lt;/span>.toLong()),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> joined = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.ofEpochDay(&lt;span style="color:#66d9ef">it&lt;/span>.toLong() + &lt;span style="color:#ae81ff">10000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 生成されるデータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Long,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> birth: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> joined: LocalDate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="controllerserviceの実装">Controller/Serviceの実装
&lt;/h4>&lt;p>MVCパターンについてはコードだけでも十分わかると思いますので、説明は割愛します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RestController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PerformanceTestController&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> service: PerformanceTestService
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GetMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/performance-controller&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getData&lt;/span>(): ResponseEntity&amp;lt;List&amp;lt;Person&amp;gt;&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResponseEntity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(service.getData())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PerformanceTestService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getData&lt;/span>(): List&amp;lt;Person&amp;gt; = service.getData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="routerhandlerの実装">Router/Handlerの実装
&lt;/h4>&lt;p>Functional Endpointでは、MVCパターンと比べ処理と言えるものは全部Handlerの方に書かれてある、という違いがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PerformanceTestRouter&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> handler: PerformanceTestHandler) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">route&lt;/span>() = router {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/performance-router&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>getData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">PerformanceTestHandler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getData&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ServerResponse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(&lt;span style="color:#a6e22e">Flux&lt;/span>.fromIterable(&lt;span style="color:#a6e22e">DataCreationUtil&lt;/span>.&lt;span style="color:#66d9ef">data&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="テスト結果">テスト結果
&lt;/h3>&lt;p>テストは以下のような条件で実施しました。&lt;/p>
&lt;ul>
&lt;li>ユーザ数は5000, ユーザごとのリクエストは50に設定&lt;/li>
&lt;li>ワームアップ時間を考慮して、パターンごとにテストを分ける
&lt;ul>
&lt;li>サーバの再起動後にテストを実施&lt;/li>
&lt;li>テストは10回ループ&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>実際に使ったスクリプトは以下のようなものです。サーバの起動後にこれを実行し、10回のループが終わったら再起動後にFunctional Endpointのテストを実施しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#f92672">{&lt;/span>1..10&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ab -n &lt;span style="color:#ae81ff">5000&lt;/span> -c &lt;span style="color:#ae81ff">50&lt;/span> http://localhost:8080/performance-controller
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうやってもやはりテスト結果では周回ごとに偏差があったので、ここでは中間値に当てはまる結果を紹介します。その結果は、以下の通りになりますが、あらかじめ結論だけ先に言いますとMVCパターンでもFunctional Endpointでもその性能の違いというものは「誤差範囲以内」と表現しても良いかなと思います。&lt;/p>
&lt;h4 id="controllerserviceの結果">Controller/Serviceの結果
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Server Software:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Server Hostname: localhost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Server Port: &lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Document Path: /performance-controller
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Document Length: &lt;span style="color:#ae81ff">1440242&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Concurrency Level: &lt;span style="color:#ae81ff">50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time taken &lt;span style="color:#66d9ef">for&lt;/span> tests: 24.989 seconds
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Complete requests: &lt;span style="color:#ae81ff">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Failed requests: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total transferred: &lt;span style="color:#ae81ff">7201590000&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HTML transferred: &lt;span style="color:#ae81ff">7201210000&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Requests per second: 200.09 &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">#/sec] (mean)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time per request: 249.892 &lt;span style="color:#f92672">[&lt;/span>ms&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>mean&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time per request: 4.998 &lt;span style="color:#f92672">[&lt;/span>ms&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>mean, across all concurrent requests&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Transfer rate: 281433.26 &lt;span style="color:#f92672">[&lt;/span>Kbytes/sec&lt;span style="color:#f92672">]&lt;/span> received
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection Times &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min mean&lt;span style="color:#f92672">[&lt;/span>+/-sd&lt;span style="color:#f92672">]&lt;/span> median max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connect: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 1.4 &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Processing: &lt;span style="color:#ae81ff">29&lt;/span> &lt;span style="color:#ae81ff">248&lt;/span> 79.8 &lt;span style="color:#ae81ff">242&lt;/span> &lt;span style="color:#ae81ff">516&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Waiting: &lt;span style="color:#ae81ff">24&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span> 60.8 &lt;span style="color:#ae81ff">185&lt;/span> &lt;span style="color:#ae81ff">442&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total: &lt;span style="color:#ae81ff">29&lt;/span> &lt;span style="color:#ae81ff">249&lt;/span> 79.4 &lt;span style="color:#ae81ff">243&lt;/span> &lt;span style="color:#ae81ff">516&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Percentage of the requests served within a certain time &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 50% &lt;span style="color:#ae81ff">243&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 66% &lt;span style="color:#ae81ff">275&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 75% &lt;span style="color:#ae81ff">295&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 80% &lt;span style="color:#ae81ff">309&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 90% &lt;span style="color:#ae81ff">354&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 95% &lt;span style="color:#ae81ff">394&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 98% &lt;span style="color:#ae81ff">430&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 99% &lt;span style="color:#ae81ff">449&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100% &lt;span style="color:#ae81ff">516&lt;/span> &lt;span style="color:#f92672">(&lt;/span>longest request&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="routerhandlerの結果">Router/Handlerの結果
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Server Software:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Server Hostname: localhost
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Server Port: &lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Document Path: /performance-router
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Document Length: &lt;span style="color:#ae81ff">1440257&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Concurrency Level: &lt;span style="color:#ae81ff">50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time taken &lt;span style="color:#66d9ef">for&lt;/span> tests: 25.541 seconds
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Complete requests: &lt;span style="color:#ae81ff">5000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Failed requests: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total transferred: &lt;span style="color:#ae81ff">7201775000&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HTML transferred: &lt;span style="color:#ae81ff">7201285000&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Requests per second: 195.76 &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#75715e">#/sec] (mean)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time per request: 255.410 &lt;span style="color:#f92672">[&lt;/span>ms&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>mean&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time per request: 5.108 &lt;span style="color:#f92672">[&lt;/span>ms&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">(&lt;/span>mean, across all concurrent requests&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Transfer rate: 275360.22 &lt;span style="color:#f92672">[&lt;/span>Kbytes/sec&lt;span style="color:#f92672">]&lt;/span> received
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection Times &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min mean&lt;span style="color:#f92672">[&lt;/span>+/-sd&lt;span style="color:#f92672">]&lt;/span> median max
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connect: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> 3.2 &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">151&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Processing: &lt;span style="color:#ae81ff">33&lt;/span> &lt;span style="color:#ae81ff">253&lt;/span> 80.4 &lt;span style="color:#ae81ff">246&lt;/span> &lt;span style="color:#ae81ff">612&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Waiting: &lt;span style="color:#ae81ff">28&lt;/span> &lt;span style="color:#ae81ff">194&lt;/span> 59.8 &lt;span style="color:#ae81ff">184&lt;/span> &lt;span style="color:#ae81ff">475&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Total: &lt;span style="color:#ae81ff">39&lt;/span> &lt;span style="color:#ae81ff">254&lt;/span> 80.0 &lt;span style="color:#ae81ff">247&lt;/span> &lt;span style="color:#ae81ff">613&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Percentage of the requests served within a certain time &lt;span style="color:#f92672">(&lt;/span>ms&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 50% &lt;span style="color:#ae81ff">247&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 66% &lt;span style="color:#ae81ff">286&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 75% &lt;span style="color:#ae81ff">302&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 80% &lt;span style="color:#ae81ff">312&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 90% &lt;span style="color:#ae81ff">361&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 95% &lt;span style="color:#ae81ff">398&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 98% &lt;span style="color:#ae81ff">441&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 99% &lt;span style="color:#ae81ff">459&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 100% &lt;span style="color:#ae81ff">613&lt;/span> &lt;span style="color:#f92672">(&lt;/span>longest request&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ドキュメンテーション">ドキュメンテーション
&lt;/h2>&lt;p>次にドキュメンテーションの観点からすると、Functional Endpointはまだ導入するには早い気がします。ここでいうドキュメンテーションは、JavaDocやKdocのようなコメントのことではなく、最近よく使われる&lt;a class="link" href="https://swagger.io" target="_blank" rel="noopener"
>Swagger&lt;/a>のことを指します。&lt;/p>
&lt;p>最近は&lt;a class="link" href="http://springfox.github.io/springfox" target="_blank" rel="noopener"
>SpringFox&lt;/a>などを使うと簡単にAPIのドキュメンテーションが可能ですが、Functional Endpointだとそう簡単にはできません。すでに理由がわかる方もいらっしゃるかと思いますが、Routerには引数としてエンドポイントとHandlerの処理を渡しているだけで、Handlerは引数がServerRequest、戻り値はServerResponseに固定されてあるのが理由です。&lt;/p>
&lt;p>もちろん、ServerRequestとServerResponseを使う場合でもそれを自分の欲しいデータとして扱うことはできます。例えば、リクエストからパラメータを取る方法は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Path Variableで渡されたIDを持ってユーザ情報を取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Path Variableを取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> id = request.pathVariable(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Request Bodyで渡されたデータを元に新しいユーザを作成する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createMember&lt;/span>(request: ServerRequest): ServerResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Request Bodyをクラスにマッピングする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> form = request.bodyToMono(MemberCreateForm&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.java).awaitFirst()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、SpringFoxのように自動でAPIのドキュメンテーションを行ってくれるような便利なAPIは、おそらくリフレクションを使っています。なので、Handlerで実際はどんな処理が行われているかを判断するのは難しいでしょう。&lt;/p>
&lt;p>幸い、この問題はSpringの開発者も認識しているようで、&lt;a class="link" href="https://springdoc.org" target="_blank" rel="noopener"
>springdoc-openapi&lt;/a>を使うとFunctional EndpointでもAPIのドキュメンテーションは可能になります。ただ、この場合でも現時点ではやはり問題があります。なぜなら、これはAPIのドキュメンテーションを自動化するものではなく、「ドキュメンテーションのための手段を提供する」だけだからです。なので、以下のように、RouterやHandlerに関して一つ一つアノテーションを指定する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RouterOperations&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> RouterOperation(
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> path = &amp;#34;/api/v1/members&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> beanClass = MemberHandler::class,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> beanMethod = &amp;#34;listMember&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> method = [RequestMethod.GET]&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterOperation(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = &lt;span style="color:#e6db74">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanClass = MemberHandler&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanMethod = &lt;span style="color:#e6db74">&amp;#34;getMember&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method = [&lt;span style="color:#a6e22e">RequestMethod&lt;/span>.GET],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterOperation(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = &lt;span style="color:#e6db74">&amp;#34;/api/v1/members&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanClass = MemberHandler&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanMethod = &lt;span style="color:#e6db74">&amp;#34;createMember&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method = [&lt;span style="color:#a6e22e">RequestMethod&lt;/span>.POST],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterOperation(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = &lt;span style="color:#e6db74">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanClass = MemberHandler&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanMethod = &lt;span style="color:#e6db74">&amp;#34;updateMember&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method = [&lt;span style="color:#a6e22e">RequestMethod&lt;/span>.PUT],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterOperation(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = &lt;span style="color:#e6db74">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanClass = MemberHandler&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> beanMethod = &lt;span style="color:#e6db74">&amp;#34;deleteMember&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method = [&lt;span style="color:#a6e22e">RequestMethod&lt;/span>.DELETE],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> produces = [&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON_VALUE]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">routeMember&lt;/span>() = coRouter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/api/v1/members&amp;#34;&lt;/span>) { handler.listMember() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GET(&lt;span style="color:#e6db74">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>getMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> POST(&lt;span style="color:#e6db74">&amp;#34;/api/v1/members&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>createMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PUT(&lt;span style="color:#e6db74">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>updateMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DELETE(&lt;span style="color:#e6db74">&amp;#34;/api/v1/members/{id}&amp;#34;&lt;/span>, handler&lt;span style="color:#f92672">::&lt;/span>deleteMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ご覧の通り、ドキュメンテーションのためのアノテーションが実際のコードよりも長くなっています。Functional EndpointでもSwaggerを利用できる手段ができたのは良いことですが、MVCパターンと比べやはり不便ではありますね。なので、ドキュメンテーションが大事であるなら、まだFunctional Pointを使うべきではないかもしれません。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回は、Spring WebFluxのMVCパターン及びFunctional Endpointをコードの書き方、性能、ドキュメンテーションという観点から比較してみました。Spring WebFluxも発表されたのが2017年なので、もう今年で5年目になりますが、まだまだMVCパターンに比べては色々と補完すべき点が多い印象です。自分の場合はWebFluxのメインコンセプトであるノンブロッキングや関数型プログラミングを活かすためにはやはりFunctional Endpointを選んだ方が良さそうな気はしていますが、まだあえてそうする必要はないのではないか、という感覚です。特にエンタプライズのアプリケーションを書くことになるとますますそうでしょう。もちろん、そもそもWebFluxそのものを導入すべきかということから考える必要がありますが。&lt;/p>
&lt;p>それでも、やはりFunctional Endpointという実装方式には色々と可能性があると思います。Spring WebFluxでなくても、最近のウェブフレームワークでは多く採用されているものですからね。例えばTechEmpowerの&lt;a class="link" href="https://www.techempower.com/benchmarks" target="_blank" rel="noopener"
>ベンチマーク&lt;/a>でJavaのフレームワークのうちではもっとも性能がよかった&lt;a class="link" href="https://jooby.io" target="_blank" rel="noopener"
>jooby&lt;/a>でもMVCパターンとFunctional Endpointとよく似たScript Routeパターンに対応していますし、JetBrainsで開発しているKotlin用のウェブフレームワークである&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>Ktor&lt;/a>ではMVCパターンなしで、同じくFunctional Endpointとよく似たRoutingにのみ対応しています。なので、他にも&lt;a class="link" href="https://expressjs.com/ja" target="_blank" rel="noopener"
>Express&lt;/a>や&lt;a class="link" href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener"
>Gin&lt;/a>のようなフレームワークでも似たようなAPIの実装方法を提供しているので、余裕があったら個人的に試してみて慣れるのも良い勉強になるかもしれません。また、関数型プログラミングはこれからも幅広く使われそうなので、これを持って練習してみるのも良いかもしれませんね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinのString実装を覗く〜whitespace編〜</title><link>https://retheviper.github.io/posts/kotlin-whitespace/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-whitespace/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post KotlinのString実装を覗く〜whitespace編〜" />&lt;p>Kotlin(JVM)は、コンパイルした結果がJVMのバイトコードになります。Javaで書かれたライブラリをそのままKotlinで利用できるのはそのためですね。これはKotliのライブラリに対しても同じなので、スタンダードライブラリを覗くとJavaの機能に依存しているところも少なくないです。&lt;/p>
&lt;p>ただ、KotlinがコンパイルしたらJVMのバイトコードになるということは、単純にKotlinが「書き方が違うJava」であるという意味ではないです。これはKotlinがJavaと言語スペックが違うという点もありますが、JVMだけでなく、JavaScriptやネイティブコードにコンパイルされることも想定してデザインされているので、スタンダードライブラリスタンダードライブラリはプラットフォームに合わせて違う実装になっています。そしてJVMだとしてもJavaのAPIをそのまま利用しているわけではありません。&lt;/p>
&lt;p>Kotlinのこういう構造は、内部のソースコードを見るとはっきりします。スタンダードライブラリの一部メソッドやクラスには&lt;code>expect&lt;/code>と&lt;code>actual&lt;/code>というキーワードが使われていますが、これらはJavaのinheritanceと似ているようなものです。Javaでは&lt;code>interface&lt;/code>で定義したメソッドを、それを継承したクラスで&lt;code>override&lt;/code>で実装して使うことになりますね。同じく、Kotlinでは&lt;code>expect&lt;/code>として定義された機能をプラットフォームに合わせて&lt;code>actual&lt;/code>で実装しているわけです。&lt;/p>
&lt;p>また、KotlinのスタンダードライブラリはJavaと一見同じようなものに見えるとしても、実際は違うケースもあります。&lt;code>actual&lt;/code>によって実装されたコードがKotlinに合わせて、書かれているからですね。なので、Kotlinのスタンダードライブラリに対しては「Javaと同じだろう」という認識をするのは危険な可能性もあります。&lt;/p>
&lt;p>今回はそういうことで、文字列のwhitespaceに関しての機能を、スタンダードライブラリのソースコードを中心に見ていきたいと思います。&lt;/p>
&lt;h2 id="whitespaceの判定">whitespaceの判定
&lt;/h2>&lt;p>とある文字列が意味のある(有効な)データであるかどうかを判定する方法の一つは、その文字列がただの空白であるかどうかを判定することです。つまり、そもそもなんのデータもなかったり、whitespaceだけでないかというチェックをするということですね。&lt;/p>
&lt;p>こういう場合の判定はKotlinのスタンダードライブラリで簡単に行うことができます。KotlinではStringのメソッドとして基本的に以下の二つを提供しています。&lt;/p>
&lt;ul>
&lt;li>&lt;code>isEmpty()&lt;/code>&lt;/li>
&lt;li>&lt;code>isBlank()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Java 11以降でもこれらと同名のメソッドが存在しているので、一見そのままの感覚で良さそうにも見えます。しかし、Kotlinではこれらのメソッドがまず&lt;code>kotlin.text.Strings&lt;/code>から呼ばれるものとされています。JavaのAPIをそのまま使っているわけではないので、処理も違う可能性があるという推測ができますね。&lt;/p>
&lt;p>ここで前者の場合、文字列が単純になんのデータも持ってないかどうかに対する判定をおこないます。実際のソースコードを見ると、文字列の長さだけをチェックしているのを確認できます。&lt;/p>
&lt;p>ちなみにJavaでは&lt;code>String&lt;/code>は&lt;code>CharSequence&lt;/code>を継承していますが、Kotlinとしてもライブラリは違えどそういう継承関係は一緒です。なので、Kotlinでは&lt;code>String&lt;/code>のメンバーでありながらも&lt;code>CharSequence&lt;/code>の関数として書かれています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CharSequence&lt;/span>.isEmpty(): Boolean = length &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>後者の場合は、文字列にwhitespaceまで含めているのかを判定します。以下のコードを見ると、何をやっているかが明確でしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">actual&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CharSequence&lt;/span>.isBlank(): Boolean = length &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> indices.all { &lt;span style="color:#66d9ef">this&lt;/span>[&lt;span style="color:#66d9ef">it&lt;/span>].isWhitespace() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>isBlank()&lt;/code>で呼び出している&lt;code>isWhitespace()&lt;/code>は、以下のような実装となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">actual&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Char&lt;/span>.isWhitespace(): Boolean = &lt;span style="color:#a6e22e">Character&lt;/span>.isWhitespace(&lt;span style="color:#66d9ef">this&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">Character&lt;/span>.isSpaceChar(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの&lt;code>Char.isWhitespace()&lt;/code>は最終的に&lt;code>Character.isWhitespace()&lt;/code>と&lt;code>Character.isSpaceChar()&lt;/code>を使って判定することになります。前者の場合はUnicodeのwhitespaceに当てはまるか、後者の場合はUnicodeのspace(改行コードなど)に当てはまるかを判定するJavaのAPIです。ここでわかるように、特集なケースでなければなるべく&lt;code>isEmpty()&lt;/code>を使った方が文字列をチェックする時に良いでしょう。&lt;/p>
&lt;h2 id="whitespaceの削除">whitespaceの削除
&lt;/h2>&lt;p>文字列が単純に意味のあるデータを持っているかどうかを判定するには、前述通り&lt;code>isEmpty()&lt;/code>を使うと良いですが、文字列にwhitespaceだけでなく、意味のあるデータも混在する場合もありますね。こういう時は前後のwhitespaceを取り除きたくなります。&lt;/p>
&lt;p>Javaでは、文字列の前後のwhitespaceを消去する方法として&lt;code>trim()&lt;/code>と&lt;code>strip()&lt;/code>がありました。前者は昔ながらのもので、全角のwhitespaceを検知できなく、性能の問題もあるのでJava 11以降は後者を使うことが推奨されています。&lt;/p>
&lt;p>ただ、Kotlinの場合は少し都合が違います。Kotlinでは基本的に&lt;code>trim()&lt;/code>だけを使うことになります。まずは&lt;code>trim()&lt;/code>の実装をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>.trim(): String = (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> CharSequence).trim().toString()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まず&lt;code>String&lt;/code>としては、&lt;code>CharSequence&lt;/code>にアップキャストしてその&lt;code>trim()&lt;/code>を呼び出すことにしています。そのあとは単純に&lt;code>toString()&lt;/code>で返すだけですね。&lt;/p>
&lt;p>続いて、&lt;code>String&lt;/code>で呼ばれている&lt;code>CharSequence&lt;/code>側の&lt;code>trim()&lt;/code>をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CharSequence&lt;/span>.trim(): CharSequence = trim(Char&lt;span style="color:#f92672">::&lt;/span>isWhitespace)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでは、オーバロードした他の&lt;code>trim()&lt;/code>に&lt;code>isWhitespace()&lt;/code>をメソッドレファレンスとして渡しているのがわかります。&lt;code>Boolean&lt;/code>が戻り値なので、引数は&lt;code>Predicate&lt;/code>であると推測できますね。続けて、こちらで呼び出している&lt;code>trim(predicate)&lt;/code>の方を確認します。こちらのコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CharSequence&lt;/span>.trim(predicate: (Char) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Boolean): CharSequence {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> startIndex = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> endIndex = length - &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> startFound = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (startIndex &lt;span style="color:#f92672">&amp;lt;=&lt;/span> endIndex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> index = &lt;span style="color:#66d9ef">if&lt;/span> (!startFound) startIndex &lt;span style="color:#66d9ef">else&lt;/span> endIndex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> match = predicate(&lt;span style="color:#66d9ef">this&lt;/span>[index])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!startFound) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!match)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startFound = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startIndex &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!match)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endIndex &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> subSequence(startIndex, endIndex + &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここまできてやっと実際の処理がでました。&lt;code>CharSequence&lt;/code>をループしながら左(start)から右の方にwhitespaceを探し、初めてwhitespaceでない文字を見つけたら右(end)から左の方にループしながら繰り返すという処理ですね。意外と単純ですが、効率的な処理です。&lt;/p>
&lt;p>そしてその処理での判断基準が&lt;code>isWhitespace()&lt;/code>になっているわけですが、先に確認している通りこちらは最終的にJavaのAPIを呼ぶことになっているので、&lt;code>trim()&lt;/code>でも十分Unicodeに定義されてあるwhitespaceやspaceまでを削除してくれると推論できます。なので、Javaとは違ってあえて&lt;code>strip()&lt;/code>を使う必要はなさそうです。&lt;/p>
&lt;p>また、&lt;code>trim()&lt;/code>は文字列の前後のwhitespaceを削除しますが、場合によっては前方のみ、後方のみで分けて使いたい場合もあるかもしれません。その時は、以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> string = &lt;span style="color:#e6db74">&amp;#34; string &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 左のみtrim
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.trimStart()) &lt;span style="color:#75715e">// &amp;#34;string &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 右のみtrim
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.trimEnd()) &lt;span style="color:#75715e">// &amp;#34; string&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのメソッドは引数として&lt;code>Predicate&lt;/code>を渡すこともできるので、他の条件を自前で書く必要がある場合にはそちらを使えますね。&lt;/p>
&lt;p>他にも、whitespaceではない、前後の特定の文字(prefix、suffix)を削除してたい場合は以下のメソッドが提供されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> string = &lt;span style="color:#e6db74">&amp;#34;--hello--&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// prefixのみ削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.removePrefix(&lt;span style="color:#e6db74">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#75715e">// &amp;#34;hello--&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// suffixのみ削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.removeSuffix(&lt;span style="color:#e6db74">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#75715e">// &amp;#34;--hello&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 前後を削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.removeSurrounding(&lt;span style="color:#e6db74">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#75715e">// &amp;#34;hello&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="改行を削除">改行を削除
&lt;/h3>&lt;p>改行が文字列の前後に入っていれば&lt;code>trim()&lt;/code>で十分ですが、文字列の中に改行が含まれていて、それを変えたい場合もありますね。例えばJSONをログに一行で出力したいだったり、以下のようなMulitiline Stringを一行にまとめたい場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> string = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> World
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Intellijだと自動的に&lt;code>trimIndent()&lt;/code>をつけてくれますが、これはあくまでインデントに関与するものであって、中の改行まではtrimしてくれないです。こういう場合は、KotlinでもJavaでも対応するメソッドは特にないので、自分で処理を書くしかないですね。例えば、以下のようなコードが使えるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>.stripLine() = replace(&lt;span style="color:#a6e22e">System&lt;/span>.lineSeparator(), &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Javaでも13から&lt;a class="link" href="https://openjdk.java.net/jeps/355" target="_blank" rel="noopener"
>Text Block&lt;/a>が導入されているので、今後はJavaのAPIの方で上記のようなメソッドが追加されることを期待できるかもしれません。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最初に&lt;code>expect&lt;/code>と&lt;code>actual&lt;/code>の話をしましたが、これらのキーワードは&lt;a class="link" href="https://kotlinlang.org/docs/multiplatform.html" target="_blank" rel="noopener"
>Kotlin Multiplatform&lt;/a>でもっとも重要な概念です。Kotlinで書いたコードをさまざまなプラットフォームで共有できるようにすることを目的としているので、こういう構造になっているのは自然ですね。なので、Kotlin/JVMだけでなく、他のことを試したい方にはとりあえず理解しておく必要があるキーワードだと思います。ちょっと独特なだけで、実体は単純なので、理解は簡単でしょう。&lt;/p>
&lt;p>また、KotlinのStringに関しては、&lt;a class="link" href="https://youtu.be/n4WBip822A8" target="_blank" rel="noopener"
>JetBrains公式YouTubeチャンネルの動画&lt;/a>で簡単に説明しているので、Kotlinで開発をしている方なら一度は参考にした方が良いかもしれません。&lt;/p>
&lt;p>他に、&lt;code>strip()&lt;/code>をあえて使う必要はないと言いましたが、実際Kotlinの最新バージョンである1.5.0でも&lt;code>strip()&lt;/code>は&lt;code>deprecated&lt;/code>になっていて、以下のようなコメントがついているので、次のバージョンで正式対応するまでは使わない方が良いですね。&lt;/p>
&lt;blockquote>
&lt;p>&amp;lsquo;strip(): String!&amp;rsquo; is deprecated. This member is not fully supported by Kotlin compiler, so it may be absent or have different signature in next major version&lt;/p>&lt;/blockquote>
&lt;p>こういうケースでもわかるように、KotlinがJavaと100%互換性があると言い切れない側面もあるのではと思います。なので、JavaからKotlinに移行した場合(実際のコードであれ、開発者自身のスキルであれ)には、一度注意深くスタンダードライブラリの説明を読む必要があるかもしれません。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>年月を扱ってみる</title><link>https://retheviper.github.io/posts/kotlin-year-month/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-year-month/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post 年月を扱ってみる" />&lt;p>Kotlin(Java)では、&lt;code>java.time&lt;/code>パッケージのクラスで日付や時間を処理することができます。例えば&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/LocalDateTime.html" target="_blank" rel="noopener"
>LocalDateTime&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/LocalDate.html" target="_blank" rel="noopener"
>LocalDate&lt;/a>などがありますね。サーバサイドではこれらのクラスを使ってDBに日付や時間を入力したり、認証用のトークンの有効期間を設定したりの処理ができるようになります。他にも&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/time/Period.html" target="_blank" rel="noopener"
>Period&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" target="_blank" rel="noopener"
>Duration&lt;/a>があって、「期間」を扱うこともできますね。&lt;/p>
&lt;p>ただ、「年月」という単位を扱いたい場合はどうしたらいいでしょうか。例えば、口座の入出金明細などを照会する時に、「2月から4月まで」という風に期間を設定するケースなどがあるとしたら、いらない「日」や「時間」まで含めるのはあまり効率的でなく、場合によってはバグの原因になるかもしれません。こういった場合は確かな「年月」としてデータを扱うか、数字として表現するかなどどちらかの方法を考える必要があるでしょう。&lt;/p>
&lt;p>ということで、今回はこの年月を扱う方法について少し述べたいと思います。&lt;/p>
&lt;h2 id="年月を年と月に">年月を年と月に
&lt;/h2>&lt;p>年月を扱うということは、つまり、いつでも「年」と「月」という二つのデータとして分離できるようにしたいということにもなりますね。ここでは二つの方法で、「年月」を「年」と「月」の二つに分けて扱う方法について説明します。&lt;/p>
&lt;h3 id="yearmonthとして">YearMonthとして
&lt;/h3>&lt;p>&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>では、基本的に&lt;a class="link" href="https://www.iso.org/iso-8601-date-and-time-format.html" target="_blank" rel="noopener"
>ISO-8601&lt;/a>形式で日付を扱うことができます。もちろん、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>を使って他の形式を指定することもできますが、扱うデータの形が違うだけで、本質的には「年月日」が基本となりますね。&lt;/p>
&lt;p>&lt;code>ISO-8601&lt;/code>の「年月日」形式で日付を扱っているということは、つまり、SpringでREST APIを作っている場合、リクエストの値が&lt;code>ISO-8601&lt;/code>の形式を守っていれば&lt;code>LocalDateTime&lt;/code>や&lt;code>LocalDate&lt;/code>形式に自動変換されるということでもあります。例えば以下のようなリクエストのJSONがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;date&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-04-01&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Spring側では以下のようなコードで、リクエストのdateを&lt;code>LocalDate&lt;/code>に変換することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// リクエストボディ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DateRequest&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> date: LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コントローラ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@PostMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">date&lt;/span>(&lt;span style="color:#a6e22e">@RequestBody&lt;/span> request: DateRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして全く同じやり方で、&lt;code>LocalDate&lt;/code>を&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/YearMonth.html" target="_blank" rel="noopener"
>YearMonth&lt;/a>に変えることで年月に対応することができます。例えば以下のようなリクエストがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;yearMonth&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-04&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>yearMonth&lt;/code>を&lt;code>YearMonth&lt;/code>に変えるだけです。以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// リクエストボディ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">YearMonthRequest&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> yearMonth: YearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コントローラ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@PostMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/year-month&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">yearMonth&lt;/span>(&lt;span style="color:#a6e22e">@RequestBody&lt;/span> request: YearMonthRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>YearMonth&lt;/code>を使うことのメリットは、&lt;code>LocalDateTime&lt;/code>や&lt;code>LocalDate&lt;/code>と同じく&lt;code>java.time&lt;/code>パッケージに属するオブジェクトなので、それらと互換性があり、相互変換が自由ということでもあります。例えば以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> yearMonth = &lt;span style="color:#a6e22e">YearMonth&lt;/span>.now() &lt;span style="color:#75715e">// 現在の年月を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2021&lt;/span>-&lt;span style="color:#ae81ff">04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> localDate = yearMonth.atDay(&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// 年月に日を指定してLocalDateにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&amp;gt;&amp;gt;&amp;gt; println(localDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2021&lt;/span>-&lt;span style="color:#ae81ff">04&lt;/span>-&lt;span style="color:#ae81ff">01&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>YearMonth&lt;/code>は時間に関する便利なメソッドを多く提供しているので、単純に数値としての年月を扱うだけでなく、色々な要件に合わせて日付関連の処理が必要な場合に便利かもしれません。例えば以下のような機能が提供されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> yearMonth = &lt;span style="color:#a6e22e">YearMonth&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2021&lt;/span>-&lt;span style="color:#ae81ff">05&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getYear()) &lt;span style="color:#75715e">// 年を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getMonth()) &lt;span style="color:#75715e">// 月(Enum)を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>MAY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getMonthValue()) &lt;span style="color:#75715e">// 月(数字)を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.isLeapYear()) &lt;span style="color:#75715e">// うるう年であるかどうか
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.atEndOfMonth()) &lt;span style="color:#75715e">// 月の最後の日(LocalDate)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">2021&lt;/span>-&lt;span style="color:#ae81ff">05&lt;/span>-&lt;span style="color:#ae81ff">31&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数字として">数字として
&lt;/h3>&lt;p>&lt;code>YearMonth&lt;/code>で受け取って処理した方がもっとも綺麗な方法に見えますが、状況によっては素直に&lt;code>Int&lt;/code>型で受け取った方が良い(もしくはそうするしかない)ケースもあるはずです。例えば以下のようなリクエストが送らられて来るようなケースですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;yearMonth&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">202104&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そもそも&lt;code>year&lt;/code>と&lt;code>month&lt;/code>のように別の項目になっていたとしたらもっとやりやすいのですが、このように年月が一つの&lt;code>Int&lt;/code>型のデータとして送られてくる場合は自分で年と月を抽出する処理を作るしかないですね。例えば以下のようなextension functionを書くことができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 年を抽出する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.extractYear(): Int = &lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 月を抽出する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.extractMonth(): Int = &lt;span style="color:#66d9ef">this&lt;/span> % &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実際のコードを動かしてみると、ちゃんと意図通り動くのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.extractYear(): Int = &lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ae81ff">202104.&lt;/span>extractYear()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res4: kotlin.Int = &lt;span style="color:#ae81ff">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.extractMonth(): Int = &lt;span style="color:#66d9ef">this&lt;/span> % &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ae81ff">202104.&lt;/span>extractMonth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res6: kotlin.Int = &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、パラメータとして渡されたものはただの&lt;code>Int&lt;/code>型なので、期待した通りの値ではない可能性もあるという問題があります。常に&lt;code>YYYYMM&lt;/code>という形でデータが送られてくるかどうかをチェックする必要がありますね。&lt;/p>
&lt;p>そういう場合に、上記のコードだとリクエストの&lt;code>yearMonth&lt;/code>が正しい年月の形式になっているかどうかがわかりません。なので、正規式を用いたバリデーションチェックを挟むことにしたらより安全になるでしょう。例えば、以下のようなコードを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.toYearMonth(): Pair&amp;lt;Int, Int&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (Regex(&lt;span style="color:#e6db74">&amp;#34;^(19|20)&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">d{2}(0[1-9]|1[012])&amp;#34;&lt;/span>).matches(&lt;span style="color:#66d9ef">this&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span> to &lt;span style="color:#66d9ef">this&lt;/span> % &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;cannot convert&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数は、以下のような使い方ができます。簡単に使えるのでいい感じですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>year, month) = &lt;span style="color:#ae81ff">202104.&lt;/span>toYearMonth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(year)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(month)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元の値を二つの&lt;code>Int&lt;/code>に分けるために戻り値として&lt;code>Pair&lt;/code>を使いましたが、場合によっては&lt;code>YearMonth&lt;/code>の方が良いかもしれません。そういう場合は、以下のようなコードが使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.toYearMonth(): YearMonth =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (Regex(&lt;span style="color:#e6db74">&amp;#34;^(19|20)&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">d{2}(0[1-9]|1[012])&amp;#34;&lt;/span>).matches(&lt;span style="color:#66d9ef">this&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YearMonth(&lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span> % &lt;span style="color:#ae81ff">100&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;cannot convert&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="年と月を年月に">年と月を年月に
&lt;/h2>&lt;p>さて、今回は逆に「年」と「月」を繋げて「年月」にする場合の処理を考えてみましょう。二つの&lt;code>Int&lt;/code>を合わせて、一つの&lt;code>Int&lt;/code>(YYYYMM)にする形です。ここでまず考えられる方法は二つです。&lt;code>YearMonth&lt;/code>を使った方法と、文字列に変換してから処理するという方法です。&lt;/p>
&lt;h3 id="yearmonthで">YearMonthで
&lt;/h3>&lt;p>まず&lt;code>YearMonth&lt;/code>を利用する場合は、年と月をそのまま引数として渡した後、&lt;code>Int&lt;/code>に変換すれば良いですね。ただ、&lt;code>YearMonth&lt;/code>は基本的に&lt;code>ISO-8601&lt;/code>形式なので、2021年4月だと&lt;code>2021-04&lt;/code>となるので&lt;code>Int&lt;/code>へ変換ができません。なので、まず&lt;code>String&lt;/code>に変えてから、&lt;code>-&lt;/code>を消して&lt;code>Int&lt;/code>に変換することにします。以上の処理は、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">toYearMonth&lt;/span>(year: Int, month: Int): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">YearMonth&lt;/span>.of(year, month).toString().replace(&lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>).toInt()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="文字列で">文字列で
&lt;/h3>&lt;p>文字列で処理する場合は、単純に&lt;a class="link" href="https://kotlinlang.org/docs/basic-types.html#string-templates" target="_blank" rel="noopener"
>String templates&lt;/a>を使うことでも可能ですが、注意したいのは、月は1&lt;del>12という範囲を持つので、単純にtemplateで年と月を繋げると&lt;code>20214&lt;/code>のような形になり得る可能性もあるということですね。なので、&lt;code>padStart()&lt;/code>を利用して、月が1&lt;/del>9の場合は先頭に&lt;code>0&lt;/code>をつけるようにします。そのあとは&lt;code>Int&lt;/code>に変換するだけですね。これは以下のようなコードになリます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">toYearMonth&lt;/span>(year: Int, month: Int): Int = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${year}${month.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらの方法は、引数が二つなので、&lt;code>infix&lt;/code>として定義することもできます(好みの問題かと思いますが)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">infix&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.toYearMonthWith(month: Int): Int = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${this}${month.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ae81ff">2021&lt;/span> toYearMonthWith &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res10: kotlin.Int = &lt;span style="color:#ae81ff">202105&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがだったでしょうか。あまり難しいコードではなかったので、あえて記事にまでする必要があったのか、という気もしましたが、個人的には&lt;code>YearMonth&lt;/code>というクラスの存在を初めて知ったのもあり、Kotlinならではのコード(extension function)を書いてみたく試したことを共有したいと思った次第です。もしKotlinやJavaで年月を扱う必要がある方には、少しでも役に立てるといいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinでZIP圧縮してみる</title><link>https://retheviper.github.io/posts/kotlin-zip-files/</link><pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-zip-files/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post KotlinでZIP圧縮してみる" />&lt;p>サーバサイドの機能を作っていると、ファイルダウンロード機能が必要な時があります。ただ、ストレージに保存されてあるファイルをそのまま返すということだけでなく、場合によってはファイルを生成してそのまま返したり、複数のファイルをまとめて転送する必要もありますね。&lt;/p>
&lt;p>リクエストごとに一つのファイルをダウンロードさせるとしたら、実装はそう難しくないものですが、複数のファイルをダウンロードさせるという場合は少し複雑になりますね。ファイルを一つにまとめて送るとしたら、ZIPに圧縮した方が良いでしょう。幸い、Javaでは基本的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/zip/ZipOutputStream.html" target="_blank" rel="noopener"
>ZipOutputStream&lt;/a>というAPIを提供しているので、エントリに圧縮対象のファイルを追加したあとZIPファイルを出力だけで良いです。&lt;/p>
&lt;p>ただ、単純にファイルが複数だるだけでなく、ディレクトリが多重にネストされてあったりする場合は、ディレクトリ構造を維持しつつそのまま圧縮するとかの追加的な処理が必要となります。そして場合によっては含めたくないファイルがあるケースもあったりしますね。そしてなるべくファイルの数に関係なく(ファイルが一つであれ、ディレクトリであれ)一つの機能で済ませたいものです。なので、今回はそのようなユースケースに合わせた簡単なメソッドを作る方法を、JavaのコードからKotlinへ移行していく過程を簡単に紹介したいと思います。&lt;/p>
&lt;p>今回紹介しますコードは、はBaeldungの&lt;a class="link" href="https://www.baeldung.com/java-compress-and-uncompress" target="_blank" rel="noopener"
>JavaでZipを圧縮する方法&lt;/a>に関する記事に紹介されてあるものをベースにしています。&lt;/p>
&lt;h2 id="java">Java
&lt;/h2>&lt;p>まずJavaのコードを見ていきましょう。上記の記事には、以下のようなコードが紹介されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ZipDirectory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String sourceFile &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;zipTest&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileOutputStream fos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileOutputStream(&lt;span style="color:#e6db74">&amp;#34;dirCompressed.zip&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipOutputStream zipOut &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ZipOutputStream(fos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File fileToZip &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> File(sourceFile);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile(fileToZip, fileToZip.&lt;span style="color:#a6e22e">getName&lt;/span>(), zipOut);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fos.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">zipFile&lt;/span>(File fileToZip, String fileName, ZipOutputStream zipOut) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileToZip.&lt;span style="color:#a6e22e">isHidden&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileToZip.&lt;span style="color:#a6e22e">isDirectory&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileName.&lt;span style="color:#a6e22e">endsWith&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">putNextEntry&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ZipEntry(fileName));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">closeEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">putNextEntry&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ZipEntry(fileName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">closeEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File&lt;span style="color:#f92672">[]&lt;/span> children &lt;span style="color:#f92672">=&lt;/span> fileToZip.&lt;span style="color:#a6e22e">listFiles&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (File childFile : children) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile(childFile, fileName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> childFile.&lt;span style="color:#a6e22e">getName&lt;/span>(), zipOut);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileInputStream fis &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileInputStream(fileToZip);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipEntry zipEntry &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ZipEntry(fileName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">putNextEntry&lt;/span>(zipEntry);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bytes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>1024&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> fis.&lt;span style="color:#a6e22e">read&lt;/span>(bytes)) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">write&lt;/span>(bytes, 0, length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fis.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>zipFile&lt;/code>メソッドをみると、引数の&lt;code>fileToZip&lt;/code>にZIPで圧縮したいファイルやディレクトリのパスを指定して、&lt;code>fileName&lt;/code>にはファイルもしくはディレクトリ名、&lt;code>zipOut&lt;/code>には圧縮後のZIPのファイル名を指定するようになっています。&lt;/p>
&lt;p>そして実装としては、指定したファイルやディレクトリに&lt;code>hidden&lt;/code>属性がある場合は圧縮しなく、圧縮元のファイルがディレクトリである場合は中のファイルを全部ZIPに含ませるという処理が含まれてありますね。対象のファイルとディレクトリを全部エントリに追加した後は、圧縮元を読み込んでZipOutputStreamに書き込むという処理となっています。これをKotlinのコードに変えてみましょう。&lt;/p>
&lt;h2 id="kotlinのコードに変えてみる">Kotlinのコードに変えてみる
&lt;/h2>&lt;p>JavaのコードをKotlinのコードに変えるのはそう難しくありません。Intellijの場合、すでにJavaのコードを貼り付けると自動でKotlinのコードの変換してくれる機能を搭載していますので。ただ、それだけでは十分ではないですね。簡単に変換ができるとしても、それが本当に&lt;code>Kotlinらしいコード&lt;/code>になっているとはいえない場合があります。&lt;/p>
&lt;p>そして、処理自体もより単純に、もしくは読みやすいコードにする方法もあるはずですね。上記のJavaコードをまずKotlinに変えて、色々改善したいところを含めて変えていきます。&lt;/p>
&lt;h3 id="kotlinらしいコードに変える">Kotlinらしいコードに変える
&lt;/h3>&lt;p>Intellij 2021.1を基準に、Javaのコードをそのまま貼り付けると以下のようなコードに自動変換されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Throws&lt;/span>(IOException&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">zipFile&lt;/span>(fileToZip: File, fileName: String, zipOut: ZipOutputStream) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileToZip.isHidden) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileToZip.isDirectory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileName.endsWith(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(ZipEntry(fileName))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(ZipEntry(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$fileName&lt;/span>&lt;span style="color:#e6db74">/&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> children = fileToZip.listFiles()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (childFile &lt;span style="color:#66d9ef">in&lt;/span> children) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile(childFile, fileName + &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> + childFile.name, zipOut)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> fis = FileInputStream(fileToZip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> zipEntry = ZipEntry(fileName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(zipEntry)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> bytes = ByteArray(&lt;span style="color:#ae81ff">1024&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> length: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (fis.read(bytes).also { length = &lt;span style="color:#66d9ef">it&lt;/span> } &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.write(bytes, &lt;span style="color:#ae81ff">0&lt;/span>, length)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fis.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでもっとKotlinらしいコードに変えたい部分は、&lt;code>InputStream&lt;/code>や&lt;code>OutputStream&lt;/code>の使い方です。Javaでも&lt;code>try-with-resource&lt;/code>があって、Kotlinには&lt;code>use()&lt;/code>があるのでそちらを使った方が&lt;code>close&lt;/code>よりも良い気がします。&lt;/p>
&lt;p>また、&lt;code>if&lt;/code>は&lt;code>when&lt;/code>に変えたり、&lt;code>for&lt;/code>を&lt;code>forEach()&lt;/code>に変えたりなどでよりやりたいことを明確にすることができるようにも見えます。個人的にはスコープをあえて分けたほうが責任が明確になり、処理を追うときに混乱しないのでなるべくスコープ関数やCollection専用のオペレーションを積極的に使用して処理の単位を分けられるところはきちんと分けたいと思います。Javaのやり方をとっても処理としては全く問題がありませんが、せっかくなのでKotlinならではのコードを描きたいものです。&lt;/p>
&lt;p>あえてIOExceptionを投げるという表示をしておくというのも、ランタイム時の例外の処理を強制してないKotlinには相応しくないのではないかという気もするので、アノテーションは削除することとします。&lt;/p>
&lt;h3 id="ioからnioに変える">IOからNIOに変える
&lt;/h3>&lt;p>NIOに関しては以前のポストで何回か言及したことがありますが、サーバのように頻繁かつ同時実行数が多いケースは積極的に採用した方が良いと思います。また、Java 1.8以降から追加されたメソッドでかなり便利に使える機能が多いので、IOをNIOに変えるだけでコードの量をかなり減らせる可能性もあります。&lt;/p>
&lt;p>特にディレクトリを指定した場合、そのディレクトリの子要素を循環するにはNIOの&lt;code>Files&lt;/code>が提供する機能が強力なので、今回はそれを積極活用することにします。&lt;/p>
&lt;h3 id="シグニチャーを変える">シグニチャーを変える
&lt;/h3>&lt;p>上記のメソッドでは、三つの引数を取っていますが、実際に必要なのは圧縮元のパスと、圧縮先のパスのみですね。ZipOutputStreamを呼び出し元で渡す理由は特になく、むしろこのメソッドを利用する度に定義する必要があるので不便ですね。そして、メソッドの中で単純にエントリを追加していて、呼び出し元とオブジェクトに対する処理の職務を分担するという構造もあまりよくないかと思います。なので、ZipOutputStreamの生成と使用はメソッドの中で完結するように変えることにします。&lt;/p>
&lt;p>こうすることで、メソッドの外側(呼び出し元)での使い方はもっと簡単になりますし、圧縮元のデータを読み込む際に使う&lt;code>InputStream&lt;/code>は中で閉じているのに引数の&lt;code>OutputStream&lt;/code>は外で閉じるという複雑な状況は避けられます。&lt;/p>
&lt;h3 id="再帰を無くす">再帰を無くす
&lt;/h3>&lt;p>圧縮元のパスがディレクトリである場合は、さらにネストされたディレクトリやファイルもまとめて圧縮するために再帰を使うようになっています。再帰はアルゴリズムとしては重要ではあるものの、処理が全部終わるまでメモリに全データと処理を詰めておくので処理の効率という面ではあまりよくない場合もありますね。やりたいのは単純に&lt;code>hidden&lt;/code>属性を持つファイルやディレクトリを除外すること、そしてそれ以外のファイルやディレクトリは全部ZipOutputStreamのエントリに入れたいという単純な事です。&lt;/p>
&lt;p>幸い、NIOを使うことでディレクトリの子要素を全部取得することができますし、取得した子要素は&lt;code>Stream&amp;lt;Path&amp;gt;&lt;/code>として取得できるので、&lt;code>filter()&lt;/code>や&lt;code>forEach()&lt;/code>のようなメソッドが使えます。これで十分、再帰を使わずに目的を達成できそうですね。&lt;/p>
&lt;h2 id="完成したコード">完成したコード
&lt;/h2>&lt;p>以上のことを反映し、修正したコードは以下の通りになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">ZipService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">archive&lt;/span>(source: Path, target: Path): Unit =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipOutputStream(&lt;span style="color:#a6e22e">Files&lt;/span>.newOutputStream(target)).use { zos &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.walk(source)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { &lt;span style="color:#a6e22e">Files&lt;/span>.isHidden(&lt;span style="color:#66d9ef">it&lt;/span>).not() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">Files&lt;/span>.isDirectory(&lt;span style="color:#66d9ef">it&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.putNextEntry(ZipEntry(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">/&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.putNextEntry(ZipEntry(&lt;span style="color:#66d9ef">it&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.copy(&lt;span style="color:#66d9ef">it&lt;/span>, zos)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>簡単に説明しますと、&lt;code>object&lt;/code>として宣言したSingletonクラスにおくことでどこでも活用できるユーティリティクラスにして、メソッドのシグニチャはより単純なものにしました。引数の&lt;code>source&lt;/code>には圧縮元のファイルやディレクトリを、&lt;code>target&lt;/code>には圧縮先のZIPファイルを指定する事になっています。ZipOutputStreamはメソッドの中で生成して、&lt;code>use()&lt;/code>を使って自動にクローズされるようにしています。&lt;/p>
&lt;p>まず優先的に&lt;code>Files.walk()&lt;/code>を使って子要素を全部取得するようにしています。取得した子要素は&lt;code>filter()&lt;/code>で&lt;code>hidden&lt;/code>でない場合を選別しているので、分岐は無くなりますね。また、子要素がディレクトリである場合ディレクトリ名であることを表すために&lt;code>/&lt;/code>をつけて&lt;code>ZipEntry&lt;/code>を追加とクローズします。子要素がファイルの場合は&lt;code>ZipEntry&lt;/code>の追加とコンテンツのコピーを行います。これでより短く、単純なコードの出来上がりです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>&lt;code>Kotlinらしいコード&lt;/code>と述べましたが、上記のコードはあくまで&lt;code>Kotlin/JVM&lt;/code>でのみ有効ですね。なのでもし&lt;code>Kotlin/Native&lt;/code>や&lt;code>Kotlin/JS&lt;/code>などで使うには、別の方法を探す必要があるはずです。また、&lt;code>Files.walk()&lt;/code>はJava 1.8から追加されたメソッドなので、1.7の場合は&lt;code>Files.walkFileTree()&lt;/code>を、その以前なら仕方なくNIOではない別の方法を使う必要があると思います。&lt;/p>
&lt;p>なので、&lt;code>Kotlin/JVM&lt;/code>(Java 1.8以上)ではこれが最善なのかもしれませんが、また色々と研究の余地はありそうですね。こうやってJavaのAPIをKotlinの作法で切り替えていくのも、それなりに価値のあることではないかと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その一〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-1/</link><pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-1/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Kotlinで書いてみた〜その一〜" />&lt;p>こないだはGoに関するポストを作成しましたが、やはり本業はKotlinなので、Kotlinに関しても何かわかったことや閃いたことなどあれば、順次に書いていこうと思っています。今回はKotlinでAPIを作りながら、業務での要件をどんなコードで満たしたかを簡単に説明させていただきたいと思います。&lt;/p>
&lt;p>サーバサイドエンジニアをやっていると、要求される機能を以下に実現している方法がどんなものあれ(GraphQL、REST API、マイクロサービスみたいな技術やアーキテクチャの観点の以前の話として)、業務としてはある程度パターン化しているように感じることがあります。こういう場合には、コードよりもロジックが大事であるかのように見える場合もありますね。でも逆に、むしろ似たようなロジックが多いので、より良いコードを書くために工夫できる余地もまた多いのではないか、とも思います。&lt;/p>
&lt;p>正直自分はアルゴリズムに強いわけでもないので、効率的なコードを書くとしたら限界はあるだろうなという気はしています。とりあえず動くコードを書いて、それをリファクタリングしながら少しづつ整える感じのことしかできないのかもしれません。&lt;/p>
&lt;p>しかし、そんな自分にも良いコードを書くためにできることが全くないわけでもないと思います。例えば、Javaでコードを書くときは、参照の問題などからなるべく&lt;code>final&lt;/code>をつけてオブジェクトを&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%9F%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB" target="_blank" rel="noopener"
>immutable&lt;/a>にするようにと教わりましたが、実際は&lt;a class="link" href="https://www.baeldung.com/java-final-performance?__s=m4suw1p9x2sbizbhxrew" target="_blank" rel="noopener"
>ベンチマークで比較した結果&lt;/a>でもわかるように、性能の改善にも繋がっています。また、JavaでもKotlinでも色々と便利なAPIを提供していて、バージョンアップの度にまた新しいAPIが追加されるので、それらの用途と使い方をよく理解した上で、積極的に使用するだけでも読みやすく、性能も良いコードを書くことができます。&lt;/p>
&lt;p>ということで、今回はKotlinのAPIを使って書いていたコードを一部紹介したいと思います。&lt;/p>
&lt;h2 id="リストのグループ化">リストのグループ化
&lt;/h2>&lt;p>DBに商品情報テーブルがあって、さらに商品属性テーブル、生産地や販売店テーブルなどがある場合に、業務によっては「販売店ごとにどんな商品が販売されているかを確認したい」とか、「特定の商品属性に当てはまる商品だけみたい」とかのケースがあるはずですね。&lt;/p>
&lt;p>そういった場合、APIとしてはテーブルから取得したデータを、特定のカラムを基準にまとめたもの返す必要があります。これをコードに書くとしたら&lt;code>List&lt;/code>で取得したデータを、中の一つの属性をキーに&lt;code>Map&lt;/code>にまとめて返すということになりますね。Javaだと、以下のような形になるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBのデータの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>User&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, 20, &lt;span style="color:#e6db74">&amp;#34;USA&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Programmer&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;James&amp;#34;&lt;/span>, 30, &lt;span style="color:#e6db74">&amp;#34;Canada&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Sales&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;Jack&amp;#34;&lt;/span>, 35, &lt;span style="color:#e6db74">&amp;#34;UK&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Programmer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UserのJobを基準にまとめる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">groupingBy&lt;/span>(User::getJob,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">mapping&lt;/span>(user &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Pair(user.&lt;span style="color:#a6e22e">getAge&lt;/span>(), user.&lt;span style="color:#a6e22e">getName&lt;/span>()), Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>())));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// {James=[Pair(first=30, second=Sales)], John=[Pair(first=20, second=Programmer), Pair(first=35, second=Writer)]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> age;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String address;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String job;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Pair&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Object first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Object second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinでもJavaのAPIをそのまま使うことができるので、上記の&lt;code>Stream&lt;/code>と&lt;code>Collector&lt;/code>を使って同じことはできます。ただ、せっかく違う言語と使っているわけなので、できればKotlinが提供するAPIを活用して同じことをしたいものです。&lt;/p>
&lt;p>KotlinはCollectionで提供する機能だけでも&lt;code>Stream&lt;/code>と&lt;code>Collector&lt;/code>を組み合わせたものと似たような処理ができる場合が多いので、JavaのAPIに対応した機能があるかどうかを探すだけで事足りるケースが多いです。ということは、上記の処理でキモになっている&lt;code>Collectors.groupingBy()&lt;/code>と&lt;code>Collectors.mapping()&lt;/code>と似たようなものがあればいいというわけですが、&lt;code>groupBy()&lt;/code>でそれらの処理をまとめることができます。なので、上記のコードをKotlinで変えると、以下のようになります。色々とスッキリしますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;USA&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Programmer&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;James&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Canada&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Sales&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;Jack&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">35&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;UK&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Programmer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Jobを基準にMap&amp;lt;String, List&amp;lt;Pair&amp;lt;Int, String&amp;gt;&amp;gt;&amp;gt;にまとめる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> map = list.groupBy({ &lt;span style="color:#66d9ef">it&lt;/span>.job }, { &lt;span style="color:#66d9ef">it&lt;/span>.age to &lt;span style="color:#66d9ef">it&lt;/span>.name })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// {Programmer=[(20, John), (35, Jack)], Sales=[(30, James)]}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> age: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> address: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> job: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mapのvalueだけを変える">Mapのvalueだけを変える
&lt;/h2>&lt;p>上記の処理に加えて、もっと条件がつく場合もあるかと思います。例えば、金額計算とかの例があるとします。従業員が案件ごとに賃金をもらうということになっていて、案件はコードで管理されている場合、賃金を払う側としては同じ案件に対しては合算した金額のみが知りたいとかのケースもあるでしょう。こういう場合には、従業員ごとにデータをまとめた上で、さらにその人が担当した案件のリスト野中で重複するものがあれば、金額だけを合算するようにする必要がありますね。&lt;/p>
&lt;p>こういう場合は、グルーピングの段階からそういう処理を入れるのがもっとも効率的ではあるとは思いますが、スレッドの問題もあるので(生成中のMapの中を巡回するという)、実際のコードに書くとするとかなり複雑になる可能性もあります。なのでここではまず、&lt;code>List&lt;/code>を&lt;code>Map&lt;/code>にまとめた結果を持ってさらに処理を加えるという形を取ります。&lt;/p>
&lt;p>Kotlinの&lt;code>Map&lt;/code>には、&lt;code>map()&lt;/code>以外にも&lt;code>mapKeys()&lt;/code>や&lt;code>mapValues()&lt;/code>のような関数があって、必要な部分だけをマッピングできます。今回は&lt;code>value&lt;/code>だけを変えたいので、&lt;code>mapValues()&lt;/code>を使った方が無駄がなく、コードを読む側としても意図が明確になって良いと思います。&lt;code>mapValues()&lt;/code>を使ってさらにマッピングを行うコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> name: String, &lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> amount: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// nameでまとめた後、重複するidを一つにまとめる(amountを合算)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> map = list.groupBy({ &lt;span style="color:#66d9ef">it&lt;/span>.name }, { &lt;span style="color:#66d9ef">it&lt;/span>.id to &lt;span style="color:#66d9ef">it&lt;/span>.amount })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .mapValues {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// idでグルーピング
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>.groupBy { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.first }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// keyはそのまま、valueだけを合算する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .map { map &lt;span style="color:#f92672">-&amp;gt;&lt;/span> map.key to map.&lt;span style="color:#66d9ef">value&lt;/span>.sumBy { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.second } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// {A=[(1, 3000), (2, 4000)], B=[(3, 5000)]}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>List&lt;/code>を&lt;code>Map&lt;/code>にまとめるもう一つの方法は、&lt;code>groupingBy()&lt;/code>があります。この関数を使うと、Collectionが&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-grouping" target="_blank" rel="noopener"
>Grouping&lt;/a>というオブジェクトに変わって、&lt;code>aggregate()&lt;/code>・&lt;code>reduce()&lt;/code>・&lt;code>fold()&lt;/code>・&lt;code>eachCount()&lt;/code>のような関数を使うことで後続の処理ができます。上記のコードを&lt;code>Grouping&lt;/code>を使ったものに変えるとしたら、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Groupingのaggregateを利用してMapに変えた後から、valueの処理を行う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> map = list.groupingBy { &lt;span style="color:#66d9ef">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .aggregate { _, accumulator: MutableList&amp;lt;Pair&amp;lt;Int, Int&amp;gt;&amp;gt;?, element, first &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 新しいキーなら、MutableListを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (first)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutableListOf(element.id to element.amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// そうではない場合は、存在するListに要素を追加する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accumulator&lt;span style="color:#f92672">?.&lt;/span>apply { add(element.id to element.amount) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.mapValues {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>&lt;span style="color:#f92672">?.&lt;/span>groupBy { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.first }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?.&lt;/span>map { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.key to pair.&lt;span style="color:#66d9ef">value&lt;/span>.sumBy { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.second } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見、&lt;code>groupingBy()&lt;/code>の方が複雑にも見えますが、&lt;code>accumulator&lt;/code>を使ってマッピングした値を積み重ねることができるので、場合によっては考慮する価値があるかもですね。&lt;/p>
&lt;h2 id="mapを使ったキャッシュ">Mapを使ったキャッシュ
&lt;/h2>&lt;p>DBの参照が頻繁であり、なお参照されるデータそのものは更新される頻度が高くない場合は、アプリケーション内にキャッシュして置くのが良いケースもたまにありますね。こういう場合には、パラメータをキーとして持つ&lt;code>Map&lt;/code>を宣言しておいて、そのキーがない場合だけDBにアクセスする(そして&lt;code>Map&lt;/code>に追加する)という形にすれば良いでしょう。Javaでは1.8から&lt;code>computeIfAbsent()&lt;/code>というメソッドを提供しているので、簡単に実装ができます。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBデータの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// キャッシュのMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Boolean&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentHashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// パラメータ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String element &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// キャッシュにパラメータがない場合はDBデータを参照して、追加した後に返す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Boolean exists &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">computeIfAbsent&lt;/span>(element, key &lt;span style="color:#f92672">-&amp;gt;&lt;/span> list.&lt;span style="color:#a6e22e">contains&lt;/span>(element));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Method Referenceを使った例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exists &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">computeIfAbsent&lt;/span>(element, list::contains);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaで提供する機能なので、もちろんKotlinでも全く同じ形で実装できます。ただ、Kotlinの仕様上&lt;code>compute&lt;/code>のコードが&lt;a class="link" href="https://kotlinlang.org/docs/lambdas.html#instantiating-a-function-type" target="_blank" rel="noopener"
>LambdaかMethod Referenceかによって書き方が違う&lt;/a>ので、そこだけ注意する必要があります。これはKotlin自体の仕様によるものですが、Javaの書き方に慣れていると最初はなかなかわかりにくいところかもしれません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// キャッシュのMap
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> map = ConcurrentHashMap&amp;lt;String, Boolean&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// パラメータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> element = &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Lambdaの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> exists = map.computeIfAbsent(element) { list.contains(element) } &lt;span style="color:#75715e">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Method Referenceの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>exists = map.computeIfAbsent(element, list&lt;span style="color:#f92672">::&lt;/span>contains)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、似たような機能をするメソッドとして&lt;code>putIfAbsent()&lt;/code>がありますが、&lt;code>computIfAbsent()&lt;/code>の場合&lt;code>Map&lt;/code>にキーがなかった場合にだけ後続の処理が行われるに対して、&lt;code>putIfAbsent()&lt;/code>はキーがあるかないかに関係なく処理が走ってしまうという違いがあるらしいです。なのでキャッシュとして使う場合は、&lt;code>computeIfAbsent()&lt;/code>を使った方が良いでしょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>自分が書いたコードをいくつか紹介しましたが、いかがだったでしょうか。まだKotlinに移行したばかりなので色々とわからないことが多く、本当はもっとスマートな方法があるのかもしれませんが、自分的には、こうやって実際の業務の要件に合わせて違う言語とコードを比べながら、APIのソースをみたりで自分なりにどうやって書くかを考えてみるのは意味のあることで、楽しいとも思います。&lt;/p>
&lt;p>というわけで、これからもKotlinでの書き方に対する研究はこれからも続きます。そろそろGoでも簡単なAPIでも作ってみたりで勉強をしないとやばそうな気もしていますが…まぁ、なんとかなるでしょう。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>JavaプログラマーがみたGo</title><link>https://retheviper.github.io/posts/go-first-impression/</link><pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/go-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/go.webp" alt="Featured image of post JavaプログラマーがみたGo" />&lt;p>このブログのポストとしてはいきなりですが、転職してからは仕事の都合上Goも少し触ることとなりました。以前からGoかRustに触れてみたいなとは思っていたのものの、いざ全く触れてみたことのない言語で書かれてあるアプリを修正するようなことになると少し怖くもなります。なので、少しでもGoのことを知っておくべきではありますね。というわけで、今回はGoに少し触れてみて感じたことを、Javaプログラマーの観点から述べてみたいと思います。&lt;/p>
&lt;p>Goの特徴は、色々とあると思いますが、正直GCがあって、VMがない言語だという特徴は、実際はあまり肌で感じる違いではないです。VMがないから、ある言語よりは早いだろうなというとしか言えませんね。&lt;/p>
&lt;p>実際その言語を持ってコードを書くという仕事をしている身からしては、そのような特徴よりも、コードを書く場面で気にしなければならないことの方に注目したいものです。まずは自分が今まで触れてきた言語とはどう違うかですね。例えば、ループや条件などを書くときはどうなのか、今までの習慣通りコードを書いても問題ないだろうか、注意すべきところは何かなど。今回はそのような観点から本当の少しだけGoに触れてみた感想を書いていきたいと思います。&lt;/p>
&lt;h2 id="考え方を変える必要があるかも">考え方を変える必要があるかも
&lt;/h2>&lt;p>Goに少し触れてみて考えたことは、もっとも基本的な部分でもJavaを書くときとはかなり違うアプローチが必要ではないかということでした。私の場合はJava意外にPython、JavaScript、TypeScript、Kotlinに触れてみたことがあるのですが、JavaScriptやTypeScriptはJavaの書き方とそう変わらない感覚で書くことができて、Kotlinも基本はJavaを簡略化した感覚でコードが書けます。Pythonがかなり違うのですが、どちらかというと書きたいコードを文法の制約なしで書けるという感覚に近いので、文法の差が気にならないものでした。&lt;/p>
&lt;p>しかし、Goの場合は少しわけが違います。Javaと比べ、書き方が少し違うだけでなく、機能レベルで違いがあるからです。機能レベルで違うということは、単純にJavaのコードを少し変更したくらいのコードを書くことはあまりよくないということになると思います。なので、そもそもの考え方を変える必要があるのではないかと思いました。そういう観点から感じたGoの印象は、以下の通りです。&lt;/p>
&lt;h3 id="似ているようで似ていない">似ているようで、似ていない
&lt;/h3>&lt;p>まず目立つのは、文法です。もちろん、大枠はいわゆるCファミリープログラミング言語とそう変わらないですが、Javaと比較すると文法の構造以外の部分でかなり変わった部分があります。例えば、&lt;code>Walrus Operator&lt;/code>とも呼ばれる&lt;a class="link" href="https://docs.python.org/ja/3/whatsnew/3.8.html#assignment-expressions" target="_blank" rel="noopener"
>Pythonの代入式&lt;/a>に似たような表現があったり、if文の条件式を括弧なしで書けたり、importを文字列で書いたり、クラスや&lt;code>public&lt;/code>・&lt;code>private&lt;/code>のようなキーワードが無かったりの違いがあるので、コードを書くときの感覚が違うだけでなく、パッケージ構造やアプリケーションのアーキテクチャ設計のレベルで今まで自分が経験していたJavaやKotlinとは違うアプローチが必要ではないかと思えるくらいです。&lt;/p>
&lt;p>色々と違う点を述べましたが、単純にコードを持って比較してみましょう。例えば、以下のようなコードがあるとしましょう。数字に関する計算を担当するクラスがあって、中には渡された引数が奇数か偶数かを判別して、結果を標準出力する形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> simple.math;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Class Calculator {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">judge&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> number) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> number &lt;span style="color:#f92672">%&lt;/span>2 &lt;span style="color:#f92672">==&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(number &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;は偶数です&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(number &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;は奇数です&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをGoのコードに変えてみます。例えば以下のようになると思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">simple&lt;/span>.&lt;span style="color:#a6e22e">math&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Judge&lt;/span>(&lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">condition&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">condition&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">number&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;は偶数です&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">number&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;は奇数です&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見あまり変わらないように見えるかもしれませんが、細かいところが違うので注意しなければならないところがあります。いくらIDEの性能がよくなったとはいえ、その言語の仕様と全く違うようなコードを書いてしまっては、正しいコードを提示してくれませんので。例えばインポートは複数になると、以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;math&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pythonの場合も一行でimportをまとめたり、&lt;code>from&lt;/code>と&lt;code>as&lt;/code>でAliasを指定するようなことができたりもします。しかし、Goで根本的に違うのは、GoそのものがMavenやGradleのようなパッケージ管理もできるので、インポートにgithubのパッケージを描くこともできるということです。例えば以下のようなコードで、Goのウェブフレームワークである&lt;a class="link" href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener"
>Gin&lt;/a>をインポートすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;github.com/gin-gonic/gin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、変数を&lt;code>:=&lt;/code>を使って宣言する場合は、関数内でのみ可能であるので、パッケージレベルで宣言する場合は普通に&lt;code>var&lt;/code>を使う必要があるという仕様も理解する必要があったりします。そしてそれに対して、関数の引数としては&lt;code>var&lt;/code>宣言がいらなく、型を宣言する必要があります。どんな場合でも(初期化とともに&lt;code>var&lt;/code>を使うことは最近のJavaでも可能になりましたが)変数の型を書く必要のあるJavaとは大きく違うところですね。こういう細かい違いがあるので、Goの作法に対する理解なしでJavaの感覚のままコードを書くのは大変なことになるかもしれません。&lt;/p>
&lt;h3 id="大文字には機能がある">大文字には機能がある
&lt;/h3>&lt;p>会社ごとにルールは違うかと思いますが、今までの自分が経験では、言語がJavaであれJavaScriptであれ以下のようなルールで書く場合が多かったです。&lt;/p>
&lt;ul>
&lt;li>クラス、インタフェース名はPascalCase&lt;/li>
&lt;li>フィールド、メソッド、変数、引数はcamelCase&lt;/li>
&lt;/ul>
&lt;p>たまにPythonでコードを書く場合はsnake_caseだったり、URLはkebab-caseだったりもしたのですが、プライベートでも多くの場合このルールに従ってコードを書いています。そしてこれはあくまで人間が定めたルールなので、守らなくても&lt;/p>
&lt;p>しかし、GoではPascalCaseかcamelCaseかによって意味が変わる部分があります。正確には頭が大文字か小文字かによる違いですね。&lt;code>public&lt;/code>と&lt;code>private&lt;/code>の代わりになってくるのが、この仕様です。簡単に説明すると、&lt;code>他のパッケージからも参照できる&lt;/code>のは大文字から始まるフィールドや関数であり、そうでない場合は小文字から始まるものということです。&lt;/p>
&lt;p>例えば以下をみてください。&lt;a class="link" href="https://tour.golang.org" target="_blank" rel="noopener"
>A Tour of Go&lt;/a>で提示しているコードです。ここでは&lt;code>math&lt;/code>パッケージをインポートして、あらかじめ定義されてある&lt;code>π&lt;/code>を標準出力している例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;math&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">math&lt;/span>.&lt;span style="color:#a6e22e">pi&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、なんの問題もないかのように見えますが、実行すると以下のようなエラーメッセージが出力されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./prog.go:9:14: cannot refer to unexported name math.pi
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはつまり、外部から参照できないということですね。なので、正しいコードに変えると&lt;code>main&lt;/code>関数を以下のように直す必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">math&lt;/span>.&lt;span style="color:#a6e22e">Pi&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先端が大文字であり、外部から参照できるように定義された名前のことを&lt;a class="link" href="https://go-tour-jp.appspot.com/basics/3" target="_blank" rel="noopener"
>Exported Names&lt;/a>というらしいです。Goにはクラスがないので、パッケージをインポートして、そのパッケージ内に存在する&lt;code>.go&lt;/code>ファイルの中に&lt;code>Export Names&lt;/code>で定義された項目のみを参照することになります。なのでクラスを作って、そのクラスのインスタンスを生成し、小文字から始まるフィールドやメソッドを呼ぶというJavaの作法とは感覚が大きく違いますね。&lt;/p>
&lt;h2 id="ポインターの存在">ポインターの存在
&lt;/h2>&lt;p>プログラマーだと誰もが知っていることだと思いますが、ポインターがあるかどうかの問題は、コードを各感覚にかなりの影響を与えるようなものです。JavaやKotlinなど、ポインターがない言語ではクラスやメソッド間にただ、GoにはGCがあるので、CやC++のようなメモリー問題はないかとも思いますが、とにかく直接使ってみないとわからないところですね。&lt;/p>
&lt;p>もちろん、Javaでも&lt;code>public static&lt;/code>で宣言したり、Springだと&lt;code>Autowired&lt;/code>アノテーションをつけることでどこでもアクセスできるオブジェクトを作ることは可能です。Kotlinだと&lt;code>companion object&lt;/code>という、クラスに似たようなものをまず定義する必要がありますが、呼び出し元としてはJavaとあまり変わらないコードになりますね。&lt;/p>
&lt;p>しかし、こう言った&lt;code>static&lt;/code>なものは、JavaやKotlinだと&lt;code>定数&lt;/code>として使われるのが一般的です。&lt;code>Autowired&lt;/code>でも&lt;code>Singletone&lt;/code>と使い方はあまり変わらず、固定値を格納するか、常に同じ動作(&lt;code>冪等&lt;/code>に違い)をすることを期待するのが一般的ですね。それに比べ、ポインターはやはりその値を直接書き換えたりすることを期待する場合もあるので、やはり違うものです。&lt;/p>
&lt;p>まだ私はポインターを本格的に扱う言語に触れてみたことがなく、Goでもポインターを活用するようなコードは書いたことがあまりないので、ここで言えるのは上記で述べた内容だけですが、私と同じくポインターのない言語の経験しかない方にはやはり慣れるまで時間がかかるのではないかと思います。試行錯誤もかなりありそうですね。&lt;/p>
&lt;h2 id="例外処理が独特">例外処理が独特
&lt;/h2>&lt;p>Goで書かれてあるコードをみて、何が一番目立つかというと、例外処理の部分ではないかと思います。私が経験したことのある言語(Java、Python、JavaScript、TypeScript、Kotlin)では、例外処理のために&lt;code>try-catch&lt;/code>ブロックという仕様がありました。言語ごとに少しづつ違うところはありましたが、基本的に例外が発生しうる場所をそのブロックで囲んでから処理する、という発想自体は変わりがありません。例えば以下のようなコードで例外を処理することが一般的でしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> divide(1, 0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (e &lt;span style="color:#66d9ef">instanceof&lt;/span> ArithmeticException) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;0で分けません&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">divide&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> numerator, &lt;span style="color:#66d9ef">int&lt;/span> denominator) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> numerator &lt;span style="color:#f92672">/&lt;/span> denominator;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Goではそのような機能はありません。代わりに、どんな関数でも戻り値として&lt;code>期待する値&lt;/code>と&lt;code>発生したエラー&lt;/code>を定義し、呼び出し元では関数の実行結果としてエラーが発生したを確認して、エラーが発生していたら(エラーが&lt;code>nil&lt;/code>ではない場合)にそのエラーの対応をする、ということが一般的な作法のようです。言葉で説明すると難しいので、実際のコードをみていきましょう。上記のコードをGoの作法に合わせて書き直すと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">divide&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">divide&lt;/span>(&lt;span style="color:#a6e22e">numerator&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>, &lt;span style="color:#a6e22e">denominator&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span>) (&lt;span style="color:#66d9ef">int32&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">denominator&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">numerator&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#a6e22e">denominator&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;0で分けません&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、関数ではエラーが発生した場合にそれをそのまま返し(上記のコードでは、あえてエラーを作っていますが)、呼び出し元ではエラーがあったかどうかを確認して分岐します。こうすることで「エラーが発生した場所が明確になる」メリットがあるらしいです。確かに、&lt;code>try-catch&lt;/code>ブロックが囲んでいるコードが多ければ多いほど、例外が発生し得るコードがどれなのかわからなくなる場合もありますね。例外を処理するための機能が、例外を起こさないコードと混り、わけがわからなくなります。そういう観点からすると、Goのアプローチはエラーとロジックを分離できるというメリットがあると言えるでしょう。&lt;/p>
&lt;p>ただ、Goの作法では関数を呼び出す度に後続でエラーチェックが入るので、毎回同じ様なコードを書く場合があるのは少し違和感があります。例えば以下のようなコードを見かけるのですが、皆さんはどう思われるのでしょうか。もっとスマートな方法があって、自分が知らないだけなのかもしれませんが…&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// いくつかの関数を呼び出して処理をする関数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>() (&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 関数1を呼び出す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result1&lt;/span>, &lt;span style="color:#a6e22e">err1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">someFunction1&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 関数1でエラーが発生した場合はエラーを返却する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err1&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 関数1でエラーが発生していない場合は関数2を呼び出す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result2&lt;/span>, &lt;span style="color:#a6e22e">err2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">someFunction2&lt;/span>(&lt;span style="color:#a6e22e">result1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 関数2でエラーが発生した場合はエラーを返却する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err2&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 関数2でエラーが発生していない場合は関数2を呼び出す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result3&lt;/span>, &lt;span style="color:#a6e22e">err3&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">someFunction3&lt;/span>(&lt;span style="color:#a6e22e">result2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 関数3でエラーが発生した場合はエラーを返却する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err3&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 関数3でエラーが発生していない場合は関数2を呼び出す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">result4&lt;/span>, &lt;span style="color:#a6e22e">err4&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">someFunction4&lt;/span>(&lt;span style="color:#a6e22e">result3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 関数4でエラーが発生した場合はエラーを返却する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err4&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...続く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="コンパイラーが厳しい">コンパイラーが厳しい
&lt;/h2>&lt;p>コンパイルエラーが発生した場合はIDEで知らせてくれるので気にすることはあまりないかと思いがちですが、意外と気になるのはコンパイラーの厳しさです。個人的には&lt;code>jShell&lt;/code>の様なインタラクティブツールを使ってよくコードの検証をするのですが、GoにはそれがないのでVimで書いたコードをターミナルで動かしてみたり、&lt;a class="link" href="https://play.golang.org/" target="_blank" rel="noopener"
>The Go Playground&lt;/a>を使ってみています。そしてこういう方法ではIDEの様なサポートをあまり期待できませんので、コンバイルエラーになることが多かったです。&lt;/p>
&lt;p>ただ、コンパイルエラーといっても色々な原因がありますが、Goは特に他の言語と比べてもかなり厳しいのではないかと思います。例えば以下の様なコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ターミナルやThe Go Playgroundでこれを実行すると、以下の様なエラーメッセージが出ます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./prog.go:4:2: imported and not used: &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インポートしたパッケージが使われていないというエラーですね。さらに、以下の様なコードを実行したとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;this is test program&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードを実行した結果は、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./prog.go:8:9: result declared but not used
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回は&lt;code>result&lt;/code>という変数が使われてないというエラーです。この様に、Goでは使われてないインポートや変数などがあればエラーとなるので、他の言語と比べ厳しい方と言えますね。なので、プラグインなしのVimを使って修正するなどの場合には十分に気をつける必要がありますね。IDEでも少しはめんどくさいかもしれません。(リンティングと同時に使われてないパッケージや変数を削除してくれるとかの設定をすれば良いかもですが)&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>他にも細かい違いはまだまだ山ほどありますが、今の時点で言えるものはこのくらいです。ここで述べた、Javaプログラマーの観点からみたGoの特徴というものは、実は「慣れれば問題ない」だけなのかもしれません。しかし、「慣れる」ということは、「すでに慣れている」ものがあったらまたなかなか難しいものにもなりますね。&lt;/p>
&lt;p>例えば、人間の言語でいうと、同じ系列のドイツ語の話者が英語を学ぶのは簡単と言われていますが、それは二つの言語がよく似ているからですね。逆に&lt;a class="link" href="https://www.businessinsider.com/the-hardest-languages-to-learn-2014-5" target="_blank" rel="noopener"
>英語が母国語である人には中国語・日本語のような言語がもっとも難しい言語らしい&lt;/a>のですが、これは語彙、文字、文章構造の全てが違うのが原因だそうです。プログラミング言語も本質は人間の言語を模倣しているものなので、新しい言語を学ぶ際には、それが自分の母国語と言える言語と似ていれば似ているほど学びやすく、そうでない場合は難しく感じるものではないかと思います。そういう観点からすると、JavaからGoへの移行は、簡単そうで難しそうな側面があるかなという気がします。&lt;/p>
&lt;p>もちろん、世の中には元Javaプログラマーでも、Goの方が簡単だった！という方もたくさんいらっしゃるかと思います。ただ自分がついていけないだけなのかも…ですが。&lt;/p></description></item><item><title>JavaプログラマーがみたKotlin〜その二〜</title><link>https://retheviper.github.io/posts/kotlin-basics/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-basics/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post JavaプログラマーがみたKotlin〜その二〜" />&lt;p>この度は、転職することとなり、仕事で使われる言語もJavaからKotlinに変わることになりました。個人的にKotlinで簡単なSpring WebFluxプロジェクトを作ってみたことはあり、もともとJavaプログラマがKotlinへ移行するのは難しいことではないと言われてはいるものの、やはり仕事で使われる言語が変わるというのはかなりのチャレンジではあると思います。なので、今まではJavaに関してのポストを主に載せていたのですが、これからはKotlinに関してのポストを増やしていきたいと思います。&lt;/p>
&lt;p>まず、よく知られているように、KotlinはJavaと完璧な互換性を持つものです。それはJVM言語であり、コンパイルしたらJavaと同じくバイトコードになるからですね。ただ、だからと言って「Javaの感覚で」コードを書くということは、Kotlinという「違う言語」に移行する意味を無くす行為な気がします。なぜなら、Kotlinは触れば触るほどJavaとは根本的に違う考え方で設計されている言語だということが伝わってくるからです。最初はJavaの冗長さ(Verbose)を減らすことが第一の目標ではないかという印象を受けましたが、本格的に勉強を始めるとそれだけではないような気がしているのです。&lt;/p>
&lt;p>今回のポストは、&lt;a class="link" href="https://www.coursera.org" target="_blank" rel="noopener"
>Coursera&lt;/a>の&lt;a class="link" href="https://www.coursera.org/learn/kotlin-for-java-developers" target="_blank" rel="noopener"
>Kotlin for Java Developers&lt;/a>の講義の内容に基づいて作成されました。&lt;/p>
&lt;h2 id="冗長さを減らすということ">冗長さを減らすということ
&lt;/h2>&lt;p>Javaは今でも良い言語であり、多くの言語が発表されエンタープライズレベルで使われるようになった今でも、幅広い分野で使われていますね。Javaが依然としてよく使われる言語であることは、&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE index&lt;/a>やJetBrainsの&lt;a class="link" href="https://www.jetbrains.com/lp/devecosystem-2020" target="_blank" rel="noopener"
>The State of Developer Ecosystem&lt;/a>、Stackoverflowの&lt;a class="link" href="https://insights.stackoverflow.com/survey/2020" target="_blank" rel="noopener"
>Developer Survey&lt;/a>からも読み取れることです。&lt;/p>
&lt;p>ただ、Javaが依然として人気の言語だとしても、それは圧倒的にJavaが他の言語に比べ優秀だとか、使いやすい言語であるという意味ではないでしょう。どの言語でもそうであると思いますが、Javaでよく指摘されている問題の一つは、「冗長すぎる」というところです。数多くのライブラリがあり、MavenやGradleのような優秀なビルドツールを使えながらも、やはり言語の仕様は変わってないですからね。Java 9からはこの問題を解消するため、他の言語から影響を受けたような機能を多く導入していますが(例えば、&lt;a class="link" href="https://blogs.oracle.com/javamagazine/pattern-matching-for-instanceof-in-java-14" target="_blank" rel="noopener"
>instanceofのパターンマッチング&lt;/a>や&lt;a class="link" href="https://blogs.oracle.com/javamagazine/records-come-to-java" target="_blank" rel="noopener"
>record&lt;/a>など)、言語そのものの設計思想が変わるというよりは「違う言語の特徴をJavaに合わせた仕様で導入する」ことに近いので、根本的な変化とは言えないものです。なので今まで書かれている冗長なコードは残るもので、またこれからも使われることになるはずです。&lt;/p>
&lt;h3 id="コードが短くなる">コードが短くなる
&lt;/h3>&lt;p>冗長さを減らすということは、簡単にいうと「より短いコードで、同じ結果を得る」と定義できるでしょう。そういう観点からすると、KotlinはJavaの冗長さを減らすために工夫した痕跡が言語の仕様から感じ取れるようなものです。例えば以下のようなコードがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">updateWeather&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> degrees) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String description;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Color color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (degrees &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;cold&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#f92672">=&lt;/span> BLUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (degrees &lt;span style="color:#f92672">&amp;lt;&lt;/span> 25) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mild&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#f92672">=&lt;/span> ORANGE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#f92672">=&lt;/span> RED;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをKotlinで書き換えると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>description, color) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (degrees &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#e6db74">&amp;#34;cold&amp;#34;&lt;/span>, BLUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (degrees &amp;lt; &lt;span style="color:#ae81ff">25&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#e6db74">&amp;#34;mild&amp;#34;&lt;/span>, ORANGE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span>, RED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まず二つの変数を、戻り値が&lt;code>Pair&lt;/code>のオブジェクトの表現式でより短くできることがわかります。そしてこのコードは、&lt;code>when&lt;/code>句を使ってより短い形で変えることもできます。その結果が以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>description, color) = &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#e6db74">&amp;#34;cold&amp;#34;&lt;/span>, BLUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#ae81ff">25&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#e6db74">&amp;#34;mild&amp;#34;&lt;/span>, ORANGE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span>, RED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに&lt;code>Pair&lt;/code>は、&lt;code>to&lt;/code>を使うことでもっと簡単に表現することもできます。そうすると、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>description, color) = &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;cold&amp;#34;&lt;/span> to BLUE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#ae81ff">25&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mild&amp;#34;&lt;/span> to ORANGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span> to RED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最初のJavaのコードと比べ、かなり簡単かつ明瞭なコードになっているのがわかります。他の言語を使っていた人だとしても、一瞬ですぐに何をしているのかがわかって、より短く効率なコードになっているのがわかりますね。こういうところこそ、KotlinがJavaの冗長さ−無駄を減らすことに力を入れている部分ではないかと思います。&lt;/p>
&lt;h3 id="コードを簡単に書ける">コードを簡単に書ける
&lt;/h3>&lt;p>自分は最初、Kotlinの文法を簡単にみながら&lt;code>switch&lt;/code>がここでは&lt;code>when&lt;/code>に変わって、&lt;code>case&lt;/code>を書く必要がないんだな、くらいの印象しか受けてなかったです。しかし、よくよく見ると、他にもJavaと違うところが良く見えます。ここで読み取れるものは、例えばさっきのコードだと以下がありますね。&lt;/p>
&lt;ul>
&lt;li>&lt;code>when&lt;/code>句が表現式として使える&lt;/li>
&lt;li>&lt;code>when&lt;/code>句の条件の対象は条件式の中のみで良い&lt;/li>
&lt;li>表現式の中で複数の値を戻り値として定義し、それを&lt;/li>
&lt;li>&lt;code>to&lt;/code>で二つのオブジェクトを&lt;code>Pair&lt;/code>にまとめることができる&lt;/li>
&lt;/ul>
&lt;p>他にも、Javaの&lt;code>switch&lt;/code>に比べKotlinの&lt;code>when&lt;/code>句は以下のよう活用ができるというところもあります。オブジェクトの比較がより簡単ですね。例えば以下のようなコードで、簡単に二つのオブジェクトに対しても比較が可能になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">mix&lt;/span>(c1: Color, c2: Color) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (setOf(c1, c2)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(RED, YELLOW) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ORANGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(YELLOW, BLUE) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> GREEN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(BLUE, VIOLET) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> INDIGO
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> Exception(&lt;span style="color:#e6db74">&amp;#34;Dirty Color&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをあえてJavaのコードで書くとしたら、おそらく以下のようになるでしょう。個人的に、たくさんの&lt;code>else if&lt;/code>はあまり読みやすいコードではなく、書く立場としても綺麗ではないと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> Color &lt;span style="color:#a6e22e">mix&lt;/span>(Color c1, Color c2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (c1 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">RED&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">YELLOW&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Color.&lt;span style="color:#a6e22e">ORANGE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (c1 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">YELLOW&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">BLUE&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Color.&lt;span style="color:#a6e22e">GREEN&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (c1 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">BLUE&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">VIOLET&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Color.&lt;span style="color:#a6e22e">INDIGO&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Dirty Color&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、KotlinではJavaと同じことをするとしても、短いだけでなく、より簡単にコードをかけるということですね。もちろん、別のメソッドを作ったり、&lt;code>Comparable&lt;/code>なオブジェクトを作ったり、&lt;code>Comparator&lt;/code>クラスを実装することでJavaでも似たようなことはできるかもしれません。しかし、そこまでしたいかというと微妙ですね。&lt;/p>
&lt;p>もちろん、Java 12からはKotlinの&lt;code>when&lt;/code>に近い感覚でコードを書くこともできるようになっています。表現式としても使えて、複数の条件を指定することができ、&lt;code>Lambda&lt;/code>の感覚で書けるということも良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (month) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> JANUARY, JUNE, JULY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 3;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> FEBRUARY, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> MARCH, MAY, APRIL, AUGUST &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> monthLength &lt;span style="color:#f92672">=&lt;/span> month.&lt;span style="color:#a6e22e">toString&lt;/span>().&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> monthLength &lt;span style="color:#f92672">*&lt;/span> 4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような変化を見ると、この「冗長さを減らす」という面では、Javaもまたバージョンアップとともに新機能を次々と導入してきているので、Kotlinの魅力が半減しているように見えるかもしれません。しかし、Kotlinではもっと重要なポイントがまた一つあります。言語自体の拡張性です。&lt;/p>
&lt;h2 id="拡張ができるということ">拡張ができるということ
&lt;/h2>&lt;p>言語自体の拡張性と言いましたが、簡単にいうと、以前にも紹介したことのある拡張関数、つまり&lt;code>extension&lt;/code>のことです。Kotlinの仕様としてもこれは大きい部分として紹介されているものですね。これをよく使うと、ただ「継承しなくてもそのクラスにメソッドを追加できる」だけでなく、&lt;code>infix&lt;/code>と組み合わせることでまるで予約後であるように使うことができます。&lt;/p>
&lt;p>実際、&lt;a class="link" href="https://www.coursera.org/learn/kotlin-for-java-developers" target="_blank" rel="noopener"
>Kotlin for Java Developers&lt;/a>のコーディング問題では、&lt;code>infix&lt;/code>で書かれた以下の拡張関数を持って結果の確認を行っていると言われています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">infix&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">T&lt;/span>.eq(other: T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#f92672">==&lt;/span> other) println(&lt;span style="color:#e6db74">&amp;#34;OK&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;Error: &lt;/span>&lt;span style="color:#e6db74">$this&lt;/span>&lt;span style="color:#e6db74"> != &lt;/span>&lt;span style="color:#e6db74">$other&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>infix&lt;/code>を使うと、以下のようなコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;ABC&amp;#34;&lt;/span> eq &lt;span style="color:#e6db74">&amp;#34;ABC&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような特徴があるということは、使う側からしても便利ですが、これから言語そのもののバージョンアップにしたがってより便利な機能が追加され安いことにもなっていると思います。例えば先ほどの&lt;code>Pair&lt;/code>オブジェクトを作る&lt;code>to&lt;/code>が、このように&lt;code>infix&lt;/code>関数として作られているものです。これからもこういった便利な機能が追加され、追加しやすくなるのは確かに開発のコストの削減をという面でも良いことですね。&lt;/p>
&lt;h2 id="もう十分便利であること">もう十分便利であること
&lt;/h2>&lt;p>冗長さを減らし、拡張性がある言語だという特徴は、おそらくKotlinを作っているJetBrainsにとっても十分有効な特徴であるかと思います。Kotlinのスタンダードライブラリを見ると、すでに便利な関数が多く存在しています。例えば、簡単なループでは以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 一般的なfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (element &lt;span style="color:#66d9ef">in&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(element)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデックスを含むfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> ((index, element) &lt;span style="color:#66d9ef">in&lt;/span> list.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$index&lt;/span>&lt;span style="color:#e6db74">: &lt;/span>&lt;span style="color:#e6db74">$element&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデックスのみのfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (index &lt;span style="color:#66d9ef">in&lt;/span> list.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(index)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前もJavaのfor文の性能についてのポストで簡単に述べたことがありますが、そこではJavaならインデックスが必要な場合は伝統的なfor文を使い、そうではない場合は一般的に拡張for文を使った方がいいという結論をJMHでのベンチマークで出していました。しかし、こうやってすでに言語から便利な方法を提供していると、性能を気にすることなく便利な方法を取れるという面でも魅力的です。&lt;/p>
&lt;p>そして、forEachでもインデックスが必要であるなら、&lt;code>forEachIndexed&lt;/code>を使えるという良い点もあります。例えば、以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 一般的なforEach文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>list.forEach(&lt;span style="color:#f92672">::&lt;/span>println)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデックスを含むforEach文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>list.forEachIndexed { index, element &lt;span style="color:#f92672">-&amp;gt;&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$index&lt;/span>&lt;span style="color:#e6db74">: &lt;/span>&lt;span style="color:#e6db74">$element&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インデックスを簡単に取得できるということは、ループ対象のオブジェクトが持つ全インデックスを取得したい場合に、あえて&lt;code>0&lt;/code>のような、マジックナンバーにありえる数値を指定する必要がないというところでも良いですね。Javaだと毎回、static finalなフィールドとして宣言したり、別の定数として管理したりするケースが多いので…&lt;/p>
&lt;p>他にも、正規表現なしでも文字に関して簡単にチェックできる関数が事前に提供されているとか(&lt;code>Char.isLetter()&lt;/code>や&lt;code>Char.isDigit()&lt;/code>など)、&lt;code>Map&lt;/code>には&lt;code>Pair&lt;/code>で要素を入れることができるとか、iterableなオブジェクトからStream APIのような操作がすぐできるなど、確かにJavaに比べ「悩む必要がない」のが魅力的と思います。まぁ、人によってはこれはデメリットと認識する可能性もあるのでは、といは思いますが…&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>色々とKotlinの特徴・メリットについて述べましたが、こういう自分もまだ実際に業務でKotlinを使っているわけではないので、まだまだ表面的な知識のみに止まっていると思います。しかし、ここで紹介したことだけでも、Kotlinの魅力は感じ取れるのではないかと思います。&lt;/p>
&lt;p>言語自体も魅力的なのですが、他にもKotlinを扱うことで得られるメリットは多いです。例えば、JetBrainsが開発しているので、Intellijとの相性が良いこと。JVM言語でありJavaとの互換性があるので、Javaの発展をそのまま吸収できるということ。NativeやJavaScriptへのコンパイルもできるということ。他の言語も十分魅力的なポイントはありますが、Javaプログラマーであるなら、一度Kotlinに触れてみる価値はあると信じています。皆さんもまだKotlinに触れたことがないのであれば、この度ぜひ軽い気持ちで挑戦してみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>今更な文字列操作の話</title><link>https://retheviper.github.io/posts/java-string-concat-and-split/</link><pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-string-concat-and-split/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post 今更な文字列操作の話" />&lt;p>もうこれで3回目の、「今更なシリーズ」です。このシリーズ自体は、またベンチマークとともに戻ってきました。さて、今回のテーマはJavaによる文字列の操作となりますが、その中でも&lt;code>連結(Join)&lt;/code>と&lt;code>分割(split)&lt;/code>について述べたいと思います。最初は単純に、文字列の分割は&lt;code>String.split()&lt;/code>でやるしかないのに、連結の場合は&lt;code>String.join()&lt;/code>とか&lt;code>Collectors.joining()&lt;/code>とか、色々あるなと思ったのがきっかけです。同じことが複数のAPIでできるのは、単純に&lt;a class="link" href="https://ja.wikipedia.org/wiki/%e7%b3%96%e8%a1%a3%e6%a7%8b%e6%96%87" target="_blank" rel="noopener"
>シンタックスシュガー&lt;/a>な場合もありますが、実際は全く実装が違うケースもありますね。特に、Javaのように長い間使われてきた言語こそそのようなケースが多いかと思います。&lt;/p>
&lt;p>また、単純なシンタックスシュガーに近い場合でも、その前後のコードや可読性など、周りの様相を考慮して適切なものを選ぶ必要がある場合もあります。例えば、以前紹介したInputStreamの&lt;code>transferTo()&lt;/code>がそのようなケースですね。なので、一つのAPIを使う場合は、できればその実装がどうなっているかを確認してみるのも、良いコードを書くための工夫となるのではないかと思います。&lt;/p>
&lt;p>ではでは、早速本題に入りましょう。まずは文字列の連結からです。&lt;/p>
&lt;h2 id="concatenating">Concatenating
&lt;/h2>&lt;p>文字列の連結といっても、色々なケースがありますね。そしてそういった場合は、&lt;code>String.concat()&lt;/code>、&lt;code>String.format()&lt;/code>などさまざまな方法があって、それら全部に対してシナリオを想定し検証するということは難しいと思います。なので今回は、「文字列の配列もしくはCollectionを、区切り文字でつないで一つの文字列にする」というケース一つに限定して述べたいと思います。&lt;/p>
&lt;p>Javaでの区切り文字を使った文字列の連結には、主に以下のような方法が考えられます。これら一つ一つのAPIの特徴と、実際の使い方を持って比較して見た後、いつもの通りベンチマークをするということで性能を測定することとします。(&lt;code>+&lt;/code>を使って文字列を繋ぐケースは、あまりよろしくないと思うのでケース外としています)&lt;/p>
&lt;ul>
&lt;li>&lt;code>String.join()&lt;/code>&lt;/li>
&lt;li>&lt;code>StringJoiner&lt;/code>&lt;/li>
&lt;li>&lt;code>StringBuffer&lt;/code>&lt;/li>
&lt;li>&lt;code>StringBuilder&lt;/code>&lt;/li>
&lt;li>&lt;code>Collectors.joining()&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="stringbuffer--stringbuilder">StringBuffer || StringBuilder
&lt;/h3>&lt;p>純粋に、Collectionや配列になっている複数の文字列を連結する場合もあるとは思いますが、普通、文字列の連結が必要となる場合では、「とある規則によって」という条件がつくケースが多いかなと思います。例えば、ダッシュ(-)、アンダースコア(_)、カンマ(,)などで並ぶようにですね。そしてこのような規則がある場合、&lt;code>StringBuffer&lt;/code>や&lt;code>StringBuilder&lt;/code>を使った方法は他と比べて少し不利です。なぜなら、最後に区切り文字(delimiter)が付かないように制御するにはかなりコードの書き方に注意しなければならないからです。以下のコードが、そのようなケースです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// StringBufferを使う例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String delimiter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringBuffer buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuffer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listの要素と区切り文字を足す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String string : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(delimiter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> buffer.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// A, B, C,&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あえて、文字列の末尾に区切り文字が付かないようにするとしたら、おそらくこういうコードを書く必要があるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String delimiter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> limit &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringBuffer buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuffer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listの要素と区切り文字を足す(最後のインデックスの前まで)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> limit; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(list.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(delimiter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 最後の要素を足す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>buffer.&lt;span style="color:#a6e22e">append&lt;/span>(list.&lt;span style="color:#a6e22e">get&lt;/span>(limit));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> buffer.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// A, B, C&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こういう問題があるのに比べて、他の方法(&lt;code>String.join()&lt;/code>、&lt;code>StringJoiner&lt;/code>、&lt;code>Collectors.joining()&lt;/code>)は、区切り文字が最後の要素の後に付かないので、よりシンプルなコードで書けるというメリットがありますね。なので、結論として&lt;code>StringBuffer&lt;/code>や&lt;code>StringBuilder&lt;/code>は、少なくとも「とある規則によって」複数の文字列を連結する場合には可読性という観点からしてあまり良い選択肢ではないということがわかります。&lt;/p>
&lt;h3 id="stringjoiner">StringJoiner
&lt;/h3>&lt;p>&lt;code>StringBuffer&lt;/code>と&lt;code>StringBuilder&lt;/code>ではループで文字列を連結して行くので、ループの中で条件分岐など他の処理も必要な場合に使えるのでは？と思われるかもしれません。しかし、そういう場合でも、&lt;code>StringJoiner&lt;/code>を使ったほうが良いですね。なぜなら、使い方はほぼ変わらなく、特に操作をしなくても常に末尾に区切り文字が付かないからです。以下は、&lt;code>StringJoiner&lt;/code>のもっともベーシックな使い方のコードとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 区切り文字を指定してインスタンスを作る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringJoiner joiner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringJoiner(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// あとは要素を足していく&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String string : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> joiner.&lt;span style="color:#a6e22e">add&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> joiner.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// A, B, C&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>StringJoiner&lt;/code>を使った場合は、PrefixとSuffixの指定も可能です。これらを指定した場合、文字列の先頭と末尾に指定したPrefixとSuffixが付くようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 区切り文字とPrefix、Suffixまで指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringJoiner joiner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringJoiner(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;[&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;]&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String string : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> joiner.&lt;span style="color:#a6e22e">add&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> joiner.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// [A, B, C]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使い方だけ見ても、区切り文字を持って文字列を繋ぐ場合は&lt;code>StringBuffer&lt;/code>や&lt;code>StringBuilder&lt;/code>より&lt;code>StringJoiner&lt;/code>の方がより簡単であるということが分かります。&lt;/p>
&lt;h4 id="番外stringjoinerの実装">番外：StringJoinerの実装
&lt;/h4>&lt;p>ついでに、StringJoinerはどんなコードで書かれているかを見ていきたいと思います。まずは&lt;code>add()&lt;/code>ですが、これは面白くも、&lt;code>ArrayList&lt;/code>の実装と似たような感じになっています。&lt;code>StringJoiner&lt;/code>クラスはフィールドとして&lt;code>String[]&lt;/code>を持っていて、&lt;code>add()&lt;/code>がよばれる度にそれより大きいコピーを作っていく形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> StringJoiner &lt;span style="color:#a6e22e">add&lt;/span>(CharSequence newElement) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String elt &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">valueOf&lt;/span>(newElement);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (elts &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elts &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">[&lt;/span>8&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">==&lt;/span> elts.&lt;span style="color:#a6e22e">length&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elts &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">copyOf&lt;/span>(elts, 2 &lt;span style="color:#f92672">*&lt;/span> size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len &lt;span style="color:#f92672">+=&lt;/span> delimiter.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len &lt;span style="color:#f92672">+=&lt;/span> elt.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elts&lt;span style="color:#f92672">[&lt;/span>size&lt;span style="color:#f92672">++]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> elt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして&lt;code>toString()&lt;/code>では、フィールドの&lt;code>String[]&lt;/code>をループしながら、区切り文字とともに繋げて行くのが分かります。少し変わっているのは、性能を意識しているからか、&lt;code>char[]&lt;/code>として文字列をつめた後から新しく&lt;code>String&lt;/code>のインスタンスを作って返しているというところですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">toString&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span> elts &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elts&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (elts &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> emptyValue &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> emptyValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> addLen &lt;span style="color:#f92672">=&lt;/span> prefix.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> suffix.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (addLen &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compactElts();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> size &lt;span style="color:#f92672">==&lt;/span> 0 &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> : elts&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String delimiter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delimiter&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> chars &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[&lt;/span>len &lt;span style="color:#f92672">+&lt;/span> addLen&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> getChars(prefix, chars, 0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+=&lt;/span> getChars(elts&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>, chars, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+=&lt;/span> getChars(delimiter, chars, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+=&lt;/span> getChars(elts&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>, chars, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+=&lt;/span> getChars(suffix, chars, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> String(chars);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="stringjoin">String.join()
&lt;/h3>&lt;p>&lt;code>String.join()&lt;/code>は、&lt;code>InputStream.transferTo()&lt;/code>のように、あくまでシンタックスシュガーとして存在するものだと言えます。以下は実際のコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">join&lt;/span>(CharSequence delimiter,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Iterable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> CharSequence&lt;span style="color:#f92672">&amp;gt;&lt;/span> elements) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(delimiter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(elements);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringJoiner joiner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringJoiner(delimiter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (CharSequence cs: elements) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> joiner.&lt;span style="color:#a6e22e">add&lt;/span>(cs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> joiner.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>引数に対するNullチェック以外は、Prefix・Suffixなしの&lt;code>StringJoiner&lt;/code>での連結になっているということを確認できます。なので、より短いコードを書きたい場合は&lt;code>StringJoiner&lt;/code>を使うよりも、こちらの方が便利ではありますね。&lt;/p>
&lt;h3 id="collectorsjoining">Collectors.joining()
&lt;/h3>&lt;p>文字列の連結で&lt;code>Stream&lt;/code>を利用する場合、他にも&lt;code>filter()&lt;/code>、&lt;code>map()&lt;/code>、&lt;code>peek()&lt;/code>など、さまざまな処理をメソッドチェイニングで書けるというところが魅力的ですね。個人的には、処理の役割と目的・影響範囲が明確に見えるので、&lt;code>Stream&lt;/code>による処理を好んで使っています。ただ、以前のポストでも書いたことがありますが、多くの場合に&lt;code>Stream&lt;/code>は伝統的なループより性能面で不利ですので、時と場合によって適切に選ぶべきでしょう。&lt;/p>
&lt;p>さて、そんな&lt;code>Stream&lt;/code>ですが、中の実装はどうなっているのでしょうか。&lt;code>Collectors.joining()&lt;/code>の場合、以下のような実装となっています。結局は、&lt;code>StringJoiner&lt;/code>を内部で使っているだけですので、&lt;code>String.join()&lt;/code>・&lt;code>StringJoiner&lt;/code>と比べては、&lt;code>Stream&lt;/code>によるコードの変化や性能に影響されるだけと言えるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Collector&lt;span style="color:#f92672">&amp;lt;&lt;/span>CharSequence, &lt;span style="color:#f92672">?&lt;/span>, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">joining&lt;/span>(CharSequence delimiter,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CharSequence prefix,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CharSequence suffix) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CollectorImpl&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringJoiner(delimiter, prefix, suffix),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringJoiner::add, StringJoiner::merge,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringJoiner::toString, CH_NOID);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="tostring">toString()
&lt;/h3>&lt;p>実は、Collectionの場合(&lt;code>List&amp;lt;String&amp;gt;&lt;/code>)は、もっと簡単に文字列を作る方法がありますね。&lt;code>toString()&lt;/code>を呼ぶことで、簡単にカンマ区切りの文字列が出来上がります。ただ、そうして文字列を作った場合、先頭と末尾に&lt;code>[]&lt;/code>が入ってしまうので、場合によってはそれらを取り消すか、&lt;code>substring()&lt;/code>で抽出するかの追加的な処理が必要となりますね。以下は、&lt;code>substring()&lt;/code>を利用して&lt;code>[]&lt;/code>の中の文字列だけを切り取るサンプルとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String toString &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// [A, B, C]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> toString.&lt;span style="color:#a6e22e">substring&lt;/span>(1, toString.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1); &lt;span style="color:#75715e">// A, B, C&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、もし区切り文字がカンマではない場合は、とりあえず&lt;code>toString()&lt;/code>で文字列に変換した結果の文字列から、更に&lt;code>replace()&lt;/code>を呼び出し、区切り文字だけを入れ替えるというやり方でも対応はできます。ただ、これは非常に非効率的なやり方ではあります。なぜなら、&lt;code>replace()&lt;/code>のコードをみると、結局はループの中で&lt;code>StrinbBuilder&lt;/code>を使って新しく作り出すような構造となっているからです。実際のコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">replace&lt;/span>(CharSequence target, CharSequence replacement) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String tgtStr &lt;span style="color:#f92672">=&lt;/span> target.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String replStr &lt;span style="color:#f92672">=&lt;/span> replacement.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> indexOf(tgtStr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (j &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> tgtLen &lt;span style="color:#f92672">=&lt;/span> tgtStr.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> tgtLen1 &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(tgtLen, 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> thisLen &lt;span style="color:#f92672">=&lt;/span> length();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> newLenHint &lt;span style="color:#f92672">=&lt;/span> thisLen &lt;span style="color:#f92672">-&lt;/span> tgtLen &lt;span style="color:#f92672">+&lt;/span> replStr.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (newLenHint &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> OutOfMemoryError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder(newLenHint);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sb.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, i, j).&lt;span style="color:#a6e22e">append&lt;/span>(replStr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">=&lt;/span> j &lt;span style="color:#f92672">+&lt;/span> tgtLen;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (j &lt;span style="color:#f92672">&amp;lt;&lt;/span> thisLen &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (j &lt;span style="color:#f92672">=&lt;/span> indexOf(tgtStr, j &lt;span style="color:#f92672">+&lt;/span> tgtLen1)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sb.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, i, thisLen).&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>少なくとも区切り文字がカンマではない場合は、&lt;code>toString()&lt;/code>と&lt;code>replace()&lt;/code>での文字列の生成よりは、他の方法をとったほうが性能面では有利ではないか、という推測が可能です。もちろん、要素数という変数があるので、実際の性能は測ってみないとわからないものですが…&lt;/p>
&lt;h3 id="ベンチマークしてみる1">ベンチマークしてみる(1)
&lt;/h3>&lt;p>では、文字列を連結するために使える色々なAPIと、その特徴を簡単に把握できたので、次に確認したいのは、やはり性能です。特に気になるのは、&lt;code>String.join()&lt;/code>や&lt;code>Collectors.joining()&lt;/code>でも結局は内部で&lt;code>StringJoiner&lt;/code>を使っているというところです。それはつまり、&lt;code>StringBuffer&lt;/code>や&lt;code>StringBuilder&lt;/code>よりも&lt;code>StringJoiner&lt;/code>が性能で有利だから、でしょうか。&lt;/p>
&lt;p>これらのAPIを利用して、実際のアプリケーションに使われるビジネスロジックのコードを書く立場としては、それはコードを簡単に書ける方が良いのは当然ですが、そもそもこういうAPIの場合は、手間を省けるために性能は良くても複雑なコードで実装する可能性もあるのですので、疑問になります。しかも、多くの場合、文字列の操作では&lt;code>StringBuilder&lt;/code>が早いと言われていますので、ますます性能差というのが気になってきます。なので、いつもの通りにベンチマークを実施してみました。&lt;/p>
&lt;p>ベンチマークは、カンマ区切りで文字列を連結する例として作成しています。以下がそのコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Benchmark&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StringConcatTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String DELIMITER &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> DecimalFormat format &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;0000000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span> &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 1000000).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> format.&lt;span style="color:#a6e22e">format&lt;/span>(i)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String toString &lt;span style="color:#f92672">=&lt;/span> target.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(toString.&lt;span style="color:#a6e22e">substring&lt;/span>(1, toString.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stringJoin&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(String.&lt;span style="color:#a6e22e">join&lt;/span>(DELIMITER, target));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">collectorsJoining&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(target.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">joining&lt;/span>(DELIMITER)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stringBuffer&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> StringBuffer buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuffer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> limit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> limit; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(DELIMITER);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(limit));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(buffer.&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stringBuilder&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> StringBuilder builder &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> limit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> limit; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builder.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builder.&lt;span style="color:#a6e22e">append&lt;/span>(DELIMITER);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builder.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(limit));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(builder.&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、結果は以下の通りです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StringConcatTest.toString thrpt 25 41.445 ± 0.461 ops/s
StringConcatTest.stringJoin thrpt 25 28.396 ± 0.447 ops/s
StringConcatTest.collectorsJoining thrpt 25 31.024 ± 1.313 ops/s
StringConcatTest.stringBuffer thrpt 25 30.570 ± 1.205 ops/s
StringConcatTest.stringBuilder thrpt 25 45.965 ± 1.736 ops/s
&lt;/code>&lt;/pre>&lt;p>この結果からわかるのは、やはり&lt;code>StringBuilder&lt;/code>の性能は優秀ということですね。ただ、よく知られているように、&lt;code>StringBuilder&lt;/code>はマルチスレッドを考慮したAPIではないので、スレッドセーフなAPIを使う必要のある環境であるなら、他のAPIを考慮すべきですね。そのような観点からすると、意外と、誤差範囲を踏まえて考えると&lt;code>String.join()&lt;/code>が&lt;code>Collectors.joining()&lt;/code>と大差ない性能を見せるという結果となりましたが…このような結果だとすると、気軽に&lt;code>Stream&lt;/code>を使っても良さそうな気がします。&lt;/p>
&lt;p>また、&lt;code>toString()&lt;/code>の結果は、やはり早いものとなっていますが、ここで&lt;code>replace()&lt;/code>を挟んだ瞬間性能は半分以下という結果となっています。なので、無理して&lt;code>toString()&lt;/code>を使う必要はあまりないかな、と思いますね。文字列の連結という目的に合うコードかどうかもすぐわからないし…&lt;/p>
&lt;p>もう一つ確かなのは、&lt;code>StringBuffer&lt;/code>はもう使わなくても良さそうということですね。もうレガシーなコードとして残しておいて、これからはなるべく違うAPIを使うべきなのではないかと思います。&lt;/p>
&lt;h2 id="split">Split
&lt;/h2>&lt;p>次に検証したいのは、文字列の分割です。先に述べたのように、文字列の分割は実質、&lt;code>String.split()&lt;/code>しかない状態と言えますね。&lt;code>substring()&lt;/code>でもなんとか分割はできるかもしれませんが、その場合はループと条件分岐なしでは話にならないので、そもそも論外かと思います。&lt;/p>
&lt;p>ただ、ここで注目したいのは分割した後のことです。&lt;code>String.split()&lt;/code>の戻り値は&lt;code>String[]&lt;/code>なので、場合によって&lt;code>Collection&lt;/code>に変えたくなりますね。なので、どちらかというと「配列をListに」する方法の検証ということとなりますが…とりあえずListをStringに変えてみたので、その逆の場合を考えてみるということで受け止めてくださると幸いです。&lt;/p>
&lt;h3 id="arraysaslist">Arrays.asList()
&lt;/h3>&lt;p>配列をListに変えるもっとも簡単な方法は、&lt;code>Arrays.asList()&lt;/code>だと思います。コードも簡単ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A, B, C&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// まずは分割する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> array &lt;span style="color:#f92672">=&lt;/span> string.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listに変える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(array);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうやって生成したListのインスタンスは、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%9F%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB" target="_blank" rel="noopener"
>Immutable&lt;/a>となってしまいます。中の要素を操作できないということですね。&lt;/p>
&lt;p>もちろん、これは新しいListのインスタンスに要素をコピーすることで解決できます。もっとも簡単なのは、コンストラクタの引数としてListを渡す方法ですね。なので、「配列をMutableなListにする」もっとも簡単な方法は、おそらく以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A, B, C&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// まずは分割する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> array &lt;span style="color:#f92672">=&lt;/span> string.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listに変える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(array);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// MutableなListのインスタンスを作成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> mutableList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(list);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="arraysstream">Arrays.stream()
&lt;/h3>&lt;p>配列をListにするまたの方法は、&lt;code>Stream&lt;/code>を利用することです。文字列の連結でも言及したことなのですが、&lt;code>Stream&lt;/code>の場合は、&lt;code>map()&lt;/code>や&lt;code>filter()&lt;/code>のような中間操作のメソッドを使えるというメリットがありますね。また、&lt;code>Collectors&lt;/code>のどのメソッドを呼ぶかによって結果として生成されるListがImmutableか、Mutableかを決定できるという面もメリット(可読性という観点で)ではないのかと思います。コードは&lt;code>Arrays.asList()&lt;/code>と比べて少し複雑になっているように見えるかもしれませんが。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A, B, C&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// まずは分割する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> array &lt;span style="color:#f92672">=&lt;/span> string.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listに変える(Mutable)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> mutableList &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(array).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listに変える(Immutable)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> mutableList &lt;span style="color:#f92672">=&lt;/span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>(array).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toUnmodifiableList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ベンチマークしてみる2">ベンチマークしてみる(2)
&lt;/h3>&lt;p>では、次にまたベンチマークとなります。コード自体は明らかに&lt;code>Arrays.toList()&lt;/code>の方が簡単だったのですが、MutableなListを作るためにはListを生成した後にさらにインスタンスを作成する必要があるということで、性能面で損する可能性もあるのかなという気がします。なので、以上で紹介した&lt;code>Arrays.asList()&lt;/code>と&lt;code>Stream&lt;/code>によるListのインスタンスの作成を、Immutable・Mutableという二つのケースに分けて検証してみました。以下がそのベンチマークのコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Benchmark&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StringSplitTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String DELIMITER &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> DecimalFormat format &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;0000000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span> &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 1000000).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> format.&lt;span style="color:#a6e22e">format&lt;/span>(i)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">joining&lt;/span>(DELIMITER));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">arraysAsListImmutable&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(target.&lt;span style="color:#a6e22e">split&lt;/span>(DELIMITER)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">arraysAsListMutable&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(target.&lt;span style="color:#a6e22e">split&lt;/span>(DELIMITER))));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">streamCollectImmutable&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(target.&lt;span style="color:#a6e22e">split&lt;/span>(DELIMITER)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toUnmodifiableList&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">streamCollectMutable&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(target.&lt;span style="color:#a6e22e">split&lt;/span>(DELIMITER)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして結果は以下の通りです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StringSplitTest.arraysAsListImmutable thrpt 25 8.316 ± 1.085 ops/s
StringSplitTest.arraysAsListMutable thrpt 25 8.133 ± 0.435 ops/s
StringSplitTest.streamCollectImmutable thrpt 25 6.086 ± 0.312 ops/s
StringSplitTest.streamCollectMutable thrpt 25 7.247 ± 0.262 ops/s
&lt;/code>&lt;/pre>&lt;p>ここでは、&lt;code>Arrays.asList()&lt;/code>の方が、性能が高い結果となっていますね。途中で何かしらの操作が必要な場合は&lt;code>Stream&lt;/code>の方が良いかと思いますが、そうではなく、単純に配列をListに変えたい場合はやはり&lt;code>Arrays.AsList()&lt;/code>を使った方がコードもより簡単で、性能面でも少し優勢ということがわかりました。なので、(いつもそうですが)何をしたいかによって適切なコードを選ぶべきかんと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>他にも、文字列の操作に関しては&lt;a class="link" href="https://www.baeldung.com/java-string-performance" target="_blank" rel="noopener"
>Baeldungさんの記事&lt;/a>がかなり良かったので、皆さんにもおすすめしたいと思います。最近は特に、アプリケーションでもっともよく扱うデータ型が文字列となっているので、文字列の操作に関してはなるべく性能と可読性という観点から良い書き方を取りたいものです。個人的には&lt;code>Stream&lt;/code>が大好きなので、なるべくなんでも&lt;code>Stream&lt;/code>で解決したいものですが…Javaだけでなく、プログラミング言語にとって「どんなケースでも正解」というものはないので。&lt;/p>
&lt;p>しかし、Javaに触れてからもう3年も過ぎていますが、今更こんなことを考えるということが恥ずかしい限りですね…次からは、もっと興味深い(そしてこのブログを読まれる方々にも役立つような)ネタを探したいと思います。うまくいくかは少しわからない状態なのですが…！&lt;/p></description></item><item><title>個人的な2021年のロードマップ</title><link>https://retheviper.github.io/posts/my-roadmap-in-2021/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/my-roadmap-in-2021/</guid><description>&lt;img src="https://retheviper.github.io/images/map.webp" alt="Featured image of post 個人的な2021年のロードマップ" />&lt;p>エンジニアとして働いていると会社の方針・クライアントの要求・経歴のような、自分の意思以外のところから自分の技術スタックを決まってしまう場合が決して少なくないと思います。会社は利益集団なので、致し方ないのですが、個人としてはどうでしょうか。私は、エンジニアは常にトレンドとともに前に進むべき職種なので、業務としてはあまり機会がないとしても、やはり自分で何かロードマップを立てて、独学でもスキルアップを図るべきたと思っています。&lt;/p>
&lt;p>例えば私は、どんな案件でも主にJavaとSpringのサーバサイドエンジニアか、Jenkins・Shell・Linuxを触るインフラエンジニアとして働いたことが多いのですが、何か一つは自分のアプリやサービスを作ってみたいと思っています。このような目標ないしは願望がある場合、それを成すためには何が必要か、と考えるようになり、そこから適合なプラットフォームは？言語は？フレームワークは？という風に考え始めて、そのうちでもっとも自分にとって合理的な道を選ぶようになります。何が合理的か、という基準は人それぞれですが(主観だけで決められるものでもないし)、会社が自分のエンジニアとしての目標を考えてくれる可能性は低いので、とにかくこういう目標設定は自分でなすべきでしょう。&lt;/p>
&lt;p>そういう意味で、今年の自分のロードマップを、「やりたいこと」と「良さそうなこと」という基準からいくつか立ててみました。まだロードマップとしては何一つ計画を具体化してないので、ただの興味に近いものなのかもしれませんが…とにかく、今の時点で興味を持っているものや考えていることについて、Google Trendを持って語ります。軽く、「こいつは2021年にこういうものに注目するんだな」と思ってください。&lt;/p>
&lt;h2 id="言語">言語
&lt;/h2>&lt;h3 id="typescript">TypeScript
&lt;/h3>&lt;p>いつまでになるかはわかりませんが、少なくともここ数年はJavaScriptの天下が続きそうですね。ただ、なぜそうかというと、Webの標準であるという強力な基盤がある上に、今はNode.jsやElectronのおかげでブラウザ以外でも使える場面が多いから、ということだけでは説明が難しくなりつつあるという側面もある印象です。今はもはやコーディングを学び始めるきっかけや入門の言語としてJavaScriptに触れるケースが多いし、SPAの登場以来からサーバサイドよりもフロントエンドの重要さが増してきたという感覚でもありますね。アプリケーションというのは、結局はユーザのためにデザインされるものであるということを考えると、より画面に密接な言語が持つ権限の方が大きくなるのは当然なのかもしれません。&lt;/p>
&lt;p>そしてバックエンドだけをみるとしても、最近はなるべくサーバサイドの役割を減らしていくか、細かく分けていく感覚ですね。&lt;a class="link" href="https://www.redhat.com/ja/topics/microservices" target="_blank" rel="noopener"
>マイクロサービス&lt;/a>、&lt;a class="link" href="https://www.atmarkit.co.jp/ait/articles/1803/12/news012.html" target="_blank" rel="noopener"
>BFF&lt;/a>、サーバレスのようなキーワードが流行っているのがその証拠だと思います。もちろんJavaScriptという言語そのものの発達によるものもあるとは思いますが、アプリケーションのアーキテクチャやデザインの思想そのものが変わっているので、仕方ないことです。&lt;/p>
&lt;p>そこで、少なくともJavaScriptは基礎だけでもできるようにしないと、と思いました。研修などで簡単な文法については学んだことがありますが、本格的なアプリを書いた経験はあまりなかったので、少なくとも&lt;a class="link" href="https://expressjs.com" target="_blank" rel="noopener"
>Express&lt;/a>で簡単なREST APIを作ってみるとかの経験はかなり役立つかもしれません。また、フロントエンドも少しは触れるようになるとよりいいでしょう。&lt;/p>
&lt;p>このように思ったときに、目に入ってきたのがTypeScriptでした。TypeScriptは以前、Udemyの講座で接したことがあり、気に入っていましたが、最近はかなり人気を得ているらしいですね。実際どうかは、まずGoogle Trendで確認してみました。&lt;/p>
&lt;script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2431_RC04/embed_loader.js">&lt;/script>&lt;script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"typescript","geo":"","time":"today 5-y"}],"category":0,"property":""}, {"exploreQuery":"date=today%205-y&amp;q=typescript","guestPath":"https://trends.google.com:443/trends/embed/"}); &lt;/script>
&lt;p>結果をみると、確かにTypeScriptに対する興味は日々増えていっているような気がします。おそらくAngular・React・Vueのような有名フレームワークやライブラリからTypeScriptに公式対応し始めたのも理由と思いますし、やはり静的型付けの方が生産性が上がるというところがわかったきたからなのでしょう。私はJavaから触れた人間なので、静的型付けのできるTypeScriptの方を学んだ方が良いかなと思います。&lt;/p>
&lt;h3 id="go-or-rust">Go or Rust
&lt;/h3>&lt;p>個人的には、JVM言語が好きですが、やはり高水準言語&amp;amp;VMを挟む構造ということもあり、より低水準に近い言語も扱ってみたいと思っています。今すぐに必要なわけではないのですが、やはりハードウェア制御やバイナリデータを扱うなど、低水準言語ならではのことがやってみたいという純粋な好奇心が理由です。最近はIOTなどでC言語の人気も高くなっていたりしますが、組み込み系ならまだしも、いわゆる「応用ソフトウェア」を開発する身としては、CやC++、もしくはそれよりも古い言語よりは、GoやRustのような言語に触れてみた方が良さそうな気もします。&lt;/p>
&lt;p>ただ、悩ましいのは、それでGoとRustのうち、どれを選ぶかということです。性能だけを考えたら、当然Rustなのかもしれません。多くの場合、Rustが性能ではGoより優れていると言われていますね。実際の例として、音声チャットツールで有名な&lt;a class="link" href="https://discord.com/" target="_blank" rel="noopener"
>Discord&lt;/a>はGoからRustに移行しましたが、これが&lt;a class="link" href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f" target="_blank" rel="noopener"
>性能のため&lt;/a>だったと言っています。ただ、言語を学ぶこと自体の難易度は、やはりRustの方がGoより高いらしいですね。そして一般的に、生産性の方はGoが優れていると言われています。&lt;/p>
&lt;p>なので、以上のことから、自分は何をやってみたらいいのかなと思ってみた結果、CやC++に近い低水準言語の感覚としてRustを触ってみたらどうかな、と思いました。どちらもマイナーな言語ではありますが、&lt;a class="link" href="https://insights.stackoverflow.com/survey" target="_blank" rel="noopener"
>Stack Overflow survey&lt;/a>にて、数回も「もっともエンジニアから愛された言語」として選ばれたこともあるRustの方が、これからコミュニティの成長も期待できるのではないかなと思ったからでもあります。特に&lt;a class="link" href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved" target="_blank" rel="noopener"
>2020年の結果&lt;/a>は、86.1%というすごい結果になっているくらいですので。&lt;/p>
&lt;p>しかし、まだ実務レベルでよく使われているのはやはりGoの方で、リファレンスの量やエンジニアの興味という面でも(仕事で使うとしたら仕方ないのですが)、Goの方がまだ少し優勢ではないのかという気もします。Rustが最初からCやC++の代替を目標としてデザインされた言語であることに比べ、Goという言語がどこまでそのような役割ができるのかというのはまだあまりわかってないのですが、もし同じようなことできるのであれば、あえてRustにこだわる必要はないのではないかと思ったりもしますね。特に、ある言語の成長性というのは、そのコミュニティの大きさにも関係するので…なので、とりあえずGoogle Trendの方で、二つの言語に対する興味度について調べてみました。&lt;/p>
&lt;p>Goの場合は一般動詞(行く)と区別するため、多くの場合&lt;code>golang&lt;/code>で検索するケースが多いらしいです。しかし、Rustもあまり状況は変わってなくて(しかも、ゲーム名としても使われているようですね)、&lt;code>rustlang&lt;/code>という検索語はあまり使われてないと思うので、直接的な比較が難しいですね。なので、なるべく価値中立的なキーワードとして、&lt;code>go programming&lt;/code>と&lt;code>rust programming&lt;/code>を選んでみました。そしてその結果が、以下です。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "go programming", geo: "", time: "today 5-y" },
{ keyword: "rust programming", geo: "", time: "today 5-y" },
],
category: 0,
property: "",
},
{ exploreQuery: "date=today%205-y&amp;q=go%20programming,rust%20programming", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>結果だけをみると、やはりRustの方がすごい人気を得ているように見えますが、まだGoの方が優位にはありますね。なので、こちらの方が(急ぎでもないので)、もう少し観望しながら、ゆっくり決めようと思っています。&lt;/p>
&lt;h3 id="kotlin">Kotlin
&lt;/h3>&lt;p>今はJavaのいう&lt;code>Write once, run everywhere&lt;/code>が、どの言語でも同じようなことができていて(逆にJavaでできない分野はありますが)、それでもJVM言語は依然として魅力的だと思っています。最初からJVMがヒープを設定するのでメモリ管理という面でも安定的で、パフォーマンスも今流行りの高水準言語に比べても優秀な方ですね。また、10年以上世界でもっとも人気な言語だったので、ライブラリ・フレームワーク・リファレンスも豊富ですね。また、バイトコードだけを生成すればいいので、コンパイルする前の言語はどれでも良いです。なのでJava以外でも&lt;a class="link" href="https://www.scala-lang.org" target="_blank" rel="noopener"
>Scala&lt;/a>、&lt;a class="link" href="https://clojure.org" target="_blank" rel="noopener"
>Clojure&lt;/a>、&lt;a class="link" href="https://groovy-lang.org" target="_blank" rel="noopener"
>Groovy&lt;/a>、&lt;a class="link" href="https://www.jython.org" target="_blank" rel="noopener"
>Jython&lt;/a>、&lt;a class="link" href="https://www.jruby.org" target="_blank" rel="noopener"
>JRuby&lt;/a>、&lt;a class="link" href="https://ceylon-lang.org/" target="_blank" rel="noopener"
>Ceylon&lt;/a>、&lt;a class="link" href="https://github.com/Frege/frege" target="_blank" rel="noopener"
>Frege&lt;/a>、&lt;a class="link" href="https://eta-lang.org" target="_blank" rel="noopener"
>Eta&lt;/a>、&lt;a class="link" href="https://haxe.org" target="_blank" rel="noopener"
>Haxe&lt;/a>のような幾多の言語がJVMを利用できるようになっているわけですね。つまり、JVMこそ死なないが、Javaという言語そのものはこれらの言語のどれかに代替できるというわけです。&lt;/p>
&lt;p>そしていろんな言語の候補があるわけですが、その中でも個人的にはKotlinを選びました。近年のJavaも急激なバージョンアップを重ねながら改善されてはいるものの、実際エンタープライズレベルでそういったバージョンアップの効果を期待できるのはLTSバージョンがでた時だけですね。なので、いますぐ生産性を上げながらもJVMをそのまま利用できるという面では、Kotlinのようなモダンな言語への転換を考えるにはちょうどいい時期なのではないかと思っています。もちろん、私みたいにモバイルアプリの開発を考えているとしたら、尚更ですね。&lt;/p>
&lt;p>他にもGoogle推しの言語であることや、&lt;a class="link" href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener"
>Kotlin/Native&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/docs/reference/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>など他の言語でコンパイルできるという点も良いですね(実際Wantedlyでは、&lt;a class="link" href="https://www.wantedly.com/companies/wantedly/post_articles/282562" target="_blank" rel="noopener"
>すでにKotlin Multiplatformを導入&lt;/a>しているらしいです)。そして何より、Kotlinを開発しているのがJetBrainなので、Intellijでは完璧なサポートができるというところも無視できないメリットです。ほんと少しだけですが、使ってみた鑑賞としても、完成度がかなり高い感じの言語だったので(Swiftよりも)、そのようなところからKotlinの未来はかなり明るいと思っています。&lt;/p>
&lt;h2 id="フレームワーク--ライブラリ">フレームワーク &amp;amp; ライブラリ
&lt;/h2>&lt;h3 id="svelte">Svelte
&lt;/h3>&lt;p>先ほど少しJavaScriptの話をしましたが、JavaScriptそのものの需要や重要性については語るまでもないとはいうものの、そのJavaScriptのフレームワーク・ライブラリはどれが良いかという課題だけは、少なくとも数年でこれが正解と言えるような状態ではないかと思います。ここ数年で幾多のフレームワークやライブラリが生まれ、消えていってますね。幸い、いわゆるフロントエンド3強のAngular・React・Vueの中ではReactが勝者になりつつある雰囲気ではあります。Google Trendの結果も、それを見せていますね。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "angular", geo: "", time: "today 12-m" },
{ keyword: "react", geo: "", time: "today 12-m" },
{ keyword: "vue", geo: "", time: "today 12-m" },
],
category: 0,
property: "",
},
{ exploreQuery: "q=angular,react,vue&amp;date=today 12-m,today 12-m,today 12-m", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>しかし、フロントエンド以外の世界はまた話が違います。まだ多くのフレームワークやライブラリが乱立していて、まるで戦国時代のような様子です。こんななかでは、一体どれを選ぶべきか悩ましいし、判断のための調査だけでもかなりの時間と努力が必要となります。このような状況なので、もう数年前から流行っている言葉なのですが、&lt;a class="link" href="https://www.google.com/search?newwindow=1&amp;amp;biw=1680&amp;amp;bih=836&amp;amp;sxsrf=ALeKk03Q7zTnfCMWJbsybKG4qkODOhqViA%3A1611463509708&amp;amp;ei=VfsMYOPbKpvahwO8zpiwCQ&amp;amp;q=javascript&amp;#43;fatigue&amp;amp;oq=javascript&amp;#43;fatigue&amp;amp;gs_lcp=CgZwc3ktYWIQAzIGCAAQBxAeMgIIADIECAAQHjIECAAQHjIECAAQHjIGCAAQBRAeOgQIIxAnOggIABAIEAcQHjoICAAQBRAKEB46CAgAEAgQChAeOgYIABAIEB46BAgAEBM6CAgAEAcQHhATOgoIABAHEAUQHhATUOeYAVjBwAFgnsQBaAFwAHgAgAGyA4gB8BOSAQkwLjcuMy4xLjGYAQCgAQGqAQdnd3Mtd2l6wAEB&amp;amp;sclient=psy-ab&amp;amp;ved=0ahUKEwij2sGw4bPuAhUb7WEKHTwnBpY4ChDh1QMIDQ&amp;amp;uact=5" target="_blank" rel="noopener"
>JavaScript Fatigue&lt;/a>(JavaScript疲労)という言葉があるくらいです。それだけ現代のJavaScriptを学ぶということは大変なことでしょう。&lt;/p>
&lt;p>例えば私みたいに、ほとんどJavaScriptの経験がない人がフロントエンドエンジニアとなって、Reactがもっとも人気があるからそれをやる、と決めたら、まずNode.jsから初めて、パッケージ管理としてはnpmを使うか、yarnを使うか、言語はJavaScriptそのままにするかそれともTypeScriptにするかを決め、次に必要なものとして&lt;a class="link" href="https://webpack.js.org" target="_blank" rel="noopener"
>Webpack&lt;/a>や&lt;a class="link" href="https://babeljs.io" target="_blank" rel="noopener"
>Babel&lt;/a>、&lt;a class="link" href="https://redux.js.org" target="_blank" rel="noopener"
>Redux&lt;/a>を学ぶなどと、知っておくべきものと学ぶべきものが多いです。しかも、それぞれのフレームワークやライブラリがその名前だけでは何が何だかわからなくなります。&lt;a class="link" href="https://ja.nuxtjs.org" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>はVue基盤のフレームワークだけど、&lt;a class="link" href="https://nestjs.com" target="_blank" rel="noopener"
>Nest.js&lt;/a>はNode.js用のフレームワークですね。そして&lt;a class="link" href="https://nextjs.org" target="_blank" rel="noopener"
>Next.js&lt;/a>はまた、React基盤のフレームワークです。この中では、一体どれを学んだらいいか、どれが良いかというのは混乱するだけです。なのでJavaScriptを扱うエンジニアが、疲労を感じるのも当然のことでしょう。&lt;/p>
&lt;p>自分の場合はすでにサーバサイドの実装がある程度はできるので、フロントエンドも触れるようになって、いわゆるフルスタックとして自分一人でアプリが書けたらいいなと思っています。ただ、会社で使われているフロントエンドのフレームワークがあればそれに触れたら良いのですが、個人レベルでは何が良いかはまだ悩ましいものですね。Reactがもっとも人気だから、やはりそれを選ぶべきか？それもいい選択なのかもしれませんが、これからも本格的にフロントエンドの開発に関わるつもりではない限り、本格的にフロントエンドに時間を投資するのはもったいない気もします。そこで考えた代案が、&lt;a class="link" href="https://svelte.dev" target="_blank" rel="noopener"
>Svelte&lt;/a>でした。&lt;/p>
&lt;p>Svleteの特徴(メリット)としては、色々とありますが、私がもっとも注目したところはかなりシンプルであるというところでした。コードが短いので、書き方に慣れるのが圧倒的に早そうな気がします。そのほかは付加的なメリットとしてよく、とにかく「必要な時にサクッとかける」ものとしては、かなり良さげなものではないかなと思ったりもします。もちろん、ちゃんとしたフレームワークなので、本格的なアプリケーションを作る時も良いでしょう。&lt;/p>
&lt;p>ただデメリットとしては、やはりメジャーな3強に比べてそこまで知られても、使われてもないというところです。幸い、Google Trendで確認したところ、少しづつながら注目を得ているのでこれからな気はします。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{ comparisonItem: [{ keyword: "svelte", geo: "", time: "today 5-y" }], category: 0, property: "" },
{ exploreQuery: "date=today%205-y&amp;q=svelte", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;h3 id="flutter">Flutter
&lt;/h3>&lt;p>今はWebアプリケーションばかり書いている私ですが、モバイルの方にも興味があり、どのような言語とフレームワークがあるかだけは把握しておきたいと思っています。そして最近は、モバイルは多くの場合ネイティブよりもハイブリッド・クロースプラットフォームの方が多くなっているような気がします。正確なデータや統計をみたわけではないのであくまで推測に過ぎないのですが、多くの場合ネイティブアプリに投資する時間や予算の余裕のないスタートアップやベンチャー企業の場合は、とりあえずハイブリッド・クロースプラットフォームを好むような印象です。もちろん、複雑な演算やOS特有の機能を使うとしたらやはりネイティブと言われていますが、個人的な経験からだと、意外とハイブリッド・クロースプラットフォームでもできることは多いのでもうOSレベルでもなく、機器固有の機能を活用する必要がなければ大体ハイブリッド・クロースプラットフォームでも事足りるのでは、と思います。&lt;/p>
&lt;p>(ここで個人的な経験というものは、iOS 14から導入されたウィージェット機能を活かした簡単なアプリを作ってみたいなと思い調べたところ、OS固有の機能なので難しいのではないかと思ったものが、意外とReact NativeやFlutterでも十分できるということがわかったことです)&lt;/p>
&lt;p>そして、昔はただのWebViewでできていたアプリも多かったような気がしますが、それならあえてモバイルアプリとして作る必要がないですね(PWAならわかりますが)。でもそのような形のアプリがあったからか、Webの技術から影響され生まれたバイブリッドモバイルアプリのフレームワークもかなり多いような印象です。なのでJavaScriptでコードを書いたり、JavaScriptのフレームワークを基盤にしてアプリを書けるフレームワークがかなり多いですね。例えば&lt;a class="link" href="https://cordova.apache.org" target="_blank" rel="noopener"
>Apache Cordova&lt;/a>、&lt;a class="link" href="https://ionicframework.com" target="_blank" rel="noopener"
>Ionic&lt;/a>、&lt;a class="link" href="https://nativescript.org" target="_blank" rel="noopener"
>NativeScript&lt;/a>、&lt;a class="link" href="https://reactnative.dev" target="_blank" rel="noopener"
>React Native&lt;/a>がそのようなものです。もちろんJavaScript(Web)とは違う系統、つまり伝統的なデスクトップアプリを継承している印象のフレームワークとしてC#基盤の&lt;a class="link" href="https://dotnet.microsoft.com/apps/xamarin" target="_blank" rel="noopener"
>Xamarin&lt;/a>とDart基盤の&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>がありますね。&lt;/p>
&lt;p>これだけ多いハイブリッド・クロースプラットフォームモバイルアプリ用のフレームワークですが、中でもそろそろ淘汰されてそうな技術はあります。またここでGoogle Trendの結果をみてみましょう。5つの項目しか比較ができないので、Flutterは入れてないです。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "cordova", geo: "", time: "today 5-y" },
{ keyword: "ionic", geo: "", time: "today 5-y" },
{ keyword: "xamarin", geo: "", time: "today 5-y" },
{ keyword: "nativescript", geo: "", time: "today 5-y" },
{ keyword: "react native", geo: "", time: "today 5-y" },
],
category: 0,
property: "",
},
{ exploreQuery: "date=today%205-y&amp;q=cordova,ionic,xamarin,nativescript,react%20native", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>少なくとも、NativeScriptにはあまり興味を持っている人がいなく、XamarinやCordovaの場合もだんだん興味が下がっているのを確認できます。そうすると、残りの結果としてはIonicとReact Nativeが残りますね。先ほどフロントエンドの話を少ししましたが、最近のフロントエンド3強の勝者がReactになりそうという現実からして、Web技術に基盤したハイブリッド・クロースプラットフォームモバイルアプリ用のフレームワークは、やはりReact Nativeが適切かなと思います。&lt;/p>
&lt;p>しかし、問題となるのはFlutterです。FlutterはReact Nativeと比べられる場合が多いですね。なので、FlutterともGoogle Trendで比較してみることにします。結果としてはReact nativeと比べFlutterが優勢な気がしています。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "react native", geo: "", time: "today 5-y" },
{ keyword: "flutter", geo: "", time: "today 5-y" },
],
category: 0,
property: "",
},
{ exploreQuery: "date=today%205-y&amp;q=react%20native,flutter", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>理由として上げられるのは、どちらもiOSとAndroidアプリを同時開発できるものであるという点を踏まえると、やはりパフォーマンス問題ではなかったのかという気がします。React Nativeでは、JavaScriptからネイティブコードを呼び出すという構造から必然的にボトルネックになるしかないと言われていますので。そして、あくまで推測なのですが、Dartという別の言語を採用していながらも、JavaやC#のような言語とかなり文法が似ていて、HTMLやXMLとは違う宣言型でのUIの実装ができるというところも、Flutterならではのメリットなのではないか、という気もします。&lt;/p>
&lt;p>もし自分がモバイルアプリを作るとしたら、おそらくネイティブになる可能性が高いのではないかとは思いますが(ハイブリッド・クロースプラットフォームが必要であれば、大抵Web基盤のアプリで事足りそうなので)、場合によってはハイブリッド・クロースプラットフォームも良い選択肢になるでしょう。そしてFlutterはモバイルだけでなく、より多くのプラットフォームのためのフレームワークとして成長していく予定なので、もし今から学ぶとしたらFlutterの方が良いかもしれません。もちろん、Reactがすでにできるフロントエンドエンジニアだとしたら、React Nativeの方が良いとは思いますが、それ以外の場合はやはりFlutterの方が良さそうな気がします。なので、当面はFlutterを視野に入れておきたいものです。&lt;/p>
&lt;p>そのほかに、React Nativeに関しては興味深い記事がいくつかあったので、いくつかの事例を以下に記載します。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c" target="_blank" rel="noopener"
>React Native at Airbnb&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://engineering.udacity.com/react-native-a-retrospective-from-the-mobile-engineering-team-at-udacity-89975d6a8102" target="_blank" rel="noopener"
>React Native: A retrospective from the mobile-engineering team at Udacity&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://qiita.com/taneba/items/9903064aaaffdf041022" target="_blank" rel="noopener"
>React Nativeを採用すべきか〜Shopifyに学ぶ&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="ハードウェア">ハードウェア
&lt;/h2>&lt;h3 id="apple-silicon-mac">Apple silicon Mac
&lt;/h3>&lt;p>私はもともと20年ほどOSはMicrosoftの製品ばかりを使ってきたものです。それがたまたま、iPhoneやiPadから初めてAppleの製品に触れてから思ったよりも自分との相性がよかったので(仕事でLinuxを使っていたので気軽にターミナルを使えるという点が大きいのですが)、今後も引き続きMacを使いたいと思っています。少なくとも、自分の環境ではMacではないと困ることはあっても、Windowsでないと困ることはあまりないですので。&lt;/p>
&lt;p>なので、自然にApple Silicon Macにも興味を持ったわけなのですが、やはりいきなりCPUのアーキテクチャが変わるということは、やはり互換性を担保できない問題があるので、その問題に対してAppleはどのような形で解決策を出すのだろう、という疑問を持っていました。発表直後に&lt;a class="link" href="https://jp.techcrunch.com/2020/07/11/the-real-reason-why-apple-is-putting-apple-slicon-on-the-mac" target="_blank" rel="noopener"
>色々な記事&lt;/a>を読んでみてから予想できたのは、少なくとも「性能(演算・発熱・電力消耗を含め)はIntelより優れている」というところでしたが、それはアーキテクチャがより進んだ工程で作られているからか、それともカスタマイズによるものか、またどれだけ優れているかというのはわからない状態でした。なので「2年で移行する」という話を信じ、まずは様子を見ようとしていました。&lt;/p>
&lt;p>そして今はM1チップのMacが色々とでていて、その性能も検証されていますね。確かなのは性能だけを見ると既存のIntel Macを買う理由はもはやないかのように見えます。さすがに互換性という不安要素があるのに、CPUのアーキテクチャを変えるという宣言をするぐらいのものではあると思います。しかし、やはりエンジニアたる身としては、互換性と安定性にまず目が行くものです。なぜなら、私は最初のメジャーバージョンは必ず、何かわかってない問題を抱えている可能性が高いというのを経験で実感しているからです。実際、Bluetooth問題や初期化が難しい点、スリープモードから起き上がらない問題などが一部で報告されていて、外装ディスプレイも公式的には1台しか対応しないという問題もあります(おそらく、Thunderbolt 3の大域幅の問題なのではないかと思います)。また、続々とUniversalバイナリやM1 Nativeでコンパイルされたアプリも発表されていますが、やはりまだそうではないアプリもたくさんあるので、不安ではありますね。&lt;/p>
&lt;p>しかし、それでもいつかはApple Siliconに全てのMacが転換されるだろうし、いますぐM1チップ搭載モデルを購入しないとしても、十分注目する価値はあるのではないかと思っています。いや、注目だけでなく、今年は16インチMacbook Proのフルチェンジの噂もあるので、もしそれが本当なら自分も乗り換えるのではないかと思っているくらいです。もしそれが出るなら、M1チップ搭載モデルの問題としてあげられたところを改善(少なくとも、外装ディスプレイの件や&lt;a class="link" href="https://9to5mac.com/2021/01/21/macos-big-sur-11-2-rc-now-available" target="_blank" rel="noopener"
>Bluetooth問題&lt;/a>は改善されそうです)されるはずで、今のアプリケーションのM1 Native対応の速度を見ると年内には意外と多くのアプリをNativeに使えるのではないかと思われます。まだまだこれからが注目なのですが、JavaScript中心の開発を行う方にとっては今のM1搭載モデルも十分メリットがあるのではないかと思います(AdoptOpenjdkはまだx64のみなので私は見送りですが…)。また、最近&lt;a class="link" href="https://www.theverge.com/2021/1/21/22242107/linux-apple-m1-mac-port-corellium-ubuntu-details" target="_blank" rel="noopener"
>M1搭載モデルでLinuxを使える&lt;/a>ようになったので、ホームサーバとしてこれらのMacを考慮してみるのも良いチョイスかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>まだJavaとSpringも全ての機能を使いこなしているとも言えない自分が、今から新しい言語やフレームワークを学ぶという計画を立てるのは無理な話なのかしれません。これはいつも悩ましい主題です。一つの言語に関する知識やスキルを極めていった方が良いか、それとも常にトレンドを追いながら幅広い分野のスキルセットを持つべきか。深い知識も、広い知識も持っていて良いものではありますが、自分がこれから積み上げるキャリアを完成するにはどれがより効率的かという疑問は解消されないものです。&lt;/p>
&lt;p>自分なりの答えを出すとしたら、トレンドを追った方が、より自分の持つスキルセットの深さを増して行く方にも作用するのではないかという気はします。JavaしかできないものなのでJavaのAPIを借りて例え話をすると、Java 1.8では他の言語の持つClosureから影響されてLambdaが導入されましたね。その他にもvarの型推論やテキストブロックなどの改善もまた違う言語から影響されたものです。このような変化は、そもそもJavaの開発者たちが他の言語に注目しなかったら起こらなかったことでしょう。なので、「他と比較することで自分をより深く理解することにもなる」のではないでしょうか。そういう意味からすると、自分がすでに持っているスキルセットのみでなく、業界の動向や流行りを早くキャッチして受け入れることこそ重要ではないかと思ったりもします。&lt;/p>
&lt;p>この度はだいぶ主観的な意見だけ語る場となってしましましたが、どうでしょうか。またこれから自分の考えも、トレンドも変わっていくかもしれませんが、今は私の結論が紹介できただけでよかったかなと思います。そして、こうやって色々と自分の知らない分野について調べたり勉強したりするほど、自分には何もないなと実感でき、良い刺激になります。これからも色々と勉強していかないとですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>今更なI/Oの話</title><link>https://retheviper.github.io/posts/java-file-copy/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-file-copy/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post 今更なI/Oの話" />&lt;p>以前、Java 1.7から導入されたNIOに関してのポストを書いたことがありますが、いまだにJavaにおけるファイルのI/Oに関しては悩ましいところが多いです。恥ずかしいことですが、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%8B%E3%83%A5%E3%83%BC%E3%82%B9%E3%83%AB%E3%83%BC%E3%83%A0" target="_blank" rel="noopener"
>Newsroom&lt;/a>のセリフでもあるように、「問題を解決する第一歩はそこに問題があるということを認識すること(First step in solving any problem is recognizing there is one)」ですね。なので、今までの自分が書いたコードを振り返り、どのように書いた方が良いかを反省することにしました。&lt;/p>
&lt;p>なので今回は、今までなんとなく使ってきたコードたちを振り返り、なるべくどのような方法をとった方が良いかを考えてみようと思います。ただ、考えられる全てのケースを網羅するのは難しいと思うので、この度はあくまで&lt;code>Javaのコードでファイルをコピーする&lt;/code>場合に限ります。なので、考えてみたいこと(検証対象)は以下の通りになります。&lt;/p>
&lt;ol>
&lt;li>InputStreamとOutputStreamはどう作った方がいいか
&lt;ol>
&lt;li>FileInputStreamとFileOutputStreamを使うか&lt;/li>
&lt;li>Filesのメソッドを使うか&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ファイルコピーはどのような方法を使った方がいいか
&lt;ol>
&lt;li>InputSteamからOutpuStreamへ書くか
&lt;ol>
&lt;li>readAllBytes()&lt;/li>
&lt;li>transferTo()&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Filesのメソッドを使うか&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>今回はこれらの疑問について、よく使われているファイルコピーのコードを一つ一つ見ていきながら、考えてみたいと思います。&lt;/p>
&lt;h2 id="inputstreamとoutputstreamはどう作るべきか">InputStreamとOutputStreamはどう作るべきか
&lt;/h2>&lt;p>まずはInputStreamとOutputStreamです。今も多くの場合、メモリー問題を考えて、ファイルはなるべくStreamとして扱っているのではないかと思います。特に今のJavaがよく使われている分野はWebアプリケーションですが、そのWebアプリケーションを作るための代表的なフレームワークであるSpringでもファイルのアップロードやダウンロードはStreamの形式となっていますし、ローカルのものかネットワーク越しのものかを問わずファイルのデータを取り扱えるという意味ではFileやPathというオブジェクトを使う場合に比べ汎用性という面でも良さそうな気がします。&lt;/p>
&lt;p>ただ、ローカルでファイルをコピーするために、InputStreamやOutputStreamを生成する方法は、Java 1.7以降だと二つの方法があります。一つはFileオブジェクトから&lt;code>FileInputStream&lt;/code>・&lt;code>FileOutputStream&lt;/code>を生成する方式であり、もう一つはPathオブジェクトとFilesクラスを利用して生成する方法ですね。&lt;/p>
&lt;p>なるべくこれからのコードはNIOを使って書きたいと思っていますが、本当にそれだけで十分か、既存のコード(FileInputStreamとFileOutputStreamを利用する)までもNIOのものに変える必要があるかをまず確認してみたいです。&lt;/p>
&lt;h3 id="コピーの方式">コピーの方式
&lt;/h3>&lt;p>まずは、JavaでInputStreamとOutputStreamを利用して、ファイルをコピーするコードから見ていきましょう。&lt;/p>
&lt;p>私を含め、初めてJavaに触れた多くの方々接することとなるファイルコピーのコードは、おそらく以下のようなものではないかと思います。いわば、最も一般的で、オーソドックスな形とも言えるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// byte[]を利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(File source, File dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileInputStream(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileOutputStream(dest);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>8192&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>(buffer)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(buffer, 0, length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BufferedStreamを利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(File source, File dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> buff &lt;span style="color:#f92672">=&lt;/span> 8192;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(&lt;span style="color:#66d9ef">new&lt;/span> FileInputStream(source), buff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(&lt;span style="color:#66d9ef">new&lt;/span> FileOutputStream(dest), buff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでまず、&lt;code>FileInputStream&lt;/code>は&lt;code>Files.newInputStream&lt;/code>、&lt;code>FileOutputStream&lt;/code>は&lt;code>Files.newOutputStream&lt;/code>に代替できます。まず目立つ違いとしては、&lt;code>FileInputStream&lt;/code>・&lt;code>FileOutputStream&lt;/code>は引数として&lt;code>File&lt;/code>を取り、&lt;code>Files.newInputStream&lt;/code>・&lt;code>Files.newOutputStream&lt;/code>は引数として&lt;code>Path&lt;/code>を取るという点がありますね。ただ、この違いは、&lt;code>File&lt;/code>と&lt;code>Path&lt;/code>の変換が自由なので、あまり決定的な違いとは言えません。つまり、どちらの方法にも簡単に切り替えができるということですね。&lt;/p>
&lt;p>一見、&lt;code>Files&lt;/code>クラスからInputStreamとOutputStreamのインスタンスを生成した方が、より最新のAPIを使っているので性能の面で良さそうな気はします。しかし、JavaのNIOは、必ず性能面で既存のIOと比べ優位にあるわけではないですね。実際、ファイルのI/Oに関しては、NIOを使ってもBlockingモードとしてしか動かないので、あまり性能は変わらないという話もあります。&lt;/p>
&lt;p>そういう場合は、特に問題を起こしてないのに、あえて既存のコードをNIOに切り替える必要は無くなりそうな気もします。しかし、本当にそれで大丈夫でしょうか。&lt;/p>
&lt;h3 id="fileinputstreamとfileoutputstreamの問題">FileInputStreamとFileOutputStreamの問題
&lt;/h3>&lt;p>実際は、そうでもないようです。&lt;code>FileInputStream&lt;/code>・&lt;code>FileOuputStream&lt;/code>には性能とは別の問題があります。GCによりアプリケーション全体が長くポーズの状態になる可能性があるということです。&lt;/p>
&lt;h4 id="finalizeのオーバライド問題">finalize()のオーバライド問題
&lt;/h4>&lt;p>GCによりアプリケーション全体がポーズされるということは、つまり、メモリがフルになるということです。ファイルI/Oで、InputStreamとOutputStreamを使ってメモリがフルになるということは、ちゃんと&lt;code>close()&lt;/code>されてないことですね。なので、&lt;code>単純にclose()すれば良いだけなのでは？&lt;/code>と思われます。&lt;/p>
&lt;p>しかし、本当の問題は&lt;code>FileInputStream&lt;/code>・&lt;code>FileOuputStream&lt;/code>のソースコードにあります。この二つのクラスは、&lt;code>finalize()&lt;/code>メソッドをオーバーロードしていて、ちゃんと&lt;code>close()&lt;/code>してもメモリー上にデータが残ってしまう可能性があるのです。この問題は、&lt;a class="link" href="https://dzone.com/articles/fileinputstream-fileoutputstream-considered-harmful" target="_blank" rel="noopener"
>こちらの記事&lt;/a>に説明されてある通り、Jenkinsでも&lt;a class="link" href="https://issues.jenkins.io/browse/JENKINS-42934" target="_blank" rel="noopener"
>問題視されたことがあり&lt;/a>、OpenJDKでも&lt;a class="link" href="https://bugs.openjdk.java.net/browse/JDK-8212050" target="_blank" rel="noopener"
>finalize()を消す必要がある&lt;/a>と指摘されたことがあります。&lt;/p>
&lt;p>JDKの対応としては、&lt;code>FileInputStream&lt;/code>・&lt;code>FileOuputStream&lt;/code>の&lt;code>finalize()&lt;/code>はJava 9から&lt;code>Deprecated&lt;/code>となり、Java 10からは別の実装を加えることで問題を解決していますが、Java 1.7や1.8を使う場合は依然として問題が起こり得るということになりますね。&lt;/p>
&lt;p>なので、これからはなるべく&lt;code>FileInputStream&lt;/code>・&lt;code>FileOutptStream&lt;/code>の利用は避けるようにする必要があると思います。習慣は怖いですので。&lt;/p>
&lt;h2 id="ファイルコピーはどのような方法を使った方がいいか">ファイルコピーはどのような方法を使った方がいいか
&lt;/h2>&lt;p>今までの結論で、InputStream及びOuputStreamのインスタンスはNIOを使うことにします。したがって前述のコードは以下のように直すことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// byte[]を利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source); &lt;span style="color:#75715e">// FileInputStreamを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest); &lt;span style="color:#75715e">// FileOutputStreamを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>8192&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>(buffer)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(buffer, 0, length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BufferedStreamを利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> buff &lt;span style="color:#f92672">=&lt;/span> 8192;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source), buff); &lt;span style="color:#75715e">// FileInputStreamを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest), buff); &lt;span style="color:#75715e">// FileOutputStreamを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="try-with-resource">try-with-resource
&lt;/h3>&lt;p>InputStreamやOutputStreamは最後に&lt;code>close()&lt;/code>しないと、すでに使ったものでもメモリ上にデータが残ってしまいますね。なのでfinallyブロックでクローズするのが一般的かなと思いますが、こうした場合、finallyブロックでも追加の例外処理が必要になるケースもありますし、毎回&lt;code>close()&lt;/code>するのは忘れられる可能性もあるので危険です。&lt;/p>
&lt;p>なのでJava 1.7からは&lt;code>AutoCloseable&lt;/code>と&lt;code>try-with-resource&lt;/code>が導入され、以下のようにより簡潔かつ安全なコードを書くことができるようになりました。例えば上記のコードは、&lt;code>try-with-resource&lt;/code>を使うと以下のようなコードに代替できますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// byte[]を利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>8192&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>(buffer)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(buffer, 0, length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BufferedStreamを利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> buff &lt;span style="color:#f92672">=&lt;/span> 8192;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source), buff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest), buff)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>try-with-resourceでは、既存の方式と比べメリットしかないので、これは必ず使うことにします。&lt;/p>
&lt;h3 id="readallbytes">readAllBytes()
&lt;/h3>&lt;p>次に考えられるのは、ファイルコピーでのBufferです。以上の例では、&lt;code>byte[]&lt;/code>を使うか、&lt;code>BufferedInputStream&lt;/code>・&lt;code>BufferedOutputStream&lt;/code>を使っていますが、これは性能のためのものであるということは皆さんもご存知のはずなので、Bufferについては割愛します。&lt;/p>
&lt;p>我々が知る限り、Bufferのサイズが大きければ大きいほど、性能はよくなります。なら、メモリが許容する限り、できるだけ大きいサイズのBufferを指定したら自然に性能はマシンが出せる最大限となるはずです。&lt;/p>
&lt;p>そして、Java 9からは、InputStreamを一気に全部読み込み、&lt;code>byte[]&lt;/code>として返す&lt;code>readAllBytes()&lt;/code>というメソッドができました。このメソッドを使うと、&lt;code>Integer.MAX_VALUE&lt;/code>サイズの&lt;code>byte[]&lt;/code>を生成してInputStreamを全部読み込むことができます。理論的にはこれを使ったらファイルコピーもあっという間にできそうですね。&lt;/p>
&lt;p>しかし、考えなくてはならないのが、そうやって読み込んだデータはメモリ上に残ってしまうということです。例えば複数のユーザが使っているWebアプリケーションで、数GBに達するファイルをアップロードする場合が予想されるのに、&lt;code>readAllBytes()&lt;/code>を使ったらメモリはすぐ足りなくなるでしょう。いくらファイルコピーが早くなるとしても、同時に複数のユーザがファイルをアップロードする場合があれば、一周でのもメモリ上に大量のファイルデータが詰まってしまう可能性があるので、あまり良くない選択になります。なので、なるべく&lt;code>readAllBytes()&lt;/code>の仕様は控えるべきでしょう。&lt;/p>
&lt;h3 id="transferto">transferTo()
&lt;/h3>&lt;p>Java 9からは追加されたメソッドのうちには、InputStreamにはより簡単にOutputStreamにデータを転送することのできる&lt;code>transferTo()&lt;/code>というメソッドもあります。&lt;code>try-with-resource&lt;/code>に加え、&lt;code>transferTo()&lt;/code>を使うとさらに簡潔なコードでファイルのコピーができるようになります。例えば以下のようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">transferTo&lt;/span>(os);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ソースコードを見るとわかることですが、&lt;code>transferTo()&lt;/code>ではデフォルトのBufferサイズで作ったbyte[]を使ってコピーをしているので、デフォルト値のBuffer(&lt;code>8192&lt;/code>バイト)を使う場合は、Bufferの指定もいらなくなるのが魅力的です。以下はソースコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">transferTo&lt;/span>(OutputStream out) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(out, &lt;span style="color:#e6db74">&amp;#34;out&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> transferred &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>DEFAULT_BUFFER_SIZE&lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#75715e">// 8192&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> read;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((read &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(buffer, 0, DEFAULT_BUFFER_SIZE)) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out.&lt;span style="color:#a6e22e">write&lt;/span>(buffer, 0, read);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transferred &lt;span style="color:#f92672">+=&lt;/span> read;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> transferred;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ気になるのは、&lt;code>transerTo()&lt;/code>を使う場合は本当にBufferedが要らないかという点です。例えばInputStreamを&lt;code>BufferedInputStream&lt;/code>でラップすると、せめてファイルを読み込む速度は上がるのではないかという疑問が湧いてきます。とにかく、もしものことなので、簡単なベンチマークも実施してみました(実はやってみたかっただけですが)。10GBほどのファイルを生成し、以下のケースでテストしてみました。&lt;/p>
&lt;ul>
&lt;li>InputStream → OutputStream&lt;/li>
&lt;li>BufferedInputStream → OutputStream&lt;/li>
&lt;li>InputStream → BufferedIOutputStream&lt;/li>
&lt;li>BufferedInputStream → BufferedIOutputStream&lt;/li>
&lt;/ul>
&lt;p>そしてコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Benchmark&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@BenchmarkMode&lt;/span>(Mode.&lt;span style="color:#a6e22e">AverageTime&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StreamBufferTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Path source;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Path output &lt;span style="color:#f92672">=&lt;/span> Path.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/Users/retheviper/temp/benchmarkOutput&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テスト用のファイルを作成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/Users/retheviper/temp/benchmarkSource&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> RandomAccessFile file &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RandomAccessFile(path, &lt;span style="color:#e6db74">&amp;#34;rw&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> (1024 &lt;span style="color:#f92672">*&lt;/span> 1024 &lt;span style="color:#f92672">*&lt;/span> 1024) &lt;span style="color:#f92672">*&lt;/span> 10L; &lt;span style="color:#75715e">// 10GB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file.&lt;span style="color:#a6e22e">setLength&lt;/span>(size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">source&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Path.&lt;span style="color:#a6e22e">of&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">noBuffer&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">withInputBuffer&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">withOutputBuffer&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">withBothBuffer&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてベンチマーク結果は、以下の通りです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StreamBufferTest.noBuffer avgt 25 13.055 ± 0.583 s/op
StreamBufferTest.withInputBuffer avgt 25 13.302 ± 0.460 s/op
StreamBufferTest.withOutputBuffer avgt 25 13.663 ± 0.535 s/op
StreamBufferTest.withBothBuffer avgt 25 12.668 ± 0.355 s/op
&lt;/code>&lt;/pre>&lt;p>予想通り、&lt;code>transferTo()&lt;/code>でのコピーの場合、BufferedInputStreamやBufferedOutputStreamを使わなくても性能はあまり変わりありませんでした。単純なファイルコピーではなかったり、InputStreamからOutputStreamというデータの転送ではない場合はまた必要となりそうな気はしますが、このメソッドが使える場合はあまり意識しなくても良さそうですね。&lt;/p>
&lt;h3 id="filescopyがいい">Files.copy()がいい？
&lt;/h3>&lt;p>Java 1.7では、&lt;code>Files.copy()&lt;/code>を通じて以下のファイルコピーができるようになっています。&lt;/p>
&lt;ul>
&lt;li>InputStream → Path&lt;/li>
&lt;li>Path → OutputStream&lt;/li>
&lt;li>Path → Path&lt;/li>
&lt;/ul>
&lt;p>そして一部では、JavaのNIOはネイティブコードで書かれてあるので、InputStreamからOutputStreamへの書き込みよりはFiles.copy()の方が性能がいいと言われる場合もありました。この話が本当さとすると少なくともローカルのファイルを扱う場合、InputStreamからOutputStreamへの書き込みよりはPathを使ったコピーが良さそうな気がします。&lt;/p>
&lt;h4 id="ソースで確認する">ソースで確認する
&lt;/h4>&lt;p>コードが違うと言われたからには、直接確認した方がいいですね。早速、以上であげた三つのメソッドのソースコードを確認することにします。まずは、&lt;code>InputStream → Path&lt;/code>と&lt;code>Path → OutputStream&lt;/code>です。こちらはシンプルに、&lt;code>Path&lt;/code>からOuputStreamもしくはInputStreamを生成し、&lt;code>transferTo()&lt;/code>を使ってコピーすることとなっています。(ただ、これはJava 11基準のソースコードなので、Java 9以前の場合は違うコードの可能性があります)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// InputStream → Path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(InputStream in, Path target, CopyOption... options) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// コピー以外の処理は省略&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream ostream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ostream &lt;span style="color:#f92672">=&lt;/span> newOutputStream(target, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE_NEW&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StandardOpenOption.&lt;span style="color:#a6e22e">WRITE&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (FileAlreadyExistsException x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (se &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> se;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// someone else won the race and created the file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do the copy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (OutputStream out &lt;span style="color:#f92672">=&lt;/span> ostream) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Path → OutputStream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, OutputStream out) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ensure not null before opening file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> newInputStream(source)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、やはり&lt;code>Path → Path&lt;/code>の場合は全く違うコードになっています。コピー元とコピー先が同じファイルシステムの場合は&lt;a class="link" href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/spi/FileSystemProvider.html" target="_blank" rel="noopener"
>FileSystemProvider&lt;/a>を使い、そうではない場合はCopyMoveHelperを使うことになっていますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Path → Path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Path &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path target, CopyOption... options) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileSystemProvider provider &lt;span style="color:#f92672">=&lt;/span> provider(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (provider(target) &lt;span style="color:#f92672">==&lt;/span> provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// same provider&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> provider.&lt;span style="color:#a6e22e">copy&lt;/span>(source, target, options);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// different providers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CopyMoveHelper.&lt;span style="color:#a6e22e">copyToForeignTarget&lt;/span>(source, target, options);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>CopyMoveHelper.copyToForeignTarget()&lt;/code>の場合は、結果的に&lt;code>Files.copy(InputStream, Path)&lt;/code>を呼ぶことになるのですが、前者の場合は全く違う方式になるのでやはり性能の差が発生する可能性もありそうですね。整理すると、&lt;code>同じシステム内で、Path → Pathでコピーする場合だけ性能がよくなる可能性がある&lt;/code>ということですね。&lt;/p>
&lt;p>ここはまた検証が必要なところなので、またベンチマークを実施してみました。もちろんファイルシステムの違いにより結果は変わる可能性があるので、これが絶対的だとは言えませんが、何らかの違いがあるかもしれません。他の&lt;code>Files.copy()&lt;/code>メソッドは実質的に&lt;code>transferTo()&lt;/code>と同じものなので、今回の比較は&lt;code>InputStream → OutputStream&lt;/code>と&lt;code>Path → Path&lt;/code>だけになります。また、比較のためのテストケースが少ないので、今回は&lt;code>transferTo()&lt;/code>のベンチマークよりもファイルサイズを大きくしてみました。以下は、そのテストコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Benchmark&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@BenchmarkMode&lt;/span>(Mode.&lt;span style="color:#a6e22e">AverageTime&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StreamCopyTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Path source;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Path output &lt;span style="color:#f92672">=&lt;/span> Path.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/Users/youngbinkim/Downloads/benchmarkOutput&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テスト用のファイルを作成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/Users/youngbinkim/Downloads/benchmarkSource&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> RandomAccessFile file &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RandomAccessFile(path, &lt;span style="color:#e6db74">&amp;#34;rw&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> (1024 &lt;span style="color:#f92672">*&lt;/span> 1024 &lt;span style="color:#f92672">*&lt;/span> 1024) &lt;span style="color:#f92672">*&lt;/span> 10L; &lt;span style="color:#75715e">// 10GB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file.&lt;span style="color:#a6e22e">setLength&lt;/span>(size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">source&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Path.&lt;span style="color:#a6e22e">of&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">streamToStream&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pathToPath&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Files.&lt;span style="color:#a6e22e">copy&lt;/span>(source, output, StandardCopyOption.&lt;span style="color:#a6e22e">REPLACE_EXISTING&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、ベンチマークの結果は以下の通りです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StreamCopyTest.streamToStream avgt 25 12.128 ± 0.331 s/op
StreamCopyTest.pathToPath avgt 25 12.257 ± 0.342 s/op
&lt;/code>&lt;/pre>&lt;p>10GBのファイルでは誤差範囲以内の結果となったので、ファイルサイズだけを100GBに変えて同じくベンチマークを実施してみました。その結果は以下です。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StreamCopyTest.streamToStream avgt 25 160.046 ± 2.538 s/op
StreamCopyTest.pathToPath avgt 25 153.505 ± 2.662 s/op
&lt;/code>&lt;/pre>&lt;p>100GBになってからやっと差が見えてくる、ということになりますが、結論としてはやはり、&lt;code>Path → Path&lt;/code>の方が早いという結果となりました。機会があれば、複数スレッドによるI/OやOSの違いまで考慮したベンチマークを書きたいものですが、とりあえずは予想通りの結果となったということで。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>以上のソースコードとベンチマークでわかったことをまとめると、Javaでのファイルコピーは、とりあえず以下のようなことで結論づけができそうです。&lt;/p>
&lt;ul>
&lt;li>Java 1.7以上の場合
&lt;ul>
&lt;li>&lt;code>FileInputStream&lt;/code>・&lt;code>FileOutputStream&lt;/code>の代わりに&lt;code>Files.newInputStream&lt;/code>・&lt;code>Files.newOutputStream&lt;/code>を使う&lt;/li>
&lt;li>&lt;code>try-with-resource&lt;/code>を使う&lt;/li>
&lt;li>コピー元とコピー先のどちらも同じファイルシステム上のパスであれば、両方&lt;code>Path&lt;/code>が引数の&lt;code>Files.copy()&lt;/code>を使う&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Java 9以上の場合
&lt;ul>
&lt;li>Bufferサイズが&lt;code>8192&lt;/code>の場合は&lt;code>transferTo()&lt;/code>を使う
&lt;ul>
&lt;li>&lt;code>transferTo()&lt;/code>を使う場合、&lt;code>BufferedInputStream&lt;/code>・&lt;code>BufferedOutputStream&lt;/code>は必須ではない&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>多くの場合、エンタープライズアプリケーションはLTSである1.8や11を使うと思われるので、実質的には以上に並べた項目全てが当てはまると言えましょう。&lt;/p>
&lt;p>かなり今更な感があるポストとなりましたが、個人的には自分の納得できる形で整理でき、スッキリしました。こうやって何気なく、「そう教わったから」使っていたコードを振り返ってみるのも良い勉強になりますね。次もまた、こうやってソースコードやベンチマークによる検証をやってみたいなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>9からの新メソッドめぐり</title><link>https://retheviper.github.io/posts/java-new-methods-from-9-to-11/</link><pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-new-methods-from-9-to-11/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post 9からの新メソッドめぐり" />&lt;p>仕事ではJava 11を扱うことが多いのですが、正直、自分の書いたコードを振り返ってみると、Java 9から新しく追加されたメソッドはあまり使ってないのが現実です。しかし、これら新しいメソッドたちは冗長さを隠してくれるシンタックスシュガーとして存在するだけでなく、性能や機能面でより優れているものもあるので、いますぐ使わないとしても目は通しておきたいものが多いなと思っています。&lt;/p>
&lt;p>2021年は次のLTSバージョンとなる17の登場が予告されている時点なので、今更な感はありますが、そろそろ私もSEになってから2年になるので、今回は今年、自分が書いたコードへの反省を含め、Java 9〜11まで新しく追加されたメソッドたちの中から、良さそうな(よく使えそうな)ものを選別してみました。そして今回のポストは、そう選別したメソッドの簡単な紹介となります。&lt;/p>
&lt;p>多くの場合、これらのメソッドを使える環境だとしたらJava 11を導入しているはずなのであまり意味はないのかもしれませんが、それぞれのメソッド名の右に、該当メソッドがどのバージョンから導入されたかを記入していますので参考にしてください。&lt;/p>
&lt;h2 id="stream">Stream
&lt;/h2>&lt;p>StreamこそJava 8のキモではないかと思います。そしてJava 9では、そのStreamの問題を色々と改善したり、より簡単に使えるようなメソッドを用意しています。なので、既存のforループにしか慣れてない人でも、簡単に入門できるようになったのではないかと思います。&lt;/p>
&lt;h3 id="iterate-9">Iterate (9)
&lt;/h3>&lt;p>&lt;code>iterate()&lt;/code>というメソッド名だけではすぐに意味がわからない場合もあると思いますが、このメソッドは伝統的なFor文と同じような構文でStreamでの処理を書くことができるようになります。つまり、「初期化・ループの継続条件・カウンタ変数の更新」を書くことで、Streaｍの要素数を決めることができるという意味です。例えば、以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 0~9までを出力&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(0, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1).&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはつまり、以下のコードと同じ意味を持ちます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、&lt;code>iterate()&lt;/code>で指定できる初期化の値が数字という制限はないので(&lt;code>T&lt;/code>です)、以下のようなこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Aで三角形を出力&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、ループの継続条件を指定しないこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Aで三角形を出力&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>継続条件を指定しないと、無限ループになってしまうのでは？と思われそうですね。確かにそうですが、同じくJava 9でStreamの要素数の上限を指定できる新しいメソッドが追加されています。次に紹介するものがそれです。&lt;/p>
&lt;h3 id="takewhile-9">takeWhile (9)
&lt;/h3>&lt;p>以前、Streamの問題として「途中でやめられない」と書きましたが、Java 9から導入された&lt;code>takeWhile()&lt;/code>メソッドを使うと、途中で処理を終了するようなことができるようになりました。既存にあった&lt;code>limit()&lt;/code>の場合は、「指定された回数分」という限界がありましたが、こちらはPredicate型の条件を指定できるというところが違います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// AAAAAAAAAまで出力する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">takeWhile&lt;/span>(s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、&lt;code>iterate()&lt;/code>の継続条件を書いてない場合には&lt;code>takeWhile()&lt;/code>を使ってどの条件で処理が終わるかを明示した方が良いですね。&lt;/p>
&lt;h3 id="dropwhile-9">dropWhile (9)
&lt;/h3>&lt;p>&lt;code>dropWhile()&lt;/code>は、その名からも推測できますが、&lt;code>takeWhile()&lt;/code>と真逆の機能をするメソッドです。このメソッドはStreamから与えられた条件と一致する要素を除いて、残りの要素を返却します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// AAAAAから出力する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">dropWhile&lt;/span>(s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>s.&lt;span style="color:#a6e22e">contains&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;AAAAA&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ofnullable-9">ofNullable (9)
&lt;/h3>&lt;p>Java 1.8のStreamでは、Null要素を追加するためにはまずその要素がNullかどうかをチェックして、Nullの場合に&lt;code>Stream.empty()&lt;/code>を呼ぶような形にする必要がありました。いつものJavaのNullチェックですね。例えば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素のNullチェックを含むStreamのCollect&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>keyList.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">flatMap&lt;/span>(k &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object value &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">get&lt;/span>(k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> value &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>(value) : Stream.&lt;span style="color:#a6e22e">empty&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、Java 9ではより簡単なコードで書くことができます。&lt;code>Optional&lt;/code>の&lt;code>ofNullable()&lt;/code>とあまり変わらない感覚ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>keyList.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">flatMap&lt;/span>(k &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Stream.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(map.&lt;span style="color:#a6e22e">get&lt;/span>(k)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="collectors">Collectors
&lt;/h2>&lt;p>Streamの要素を集約するためのCollectorを提供する&lt;code>Collectors&lt;/code> APIですが、こちらの変化は主にシンタックスシュガーなものが多い印象です。主にStreamでしかできなかったことや、既存のCollectorsのみだとかなり長くなるコードを簡潔に書くことができるようになっています。&lt;/p>
&lt;h3 id="filtering-9">filtering (9)
&lt;/h3>&lt;p>&lt;code>Stream&lt;/code>の&lt;code>filter()&lt;/code>と同じ処理を、&lt;code>Collector&lt;/code>でもできるようになりました。どちらを使うかは好みの問題な気がしますが、&lt;code>Collector&lt;/code>そのものを共通化するなどの処理ができそうな気はしますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 0~9までのリスト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> numbers &lt;span style="color:#f92672">=&lt;/span> Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(0, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Stream.filter()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>numbers.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(e &lt;span style="color:#f92672">-&amp;gt;&lt;/span> e &lt;span style="color:#f92672">&amp;gt;&lt;/span> 5)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()); &lt;span style="color:#75715e">// 6, 7, 8, 9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collectors.filtering()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>numbers.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">filtering&lt;/span>(e &lt;span style="color:#f92672">-&amp;gt;&lt;/span> e &lt;span style="color:#f92672">&amp;gt;&lt;/span> 5, Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>())); &lt;span style="color:#75715e">// 6, 7, 8, 9&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="flatmapping-9">flatMapping (9)
&lt;/h3>&lt;p>これもまた名前から推測できると思いますが、&lt;code>Collectors&lt;/code>でCollectionに変えるとき、要素のflatMappingをできるようにしてくれるようなものです。具体的には、以下のサンプルコードを参照してください。&lt;/p>
&lt;p>例えば、以下のようなクラスがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Selling&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String clientName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> products;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、このSellingのリストを、「clientNameをKeyに、productsをValueにしたMapにしたい」場合はどうしたら良いでしょうか。例えば以下のような方法を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> operations.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">groupingBy&lt;/span>(Selling::getClientName, Collectors.&lt;span style="color:#a6e22e">mapping&lt;/span>(Selling::getProducts, Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>())));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、問題は、&lt;code>List&amp;lt;Product&amp;gt;&lt;/code>をさらにListの中に入れてしまうことになります。これは本来の目的ともズレていて、無駄な処理が発生し、Valueを持ち出すときも不便なはずです。&lt;/p>
&lt;p>これを&lt;code>Map&amp;lt;String, List&amp;lt;Product&amp;gt;&amp;gt;&lt;/code>の形に変えるとしたら、以下のような方法が使えます。自作のCollectorを作るのですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> operations.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">groupingBy&lt;/span>(Selling::getClientName, Collectors.&lt;span style="color:#a6e22e">mapping&lt;/span>(Selling::getProducts,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collector.&lt;span style="color:#a6e22e">of&lt;/span>(ArrayList::&lt;span style="color:#66d9ef">new&lt;/span>, List::addAll, (x, y) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x.&lt;span style="color:#a6e22e">addAll&lt;/span>(y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }))));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、毎回このような自作Collectorを作るというのはあまり効率的ではない方法ではないかと思います。それに、自作のCollectorを普段から使ってない場合はコードだけみても少しわかりづらくもありますね。なので、ここは新しく追加された&lt;code>flatMapping()&lt;/code>で変えてみると以下のようになります。より簡潔ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> operations.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">groupingBy&lt;/span>(Selling::getClientName, Collectors.&lt;span style="color:#a6e22e">flatMapping&lt;/span>(selling &lt;span style="color:#f92672">-&amp;gt;&lt;/span> selling.&lt;span style="color:#a6e22e">getProducts&lt;/span>().&lt;span style="color:#a6e22e">stream&lt;/span>(), Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>())));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="tounmodifiable-10">toUnmodifiable (10)
&lt;/h3>&lt;p>Java 10では&lt;code>Collectors&lt;/code>に以下の三つのメソッドが追加されています。&lt;/p>
&lt;ul>
&lt;li>&lt;code>toUnmodifiableList()&lt;/code>&lt;/li>
&lt;li>&lt;code>toUnmodifiableSet()&lt;/code>&lt;/li>
&lt;li>&lt;code>toUnmodifiableMap()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>これらのメソッドを使うと、既存の&lt;code>Collections&lt;/code>を呼ぶ必要なく、簡単に(もっと短いコードで)UnmodifiableなCollectionを作ることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collections.unmodifiableList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> collectionsUnmodifiable &lt;span style="color:#f92672">=&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableList&lt;/span>(Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(0, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collectors.toUnmodifiableList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> collectionsUnmodifiable &lt;span style="color:#f92672">=&lt;/span> Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(0, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toUnmodifiableList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>引数は、既存の&lt;code>toList()&lt;/code>・&lt;code>toSet()&lt;/code>・&lt;code>toMap()&lt;/code>と同じなので(&lt;code>toMap()&lt;/code>だけ、KeyとValueのマッピングを指定する必要がありますね)、既存のメソッドと同じ感覚で使うことができます。&lt;/p>
&lt;h2 id="collections">Collections
&lt;/h2>&lt;p>Collections APIの新しいメソッドは、かなり現代的な書き方を可能にします。Kotlinのような言語がJavaの冗長さを回避するための工夫をしているのであれば、Java側に新しく追加されたメソッドはそれをさらにJavaに似合うような形で受け入れたような印象です。(というか、それしか方法はなかったかもしれませんが…)&lt;/p>
&lt;h3 id="factory-method-9">Factory Method (9)
&lt;/h3>&lt;p>Java 9では、&lt;a class="link" href="https://ja.wikipedia.org/wiki/Factory_Method_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3" target="_blank" rel="noopener"
>ファクトリーメソッド&lt;/a>でCollectionの作成ができるようになりました。使い方としては、既存の&lt;code>Arrays.asList()&lt;/code>と似ているような感覚です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listの作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Setの作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> set &lt;span style="color:#f92672">=&lt;/span> Set.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2, 3);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mapの場合は、KeyとValueを順番に並ぶことでインスタンスを作成できますが、エントリーを定義することもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// KeyとValueのセットで定義する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> Map.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// エントリーを定義する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> Map.&lt;span style="color:#a6e22e">ofEntries&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map.&lt;span style="color:#a6e22e">entry&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map.&lt;span style="color:#a6e22e">entry&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map.&lt;span style="color:#a6e22e">entry&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのファクトリーメソッドで作成したCollectionの特徴は、最初からUnmodifiableなオブジェクトになるということです。なので、例えばアプリケーションの起動時にフィールドに定数をCollectionとして定義する、という場合に使えます。つまり、以下のような既存のコードを代替できるようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// もっとも基本的な方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> set &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashSet&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set &lt;span style="color:#f92672">=&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableSet&lt;/span>(set);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Double-brace initialization &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> set &lt;span style="color:#f92672">=&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableSet&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> HashSet&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add(&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add(&lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add(&lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、このファクトリーメソッドで作ったCollectionは以下のような特徴を持ちますので、必要に応じて使うのが大事ですね。&lt;/p>
&lt;ul>
&lt;li>Immutable(Unmodifiable)になる&lt;/li>
&lt;li>Null要素を指定できない&lt;/li>
&lt;li>要素がSerializableだとCollectionもSerializableになる&lt;/li>
&lt;/ul>
&lt;h4 id="copyof-10">copyOf (10)
&lt;/h4>&lt;p>List, Set, Mapに&lt;code>copyOf()&lt;/code>というメソッドが追加されています。引数にそれぞれのCollectionを渡すと、Unmodifiableなコピーすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コピー元のリスト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> original &lt;span style="color:#f92672">=&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コピーする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> copy &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">copyOf&lt;/span>(original);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="optional">Optional
&lt;/h2>&lt;p>Optionalは積極的に使われていますか？私の場合は、Streamが返すもの以外で、自分でOptionalを使う場合はあまりないです。色々制約が多いので、複雑なNullチェックが必要な場合ではないと使いづらい気もしますね。ただ、9と10で追加されたメソッドでかなり便利に使えるものとなったので、たまには良いのかもしれません。&lt;/p>
&lt;h3 id="or-9">or (9)
&lt;/h3>&lt;p>Optionalの中身がNullの場合に実行されるメソッドです。既存の&lt;code>orElse()&lt;/code>や&lt;code>orElseGet()&lt;/code>と何が違うかというと、こちらはOptionalの中身ではなく、またのOptionalを返すということです。引数としてはSupplierをとります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> optional &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(optional.&lt;span style="color:#a6e22e">or&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>)).&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// &amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="orelsethrow-10">orElseThrow (10)
&lt;/h3>&lt;p>Optionalの中身がNullの場合は例外を投げる分岐です。NullのOptionalはもともと&lt;code>NoSuchElementException&lt;/code>を投げますが、ビジネスロジックなどによりカスタマイズした例外を投げたい場合などはこちらを使えますね。引数としてはSupplierをとります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> optional &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String throwing &lt;span style="color:#f92672">=&lt;/span> optional.&lt;span style="color:#a6e22e">orElseThrow&lt;/span>(RuntimeException::&lt;span style="color:#66d9ef">new&lt;/span>); &lt;span style="color:#75715e">// RuntimeException&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ifpresentorelse-9">ifPresentOrElse (9)
&lt;/h3>&lt;p>Optionalの中身がNullかどうかによって二つのアクションを指定して、分岐処理ができるようなメソッドです。第一引数としてはConsumerを指定することで中身がNullではない場合の処理を、第二引数としてはRunnableとして中身がNullだった場合の処理を書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> hasValue &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;proper value&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hasValue.&lt;span style="color:#a6e22e">ifPresentOrElse&lt;/span>(v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;the value is &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> v), () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;there is no value&amp;#34;&lt;/span>)); &lt;span style="color:#75715e">// the value is proper value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> hasNoValue &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">empty&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hasNoValue.&lt;span style="color:#a6e22e">ifPresentOrElse&lt;/span>(v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;the value is &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> v), () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;there is no value&amp;#34;&lt;/span>)); &lt;span style="color:#75715e">// there is no value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="stream-9">stream (9)
&lt;/h3>&lt;p>Optionalを要素が一つか、Null(&lt;code>Stream.empty()&lt;/code>)のSteamに変えるメソッドです。もともとStreamから要素を取得するときもOptionalになっていたので、このようなメソッドが追加されたのも当たり前といえば当たり前ですね。要素が多くて一つなのにStreamに変える意味があるかというと、他のStreamと結合ができたりもするので色々と活用できる余地はありそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> optional &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;value&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> stream &lt;span style="color:#f92672">=&lt;/span> optional.&lt;span style="color:#a6e22e">stream&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="string">String
&lt;/h2>&lt;p>String APIの場合は、主にJava 11でかなりの変化がありました。Webアプリケーションのみならず、最近のアプリケーションは文字列を扱う場合が多いので、このような変化はありがたいですね。&lt;/p>
&lt;h3 id="repeat-11">repeat (11)
&lt;/h3>&lt;p>指定した数値分、文字列を繰り返します。同じ文字列の単純な繰り返しだとすると、StringBuilderやStrinbBufferなしでも簡単に使えるこちらのメソッドの方が良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String a10 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">repeat&lt;/span>(10); &lt;span style="color:#75715e">// &amp;#34;AAAAAAAAAA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="strip-11">strip (11)
&lt;/h3>&lt;p>文字列の前後の空白を除外するために、今までは&lt;code>trim()&lt;/code>を使うケースが多かったのではと思いますが、Java 11からは&lt;code>strip()&lt;/code>が追加され、&lt;code>trim()&lt;/code>を代替できます。この二つが何が違うかというと、まずそれぞれのメソッドで定義している「空白」が違います。&lt;code>trim()&lt;/code>はUnicodeを考慮してなかったため、半角スペースのみの対応となっていましたが、&lt;code>strip()&lt;/code>はUnicodeで指定されたWhitespace全部を対象とするので、全角スペースや改行にも対応できます。どの文字がWhitespaceとして扱われるかは、&lt;code>Character.isWhitespace()&lt;/code>のメソッドが基準となるので、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#isWhitespace%28char%29" target="_blank" rel="noopener"
>そちらのJavaDoc&lt;/a>を参照してください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String stripped &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n hello world \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">strip&lt;/span>(); &lt;span style="color:#75715e">// &amp;#34;hello world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>strip()&lt;/code>では前後の空白が全部削除されるのですが、文字列の前後を基準にして片方だけ削除したい場合は、前からだけを削除する&lt;code>stripLeading()&lt;/code>や後ろからだけを削除する&lt;code>stripTrailing()&lt;/code>も使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String stripLeading &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n hello world \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">stripLeading&lt;/span>(); &lt;span style="color:#75715e">// &amp;#34;hello world  &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String stripTrailing &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n hello world \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">stripTrailing&lt;/span>(); &lt;span style="color:#75715e">// &amp;#34;\n hello world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今までの説明だけでも十分&lt;code>strip()&lt;/code>を使う理由はあると思いますが、実はもう一つがあります。性能です。性能という面では&lt;code>strip()&lt;/code>の方が&lt;code>trim()&lt;/code>より&lt;a class="link" href="https://stackoverflow.com/questions/53640184/why-is-string-strip-5-times-faster-than-string-trim-for-blank-string-in-java" target="_blank" rel="noopener"
>5倍も早い&lt;/a>と言われているので、なるべく&lt;code>trim()&lt;/code>よりは&lt;code>strip()&lt;/code>を使うべきですね。&lt;/p>
&lt;h3 id="isblank-11">isBlank (11)
&lt;/h3>&lt;p>すでに&lt;code>isEmpty()&lt;/code>というメソッドがありますが、このメソッドと&lt;code>isBlank()&lt;/code>の違いは、&lt;code>trim()&lt;/code>と&lt;code>strip()&lt;/code>の関係と似ています。同じく、&lt;code>isEmpty()&lt;/code>と比べると&lt;code>isBlank()&lt;/code>の方がUnicodeに対応しているのでより多くのケースのWhitespaceに対応できて、性能でも優れています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> isEmpty &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">isEmpty&lt;/span>(); &lt;span style="color:#75715e">// false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> isBlank &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">isBlank&lt;/span>(); &lt;span style="color:#75715e">// true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="lines-11">lines (11)
&lt;/h3>&lt;p>文字列に改行コード(&lt;code>\n&lt;/code>・&lt;code>\r&lt;/code>・&lt;code>\r\n&lt;/code>)を基準に分けた&lt;code>Stream&amp;lt;String&amp;gt;&lt;/code>を返却します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String multipleLine &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;first\nsecond\nthird&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> lines &lt;span style="color:#f92672">=&lt;/span> multipleLine.&lt;span style="color:#a6e22e">lines&lt;/span>().&lt;span style="color:#a6e22e">filter&lt;/span>(String::isBlank).&lt;span style="color:#a6e22e">count&lt;/span>(); &lt;span style="color:#75715e">// 3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="prediacte-not-11">Prediacte not (11)
&lt;/h2>&lt;p>LambdaやMethod Referenceで定義したPredicateの結果がFalseかどうかを判断するためのメソッドです。単純にtrueの否定になるだけなのですが、このメソッドの引数はPredicateなので、LambdaやMethod Referenceを使ってより単純に表現できるのがメリットといえますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 否定の条件式を使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(m &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>m.&lt;span style="color:#a6e22e">isPrepared&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Predicate.not()を使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(Predicate.&lt;span style="color:#a6e22e">not&lt;/span>(Man::isPrepared))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>2021年に次のLTSであるJava 17がリリースされると、今のJava 11を使う現場の場合は多くがJava 17に移行するのではないかと思います。12から16まで、さまざまなAPIや機能、JVMの改善などが含まれていて、すでに多くのブログなどで紹介されていますが、また既存のAPIにはどのような変化があるかまでは完全に把握していない状態です。なので、Java 17のリリースに合わせて、もう一度12〜17までの新しいメソッドの整理と紹介を行おうと思います。これだけでもかなり勉強になりますし、業務で使えそうなテクニックも増えていく感覚ですね。&lt;/p>
&lt;p>また、今年のポスティングはこれで終了となります。色々と大変な一年だったのですが、なんとか年末を迎えることができましたね。その間、このブログにも多くの方々がいらしてくださいました。まだジュニアレベルでしかない駆け出しエンジニアのブログなのであまり情報取集には役立たないかもしれませんが、少しでも私の書いたポストを読んでくださりありがとうございます。来年からは、より面白く、より良い情報を収取してブログに載せたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Spring WebFlux、少し触ってみてからの話</title><link>https://retheviper.github.io/posts/spring-webflux-and-nonblocking/</link><pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-webflux-and-nonblocking/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post Spring WebFlux、少し触ってみてからの話" />&lt;p>今まではずっとSpring MVCを使ってきたので、最近はKotlin + Spring WebFluxという組み合わせで簡単なアプリを作ってみているところです(Spring WebFluxそのものについての紹介は、前回のポストでしているのでここでは割愛します)。Spring WebFluxが紹介されたのももう3年前のことなので(あと少しで、4年になりますね)、もうかなりの時間が経ちますが、実際はあまり幅広く使われてはいないのが現状ではないかと思います。なのでネットで調べてもあまり参考できそうなものがなかったりしますね。&lt;/p>
&lt;p>これはおそらくSpring WebFluxが本格的に導入するにはまだ色々と考えるべきところがあるからでしょう。例えば、フレームワークとしてまだまだ成熟している技術ではないということがあります。まだ、このフレームワークの核心となるReactorの書き方に慣れていない人が多い(Reactiveといいつつ、&lt;a class="link" href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener"
>RxJava&lt;/a>ともまた微妙に違いますしね)という面も考慮しなくてはならないです。会社の立場からしたら、このようにまだ新しい技術をすぐに取り入れるということはリスクもあり、エンジニアの学習コストも考えなくてはいけないという面からあまりメリットがないです。&lt;/p>
&lt;p>そして前回紹介した通り、パフォーマンスの面からしても既存のSpring MVCプロジェクトをSpring WebFluxに変えるだけではあまり得しないという問題があります。なら、新規プロジェクトから導入して良いのでは？と思われる可能性もあると思いますが、スタートアップやベンチャー企業などではそもそもJVM言語を使和ないケースが多いので(勝手なイメージかもしれませんが、そのような企業はやはりPythonやRuby、JavaScriptが多いと思います)、そもそも考慮の対象になっていないのかもしれません。また、もしJVM言語に慣れているエンジニアがいるからSpring WebFluxは導入できるとしても、やはり前述した「検証されてない」と「学習コストがかかる」という問題からは自由ではないですね。&lt;/p>
&lt;p>少なくともこれらの理由からエンタープライズレベルでは、まだSpring WebFluxの導入は難しいかと思います。ただ、おそらくSpringの未来はWebFluxにあるので、これからだんだんWebFluxを中心に開発が行われる可能性もあるので、今からでもReactorの書き方になれる必要があるのかもしれません。また、Springという一つのフレームワークの観点からでなくても、非同期による同時処理性能の向上は、多数のユーザの利用する頻度の高いWebアプリケーションの開発においては重要な要素であるので、少なくともその概念、思想、そしてコードの書き方には慣れる必要があるかもしれません。そういう意味で、自作アプリをSpring WebFluxで書いてみた経験とそこから感じたことを述べたいと思います。&lt;/p>
&lt;h2 id="spring-webfluxのアプリを書くということ">Spring WebFluxのアプリを書くということ
&lt;/h2>&lt;p>Spirng WebFluxは既存のController + Serviceというパターンでもコードを書くことができます。なので、一見みると既存のSpring MVCで作られたプロジェクトと並行して運用したり、既存のコードを少し書き換えるだけで簡単にWebFluxに移行できそうなイメージを与えていると思います。が、実際はそうでもないような気がします。まず私の場合、簡単なCRUDのサンプル(GitHubのリポジトリは&lt;a class="link" href="https://github.com/retheviper/springwebfluxsample" target="_blank" rel="noopener"
>こちら&lt;/a>)を作ってみてから、これを応用して&lt;a class="link" href="https://chouseisan.com" target="_blank" rel="noopener"
>調整さん&lt;/a>のマイナークロンを作ってみようとしました。&lt;/p>
&lt;p>ここで、サンプルではSpring Data JPAを使っていましたが、WebFluxで本格的なノンブロッキングのアプリを書いてみたいと思ったので、&lt;a class="link" href="https://r2dbc.io/" target="_blank" rel="noopener"
>R2DBC&lt;/a>を導入してDBアクセスも非同期で構成することにしました。なぜかというと、非同期の処理の中に一つでも同期の処理が発生するとしたら、それだけでももはや非同期ではなくなるからです。なのでORMもそれに合わせてR2DBCを使う必要がる、とのことです。&lt;/p>
&lt;p>幸い、R2DBCは使い方としてもSpring Data JPAやSpring Data JDBCとそう変わらない感覚で、Interface形式のRepositoryを作り、DTO形式のオブジェクト(Kotlinなら、Data classで十分でした)を作るだけでDBとのマッピングは簡単にできました。あとJPAに比べ、アノテーションの数が少なくなっているだけなのでテーブルとしてオブジェクトを定義するのも簡単です(&lt;code>@Id&lt;/code>をつけるのみで終わります)。そしてSpring Data JDBCとは違って、メソッド名から自動でクエリを生成してくれるというところもあったので、最初は楽だと思いました。でも、やはり初めて触っている技術で、そうなんでもうまくいくはずがありません。一つ、問題にあってしまいました。&lt;/p>
&lt;h3 id="joinができない">Joinができない
&lt;/h3>&lt;p>個人的にはどんな技術でも、やはりある程度の時間がたち、安定期に入る前までは既存の技術に比べ圧倒的な優位にあり、すぐに乗り換えるべきと言えなくするところ(つまり、レガシーを捨てがたくする要素)が必ずしも一つ以上は存在すると思います。そういう意味からすると、Spring Data R2DBCが既存のORMを今すぐ代替するには十分ではないと言える部分は、自動でJoinを行う方法がない(テーブル間の関係をあらかじめオブジェクトとして定義することができない)というところと言えるのではと思います。&lt;/p>
&lt;p>Spring Data JPAやJDBCを使う場合、アノテーションを使うことで簡単にテーブル間の関係(&lt;a class="link" href="https://docs.oracle.com/javaee/6/api/javax/persistence/OneToOne.html" target="_blank" rel="noopener"
>@OneToOne&lt;/a>など)を定義できて、テーブルの関係をコード内で簡単に定義できます。しかし、これがまだR2DBCでは対応していない機能となっています。こういう状況では、リポジトリに&lt;code>@Query&lt;/code>アノテーションをつけて直接Joinが含まれたSQLを書いたメソッドを定義するか、二つのオブジェクトをアプリケーションの中で組み合わせるかの方法があるかと思います。&lt;/p>
&lt;p>ここで前者の場合、コードカバレッジとして取れない部分になってしまうので(そして、個人的には性能が良いとしても、あまりクエリが複雑になりそうなものはメンテの観点からよく思ってないので)、後者の方法を取ることにしました。オブジェクトとリポジトリが1:1になって、後でテーブルに修正が発生してもそのテーブルに当てはまるオブジェクトを直すだけで済むので、より簡単な方法だと思ったからです。しかし、その決定にも問題はありました。R2DBCが返すSQLの実行結果としてのオブジェクトは、オブジェクトそのままではなく、&lt;code>Mono&lt;/code>か&lt;code>Flux&lt;/code>であったからです。&lt;/p>
&lt;h4 id="blockのジレンマ">block()のジレンマ
&lt;/h4>&lt;p>リポジトリから取得したオブジェクトが&lt;code>Mono&lt;/code>や&lt;code>Flux&lt;/code>なので、またどうやって二つのオブジェクトを組み合わせるか(Joinさせるか)を考える必要があります。&lt;/p>
&lt;p>一番簡単な方法としては、&lt;code>Mono&lt;/code>や&lt;code>Flux&lt;/code>をブロッキングして使う方法がありますね。すでに&lt;code>Mono&lt;/code>や&lt;code>Flux&lt;/code>には&lt;code>block()&lt;/code>というメソッドが用意されてあって、同期のコードの中で使うことも可能になっています。例えばSpring MVCでもRestTemplateよりWebClientを使うことが推奨されているので、非同期と同期のの共存が不可能なわけでも、おかしいわけでもないです。&lt;/p>
&lt;p>ただ問題は、そのような方法を取ると非同期のメリットがなくなるということです。なぜなら非同期が見せてくれる素晴らしい同時処理性能は、どこか一つの箇所でもブロッキングが挟むと、結局は同期コードになってしまうからです。それなら今までのSpring MVCとORMでよくて、あえてWebFluxやR2DBCを使う必要が無くなりますね。なので別の方法を試してみることにしました。&lt;/p>
&lt;h4 id="mono--monoもしくはflux--flux">Mono + MonoもしくはFlux + Flux
&lt;/h4>&lt;p>やはりここで取るべき方法は、非同期に相応しい処理方法を探すことでしょう。なので調べた結果、二つの&lt;code>Mono&lt;/code>もしくは&lt;code>Flux&lt;/code>を配列のようなオブジェクトとして結合して扱う方法があるということがわかりました。答えは意外と簡単で、&lt;code>zipWith()&lt;/code>というメソッドを使うことで二つの&lt;code>Mono&lt;/code>か&lt;code>Flux&lt;/code>をつなげることができます。つなげた&lt;code>Mono&lt;/code>もしくは&lt;code>Flux&lt;/code>は、Kotlin基準でタプルになるのであとは&lt;code>map()&lt;/code>からタプルのインデックス(繋ぎ元が&lt;code>t1&lt;/code>、繋ぎ先が&lt;code>t2&lt;/code>となります)を指定して使うだけです。例えば、以下のコードは&lt;code>Paticipant&lt;/code>というオブジェクトをリポジトリから取得したあと、さらに&lt;code>CandidateParticipants&lt;/code>を取得して結合する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getParticipant&lt;/span>(participantId: Long): Mono&amp;lt;ParticipantDto&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repository.findById(participantId)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .zipWith(candidateParticipantHandler.getåCandidateParticipantsByParticipantsId(participantId).collectList())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { mapDto(&lt;span style="color:#66d9ef">it&lt;/span>.t1, &lt;span style="color:#66d9ef">it&lt;/span>.t2) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、このような方式を使ってテーブルをJoinするためには、二つのMonoとFluxを取得できる環境である必要があります。なのでSelectを発行するメソッド(Get系のAPIなど)なら、オブジェクトにテーブル間の関係を上手く設計して反映する必要があります。つまり、一つのキーでJoin対象の全てのオブジェクトを取得できるようにする必要があるということになります。最初のオブジェクトを取得したあと、そのオブジェクトが持つまたのキーで紹介したら良いのでは？と思ったこともありますが、残念ながら私の知る限りは簡単にできそうにないです。なぜなら、そのような方法を取るには以下の手順が必要になるからです。&lt;/p>
&lt;ol>
&lt;li>キーを持ってJoin元のテーブルを照会、データを&lt;code>Mono&lt;/code>もしくは&lt;code>Flux&lt;/code>として取得する&lt;/li>
&lt;li>取得した&lt;code>Mono&lt;/code>もしくは&lt;code>Flux&lt;/code>の&lt;code>map()&lt;/code>を呼び出し、更なるキーを抽出、Join先のテーブルを照会する&lt;/li>
&lt;li>Join元とJoin先のテーブルを組み合わせる&lt;/li>
&lt;/ol>
&lt;p>一見問題なさそうですが、&lt;code>Join先のテーブルを紹介する&lt;/code>段階で、またの&lt;code>Mono&lt;/code>もしくは&lt;code>Flux&lt;/code>を取得してしまうので、それからどうやって元のオブジェクトを取り出すかが問題となります。ここでまた&lt;code>block()&lt;/code>を使うと、今までやってきたことたちが台無しとなってしまうわけです。なので、かなり不便でありながら、コードを持ってのテーブルのJoinは、現時点ではこのような方法しかないのではと思っているところです。&lt;/p>
&lt;h2 id="これがベストか">これがベストか
&lt;/h2>&lt;p>こうやって、WebFluxで疑問となった問題は、なんとか解決することはできました。しかし、個人的にはこのようなやり方に違和感があります。そして、その理由をProject LoomのリーダであるRon Pressleの&lt;a class="link" href="https://www.infoq.com/presentations/continuations-java/" target="_blank" rel="noopener"
>説明&lt;/a>から探すことができました。彼の話によると、今の非同期プログラミングは以下の三つの問題を持っています。&lt;/p>
&lt;h3 id="コントロールフローを見失いやすい">コントロールフローを見失いやすい
&lt;/h3>&lt;p>非同期でコードを書いていると、どんなロジックと目的でコードを書いていたか忘れてしまうような気がする時があります。それはおそらく、アプリケーションの本来の目的を達成するための「ビジネスロジック」よりも、「ノンブロッキングのお作法」の方を気にかけることが多くなるからですね。非同期でコードを書いていると、簡単な条件分岐や繰り返してもかなりコードが複雑になり、一体どのような処理をしようとしたか、その制御の流れを見失いやすくなります。Javaだけやっていた自分にはあまり実感がないですが、JavaScirptで非同期のコードを書いた経験のある方にはこれが理解できるでしょう。(あの有名な、コールバックヘル問題とかがあるし…)&lt;/p>
&lt;p>例えばこのポストでも紹介した通り、二つのテーブルをJoinするために、何をしているかをみてください。同期だったら、最初からJoinしたデータを取得するか、二つのオブジェクトを順番に宣言して処理するだけ済む話ですね。このように簡単な処理でも非同期に変えようとすると、そのコードで何をしたいかよりも、まず非同期の形式に合わせたコードを書くことになるので、「一体何をしようとしているのか」という、そもそもの目的がわからなくなる場合があるという話です。&lt;/p>
&lt;h3 id="コンテキストを見失ってしまう">コンテキストを見失ってしまう
&lt;/h3>&lt;p>非同期だと、例外が発生した時に、スタックトレースを追うのが非常に難しくなります。なぜなら、同期の場合は一つのスレッドが一つのリクエストを処理するため、何が実行されどんな結果になったのかを追跡するためにはそのスレッドの残した履歴を見るだけで十分です。しかし、非同期だと、一つのリクエストが複数のスレッドを渡りながら処理されるため、一つのスレッドの履歴を追うだけでは一体どんなことが起こっているかわからなくなるからです。&lt;/p>
&lt;h3 id="コードの伝染">コードの伝染
&lt;/h3>&lt;p>非同期でコードを書くことになると、結局はアプリケーション全体から同期という概念を排除する結論に至るかもしれません。なぜなら、先に述べました通り、非同期の処理の中で一つでも同期の処理が混ざっているとしたら、それだけでも全体の処理が同期になっちゃうからです。なので、同期と非同期を一つのアプリの中で共存させるのはかなり難しくなり、結果的には非同期のコードに他のコードが「伝染」されるようなことが起きてしまうケースが発生します。例えばWebFluxの例では、同期のコードと混ぜて使うこともほぼ不可能に近いので、あえてオブジェクトを&lt;code>Mono&lt;/code>や&lt;code>Flux&lt;/code>に入れ(非同期に変え)、&lt;code>zipWith()&lt;/code>でタプルとして結び、&lt;code>map()&lt;/code>や&lt;code>flatMap()&lt;/code>で処理するという形になるしかなくなります。そしてその逆の方法を取るとしたら(&lt;code>block()&lt;/code>で&lt;code>Mono&lt;/code>の中身を持ち出すなど)、もはや最初から同期でコードを書いた方が良いということになってしまうという問題があります。&lt;/p>
&lt;h2 id="それでも非同期は必要">それでも非同期は必要
&lt;/h2>&lt;p>以上のことは、おそらく非同期に触れてみた人なら誰でも一度は触れてみた問題であり、共感する人も多いのではないかと思います。しかし、このような不便さがあるにもかかわらず、依然として非同期プログラミングの必要性はあります。特に、今のトレンドだと多くのWebアプリケーションで同時処理性能が重要となっていますので、尚更です。実際&lt;a class="link" href="https://support.google.com/analytics/answer/4589209?hl=ja" target="_blank" rel="noopener"
>グーグルアナリティクス&lt;/a>は、KissMetricsを引用して「ページのレスポンスが 1 秒遅れると、コンバージョン数が 7% 減少する」、「47% の消費者は 2 秒以内にウェブページが読み込まれることを期待している」と行っているくらいですが、このような要求に対応できるのはやはり非同期としか言えません。なので、JavaScriptやC#のような言語では&lt;code>async&lt;/code>/&lt;code>await&lt;/code>/&lt;code>promise&lt;/code>などを試し、Kotlinで&lt;a class="link" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" target="_blank" rel="noopener"
>Coroutine&lt;/a>というものを導入するなど、なんとしても非同期の短所を補完するという努力をしているところですね。&lt;/p>
&lt;p>特に、Javaの場合はOSのスレッドを直接使用するので、同時に処理できるリクエストは数千くらいにすぎません。なので、このスレッド基盤という言語そのものの限界を克服するため今まで多くの非同期ライブラリが作られてきました。しかし、ライブラリにはやはり限界があったので、JVMレベルでの対応が検討されているところです。それが先ほど紹介しました、&lt;a class="link" href="https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html" target="_blank" rel="noopener"
>Project Loom&lt;/a>というものです。&lt;/p>
&lt;h3 id="project-loomという答え">Project Loomという答え
&lt;/h3>&lt;p>Project Loomでは、既存のスレッドをFiberという仮想・軽量スレッドとして切り分け、同時処理性能をあげると同時に、「非同期プログラミングを同期プログラミングの感覚でできるように」して、今までのように非同期か同期かによってコードが変わるような現象を無くすのが目的です。Fiberは数百万まで生成できるというし、使い方としても既存のスレッドどあまり変わらないので、コードの修正も少なくなります。それに、同期の感覚で書いても内部的に&lt;code>async&lt;/code>/&lt;code>await&lt;/code>を使ったかのように処理されるので、コールバックヘルのような問題も無くなりますね。&lt;/p>
&lt;p>また、KotlinのCoroutineはあくまでコンパイラレベルの対応なので、上述した3つの問題のうち、「コンテキストを見失う」、「コードの伝染」という問題は根本的に解決できませんが、Project LoomはJVMレベルの対応なので、これらの問題が全部解消されるというメリットもあります。そして既存の同期APIを非同期に変えることで、クライアントコードとしてはあまり変わることなくすぐに適応できるのも魅力的ですね。&lt;/p>
&lt;p>多くの場合に「非同期の性能」は欲しくても、多くのプログラマが「同期の書き方」に慣れているという現実からして、Proejct Loomが正式リリースされるとしたら既存のCoroutineや&lt;code>async&lt;/code>/&lt;code>await&lt;/code>/&lt;code>promise&lt;/code>、Reactice Streamを使ったプロジェクトの多くがFiberを使ったコードに変わるのではないかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>どんな分野でも、過渡期にあるものがもっとも混乱しやすく、辛いものです。そしてプログラミングにおいては、非同期プログラミングというパラダイムが、まさにそうなのではないかと思います。多くの天才たちが言語、ライブラリ、フレームワークとしうさまざまな方面から非同期プログラミングの短所を克服しようと努力してきて、やがてその結実が見えてくるような気がします。Reactive Steamの思想、「反応型」という概念は個人的に嫌いではないですが、それが今までのプログラミングに比べあまりにも変わった書き方になってくるので、個人的には「特定の目的のため、完全に違う言語も学ぶのと同じくらいの努力が必要となるが、その効率の悪さを甘んずるほどのメリットがあるか」とも思います。それはおそらく、まだ自分が本格的に非同期のコードを書いてみたことがないのでそう思うだけなのかもしれませんが。でも、これもProject Loomのように、同期の感覚で非同期プログラミングができるような技術があると解決される問題でしょう。&lt;/p>
&lt;p>ただ、まだProject Loomは完成した技術ではなく、開発途中のものなので、のちに限界や問題が見つかる可能性もありますね。そして将来的にWebFluxなどで採用されるとしても、リリースのタイミングがわからないので、それまではReactive StreamやCoroutineを使うしかないので、のちにLoomのリリースに合わせて既存のコードを全部書き換えるというのも無理な話です。なるべく早く出て欲しいのですが、まだ2年以内のリリースはないみたいなので、今の姿とは全く違うものになる可能性もありますね。&lt;/p>
&lt;p>だとしても、JVM自体が代わり、非同期プログラミングがより楽なるということは魅力的なものです。最近はKotlinにハマっていますが、こうやって変わっていくJavaを見るのも楽しいことですね。また新しい世界が見えてきそうな気分です。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>今更なループの話</title><link>https://retheviper.github.io/posts/java-collection-loop/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-collection-loop/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post 今更なループの話" />&lt;p>Javaはもともと手続き型な言語ですが、賢い方法で関数型な言語の特徴を受け止めていて、言語の中に共存させていますね。個人的には関数型プログラミングというものに憧れているので、Javaの中でも好んでStreamやLambdaを使っていて、個人的にもKotlinとSpring WebFluxで色々試しているところです。&lt;/p>
&lt;p>ただ、Java 1.8から続いている話ですが、&lt;code>Streamは果たして全てのForループを代替できるのか？&lt;/code>というものがありますね。そしてここでForループを代替ない理由としてよく挙げられているものが、性能・可読性・デバッグの難しさです。つまり内部的により複雑な処理を行っているため性能もよくないし、例外が発生した時も理由を特定するのが難しい上に、多くの人は&lt;a class="link" href="https://en.wikipedia.org/wiki/Method_chaining" target="_blank" rel="noopener"
>Method Chaining&lt;/a>とLambdaに慣れてない、ということですね。&lt;/p>
&lt;p>以上の理由から、私も普段はやはりList = ArrayListで、ループは拡張For文(たまに、Listの要素をいじって新しいインスタンスを新しく生成する場合はStream)というルールを当たり前のように守ってきていますが、ふとこれで本当に良いのか、いう疑問が湧いてきました。Javaも16までバージョンアップしていて、そろそろ関数型プログラミングに転換しても良い時期なのでは？だったり、自分の知っているものは正しいのかという検証をしてみたいという風にですね。&lt;/p>
&lt;p>なので今更な感じではあるのですが、ちょっとしたベンチマークを兼ねて色々検証してみたり、考えてみました(本当は、ベンチマークがしてみたかっただけ)。&lt;/p>
&lt;h2 id="ループの方法">ループの方法
&lt;/h2>&lt;p>今更な紹介となりますが、そもそも今回のポストが今更な話をしているので、Collectionに関する4つのループ文の細かい話もして行こうかと思います。&lt;/p>
&lt;p>多くの場合、Collectionや配列のループ処理の方法は、以下の表通りに使われているのではないかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>種類&lt;/th>
&lt;th>使う場面&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>For&lt;/td>
&lt;td>インデックスが必要な時&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>拡張For&lt;/td>
&lt;td>他の方法を取る必要がない場合&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Iterator&lt;/td>
&lt;td>基本的に使わない&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>forEach()&lt;/td>
&lt;td>基本的に使わない&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上記のケースが成立する基準は、やっぱり&lt;code>性能&lt;/code>になっているのではないかと思います。他にも可読性だとか、色々考慮する要素はあると思いますが、何よりも性能が基準として優先されているのは否定できない事実かと思います。なぜなら、他の要素はチューニングが難しいか、できないものであり(例えばセキュリティやバグ防止のためのバリデーションチェックは、効率的なコードに書き換えることはできても、そもそも無くすというのは論外になりますね)、全ての要件が満たされたアプリケーションでリファクタリングにより「目に見える形で」改善できるのは性能しかないからでしょう。そもそも、同じ処理をするなら性能が良い方が絶対いいですし。&lt;/p>
&lt;p>なので、私が初めてループ処理に関して学んだ時は伝統的な形のFor文とWhileなのですが、のちにCollectionや配列だと拡張For文を使った方が良いという風に教わりましたが、その時も根拠としてあげられたのが「Forと拡張Forは性能上あまり違わない上に、拡張Forの方が常に要素数分だけループするのが保証されてあるから」ということでした。やはり性能から考えて、それから他のことも考慮するような話ですね。納得のいく話だったので、私自身もそれを信じて今までずっと拡張For文を使ってきました。&lt;/p>
&lt;p>でも、実際はどうか検証してみたことはあまりなかったですね。ネットなどで調べてみても、拡張For文は既存のループの書き方を向上させたものであるとか、Iteratorの&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87" target="_blank" rel="noopener"
>Syntax Sugar&lt;/a>に過ぎないとかの話もあリました。聞いた話では、もっとも性能が良いのは&lt;/p>
&lt;p>ただ一つ、&lt;code>Stream&lt;/code>と&lt;code>forEach()&lt;/code>はどうでしょう。Javaでこれらが導入されてからもさらに時間が立っています。しかし、上述したとおり、依然として&lt;code>Stream&lt;/code>や&lt;code>forEach()&lt;/code>は&lt;code>性能が劣る&lt;/code>から多く使われてないような気がしています(他にも、&lt;code>あえて使う理由がわからない&lt;/code>・&lt;code>わかりにくい&lt;/code>などの理由があると思いますが)。最初Java 1.8リリース当時にも、多くの人が性能のテストを行い、少なくとも性能面では既存の方式が有利という結論を出していて、今もそれはあまり変わってないようです。Javaのバージョンも16にまで上がったのですが、それまで行われたチューニングを踏まえても&lt;code>Stream&lt;/code>や&lt;code>forEach()&lt;/code>が持つ根本的なアーキテクチャ(?)的な理由から、既存の方式よりも性能が劣るのはしょうがない、という風に認識されています。&lt;/p>
&lt;p>しかし、誰かにそう言われたから、そう思うというのはあまり良い考え方ではないでしょう。また、前述のとおり、Javaはすでに16までバージョンアップを重ねていて、大抵の変化というのは新しい機能の追加となっていますが、裏では何かJVMやコンパイラのチューニングなどでなんらかの目に見えない改善があったのかもしれません。関数型としてのコードの書き方に慣れているかどうかは、その人の問題として、性能面で改善されているとしたら、よりモダンな方法を使わない理由がないですね。そして、本当に拡張For文が全ての場合で良いかどうかの検証もあらかじめしておく必要があると思います。&lt;/p>
&lt;p>以上の理由から、まず検証で使う4つのループの紹介と、そのベンチマークについて紹介したいと思います。&lt;/p>
&lt;h3 id="for文">For文
&lt;/h3>&lt;p>まずは伝統的な形のFor文です。一部では&lt;code>c-style&lt;/code>とも呼ぶらしいですね。一番基本となるもので馴染みもありますが、やはり古い、という印象もあります。端的に、最近のいわゆる&lt;code>モダン&lt;/code>な言語では、このような形のループは使えない場合もありますね。基本的に以下のような形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(list.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>マイクロな最適化として、ループ対象のCollectionや配列の長さをあらかじめ宣言しておく場合もありますね。こうすると、ループ毎にループの対象となるCollectionや配列のサイズを毎回計算する必要がないため、少しは性能が有利になるという話があります。(コンパイラがこれぐらいの最適化は勝手にしてくれるという話もありますが)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この伝統的なFor文の良いところは、インデックスを基準にして処理をするため、インデックスが必要な場合はなんでもできるということです。例えば、以下のような場合があるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 偶数のインデックスのみ処理をしたい&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i &lt;span style="color:#f92672">+=&lt;/span> 2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(list.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 条件と一致する要素のインデックスが知りたい&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (list.&lt;span style="color:#a6e22e">get&lt;/span>(i).&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 前後の要素と比較したい&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i &lt;span style="color:#f92672">+=&lt;/span> 2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;インデックス&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> 1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;の長さ：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i &lt;span style="color:#f92672">-&lt;/span> 1).&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;、インデックス&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;の長さ：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i).&lt;span style="color:#a6e22e">length&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただし、For文で指定されてあるインデックスが必ずループ対象の範囲内にあるかどうか、わからなくなる場合もあります。0から始まるインデックスで&lt;code>i - 1&lt;/code>を指定してしまったり、iの範囲が対象のCollectionや配列よりも大きくなり例外を投げることになることもあるでしょう。また、インデックスを利用した場合、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%B8%E3%83%83%E3%82%AF%E3%83%8A%E3%83%B3%E3%83%90%E3%83%BC_%28%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%29" target="_blank" rel="noopener"
>マジックナンバー&lt;/a>になってしまう可能性もあるので、バグが発生する可能性が上がったり、可読性が悪くなるなどの問題があります。なので、インデックスを基準に処理をしたい場合は慎重にコードを作成する必要がありますね。&lt;/p>
&lt;h3 id="拡張for文">拡張For文
&lt;/h3>&lt;p>いわゆる&lt;code>for-each&lt;/code>文ですね。Colleciton/配列内の全要素を巡回しながら処理するには、これほど理解しやすく、安全なものはないかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最近は、Javaのみでなく他の言語でもこれが標準となっているようです(書き方は言語毎に少し違いますが)。それはつまり、インデックスによるループよりも、ループないで扱うオブジェクトを拡張For文で対象のCollection/配列内の要素に確実に制限した方が色々有利だということでしょう。実際、インデックスといいつつ、伝統的なForb文のものはCollection/配列のインデックスと同じものでもないですので、危険なコードでもありますから。&lt;/p>
&lt;p>伝統的なFor文と比べ、拡張For文の中ではインデックスを利用することができないという問題があります。ただ、全く方法がないわけではないです。どうしてもインデックスを拡張For文の中で使いたい場合は、ループの外に定数を宣言するか、Collectionなら利用できる&lt;code>indexOf()&lt;/code>か、&lt;code>Collections.binarySearch()&lt;/code>を使う方法があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 定数を利用する方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;のインデックス：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// indexOf()を利用する場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;のインデックス：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> list.&lt;span style="color:#a6e22e">indexOf&lt;/span>(element));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collections.binarySearch()を利用する場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;のインデックス：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Collections.&lt;span style="color:#a6e22e">binarySearch&lt;/span>(values, value));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ループの中で&lt;code>indexOf()&lt;/code>を使うのはあまり良い選択じゃないです。以下は&lt;code>ArrayList.indexOf()&lt;/code>の実装になりますが、結局Collectionの中をループしながらインデックスを探すことになるので、実質的に二重ループになっちゃいます。なのでインデックスがどうしても必要な場合は、なるべく定数を使うか、伝統的なFor文を使うべきですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ArrayList.indexOf()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">indexOf&lt;/span>(Object o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> indexOfRange(o, 0, size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">indexOfRange&lt;/span>(Object o, &lt;span style="color:#66d9ef">int&lt;/span> start, &lt;span style="color:#66d9ef">int&lt;/span> end) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object&lt;span style="color:#f92672">[]&lt;/span> es &lt;span style="color:#f92672">=&lt;/span> elementData;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> start; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> end; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (es&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> start; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> end; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o.&lt;span style="color:#a6e22e">equals&lt;/span>(es&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Collections&lt;/code>の&lt;code>binarySearch()&lt;/code>を利用する場合も、結局ループしながらインデックスを探すというのは変わりませんので注意を。以下はその実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collections.binarySearch()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">binarySearch&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> list, T key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (list &lt;span style="color:#66d9ef">instanceof&lt;/span> RandomAccess &lt;span style="color:#f92672">||&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>()&lt;span style="color:#f92672">&amp;lt;&lt;/span>BINARYSEARCH_THRESHOLD)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">indexedBinarySearch&lt;/span>(list, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">iteratorBinarySearch&lt;/span>(list, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">indexedBinarySearch&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> list, T key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> low &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> high &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>()&lt;span style="color:#f92672">-&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (low &lt;span style="color:#f92672">&amp;lt;=&lt;/span> high) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> mid &lt;span style="color:#f92672">=&lt;/span> (low &lt;span style="color:#f92672">+&lt;/span> high) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> midVal &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(mid);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cmp &lt;span style="color:#f92672">=&lt;/span> midVal.&lt;span style="color:#a6e22e">compareTo&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cmp &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (cmp &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> high &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mid; &lt;span style="color:#75715e">// key found&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>(low &lt;span style="color:#f92672">+&lt;/span> 1); &lt;span style="color:#75715e">// key not found&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">iteratorBinarySearch&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> list, T key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> low &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> high &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>()&lt;span style="color:#f92672">-&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListIterator&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">listIterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (low &lt;span style="color:#f92672">&amp;lt;=&lt;/span> high) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> mid &lt;span style="color:#f92672">=&lt;/span> (low &lt;span style="color:#f92672">+&lt;/span> high) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> midVal &lt;span style="color:#f92672">=&lt;/span> get(i, mid);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cmp &lt;span style="color:#f92672">=&lt;/span> midVal.&lt;span style="color:#a6e22e">compareTo&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cmp &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (cmp &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> high &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mid; &lt;span style="color:#75715e">// key found&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>(low &lt;span style="color:#f92672">+&lt;/span> 1); &lt;span style="color:#75715e">// key not found&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="iterator">Iterator
&lt;/h3>&lt;p>Iteratorは、個人的にあまり馴染まない(使いたくない)ものです。どのCollectionでもIteratorとして抽出ができてしまうので、CollectionよりもIteratorが主体になってしまうような感覚であり、定型文な書き方を矯正しているからです。少なくとも拡張ForではどんなCollectionのどんな要素を抽出して使っているのか明確ですが、Iteratorだとそれがわからないですね。&lt;/p>
&lt;p>とにかく、そんなIteratorですが、ForでもWhileでもループをかけるという特徴があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Forを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Iterator iterator &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">iterator&lt;/span>(); iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Whileを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Iterator iterator &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Iteratrorを使う場合の問題は、使い方がいまいち直感的ではないということです。例えば以下のような例をみましょう。&lt;code>getFoo()&lt;/code>と&lt;code>getBar()&lt;/code>は、同じオブジェクトから呼ばれているように勘違いしやすいのではないでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Iterator iterator &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">iterator&lt;/span>(); iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>().&lt;span style="color:#a6e22e">getFoo&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>().&lt;span style="color:#a6e22e">getBar&lt;/span>()); &lt;span style="color:#75715e">// 注意！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>面白いことに、拡張For文のバイトコードは、Iteratorを使うコードになるということです。なので少なくとも拡張For文は、Iteratorよりは発展した形と言えるのかもしれません。&lt;/p>
&lt;h3 id="foreach">forEach()
&lt;/h3>&lt;p>モダンな書き方としてのforEach()ですね。拡張For文とあまり違わないのですが、Lambdaやメソッド参照が使えるというメリットがありますね。また、Kotlinのスコープ関数のように、処理の範囲がはっきりするという意味で良いのかもしれません。何よりコードが短くなるのが好きですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>list.&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実装としても、拡張For文の中でLambdaを実行するという単純な構造になっています。なので単純に考えて、拡張For文よりは性能が劣る可能性がありますね。以下はIterableの実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// IterableのforEach()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">forEach&lt;/span>(Consumer&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> action) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(action);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (T t : &lt;span style="color:#66d9ef">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action.&lt;span style="color:#a6e22e">accept&lt;/span>(t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ArrayListの場合は実装が大きく違います。なので性能も大きく変わる可能性がありますね。以下はその実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ArrayListのforEach()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">forEach&lt;/span>(Consumer&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> E&lt;span style="color:#f92672">&amp;gt;&lt;/span> action) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(action);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> expectedModCount &lt;span style="color:#f92672">=&lt;/span> modCount;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> es &lt;span style="color:#f92672">=&lt;/span> elementData;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; modCount &lt;span style="color:#f92672">==&lt;/span> expectedModCount &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action.&lt;span style="color:#a6e22e">accept&lt;/span>(elementAt(es, i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (modCount &lt;span style="color:#f92672">!=&lt;/span> expectedModCount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentModificationException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> E &lt;span style="color:#a6e22e">elementAt&lt;/span>(Object&lt;span style="color:#f92672">[]&lt;/span> es, &lt;span style="color:#66d9ef">int&lt;/span> index) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (E) es&lt;span style="color:#f92672">[&lt;/span>index&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ベンチマークで検証してみると">ベンチマークで検証してみると
&lt;/h2>&lt;p>この度も、JMHを使って簡単なベンチマークを作ってみました。実はstatic finalなフィールドとして宣言しておくとそのオブジェクトを全てのベンチマークで使い回してくれるのかな、と思っていましたが、どうやらそうではなかったみたいです。なので今回は、ちゃんと@Setupアノテーションを使ってフィールドの初期化をしてみました。実際のコードは以下のとおりです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Thread&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LoopTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> values;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> DecimalFormat format &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;0000000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 9999999).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(format::format).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">indexLoop&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">size&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> length; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(values.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">iteratorLoopFor&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Iterator iterator &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">iterator&lt;/span>(); iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">iteratorLoopWhile&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Iterator iterator &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">extendedLoop&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : values) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">forEachLoop&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values.&lt;span style="color:#a6e22e">forEach&lt;/span>(bh::consume);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてベンチマークの結果は、以下のとおりです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
LoopTest.indexLoop thrpt 25 27.737 ± 0.475 ops/s
LoopTest.iteratorLoopFor thrpt 25 26.968 ± 0.556 ops/s
LoopTest.iteratorLoopWhile thrpt 25 27.250 ± 0.557 ops/s
LoopTest.extendedLoop thrpt 25 13.186 ± 0.152 ops/s
LoopTest.forEachLoop thrpt 25 12.479 ± 0.104 ops/s
&lt;/code>&lt;/pre>&lt;p>やはり、4つのループがそれぞれ違う結果を見せているのがわかります。少なくとも、ここでは伝統的なFor文を使った方がもっとも性能の面では有利のように見えますね。なるべく拡張For文を使った方が良い、という根拠として&lt;code>性能はあまり変わらないから&lt;/code>というのはなんだったんだろう、と思うくらいの差があります。&lt;/p>
&lt;p>しかし、本当にこれで、&lt;code>性能が良い方を選べば良い&lt;/code>という結論を出して良いのでしょうか？&lt;/p>
&lt;h2 id="考えたいこと">考えたいこと
&lt;/h2>&lt;p>処理としての結果が同じだとしたら、やはり性能の良い方を選びたくなるのは当然です。企業レベルの話だと、性能は費用と直結する問題でもありますしね。しかし、複雑化している現代のアプリケーションで考えるべきは、性能のみではありません。極端的な話だと、性能のためにをC、C++でWebアプリケーションを作るとしたら、他の言語に比べて生産性が下がってしまうでしょう。そして可読性や維持保守を考えず、性能を優先したコードだけを書いていくと、いわゆる&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%91%E3%82%B2%E3%83%86%E3%82%A3%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0" target="_blank" rel="noopener"
>スパゲティコード&lt;/a>になってしまう可能性もあります。&lt;/p>
&lt;p>なので、性能のみではなく、アプリケーションを開発するときには色々と考慮すべき要素があるのは確かです。例えば、Readability(可読性)、Error-proneness(エラー発生可能性)、Capability(処理能力)などがあるでしょう。今までは性能ばかりの話をしてきましたが、これらの観点から4つのループを比較してみたらどうでしょう。&lt;/p>
&lt;h3 id="可読性とエラー発生可能性の側面から考える">可読性とエラー発生可能性の側面から考える
&lt;/h3>&lt;p>拡張For文(forEach())では、Collectionそのものの要素をことができます。逆に、For文やIteratorでは可能ですね。ならば、Collectionや配列の中でとある条件と一致する要素だけのことしたい場合は、拡張For文よりもFor文やIteratorを使うべきであるようにも見えます。&lt;/p>
&lt;p>しかし、観点を変えてみると、元のオブジェクトそのものが変わることで起こり得るサイドエフェクトが発生する場合も考えられます。こういう場合、元のオブジェクトを直接操作できるということはメリットではなくデメリットになってしまいますね。なので、どちらかというと、与えられたCollection/配列から条件に一致する要素だけを抽出して新しいCollection/配列のインスタンスを生成するのが正解の可能性もあります。そしてそれをよりわかりやすいコードとして実現できるのは拡張For文(forEach())ですね。例えば、以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のリストが変わってしまう&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">filterFor&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (list.&lt;span style="color:#a6e22e">get&lt;/span>(i).&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;gt;&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list.&lt;span style="color:#a6e22e">remove&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のリストには影響がない - For文&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterFor&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String element &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (element.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(element);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のリストには影響がない - 拡張For文&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterForEach&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (element.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(element);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のリストには影響がない - Stream.forEach()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterStream&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">filter&lt;/span>(element &lt;span style="color:#f92672">-&amp;gt;&lt;/span> element.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 10).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>良いコードは、短く、わかりやすいコードなのではないかと思っています。そしてわかり安いコードは、誰がメンテしてもバグを起こす可能性は低くなるはずでしょう。そういう観点からすると、伝統的なFor文とIteratorは、今は使うべきではないのかもしれません。&lt;/p>
&lt;h3 id="処理能力の側面から考える">処理能力の側面から考える
&lt;/h3>&lt;p>処理能力、というのはある程度性能ともつながるものですね。なので、性能という側面でもう一度考えてみます。互換性、汎用性などとも言える物かもしれません。ここで言いたいのは、Collection/配列がどんなものであれ、一定の性能を保証する実装を考える必要があるということです。&lt;/p>
&lt;p>引数として&lt;code>List&lt;/code>をとり、なんらかの処理をループで行うメソッドを実装するとしましょう。今まであげてきた、4つのループのパターンのうちどれを選ぶべきかは、その引数の実装クラスが何になるかわからない、という面も考慮する必要があります。なぜなら、Listは色々な実装クラスを持つインタフェースだからです。&lt;/p>
&lt;p>引数としてListをまず宣言しておくと、言語の仕様としてはListの実装クラスはどれでも許容することになりますね。なので引数として入ってくるのは&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html" target="_blank" rel="noopener"
>ArrayList&lt;/a>になる可能性もあり、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html" target="_blank" rel="noopener"
>LinkedList&lt;/a>にな可能性もあり、極端的には&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/AbstractList.html" target="_blank" rel="noopener"
>AbstractList&lt;/a>で個人がカスタマイズしたものが来る場合もあると予想できます。他にもJava 11を基準に、java.util.Listを継承しているCollectionの実装クラスの場合、例えば&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/AbstractSequentialList.html" target="_blank" rel="noopener"
>AbstractSequentialList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/AttributeList.html" target="_blank" rel="noopener"
>AttributeList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CopyOnWriteArrayList.html" target="_blank" rel="noopener"
>CopyOnWriteArrayList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/relation/RoleList.html" target="_blank" rel="noopener"
>RoleList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/relation/RoleUnresolvedList.html" target="_blank" rel="noopener"
>RoleUnresolvedList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Stack.html" target="_blank" rel="noopener"
>Stack&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Vector.html" target="_blank" rel="noopener"
>Vector&lt;/a>などがあって、これらが全部Listになりえるので、どの実装でも対応する必要があります。&lt;/p>
&lt;p>もちろん、Javaでとあるインタフェースを継承するということは、処理の前提条件と結果結果が明確であることと同じ意味なので、実装クラスが変わったって、処理の結果が大きく変わることはないです。ただ、Listの実装クラスが複数存在するのは、それらを使う目的によってどちらかに偏ったパフォーマンスを見せるためであることをまず理解する必要がありますね。これはつまり、同じ条件下でも実装クラスによって処理の性能が大きく変わる可能性があるということです。一般的に多く使われているListの実装クラスはArrayListですが、参照以外の性能が劣るという理由からLinkedListが使われる場面もあると予想できます。だとすると、ArrayListで性能がよかったものがLinkedListでもそうとは限らないものですね。&lt;/p>
&lt;p>上記で実施したベンチマークだけをみて、性能は絶対これが有利だ、と言いきれない理由がここにあります。なぜなら、テストようのデータを&lt;code>Collectors.toList()&lt;/code>を使ってListとして作成していますが、以下のコードでわかるように、常にArrayListが生成されているからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> Collector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, &lt;span style="color:#f92672">?&lt;/span>, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">toList&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CollectorImpl&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>((Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>) ArrayList::&lt;span style="color:#66d9ef">new&lt;/span>, List::add,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (left, right) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> { left.&lt;span style="color:#a6e22e">addAll&lt;/span>(right); &lt;span style="color:#66d9ef">return&lt;/span> left; },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CH_ID);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、ついでに他の実装クラスのベンチマークもしてみることにしました。ただ、Listの実装クラスを全部テストするのは無理があるので(特に、AbstractListやAbstractSequentialListは別途実装が必要ですし、CopyOnWriteArrayListはマルチスレッドでないと意味がないし、RoleListやVectorはほとんど使われてなく、Stackをループで利用するとは思わないので)、LinkedListの場合はどうかだけ確認してみました。まあ、ArrayListと違う反例は一つだけあったら十分ですしね。&lt;/p>
&lt;p>幸い、Collectorsには&lt;code>toCollection()&lt;/code>でCollectionの実装を指定できます。なので、上記のベンチマークのコードから、以下のような修正を入れるだけでListの実装を変えることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// LinkedListの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>values &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 9999999).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(format::format).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toCollection&lt;/span>(LinkedList::&lt;span style="color:#66d9ef">new&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>LinkedListの場合、要素数が増えると急激に性能が低下する傾向があります。なので、ArrayListの時よりも要素数は2桁ほど減らしてベンチマークを実施しました。結果は以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Benchmark Mode Cnt Score Error Units
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.indexLoop thrpt &lt;span style="color:#ae81ff">25&lt;/span> 0.084 ± 0.005 ops/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.iteratorLoopFor thrpt &lt;span style="color:#ae81ff">25&lt;/span> 854.459 ± 36.771 ops/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.iteratorLoopWhile thrpt &lt;span style="color:#ae81ff">25&lt;/span> 839.233 ± 18.142 ops/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.extendedLoop thrpt &lt;span style="color:#ae81ff">25&lt;/span> 659.999 ± 47.702 ops/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.forEachLoop thrpt &lt;span style="color:#ae81ff">25&lt;/span> 780.463 ± 78.591 ops/s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ArrayListとは真逆の結果になったのがわかります。特に、インデックスによるループは使えるものにならないほど性能が低く、拡張For文よりも&lt;code>forEach()&lt;/code>の性能が高いという、意外の結果となっています。このベンチマークでの数値が絶対的なものとは言えませんが、結果から推論できるのは、やはりArrayListのインデックスを利用する伝統的なFor文でのループが一番早かったからという理由だけで、全てのListをFor文で処理するというのは危ないということです。なので「どの実装クラスでも、平均的に良い性能を出してくれる」方式を選ぶ必要があるという結論を出せるでしょう。(それがおそらく拡張For文な気がします)&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>全ての場面で最適なコードを書くのは難しいことで、過去に書いたコードはいずれ改善しなければならないものとなりますね。あまりエンジニアとしての歴の長くない自分でも、たまに入社前のコードをみるとびっくりするくらいです。なんとか動くようなものは作ったものの、重複するコードや無駄なインスタンス作りなど、至る所に自分のミスが散らかっています。&lt;/p>
&lt;p>なのでたまには、そのような過去の自分が書いたコードと向かい合って、それを直してみるのも良い経験になるのではないかと思ったりもします。特に今回みたいに、ループ処理は基本の中の基本ですが、その処理すらどれを選ぶかよくわかってないまま(そして副作用などは考えず)、ただひたすら書いてしまったものも多かったので、それに対する反省を兼ねて、そして自分の思うことの根拠を探すための勉強にもなりますので。そしてベンチマーク、意外と楽しいですので。これで自分の理論を証明していくのも良い経験ですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>パターンと一致する文字列かを判定する</title><link>https://retheviper.github.io/posts/java-string-pattern-validator/</link><pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-string-pattern-validator/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post パターンと一致する文字列かを判定する" />&lt;p>一般的に、アプリケーションには要求される業務的な要件やセキュリティの観点から考慮すべきことがあるので、なんらかの機能を作るときはそれが「動くか」だけでなく、任意のロジックが必要となる場合がありますね。なのでその機能が動くにはとある場合で、動くときはとある条件に合わせて処理をする、といった制限が要求されることがあります。&lt;/p>
&lt;p>今回のポストも、またそのような業務上の要件から生まれた話です。現在、私が関わっている案件では、EC2で起動するSpring Boot基盤のアプリを作っています。このアプリでは、ファイルのデータとアップロード先のパスを指定すると、S3にアップロードするという単純な機能があり、それは自分の担当となっています。&lt;/p>
&lt;p>単純にアップロードパスとデータがあれば、動く機能を作るのは単純です。SpringにはSpring Cloudというフレームワークがあるので、すでに&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/ResourceLoader.html" target="_blank" rel="noopener"
>ResourceLoader&lt;/a>というクラスを持ってファイルアップロードを実現できます。Spring Cloudを使わない場合でも、&lt;a class="link" href="https://aws.amazon.com/jp/sdk-for-java" target="_blank" rel="noopener"
>AWS SDK&lt;/a>を使うと簡単に実装ができます。事実、こちらの昨日もアップロード先のパスとファイルだけあれば良いものとなっているので、実装というまででもないですね。&lt;/p>
&lt;p>ただ、この機能が呼び出されたとき、渡されたアップロード先のパスが「正しいもの」であるかを確認する必要がありました。つまり、業務上ファイルをS3に格納する際に決まったパスのルールがあって、この機能からはパラメータとして渡されたパスが規定のパターンと一致するかどうかを一度チェックする必要がありました。&lt;/p>
&lt;p>渡されたパスが「正しいもの」かどうかをチェックするための機能は、何で作ったら良いでしょうか。そしてどう作った方が良いでしょうか。色々な方法があるかと思いますが、まずここでは自分がどう実装したかを紹介していきたいと思います。&lt;/p>
&lt;h2 id="文字列のパターンは正規表現で">文字列のパターンは正規表現で
&lt;/h2>&lt;p>まず、ファイルのアップロード先(保存先)パスは文字列であり、特定のパターンである必要があります。文字列が特定のパターンで構成されているかどうかの判定は、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE" target="_blank" rel="noopener"
>正規表現&lt;/a>を使いますね。なので、「正しいもの」としてのパスのパターンは、正規表現としてあらかじめ宣言しておいて、渡されたパラメータがそれと一致するかをチェックすることとします。ただ、Javaでは正規表現を使って文字列のパターンを判定する方法がいくつかありますので、それらのうちにどれを選ぶべきかを考える必要があります。例えば、以下の方法がありますね。&lt;/p>
&lt;ol>
&lt;li>&lt;code>Pattern.matches()&lt;/code>を使う&lt;/li>
&lt;li>&lt;code>Pattern&lt;/code>から&lt;code>Matcher&lt;/code>を取得し使う&lt;/li>
&lt;li>&lt;code>Pattern&lt;/code>から&lt;code>Predicate&lt;/code>を取得し使う&lt;/li>
&lt;li>&lt;code>String.matches()&lt;/code>を使う&lt;/li>
&lt;/ol>
&lt;p>そして、これらの方法は、以下のコード通りに使うことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 正規表現の例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String patternRegex &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;^[0-9]*$&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 正規表現で判定したい文字列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;123456789&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Pattern.matches()を使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> patternMatches &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">matches&lt;/span>(patternRegex, value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Matcherを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pattern pattern &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(patternRegex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Matcher matcher &lt;span style="color:#f92672">=&lt;/span> pattern.&lt;span style="color:#a6e22e">matcher&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> matcherFind &lt;span style="color:#f92672">=&lt;/span> matcher.&lt;span style="color:#a6e22e">find&lt;/span>(); &lt;span style="color:#75715e">// 部分一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> matcherMatches &lt;span style="color:#f92672">=&lt;/span> matcher.&lt;span style="color:#a6e22e">matches&lt;/span>(); &lt;span style="color:#75715e">// 完全一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Predicateを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pattern pattern &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(patternRegex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> matcherFind &lt;span style="color:#f92672">=&lt;/span> matcher.&lt;span style="color:#a6e22e">asPredicate&lt;/span>().&lt;span style="color:#a6e22e">test&lt;/span>(value); &lt;span style="color:#75715e">// 部分一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> matcherMatches &lt;span style="color:#f92672">=&lt;/span> matcher.&lt;span style="color:#a6e22e">asMatchPredicate&lt;/span>().&lt;span style="color:#a6e22e">test&lt;/span>(value); &lt;span style="color:#75715e">// 完全一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String.matches()を使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> stringMatches &lt;span style="color:#f92672">=&lt;/span> value.&lt;span style="color:#a6e22e">matches&lt;/span>(patternRegex);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>Matcher&lt;/code>や&lt;code>Predicate&lt;/code>を使う場合、部分一致を選べられるので、部分一致の場合はこれらを使うしかなさそうです。しかし、完全一致が必要な場合は何を基準に、どれを選ぶべきでしょうか。どれも同じような結果を出すのであれば、より効率的な方法を選びたくなります。そして、この場合、考えられるのは性能です。つまり、どれを使った時にもっとも早く判定の結果を得られるかということです。&lt;/p>
&lt;h2 id="どれも同じなら性能で">どれも同じなら性能で
&lt;/h2>&lt;p>前述の通り、文字列が与えられた正規表現のパターンと一致するかどうかを判断する様々な方法があるので、中でももっとも早いのはどれか、測定したいと思います。いわゆるストップウォッチ方式(処理終了時点の時間から、処理開始時点の時間を引く)が簡単ですが、より正確な比較がしたかったためOpenjdkから提供する&lt;a class="link" href="https://openjdk.java.net/projects/code-tools/jmh" target="_blank" rel="noopener"
>JMH&lt;/a>を使ってベンチマークを作りました。Java特有の起動が遅い問題で測定に影響が出るのを防ぐためか、何回かのウォーミングアップも含めて測定をしてくれるので、良いですね。&lt;/p>
&lt;p>実際にベンチマークを行うため使ったコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RegexTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String PATTERN_REGEX &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;^[0-9]*$&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> DecimalFormat DECIMAL_FORMAT &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;0000000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Pattern PATTERN &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(PATTERN_REGEX);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Predicate PREDICATE &lt;span style="color:#f92672">=&lt;/span> PATTERN.&lt;span style="color:#a6e22e">asPredicate&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Predicate MATCH_PREDICATE &lt;span style="color:#f92672">=&lt;/span> PATTERN.&lt;span style="color:#a6e22e">asMatchPredicate&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> VALUES &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 9999999).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(DECIMAL_FORMAT::format).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">patternMatches&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(Pattern.&lt;span style="color:#a6e22e">matches&lt;/span>(PATTERN_REGEX, value));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">matcherFind&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(PATTERN.&lt;span style="color:#a6e22e">matcher&lt;/span>(value).&lt;span style="color:#a6e22e">find&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">matcherMatches&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(PATTERN.&lt;span style="color:#a6e22e">matcher&lt;/span>(value).&lt;span style="color:#a6e22e">matches&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">predicate&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(PREDICATE.&lt;span style="color:#a6e22e">test&lt;/span>(value));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">matchPredicate&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(MATCH_PREDICATE.&lt;span style="color:#a6e22e">test&lt;/span>(value));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stringMatches&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(value.&lt;span style="color:#a6e22e">matches&lt;/span>(PATTERN_REGEX));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、測定の結果は以下の通りです。実際の出力はメソッド名の順番が違いますが、コードでの並び順に合わせて変えています。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
RegexTest.patternMatches thrpt 25 0.591 ± 0.013 ops/s
RegexTest.matcherFind thrpt 25 1.525 ± 0.022 ops/s
RegexTest.matcherMatches thrpt 25 1.481 ± 0.030 ops/s
RegexTest.predicate thrpt 25 2.050 ± 0.182 ops/s
RegexTest.matchPredicate thrpt 25 1.733 ± 0.236 ops/s
RegexTest.stringMatches thrpt 25 0.609 ± 0.005 ops/s
&lt;/code>&lt;/pre>&lt;p>この結果からして、性能面では確かに&lt;code>Matcher&lt;/code>か&lt;code>Predicate&lt;/code>を使った方が良いと言えるでしょう。ただ、ベンチマークの結果としては&lt;code>Predicate&lt;/code>が誤差を含めても性能がもっとも良いこととなっていますが、&lt;code>Pattern.asPredicate()&lt;/code>はJava 1.8、&lt;code>Pattern.asMatchPredicate()&lt;/code>はJava 11から導入されたので、JDKのバージョンに合わせて適切な方を選ぶ必要があります。&lt;/p>
&lt;p>ただ、結果だけでなく理由も知りたくなります。性能がよかった&lt;code>Matcher&lt;/code>と&lt;code>Predicate&lt;/code>の場合、テストではあらかじめインスタンスを作成しておいたという共通点があります。なので、性能の低い&lt;code>Pattern.matches()&lt;/code>と&lt;code>String.matches()&lt;/code>の場合、メソッドが呼び出されるたびにインスタンスを作成しているため遅くなっているのではないか、という推測もできますね。実際はどうか、コードをみていきましょう。&lt;/p>
&lt;p>まず&lt;code>Pattern.matches()&lt;/code>ですが、実際のコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Pattern.matches&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>(String regex, CharSequence input) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pattern p &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(regex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Matcher m &lt;span style="color:#f92672">=&lt;/span> p.&lt;span style="color:#a6e22e">matcher&lt;/span>(input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> m.&lt;span style="color:#a6e22e">matches&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをみると、&lt;code>Pattern&lt;/code>と&lt;code>Matcher&lt;/code>のインスタンスがメソッドを呼び出すたびに生成されるということがわかります(実際、&lt;code>Pattern.compile()&lt;/code>と&lt;code>Pattern.matcher()&lt;/code>のコードを追ってみるとインスタンスを作成するのがわかります)。なのでこちらが遅くなるのは当然のことですね。&lt;/p>
&lt;p>それでは、&lt;code>String.matches()&lt;/code>の場合はどうか、同じくコードから確認しましょう。実際のコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String.matches&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>(String regex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Pattern.&lt;span style="color:#a6e22e">matches&lt;/span>(regex, &lt;span style="color:#66d9ef">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これもまた、単に&lt;code>Pattern.matches()&lt;/code>を呼び出しているだけなので、遅いわけですね。ただ一つ違う点は、比較対象となる自分自身のインスタンスが必要なため、&lt;code>Pattern&lt;/code>とは違ってstaticメソッドではないというところといえますが、これは性能に影響する部分ではないので、ベンチマークでも誤差範囲の中の結果となったと思います。&lt;/p>
&lt;h2 id="実際のvalidatorを作る">実際のValidatorを作る
&lt;/h2>&lt;p>では、性能で&lt;code>Matcher&lt;/code>と&lt;code>Predicate&lt;/code>が有利であるということがわかったので、あとはこれを利用して、渡されたパスが許容できるものかどうかを判定するValidatorを作ります。今の案件ではJava 11を使うので、&lt;code>Predicate&lt;/code>を選びました。&lt;/p>
&lt;p>パスのパターンは複数あるので、配列やリストとしてパターンを指定して起きます。また、&lt;code>Predicate&lt;/code>で判定するので、あらかじめ指定したパターンでインスタンスを作成しておいて、判定が必要なときはパターンの配列やリストをループさせて、一致するものがあるかどうかを返すと良いでしょう。この要件から、実際のコードは以下のようになりました(パスの正規表現は、実際の業務とは違うものとなっていますが)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@NoArgsConstructor&lt;/span>(access &lt;span style="color:#f92672">=&lt;/span> AccessLevel.&lt;span style="color:#a6e22e">PRIVATE&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StorageValidator&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 許容されたパスのパターン
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> PATH_PATTERN_MATCHERS &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createMatcher(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;\\/contents\\/images\\/\\d{0,4}\\/(19[0-9]{2}|20[0-9]{2})(0[0-9]|1[0-2])\\/thumbnail\\.(?:bmp|jpg|jpeg|gif|png|BMP|JPG|JPEG|GIF|PNG)$&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createMatcher(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;\\/contents\\/images\\/\\d{0,4}\\/(19[0-9]{2}|20[0-9]{2})(0[0-9]|1[0-2])\\/thumbnail_backup\\.(?:bmp|jpg|jpeg|gif|png|BMP|JPG|JPEG|GIF|PNG)$&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 与えられた文字列が、SPLで利用できる有効なファイルアップロードパスであるかどうかを判定する.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param path 判定対象の文字列(ファイルパス)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @return 判定結果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isValidUploadPath&lt;/span>(String path) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> PATH_PATTERN_MATCHERS.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">anyMatch&lt;/span>(predicate &lt;span style="color:#f92672">-&amp;gt;&lt;/span> predicate.&lt;span style="color:#a6e22e">test&lt;/span>(path));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 与えられた正規表現から、{@link Predicate}型のパターンマッチャーオブジェクトを返す.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param pattern 正規表現
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @return 生成されたパターンマッチャーオブジェクト
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">createMatcher&lt;/span>(String pattern) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(pattern).&lt;span style="color:#a6e22e">asMatchPredicate&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上で、渡されたパスが想定のパターンと一致するものかどうか判定することができるようになりました。簡単ですね。&lt;/p>
&lt;h3 id="番外kotlinで書いてみたら">番外：Kotlinで書いてみたら？
&lt;/h3>&lt;p>今回のポストの内容とはあまり関係のないものですが、ちょっとした興味本位から、Javaで作成したValidatorをKotlinのコードに変えてみました。幸い、intellijには、Javaで書かれたコードをKotlinに変えてくれる便利な機能がありますので簡単にできます。そもそもKotlinを作ったのがJetbrain社なので、Kotlinを普及するための機能であるとは思いますが、おかげでJavaプログラマがKotlinに入門するのも簡単になりますね。&lt;/p>
&lt;p>&lt;code>static final&lt;/code>なフィールドをKotlinでは&lt;code>companion object&lt;/code>として扱うことになるらしく、コード自体はそう変わらない感覚です。ただ、Kotlinでは&lt;code>stream()&lt;/code>を呼び出さなくてもCollectionから直接呼び出すことのできるメソッド(&lt;code>any&lt;/code>)があったり、&lt;code>List.of()&lt;/code>も&lt;code>listOf()&lt;/code>で代替できるのですが、自動変換ではそこまでしてくれなかったので、そういうところ自分で変えるしかないです。それで完成したコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StorageValidator&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> PATH_PATTERN_UPLOAD = listOf( &lt;span style="color:#75715e">// 画像の保存先パスのパターン(正規)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Pattern&lt;/span>.compile(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/contents&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/images&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">d{0,4}&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/(19[0-9]{2}|20[0-9]{2})(0[0-9]|1[0-2])&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/thumbnail&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">.(?:bmp|jpg|jpeg|gif|png|BMP|JPG|JPEG|GIF|PNG)$&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .asMatchPredicate(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Pattern&lt;/span>.compile(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/contents&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/images&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">d{0,4}&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/(19[0-9]{2}|20[0-9]{2})(0[0-9]|1[0-2])&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/thumbnail_backup&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">.(?:bmp|jpg|jpeg|gif|png|BMP|JPG|JPEG|GIF|PNG)$&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .asMatchPredicate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">isValidUploadPath&lt;/span>(path: String): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">PATH_PATTERN_UPLOAD&lt;/span>.any { predicate &lt;span style="color:#f92672">-&amp;gt;&lt;/span> predicate.test(path) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>本当は、正規表現を使って文字列がパターンと一致するかどうかを判定する、という機能を作るのはそう難しいことではないですね。どちらかというと、正規表現そのものの書き方が難しいのでは、と思います。ただ、最近は&lt;a class="link" href="https://regexr.com" target="_blank" rel="noopener"
>RegExr&lt;/a>、&lt;a class="link" href="https://www.regextester.com" target="_blank" rel="noopener"
>RegEx Testing&lt;/a>、&lt;a class="link" href="https://regex101.com" target="_blank" rel="noopener"
>regular expressions 101&lt;/a>など、その場で入力した正規表現をテストしながら作成できるオンラインのツールなども多いので、じっくり時間をかけるといくらでも必要なパターンに合わせたものを作ることができると思います。&lt;/p>
&lt;p>個人的な感想としては、書いたコードは短く簡単でしたが、久々に色々と考えられる(効率の面で)チャンスとなったのでなかなか面白い作業になったと思っています。これからもこのような要件があるとしたら、また違う方法で挑戦してみたくなりますね。では、また！&lt;/p></description></item><item><title>Scope Functionはどう使うか</title><link>https://retheviper.github.io/posts/kotlin-scope-function/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-scope-function/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post Scope Functionはどう使うか" />&lt;p>KotlinがJavaと区別される特徴といえば色々あるとは思いますが、そのうちの一つとしてあげられるものが&lt;code>Scope Function&lt;/code>ではないかと思います。以前のポストでも簡単に触れたことがありますが、これらのビルトイン関数たちは確かに上手く使うと、Javaより簡潔なコードを書くばかりでなく、より作成者の意図が伝わりやすい、強力な武器になり得るのではないかと思います。しかしながら、やはり他の言語と比べて新しい概念のものであるので、どの場面で使った方が良いか、どう使ったらいいかという、いわゆるBest Practiceがどんなものであるか悩ましくもなりますね。&lt;/p>
&lt;p>おそらくこう思っているのは自分だけでなく、ネットから検索してみるとScope Functionに関しての多くの記事を見つけることができますが、大抵が個別の関数の使い方の紹介に過ぎないような気がしています。なので、具体的にこれらの関数はなんのためのものであり、それぞれどう使い分けるか、またどの場面で使うべきかというのが気になっていたところです。調べてみたところ、公式のドキュメントやいくつかのブログの記事などに情報があったので、これらをまとめて整理してみました。&lt;/p>
&lt;h2 id="そもそもscope-functionって">そもそもScope Functionって？
&lt;/h2>&lt;p>最初にScope Functionを言及しましたが、これは一体なんでしょう。まずはなぜこれらの関数にこんな名前がつけられたのかを知る必要がありそうです。&lt;a class="link" href="https://kotlinlang.org/docs/reference/scope-functions.html" target="_blank" rel="noopener"
>公式の説明&lt;/a>だと、以下のように述べています。&lt;/p>
&lt;blockquote>
&lt;p>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions.&lt;/p>&lt;/blockquote>
&lt;p>要するに、特定のオブジェクトに範囲(Scope)を限定し、Lambdaで書かれた関数を実行させたい場合に使えるもののようです。もちろん、これは全く新しい形の関数ではありません。形(コードの書き方)としては、オブジェクトの関数を呼び出しているだけのように見えるだけですね。しかし、コードをみてみると、コードブロックで警戒を作ることでより&lt;code>特定のオブジェクト&lt;/code>に限った処理であることが視覚的に、明確になります。例えば、以下のようなコードはどれもやっていることは同じですが、コードも読む側からすると処理を適用させる&lt;code>範囲&lt;/code>は後者の方が明確になりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Scope Functionなしのコード
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> john = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#a6e22e">Gender&lt;/span>.Male)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>john.doWarmingUp()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>john.startToRun()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Scope Functionのletを使った場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> john = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#a6e22e">Gender&lt;/span>.Male).let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.doWarmingUp()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.startToRun()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="どう違う">どう違う？
&lt;/h2>&lt;p>上述した通り、コードの範囲を限定することで、処理の範囲が明確になるのが分かりました。しかし、これでScope Functionを使う準備は整ったかというと、そうでもないです。実はそれ以外でも考えなければならないところがあるのです。なぜなら、Scope Functionには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" target="_blank" rel="noopener"
>with&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="_blank" rel="noopener"
>let&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="_blank" rel="noopener"
>run&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html" target="_blank" rel="noopener"
>also&lt;/a>の5つの関数が存在するからです。複数の関数が存在していることは、時と場合によって違う関数を選ぶ必要があるということでしょう。&lt;/p>
&lt;p>では、これらの関数は他と何が違うのでしょう。まず、考えられるのは仕様です。Scope Functionは、内部的には渡したLambdaを実行してその結果を返すこととなっています。だとすると、仕様としてはLambdaで扱うオブジェクトと戻り値の差だけとなります。Scope Functionには処理の対象となるオブジェクト(レシーバーと言います)と、Lambdaをまずパラメータとして渡すようになります。ここで渡したレシーバーへのアクセスをどう書くかと、処理後の戻り値がどうなるかがこの5つのScope Functionでそれぞれ違います。これをテーブルとして表すと、以下のようになります。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>関数名&lt;/th>
&lt;th>レシーバーのアクセス&lt;/th>
&lt;th>戻り値&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>with&lt;/td>
&lt;td>this&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>let&lt;/td>
&lt;td>it&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>apply&lt;/td>
&lt;td>this&lt;/td>
&lt;td>T&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>run&lt;/td>
&lt;td>this&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>also&lt;/td>
&lt;td>it&lt;/td>
&lt;td>T&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>また、withを除いた他の4つの関数たちは、&lt;a class="link" href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener"
>Extension Function&lt;/a>でもあるという特徴があります。 Extension Functionは何か？というと、簡単に、既定のクラスに関数を追加することです。Javaだとクラスの継承やラッパークラスの作成、オーバーライドなどで実現できる機能ですが、Kotlinでは簡単に定義できます。&lt;/p>
&lt;p>「Scope FunctionなのにExtension Functionでもあると？」と思うかもしれませんが、理由は簡単です。クラスの作成時に関数として定義してなくても、もともとそのクラスにあったかのように呼べる関数だから、ということです。どのオブジェクトでも、宣言しなくてもwithを除いたScope Functionをあらかじめ宣言しておいたかのように使うことができます。&lt;/p>
&lt;h3 id="参考itとthis">参考：itとthis
&lt;/h3>&lt;p>&lt;code>it&lt;/code>は、パラメータが一つのみのLambdaで使われるものです。例えばJavaだと、パラメータが一つだとしても、&lt;a class="link" href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener"
>Method Reference&lt;/a>を使わない限り以下のように書く必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> names &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;john&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;jack&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Predicateの引数は一つだけだが、&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> filtered &lt;span style="color:#f92672">=&lt;/span> names.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">filter&lt;/span>(name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;john&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">equals&lt;/span>(name)).&lt;span style="color:#a6e22e">findFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは、同じ状況だとパタメータを省略して単純に&lt;code>it&lt;/code>として表現することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> names: List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#e6db74">&amp;#34;john&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;jack&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// itでの省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> filtered = names.first { &lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;o&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>結局、&lt;code>this&lt;/code>と同じではないか？と思いがちですが、&lt;code>it&lt;/code>はLambdaのぱらめーたにスコープが限定されて、&lt;code>this&lt;/code>のスコープはローカルでもグローバルでもなれるという点が違います。なぜなら、&lt;code>this&lt;/code>はレシーバーそのものを指していて、パラメータがない場合はLambdaのスコープの外を指すことになるからです。つまり、パラメータのないLambdaではitを使えないですが、thisは使えるということになります。&lt;/p>
&lt;h2 id="いつ使う">いつ使う?
&lt;/h2>&lt;p>では、Scope Functionに5つの関数があり、それぞれどう違うかがわかったので、次はそれぞれをどう使い分けるか知りたいですね。さまざまな意見があったので、(自分の)納得の行くもので整理してみました。&lt;/p>
&lt;h3 id="with">with
&lt;/h3>&lt;p>&lt;code>with&lt;/code>はExtension Functionではないので、オブジェクトをパラメータとして受け取る一般的な関数として使えます。このような特徴があるので、複数のオブジェクトで同じような処理を行う必要があるときに使えます。例えばforループの中で、わざとメソッドを分離したくない(命名がめんどくさいとか…)の場合に使えるでしょう。また、やはりScope Functionなので、処理の範囲を明確に区分するためにも使えそうですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (name &lt;span style="color:#66d9ef">in&lt;/span> names) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with(name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> rev = &lt;span style="color:#66d9ef">this&lt;/span>.reversed()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reversedName.add(rev)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="let">let
&lt;/h3>&lt;p>オブジェクトをトリガーにして、そのオブジェクトを持って何かの処理を行いたい場合に使うものです。&lt;code>let&lt;/code>の意味通り、そのオブジェクトを持って何かをするというイメージですね。また、戻り値も最後の結果となるので、それを持ってまた何かができそうです。また、&lt;a class="link" href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls" target="_blank" rel="noopener"
>Safe Call&lt;/a>な使い方ができるため、Nullではない場合のみの動作として指定することも可能です。なのでNullになり得るオブジェクトでは、&lt;code>let&lt;/code>を使った方が良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> name: String? = &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#f92672">?.&lt;/span>let { println(&lt;span style="color:#e6db74">&amp;#34;name is not null&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="apply">apply
&lt;/h3>&lt;p>Lambdaでレシーバーの関数を使わず、レシーバーそのものを返却する場合に使います。つまり、レシーバーのプロパティに新しい値を入れる場合のことです。代表的にはオブジェクトの初期化がありますね。もちろん初期化だけなら、コンストラクタを呼ぶだけで十分ではないかと思われますが、同じオブジェクトの値を入れ替える(例えばConfigurationクラスなど)場合に役立つらしいです。例えば以下のような場合を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (devMode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeConfig().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#e6db74">&amp;#34;devMode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="run">run
&lt;/h3>&lt;p>他の4つの関数で事足りるので、なるべくこれは使わないように、という話が多いです。確かに、runはノーマルな関数としても使えるので(&lt;code>run {}&lt;/code>)、&lt;code>with&lt;/code>との違いがいまいちわからない感覚ではありますね。あえて使う場合は、オブジェクトの値をオーバーライドする時だそうです。でも、これも&lt;code>let&lt;/code>でできるので、あえて使う必要はなさそうです。多くのケースで、これは推奨されてませんでした。&lt;/p>
&lt;p>ただ、一部ではオブジェクトの初期化として使うと便利と言ってました。確かに&lt;code>this&lt;/code>を使うので、少しながら&lt;code>it&lt;/code>を使う&lt;code>let&lt;/code>よりコードが短くなり得るというメリットはありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// runを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> result1 = server.run {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port = &lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/members:&lt;/span>&lt;span style="color:#e6db74">$port&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// letを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> result2 = server.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.port = &lt;span style="color:#ae81ff">8081&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/members:&lt;/span>&lt;span style="color:#e6db74">${it.port}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="also">also
&lt;/h3>&lt;p>オブジェクトがトリガーとなり、そのオブジェクトとは関係のない別の処理を行います。なので、元のオブジェクトがNullであっても、そのオブジェクトが呼ばれた時点でなんらかの処理を行うことができます。これを応用すると、条件分岐(三項演算子)のように使うことも可能です。例えば、こんな感じですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> name: String? = &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#f92672">?.&lt;/span>let { println(&lt;span style="color:#e6db74">&amp;#34;name is not null&amp;#34;&lt;/span>) } &lt;span style="color:#f92672">?:&lt;/span> also { println(&lt;span style="color:#e6db74">&amp;#34;name is null&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="まとめ">まとめ
&lt;/h3>&lt;p>&lt;a class="link" href="https://medium.com/@brijesh1794/kotlin-standard-library-let-run-also-apply-with-bb08473d29fd" target="_blank" rel="noopener"
>Kotlin Standard Library (let, run also, apply, with)&lt;/a>では、5つのScope Functionのどれを使うか判断する基準を、フローチャートとして提示しています。以下は、そのフローチャートを簡単に翻訳したものです。どれを使うか悩ましい時は、こういう基準でコードを書いても良さそうですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function.webp"
width="3483"
height="1203"
srcset="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function_hu_92d3a651e46012e0.webp 480w, https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function_hu_345f8c42e2fb8f0f.webp 1024w"
loading="lazy"
alt="Kotlin Select Scope Function"
class="gallery-image"
data-flex-grow="289"
data-flex-basis="694px"
>&lt;/p>
&lt;h2 id="応用">応用
&lt;/h2>&lt;p>Scope Functionが戻り値としてレシーバーそのものを返すというのは、すなわちBuilderパターンとして使えるという意味でもあります。なので、適切な組み合わせで、Scope Functionによるメソッドチェーンもできます。これをよく活用すると、かなり関数型的な感覚でコードを書くことができるでしょう。以下は、その例の一つです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// letの連鎖
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> three: Int = &lt;span style="color:#e6db74">&amp;#34; abc &amp;#34;&lt;/span>.let { &lt;span style="color:#66d9ef">it&lt;/span>.trim() }.let { &lt;span style="color:#66d9ef">it&lt;/span>.length }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// alsoの連鎖
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> jack: Person = Person(&lt;span style="color:#e6db74">&amp;#34;Jack&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#a6e22e">Gender&lt;/span>.MALE).also { println(&lt;span style="color:#66d9ef">it&lt;/span>.name) }.also { &lt;span style="color:#66d9ef">it&lt;/span>.doWarmingUp() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>実は、このようなKotlinの機能は、そう新しいものでもありません。なぜなら、同じJVM言語であり、同じく機能する&lt;code>with()&lt;/code>のような関数を提供している&lt;a class="link" href="http://groovy-lang.org" target="_blank" rel="noopener"
>Groovy&lt;/a>があるからです。自分の中では&lt;a class="link" href="http://spockframework.org" target="_blank" rel="noopener"
>Spock&lt;/a>かGradleのイメージしかないのですが…&lt;/p>
&lt;p>ただ、このようにKotlinが提供する機能は「新しくはないけど、快適」という感覚を確かに伝えてくれているような気がします。なのでJavaプログラマーがKotlinに転向していく数も増えているのでしょう。最近は特にPythonやJavaScriptのような言語が人気を得ているところですが(Kotlinは&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE&lt;/a>の順位からだと見えもしないし…)、もっと性能と安定性、そして快適な開発のバランスを持ちたいと思う人にはぜひおすすめしたい言語です。なのでもっと、Kotlinの魅力をより多くの人(自分を含め)にわかった欲しいところです。今回のポストで少しはそれが伝わると幸いですね。&lt;/p>
&lt;p>では、また!&lt;/p></description></item><item><title>JavaプログラマーがみたKotlin</title><link>https://retheviper.github.io/posts/kotlin-first-impression/</link><pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.webp" alt="Featured image of post JavaプログラマーがみたKotlin" />&lt;p>KotlinがAndroidの公式言語になってからもだいぶ長い時間が経ちましたが、まだまだWebアプリケーションの業界ではサーバサイド言語としてはJavaを使う企業も多く(自分の場合がそうです)、モバイル業界でもJavaを使うところが多いようです。Javaも9以降はアジャイル開発でバージョンアップにスピードを出していて、いわゆるモダンな言語の特徴を吸収していってますが、そもそもの言語のデザインが古いし、互換性のために昔ながらの名残を捨てられてないところもあるので根本から違う哲学でデザインされた言語とはかなり違うはずです。また、JVMを利用しない&lt;a class="link" href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener"
>Kotlin Native&lt;/a>も発表されているので、今後Javaよりも活躍できる場面が多いかも知れないなーという気がしたりもします。(&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>は使われることあるのかな…)&lt;/p>
&lt;p>取りまとめ、まだ正式の研修とかを受けたわけでなく、あくまでSpring WebFluxを使って簡単なアプリを作ってみるついでに使ってみただけなので、よくわかってない部分も多いかと思いますが、今まで触れてみた感想をJavaプログラマーの観点から簡単に紹介したいと思います。&lt;/p>
&lt;h2 id="これがよかった">これがよかった
&lt;/h2>&lt;p>まずは使ってみてよかったところから。結論からとなりますが、良いと思ったところはおおよそイメージ通り(期待してた通り)という感覚です。&lt;/p>
&lt;h3 id="やはりモダンな感じ">やはりモダンな感じ
&lt;/h3>&lt;p>Kotlinで書いたコードを見ると、モダンな言語だとやはりこんなものかなという感覚ではあります。モダンな言語が何か、という定義から必要になるのではという気もしますが、例えばSwift、Kotlin、Goみたいなものですね。あまり他の言語に詳しいわけではないのですが、これらの言語はなんとなくPythonに似ているような気がします。例えば&lt;code>var&lt;/code>、&lt;code>fun&lt;/code>のように基本文法で略語をよく使っていたり、型の指定はコロンの後につけたり、セミコロンがなかったり、&lt;code>in&lt;/code>や&lt;code>Range&lt;/code>、&lt;code>is&lt;/code>があるなどの共通点があったりしますので。他には、言語の使用ではないけど、一般的にはGetter/Setterを使わずフィールドに直接アクセスするところですかね。(おかげでLombokを使う必要がないのも便利ではあります)&lt;/p>
&lt;p>ただ、そんなモダンな感覚でありながらも、やはりKotlinはJavaよりな感覚ではあります。厳格なJavaをよりゆるくしただけの感覚といえばいいでしょうか。例えばPythonだと&lt;code>elif&lt;/code>なのですが、Kotlinでは&lt;code>else if&lt;/code>だったりしますので。JVM言語という理由だけでなく、基本文法からしてもJavaプログラマーならすぐに適応できる言語でもあります。例えばforループにラベルをつけることができたりします。&lt;/p>
&lt;p>あえてJavaとの比較をするとしたら、やはり冗長さを省けただけでなく、Javaという言語のデザインを根本的に変えようとしている気もしていました。例えばNullや、Mutableを扱う方式がそうです。Kotlinでは基本的に変数はNullになれなくて、Nullになれるオブジェクトは最初からそうであると宣言する必要があり、Nullになれるオブジェクトを扱う時もSafe Callを強制することでNullに対してはコンパイラレベルではできるだけサポートしている感覚です(おそらくこれはモダンな言語だと全部がそうですが)。そしてCollectionなどを宣言する時も、あえてMutableという宣言をしない限りは基本的にImmutableなオブジェクトが生成されます。これだけでもJavaでもっともよく見つかるNPEをよく避けられる気がしてしまいます。いちいち宣言して、コールもクエスチョンマークをつける必要があるのは面倒臭いことな気もしますが、コンパイルエラーの方がランタイムエラーよりはずっとマシだというのは我々みんなが知っていることではないでしょうか。&lt;/p>
&lt;p>あとは、個人的にPythonで使ってみてよかったなと思った機能がKotlinにもあってよかったです。例えばMultiple Return(複数の戻り値)だったり、Named argument(名前付き引数)があります。前者は特に、Pair/Tripleという型で明確な戻り値を提示できるのが素晴らしいと思います。こういうところはモダンながらも、Javaの持つ安定性もしくは丈夫さを捨ててなかったなという印象を与えてくれました。&lt;/p>
&lt;p>ただ、これらのメリットは最近のJavaもかなり近づいている状態ではあります。(まだ少し遅い感はありますが)&lt;/p>
&lt;h3 id="クラスファイルではない">クラス=ファイルではない
&lt;/h3>&lt;p>Javaの場合は、一つのファイルには一つのクラスというのが常識のようになっています。もちろんInner Classを書く場合もありますが、それだと名前とおりクラスの中に含まれたものになるので、インスタンスを生成するときに複雑だったりしますね。でもKotlinだと、純粋なクラスを一つのファイルに複数書くことができます。&lt;/p>
&lt;p>なので、似たようなクラスを一つのファイルの中に集めておくことができますね。例えばDTO、DAO、Entityなど似たようなクラスが複数損際するパターンでは、一つのファイルの中にそれらを集めておいた方がパッケージの中が複雑にならないような気がします。実際、Kotlinを試しながら好みの領域の話かもしれませんが。&lt;/p>
&lt;p>どちらかを選択できる自由があるというのが、必ずしも良いこととは言い切れませんが、ファイル内にクラスを複数書くかどうかはキメの問題であって実装時のコーディングスタイルに影響を与えるものではないので(今時importを直接書く人もいないだろうし…)、良い点として挙げられるのではないか、と思います。&lt;/p>
&lt;h3 id="拡張関数で自由に関数を追加できる">拡張関数で自由に関数を追加できる
&lt;/h3>&lt;p>Javaのデメリットとしてよく挙げられているのが、冗長すぎる(verbose)ということです。いわゆるBoilerplateなコードを毎回書かなくてはならないというのは、生産性の面からもよくないです。Javaにこういう面があるので、さまざまなデザインパターンが発達したり、IDEでコードを自動生成してくれたり、Lombokのようにコードの量を減らしてくれるライブラリが人気だったりしますね。自分が開発に参加したフレームワークの開発の案件も、結局は冗長化するコードを減らしたいという目的によるものでした。&lt;/p>
&lt;p>とにかく、Kotlinはこういう問題に対する反発ないしは反省から言語がデザインされているようにも見えます。最近のモダンな言語の特徴をコピーしただけでなく、Javaを改善させたいという強い意志が言語のデザインから感じ取れているような感覚でした。&lt;/p>
&lt;h3 id="スタンダードライブラリがとにかく便利">スタンダードライブラリがとにかく便利
&lt;/h3>&lt;p>拡張関数が便利な理由ともつながるようなことですが、Kotlinのスタンダードライブラリに存在する関数たちもまた同じ観点から便利といえます。例えば、すでに有名なのがいわゆる&lt;code>Scope Functions&lt;/code>の&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="_blank" rel="noopener"
>let&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" target="_blank" rel="noopener"
>with&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="_blank" rel="noopener"
>run&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html" target="_blank" rel="noopener"
>also&lt;/a>のような関数です。&lt;/p>
&lt;p>これらはJavaだと別途ユーティリティクラスを作るか、プライペートなメソッドを定義するか、特定のクラスを継承してからオーバライドで関数を新しく定義するなどの方法で対応はできるものの、やはり手間がかかるのでやりたくはないものです。これをKotlinでは、より関数型的な方法で解決してくれます。例えばletの例を見ていきましょう。以下のようなdata classがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Member&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> region: String, &lt;span style="color:#66d9ef">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このdata classのインスタンスを一つ作成します。そうすると以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> john = Member(&lt;span style="color:#e6db74">&amp;#34;Tokyo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとで、同じくMemberのインスタンスとしてjakeという変数を追加するとします。jakeは常にjohnと同じregionである必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> jake = Member(&lt;span style="color:#e6db74">&amp;#34;Tokyo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをJavaの考え方で、コードを整理するとしたら以下のようになります。regionを同じインスタンスを使うようにすることですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> tokyo = &lt;span style="color:#e6db74">&amp;#34;Tokyo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> john = Member(tokyo, &lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> jake = Member(tokyo, &lt;span style="color:#e6db74">&amp;#34;Jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをletを使う場合のコードとして書くと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> jake = john.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Member(&lt;span style="color:#66d9ef">it&lt;/span>.region, &lt;span style="color:#e6db74">&amp;#34;jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>共通のregionを別途変数として宣言したくても、jakeのregionはjohnに指定したregionと同じ値となります。そしてある意味、こちらの方が「johnとjakeは同じregionを共有する」という意図がコードの中によく表れているのではないか、という気もします。今は簡単なフィールドを共有しているだけですが、変数の数が増えたり処理すべき項目が多くなった場合はいちいち定数を宣言するよりも、このような書き方の方がより優雅になるのではないか、と思います。そういう意味では、かなり洗練された方法を提供していますね。同じことをJavaでまねるとしたら…あまりやりたくなくなりそうです。&lt;/p>
&lt;h2 id="これはいまいち">これはいまいち
&lt;/h2>&lt;p>KotlinがJavaのさまざまな問題や不便さに注目し、それらの多くを解消してくれたのは事実ですが、果たして&lt;code>全て&lt;/code>Javaより発展しているか、というとそうでもないような気もします。ただし、ここであげているKotlinの問題点ないしデメリットは、メリットと同様、個人的な見解なので参考までに。&lt;/p>
&lt;h3 id="varと型">varと型
&lt;/h3>&lt;p>モダンな言語から接した人なら、変数の宣言が&lt;code>var&lt;/code>だけで集結するのはメリットと言いたくなるかもしれません。実際Kotlinだけでなく、JavaScriptやC#など現代に使われる大体の言語は&lt;code>var&lt;/code>に対応していて、あのJavaすらも10から&lt;code>var&lt;/code>による変数の表記を導入しています。また、Pythonのようにそもそも&lt;code>var&lt;/code>の宣言すらいらない言語があったりもしますね。&lt;code>var&lt;/code>をつけることで変数であることが明確だという考え方から来てるのか、Javaとは違って関数も&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88" target="_blank" rel="noopener"
>First Class Object&lt;/a>として扱う言語としては関数と同様に表記したいからそうしてるのか、よくわかってないのですが、どっちかというと流行りのもののようです。&lt;/p>
&lt;p>こういう傾向だけを見ると、「変数は変数であることが分かればいい」というだけの話になっているようにも思えます。しかし、私はこの&lt;code>var&lt;/code>が果たして良いものであるかという疑問を持っています。Javaに慣れすぎていて、新しいのを受け入れられてない、もしくは&lt;code>var&lt;/code>の良さをわかってないだけかもしれませんが、とにかく「型指定で変数であることも、型もわかるからこっちの方が良くないか」と思ってしまいます。&lt;/p>
&lt;p>こう思うまたの理由は、モダンなプログラミング言語の中でもTypeScriptのように、あえて型指定ができるように既存の言語を変えようとする動きもあるからです。Pythonの場合も3.6から型を宣言できるようになっています。これ自体が、「変数は変数であることが分かればいい」から「変数の型もわかった方がいい」に変わっているように見えます。ただ、問題は最初から型指定で変数を指定する方法がなく、&lt;code>var&lt;/code>しかない言語に型指定(型注釈)が付く場合です。&lt;code>var&lt;/code>のメリットである短くかけるというところが、型指定をすることで台無しになります。&lt;/p>
&lt;p>例えば、Kotlinでの&lt;code>var&lt;/code>だけの宣言だと以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> a = &lt;span style="color:#e6db74">&amp;#34;this is string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして&lt;code>var&lt;/code>に型を指定すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> b: String = &lt;span style="color:#e6db74">&amp;#34;this is string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの伝統的な書き方だと以下です。こちらの方が、むしろコードは短くなるし、変数であることも明確ではないでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is string&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、厳密にいうと変数ではないところでは&lt;code>var&lt;/code>をつけないのは当たり前なのかもしれませんが、Javaだと変数でも戻り値でも引数でも型をつけてしまうのに対して、Kotlinではこれらに&lt;code>var&lt;/code>をつけるか型をつけるか方が省略できるかという場面がそれぞれ区別されてしまうので、これだけはJavaよりも厳格じゃないか？という気になったりもします。例えば以下のような例です。&lt;/p>
&lt;p>関数の引数の場合は、型の指定が必要です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#66d9ef">it&lt;/span>.username, &lt;span style="color:#66d9ef">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして関数の戻り値は、型推論により省略可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>(request: ServerRequest) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#66d9ef">it&lt;/span>.username, &lt;span style="color:#66d9ef">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これはあくまで関数をSingle Expressionで書いた時の話です。明示的にreturnを書く場合は戻り値を省略するとコンパイルエラーになります。例えば以下のような場合がそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// これはコンパイルエラー(戻り値はUnitとなってしまう)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>(request: ServerRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#66d9ef">it&lt;/span>.username, &lt;span style="color:#66d9ef">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、data classの場合はフィールドに&lt;code>val&lt;/code>か&lt;code>var&lt;/code>をつける必要があります。しかし、一般的なクラスを宣言する場合は要りません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// data classではvalかvarが必要
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MemberDto&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> username: String, &lt;span style="color:#66d9ef">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// classなら必要ない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MemberEntity&lt;/span>(username: String, name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通常はコンパイルエラーになるので、慣れるまではKotlinのルールに従ってコードを見直すしかないのですが、Javaからの入門だとかなり混乱する部分です。(自分だけかもしれませんが…)&lt;/p>
&lt;h3 id="依存関係">依存関係
&lt;/h3>&lt;p>プロジェクトにKotlinを使う場合はスタンダードライブラリを追加して使う必要があります。ただ、ここで&lt;code>kotlin-stdlib&lt;/code>だけを追加すると、Java 1.7以降に追加された一部の機能(AutoCloseableなど)を使えなくなります。なので、Java 1.7以降の機能を使いたい場合は&lt;code>kotlin-stdlib-jdk7&lt;/code>か&lt;code>kotlin-stdlib-jdk8&lt;/code>を依存関係に追加する必要があります。&lt;/p>
&lt;p>個人的にはOracleとGoogleの訴訟沙汰のようなことがあって、わざと著作権を避けるための独自のパッケージを作ったりしらからではないかなと思いましたが、実際はJava 9から導入されたModuleシステムに対応するための理由だそうです。なので&lt;code>kotlin-stdlib-jre7&lt;/code>が&lt;code>kotlin-stdlib-jdk7&lt;/code>に、&lt;code>kotlin-stdlib-jre8&lt;/code>が&lt;code>kotlin-stdlib-jdk8&lt;/code>に代替されたらしいですね。&lt;/p>
&lt;p>とにかく、これらのスタンダードライブラリを使うには、MavenやGradleのような依存関係を管理するパッケージマネージャを使って一回だけ登録しておけばよく、そこまでめんどくさくはないことなのかもしれませんが、例えば&lt;code>kotlin-stdlib-jre8&lt;/code>があったりするので、初めはどれを選べば良いか、どれが必要であるかを把握するのにも時間を使ってしまうことになるのでデメリットになるのではないかと思います。例えば&lt;code>kotlin-stdlib-jdk7&lt;/code>がなくても、AutoCloseable以外のJDK 1.7の機能は使えたりするのですが、今から作るプロジェクトや既存のプロジェクトにAutoCloseableが使われるかどうかで依存関係をまた追加するかどうかを調べるのもかなり面倒くさそうです。&lt;/p>
&lt;p>そしてJDK7やJDK8対応のスタンダードライブラリが別途存在するということは、今後JavaがバージョンアップしたらまたJDK 17などの新しいスタンダードライブラリが追加される可能性があるということでもあるでしょう。7(1.7)と17はよく勘違いしそうだし…あと、JDK以外の依存関係のパッケージが色々あるので(&lt;code>kotlin-reflect&lt;/code>など)、プロジェクトの構成によってはKotlinの導入にはかなり慎重になる必要がありそうです。ある意味、KotlinがPost Javaとしてのポテンシャルは十分でありながらも、Androidアプリの作成以外にではあまり導入されてないのはこのような理由もあるのではないかという気もしています。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>簡単にPros・Consに分けて自分が感じたKotlinに対して書いてみました。実はまだ本格的な案件で触れてみたわけでもないので、&lt;a class="link" href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="noopener"
>Type aliases&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/docs/reference/inline-classes.html" target="_blank" rel="noopener"
>inline class&lt;/a>のような良さそうな機能に触れてもないです。でもやはり、使えば使うほど魅力的な言語であるなと感じているところです。なので個人的な意見としては、すでにJavaを使っているところなら本格的にKotlinへの移行を考慮しても良いのでは、と思っています。Javaプログラマーなら慣れやすく、より生産性も高いながら、Javaとの100%の互換性も担保されているので…言語の完成度やJVM対応でありながらNative、JavaScriptとの連動も可能なのを見るとまさにPost Javaとして相応しい言語なのではないかと思うくらいです。(他のJVM言語には悪いですが…)&lt;/p>
&lt;p>そういう意味で皆さん、今からでもKotlinやりませんか！&lt;/p></description></item><item><title>AWS認定デベロッパー - アソシエイトについて</title><link>https://retheviper.github.io/posts/aws-certification-associate-developer/</link><pubDate>Sun, 04 Oct 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/aws-certification-associate-developer/</guid><description>&lt;img src="https://retheviper.github.io/images/aws.webp" alt="Featured image of post AWS認定デベロッパー - アソシエイトについて" />&lt;p>入社してから自分で立てた目標は、年に1つ以上の資格を取ることです。それは自分が元文系出身であって、転職でエンジニアになったので他の人と比べエンジニアとしてのベースとなる知識が足りないからです。なので「何から勉強したら良いかわからない」場合も多く、資格の勉強をしていると少なくとも問われることに対しての勉強はできるので、資格の勉強を頼りにして自分のスキルアップを狙っています。&lt;/p>
&lt;p>そんな中、今回はAWS認定の資格を受験しました。AWS認定資格の種類は以下の画像の通りですが、この中で自分が受験したのはデベロッパー - アソシエイトです。仕事でAWSの基本的なサービス(EC2とS3など)に触れたことがあり、AzureでもFunctionsとQueueによる簡単なサーバレスアプリを作ってみたり、Bastionなどのサービスを使ってみた経験があったので悩まずデベロッパーを選択。なんとか受かりましたが、少し使ってみただけで気安く挑戦するような資格ではなかったと実感しました…&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/aws-certification-associate-developer/aws_certifications.webp"
width="2040"
height="1172"
srcset="https://retheviper.github.io/posts/aws-certification-associate-developer/aws_certifications_hu_6583220111e79d7f.webp 480w, https://retheviper.github.io/posts/aws-certification-associate-developer/aws_certifications_hu_6ee18f73b40fec33.webp 1024w"
loading="lazy"
alt="AWS Certification"
class="gallery-image"
data-flex-grow="174"
data-flex-basis="417px"
>
&lt;em>出典：AWS公式サイト - &lt;a class="link" href="https://aws.amazon.com/jp/certification/?nc1=h_ls" target="_blank" rel="noopener"
>AWS認定&lt;/a>&lt;/em>&lt;/p>
&lt;p>ともかく、前回の&lt;a class="link" href="../java-se-8-gold" >Java資格の時&lt;/a>でもそうであったように、今回も自分の観点からテストはどうだったかについて簡単に述べていきたいと思います。&lt;/p>
&lt;h2 id="試験はどんな感じか">試験はどんな感じか
&lt;/h2>&lt;p>問題で問われる知識の内容や範囲(AWSのサービスの種類)の側面でなく、テストそのものはどうかというと、学生時代の歴史の科目のような感覚のテストでした。もちろん、テストとは受験者の持っている知識の確認が基本なのであって、AWSのサービスの仕様や特徴などを問われるだろうと推測するのは自然なことだと思います。しかし、実際のテストで問われるのは「このようなアプリを開発するためにはどんなサービスを使って、どのような構成にするべきか？」といった物よりも、「このような要件で、入力すべきCLIのコマンドは何か？」、「この状況下のこのサービスで、〇〇を設定するために使うオプションは何か？」のような、暗記の問題が多い感覚です。例えば、特定のサービスにとある設定をするために使うファイルの「ファイル名」を選ぶような問題があったりします。&lt;/p>
&lt;p>AWSには本当に多様なサービスがあって、それぞれの役割や領域が重なる部分もあるので、サービスの仕様を正確に把握していない場合は設計も開発も難しくなるので、自然に試験もこのような形になるのかも、とは思っています。特に資格のレベルが上がり、アプリケーションの設計という面で考えると、開発の効率やコストの問題も考えなくてはならないので、各サービスの仕様の詳細までを知っておく必要があるでしょう。&lt;/p>
&lt;p>ただ、このようなクラウドサービスの発達により、インフラもコードで書いて構築する時代となっているし、資格も「デベロッパー」なのに、より開発者よりな形の試験にするのはできなかったのかな？と思ったりもしました。例えばLambdaについての問題だとすると、頻繁なアクセスがある場合と処理量の多い場合はそれぞれどの言語で書いた方がいいか、を聞いたりしたらよかったのではないかなと思いました。&lt;/p>
&lt;h2 id="どうやって準備したか">どうやって準備したか
&lt;/h2>&lt;p>自分の場合はアソシエイトの3つの資格の概要をまとめた本を購入しましたが、あくまでAWSのサービスを紹介するものでしかなかったので、&lt;a class="link" href="https://www.udemy.com/" target="_blank" rel="noopener"
>Udemy&lt;/a>で5回分の模擬試験の講座を購入しました。ただ、こちらもデベロッパーをターゲットとしてるよりは、プロフェッショナルレベルの資格の内容も含めているような印象でした。どちらかというとUdemyの模擬試験の方が難しかったと思います。他にもUdemyの模擬試験も複数ありますので、どれを選ぶかによってまた実際のテストで受ける印象は変わってくるのではないかと思います。&lt;/p>
&lt;p>個人的には他の資格もある程度問われる知識に関しては共有する部分が多いと思うので、難易度の高い模擬試験の講座を購入し、繰り返して解いてみることがもっとも効率的ではないかと思います。そうすると他の資格を受験するときに役立つ可能性もあるでしょう。他にもAWSのオンライン動画講座を受講したり(無料ですが、英語版しかないです)、公式のドキュメントを参照したりしていました。AWSの公式の&lt;a class="link" href="https://aws.amazon.com/jp/training/course-descriptions/" target="_blank" rel="noopener"
>トレーニングコース&lt;/a>で動画やPDFの資料を提供していますので、目を通しておくのをオススメします。&lt;/p>
&lt;p>また、プラクティショナから取得されている方にはあまり当てはまらないことなのかもしれませんが、AWSのサービスは略称で呼ばわれることが多く、名称だけではどんなサービスなのか推測が難しいので、少なくとも模擬試験で言及されるサービスに対しては自分の辞書を作っておくのをオススメします。&lt;a class="link" href="https://aws.amazon.com/jp/ebs" target="_blank" rel="noopener"
>EBS&lt;/a>と&lt;a class="link" href="https://aws.amazon.com/jp/efs" target="_blank" rel="noopener"
>EFS&lt;/a>はストレージなのに、&lt;a class="link" href="https://aws.amazon.com/jp/ecs" target="_blank" rel="noopener"
>ECS&lt;/a>はコンテナサービスだったりするので…(他にも、&lt;a class="link" href="https://aws.amazon.com/jp/sqs" target="_blank" rel="noopener"
>SQS&lt;/a>と&lt;a class="link" href="https://aws.amazon.com/jp/sns" target="_blank" rel="noopener"
>SNS&lt;/a>はメッセージングなのに&lt;a class="link" href="https://docs.aws.amazon.com/STS/latest/APIReference/welcome.html" target="_blank" rel="noopener"
>STS&lt;/a>はセキュリティ関連の物だったりします)&lt;/p>
&lt;p>とにかく「覚える」ことがまず大事な資格だと思います。&lt;/p>
&lt;h2 id="何を問われるか">何を問われるか
&lt;/h2>&lt;p>それでは、次は試験の内容です。AWS公式サイトのデベロッパーの&lt;a class="link" href="https://aws.amazon.com/jp/certification/certified-developer-associate/" target="_blank" rel="noopener"
>紹介ページ&lt;/a>を見ると、&lt;strong>推奨される知識と経験&lt;/strong>としていくつか挙げられている項目がありますが、これはあくまで大まかな概念の話であって、実際のテストで具体的に何を問われるかは提示されていません。サンプル問題があるのでそちらを参照することはできますがね。自分の場合は模擬試験を通じて勉強はしたものの、模擬試験のうちどれがデベロッパーに当てはまるかは分かりませんでしたので、AWの公式の模擬試験を購入するのもありかなと思いました。&lt;/p>
&lt;p>とにかく、実際のテストでよく問われれる(デベロッパーとして重要視される)と感じたのは以下のような物です。&lt;/p>
&lt;h3 id="サーバレスアーキテクチャ">サーバレスアーキテクチャ
&lt;/h3>&lt;p>もっとも多かった問題のパターンは、サーバレスアーキテクチャでの開発に関するものです。つまり、&lt;a class="link" href="https://aws.amazon.com/jp/lambda" target="_blank" rel="noopener"
>AWS Lambda&lt;/a>と&lt;a class="link" href="https://aws.amazon.com/jp/dynamodb" target="_blank" rel="noopener"
>Amazon DynamoDB&lt;/a>、もしくは&lt;a class="link" href="https://aws.amazon.com/jp/kinesis/" target="_blank" rel="noopener"
>Amazon Kinesis&lt;/a>の組み合わせでアプリを構築する場合を提示して、そこで注意すべきことや、障害が起きた場合の対処、各種設定方などを問われます。単純にサーバレスがどんな物であるか、を理解しているだけでは十分ではないと思います。なので以上の三つに関しては、詳細まで勉強する必要があります。Lambdaでの依存関係の設定はどうするか、スケーリングを考慮したシャードの設定方法、RCUとWCUのスペックなどを覚えておくといいでしょう。&lt;/p>
&lt;p>また、サーバレス開発をする場合だとしても、エンドポイントやセキュリティ周りのことは一般的なアプリケーション開発(サーバあり)と変わらないので、一般的な開発のパターンで考えるべきところの問題もありました。例えば、&lt;a class="link" href="https://aws.amazon.com/jp/api-gateway" target="_blank" rel="noopener"
>Amazon API Gateway&lt;/a>の設定やS3、CLIコマンドの使い方などがあります。&lt;/p>
&lt;h3 id="セキュリティ">セキュリティ
&lt;/h3>&lt;p>セキュリティに関する問題もあります。主に&lt;a class="link" href="https://aws.amazon.com/jp/iam" target="_blank" rel="noopener"
>IAM&lt;/a>でのポリシー、ロール、グループの設定や、&lt;a class="link" href="https://aws.amazon.com/jp/kms" target="_blank" rel="noopener"
>KMS&lt;/a>を使った暗号化キーのマネージメント、などがあります。Lambdaについての問題があるので、もちろんLambdaオーソライザーに関しての問題もありました。&lt;/p>
&lt;h2 id="ログ監視">ログ・監視
&lt;/h2>&lt;p>アプリケーションに障害が起きた場合での追跡方法や、監視したい要件でどのような設定をすべきかを問われます。例えば&lt;a class="link" href="https://aws.amazon.com/x-ray" target="_blank" rel="noopener"
>X-Ray&lt;/a>デーモンの設定方法や、&lt;a class="link" href="https://aws.amazon.com/jp/cloudwatch" target="_blank" rel="noopener"
>CloudWatch&lt;/a>と&lt;a class="link" href="https://aws.amazon.com/jp/cloudtrail" target="_blank" rel="noopener"
>CloudTrail&lt;/a>の違いが何かなどをとう問題があります。&lt;/p>
&lt;h3 id="code兄弟">Code兄弟
&lt;/h3>&lt;p>CI/CD関連で問われる問題です。&lt;a class="link" href="https://aws.amazon.com/jp/codepipeline" target="_blank" rel="noopener"
>CodePipeline&lt;/a>、&lt;a class="link" href="https://aws.amazon.com/jp/codedeploy" target="_blank" rel="noopener"
>CodeDeploy&lt;/a>、&lt;a class="link" href="https://aws.amazon.com/jp/codebuild" target="_blank" rel="noopener"
>CodeBuild&lt;/a>、&lt;a class="link" href="https://aws.amazon.com/jp/codestar" target="_blank" rel="noopener"
>CodeStar&lt;/a>に関して問われますが、それぞれの役割をちゃんと理解していれば難しくはないです。&lt;/p>
&lt;p>ただ、機能的に&lt;a class="link" href="https://aws.amazon.com/jp/elasticbeanstalk" target="_blank" rel="noopener"
>Elastic Beanstalk&lt;/a>や、&lt;a class="link" href="https://aws.amazon.com/jp/cloudformation" target="_blank" rel="noopener"
>CloudFormation&lt;/a>と重なる部分があり、デプロイでどれを使うかを選ぶような問題もあったような気がします。これらの違いはちゃんと覚えておく必要があります。&lt;/p>
&lt;p>自分の場合は、以下のイメージを見てだいぶ理解ができたと思います。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/aws-certification-associate-developer/aws_code_services.webp"
width="1842"
height="1036"
srcset="https://retheviper.github.io/posts/aws-certification-associate-developer/aws_code_services_hu_5031f273dfd76323.webp 480w, https://retheviper.github.io/posts/aws-certification-associate-developer/aws_code_services_hu_9236096ba2e8f1d0.webp 1024w"
loading="lazy"
alt="AWS Code Sevices"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="426px"
>
&lt;em>出典：AWS公式サイトトレーニングコース &lt;code>Exam Readiness: AWS Certified Developer - Associate (Digital)&lt;/code>&lt;/em>&lt;/p>
&lt;p>以上の内容は、AWS公式の動画でよく説明してくれているので、一回は受講することをオススメします。&lt;/p>
&lt;h2 id="参考にすると良い情報">参考にすると良い情報
&lt;/h2>&lt;p>他に、ちょっと覚えておくと良さげなものは以下の通りです。&lt;/p>
&lt;h3 id="名前だけは知っておきたいサービス">名前だけは知っておきたいサービス
&lt;/h3>&lt;p>テストで深くは問われないですが、名前だけ(そして何をするものか、大まかなイメージだけ)知っておくといいものとしては、&lt;a class="link" href="https://aws.amazon.com/jp/opsworks" target="_blank" rel="noopener"
>OpsWorks&lt;/a>、&lt;a class="link" href="https://aws.amazon.com/jp/step-functions" target="_blank" rel="noopener"
>Step Functions&lt;/a>、&lt;a class="link" href="https://aws.amazon.com/jp/systems-manager" target="_blank" rel="noopener"
>Systems Manager&lt;/a>のパラメータストアがあります。ただ、こちらまで覚えるのは流石に余裕がないと思います。他も覚えるべきものは山ほどあるので…&lt;/p>
&lt;h3 id="aws-elastic-load-balancer">AWS Elastic Load Balancer
&lt;/h3>&lt;p>&lt;a class="link" href="https://aws.amazon.com/jp/elasticloadbalancing" target="_blank" rel="noopener"
>ELB&lt;/a>についての問題も出ますが、最初はいまいちALB、NLB、CLBのことがわからず苦労をしていたので、以下のことを覚えておくと良いと思います。ELBはクラウドプラクティショナでも問われるものなので、私みたいにAWSの資格が初めてだったり、ELBのことが全くわからない場合に覚えておくといいでしょう。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>特徴&lt;/th>
&lt;th>ALB&lt;/th>
&lt;th>NLB&lt;/th>
&lt;th>CLB&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>対応Protocol&lt;/td>
&lt;td>HTTP, HTTPS&lt;/td>
&lt;td>TCP, TLS&lt;/td>
&lt;td>TCP, SSL/TLS, HTTP, HTTPS&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>プラットフォーム&lt;/td>
&lt;td>VPC&lt;/td>
&lt;td>VPC&lt;/td>
&lt;td>EC2-Classic, VPC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Health-Check&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CloudWatchマトリックス&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ロギング&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Zonal Fail-Over&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Connection Draining&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>同じインスタンスの複数ポートに負荷分散&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>WebSockets&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ターゲット(IPアドレス)&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ターゲット(Lambda)&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ロードバランサー削除保護&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>パスベースルーティング&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ホストベースルーティング&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Native HTTP/2&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Idle Connection Timeout設定&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Zond間の負荷分散&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SSLオフロード&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SNI(Server Name Indication)&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Sticky Session&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>バックエンドサーバ暗号化&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>固定IP&lt;/td>
&lt;td>-&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Elastic IPアドレス&lt;/td>
&lt;td>-&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>送信元IPアドレスを保持&lt;/td>
&lt;td>-&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>リソースベースIAMアクセス許可&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>タグベースのIAM権限&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>スロースタート&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ユーザ認証&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>リダイレクト&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>固定応答&lt;/td>
&lt;td>対応&lt;/td>
&lt;td>-&lt;/td>
&lt;td>-&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="受かったあとは">受かったあとは
&lt;/h2>&lt;p>試験に受かったら、しばらくしていくつかの特典をもらえるよ、というお知らせのメールが届きます。詳細は&lt;a class="link" href="https://aws.amazon.com/jp/certification/benefits" target="_blank" rel="noopener"
>AWS認定のサイト&lt;/a>からも確認できる内容ですが、簡単に紹介しますと以下の特典が提供されます。&lt;/p>
&lt;ul>
&lt;li>AWS認定ロゴのついたグッズを購入できる&lt;/li>
&lt;li>AWS認定資格の模擬試験を一つ購入できるクーポンをもらえる&lt;/li>
&lt;li>&lt;a class="link" href="https://www.linkedin.com" target="_blank" rel="noopener"
>LinkedIn&lt;/a>のAWSコミュニティに入れる&lt;/li>
&lt;li>次の試験が半額になるクーポンをもらえる&lt;/li>
&lt;li>イベントがあったら通知をもらえる&lt;/li>
&lt;li>&lt;a class="link" href="https://www.youracclaim.com" target="_blank" rel="noopener"
>Acclaim&lt;/a>に登録できるデジタルバッジをもらえる&lt;/li>
&lt;/ul>
&lt;p>正直デジタルバッジと模擬試験のクーポンがもらえる以外、使うところがあるかどうかは少々疑問になるライナップではあります。ただ、自腹の場合は確かに次の試験が半額になるのはメリットになるでしょう。自分の場合は会社負担のなっているので、半額でも特にうれしくはないのですが…&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>それで、受験する価値はあったのか？というと、それはあったと思います。暗記に弱く、あまり好きではないので苦労したのは事実ですが、おかげでAWSというサービスをより深く理解することができたと思っています。違うベンダーのクラウドだとしても、やはり大まかなサービスのコンセプトはやはりAWSと変わらないものなので、AzureやGCPなどを使う場合でも十分役立つのではないかと思います。実際、AWSを使うことで得られた知識でオラクルクラウドのVMを有効活用しているところです。&lt;/p>
&lt;p>また、クラウドごとに無料Tierで提供されるサービスはそれぞれ違うのですが、AWSの場合はLambdaとDynamoDBが無料で使えます。なので、この資格を勉強しならが得られた知識で何らかのサーバレスアプリケーションを作ることも可能になったような感覚です。オラクルクラウドとGCPでは無料で使えるVMを提供しているので、この組み合わせだと無料プランだけで立派なサービスを立ち上げることも不可能ではないような気がしますね。おそらく、こういうのも資格に挑戦してなかったら得られなかった知識だっただろうと思っています。&lt;/p>
&lt;p>一つ悩ましいのは、AWSの資格は3年という有効期限があるということです。クラウドは常に変化するサービスであり、続々と新しいサービスが登場するものなので仕方ないものですが、資格を持ってどこに活用するか(例えば、就職や転職に使うなど)はよく考える必要がありそうな気がします。あとは、、他の資格とも共有する部分が多いと思うので、連続して違う資格を早めに取っておいたほうが良さげな感じですね。なので自分もいつかまた、ソリューションアーキテクトなどに挑戦したいと思っています。&lt;/p>
&lt;p>ま、しばらくは疲れたので全然挑戦する気にならないのですが…&lt;/p></description></item><item><title>GETとPOSTの間</title><link>https://retheviper.github.io/posts/get-or-post/</link><pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/get-or-post/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.webp" alt="Featured image of post GETとPOSTの間" />&lt;p>&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/HTTP/Methods" target="_blank" rel="noopener"
>MDNの説明&lt;/a>によると、HTTPメソッドは主に「リソースに対する」ものだと定義しています。なので書くメソッドの説明としても、GETならリソースの表現、POSTならリソースの作成、PUTならリソースの置き換え、DELETEならリソースの削除のような表現をしていますね。これを元に、CRUDの基本を説明するような資料も多く、学習者は自然にAPIのデザインはリソースの作成、参照、置き換え、削除を基準に考えることになります。あとはリクエストに対する処理が&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%86%AA%E7%AD%89" target="_blank" rel="noopener"
>冪等&lt;/a>であるかどうか、というのが重要ですね。&lt;/p>
&lt;h2 id="理論--現実">理論 != 現実
&lt;/h2>&lt;p>しかし、理論的にはそうだと認識していても、実際の業務をアプリケーションとして表現していくと、悩ましい場合があります。今回がそうです。「リソースを単純に返すだけに見えるけど、実際は内部的にリソースの作成や修正が伴う処理の場合はどうするか」という疑問がありました。なぜなら、このような要件があったからです。&lt;/p>
&lt;ul>
&lt;li>クライアントにとあるファイルのダウンロードを提供するAPIがある。&lt;/li>
&lt;li>サーバからのファイルの取得には以下の二つのケースがある。
&lt;ul>
&lt;li>ファイルがすでに作成されていて、サーバはそのファイルをクライアントに返すだけ。&lt;/li>
&lt;li>リクエストに応じて、サーバがDBのレコードをファイルに書き込み(作成し)クライアントに返す。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>クライアントがファイルをダウンロードすると、サーバはDBを更新する。
&lt;ul>
&lt;li>サーバはDBに「ファイル出力済み」というフラグと、「更新ユーザ」としてログインユーザの情報を登録する。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>「ファイルがすでに作成されていて、サーバはそのファイルをクライアントに返すだけ」だと、GETでことは済みます。クライアントの観点からしてもそうであって、サーバもすでにあるリソースを返すだけですね。これは一般的にGETに期待する、「リソースの表現」に合致していて、何の問題もないです。&lt;/p>
&lt;p>しかし、「リクエストに応じて、サーバがDBのレコードをファイルに書き込みクライアントに返す」の場合はどうでしょうか？ファイルを新しく作成するのは、「リソースの作成」に当てはまるのでしょうか？それとも、レコードとしてすでに存在しているので、ただ違う形に加工するだけであって「リソースの表現」に当てはまるのでしょうか。または、ファイルの要請だけでなく、クライアントが提供した情報を持ってDBの更新を行うので、「リソースの作成」に当てはまるのでしょうか。&lt;/p>
&lt;h2 id="誰の観点から見るべきか">誰の観点から見るべきか
&lt;/h2>&lt;p>以上の問題は、自分の観点、つまり、バックエンドエンジニア及びアプリケーションとしての問題でもあります。ならば、クライアント(ユーザ)からしてみるとどうでしょうか。以下のことを考えられます。&lt;/p>
&lt;ul>
&lt;li>クライアントはファイルがすでに作成されているか、作成してくれるかに興味がない。
&lt;ul>
&lt;li>リクエストは「ファイルをくれ」であり、「ファイルを作ってくれ」ではない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>クライアントのリクエストに合わせてファイルを作成するかしないかはサーバ(アプリケーション)の都合である。
&lt;ul>
&lt;li>クライアントはファイルを要請するだけであり、中の処理についてはわからない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>つまり、クライアント側からすると、ファイルをダウンロードするという行為に関しては、あくまで「リソースの表現」を要請することに過ぎなくなります。サーバサイドとはまた都合が違いますね。こういう場合は、どちらの都合に合わせるかは明白ではないでしょうか。優先すべきは、クライアントですね。なぜなら、アプリケーションはそもそもクライアントの要件のために存在するものであるからです。なので、サーバサイドの都合でリクエストをPOSTにする理由はなくなりますね。&lt;/p>
&lt;h2 id="specでは">Specでは
&lt;/h2>&lt;p>ただ、クライアント側の観点枯らして、こういう場合はGETが正しい、と決めつけるにはまた違う根拠がいるのではないでしょうか。例えばHTTPの標準とかです。ちょうど、HTTPのスペックに関する文には、&lt;a class="link" href="https://tools.ietf.org/html/rfc7231#section-4.2.1" target="_blank" rel="noopener"
>以下のような章&lt;/a>があります。&lt;/p>
&lt;blockquote>
&lt;p>4.2.1. Safe Methods&lt;/p>
&lt;blockquote>
&lt;p>Request methods are considered &amp;ldquo;safe&amp;rdquo; if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource. Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server.&lt;/p>&lt;/blockquote>&lt;/blockquote>
&lt;blockquote>
&lt;p>4.2.1 安全なメソッド&lt;/p>
&lt;blockquote>
&lt;p>クライアントがサーバの状態を変えない、変わることを期待しない読み込み専用のリクエストは、「安全」とされる。安全なメソッドを正しく使うことによりサーバにとって害や損となるような事情を発生させなくなる。&lt;/p>&lt;/blockquote>&lt;/blockquote>
&lt;p>これを見ると、クライアントのリクエストによりサーバに何かリソースの変化をもたらすようなことになる場合は、GETではなさそうが気がします。しかし、重要なのはこの次の内容です。&lt;/p>
&lt;blockquote>
&lt;blockquote>
&lt;p>This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method. What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it. For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server.&lt;/p>&lt;/blockquote>&lt;/blockquote>
&lt;blockquote>
&lt;blockquote>
&lt;p>安全なメソッドが、完璧な読み込み専用でなかったり、副作用を伴うなどで害を招くような実装を防止するわけではない。大事なのは、その動作はクライアントの要請ではなく、責任もまたクライアントにないということである。例えば、多くのサーバはどんなメソッドに対してもアクセスログを記録するが、ログによってサーバのストレージが足りなくなりサーバに障害が生じることもあり得るが、こういう場合でもリクエストは安全とする。&lt;/p>&lt;/blockquote>&lt;/blockquote>
&lt;p>つまり、大事なのは実装上の都合はあくまでサーバサイドの責任であって、クライアントからの行為であるということですね。安全なリクエストのためには、クライアントのリクエストがどのようなものであるかを考えるべき、という結論になります。HTTPメソッドはそういう行為の本質を表すものであり、サーバの都合の表現ではない、ということですね。なのであくまでクライアントからして、「リソースの表現」に対する要請であれば、サーバはGETとして応じるベキになるかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>実際のウェブサイトを観察してみても、純粋な「リソースの表現」としてのGETはあまりないような気もしています。例えば訪問するだけで「訪問者カウンター」が更新されるサイトがあったりしますね。こういう場合でもクライアントはリソースの作成やリソースを要請してなく、サーバ側で勝手に更新を行っていますが、依然としてGETとされまていて、違和感もないです。むしろこのようなリソースの変更全てをPOSTとして扱うようになるとしたら、GETを使う場面自体がなくなるかもしれません。&lt;/p>
&lt;p>ただし、注意しなくてはならないのが、リソースの作成や更新を伴うリクエストを全てGETにするという発想も危険であることです。リソースの扱い方という原則に戻って考えたら、「POSTで作成させた後、GETで取得させる」というやり型もあるのかもしれません。こういう場合は2回のトランザクションが発生するので性能面では劣るかもしれませんが、場合によってはより安全な設計になる可能性もありますね。&lt;/p>
&lt;p>なので「全てのケースに置いて」ではなく、アプリケーション全体の設計や今後の方向性を考慮した設計として適切なHTTPメソッドを選んだ方が良い、というのが結論になるかと思います(原論的な話ですが)。重要なのは、「こういう場合は絶対GETだ」、「こういう場合は絶対POST」だと言わないことですね。&lt;/p></description></item><item><title>Spring WebFluxって何？</title><link>https://retheviper.github.io/posts/spring-webflux/</link><pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-webflux/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post Spring WebFluxって何？" />&lt;p>Springが初めて発表されたのが2002年なので、およそ20年に近い時間が経ちました。今はJavaと言えば当たり前のようにSpringを使っていて、Spring MVCやMaven、propertiesのような煩雑な環境構築と初期設定の問題も、Spring Bootが登場したおかげでだいぶマシになりましたね。特に自分の場合がそうですが、Spring Boot、Gradle、yamlを使ってXMLは一つもないアプリをよく書いていて、なんでも楽と思います。&lt;/p>
&lt;p>こうも発展を成し遂げているSpringですが、実は数年前から、そもそものSpring MVCの問題を改善したいという声があり、Spring 5.0からはMVCとは全く違う、新しいフレームワークが登場していました。それが今回紹介します、Spring WebFluxです。&lt;/p>
&lt;h2 id="spring-webfluxはmvcと何が違うか">Spring WebFluxはMVCと何が違うか
&lt;/h2>&lt;p>最初から作り直したフレームワークなので、根本的な部分から違うところが多いので、理論的なだと以下のキーワードをあげられますでしょう。&lt;/p>
&lt;ul>
&lt;li>非同期、ノンブロッキング、反応型&lt;/li>
&lt;/ul>
&lt;p>私の(コードモンキーの)レベルからしたら、実際のコードのレベルで体感するMVCとの違いは以下です。&lt;/p>
&lt;ul>
&lt;li>MonoとFlux&lt;/li>
&lt;li>Controller/Serviceの代わりにFunction&lt;/li>
&lt;li>TomcatよりNetty&lt;/li>
&lt;li>JPA/JDBCよりR2DBC&lt;/li>
&lt;li>新しい抽象化クラス&lt;/li>
&lt;/ul>
&lt;p>では、これらの違いについて、一つ一つみていきたいと思います。&lt;/p>
&lt;h2 id="理論的な話">理論的な話
&lt;/h2>&lt;h3 id="非同期ノンブロッキング反応型">非同期、ノンブロッキング、反応型
&lt;/h3>&lt;p>Spring WebFluxは&lt;a class="link" href="https://github.com/reactor/reactor-core" target="_blank" rel="noopener"
>Project Reactor&lt;/a>に基づいて作られていて、その根幹となる考え方は&lt;a class="link" href="https://www.reactive-streams.org" target="_blank" rel="noopener"
>Reactive Stream&lt;/a>だそうです。Reactive Streamは標準APIであり、Java 9から&lt;code>java.util.concurrent.Flow&lt;/code>として導入されています。&lt;/p>
&lt;p>Reactive Streamはデザインパターン的にはObserverと似ています。簡単にいうと、何かのイベントが発生した時に「通知してくれ」と頼んで、データをもらうということです。この「通知してくれ」と頼む行為のことをSubscription(購読)といい、データを発行するPublisherと購読するSubscriberの間でSubscriptionのやり取りで行われます。こういうイベント基盤のプログラムを作ることが、いわゆる「反応型」だそうです。&lt;/p>
&lt;p>そしてReactive StreamではこのSubscriptionのやり取りが、非同期・ノンブロッキングで行われるらしいです。ということは、コードが実行された時点か終わるまでまつ必要がなく、その間に他のことができるということです。なので同じ数の同じタスクを実行するときは同期・ブロッキングと比べあまり性能面での違いはないのですが&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>、スレッド数がボトルネックとなる場合だと、非同期・ノンブロキングの方が早くなります。&lt;/p>
&lt;p>理論的な話は、深くまで踏み入るとキリが無くなるので、実際のコードではどんな違いがあるのか？をみていきましょう。&lt;/p>
&lt;h2 id="コードのレベルでの話">コードのレベルでの話
&lt;/h2>&lt;h3 id="monoとflux">MonoとFlux
&lt;/h3>&lt;p>Spring WebFluxだと、コントローラのメソッドに戻り値(レスポンス)としてMonoとFluxを使うということです。Spirng MVCなら、文字列でJSPファイルを指定したり、REST APIならJSONとして返すオブジェクトを指定していましたね。もちろんMonoとFluxもJSONオブジェクトとして出力されるのですが、作り方が少し独特です。&lt;/p>
&lt;p>Spring WebFluxの根幹となる考え方がReactive Streamであると先に述べましたね。そしてReactive StreamをWebFlux側で実装したものが、MonoとFluxになります。Monoは&lt;code>0か1か&lt;/code>、Fluxは&lt;code>0かNか&lt;/code>の違いだそうですが、必ずしもCollection=Fluxにする必要はなくて、Monoとして扱うこともできます。&lt;/p>
&lt;p>Reactive Streamは、名前からしてJava 1.8のStream APIとなんらかの関係があるようにも見えます。実際、データの作成と消費の時点が違うのですが&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>、似たような名のメソッドや、Lambdaで完成していくところは似ています。すでに&lt;a class="link" href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener"
>RxJava&lt;/a>や&lt;a class="link" href="https://github.com/jOOQ/jOOL" target="_blank" rel="noopener"
>JOOL&lt;/a>などに慣れているなら、書き方的にはまあり問題なく適応できそうですが、そうでない方には適応が難しいかもしれません。&lt;/p>
&lt;p>例えば、GETで、リクエストを受けたら1秒後にレスポンスを返す簡単なメソッドを実装するとしましょう。Spring MVCによるREST APIだと、以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@GetMapping&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ResponseStatus&lt;/span>(HttpStatus.&lt;span style="color:#a6e22e">OK&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getTest&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(1000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;task completed by mvc&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;task failed by mvc&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>WebFluxでは、以下のようにMonoを作成して返します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@GetMapping&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ResponseStatus&lt;/span>(HttpStatus.&lt;span style="color:#a6e22e">OK&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Mono&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">getTest&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Mono.&lt;span style="color:#a6e22e">delay&lt;/span>(Duration.&lt;span style="color:#a6e22e">ofMillis&lt;/span>(1000)).&lt;span style="color:#a6e22e">then&lt;/span>(Mono.&lt;span style="color:#a6e22e">just&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;task completed by Mono&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最近はなんでも宣言的な言語やフレームワークなどが増えているので(例えばFlutterやSwiftUIがそんな感じですね)、こういう書き方は珍しくもないですが、伝統的な命令型プログラミングに慣れている方には少し辛い書き方になるかもしれません。私自身も、StreamやLambdaは好きなものの、ネストしていく命令型とメソッドチェインで長くなる宣言型のどちらがいいか確信がないです…&lt;/p>
&lt;h3 id="controllerserviceの代わりにfunction">Controller/Serviceの代わりにFunction
&lt;/h3>&lt;p>WebFluxのコード上でのもう一つの特徴は、ControllerとServiceの代替となるクラスを作ることができるということです。もちろん従来通りControllerとServiceクラスを利用することもできますが、どうせなら新しいものが使ってみたくなりますね。&lt;/p>
&lt;p>SpringでController/Serviceを作るということは、つまりアノテーションによる「メタプログラミング」に依存して開発するというです。確かにアノテーションは便利であって、Springではアノテーションでなんでもできるような感じもしますね。しかし、アノテーションによる開発では以下のような問題があります。&lt;/p>
&lt;ul>
&lt;li>コンパイラで検証できない&lt;/li>
&lt;li>コードの行為を規定しない&lt;/li>
&lt;li>継承、拡張のルールに標準がない&lt;/li>
&lt;li>理解できない、誤解しやすいコードをを生み出す可能性がある&lt;/li>
&lt;li>テストが極めて難しい&lt;/li>
&lt;li>カスタマイズが難しい&lt;/li>
&lt;/ul>
&lt;p>なぜかというと、アノテーションを使うということは結局Reflectionに依存するということになるからです。Reflectionを使っているとランタイムでバイトコードが生成されてしまうので、コンパイルタイムにできることがあまりないですね。Reflectionは確かに強力な道具ですが、他にも問題はあります。例えばパフォーマンスは低下し、デバッグも難しいです。こういう問題があるのでJavaのコードをネイティブにコンパイルしてくれるという&lt;a class="link" href="https://www.graalvm.org" target="_blank" rel="noopener"
>GraalVM&lt;/a>ではReflectionに対応していないのかもしれないですね。&lt;/p>
&lt;p>とにかく、このような問題を解決するためにWebFluxで新しく導入されたのは、&lt;code>Function&lt;/code>です。はい、言葉通り、関数です。既存のControllerに対応する&lt;code>Router&lt;/code>とServiceに対応する&lt;code>Handler&lt;/code>を作り、関数型モデルとして(Functinalに)コードを書くことができます。もちろんFunctionalに書くとしても、アノテーションは使えます(むしろアノテーションなしではだめです…)。例えば以下のような書き方になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Router&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> RouterFunction&lt;span style="color:#f92672">&amp;lt;&lt;/span>ServerResponse&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">route&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Handler handler) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> nest(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path(&lt;span style="color:#e6db74">&amp;#34;/api/v1/web/members&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RouterFunctions.&lt;span style="color:#a6e22e">route&lt;/span>(GET(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>), handler::listMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">andRoute&lt;/span>(POST(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>), handler::createMember)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Handler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> MemberRepository repository;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Handler&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> MemberRepository repository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span> &lt;span style="color:#f92672">=&lt;/span> repository;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Mono&lt;span style="color:#f92672">&amp;lt;&lt;/span>ServerResponse&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">listMember&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> ServerRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">contentType&lt;/span>(MediaType.&lt;span style="color:#a6e22e">APPLICATION_JSON&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">body&lt;/span>(Flux.&lt;span style="color:#a6e22e">fromIterable&lt;/span>(repository.&lt;span style="color:#a6e22e">findAll&lt;/span>()), Member.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Mono&lt;span style="color:#f92672">&amp;lt;&lt;/span>ServerResponse&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">createMember&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> ServerRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">contentType&lt;/span>(MediaType.&lt;span style="color:#a6e22e">APPLICATION_JSON&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">body&lt;/span>(request.&lt;span style="color:#a6e22e">bodyToMono&lt;/span>(Member.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">flatMap&lt;/span>(member &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Mono.&lt;span style="color:#a6e22e">fromCallable&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> repository.&lt;span style="color:#a6e22e">save&lt;/span>(member))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">then&lt;/span>(Mono.&lt;span style="color:#a6e22e">just&lt;/span>(member))), Member.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>関数型になってわかりやすくなったような、難しくなったような…&lt;/p>
&lt;h3 id="tomcatよりnetty">TomcatよりNetty
&lt;/h3>&lt;p>Spring WebFluxのデフォルトのアプリケーションサーバはNettyです。簡単に推論できる理由ですが、&lt;a class="link" href="https://netty.io" target="_blank" rel="noopener"
>Netty&lt;/a>の方が最初からノンブロッキングという考え方に基づいて作られているからでしょう。Tomcatはもちろん同期、ブロッキングなので、Nettyと比較すると以下のような違いがあるらしいです。&lt;/p>
&lt;ul>
&lt;li>Tomcat：リクエストとスレッドは1:1&lt;/li>
&lt;li>Netty：リクエストとスレッドはN:1&lt;/li>
&lt;/ul>
&lt;p>もちろん、Spring MVCみたいにNettyの代わりにTomcatを使うこともできます。例えばGradleでは以下のような書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>dependencies &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;org.springframework.boot:spring-boot-starter-webflux:2.3.3.RELEASE&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exclude group: &lt;span style="color:#e6db74">&amp;#39;org.springframework.boot&amp;#39;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> module: &lt;span style="color:#e6db74">&amp;#39;spring-boot-starter-reactor-netty&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;org.springframework.boot:spring-boot-starter-tomcat:2.3.3.RELEASE&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="jpajdbcよりr2dbc">JPA/JDBCよりR2DBC
&lt;/h3>&lt;p>これもアプリケーションサーバと同じような話です。JPA/JDBCなど、従来のORMはブロッキングなのでノンブロッキングに対応する&lt;a class="link" href="https://r2dbc.io" target="_blank" rel="noopener"
>R2DBC&lt;/a>に変えましょう、ということです。NIOがそうであったように、ブロッキングでもR2DBCを使うと場合によってはパフォーマンスの向上を図ることもできるらしいです。&lt;/p>
&lt;h3 id="新しい抽象化クラス">新しい抽象化クラス
&lt;/h3>&lt;p>WebFluxでは、Spring MVCで使っていた抽象化クラスも変わっています。これも同じく、関数型としての書き方とノンブロッキングに対応するためですね。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>種別&lt;/th>
&lt;th>Spring MVC&lt;/th>
&lt;th>Spring WebFlux&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>リクエスト&lt;/td>
&lt;td>HttpServletRequest&lt;/td>
&lt;td>ServerHttpRequest&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>レスポンス&lt;/td>
&lt;td>HttpServletResponse&lt;/td>
&lt;td>ServerHttpResponse&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>他のAPIをコール&lt;/td>
&lt;td>RestTemplate&lt;/td>
&lt;td>WebClient&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>WebClientの場合は、RestTemplateが&lt;code>deprecated&lt;/code>に変更されるので、Spring MVCを使う場合でも導入を考える必要はあります。実際Spring MVCで使う場合でもResttemplateに比べてパフォーマンスが向上される場合もあると言われています。&lt;/p>
&lt;h2 id="どこに使えばいい">どこに使えばいい？
&lt;/h2>&lt;p>さて、さっくりWebFluxの特徴をみてみましたが、どうでしょうか。書き方もかなり違っていて、Servlet基盤のMVCとは全く違うReactorに基盤しているので、Spring WebFluxの導入はかなり悩ましいことです。実際Spring MVCと同時に使うこともできず(無理矢理Dependencyを追加しても、MVCが優先され、WebFluxの機能は動作しなかったりもします)、Spring Securityなど他のフレームワークもSpring WebFluxのために作りなおったものに変えなくては行けないので、既存のシステムやSpring MVCに基づいて整備したライブラリなどがたくさんある場合はその影響範囲が測定できません。&lt;/p>
&lt;p>そして性能面でも、ノンブロッキングが強いのは、「指定されたスレッド数を超えるリクエストがある場合」という条件下の話です。ノンブロッキングに変えたからって、単一スレッドでの性能が上がるわけでもないということですね。&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;p>ただし、以下のような場合はWebFluxの導入を考えられます。&lt;/p>
&lt;ol>
&lt;li>完全新規サービスをはなから作る&lt;/li>
&lt;li>複数のサービスがあり、サービス同士での呼び出しが多い場合(マイクロサービス)&lt;/li>
&lt;li>BFF&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>の場合&lt;/li>
&lt;/ol>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>簡単に整理しようとしていた内容が、いつの間にかかなり長くなりましたが…おかげで色々と勉強はできたと思います。WebFluxが登場してからもすでに数年が経っていて、RestTemplateがdeprecatedになる予定であるように、究極的には全体をWebFlux基盤に移行する必要が生じる日がいつか来るかもしれません。なんでも最近は非同期、関数型、反応型というキーワードがすごく流行っていますし。&lt;/p>
&lt;p>静的タイプの言語が最初に生まれて、動的タイプの言語も生まれ、TypeScriptのように静的な世界にまた戻るような現象が起きているのを見ると、また関数型から命令型に移行する日もいつか来る可能性があるのかな、と思ったりもします。ただ、こういうパラダイムはどれが絶対というわけではないので、優秀なプログラマならどれも適時適切に使いこなせるようにならないと、という気もします。エンジニアとしての勉強の道は本当に終わりがないですね。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>実際は、スレッド数によるボトルネックのない状態だと、関数型の方が少し遅いらしいです。実際は関数型のAPIの実装の方が複雑だからですね。ただ、この違いはコードの読みやすさや実装のしやすさなどを考慮した時は、十分トレードオフとして考慮できるくらいの差のようです。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Streamは同期なので、データを生産と消費が一緒に行われます。しかし、Reactive Streamではデータの生産がすぐ消費までつながるとは言い切れません。非同期だからです。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>むしろ、単一スレッドでの処理は、WebFluxの方がMVCに比べ少し遅いという話もあります。forループに比べStreamが遅い理由と似ているような気がしますが…&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>Back-end For Front-endの略。マイクロサービスの一種で、複数のエンドポイントをまとめて固有のオブジェクトを生み出すバックエンド。フロントエンドは一つのエンドポイントを呼び出すだけでことが済みます。&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>静的ウェブページに興味を持つ</title><link>https://retheviper.github.io/posts/static-web-page/</link><pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/static-web-page/</guid><description>&lt;img src="https://retheviper.github.io/images/tools.webp" alt="Featured image of post 静的ウェブページに興味を持つ" />&lt;p>今更な話ですが、主にバックエンドの仕事をしてきたエンジニアとしては(特に、Springが全てを占拠してしまったJavaがメインな立場からは)、昨今のフロントエンドの世界を見ていると、一瞬よそ見しただけでもすぐに時代遅れな人間になってしまうような気になります。それだけさまざまなライブラリ、フレームワーク、設計思想、プラットフォームが現れ消えていくので、これからどれを学んでおくべきかわからなくなります。&lt;/p>
&lt;p>例えばアプリの設計思想だと、SPA&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>がトレンドになっているものの、&lt;a class="link" href="https://webassembly.org" target="_blank" rel="noopener"
>WASM&lt;/a>の登場でPWA&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>も登場し始めています。JavaScriptのフレームワークでは、「Virtual DOMを使用するので早い」という、&lt;a class="link" href="https://angular.io" target="_blank" rel="noopener"
>Angular&lt;/a>・&lt;a class="link" href="https://reactjs.org" target="_blank" rel="noopener"
>React&lt;/a>・&lt;a class="link" href="https://vuejs.org" target="_blank" rel="noopener"
>Vue.js&lt;/a>が今の通称「3強」となっていますが、「DOMを直接更新するから早い」という&lt;a class="link" href="https://svelte.dev" target="_blank" rel="noopener"
>Svelte&lt;/a>もあります。&lt;a class="link" href="https://nodejs.org" target="_blank" rel="noopener"
>Node.js&lt;/a>は失敗したという&lt;a class="link" href="https://deno.land" target="_blank" rel="noopener"
>Deno&lt;/a>が登場しているし、今の&lt;a class="link" href="https://www.typescriptlang.org" target="_blank" rel="noopener"
>TypeScript&lt;/a>の位置を目指したが失敗したと思われた&lt;a class="link" href="https://dart.dev" target="_blank" rel="noopener"
>Dart&lt;/a>は、&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>や&lt;a class="link" href="https://fuchsia.dev" target="_blank" rel="noopener"
>Fuchsia&lt;/a>で再起できているようにも見えますね。&lt;/p>
&lt;p>このように、フロントエンド系は新しい概念と技術の氾濫で混乱な状況ですが、面白くも、トレンドと逆行するような形のWebアプリ、いや、Webサイトの構築に関する概念もそれなりの割合を示しているように見えます。本日のポストのテーマである、「静的ウェブページ」です。&lt;/p>
&lt;h2 id="静的ウェブページstatic-web-pageとは">静的ウェブページ(Static Web Page)とは
&lt;/h2>&lt;p>「静的」であるということは、「動的」と区分される特徴があるということでしょう。ここでいう動的か静的かというのは、入力によって何かの処理が行われるか、もしくは常にサーバに保存されたデータをそのまま返すかががもっとも重要な基準となっているようです。例えばWikipediaでは以下のように定義しています。&lt;/p>
&lt;blockquote>
&lt;p>A static web page (sometimes called a flat page or a stationary page) is a web page that is delivered to the user&amp;rsquo;s web browser exactly as stored, in contrast to dynamic web pages which are generated by a web application.&lt;/p>&lt;/blockquote>
&lt;p>言い方を変えると、サイトが「アプリケーション」として作られたものならば動的、もしくはただの固定されたデータを表示するための「ページ」であるなら静的といえますね。&lt;/p>
&lt;h2 id="なぜ今更">なぜ今更？
&lt;/h2>&lt;p>サーバに保存されたデータをそのまま返すという概念は、 Webアプリケーションが登場する前から存在していました。当時のウェブサイトはhtmlとcss、イメージなどのリソースをFTPなどでサーバにアップロードしてホスティングを行っていたのですが、これは今の静的ウェブページにとっても同じ方式です。&lt;/p>
&lt;p>つまり、概念だけを見ると静的ウェブページは昔に流行っていた「ホームページ」や「ブログ」などに近いものです。時代に逆行するような、静的ウェブページが今更注目されるのは、なぜか。&lt;/p>
&lt;p>当たり前ながら、当時とは違って、JavaScriptの発展によりサーバに依存しなくても簡単な処理はブラウザでできるようにもなり、適切なAPIがあればバックエンドを実装する必要がなくなるのもあり、AWS LambdaやAzure Functionsのようなサービスによりサーバレスができる環境ができるなど、バックエンドよりはフロントエンドの目的によって選択できる方法が多くなったという点があるでしょう。&lt;/p>
&lt;p>そして、もっとも根本的な、サイトの目的がありますね。ブログ、ポートフォリオ、イベント案内などそもそも「大した処理が必要ない」サイトに関しては、静的にしたほうがリソース使用、費用、パフォーマンス、セキュリティという面で動的ウェブページより有利です。例えば今このブログみたいにですね。&lt;/p>
&lt;p>最近はMarkdownなどで文書を書くと、それを元に静的ウェブページを作成してくれるツールもたくさんあり、そのようなツールで生成したデータを載せるだけでホスティングする方法も多いです。自分でソースを管理できて、簡単にホスティングできるのである意味ではもっとも静的ウェブページを作り安い時代となったとも言えますね。&lt;/p>
&lt;h2 id="静的ウェブページを作られるツール">静的ウェブページを作られるツール
&lt;/h2>&lt;p>多くの場合、静的ウェブサイトの生成ツールの使用は難しくありません。ベースになっている言語の実行環境を構築して、テンプレートをダウンロードして適用するか、作っていくかなのですが、ツールを実行するための環境の構築はツールのホームページの手順通りでよく、テンプレートも人の作っておいたものを持ってきて少し修正するくらいです。簡単な修正なら、HTML、CSS、JSON、YAMLくらいのファイルをいじるだけなので(プロパティファイルで色々なオプションを選択できる例もあります)、難しくありません。あとはMarkdownなどで記事を書いていくだけですね。&lt;/p>
&lt;p>ただ、自分の経験からだと、既製のテンプレートを大きく変えるか、最初から作り直す場合は自分が触ることのできる言語をベースにしておいた方が良いということですね。例えばこのブログは&lt;a class="link" href="https://jekyllrb.com" target="_blank" rel="noopener"
>Jekyll&lt;/a>で作られていて、テンプレートも一部修正していますが、そもそも私はRubyに慣れてないので根本的な部分を修正してはいないところです。&lt;/p>
&lt;p>Jekyll以外には、Nodejs基盤のツールが多いようです。例えば&lt;a class="link" href="https://metalsmith.io" target="_blank" rel="noopener"
>Metalsmith&lt;/a>や、&lt;a class="link" href="https://hexo.io" target="_blank" rel="noopener"
>Hexo&lt;/a>のような物があって、React基盤の&lt;a class="link" href="https://www.gatsbyjs.com" target="_blank" rel="noopener"
>Gatsby&lt;/a>、Vue.js基盤の&lt;a class="link" href="https://vuepress.vuejs.org" target="_blank" rel="noopener"
>VuePress&lt;/a>もあります。JavaScriptとそのフレームワークの使用に慣れているなら、こちらがいいかもしれませんね。他には、Go言語基盤の&lt;a class="link" href="https://gohugo.io" target="_blank" rel="noopener"
>Hugo&lt;/a>もありますので、Goに慣れている方ならこちらを選択することもありですね。&lt;/p>
&lt;h2 id="静的ウェブページを載せられるプラットフォーム">静的ウェブページを載せられるプラットフォーム
&lt;/h2>&lt;p>ツールを使って、静的サイトを作ったら、次はホスティングが必要となりますね。静的ウェブページのホスティングの場合、このブログでも使用している&lt;a class="link" href="https://pages.github.com" target="_blank" rel="noopener"
>GitHub Pages&lt;/a>や&lt;a class="link" href="https://www.netlify.com" target="_blank" rel="noopener"
>netlify&lt;/a>のようなサービスがあり、データをGitなどでアップロードすると自動でビルドとデプロイが完了される便利さがあります。&lt;/p>
&lt;p>他にはクラウドを利用する方法があります。AWSやAzure、Google Cloud Platformのようなクラウドサービスには、&lt;a class="link" href="https://aws.amazon.com/s3" target="_blank" rel="noopener"
>S3&lt;/a>や&lt;a class="link" href="https://azure.microsoft.com/ja-jp/services/storage/blobs" target="_blank" rel="noopener"
>Blob&lt;/a>のようにウェブからアクセスできるストレージサービスが必ずありますが、このストレージにツールで作成した静的サイトをアップロードしてホスティングする方法もあります。特にGoogleのサービスの場合、&lt;a class="link" href="https://firebase.google.com" target="_blank" rel="noopener"
>Google Firebase&lt;/a>というアプリ開発に特化したプラットフォームもあるのでAPIとの連携が必要な場合は考慮できる候補ではないかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ここでは単にツールとプラットフォームを紹介(というより、言及)しただけですが、静的ウェブページでできることや活用できるものは、他にも多いようです。同じ静的ウェブページだとしても、どのような技術の組み合わせでどのような物が作り上げられるかがかなり変わってくるのですが、実際にどんな物ができるかは&lt;a class="link" href="https://jamstack.org" target="_blank" rel="noopener"
>JAMstack&lt;/a>のExamplesタブから色々発見できますので、参考にしてみてください。&lt;/p>
&lt;p>個人的にはGatsbyに興味があって、Reactの勉強のついでに、いつかポートフォリオのためのサイトをそれで作り上げてみようかなと思っています。Oracleクラウドだと無料のVMやDBも提供されるので、簡単なAPIを作成しておくのも可能になるかもしれませんね。いや、いい時代になったものです。皆さんもぜひ、静的ウェブページで自分だけのサイトを築き上げてみてください。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Single Page Applicationの略で、従来のWebアプリケーションが複数の画面で構成されていたことに対して、画面を一つにして開発の効率やパフォーマンスの向上を図ったWebアプリケーションのこと。画面がサーバサイドと分離されているため、バックエンドとして選択できるものの幅が広いという特徴もあります。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Progressive Web Applicationの略で、Webアプリでありながらもネイティブアプリならではのメリット(パフォーマンスが高い、インストールすることでオフラインでも利用可能)を採用したアプリケーションのことを指します。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>JWTの補完：Refresh TokenとSliding Session</title><link>https://retheviper.github.io/posts/refresh-token-and-sliding-session/</link><pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/refresh-token-and-sliding-session/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post JWTの補完：Refresh TokenとSliding Session" />&lt;p>前回、JWTとともにSpring Securityでの実現方法について&lt;a class="link" href="../spring-rest-api-login-with-jwt" >ポスト&lt;/a>を書きましたが、JWTを使ってAccess Tokenのみを発行した場合は、考えられる脆弱性があるらしいです。なので今回は、Access Tokenのみを使う認証の特徴と問題点及びそれを補完するための技術を紹介したいと思います。&lt;/p>
&lt;p>そもそもJWTを使った認証認可は、JWTがISO標準ではあるものの、正解と言った実装方式がないらしいです。なので以下で紹介するAccess Tokenのみの発行に伴う問題と、それを補完するための戦略は概念だけを紹介して行きます。&lt;/p>
&lt;h2 id="access-token">Access Token
&lt;/h2>&lt;p>Access Tokenのみを使う場合は、最初の認証以降、サーバでは秘密キーを利用してリクエストに載せられたTokenを確認するため、データベースやストレージなどのI/Oが必要なくなるため高速で処理ができます。ただ、Tokenはリクエストを送るクライアント側が持っているため、強制的にセッションを終了させることができません。なので、ログアウトの処理をするためにはクライアント側からToken情報を削除するしかないですね。&lt;/p>
&lt;p>Access Tokenを使った認証方式はこういう特徴を持っているため、クライアント側がTokenを持っているため、これをもし第三者に乗っ取られた時はサーバサイドからそれを判断できる術がありません。こういう問題を防ぐため、Tokenを発行する際はあらかじめ期限を設定することで、一定の時間がすぎるとTokenの有効期間が満了するようにして、再利用できなくしています。&lt;/p>
&lt;h3 id="tokenの期限設定のジレンマ">Tokenの期限設定のジレンマ
&lt;/h3>&lt;p>Tokenの期限をあらかじめ設定する場合、有効期限をどう設定するかの問題があります。短くした場合は、Tokenを乗っ取られた場合でもすぐにTokenを使えなくなるため安全性を担保できますが、逆にユーザは頻繁にログインし直さないと行けなくなります。逆に長くした場合は、ユーザはログインし直さなくてもサービスを長期間利用できるものの、乗っ取られたTokenも長く使えるようになりますね。&lt;/p>
&lt;h2 id="refresh-token">Refresh Token
&lt;/h2>&lt;p>Refresh Tokenは、満了したAccess Tokenの有効期限を更新するための別のTokenです。サーバは認証時にクライアント側にAccess TokenとRefresh Tokenをともに発行します。ここでAccess Tokenの期限は30分くらいの短い期間に設定して、Refresh Tokenは1ヶ月ほどの長い期間に設定します。&lt;/p>
&lt;p>クライアント側でログイン後に30分がすぎて、Access Tokenの期限が満了した場合にRefresh Tokenでサーバに新しいAccess Tokenの発行を依頼します。サーバはクライアントのリクエストに乗ってあるRefresh Tokenを検証し、問題なければAccess Tokenを再発行します。これでAccess Tokenを乗っ取られたも、すぐに満了し、ユーザはRefresh Tokenを持って有効期限の自動更新ができるので毎回ログインする必要がなくなります。また、サーバサイドでRefresh Tokenを検証するデータを持っているので、もし問題がある場合はRefresh Tokenを満了させることもできます。&lt;/p>
&lt;p>ただ、Refresh Tokenを使った場合でも完璧では言えません。サーバが検証するためにRefresh Tokenに対応するデータを別のデータベースやストレージに保存する必要があるので、追加的なI/Oが発生し得るという問題はあります。また、Refresh Tokenを用いたAccess Tokenの更新のためにはサーバとクライアント側の両方に機能を追加する必要がありますね。あと、Access Tokenと同様にクライアント側がRefresh Tokenを保存する必要があるのでこれをどう保存するかを考える必要があります。&lt;/p>
&lt;h2 id="sliding-session">Sliding Session
&lt;/h2>&lt;p>Sliding Sessionは、セッションを継続して利用しているユーザがいる場合、自動でAccess Tokenを更新してくれる仕組みのことです。リクエストごとに新しいAccess Tokenを発行する方法がありますが、特定のリクエストに限って処理する方法もあります。例えば、ユーザが長い時間を送ると予想されるページ(問い合わせの作成)や、次に何かのアクションが予想されるページ(ショッピングカートにアイテムを追加する)の場合があるでしょう。他には、Access TokenのIAT(トークン発行時間)を確認して新しいAccess Tokenの発行を要請する場合もあるらしいですね。&lt;/p>
&lt;p>ただ、Sliding SessionでAccess Tokenを更新する場合、そもそもの有効期限が長く設定されていると無限に近くセッションが延長され、ユーザが全くログインしなおさなくてもサービスを利用できることになるので注意が必要です。逆に、ユーザがあまり長い時間の作業を行わない場合はSliding Sessionそのものの必要性がなくなる可能性もあります。&lt;/p>
&lt;h2 id="refresh-token--sliding-session">Refresh Token + Sliding Session
&lt;/h2>&lt;p>最後は、Refresh TokenとSliding Sessionを同時に使った方法です。普通のSliding Sessionを適用した方法との違いは、Access TokenではなくRefresh Tokenを更新するということです。Refresh Tokenを更新することにより、Access Tokenを頻繁に更新する必要がなくなります。またRefresh Tokenが更新されるためアクセス回数の少ないユーザでも比較的ログインを頻繁にする必要がなくなりますね。Refresh TokenとSliding Sessionのメリットを適切に融合させた戦略と言えます。&lt;/p>
&lt;p>ただ、この方式でも問題が全くないとは言えません。サーバからRefresh Tokenの有効期限を満了させない限り、ユーザはリソースにアクセスできるので、もしPCやスマホなどの機器が乗っ取られた場合は対応できません。なのでアカウントのパスワードを周期的にリセットさせるか、特定のリソースにアクセスする場合は再び認証させるなどの方法が必要となります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>認証はWebアプリケーションにとってもっとも重要で、当たり前な機能となっていますが、セキュリティのため強化して行くとユーザの使用性に悪影響が出てしまうという問題を持っているものです。なので色々な方法論があり、さまざまなWebアプリケーションではそれぞれ違う方法を使って脆弱性に対応していますが、どれもメリット・デメリットがあるので正解と言える物はないのかもしれません。&lt;/p>
&lt;p>また、JWTのPayloadは暗号化されないため(ただのbase64文字列)、JWTを乗っ取られた時にその中身を見れるという問題もあるらしいです。これを補完するために&lt;a class="link" href="https://developer.okta.com/blog/2020/07/23/introducing-jpaseto" target="_blank" rel="noopener"
>PASETO&lt;/a>という物も提案されているらしいですが、これがまたJWTほど亜補給される稼働かはわからない状態ですね。&lt;/p>
&lt;p>あと、そもそもの認証方式の問題ですが、量子コンピュータが一般に補給されたら、&lt;a class="link" href="https://www.nttdata.com/jp/ja/data-insight/2018/0611" target="_blank" rel="noopener"
>従来の方式による暗号の解析はすぐにできる&lt;/a>ようになるとも言われているので、暗号化という考え方そのものが変わる可能性もあるかもしれません。そうなると既存のアプリも全体を作り直さなくてはならないことになるでしょう。&lt;/p>
&lt;p>セキュリティは難しいものです。暗号化とともに、ユーザが便利に使える設計、戦略を適切に選定するためには色々と工夫が必要と感じます。&lt;/p></description></item><item><title>二つのListを結合する</title><link>https://retheviper.github.io/posts/java-compare-and-merge-lists/</link><pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-compare-and-merge-lists/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post 二つのListを結合する" />&lt;p>よく訪問しているサイトに、とある質問がありました。質問の内容とは、&lt;code>List二つを、重複する要素なしで一つにまとめる方法&lt;/code>ということでした。SQLなら簡単に解決できそうな問題でもありますが、クエリーを修正できない状態だったり、複数のAPIを呼び出してその戻り値を扱う場合は直接コードを書いて併合するしかないですね。今まであまり経験したことのない状況でしたが、個人的にも興味が沸いたのでいろいろ試しながらコードを書いてみました。&lt;/p>
&lt;h2 id="問題のコード">問題のコード
&lt;/h2>&lt;p>質問の作成者がやりたいことは、&lt;code>List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;&lt;/code>が二つあり、Listの中のMapの要素を確認し、重複する物があれば一つのListとしてまとめたいということです。ここで重複の条件は、MapのKeyとValueでした。&lt;/p>
&lt;p>今はコードは存在するものの、重複チェックのためのロジックが複雑になりすぎて、負荷も高く性能面でも問題があるらしいです。まず彼の後悔しているコードは、以下のようなものでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> list1 &lt;span style="color:#f92672">=&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> list2 &lt;span style="color:#f92672">=&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Object object : list1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String a1 &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Object object2 : list2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String a2 &lt;span style="color:#f92672">=&lt;/span> map2.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (a1.&lt;span style="color:#a6e22e">equals&lt;/span>(a2)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> keys &lt;span style="color:#f92672">=&lt;/span> map2.&lt;span style="color:#a6e22e">keySet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String key : keys) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String v &lt;span style="color:#f92672">=&lt;/span> map2.&lt;span style="color:#a6e22e">get&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.&lt;span style="color:#a6e22e">put&lt;/span>(key, v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードをみると、3重ループになっていて、KeyとValueが一致する項目がないかを一つ一つチェックしています。そして実際のコードなのかよくわかりませんが、このコードだとキーがリテラルになっているので全体のキーを循環できるようなループがまた追加されるべきではないかと思います。そうするとまたループが追加されたりして、より複雑なコードになりそうですね。これをListの個数分回すとしたら、それは負荷が多いだろうなと思います。なのでこれをなるべく短く、より単純なコードにしてみたいと思います。&lt;/p>
&lt;p>Best Practiceではないのかもしれませんが、ひとまず自分の考えてコードを紹介します。&lt;/p>
&lt;h2 id="streamを使ってみる">Streamを使ってみる
&lt;/h2>&lt;p>Listの要素を一つづつ処理したい場合は、まずStreamを使う方法がないかをまず考えてみました。ネットで調べてみるとやはりStreamを使って複数のListをマージする方法がいくつかあります。それらを使って検証してみました。&lt;/p>
&lt;h3 id="結合と重複の除外">結合と重複の除外
&lt;/h3>&lt;p>&lt;code>Stream.concat()&lt;/code>を使うと、二つのStreamをつなげることができます。また、Streamでは&lt;code>distinct()&lt;/code>で重複を除外することができます。これらの組み合わせを使うと、二つのListを重複する要素なしで結合することができます。まず簡単な例題を使うと以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 結合したいList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list1 &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;d&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;e&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list2 &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;d&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;f&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 結合と重複の除外(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;f&amp;#34;)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> concat &lt;span style="color:#f92672">=&lt;/span> Stream.&lt;span style="color:#a6e22e">concat&lt;/span>(list1.&lt;span style="color:#a6e22e">stream&lt;/span>(), list2.&lt;span style="color:#a6e22e">stream&lt;/span>()).&lt;span style="color:#a6e22e">distinct&lt;/span>().&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Stream.concat()&lt;/code>の引数は二つしか指定できないので、3つ以上のListを繋ぐ場合はループを使うのを考慮すると良いです。また、&lt;code>distinct()&lt;/code>の場合、&lt;code>equals()&lt;/code>がちゃんと定義されてあるという前提ならどんなオブジェクトでも重複検査ができます。なのでLombokの&lt;code>@Data&lt;/code>のようなアノテーションのついたクラスでも重複を除外して一つのListに納めることができます。&lt;/p>
&lt;h3 id="限界">限界
&lt;/h3>&lt;p>質問の作成者は、Listの中のMapの要素に対して重複チェックを行いたいと行っていますが、この方法ではそのようにはなりません。なぜなら、Mapそのものを&lt;code>equals()&lt;/code>で比較してしまい、中の要素一つ一つに対してはチェックしない構造となっているからです。なのでこのようなコードだと、二つのListを繋いだような物ができてしまうだけです。&lt;/p>
&lt;h2 id="forループを使ってみる">Forループを使ってみる
&lt;/h2>&lt;p>今回は質問者のコードを直して、より効率的に変えてみます。あえてForループを使っているのは、条件に一致した場合に一回だけ&lt;code>put()&lt;/code>を実行するためです。&lt;code>Stream&lt;/code>や&lt;code>forEach()&lt;/code>は全ての要素に対して処理を行うためのものなので、除きました。&lt;/p>
&lt;p>Mapには&lt;code>put()&lt;/code>以外でも&lt;code>putAll()&lt;/code>があるので、要素を巡回しながら一つづつ一つでもループは消すことができます。そして&lt;code>putAll()&lt;/code>を実行したら、次の要素までチェックする必要はなくなるので&lt;code>continue&lt;/code>を実行して次のループは飛ばすようにして、無駄な処理を無くします。そうするとまず以下のようにコードを帰ることができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Object object : list1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String a1 &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Object object2 : list2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String a2 &lt;span style="color:#f92672">=&lt;/span> map2.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (a1.&lt;span style="color:#a6e22e">equals&lt;/span>(a2)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ループを一回無くす&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.&lt;span style="color:#a6e22e">putAll&lt;/span>(map2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで、MapのKeyを指定しているところも直します。リテラルで指定しなく、Entryを巡回しながら比較することにするのでループは一つ増えます。そして、Entryは&lt;code>Set&lt;/code>で取得できるので、Collectionのメソッドである&lt;code>contains()&lt;/code>を使って比較することができます。なので比較したいMapのうち、どちらかのEntryを巡回しながら要素が違う方のMapに入っているのかを確認するだけで良いですね。これを反映して直したコードが以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Object object : list1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Object object2 : list2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Entryで比較する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map.&lt;span style="color:#a6e22e">Entry&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, DataClass&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry : map2.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map1.&lt;span style="color:#a6e22e">entrySet&lt;/span>().&lt;span style="color:#a6e22e">contains&lt;/span>(entry)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map1.&lt;span style="color:#a6e22e">putAll&lt;/span>(map02);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは最初からあらかじめListの型変換をして、ループ毎に型変換をしないようにすることですね。あまりこれで性能の改善は期待できないのかもしれませんが…&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// あらかじめ型変換をしておく&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> convertedList1 &lt;span style="color:#f92672">=&lt;/span> (List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>) list1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> convertedList2 &lt;span style="color:#f92672">=&lt;/span> (List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>) list2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map : convertedList1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 : convertedList2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map.&lt;span style="color:#a6e22e">Entry&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, DataClass&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry : map2.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map1.&lt;span style="color:#a6e22e">entrySet&lt;/span>().&lt;span style="color:#a6e22e">contains&lt;/span>(entry)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map1.&lt;span style="color:#a6e22e">putAll&lt;/span>(map02);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは場合によってMapのKeyをソートするなどの処理が必要になるかもですが、一旦これで要件は満たしたような気がします。&lt;/p>
&lt;h2 id="条件が違う場合">条件が違う場合
&lt;/h2>&lt;p>質問者のコードからは、推論するしかないことですが、もしListのインデックスを基準に比較するという条件があるとしたら、コードはより減らすことができます。list1とlist2の同じインデックスに、同じ要素を持つMapがあるかを確認するということです。もしこの条件があるとしたら、ループは2重に納めることができます。以下はその場合のコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map : list1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map.&lt;span style="color:#a6e22e">Entry&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry : map.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// List2と同じインデックスを比較する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 &lt;span style="color:#f92672">=&lt;/span> list2.&lt;span style="color:#a6e22e">get&lt;/span>(list1.&lt;span style="color:#a6e22e">indexOf&lt;/span>(map));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map2.&lt;span style="color:#a6e22e">entrySet&lt;/span>().&lt;span style="color:#a6e22e">contains&lt;/span>(entry)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.&lt;span style="color:#a6e22e">putAll&lt;/span>(map2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法を使うためには二つのListが同じサイズを持っているという前提が必要となるのでそこには気をつけなくではならなくなります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>たまにこうやって、自分ではまだ遭遇していない場合に対して考えられるチャンスとなるので、コミュニティに注目するのは良い経験となると思います。調べている間に普段は使ってみたことのないメソッドやAPIを調べてみたり、自分が書いていたコードを振り返ってみる良い機会にもなりますね。&lt;/p>
&lt;p>他にもKeyは構わなく、重複するValueがある場合のみチェックするとか、要素のフィールドが重複している場合をチェックするかなどさまざまなバリエーションを考えられると思います。どれも面白い主題なのですが、今回の主題とは少し乖離があるため、機会があればいつかそのようなケースに対してのコードもブログに載せたいと思います。では、また！&lt;/p></description></item><item><title>MyBatisよりJPAが使いたい</title><link>https://retheviper.github.io/posts/spring-data-jpa/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-data-jpa/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post MyBatisよりJPAが使いたい" />&lt;p>個人的に、クエリーやDBのプラグインなど、DBそのものによるデータの整形はあまりよくないと思っていて、なんからの「処理」が入る場合にSQL文はなるべく最低限のCRUDに制限し、必要な作業は全てアプリにて処理するような実装をしたほうが設計として望ましい形だと思っています。なぜかというと、システム全体の性能、アプリのDBに対しての独立性、処理の容易さという観点からそちらの方が優れていると思っているからです。&lt;/p>
&lt;p>まず性能ですが、DBサーバとAPサーバが物理的に同じ性能のマシンを使っているとしたら、実際は最適化されたクエリーでパフォーマンスをあげることは十分できますね。しかし、処理すべきデータやリクエストが増えると必ずしもそうとは言えません。Webアプリケーションでユーザ数が増えるとスケールアウト&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>やスケールアップ&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>を考慮することになりますが、スケールアウトする場合の場合にDBへの依存が強いアプリは問題を起こす可能性があります。APサーバは複数を利用してもアプリの動作には変わりがありませんが、DBサーバの場合は台数が増えるとデータの整合性という新しい問題が出てきますね。どのDBにも同じデータが保存されていることを保証したいなら、DBサーバをスケールアウトするよりはAPサーバをスケールアウトした方が良いと思います。なのでこの場合はアプリにデータの「処理」を任せた方が望ましいですね。&lt;/p>
&lt;p>次にアプリのDBに対しての独立性ですが、最近は費用の高い&lt;a class="link" href="https://www.oracle.com/database/technologies" target="_blank" rel="noopener"
>Oralce&lt;/a>から無料の&lt;a class="link" href="https://www.postgresql.org" target="_blank" rel="noopener"
>PostgreSQL&lt;/a>や&lt;a class="link" href="https://www.mysql.com" target="_blank" rel="noopener"
>MySQL&lt;/a>に移行するシステムも増えてきていますね。しかし、ここでDBのクエリーやプラグインに依存した部分が多ければ多いほど移行は難しくなる可能性があります。微妙に違うカラムのデータ型から、互換性のないクエリーや機能などを全面的に検討する必要がありますね。なのでSQL文はなるべく単純にした方が、移植生が上がります。&lt;/p>
&lt;p>最後に、処理の容易さなのですが、現在DBの主流であるRDBSの場合は、徹底的にデータをいかに効率的に保存するかが最も重要な課題となっているものです。正規化を終えたテーブル構造は、データを加工するには適合していません。なのでアプリでは必要に応じてエンティティを作って使いますが、そのエンティティに合わせてSQLを書く際はまた複雑なJoinやWhereなどを描かなければならなくなりますね。エンティティの中に他のエンティティがま他入っていたりする場合はJoinをするか、しないかのケースまで考えてクエリーを描かなければなりません。&lt;/p>
&lt;p>このような理由からして、自分はなるべく複雑なクエリーを排除し、なるべくアプリ中心的に開発できる方法はないかと思っていました。初めはJDBCに触れ、そのあとはMyBatisを使うようになっていましたが、MyBatisを使ってもケース別にクエリーを書く必要があるのはまた同じでした。(プラスで、xmlが必要となることもありますね)最近はテレワークにより通勤時間がなくなり、仕事が終わった後は勉強をかねて自作アプリを実装していますが、ここでより簡単に、またよりアプリに優しいDBのAPIがないかと思っていましたが、そこで発見したのがJPAでした。&lt;/p>
&lt;h2 id="jpaとは">JPAとは
&lt;/h2>&lt;p>JPAは&lt;a class="link" href="https://www.oracle.com/java/technologies/persistence-jsp.htm" target="_blank" rel="noopener"
>Java Persistence API&lt;/a>の略で、Javaが提供する標準APIです。ただ、標準APIだとしても、Interfaceとして定義しているだけなので、これを実装したものが必要となります。JPAを実装したものとして有名なのが&lt;a class="link" href="https://hibernate.org" target="_blank" rel="noopener"
>Hibernate&lt;/a>で、これをさらに使いやすく整理したモジュールとして&lt;a class="link" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#reference" target="_blank" rel="noopener"
>Spring Data JPA&lt;/a>が存在しています。&lt;/p>
&lt;p>だいぶ序論が長くなりましたが、結論的に今回言いたいことが何かというと、Spring Data JPAを使うと他のライブラリやフレームワークを使うよりも楽に開発ができるということです。おそらくSQL中心的な開発に関しては自分と同じようなことを考えていた人が他にもいたらしく、JPAは単純なクエリーを自動で作ってくれたり、自動でテーブルのJoinをしてくれるなど全くSQLに触れなくてもDBを扱うことを可能にしてくれています。同じくORMとしてよく使われているMyBatisに比べても、JPAを使った方がより効率的なのではないかな、と個人的には考えています。その理由からか、海外では他のORMよりもJPAを使っている割合の方が圧倒的に高いようでした。なのでもし今もMyBatisを使っている方がいらっしゃるなら、ぜひJPAを一度は使ってみて欲しいところです。&lt;/p>
&lt;p>では、実際にJPA(Spring Data JPA)の特徴と使用法を、一つづつ紹介しましょう。&lt;/p>
&lt;h3 id="jpaの特徴">JPAの特徴
&lt;/h3>&lt;p>まずはJPAの特徴です。正確には特徴というよりは、JPAを使う場合のメリットに近いのではないかと思います。&lt;/p>
&lt;h4 id="自動グラフ探索">自動グラフ探索
&lt;/h4>&lt;p>まず、このようなクラスがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Team&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてチームには所属された選手がいます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Player&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Team team;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>既存のSQLでこの選手オブジェクトをDBから照会する場合は、以下の手順が必要となります。&lt;/p>
&lt;ol>
&lt;li>TeamテーブルをSelectする&lt;/li>
&lt;li>TeamオブジェクトにSelectしたデータを埋め込む&lt;/li>
&lt;li>PlayerテーブルをSelectする&lt;/li>
&lt;li>PlayerオブジェクトにSelectしたデータを埋め込む&lt;/li>
&lt;li>PlayerオブジェクトにTeamオブジェクトをセットする&lt;/li>
&lt;/ol>
&lt;p>この手順は、テーブルのJoinが多くなればなるほど増えます。また、SQLもさらに長くなりますね。例えばTeamクラスにRegionというクラスがフィールドとして入り、RegionにはさらにCountryというクラスが入るとしたら？それぞれのテーブルを照会してJoinするようなクエリーを作る必要があって、またオブジェクトも全部マッピングする必要がありますね。もしこの手順に何らかの抜け漏れなどがあったら、コードは思い通りに作動しないはずです。&lt;/p>
&lt;p>JPAでは、このような参照関係を自動で解決してくれます。例えば、何もしなくても以下のようなことが可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RepositoryからPlayerオブジェクトを取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Player player &lt;span style="color:#f92672">=&lt;/span> repository.&lt;span style="color:#a6e22e">findById&lt;/span>(1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Playerが所属したTeamを取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Team team &lt;span style="color:#f92672">=&lt;/span> player.&lt;span style="color:#a6e22e">getTeam&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="性能の最適化">性能の最適化
&lt;/h3>&lt;p>自動的にグラフ探索をしてくれるところをみると、まさかPlayerテーブルを照会するたびにTeamテーブルも照会しているような無駄なことをしているわけではないか、と思われそうですが、実際はLazy Loadingにより、Teamは&lt;code>getTeam()&lt;/code>を実行した時点でまたのSelect文を発行して照会していることになります。なので、Playerだけの情報が必要な場合はその情報しか照会しないことになります。&lt;/p>
&lt;p>では、場合によっては数回もトランザクションが発生するのではないか、という疑問もあり得ると思いますが、これをJPAではキャッシュとバッチ、フェッチタイプの指定で解決しているようです。これらは以下のように作動します。&lt;/p>
&lt;ul>
&lt;li>キャッシュ：同じエンティティに対して(同一トランザクションならば)2回目以降のSelectはキャッシュから照会する&lt;/li>
&lt;li>バッチ：バッチメソッドを提供し、一回のコミットで複数のクエリを転送する機能を実装している&lt;/li>
&lt;li>フェッチタイプ：アノテーションによりLazy Loadingをするか、最初からJoinして照会するかを選択可能&lt;/li>
&lt;/ul>
&lt;h4 id="自動クエリ生成">自動クエリ生成
&lt;/h4>&lt;p>先にRepositoryからオブジェクトを取得する例を照会しましたが、これが可能になるのはJPAが自動的に生成してくれるクエリーがあるからです。JPAが提供するアノテーションやインタフェースを使うとこで、自動生成されるクエリーを利用することができます。&lt;/p>
&lt;p>つまり、エンティティとして利用するクラスとJPAをアノテーションとインタフェースに紐づけておくといちいちクエリーを作成してオブジェクトにマッピングする必要がなくなるということです。もちろん自作クエリーを使うこともできるので、自動生成されるクエリーを使いたい場合も問題ないです。&lt;/p>
&lt;p>このクエリーの生成は、エンティティのCRUDだけに限ることではありません。エンティティに変更が生じた場合(フィールドを追加する必要がある場合)は、DDLも自動的に作成してくれます。ここで自動生成されるDDLをDrop-Createにするか、AlterにするかはアプリケーションプロパティのHibernate設定でできます。&lt;/p>
&lt;h3 id="jpaの使用法">JPAの使用法
&lt;/h3>&lt;p>では、実際のJPAをコードとしてはどう使えるかをみていきましょう。&lt;/p>
&lt;h4 id="entity">Entity
&lt;/h4>&lt;p>JPAでは、エンティティとそのフィールド(テーブルのカラムや参照関係)をアノテーションによって簡単に定義することができます。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Entityとして指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Entity&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 自動的に増加するPK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GeneratedValue&lt;/span>(strategy &lt;span style="color:#f92672">=&lt;/span> GenerationType.&lt;span style="color:#a6e22e">IDENTITY&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// UniqueかつNonNull設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Column&lt;/span>(nullable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>, unique &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Companyとは多対一の関係&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@ManyToOne&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JoinColumn&lt;/span>(name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;company_id&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Company company;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Insuranceとは一対多の関係で、Lazy Loadingをする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@OneToMany&lt;/span>(fetch &lt;span style="color:#f92672">=&lt;/span> FetchType.&lt;span style="color:#a6e22e">LAZY&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JoinColumn&lt;/span>(name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;insurances_id&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Insurance&lt;span style="color:#f92672">&amp;gt;&lt;/span> insurances;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやってEntityにはGetter・Setterをつけておくことで、Selectした時点でこのクラスに紐づくCompanyはInsuranceのようなテーブルの情報も参照できるようになります。&lt;/p>
&lt;h4 id="repository">Repository
&lt;/h4>&lt;p>JPAでは、いくつかのRepositoryというインタフェースを提供しています。よく使われているものは、&lt;a class="link" href="https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank" rel="noopener"
>JpaRepository&lt;/a>や&lt;a class="link" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html" target="_blank" rel="noopener"
>CrudRepository&lt;/a>、&lt;a class="link" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html" target="_blank" rel="noopener"
>PagingAndSortingRepository&lt;/a>などがあって、それぞれ基本的に提供しているメソッドが異なります。例えばCrudRepositoryは普通にCRUDのためのメソッド(Selectに該当するfind()、Upsertに該当するsave()、Deleteに該当するdelete()など)を基本的に提供していて、PagingAndSortingRepositoryの場合はページング(ページネーション)に対応したメソッドを提供しているなど、基本的によく使われるメソッドが揃っています。例えば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// レコードを数える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> repository.&lt;span style="color:#a6e22e">count&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 全レコードを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Iterable&lt;span style="color:#f92672">&amp;lt;&lt;/span>Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> cars &lt;span style="color:#f92672">=&lt;/span> repository.&lt;span style="color:#a6e22e">findAll&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// レコードを一件取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> car1 &lt;span style="color:#f92672">=&lt;/span> repository.&lt;span style="color:#a6e22e">findById&lt;/span>(1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// レコードを一件削除する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>repository.&lt;span style="color:#a6e22e">delete&lt;/span>(car2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// レコードを保存する(Upsert)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Car saved &lt;span style="color:#f92672">=&lt;/span> repository.&lt;span style="color:#a6e22e">save&lt;/span>(car3);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最初エンティティを定義して、それぞれのエンティティに合わせてJPAが提供するRepositoryを作成すると(extend)、そのRepositoryを使ってクエリを発行することができるようになります。また、基本的に提供しているメソッドが十分でない場合は、命名規則に従ってRepositoryに直接&lt;a class="link" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods" target="_blank" rel="noopener"
>クエリーメソッド&lt;/a>を書くと自動的にクエリーを作成してくれたり、&lt;a class="link" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query" target="_blank" rel="noopener"
>@Query&lt;/a>アノテーションで必要なクエリーを直接書くこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">CarRepository&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> CrudRepository&lt;span style="color:#f92672">&amp;lt;&lt;/span>Car, Long&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// nameで照会するカスタムクエリーメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">existsByName&lt;/span>(String name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// アノテーションにクエリーを指定する場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Query&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;select c from Car c where c.name = ?1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">findByName&lt;/span>(String name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="他に">他に
&lt;/h2>&lt;p>2018年には、&lt;a class="link" href="https://spring.io/projects/spring-data-jdbc" target="_blank" rel="noopener"
>Spring Data JDBC&lt;/a>というものも発表されています。Spring Data JPAとJDBCのAPIの間にはJPA + Hibernateという階層を経由することに比べ、Spring Data JDBCは直接JDBCのAPIを呼び出すことで性能面での利点があるらしいですね。他にも実装をより単純化することでJPAの持つ問題を解消しているらしいですね。例えばキャッシュやLazy Loadingをなくしたとか(JPAのメリットとして紹介しましたが…)&lt;/p>
&lt;p>ただ、Spring Data JDBCは2018年にリリースされたばかりのものなので、クエリーメソッドだけでクエリーを自動生成してくれるなどの機能には対応してなかったり、テーブルやカラムの命名規則がJPAと違うなど、JPAからマイグレートするにはまだいろいろと考慮しなければならない点が多いように思われます。こういうところは、まるでNode.jsとDenoの関係みたいですね。&lt;/p>
&lt;p>Spring Data JDBCは自分でもあまり詳しくなく、サンプルコードをみてテストしてみただけなのですが、すでにSpring Data JPAの経験がある人ならすぐにでも適応できそうな構成となっていました。パッケージは変わってもアノテーションやインタフェースそのものの使い方が大きく変わっている訳でもないので、感覚的には大差ありません。&lt;code>@Entity&lt;/code>のようなアノテーションを使う必要がなくなったというところが目立つくらいでした。なので、個人的なプロジェクトでは一度試してみるのも良いかもしれません。(エンタープライズレベルでは、まだ検証すべきところがあると思うので)&lt;/p>
&lt;p>また、Spring 5からReactiveなプログラミングのできる&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.htm" target="_blank" rel="noopener"
>Webflux&lt;/a>が紹介されたことと共に、同じくNon-blockingに対応する&lt;a class="link" href="https://spring.io/projects/spring-data-r2dbc" target="_blank" rel="noopener"
>Spring R2DBC&lt;/a>というものも注目されているようです。既存のSpringプロジェクトにWebfluxを今すぐ導入する必要はないらしいのでSpring R2DBCも今すぐ導入する必要はないのかもしれませんが、Non-blockingによって性能を改善できる場合&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>は確実に存在するので、場合によっては導入を考慮する価値があるのかもしれませんね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>自分の場合、Springでアプリケーションを作りながらなるべく&lt;code>XML&lt;/code>を排除しJavaのコードだけで全てを管理したかったため、クエリーを自動生成してくれるというところで惹かれていましたが、実際に使ってみると使い方も簡単で(癖はあると思いますが)、テーブルが途中で変わっても簡単に直せるというところがかなり魅力的なものですね。占有率としては標準ということもあり、JPAが他のORMと比べよく使われているようですが、自分みたいにMyBatisしか扱ったことのない方には一度触れてみて損はないかと思います。&lt;/p>
&lt;p>JPAの他にも紹介したようにSpring Dataだけでもいろいろなライブラリが存在していてそれぞれの思想が違うので、やっと一つを少しわかったくらいではまだまだ先が遠いような気もしていますね。でもこうやって、一つのライブラリが作られた経緯や思想を調べるだけでも得られる知識は多く、どれも無駄にはならないと思われるくらい新鮮なものなので、意味のあることとなっていると思います。またこうやって情報を集めつつ、それが誰かにとっては貴重な情報になるといいですね。今後もいろいろ調べてブログに載せて行きます。では、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>サーバの台数を増やすこと。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>サーバのマシンパワーをあげること。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>スレッドプールが小さすぎたり、一つのリクエストに対して処理時間が長すぎてボトルネックになるケースなど&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>最近注目しているものたち</title><link>https://retheviper.github.io/posts/personal-interests-in-this-time/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/personal-interests-in-this-time/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.webp" alt="Featured image of post 最近注目しているものたち" />&lt;p>常に勉強し続けなければならないのがこの業界の定めとは思いますが、変化は日々加速されていて、何に従って何を頼れば良いかわからない時もありますね。新しい言語が続々登場してくるなかでも、昔は性能の問題で注目されてなかった言語がいきなり人気を得たり、当たり前と思っていたパラダイムがひっくり返されたりもします。今はJavaScriptの時代と行っても過言ではない状況に来ていると思いますが、今後はどうなるのでしょうか。いくつか、個人的に興味をもったIT業界の動向についてまとめてみました。&lt;/p>
&lt;h2 id="apple-silicon-mac">Apple Silicon mac
&lt;/h2>&lt;p>こないだ、Appleの開発者向けイベントである&lt;a class="link" href="https://developer.apple.com/videos/play/wwdc2020/101" target="_blank" rel="noopener"
>「WWDC2020」&lt;/a>が開催されました。毎年必ずライブで見ているわけではないのですが(深夜に始まるので…)、最近はテレワークをしていて通勤時間がなくなっているのもあり、最初から最後までライブで見ることができました。&lt;/p>
&lt;p>iOSやiPadOS、macOSの変化ももちろん興味深かったのですが、やはり今回のイベントで最も印象的なものがなんだったかというと、macのメインプロセッサが&lt;a class="link" href="https://www.apple.com/newsroom/2020/06/apple-announces-mac-transition-to-apple-silicon" target="_blank" rel="noopener"
>Apple製のものに変わる&lt;/a>ということでしたね。自分はPowerPC時代のmacは経験したことがありませんが、PPCからIntelへの転換は成功的だったので、今回もそうなると思います。個人的にiPadも使っているのですが、あまりIntelのCPUに比べ性能が劣るという印象は受けたこともありませんでした。&lt;/p>
&lt;p>もちろん、Bootcampを使えなくなることもあり、他にもx86を基盤に作られたサードパーティアプリケーションが使えなくなる可能性もあるので、新しいプロセッサのmacが今年発売したところですぐに使っているmacを買い換えるつもりはありません(高いし…)。でも、以前から&lt;a class="link" href="https://llvm.org" target="_blank" rel="noopener"
>LLVM&lt;/a>や&lt;a class="link" href="https://developer.apple.com/mac-catalyst" target="_blank" rel="noopener"
>Catalyst&lt;/a>のように、違うプラットフォーム(プロセッサ)でも問題なくアプリが起動できるような環境を構築するために何年も投資しているのを見ると、意外と転換は早く、問題なくできるのではと思います。特に自分はWebアプリを書くだけなので、あまりlow levelの技術に触れることもなく、使っている言語のコンパイラが新しいプロセッサに対応してくれれば良いだけですね。実際WWDCの紹介でも、xcodeで作成したプロジェクトは再度ビルドするだけで良いと言ってました。&lt;/p>
&lt;p>ただ気になるのは、自分のIntel製CPUを搭載しているmacに対してのOSのサポートがいつまで続くか、くらいですかね。最近はWindowsの発展もすごいのですが、自分の環境だとあまりWindowsにこだわる必要はないので問題なく転換できそうな気もします。そしてプロセッサのみではなく、SoCなのですでにiPadやiPhoneに適用されているさまざまなセンサーやニューラルエンジンなどを使えるのも大きいメリットと思います。&lt;/p>
&lt;p>ただ、こういう感想はあくまで開発者としての自分の立場から考えた個人レベルの問題で、エンタプライズレベルだといくら&lt;a class="link" href="https://www.apple.com/newsroom/2020/06/apple-announces-mac-transition-to-apple-silicon" target="_blank" rel="noopener"
>Rosetta2&lt;/a>や&lt;a class="link" href="https://developer.apple.com/documentation/xcode/building_a_universal_macos_binary" target="_blank" rel="noopener"
>Universal Binary2&lt;/a>が優秀だとしてもどこかで互換性や性能の問題は起こり得ると思うので要注意とは思います。Officeのデモンストレーションは、今よりもパフォーマンスが優れているように見えたのでよかったのですが、事務職の人があえてmacを使う理由はそもそもないので…&lt;/p>
&lt;p>他、すでに$500でA12Zを搭載したmacを借りることができるようなので、意外とすぐに新プロセッサmacの性能や互換性問題は明らかになるかもしれませんね。まずはそこに注目かな、と思っています。性能のみならず、作業時の温度や電力消費量もどれだけ改善されたか、知りたいところですね。来週あたりでベンチマークを見れるのではないかと思っています。&lt;/p>
&lt;h2 id="deno">Deno
&lt;/h2>&lt;p>JavaScriptはあまり触ってないので、Node.jsにも詳しくないわけですが、やはり昨今のWebアプリだとNode.jsなしでは話にならない時代になっていますね。自分の場合はTypeScriptの方でJavaScriptよりも良い印象を受けたので、NodeでもネイティブなTypeScriptサポートができるといいなと思っていました。それが、Nodeの開発者によって&lt;a class="link" href="https://deno.land" target="_blank" rel="noopener"
>Deno&lt;/a>という新しいランタイムが登場したらしいです。&lt;/p>
&lt;p>基本的にNodeでの反省点(async/awaitのような？)から作っているもののようで、その他にも特徴としてはTypeScriptのコンパイラを内蔵していて、いちいちコンパイルしなくても(JavaScirptにトランスパイルしなくても)使えるというところが自分にとっては最大のメリットのように思われます。&lt;/p>
&lt;p>ただDenoの問題だと、やはり既存のNode.js用モジュールを使えない、というところと、TypeScriptのコンパイルが遅いというところがあげられています。Rustを使って自体のTypeScriptコンパイラを作るという計画があるらしいですが、いつになったら完成できるかわからないのでしばらくDenoを使ったプロジェクトはあまり発券できないかもですね。&lt;/p>
&lt;h2 id="blazor">Blazor
&lt;/h2>&lt;p>5月には&lt;a class="link" href="https://news.microsoft.com/build2020" target="_blank" rel="noopener"
>「Microsoft Build 2020」&lt;/a>にて、&lt;a class="link" href="https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-now-available" target="_blank" rel="noopener"
>Blazor WebAssemblyのリリース発表&lt;/a>がありました。これで.NETとC#による、ブラウザから実行可能なWebアプリケーションを作成できるらしいです。&lt;/p>
&lt;p>Node.jsを使ったWebアプリケーションのメリットとして、よく「一つの言語でサーバサイドとクライアントサイドの両方を開発できる」ことがあげられていますが、このようにJavaScriptを使わなくてもそれが可能になるようなフレームワーク＆ランタイムが登場することもあるのですね。JavaScirptも良い言語ですが、そもそもの限界が明確なので、C#のようなコンパイル言語をブラウザ上で使えるのは逆のパターン(JavaScriptをサーバサイドで使う)に比べ良いところが多いのではないかと思います。&lt;/p>
&lt;p>また、BlazorファミリーとしてPWAの実装ができるBlazor PWA、ElectronとWebViewでのデスクトップアプリが実装できるBlazor Hybrid、HTML要素なしでネイティブアプリが実装できるBlazor Nativeも続々登場する予定だというので、これに刺激を受け他のコンパイル言語でもブラウザで実行できるようになるのではないかと思います。&lt;/p>
&lt;p>WSLやGitHubもありますが、いろいろな意味で最近のMicrosoftの変化と投資はすごいものですね…&lt;/p>
&lt;h2 id="flutter-for-web">Flutter for web
&lt;/h2>&lt;p>iOSとAndroidの二つのプラットフォームのアプリを同時に開発でき、同じく機能するReact Nativeに比べ性能でもネイティブアプリに劣らないことがメリットという&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>ですが、最近Flutterを利用したWebアプリケーションも続々登場しているようです。そもそもFlutterを書くための言語である&lt;a class="link" href="https://dart.dev" target="_blank" rel="noopener"
>Dart&lt;/a>が、次世代JavaScirptを目標に開発されたものなのでおかしいことではないのですが、こうやって一つの言語でモバイルとWebアプリケーションの両方を開発できるということはBlazorの場合と同じく魅力的です。&lt;/p>
&lt;p>ただ、Googleが開発しているというところから、DartではなくKotlinでよかったのでは？という気持ちはありますね。また、自社のサービスをすぐ見捨てる傾向のあるGoogleなのでいつまでFlutterが生き残ることができるか、ということも疑問として残っています。MicrosoftのXamarinがいまいちになっているので、モバイルだけはFlutterを採用して開発するようなこともあるのではないかと思いますが、Webアプリケーションを開発するとしたらC#を利用できるBlazorの方がより魅力的ではないかと思います。&lt;/p>
&lt;h2 id="rust">Rust
&lt;/h2>&lt;p>ポストC、C++として注目されている&lt;a class="link" href="https://www.rust-lang.org" target="_blank" rel="noopener"
>Rust&lt;/a>ですが、最近はこの言語の人気が恐ろしいほどですね。まだエンタプライズレベルでは、既存に構築しているシステムや熟練されたエンジニアがいないなどの理由でRustが使われているケースはあまりないようですが、CやC++と同等のパフォーマンスを見せながらも安定的という面が最大のメリットと言われているらしいです。&lt;/p>
&lt;p>個人的にはWebアプリケーションレベルであまりシステムと直接関わるようなことをする場合はないのですが、PWAの登場などWebアプリケーションでもデスクトップ並みの性能を求められることがあったり、Javaでは直接扱うことのできないバイナリファイルの扱いなどで限界を感じていたりしているので、Rustのような言語が扱えたらより良いアプリケーションを作れるようになるのでは、と思っています。&lt;/p>
&lt;p>特に、コミュニケーションツールとして有名な&lt;a class="link" href="https://discord.com" target="_blank" rel="noopener"
>Discord&lt;/a>がもともと使っていた&lt;a class="link" href="https://golang.org" target="_blank" rel="noopener"
>Golang&lt;/a>をあえてRustに交替したとの記事もあったので、同じくCとC++の代替言語として開発されたGolangさえも圧倒するメリットとは一体何かという疑問が湧いてきて、ますます気になっているところです。最近人気のKotlinの場合も、おそらくJavaと完全互換できるという特徴がなかったら成功できなかったと思いますが、互換性もない言語に転換するほどRustが持っているメリットとは一体なんなのか、知りたいですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いろいろな技術と変化があり、幸せのような、プレッシャーを感じるような複雑な気持ちではありますが、どれも肯定的な変化をもたらしてくれている、と思っています。特に、各言語の変化に関してはJavaのモットーである&lt;code>Write once, run everywhere&lt;/code>がどの言語でもより発展した形として実現されているところをみているようですね。結局どの言語も似たようなものになりつつあるような感覚もするのですが、逆にいうともうどの言語を使うかはあまり関係ない時代になりつつある気もします。&lt;/p>
&lt;p>なので、いったんはそのような変化についていけられるよう、自分のスキルを磨くことですね。どの言語を使うかがあまり重要ではなくなるということは、つまりその言語で何ができるかがより重要ということになると思うので、今の自分にできる言語を使ってさまざまな経験をしてみるのが優先すべきことではないかという気がします。あまり実装ができない最近ですが、個人的なプロジェクトでも進めながら経験してみたくなりました。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>REST APIでのSpring Securityの例外ハンドリングを実装する</title><link>https://retheviper.github.io/posts/spring-rest-api-security-handling/</link><pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-rest-api-security-handling/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post REST APIでのSpring Securityの例外ハンドリングを実装する" />&lt;p>前回はREST APIでのログインの方式と、JWTを使った認証認可について説明しました。でも、アプリケーション全体のセキュリティという観点からするとログインができたということだけで全てが終わったわけではないです。例えばエラーハンドリングがありますね。&lt;/p>
&lt;p>Spring SerucityのConfigurationクラス(&lt;code>WebSecurityConfigurerAdapter&lt;/code>の継承クラス)を作成しておいて、ロールによってアクセスできるURLをの制限をかけておくことだけで認可されてないリクエストに対してエラーを出してくれますが、カスタムクラスで独自のエラーハンドリングをしたい場合もあリますね。&lt;/p>
&lt;p>なので、今回はログインの以外に、REST APIでの認証認可周りで必要となるSpring Securityの設定を紹介したいと思います。ここで紹介するのは以下のようになります。&lt;/p>
&lt;ol>
&lt;li>ログインしてない使用者が、特定のURLにアクセスする場合のハンドリング&lt;/li>
&lt;li>ログインしているが、特定のURLにアクセスする場合のハンドリング&lt;/li>
&lt;li>ログインに失敗した場合のハンドリング&lt;/li>
&lt;li>ログアウトした場合のハンドリング&lt;/li>
&lt;/ol>
&lt;p>では、一つづつどうやってカスタムクラスを作るのかをみていきましょう。&lt;/p>
&lt;h2 id="authenticationentrypoint">AuthenticationEntryPoint
&lt;/h2>&lt;p>&lt;code>ログインしていない使用者が、特定のURLにアクセスする場合のハンドリング&lt;/code>のためには、AuthenticationEntryPointの実装が必要となります。ここではレスポンスとして&lt;code>UNAUTHORIZED&lt;/code>を表示する例を紹介します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JWTAuthenticationEntryPoint&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> AuthenticationEntryPoint {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">commence&lt;/span>(HttpServletRequest request, HttpServletResponse respose, AuthenticationException exception) &lt;span style="color:#66d9ef">throws&lt;/span> IOException, ServletException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンスの設定(401 UNAUTHORIZED)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response.&lt;span style="color:#a6e22e">sendError&lt;/span>(HttpStatus.&lt;span style="color:#a6e22e">UNAUTHORIZED&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>(), HttpStatus.&lt;span style="color:#a6e22e">UNAUTHORIZED&lt;/span>.&lt;span style="color:#a6e22e">getReasonPhrase&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="accessdeniedhandler">AccessDeniedHandler
&lt;/h2>&lt;p>&lt;code>ログインしているが、特定のURLにアクセスする場合のハンドリング&lt;/code>のためには、AccessDeniedHandlerの実装が必要となります。ここではレスポンスとして&lt;code>FORBIDDEN&lt;/code>を表示する例を紹介します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JWTAccessDeniedHandler&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> AccessDeniedHandler {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">handle&lt;/span>(HttpServletRequest request, HttpServletResponse response, AccessDeniedException exception) &lt;span style="color:#66d9ef">throws&lt;/span> IOException, ServletException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンスの設定(403 FORBIDDEN)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response.&lt;span style="color:#a6e22e">sendError&lt;/span>(HttpStatus.&lt;span style="color:#a6e22e">FORBIDDEN&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>(), HttpStatus.&lt;span style="color:#a6e22e">FORBIDDEN&lt;/span>.&lt;span style="color:#a6e22e">getReasonPhrase&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="authenticationfailurehandler">AuthenticationFailureHandler
&lt;/h2>&lt;p>&lt;code>ログインに失敗した場合のハンドリング&lt;/code>のためには、AuthenticationFailureHandlerの実装が必要となります。ここではレスポンスとして&lt;code>FORBIDDEN&lt;/code>を表示する例を紹介します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JWTAuthenticationFailureHandler&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> AuthenticationFailureHandler {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">onAuthenticationFailure&lt;/span>(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) &lt;span style="color:#66d9ef">throws&lt;/span> IOException, ServletException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンスの設定(403 FORBIDDEN)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response.&lt;span style="color:#a6e22e">sendError&lt;/span>(HttpStatus.&lt;span style="color:#a6e22e">FORBIDDEN&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>(), HttpStatus.&lt;span style="color:#a6e22e">FORBIDDEN&lt;/span>.&lt;span style="color:#a6e22e">getReasonPhrase&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="logoutsuccesshandler">LogoutSuccessHandler
&lt;/h2>&lt;p>&lt;code>ログアウトした場合のハンドリング&lt;/code>のためには、LogoutSuccessHandlerの実装が必要となります。JWTを使ったログインだけでなく、REST APIのログインはSessionではなくトークンのような情報をクライアントが持つので、サーバサイドで処理することはありません。ログアウトの場合はクライアント側で認証に必要な情報を削除するようにして、サーバサイドとしては単純にレスポンスとして&lt;code>OK&lt;/code>を表示します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JWTLogoutSuccessHandler&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> LogoutSuccessHandler {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">onLogoutSuccess&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> HttpServletRequest request, &lt;span style="color:#66d9ef">final&lt;/span> HttpServletResponse response,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Authentication authentication) &lt;span style="color:#66d9ef">throws&lt;/span> IOException, ServletException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンスの設定(200 OK)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response.&lt;span style="color:#a6e22e">setStatus&lt;/span>(HttpStatus.&lt;span style="color:#a6e22e">OK&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="configurationクラスの設定">Configurationクラスの設定
&lt;/h2>&lt;p>最後に、Configurationクラスに今まで作成したカスタムHandlerクラスをそれぞれの目的に合わせて登録します。メソッドを覚えるだけで、登録の内容自体は難しくないです。ここでは以前のポストで作成したクラスを基盤に修正しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RequiredArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SecurityConfig&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> WebSecurityConfigurerAdapter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> AuthenticationManager &lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">configure&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> HttpSecurity httpSecurity) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> httpSecurity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">httpBasic&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">csrf&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">formLogin&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">sessionManagement&lt;/span>().&lt;span style="color:#a6e22e">sessionCreationPolicy&lt;/span>(SessionCreationPolicy.&lt;span style="color:#a6e22e">STATELESS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">authorizeRequests&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">anyRequest&lt;/span>().&lt;span style="color:#a6e22e">hasRole&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;USER&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 例外ハンドリングの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">exceptionHandling&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログインしなかった場合のハンドラーの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">accessDeniedHandler&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> JWTAccessDeniedHandler())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 権限がない場合のハンドラーの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">authenticationEntryPoint&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> JWTAuthenticationEntryPoint())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログアウトの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">logout&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログアウトに使うURLを設定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">logoutUrl&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/logout&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// LogoutSuccessHandlerを指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">logoutSuccessHandler&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> JWTLogoutSuccessHandler())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addFilterBefore&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> JWTAuthenticationFilter(), UsernamePasswordAuthenticationFilter.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addFilterAt&lt;/span>(getJsonUsernamePasswordAuthenticationFilter(), UsernamePasswordAuthenticationFilter.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> JsonUsernamePasswordAuthenticationFilter &lt;span style="color:#a6e22e">getJsonUsernamePasswordAuthenticationFilter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> JsonUsernamePasswordAuthenticationFilter jsonFilter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JsonUsernamePasswordAuthenticationFilter();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonFilter.&lt;span style="color:#a6e22e">setFilterProcessesUrl&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/web/login&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonFilter.&lt;span style="color:#a6e22e">setAuthenticationManager&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonFilter.&lt;span style="color:#a6e22e">setAuthenticationSuccessHandler&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> JWTAuthenticationSuccessHandler());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 認証に失敗した場合のハンドラーの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonFilter.&lt;span style="color:#a6e22e">setAuthenticationFailureHandler&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> JWTAuthenticationFailureHandler());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> jsonFilter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここではFilterやHandlerなどのクラスのインスタンスを新しく作成していますが、&lt;code>@Component&lt;/code>でBeanとして登録しておいても構いません。どっちかとするとBean登録した方が良いかなという気はしますが、ここではコードが長くなるので省略しておきました。&lt;/p>
&lt;p>また、一般的にDIはフィールドよりもコンストラクタにつけた方が良いといいますが、フィールドをfinalとして宣言している場合ならLombokの&lt;code>@RequiredArgsConstructor&lt;/code>を使っても自動でDIされますので今回はそのような書き方にしてみました。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ハンドリングの場合は、メソッドが一つしかないインタフェースを実装して、Configurationクラスに登録するだけなので難しくないですね。それぞれのHandlerインタフェースは、引数としてリクエストはレスポンス、認証情報をとっているので、場合によってはカスタム例外ビューモデルを作成して返したり、エラー処理用のControllerを作ってリダイレクトさせるなど様々な処理ができます。&lt;/p>
&lt;p>セキュリティという面から考えると、定型化されたSpring Securityのエラーが出されるということはサーバサイドがSpringで作成されていることを知らせるようなものなので、アプリの脆弱性の問題に繋がる場合もあると思われますね。なのでWebアプリケーションを作る場合は、外部に漏出される情報に関しては徹底的に管理しておいた方が良いのではないかと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>JWTによるREST APIのログインを実現する</title><link>https://retheviper.github.io/posts/spring-rest-api-login-with-jwt/</link><pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-rest-api-login-with-jwt/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post JWTによるREST APIのログインを実現する" />&lt;p>最近は、本格的にSpring SecurityによるREST APIでのログインの実装を勉強しています。実際の業務で使うことになるかどうかは分かりませんが、とりあえずREST APIで一般的な認証認可はどのように実装すべきで、Spring Securityはどう動くものかをまず理解しておかないとという気がして(そして最近はあまり実装していないので、感覚を失いたくないという願望もあり)、とりあえず自分で調べたことと、実装したコードの記録を兼ねて書きたいと思います。&lt;/p>
&lt;p>他にもいろいろな方法があるのかもしれませんが、今回自分が選んだのはJWTとSpring Securityを使ったREST APIでの認証認可のところです。初めはSpring SecurityもJWTもREST APIでの認証認可も全く知識がなかったのでかなり苦労しましたが、とりあえず成功したので、わかったことをまとめてみました。&lt;/p>
&lt;h2 id="jwtとは">JWTとは
&lt;/h2>&lt;p>JWT(JSON Web Token)は、署名や暗号化などを含む情報をJSONオブジェクトとして伝達することができる、オープン標準&lt;a class="link" href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener"
>RFC 7519&lt;/a>です。JWTのデータは署名されているためこの伝達されるデータの送信元の特定や途中でデータが入れ替えされなかったか(改ざんされてないか)の検証などができるので、多くの場合にユーザの認証で使われます。&lt;/p>
&lt;p>このようにJWTの中には署名や暗号化などに必要なデータは全て含まれているので、サーバサイドではJWTを受け取ることでデータのバリデーションチェックができるなど自己完結性があって、既存のSessionを使った方法とは別にStatelessな方法としてユーザの認証と認可を可能にします。なので今回紹介する、REST APIでのログインのために適している認証方式といえますね。&lt;/p>
&lt;h2 id="jwtでのログインシナリオ">JWTでのログインシナリオ
&lt;/h2>&lt;p>まずJWTを使ったログインの場合、クライアントからログインに必要なクレデンシャル(IDやパスワードなど)をサーバに送ると、サーバからはユーザの情報に基づいてJWTを発行して返します。クライアントはこの情報をリクエスト毎に載せてサーバに伝達し、サーバではJWTのバリデーションを行なってからレスポンスを返すようになります。&lt;/p>
&lt;p>ここでJWTとして作られたJWTをクライアント側に送る時やクライアントがリクエストを送る時、レスポンスやリクエストのHTTP Headerに載せることになります。なぜSessionではなくHeaderに載せるかについては&lt;a class="link" href="../spring-rest-api-how-to-login" >このポスト&lt;/a>を参考にしてください。&lt;/p>
&lt;p>ログインに成功したあとは、Sessionを使う場合と同じく認証させているかをチェックして各URLへのアクセスを認可するようになりますね。ここはSpring Securityが担当するようになります。&lt;/p>
&lt;h2 id="jwtとspring-securityによるログイン">JWTとSpring Securityによるログイン
&lt;/h2>&lt;p>では、以上のシナリオをどう実現できるかを考えてみます。まず、ログイン要請を受けるコントローラとメソッドを用意する必要がありますね。そして、そのコントローラからはサービスクラスから入力されたクレデンシャルを検証してもらいます。検証できたら、その情報を元にJWTのJWTを作る必要がありますね。&lt;/p>
&lt;h3 id="spring-securityの設定jwtを使う前">Spring Securityの設定(JWTを使う前)
&lt;/h3>&lt;p>まずはREST APIでの認証認可を簡単にSpring Securityで実装します。Spring Securityそのものだけでもかなり膨大な量を勉強しなければならないのですが、ここではまず、DBに登録されているユーザの情報を取得し、そのユーザのロールによってアクセスできるURLを制限するという機能だけを実現します。(他にも、ログインとはあまり関係のないクラスのコードは省略しています)&lt;/p>
&lt;h4 id="entityクラス">Entityクラス
&lt;/h4>&lt;p>まずはDBからユーザの情報を取得するためのクラスを作る必要がありますね。UserDetailsをimplementしたクラスを簡単に作っておきます。これは既存にユーザのエンティティとして作っても良いですが、認証のための専用のクラスとなるので、別クラスとして作成しても構わないです。ただ、その場合はちゃんとテーブルで既存のユーザ情報と紐づくように管理する必要がありますね。&lt;/p>
&lt;p>以下のコードは、UserDetailsクラスをSpring Data JPA基準のエンティティとして作成した例です。ここからユーザ名(username)とロール(roles)をJWTに載せて認証と認可に使うことにします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Entity&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> UserDetails {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GeneratedValue&lt;/span>(strategy &lt;span style="color:#f92672">=&lt;/span> GenerationType.&lt;span style="color:#a6e22e">IDENTITY&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザ名(一般的にID)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String username;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザアカウントが満了されているかの設定 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> accountNonExpired;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザアカウントがロックされているかの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> accountNonLocked;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザアカウントのクレデンシャルが満了されているかの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> credentialsNonExpired;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザアカウントが活性化されているかの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> enabled;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 認可のためのユーザのロール&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@ElementCollection&lt;/span>(fetch &lt;span style="color:#f92672">=&lt;/span> FetchType.&lt;span style="color:#a6e22e">EAGER&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> roles &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザの認可情報を取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Collection&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> GrantedAuthority&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">getAuthorities&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">roles&lt;/span>.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(SimpleGrantedAuthority::&lt;span style="color:#66d9ef">new&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toUnmodifiableList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="serviceクラス">Serviceクラス
&lt;/h4>&lt;p>UserDetailsを取得するためのServiceクラスを作っておきます。このクラスでログイン後のユーザ情報を取得するようになります。UserDetailsServiceのメソッドはユーザ名からUserDetailsを取得するための&lt;code>loadUserByUsername&lt;/code>しかないので、これを適切にRepositoryから取得できるように実装します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UserServiceImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> UserDetailsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// UserDetailsを取得できるRepository&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> UserRepository repository;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">UserServiceImpl&lt;/span>(UserRepository repository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span> &lt;span style="color:#f92672">=&lt;/span> repository;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 認証後にユーザ情報を取得するためのメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> UserDetails &lt;span style="color:#a6e22e">loadUserByUsername&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String username) &lt;span style="color:#66d9ef">throws&lt;/span> UsernameNotFoundException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">findByUsername&lt;/span>(username);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="configurationクラス">Configurationクラス
&lt;/h4>&lt;p>認可のためのConfigurationクラスです。ここでは&lt;code>USER&lt;/code>というロールが設定されてない場合、どのURLにもアクセスできないようにしておきました。ログイン後、ユーザがURLにアクセスためのリクエストを送ると、この設定によりユーザのロールを確認してアクセスを認可するようになります。このロールはユーザを作成するとき、createUserなどのメソッドでrolesを&lt;code>ROLE_USER&lt;/code>として保存するようにしておくと良いです。&lt;/p>
&lt;p>また、今回作るのはREST APIであり、JWTによる認証と認可を行うことになるので、いくつかのデフォルト設定を変えておきます。例えば&lt;a class="link" href="https://ja.wikipedia.org/wiki/Basic%E8%AA%8D%E8%A8%BC" target="_blank" rel="noopener"
>Basic Auth&lt;/a>と&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%82%B9%E3%82%B5%E3%82%A4%E3%83%88%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E3%83%95%E3%82%A9%E3%83%BC%E3%82%B8%E3%82%A7%E3%83%AA" target="_blank" rel="noopener"
>CSRF&lt;/a>の設定や、セッション設定などがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SecurityConfig&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> WebSecurityConfigurerAdapter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> AuthenticationManager &lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">configure&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> HttpSecurity httpSecurity) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> httpSecurity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Basic認証を使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">httpBasic&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// CSRF設定を使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">csrf&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// セッションはStatelessなので使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">sessionManagement&lt;/span>().&lt;span style="color:#a6e22e">sessionCreationPolicy&lt;/span>(SessionCreationPolicy.&lt;span style="color:#a6e22e">STATELESS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// USERではないとどのURLでもアクセスできない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">authorizeRequests&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">anyRequest&lt;/span>().&lt;span style="color:#a6e22e">hasRole&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;USER&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでSpring Securityを使うための必要最低限の準備は終わりました。他にユーザのCRUDのためのServiceやRepositoryは適宜作成してあるという前提として、次に進めましょう。&lt;/p>
&lt;h3 id="jwtの依存関係の追加">JWTの依存関係の追加
&lt;/h3>&lt;p>次に、本格的にJWTを使うための設定を行います。Spring BootでJWTを使うためには依存関係の追加が必要です。JWT自体は仕様が決まっていて、規格に合わせて適切なJSONとして作成した後にBase64としてエンコードしても実現はできますが、こういうものを扱う場合はなるべくライブラリを使った方が安全ですね。&lt;/p>
&lt;p>Spring(Java)で使えるJWTのライブラリはいくつかありますが、JWT自体が標準なのでどちらを選んでも基本は同じです。ただ、ライブラリ毎にJWTの仕様にどこまで対応しているのかは違う場合があるので、公式サイトから&lt;a class="link" href="https://jwt.io/#libraries-io" target="_blank" rel="noopener"
>対応しているライブラリのリスト&lt;/a>を確認してどれを使うかを選びましょう。このポストでは&lt;code>JSON Web Token Support For The JVM&lt;/code>を使った場合での実装方法を紹介します。&lt;/p>
&lt;p>Mavenの場合は以下のように依存関係を追加します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>io.jsonwebtoken&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>jjwt&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>0.9.1&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Gradleの場合の場合は以下となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>dependencies &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation &lt;span style="color:#e6db74">&amp;#39;io.jsonwebtoken:jjwt:0.9.1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="jwtを提供するクラスを作る">JWTを提供するクラスを作る
&lt;/h3>&lt;p>依存関係を追加したら、ログイン成功時のResponseとクライアントからのリクエスト時のHeaderに載せるためのJWTを実際に作ってくれるクラスの作成が必要となります。色々な方法があると思いますが、ここではJWTを作成して検証もしてくれるようなクラスを作ります。その後はリクエスト毎に、HeaderのJWTを検証するためのクラスを作って行きます。&lt;/p>
&lt;h4 id="jwtの仕様">JWTの仕様
&lt;/h4>&lt;p>JWTを作る前に、まず簡単にJWTがどんな構造を持っているかを見ていきましょう。JWTは&lt;code>Header&lt;/code>、&lt;code>Payload&lt;/code>、&lt;code>Signature&lt;/code>という三つの要素で構成されています。それぞれの要素はBase64の文字列としてエンコードして、つなげることで一つのJWTが構成されます。&lt;/p>
&lt;h5 id="headerの構成">Headerの構成
&lt;/h5>&lt;p>Headerではこのトークンがどのようなもので、どのアルゴリズムでエンコードされているかを表す情報を載せるようになります。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>意味&lt;/th>
&lt;th>詳細&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>typ&lt;/td>
&lt;td>Token Type&lt;/td>
&lt;td>JWTのタイプ(=JWT)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>alg&lt;/td>
&lt;td>Hashing Algoritym&lt;/td>
&lt;td>エンコードする時のアルゴリズム&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="payloadの構成">Payloadの構成
&lt;/h5>&lt;p>Payloadはnameとvalueのペアで構成された複数の情報単位で構成されている、いわばBodyのようなもので、ここに載せる個々の情報単位たちをClaimと呼びます。今回のログインではこのClaimにユーザのIDとロール、そしてトークンが発行された期間を載せることにします。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>id&lt;/th>
&lt;th>意味&lt;/th>
&lt;th>詳細&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>jti&lt;/td>
&lt;td>JWT ID&lt;/td>
&lt;td>JWTの識別子&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sub&lt;/td>
&lt;td>subject&lt;/td>
&lt;td>JWTのユニークなキー&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>iss&lt;/td>
&lt;td>issuer&lt;/td>
&lt;td>JWTを発行者&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>aud&lt;/td>
&lt;td>audience&lt;/td>
&lt;td>JWTの利用者&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>iat&lt;/td>
&lt;td>issued at&lt;/td>
&lt;td>JWTが発行された時間&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>nbf&lt;/td>
&lt;td>not before&lt;/td>
&lt;td>JWTの開始時間&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>exp&lt;/td>
&lt;td>expiration time&lt;/td>
&lt;td>JWTの満了時間&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="sigunature">Sigunature
&lt;/h5>&lt;p>SignatureではHeaderとPayloadをエンコードしたあと、更に任意のシークレットキーを持ってエンコードします。これによって、サーバ側ではクライアントが送ってきたJWTをSignatureをデコードしてHeaderとPayloadを取得できるようになります。&lt;/p>
&lt;p>Header、Payload、Signature順で正しく作成したJWTは、&lt;a class="link" href="https://jwt.io" target="_blank" rel="noopener"
>JWTの公式サイト&lt;/a>から検証できます。以下のようにJWTの構造と格納しているデータを確認してデバッグができるので、興味のある方はぜひ試してみてください。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/spring-rest-api-login-with-jwt/jwt_structure.webp"
width="2372"
height="1266"
srcset="https://retheviper.github.io/posts/spring-rest-api-login-with-jwt/jwt_structure_hu_8d70c8f76fb61da5.webp 480w, https://retheviper.github.io/posts/spring-rest-api-login-with-jwt/jwt_structure_hu_24692e8cd720ad5.webp 1024w"
loading="lazy"
alt="Structure of JWT"
class="gallery-image"
data-flex-grow="187"
data-flex-basis="449px"
>&lt;/p>
&lt;h3 id="token-providerクラスの実装">Token Providerクラスの実装
&lt;/h3>&lt;p>では、JWTがどんな情報により構成されているかがわかったので、必要な情報を載せて実際のJWTを作成するクラスを作りましょう。ここでHeader、Payload、Signatureの全部を埋める必要はなく、最低限の情報だけ使うことにします。&lt;/p>
&lt;p>まずトークンを作成するメソッドを作ります。ここで作成されるJWTのPayloadに載せるClaimは、ユーザ名とロールに限定します。また、JWTが発行された時間と満了時間を設定して、期間外では使えないようにします。そして最後にカスタムシークレットキーを設定してSignatureを作成することにします。&lt;/p>
&lt;p>他には、トークンを読み込んでDBのユーザ情報を取得するメソッド、リクエストのHeaderからトークンを取得するメソッド、トークンの有効期間を検証するメソッド、トークンにのせたユーザ名(ID)を取得するメソッドなども作っておきます。(こちらは別途クラスで切っても良さそうな気はします)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JWTProvider&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Signatureのエンコードに使うシークレットキー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String TOKEN_SECRET_KEY &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;This is secrect!&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// トークンの有効期間(1時間)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> TOKEN_VAILD_DURATION &lt;span style="color:#f92672">=&lt;/span> 1000L &lt;span style="color:#f92672">*&lt;/span> 60L &lt;span style="color:#f92672">*&lt;/span> 60L;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザ情報を取得するためのサービスクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> UserDetailsService service;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">JWTProvider&lt;/span>(UserDetailService service) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">service&lt;/span> &lt;span style="color:#f92672">=&lt;/span> service;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// UserオブジェクトからJWTを作成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">createToken&lt;/span>(User user) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Claimとしてユーザ名とロールを載せる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Claims claims &lt;span style="color:#f92672">=&lt;/span> Jwts.&lt;span style="color:#a6e22e">claims&lt;/span>().&lt;span style="color:#a6e22e">setSubject&lt;/span>(user.&lt;span style="color:#a6e22e">getId&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> claims.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;roles&amp;#34;&lt;/span>, user.&lt;span style="color:#a6e22e">getRoles&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// トークンの開始時間と満了時間を決める&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Date iat &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Date exp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date(start.&lt;span style="color:#a6e22e">getTime&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> TOKEN_VAILD_DURATION);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// JWTの作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Jwts.&lt;span style="color:#a6e22e">builder&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">setClaims&lt;/span>(claims)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">setIssuedAt&lt;/span>(iat)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">setExpiration&lt;/span>(exp)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">signWith&lt;/span>(SignatureAlgorithm.&lt;span style="color:#a6e22e">HS256&lt;/span>, TOKEN_SECRET_KEY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">compact&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// トークンからユーザ情報を取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Authentication &lt;span style="color:#a6e22e">getAuthentication&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String token) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> UserDetails userDetails &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">service&lt;/span>.&lt;span style="color:#a6e22e">loadUserByUsername&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getSubject&lt;/span>(token));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> UsernamePasswordAuthenticationToken(userDetails, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, userDetails.&lt;span style="color:#a6e22e">getAuthorities&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// リクエストのHeaderからトークンを取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">resolveToken&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> HttpServletRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> request.&lt;span style="color:#a6e22e">getHeader&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;X-AUTH-TOKEN&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// トークンの有効期間を検証する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">validateToken&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String token) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Jws&lt;span style="color:#f92672">&amp;lt;&lt;/span>Claims&lt;span style="color:#f92672">&amp;gt;&lt;/span> claims &lt;span style="color:#f92672">=&lt;/span> Jwts.&lt;span style="color:#a6e22e">parser&lt;/span>().&lt;span style="color:#a6e22e">setSigningKey&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">secretKey&lt;/span>).&lt;span style="color:#a6e22e">parseClaimsJws&lt;/span>(token);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>claims.&lt;span style="color:#a6e22e">getBody&lt;/span>().&lt;span style="color:#a6e22e">getExpiration&lt;/span>().&lt;span style="color:#a6e22e">before&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> Date());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// トークンからユーザ名を取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pubic String &lt;span style="color:#a6e22e">getSubject&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String token) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Jwts.&lt;span style="color:#a6e22e">parser&lt;/span>().&lt;span style="color:#a6e22e">setSigningKey&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">secretKey&lt;/span>).&lt;span style="color:#a6e22e">parseClaimsJws&lt;/span>(token).&lt;span style="color:#a6e22e">getBody&lt;/span>().&lt;span style="color:#a6e22e">getSubject&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="カスタムfilterクラスの実装">カスタムFilterクラスの実装
&lt;/h3>&lt;p>次に、ログインするときにリクエストを検証するためのFilterクラスを作成します。最初ユーザがログインすると、このクラスでは先に作成したJWTProviderを使って、Headerからトークンを取得、有効期間の検証を行った後、問題なければDBからユーザ情報を取得してSpring Securityの認証情報(Authentication)としてセットするようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JWTAuthenticationFilter&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> GenericFilterBean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// トークンを検証するためのProvider&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> JWTProvider provider;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">JWTAuthenticationFilter&lt;/span>(JWTProvider provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span> &lt;span style="color:#f92672">=&lt;/span> provider;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログインに対するフィルタリングを行う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doFilter&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> ServletRequest request, &lt;span style="color:#66d9ef">final&lt;/span> ServletResponse response, &lt;span style="color:#66d9ef">final&lt;/span> FilterChain filterChain)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throws&lt;/span> IOException, ServletException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String token &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span>.&lt;span style="color:#a6e22e">resolveToken&lt;/span>((HttpServletRequest) request);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (token &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span>.&lt;span style="color:#a6e22e">validateToken&lt;/span>(token)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Authentication auth &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span>.&lt;span style="color:#a6e22e">getAuthentication&lt;/span>(token);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SecurityContextHolder.&lt;span style="color:#a6e22e">getContext&lt;/span>().&lt;span style="color:#a6e22e">setAuthentication&lt;/span>(auth);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filterChain.&lt;span style="color:#a6e22e">doFilter&lt;/span>(request, response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="spring-securityにjwtでのログイン設定を追加する">Spring SecurityにJWTでのログイン設定を追加する
&lt;/h3>&lt;p>では、JWTを作成して検証するための準備が終わったので、これからはSpring Securityでこのクラスたちを使って認証と認可を行うための設定をする版ですね。どれが定番だとかという訳ではないですが、どちらも好みに合わせて(もしくは要件に合わせて)使えるのではないかと思い、三つの方法を用意しました。&lt;/p>
&lt;h4 id="formloginを使う場合">FormLoginを使う場合
&lt;/h4>&lt;p>Spring SecurityのFormLoginを利用してログインのためのURLと、ログイン後のJWT作成を全て設定しておきたい場合の実装です。クライアント側ではログインのためのクレデンシャルをPOSTのFormデータとして送るようになります。&lt;/p>
&lt;p>ここではログインを処理するためのURLとクレデンシャルのためのパラメータなどを設定して、ログインに成功したらトークンを作成して返すための&lt;code>AuthenticationSuccessHandler&lt;/code>を設定することになります。&lt;/p>
&lt;h5 id="authenticationsuccesshandlerの作成">AuthenticationSuccessHandlerの作成
&lt;/h5>&lt;p>まずログインに成功した場合にトークンを返すためのSuccessHandlerを作成します。ログインに成功した場合、Authenticationクラスにユーザ情報が保存されるので、それをProviderに渡してトークンを作成してもらった後にレスポンスのHeaderに載せて返すことをやっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JWTAuthenticationSuccessHandler&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> AuthenticationSuccessHandler {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// トークンを作成するためのProvider&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> JWTProvider provider;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">JWTAuthenticationSuccessHandler&lt;/span>(JWTProvider provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span> &lt;span style="color:#f92672">=&lt;/span> provider;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">onAuthenticationSuccess&lt;/span>(HttpServletRequest request,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpServletResponse response,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Authentication auth) &lt;span style="color:#66d9ef">throws&lt;/span> IOException, ServletException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// すでにレスポンスで情報を返した場合は何もしない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (response.&lt;span style="color:#a6e22e">isCommitted&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログインに成功したユーザ情報を取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user &lt;span style="color:#f92672">=&lt;/span> (User) auth.&lt;span style="color:#a6e22e">getPrincipal&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Headerにトークンを作成して載せる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response.&lt;span style="color:#a6e22e">setHeader&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;X-AUTH-TOKEN&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span>.&lt;span style="color:#a6e22e">createToken&lt;/span>(user));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// HTTP Statusは200 OK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response.&lt;span style="color:#a6e22e">setStatus&lt;/span>(HttpStatus.&lt;span style="color:#a6e22e">OK&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="spring-securityの設定">Spring Securityの設定
&lt;/h5>&lt;p>では、ログインに成功したときのHandlerクラスを作成したので、Spring Securityの設定を変えていきます。必要なのは&lt;code>loginProcessingUrl()&lt;/code>(ログインの処理をするためのPOST通信が行われるURLとHanlderの設定で、ユーザ名のパラメータ名やパスワードのパラメタ名はデフォルトと違う場合にだけ必要となります。そしてFilterはデフォルト設定だと&lt;code>UsernamePasswordAuthenticationFilter&lt;/code>が先に実行されるので、先ほど作成した&lt;code>JWTAuthenticationFilter&lt;/code>を使うための設定をします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SecurityConfig&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> WebSecurityConfigurerAdapter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログインが成功した場合の処理のためのHandler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> JWTAuthenticationSuccessHandler successHandler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン以降の認証認可のためのFilter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> JWTAuthenticationFilter filter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">SecurityConfig&lt;/span>(JWTAuthenticationSuccessHandler successHandler, JWTAuthenticationFilter filter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">successHandler&lt;/span> &lt;span style="color:#f92672">=&lt;/span> successHandler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span> &lt;span style="color:#f92672">=&lt;/span> filter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> AuthenticationManager &lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">configure&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> HttpSecurity httpSecurity) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> httpSecurity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">httpBasic&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">csrf&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">sessionManagement&lt;/span>().&lt;span style="color:#a6e22e">sessionCreationPolicy&lt;/span>(SessionCreationPolicy.&lt;span style="color:#a6e22e">STATELESS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// formLoginを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">formLogin&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// POSTでクレデンシャルをもらい、ログイン処理を行うURL(UserDetailsServiceを使うことになる)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">loginProcessingUrl&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/web/login&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン処理ようのURLには認証認可なしでアクセスできる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">permitAll&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザ名のパラメータ(デフォルトはusername)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">usernameParameter&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザパスワードのパラメータ(デフォルトはpassword)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">passwordParameter&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;pass&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログインに成功したら実行されるsuccessHandlerの指定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">successHandler&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">successHandler&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">authorizeRequests&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">anyRequest&lt;/span>().&lt;span style="color:#a6e22e">hasRole&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ROLE_USER&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// デフォルトのFilter設定を変える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addFilterBefore&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>, UsernamePasswordAuthenticationFilter.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="jsonを使えるfilterを使う場合">JSONを使えるFilterを使う場合
&lt;/h4>&lt;p>Spring SecurityのFormLoginを使う場合、ログインのためのクレデンシャルはFormデータである必要があります。しかし、REST APIならばデータのやりとりはJSONが基本ですね。なのでクレデンシャルもJSONで送るようにしたいのですが、Spring Securityではそのようなメソッドを提供していません。&lt;/p>
&lt;p>こういう場合は、カスタムUsernamePasswordAuthenticationFilterクラスを作ってJSONをパースする必要があります。FormLoginを使う場合に比べて少し複雑になりますが、REST APIらしくやってみましょう。FromLoginでの実装ができると、こちらはFilterをもう一つ追加するだけの感覚で実装ができます。&lt;/p>
&lt;h5 id="jsonusernamepasswordauthenticationfilterの作成">JsonUsernamePasswordAuthenticationFilterの作成
&lt;/h5>&lt;p>クレデンシャルを確認するSpringのデフォルトのFilterクラスはUsernamePasswordAuthenticationFilterというもので、これを継承したカスタムクラスを作り、そこからJSONをパースして使うようにします。以下の実装は、FormデータとJSONの両方に対応している例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JsonUsernamePasswordAuthenticationFilter&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> UsernamePasswordAuthenticationFilter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Headerからコンテントタイプを取得するための定数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String CONTENT_TYPE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Content-Type&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// JSONデータを保存するためのMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> jsonRequest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ユーザ名を取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> String &lt;span style="color:#a6e22e">obtainUsername&lt;/span>(HttpServletRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> getParameter(request, getUsernameParameter());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// パスワードを取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> String &lt;span style="color:#a6e22e">obtainPassword&lt;/span>(HttpServletRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> getParameter(request, getPasswordParameter());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// JSONもしくはFormデータのクレデンシャルを取得し、Authenticationとして載せる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Authentication &lt;span style="color:#a6e22e">attemptAuthentication&lt;/span>(HttpServletRequest request, HttpServletResponse response) &lt;span style="color:#66d9ef">throws&lt;/span> AuthenticationException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (headerContentTypeIsJson(request)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ObjectMapper mapper &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ObjectMapper();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">jsonRequest&lt;/span> &lt;span style="color:#f92672">=&lt;/span> mapper.&lt;span style="color:#a6e22e">readValue&lt;/span>(request.&lt;span style="color:#a6e22e">getReader&lt;/span>().&lt;span style="color:#a6e22e">lines&lt;/span>().&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">joining&lt;/span>()),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> TypeReference&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IOException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String username &lt;span style="color:#f92672">=&lt;/span> obtainUsername(request) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> obtainUsername(request) : &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String password &lt;span style="color:#f92672">=&lt;/span> obtainPassword(request) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> obtainPassword(request) : &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UsernamePasswordAuthenticationToken authRequest &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> UsernamePasswordAuthenticationToken(username, password);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setDetails(request, authRequest);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getAuthenticationManager&lt;/span>().&lt;span style="color:#a6e22e">authenticate&lt;/span>(authRequest);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// リクエストからパラメータ(ユーザ名とパスワード)を取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String &lt;span style="color:#a6e22e">getParameter&lt;/span>(HttpServletRequest request, String parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (headerContentTypeIsJson(request)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> jsonRequest.&lt;span style="color:#a6e22e">get&lt;/span>(parameter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> request.&lt;span style="color:#a6e22e">getParameter&lt;/span>(parameter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// HeaderからコンテントタイプがJSONかどうかを判定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">headerContentTypeIsJson&lt;/span>(HttpServletRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> request.&lt;span style="color:#a6e22e">getHeader&lt;/span>(CONTENT_TYPE).&lt;span style="color:#a6e22e">equals&lt;/span>(MediaType.&lt;span style="color:#a6e22e">APPLICATION_JSON_VALUE&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="authenticationsuccesshandlerの作成-1">AuthenticationSuccessHandlerの作成
&lt;/h5>&lt;p>ここはFormLoginの場合と同じです。詳細については&lt;a class="link" href="#AuthenticationSuccessHandler%e3%81%ae%e4%bd%9c%e6%88%90" >こちらを&lt;/a>参考にしてください。&lt;/p>
&lt;h5 id="spring-securityの設定-1">Spring Securityの設定
&lt;/h5>&lt;p>ここでは、作成したカスタムUsernamePasswordAuthenticationFilterにFilterProcessUrlと、AuthenticationManager、AuthenticationSuccessHandlerを設定して、デフォルトのフィルタ設定を変えるようになります。この設定ではFormLoginが要らなくなリます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SecurityConfig&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> WebSecurityConfigurerAdapter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログインが成功した場合の処理のためのHandler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> JWTAuthenticationSuccessHandler successHandler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン以降の認証認可のためのFilter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> JWTAuthenticationFilter filter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">SecurityConfig&lt;/span>(JWTAuthenticationSuccessHandler successHandler, JWTAuthenticationFilter filter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">successHandler&lt;/span> &lt;span style="color:#f92672">=&lt;/span> successHandler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span> &lt;span style="color:#f92672">=&lt;/span> filter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> AuthenticationManager &lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">configure&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> HttpSecurity httpSecurity) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> httpSecurity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">httpBasic&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">csrf&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">sessionManagement&lt;/span>().&lt;span style="color:#a6e22e">sessionCreationPolicy&lt;/span>(SessionCreationPolicy.&lt;span style="color:#a6e22e">STATELESS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// FormLoginは使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">formLogin&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">authorizeRequests&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">anyRequest&lt;/span>().&lt;span style="color:#a6e22e">hasRole&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ROLE_USER&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 認証前にJWTのFilterを設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addFilterBefore&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>, UsernamePasswordAuthenticationFilter.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// UsernamePasswordAuthenticationFilterはカスタムクラスに代替&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addFilterAt&lt;/span>(getJsonUsernamePasswordAuthenticationFilter(), UsernamePasswordAuthenticationFilter.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// カスタムUsernamePasswordAuthenticationFilterの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> JsonUsernamePasswordAuthenticationFilter &lt;span style="color:#a6e22e">getJsonUsernamePasswordAuthenticationFilter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JsonUsernamePasswordAuthenticationFilter jsonFilter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JsonUsernamePasswordAuthenticationFilter();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログインを処理するURLの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonFilter.&lt;span style="color:#a6e22e">setFilterProcessesUrl&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/web/login&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// AuthenticationManagerの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonFilter.&lt;span style="color:#a6e22e">setAuthenticationManager&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// AuthenticationSuccessHandlerの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonFilter.&lt;span style="color:#a6e22e">setAuthenticationSuccessHandler&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">successHandler&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonFilter.&lt;span style="color:#a6e22e">setUsernameParameter&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;id&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jsonFilter.&lt;span style="color:#a6e22e">setPasswordParameter&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;pass&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> jsonFilter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="ログイン用のcontrollerを使う場合">ログイン用のControllerを使う場合
&lt;/h4>&lt;p>他のURLをControllerで制御しているのと同じく、ログイン専用のContollerを作る場合の例です。一般的なControllerとあまり使い方は変わらないので、こちらの方がやりやすい感もしますね。&lt;/p>
&lt;p>また、レスポンスとしてResponseEntityやカスタムクラスも使えるのでHeaderにトークンを載せるだけでなく、Bodyに何かデータを埋めて共に送る必要のある場合はこちらの方が良い選択なのかもしれません。&lt;/p>
&lt;h5 id="controllerの作成">Controllerの作成
&lt;/h5>&lt;p>前述した通り、一般的なREST API用のControllerとあまり変わりないものを作ります。ログインようのURLと、それに紐づくメソッドを作り、ログイン時の認証を担当することになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RestController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RequestMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;api/v1/web&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SignApiController&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クレデンシャルを検証するためのサービスクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> UserService service;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// トークンを作成するためのProvider&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> JWTProvider provider;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">SignApiController&lt;/span>(MemberService service, JWTProvider provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">service&lt;/span> &lt;span style="color:#f92672">=&lt;/span> service;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span> &lt;span style="color:#f92672">=&lt;/span> provider;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Formデータでクレデンシャルをもらい、認証を行う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@PostMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/login&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">login&lt;/span>(&lt;span style="color:#a6e22e">@Validated&lt;/span> &lt;span style="color:#a6e22e">@RequestBody&lt;/span> LoginMemberForm form, HttpServletResponse response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クレデンシャルからユーザ情報を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">service&lt;/span>.&lt;span style="color:#a6e22e">getUser&lt;/span>(form.&lt;span style="color:#a6e22e">getId&lt;/span>(), form.&lt;span style="color:#a6e22e">getPassword&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 取得した情報でトークンを作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String token &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span>.&lt;span style="color:#a6e22e">createToken&lt;/span>(user);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Headerにトークンを作成して載せる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response.&lt;span style="color:#a6e22e">setHeader&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;X-AUTH-TOKEN&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span>.&lt;span style="color:#a6e22e">createToken&lt;/span>(user));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// HTTP Statusは200 OK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response.&lt;span style="color:#a6e22e">setStatus&lt;/span>(HttpStatus.&lt;span style="color:#a6e22e">OK&lt;/span>.&lt;span style="color:#a6e22e">value&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="spring-securityの設定-2">Spring Securityの設定
&lt;/h5>&lt;p>Controllerを使った場合は、認可認可なしでもログイン用のURLにアクセスできる設定と、Filterを使うための設定を追加します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SecurityConfig&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> WebSecurityConfigurerAdapter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン以降の認証認可のためのFilter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> JWTAuthenticationFilter filter;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">SecurityConfig&lt;/span>(JWTAuthenticationFilter filter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">provider&lt;/span> &lt;span style="color:#f92672">=&lt;/span> provider;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> AuthenticationManager &lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">authenticationManagerBean&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">configure&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> HttpSecurity httpSecurity) &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> httpSecurity
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">httpBasic&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">csrf&lt;/span>().&lt;span style="color:#a6e22e">disable&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">sessionManagement&lt;/span>().&lt;span style="color:#a6e22e">sessionCreationPolicy&lt;/span>(SessionCreationPolicy.&lt;span style="color:#a6e22e">STATELESS&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">authorizeRequests&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ログイン処理ようのURLには認証認可なしでアクセスできる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">antMatchers&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1/web/login/&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">permitAll&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">anyRequest&lt;/span>().&lt;span style="color:#a6e22e">hasRole&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ROLE_USER&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// デフォルトのFilter設定を変える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addFilterBefore&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">filter&lt;/span>, UsernamePasswordAuthenticationFilter.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="テスト">テスト
&lt;/h3>&lt;p>今まで実装したログインのテストは、CURLもしくは&lt;a class="link" href="https://www.postman.com" target="_blank" rel="noopener"
>Postman&lt;/a>などのツールで簡単にできます。&lt;/p>
&lt;p>例えば、FormLoginを使った場合のログインはこちらになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -i -X POST &lt;span style="color:#e6db74">&amp;#34;http://localhost:8080/api/v1/web/login&amp;#34;&lt;/span> -d &lt;span style="color:#e6db74">&amp;#34;id=user&amp;#34;&lt;/span> -d &lt;span style="color:#e6db74">&amp;#34;pass=1234&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Postmanを使ったJSONでのログインテストはこちらになります。(X-AUTH-TOKENでJWTが帰ってきたのを確認できます!)&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/spring-rest-api-login-with-jwt/jwt_postman_login.webp"
width="1926"
height="760"
srcset="https://retheviper.github.io/posts/spring-rest-api-login-with-jwt/jwt_postman_login_hu_49703773dba52761.webp 480w, https://retheviper.github.io/posts/spring-rest-api-login-with-jwt/jwt_postman_login_hu_f95e4859ff77c066.webp 1024w"
loading="lazy"
alt="JWT Postman Login"
class="gallery-image"
data-flex-grow="253"
data-flex-basis="608px"
>&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>思ったよりSpring Security周りの設定がいろいろと必要となり、自分の欲しがっていたレクチャはあまりなかったのでかなり苦労しましたが、これでなんとかREST APIでのJWTを使ったログインは実装できました。これだけを別途ライブラリとして作っても良いかと思いますね…&lt;/p>
&lt;p>でも、まだこれで完全な設定ができた訳ではありません。ここではSuccessHandlerのみを作成しましたが、場合によってはログインに失敗した場合の&lt;code>AuthenticationFailureHandler&lt;/code>が必要になる可能性もあります。また、これはあくまでログインに関するポストなので扱ってはなかったのですが、認証認可できてないURLへのアクセスに対するException Handlingも必要です。また、JWTを使った認証の場合、クライアントがトークンを持ってしまうのでサーバ側からログアウトを制御できないという点があり、クライアント側の実装ではそこに対しての対策も考えなければなりません。&lt;/p>
&lt;p>が、今回はとりあえず最小限の目標は達成できたということで、いったんここまでとなります。では、また！&lt;/p></description></item><item><title>REST APIでのログインのためには</title><link>https://retheviper.github.io/posts/spring-rest-api-how-to-login/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-rest-api-how-to-login/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post REST APIでのログインのためには" />&lt;p>新しい案件が始まって、AngularとSpring bootによるSPA(Single Page Application)を作ることとなりましたが、まだ要件定義の段階で実装まではしばらく時間が残っています。いわゆる上流工程にはあまり経験がないので日々奮闘中ではありますが、仕事が終わった後の時間には少しづつ、練習をかねて自作アプリケーションを作っています。&lt;/p>
&lt;p>Spring BootでREST APIを作ることにはある程度慣れてはいるものの、まだ認証/認可に対してあまり知識がないので、自作アプリではわざとSpring Securityを入れることにしました。しかし、Spring Securityの記事をいくつか読んでロールによってアクセスできるURLに制限をかけたりしているのだなと理解した後に、いざ自作アプリケーションに導入してみようとしたら、問題ができました。いつも通りREST APIで実装していたのですが、自分が参考にしていたSpring Securityのコードはほぼ昔ながらのSpring MVCパターンのためのものだったのです。&lt;/p>
&lt;p>なので、今回のポストはSpring MVCパターンとREST APIのログインするため必要となるのが何かについて簡単に書いてみようと思います。(実際のログインの方法は今後のポストを予定しています)``&lt;/p>
&lt;h2 id="コントローラの実装">コントローラの実装
&lt;/h2>&lt;p>まずMVCパターンとREST APIのコントローラをどのように実装するかからみていきましょう。&lt;/p>
&lt;h3 id="mvcパターンの場合">MVCパターンの場合
&lt;/h3>&lt;p>今も多くの研修で行われているSpringの研修は、普通のMVCパターンとJSPによるものが多いのではないか、と思います。例えば&lt;code>@Controller&lt;/code>アノテーションをつけたコントローラクラスに、&lt;code>@RequestMapping&lt;/code>アノテーションをつけたメソッドを書いて、そのメソッドでは&lt;code>Model&lt;/code>もしくは&lt;code>ModelAndView&lt;/code>などのクラスを使ってデータやビュー(主にJSPファイルのパス)を書いていくような形ですね。実際は&lt;code>JSPを使う=MVCパターン&lt;/code>というわけでもないですが、多くのSpring MVCパターンのプロジェクトがJSPを使っているのでまずはこのようなレガシーなものをMVCパターンと呼ばせていただきます。&lt;/p>
&lt;p>ただ文章で表現するよりは、コードを持って書いた方がわかりやすいと思います。例えば以下のようなものです。&lt;code>/home&lt;/code>というURLに接続すると、サーバの時間を返す簡単な例題ですね。ModelAndViewを使うとしても、Modelにデータとビューを共につめてるだけでやっていることとしてはあまり変わらないと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Controller&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HomeController&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// homeというJSPファイルとサーバの時間を表示する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@RequestMapping&lt;/span>(value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/home&amp;#34;&lt;/span>, method &lt;span style="color:#f92672">=&lt;/span> RequestMethod.&lt;span style="color:#a6e22e">GET&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">home&lt;/span>(Model model) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Date date &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> model.&lt;span style="color:#a6e22e">addAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;serverTime&amp;#34;&lt;/span>, date);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;home&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="rest-apiの場合">REST APIの場合
&lt;/h3>&lt;p>自分の場合も、やはり最初はSpring MVCパターンとJSPから学んだのでこのような書き方に慣れていましたが、入社後にはSpring BootとREST APIというものに出会い、コードの書き方が少し変わりました。最近のトレンドだとやはりJSPよりもAngular/React/VueなどのJavaScriptフレームワークを使って作成する場合が多いので、JSONの形としてデータだけを返したらよくなります。JSONとしてデータをレスポンスボディに載せるには、普通にDTOクラスをビューモデルとして作ります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HomeViewModel&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Serializble {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// サーバの時間を表示する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Date serverTime;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは、&lt;code>@RestController&lt;/code>アノテーションをつけたコントローラクラスを作り、作成したDTOクラスを返すメソッドを作成するだけです。少しアノテーションの種類や使い方も少し変わりましたが、内容としてはビューを担当しているJSPファイルの指定が消えただけで返しているデータは同じです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RestController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RequestMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api/v1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HomeApiController&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// カスタムビューモデルにデータをつめて渡す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@GetMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/home&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> HomeViewModel &lt;span style="color:#a6e22e">getHome&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HomeViewModel model &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HomeViewModel();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> model.&lt;span style="color:#a6e22e">setServerTime&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> Date());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> model;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてフロントエンドのJavaScriptフレームワークでは、レスポンスのボディから取得して画面に表示するようになりますね。このようにREST APIだと、サーバサイドではあくまでデータモデルとビジネスロジックだけを考えれば良いようになっていて、よりそれぞれの役割の分担がよくなっていますね。&lt;/p>
&lt;h2 id="ログインをするには">ログインをするには
&lt;/h2>&lt;p>では、とりあえず簡単にSpring MVCパターンとREST APIの比較をしてみたので本題に戻りましょう。先にSpring Securityの話をしましたが、実際はSpring Securityを導入しなくても同じ話になると思います。REST APIはアーキテクチャの一つにすぎないので、フレームワークを導入できるかどうかの問題はすでに別の話になってしまいます。また、ログインというのはSpring Security以前の問題です。なので今回はSpring Securityの話はさておき、二つのアーキテクチャでどのようにログインをするかについて話したいと思います。&lt;/p>
&lt;h3 id="mvcパターン">MVCパターン
&lt;/h3>&lt;p>MVCパターンでは、Sessionでログインを実現する場合が多い(と思い)ます。例えばログインを担当するメソッドを作成して、引数として&lt;code>HttpServletRequest&lt;/code>を指定すると、そこからセッションを取得することができますね。あとは、またの引数としてFormのデータ(IDとパスワード)を受けて、これは自分が最初に学んだ方式でもあります。&lt;/p>
&lt;p>まずユーザの観点から話してみましょう。普通のWebアプリケーションでは、画面のほうでログインのためにIDとパスワードを入力するようになります。JSPではそのデータを&lt;code>form&lt;/code>として受け取り、POSTとしてコントローラに送りますね。そうしたらコントローラではIDとパスワードをServiceクラスに送って検証してもらい、問題なかったらログインした情報をSessionに載せます。こういうったシナリオで、コントローラにログインのためのメソッドを作るとおそらく以下のコードのような形のなるはずです。(実際はユーザのIDだけ載せる場合はないので参考までに)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// URLは/login、メソッドはPOST&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RequestMapping&lt;/span>(value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/login&amp;#34;&lt;/span>, method &lt;span style="color:#f92672">=&lt;/span> RequestMethod.&lt;span style="color:#a6e22e">POST&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">login&lt;/span>(User user, HttpServletRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Serviceからユーザを取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User loginedUser &lt;span style="color:#f92672">=&lt;/span> service.&lt;span style="color:#a6e22e">getUser&lt;/span>(user.&lt;span style="color:#a6e22e">getId&lt;/span>(), user.&lt;span style="color:#a6e22e">getPassword&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// リクエストからセッションを取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpSession session &lt;span style="color:#f92672">=&lt;/span> request.&lt;span style="color:#a6e22e">getSession&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// SessionにユーザIDを載せる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> session.&lt;span style="color:#a6e22e">setAttribute&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;userId&amp;#34;&lt;/span>, loginedUser.&lt;span style="color:#a6e22e">getId&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでログインができたら、あとは他のメソッドでSessionの検証をして、ログインされているかどうかを判断することになります。ログアウトする場合は、Sessionを破棄すればいいです。例えば以下のようになりましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// URLは/logout、メソッドはGet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@RequestMapping&lt;/span>(value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/logout&amp;#34;&lt;/span>, method &lt;span style="color:#f92672">=&lt;/span> RequestMethod.&lt;span style="color:#a6e22e">GET&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">logout&lt;/span>(HttpServletRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// リクエストからセッションを取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpSession session &lt;span style="color:#f92672">=&lt;/span> request.&lt;span style="color:#a6e22e">getSession&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Sessionを破棄する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> session.&lt;span style="color:#a6e22e">invalidate&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Spring Securityを使った場合はかなりコードが変わってきますが、Sessionを使う場合にこう言った基本的なフローは変わりませんね。これでMVCパターンでの認証/認可は実現できます。&lt;/p>
&lt;h2 id="ここで問題が">ここで問題が
&lt;/h2>&lt;p>しかし、Sessionを使った方法はREST APIだと使えなくなります。なぜかというと、REST APIの最大の特徴の一つは&lt;code>Stateless&lt;/code>、つまり&lt;code>状態を持たない&lt;/code>というのであるからです。ここでいう状態というのはサーバに取ってのクライアントのステータスのことです。今まで通りだとクライアントはサーバに接続した瞬間からサーバに自分の状態を管理させる必要がありました。こういう状態を管理するためのものがSessionであり、先に説明した通りだとREST APIには適用すべきではないですね。(無理やり適用させるとしたら不可能でもないですが…)&lt;/p>
&lt;p>そしてStatelessである故に、REST APIではクライアントのリクエスト毎にクライアントから必要な全ての情報をサーバに送るようにしています。ここから推論できるのはSessionでログインの情報を載せておくのではなく、クライアントからリクエスト毎に自分はログインしているということを証明するデータを何かの形で送る必要があるということになります。&lt;/p>
&lt;h3 id="ではどうしたら">ではどうしたら？
&lt;/h3>&lt;p>クライアントがリクエスト毎に、本質的なデータのみでなく、認証のためのデータを送るための手段は、すでにHTTPの中にありました。つまり、Headerです。クライアントのリクエストには操作のためのデータがBodyとして入っていて、そこに認証のための情報をHeaderとして載せればいいですね。&lt;/p>
&lt;p>クライアントがHeaderに認証のための情報を載せるには、まずサーバサイドから認証をしてもらわねばなりません。この認証の詳細については今後のポストで話すことにして、まずはHeaderに載せるデータが完成されたと仮定し、これをサーバのレスポンスでどう返すかについて述べます。&lt;/p>
&lt;p>Spring BootでレスポンスのHeaderにデータを載せるためには二つの方法があります。先に述べたSpring MVCのリクエスト同様、レスポンスを扱うためのクラスである&lt;code>HttpServletResponse&lt;/code>を使う方法と、&lt;code>ResponseEntity&lt;/code>でレスポンスデータをラッピングすることです。どれも使える方法ですが、&lt;/p>
&lt;h2 id="httpservletresponseでheaderを追加する">HttpServletResponseでHeaderを追加する
&lt;/h2>&lt;p>まずはHttpServletResponseです。シンプルに、「レスポンスにデータを載せたい」という時に使える方法ですね。MVCパターンでのログインと同じく、ログインするメソッドの引数に指定すると、レスポンスのHeaderにデータを載せることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@PostMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/login&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> User &lt;span style="color:#a6e22e">login&lt;/span>(User user, HttpServletResponse response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Serviceからユーザを取得する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User loginedUser &lt;span style="color:#f92672">=&lt;/span> service.&lt;span style="color:#a6e22e">getUser&lt;/span>(user.&lt;span style="color:#a6e22e">getId&lt;/span>(), user.&lt;span style="color:#a6e22e">getPassword&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンスのHeaderにユーザのIDを載せる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response.&lt;span style="color:#a6e22e">addHeader&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;userId&amp;#34;&lt;/span>, loginedUser.&lt;span style="color:#a6e22e">getId&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Bodyを返す(Headerは自動で含まれる)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> loginedMember;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="responseentityでheaderを追加する">ResponseEntityでHeaderを追加する
&lt;/h2>&lt;p>もう一つの方法であるResponseEntityの場合は、引数はユーザ情報(IDとパスワード)のみで良くなります。名前からもわかると思いますが、ResponseEntityはBodyとHeaderを含め、HTTP Status(200 OKなど)を含めレスポンスに必要な情報は全て扱えるクラスです。使い方は簡単で、ログインメソッドの戻り値となるBodyをResponseEntityで包み、Headerなどの情報も一緒に詰めて返します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@PostMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/login&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> ResponseEntity&lt;span style="color:#f92672">&amp;lt;&lt;/span>Member&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">login&lt;/span>(User user) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User loginedUser &lt;span style="color:#f92672">=&lt;/span> service.&lt;span style="color:#a6e22e">getUser&lt;/span>(user.&lt;span style="color:#a6e22e">getId&lt;/span>(), user.&lt;span style="color:#a6e22e">getPassword&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンスとしてHeaderとBodyを一緒にセットして返す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ResponseEntity.&lt;span style="color:#a6e22e">ok&lt;/span>().&lt;span style="color:#a6e22e">header&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;userId&amp;#34;&lt;/span>, loginedUser.&lt;span style="color:#a6e22e">getId&lt;/span>()).&lt;span style="color:#a6e22e">body&lt;/span>(loginedUser);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="そのあとは">そのあとは？
&lt;/h2>&lt;p>レスポンスのHeaderに載せた情報は、フロントエンド側でリクエスト毎にHeaderに載せて送ることになります。しかし、リクエスト毎に送るためにはどこかにこの情報を保存する必要がありますね。Cookieを使う方法もありますが、セキュリティ情のリスクがあるため多くの場合ではブラウザのローカルストレージに保存するようになっているようです。これはフロントエンドの領域なので、ここでは深掘りしません。&lt;/p>
&lt;p>また、ログアウトの場合はどうなるか、という問題もありますが、これは様々な方法で実現しているようです。例えばフロントエンドからできる方法としては、Headerに載せる認証情報を削除したり、間違った情報を送るようにするような方法があります。そしてサーバサイドでは、一定時間がすぎると認証情報を使えなくするなどの対策があります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>本当は、REST APIでのログインに関してはまだ考えなければならないことは他にもあります。例えば、HTTP Headerに認証のため必要となる情報を載せるということは理解できても、実際はどのようなデータを載せればいいか、そのデータはどう作るか、リクエスト毎にHeaderで認証情報を扱うということはセキュリティやリソースの面で大丈夫かなど。&lt;/p>
&lt;p>でも、とにかくこれでREST APIでログインするための仕組みの一つはわかりました。次回は、このHeaderとSpring Securityを使ってのログインを実装する方法を述べながら、以上の問題についても扱いたいなと思っています。では、また！&lt;/p></description></item><item><title>JavaプログラマーがみたTypeScript</title><link>https://retheviper.github.io/posts/typescript-first-impression/</link><pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/typescript-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/typescript.webp" alt="Featured image of post JavaプログラマーがみたTypeScript" />&lt;p>このたびは、新しい案件で&lt;a class="link" href="https://angular.io" target="_blank" rel="noopener"
>Angular&lt;/a>とSpring BootによるWebアプリケーションの開発を担当することになりました。Spring Bootは今までずっとやってきているのであまり問題はないと思いますが、問題はAngularです。Angularはバージョン2からTypeScriptを使うことになっているらしく、JavaScriptとjQueryを少し触ったくらいの経験しかないのでそもそもTypeScriptがどんなものかすら知らなかったです。ただわかっているのは、JavaやC#みたいに静的言語みたくコードを書いたら、それをいい感じにコンパイルしてJavaScriptに変えてくれる、ということだけでした。&lt;/p>
&lt;p>なのでまずTypeScriptの勉強を始めましたが、言語そのものの特徴に含め、TypeScriptで何かを作る時に必要となる知識は意外と大きいことに気付きました。今回のポストでは正直な感想と、どんなものが必要なのかをJavaしか知らない初心者である自分の観点から述べていきたいと思います。&lt;/p>
&lt;h2 id="驚くほどjavaに似ている">驚くほどJavaに似ている
&lt;/h2>&lt;p>元々C/C++、C#、JavaといったいわゆるC-family言語と似ているとの話は聞いていましたが、実際TypeScriptを触ってみると本当にそうでした。最初、なんの情報もなかった時(型を指定できて、コンパイルしたらJavaScriptに変わるという話だけ聞いている時)、ただ普通の変数の宣言に型指定ができるようになっているだけかと思っていたのですが、それだけでなく意外とオブジェクト指向に合わせて発展、もしくは回帰している印象を受けました。&lt;/p>
&lt;h3 id="型指定はいい感じ">型指定はいい感じ
&lt;/h3>&lt;p>型の指定は、元々動的言語であるJavaScriptを昔ながらの静的言語化するものですね。でも、書き方自体は昔のままでなく、KotlinやSwiftのようなモダンな言語に似ています。型をまず書くのではなく、変数として宣言したあとに型をつける&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>のですね。例えば以下のようになります。&lt;/p>
&lt;p>Javaでの型指定&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> 1000;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>TypeScriptの型指定&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>: &lt;span style="color:#66d9ef">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、こういう型指定を、TypeScriptでは「型注釈」とも呼ぶらしいです。TypeScriptはコンパイルされたらランタイムで型が決まるJavaScriptになるので、コンパイラーのために注釈をつけてあげる、という意味に近いようです。&lt;/p>
&lt;h3 id="型以外の類似点">型以外の類似点
&lt;/h3>&lt;p>TypeScriptには型指定だけでなく、C#やJavaプログラマーならすでに慣れているAccess修飾子、Interface、Class、Generics、Decorator(Annotation)なども用意されています。これらの一部は最近JavaScriptでも対応している機能ではありますが、実際のアプリを開発する業務ではブラウザの制約から最新のJavaScriptを使えない場合もあり不便ですね。しかし、TypeScriptを使うとコンパイラのオプションを指定することでどのバージョンのJavaScriptとしてソースコードを出力するか選択できるので、ブラウザをあまり気にせず同じコードを書けます。これは本当にありがたいですね。&lt;/p>
&lt;p>他に、依存関係をnpmといったパッケージマネージャで管理できるというのも良いところ。これはJavaScriptでもできる(というか、そちらが先ですが)ことですが、Importと組み合わせたらほぼC-familyと似たような感覚で運用できるという面が良いですね。JavaScriptのモジュールというのも、またES6から対応しているのでそれ以前のバージョンを使う場合だとかなり面倒くなるかも知れない、と思いました。知識不足なだけかもしれませんが…&lt;/p>
&lt;h2 id="気になったところ">気になったところ
&lt;/h2>&lt;p>TypeScriptの良いところは、やはり昔ながらの言語に慣れている人にはかなり快適にコードをかけるような環境を提供していて、コンパイルタイムでエラーを探せるという、その何ふさわしいものとなっている点だと思います。ただ、少し気になったところもあったのでそれについても書きます。&lt;/p>
&lt;h3 id="結局はjavascript">結局はJavaScript
&lt;/h3>&lt;p>TypeScriptはJavaScriptのSuper setなので、JavaScriptの機能をそのまま利用できるというのが特徴だとも言われています。最初はそれをメリットとして捉えていましたが、勉強をしながらやはりデメリットもあるんだなと感じました。JavaScriptをそのままかけるということは、結局言い方を変えると、ソースコードの中にJavaScript(Vanilla)とTypeScriptが混在していても問題なくなるということですね。こうなった場合にTypeScriptがSuper setという特徴を諦めないかぎりコードが動かなくなることはないと思いますが、人の観点からするとかなり混乱するコードが生まれる可能性もあるのではないかと思いますね。&lt;/p>
&lt;h4 id="javascriptでも書けるということの意味">JavaScriptでも書けるということの意味
&lt;/h4>&lt;p>そもそもJavaScriptの歴史の方が長く、ユーザも絶対的にJavaScriptの方が多いです。そして、私みたいにC-family言語ではなくJavaScriptからプログラミングに入門した人もいるので、そのような人にとってTypeScriptはあえて使うメリットのない、ただの不便なものにしか思われない可能性もあると思います。また、JavaScriptの方に慣れている人がTypeScriptに移ったとしても、結局はJavaScriptと変わらない書き方になる可能性もなくはないはずですね。&lt;/p>
&lt;p>TypeScriptがSuper setとして企画された理由は、既存のJavaScriptプログラマーを吸収するための政策だったと思いますが、プログラミング言語は自由が多いほど混乱しやすいと思うので、これはやはりメリットでもデメリットでもあると思いました。&lt;/p>
&lt;h4 id="prototype">prototype
&lt;/h4>&lt;p>クラス基盤のオブジェクト指向言語から入門しているからか、自分にはJavaScriptの&lt;code>prototype&lt;/code>という概念があまりわかってないです。ともかくJavaScriptにはこのprototypeというのがあって、オブジェクトを変数として使うこともできるという特徴を持っていますね&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。Javaプログラマーとしてはオブジェクトはクラス、クラスはファイル一つ、という風に考えることが一般的なので、こういう自由度に触れるとどうしたらいいか混乱しそうな感覚です。そしてもちろん、これはTypeScriptよりもJavaScriptの特徴ではありますが、TypeScriptがSuper setである以上避けられない問題なのですね。&lt;/p>
&lt;h4 id="module">Module
&lt;/h4>&lt;p>モジュールがJavaScriptに導入されて、TypeScriptでももちろんそのまま使えます。個別のファイルにクラスを一つづつ作成して、インポートして使っているとまるでJavaと大差ないようにも思われますね。でもこのモジュールというものも実際はややこしいところがあるようで、書き方をどうするか考えなくてはならない場合もあるようです。&lt;/p>
&lt;p>例えばPythonのように&lt;code>as&lt;/code>を入れることでインポートしたモジュールに別名をつけることができるけど、そうしたら問題が怒るケースもあるとか、CORS設定で塞がる場合もあるとかというのが最初はかなり複雑だなと感じました。まだ深堀りしてないので実際は使ってみないとわからないと思いますが、そもそも使ってみないとわからないという部分はやはり気になりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 二つの書き方ができるが、一緒ではない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#a6e22e">express&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;express&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#a6e22e">express&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;express&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="コンパイル">コンパイル
&lt;/h4>&lt;p>TypeScriptをインストールすると、ターミナルから&lt;code>tsc&lt;/code>というコマンドを使えるようになります。そしてTypeScriptで作成したファイルは&lt;code>.ts&lt;/code>というファイルに書いて、tscコマンドで&lt;code>.js&lt;/code>に変わりますね。&lt;code>tsconfig.json&lt;/code>ファイルを定義することでどうコンパイルするか様々なオプションを指定することもできます。例えばJavaScriptにコンパイルする時、どんなバージョンでコンパイルするか、どのファイルをコンパイルするか、&lt;code>.js&lt;/code>ファイルはどこに吐き出すかなど。&lt;/p>
&lt;p>ただ、コンパイルにかなり時間がかかるのもあり、コンパイルされたファイルは結局JavaScriptになります&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>。そしてこれは、TypeScriptで作成しても「ランタイムでは弱タイプになる」ということを意味しますね。ちゃんとタイプを明示して(&lt;code>any&lt;/code>を使わず)コードを作成しただけでは不十分なケースが十分あり得るので、ランタイムでも型による問題が起こらないようにする必要性があるかも知れないという印象を受けました。&lt;/p>
&lt;p>最近はnpmの代替ランタイムとしてTypeScriptをそのまま使える&lt;a class="link" href="https://deno.land" target="_blank" rel="noopener"
>Deno&lt;/a>のようなものも登場していますが、やはり内部的にはtscを使っているらしく、このコンパイル速度が遅いのが最大の問題として挙げられていました。Rustで新しいコンパイラを作成しているとのことですが、それがいつ完成されるかもわからないですね。&lt;/p>
&lt;p>そしてtscのみでなく、&lt;a class="link" href="https://webpack.js.org" target="_blank" rel="noopener"
>webpack&lt;/a>を使う場合はts-loaderを使ったりするとかなり初期設定が複雑な印象を受けました。他に&lt;a class="link" href="https://babeljs.io" target="_blank" rel="noopener"
>Babel&lt;/a>などを使う場合もあるらしいですが、コンパイルをするためという理由でこのようなベンドラやコンパイラをまた勉強しなくてはならないというのは少し不便な部分ですね。JavaScriptと紐付けられている言語としての運命みたいなものかもしれませんが…&lt;/p>
&lt;h2 id="すっきりしたところ">すっきりしたところ
&lt;/h2>&lt;h3 id="javascriptライブラリを使える">JavaScriptライブラリを使える
&lt;/h3>&lt;p>「TypeScriptではJavaScriptのライブラリも使える」という話も聞きましたが、実際それがどうやって可能になったのかが疑問でした。例えばTypeScriptにも型推論があってある程度、型を宣言しなくても良い場合はあるものの、基本的には型注釈で明示的に型を指定してあげないとうまくコンパイルできない部分もありますね。しかし、すでに存在しているJavaScriptのライブラリ全てがTypeScriptを考慮して作られているとは考えられないので、これをTypeScriptではどのような形で対応しているかが一番の疑問でした。&lt;/p>
&lt;p>答えは意外と簡単で、&lt;code>.d.ts&lt;/code>という形で「型定義ファイル」を作成すると良い、ということでした。すでにTypeScriptに対応しているライブラリの場合もこの型定義ファイルによってTypeScriptが型を参照できるようにしていて、自作することも可能。そしてメジャーなものの場合、&lt;code>node_modules&lt;/code>にインストールできる形で型定義ファイルを提供している場合もありました。&lt;/p>
&lt;p>すでに作成されている型定義ファイルのインストールも簡単で、例えばnodeのTypeScript型定義が必要な場合は&lt;code>npm install --save-dev @types/node&lt;/code>のようにコマンド一つでインストールができて、GitHubの&lt;a class="link" href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener"
>リポジトリ&lt;/a>を参照するとどんなライブラリの型定義ファイルが提供されているか確認することもできました。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>まだ色々気になるところはありますが、多くはTypeScriptそのものというよりもJavaScriptの特性から起因しているものが多いため、現時点でフロントエンドエンジニアがどの言語を選択すべきかというと、やはりTypeScriptの方が良いのではないかと思いました。もちろん、これは自分のスタートがJavaであることもあるとは思いますが、やはりコンパイルタイムで多くの問題を事前にキャッチできるというメリットは捨てがたいものだと思っています。&lt;/p>
&lt;p>現在はJavaScriptとの互換性のために色々初期設定など煩雑だったりコンパイルに時間がかかるなどの問題もいくつかありますが、これらもAngularみたいに最初からTypeScriptを前提に作られるフレームワークやライブラリが増えたり、ブラウザからTypeScriptに対応したり(これは可能性が低いかな…)したら自然に解決される問題ではないかとも思いますね。&lt;/p>
&lt;p>最初は単純にAngularを使うために勉強したものの、意外としっかりしていて、これからの未来もかなり明るい感じだったのでエンジニアの皆さんにもぜひお勧めしたいと思っているところです。&lt;/p>
&lt;p>ああ、Pythonも型指定できるようになるといいな…&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>もちろん、最近はC#もJavaも&lt;code>var&lt;/code>で変数を宣言することもできますが、習慣もあり、元々静的言語では型から書いた方が良いのではないかと個人的には思っています。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>しかも、ES6で登場したClassは結局プロトタイプ基盤の&lt;code>function&lt;/code>の書き方をちょっと変えただけなのですね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>Javaのようにバイトコードに変わったり、Cのように機械語に変わるようなものとは少し違うのでTypeScriptのコンパイルは&lt;code>トランスパイル&lt;/code>とも呼ぶらしいです。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>知識不足でした！Pythonも3.6から型の宣言ができるようになっています。&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>ブログ刷新</title><link>https://retheviper.github.io/posts/renew-blog-theme/</link><pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/renew-blog-theme/</guid><description>&lt;img src="https://retheviper.github.io/images/tools.webp" alt="Featured image of post ブログ刷新" />&lt;p>この度は、ブログのテーマを新しく変えてみました。新しいテーマは&lt;a class="link" href="https://github.com/Simpleyyt/jekyll-theme-next" target="_blank" rel="noopener"
>NexT&lt;/a>です。一年がたってもあまりJekyllに慣れてないので思ったより苦労していますが(特に消えたページなどが気になります…)、それでも前のテーマと比べてかなりすっきりした感じが良いと思います。検索機能もついていたのでとりあえずアクティベートしてみましたが、ローカルでは機能してなかったのでGithub Pagesにあげてからテストですね。なるべく使いたい。(追記：残念ながら何かのバグのようで使えませんでした…)&lt;/p>
&lt;p>このブログを作ってからも1年が立ちます。最初のポストが1年前だったのですね。あの頃は入社したばかりの新人だったのでいろいろとわからない物だらけでした。なので書いていたポストの内容もいまいちな物が多かったと思います。最近はJavaを使っていろいろと開発はしているものの、あまり経歴が長いわけでもないので当時書いたポストをみているとなぜこのような恥ずかしいものを書いたんだろう、とも思います。&lt;/p>
&lt;p>それでもブログの更新を続けているのは、このブログが自分の勉強の記録であって、過去の自分が書いたコードや文面を振り返ってみることで新しい発見ができていたからです。時々過去のポストを振り返ってみることで同じことをしてもより良い方法、より安全な方法を探すことができました。修正したいものもかなり多いのですが、のちにそれを補えるようなポストを書いた方が自分のエンジニアとしての軌跡をちゃんと追える手段となるのではないかと思います。&lt;/p>
&lt;p>誰かに見せるにはかなり恥ずかしいブログですが、それでも訪問してくださる方々も増えました。おそらく私みたいに、何らかの問題と遭遇していたり他の誰かはどんな解決策を見つけたんだろうという好奇心から検索してみたりしている方々ではないかと思います。自分のコードや知識も正解とは言い切れないものなので、このブログを参考にしてくださいとおすすめはできませんが、エンジニアの仲間の一人として、こういう答えを探し出していたのでだなと受け止められれば幸いです。&lt;/p>
&lt;p>では、また何か勉強ができたら、ポストにてお伺いしましょう。これからもよろしくお願いします。&lt;/p></description></item><item><title>条件で動作するアノテーションを使う</title><link>https://retheviper.github.io/posts/spring-conditional/</link><pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-conditional/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post 条件で動作するアノテーションを使う" />&lt;p>アノテーションは普通のJavaでも使えるもので、様々なライブラリやフレームワークでは積極活用していますね。中でも、最もアノテーションを有効活用しているのはSpringではないかと思います。DIをするためでも、クラスの位置付けにも、なんでもアノテーションをつけることで簡単に定義できるようにしているからです。なのでSpringでWebアプリケーションを実装するときはどんなアノテーションがあるのかを調べてみるのが重要と思います。&lt;/p>
&lt;p>なぜこのような話をするかというと、実は&lt;a class="link" href="../spring-switching-service" >前回のポスト&lt;/a>でServiceを切り替える方法について説明しましたが、他に方法がないか探していたところ、Springならアノテーションでも条件によってBeanやConfigurationを登録する方法があるということをわかったからです。&lt;/p>
&lt;p>また、その条件によって様々なアノテーションが存在していたため、それらの勉強をかねて、今回は様々な条件と場合を想定して作られたSpringのアノテーションについて紹介したいと思います。これらのアノテーションはSpringのauto-configurationに属するものらしいです。Spring Bootではすでに多くの設定が自動化されていますが、これをカスタムして使えるようにアノテーションを提供しているということですね。&lt;/p>
&lt;p>※これらを全部試してみたわけではないですが、とりあえずはご紹介まで。&lt;/p>
&lt;h2 id="条件でdiする">条件でDIする
&lt;/h2>&lt;p>以前のポストで紹介したコートから始めます。以下のようなことをすれば、application.ymlに記載した値によりどのリポジトリをDIするか決定できるという話をしました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SomeServiceConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// YAMLに設定した値を読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Value&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;${settings.TestMode:false}&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> testMode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// YAMLの設定からどのImplクラスを使うかを決定してBean登録&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> SomeService &lt;span style="color:#a6e22e">someService&lt;/span>(SomeRepository repository, SomeTestRepository testRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">testMode&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SomeTestSerivce(testRepository) : &lt;span style="color:#66d9ef">new&lt;/span> SomeServiceImple(repository);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じようなことを、これから紹介するSpringのアノテーションで実装するとしたら、以下のように変わります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SomeServiceConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 本番用のサービスクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@ConditionalOnProperty&lt;/span>(value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;settings.Testmode&amp;#34;&lt;/span>, havingValue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;false&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> SomeService &lt;span style="color:#a6e22e">someService&lt;/span>(SomeRepository repository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SomeServiceImple(repository);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テスト用のサービスクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@ConditionalOnProperty&lt;/span>(value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;settings.Testmode&amp;#34;&lt;/span>, havingValue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> SomeService &lt;span style="color:#a6e22e">someTestService&lt;/span>(SomeTestRepository testRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SomeTestService();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のコードからわかるように、&lt;code>@ConditionalOnProperty&lt;/code>というアノテーションを使うと、とある条件によりメソッドの内容が実行されるようにすることができるようになります。わざわざ分岐を書いたり、カスタムな&lt;code>@Value&lt;/code>アノテーションを用意するよりかなりすっきりしたコードになりますね。&lt;/p>
&lt;p>また、このアノテーションはBeanアノテーションとだけ組み合わせができるわけでもないです。他のSpringのクラスアノテーション(Configuration、Component、Service、Repository、Controller)にも使えるので、より自由度が高いですね。&lt;/p>
&lt;p>他にもSpring Bootのorg.springframework.boot.autoconfigure.conditionパッケージにはには&lt;code>@Conditional...&lt;/code>といったアノテーションがいくつか用意されていて、これらを簡単に紹介したいと思います。&lt;/p>
&lt;h2 id="定義済みのconditionalアノテーション">定義済みのConditionalアノテーション
&lt;/h2>&lt;h3 id="conditionalonproperty">ConditionalOnProperty
&lt;/h3>&lt;p>application.ymlなど、プロパティを書いたファイルやシステムプロパティに、指定したアノテーションがある場合実行されるアノテーションです。Spring Bootアプリケーションで最も一般的に使われるものらしいですね。括弧の中にはプロパティ名と値、そしてそのプロパティが存在しない場合も実行するかどうかを指定できます。&lt;/p>
&lt;p>以下のコードは、use.testmodeというプロパティが存在していて、かつtrueの場合に実行されるConfigurationクラスの例です。matchIfMissingをtrueに指定すると、use.testmodeというプロパティが存在しなくても実行されるようになります。もちろん指定しなかった場合のデフォルト値はfalseとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConditionalOnProperty&lt;/span>(value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;use.testmode&amp;#34;&lt;/span>, havingValue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>, matchIfMissing &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TestConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テストモードで使うConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="conditionalonexpression">ConditionalOnExpression
&lt;/h3>&lt;p>プロパティの記述方法による実行というアノテーションです。括弧で条件を指定できます。ここでいう条件(表現式)は、Valueアノテーションなどでも使われる&lt;a class="link" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions" target="_blank" rel="noopener"
>SpEL&lt;/a>を使います。application.ymlなどに記載したプロパティが、括弧の中の条件と一致する場合に実行されますね。以下のコードはuse.testmodeとuse.submodeのどちらもtrueの場合に実行される例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConditionalOnExpression&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;${use.testmode:true} and ${use.submode:true}&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TestSubConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テストモード及びサブモードの両方がtrueの場合に使うConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="conditionalonbean">ConditionalOnBean
&lt;/h3>&lt;p>指定したBeanが存在する場合に実行というアノテーションです。括弧の中にBeanとして登録されているかどうか判定したいクラスを指定するだけで使えます。ConditionalOnPropertyでとあるBeanが登録されたら、それに合わせて必要なサブモジュール的なものも登録したい、といった場合に使えるのかなと思います。以下のコードは、TestRepositoryというクラスがBeanとして登録されている場合に実行される例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConditionalOnBean&lt;/span>(TestRepository.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TestBeanConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テスト用のBeanが登録された場合に使うConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="conditionalonmissingbean">ConditionalOnMissingBean
&lt;/h3>&lt;p>ConditionalOnBeanとは逆のものです。こちらは、指定したクラスがBeanとして登録されてない場合に実行というものとなります。以下のコードは、RepositoryがBeanとして登録されてない場合は自動的にTestRepositoryをBeanとして登録する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AlternativeConfigutration&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@ConditionalOnMissingBean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Repository &lt;span style="color:#a6e22e">testRepository&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TestRepository();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="conditionalonresource">ConditionalOnResource
&lt;/h3>&lt;p>リソースファイルが存在する場合に実行するというアノテーションです。例えばLogBackを使う場合、xmlファイルが必要となりますが、そのxmlファイルが存在する場合はConfigurationも実行するという構成にしたい場合に使えますね。以下のコードは、そのような場合の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConditionalOnResource&lt;/span>(resources &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/logback.xml&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LogbackConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// リソースフォルダにlogback.xmlが存在する場合に使うConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="conditionalonclass">ConditionalOnClass
&lt;/h3>&lt;p>指定したクラスが存在する場合に実行するというアノテーションです。ConditionalOnBeanと似ていますが、こちらはBeanではなくても良いという違いがありますね。例えば依存関係でとあるライブラリがあるかどうかで使えると思います。以下のコードはcom.custom.library.moduleパッケージのSomeClassというクラスが存在する場合に実行される例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConditionalOnClass&lt;/span>(name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;com.custom.library.module.SomeClass&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CustomLibraryConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// カスタムライブラリのSomeClassがある場合使うConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="conditionalonmissingclass">ConditionalOnMissingClass
&lt;/h3>&lt;p>ConditionalOnClassの逆の場合のアノテーションです。こちらはConditionalOnMissingBeanと似ていますね。同じく、指定するクラスはBeanでなくても良いです。以下のコードは、上のConditionalOnClassの逆の場合の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConditionalOnMissingClass&lt;/span>(name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;com.custom.library.module.SomeClass&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">NoCustomLibraryConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// カスタムライブラリのSomeClassがない場合使うConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="conditionalonjava">ConditionalOnJava
&lt;/h3>&lt;p>アプリケーションがJavaのどのバージョンで実行されているかのによるアノテーションです。JavaのバージョンによってAPIの仕様が変わる場合があるので、複数の環境でアプリケーションを実行する必要がある場合は使うことを考えられますね。以下のコードは、Javaのバージョンが1.8の場合の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConditionalOnJava&lt;/span>(JavaVersion.&lt;span style="color:#a6e22e">EIGHT&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JavaEightConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Javaのバージョンが1.8の場合に使うConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="カスタムcondition">カスタムCondition
&lt;/h2>&lt;p>Conditionインタフェースを実装することで、カスタムConditionを作ることもできます。例えば以下のコードのように、アプリケーションが実行されるOSがLinuxの場合のConditionを自作することができます。&lt;/p>
&lt;p>使い方は簡単で、戻り値がbooleanであるmatchesを実装するだけです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OnUnixCondition&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Condition {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// OSがLinuxかどうかを判定するConditionとなる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>(ConditionContext context, AnnotatedTypeMetadata metadata) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> SystemUtils.&lt;span style="color:#a6e22e">IS_OS_LINUX&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実装したConditionは、Conditionalアノテーションに指定して使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OsConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// LinuxではBeanが登録される&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Conditional&lt;/span>(OnUnixCondition.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> UnixBean &lt;span style="color:#a6e22e">unixBean&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> UnixBean();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AnyNestConditionクラスを継承すると、より複雑な条件の指定ができます。上で実装したOnUnixCondition以外でも、Windowsで実行されているかどうかを判定するOnWindwosConditionクラスを実装したとしましょう。そういった場合は、以下のように実装することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OnWindowsOrUnixCondition&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> AnyNestedCondition {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OnWindowsOrUnixCondition() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>(ConfigurationPhase.&lt;span style="color:#a6e22e">REGISTER_BEAN&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Conditional&lt;/span>(OnWindowsCondition.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OnWindows&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Windowsの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Conditional&lt;/span>(OnUnixCondition.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OnUnix&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Linuxの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実装したConditionは、また同じ方法でConditionalアノテーションに指定します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OsConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// WindowsかLinuxのどちらだとBeanが登録される&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Conditional&lt;/span>(OnWindowsOrUnixCondition.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> WindowsOrUnixBean &lt;span style="color:#a6e22e">windowsOrUnixBean&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> WindowsOrUnixBean();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>こちらで紹介したアノテーション以外でも、org.springframework.boot.autoconfigure.conditionのパッケージの下には様々なクラスが存在しています。例えばWebアプリケーションかどうか、クラウドプラットフォームかどうかのアノテーションが用意されていて、のちにまた様々な条件が追加される可能性もありますね。&lt;/p>
&lt;p>これらConditionalアノテーション群は、Spring BootのAuto Configurationでも使われているものらしいです。あので以前私が紹介したように自分でプロパティを直接読み込み、if文を書くよりは安定的な方法であると思います。また、様々な条件に対応するアノテーションがそれぞれ存在していて、カスタムCondtionを作ることで共通化できる部分もあると思うので、いろいろ便利ですね。&lt;/p>
&lt;p>Javaそのものもそうですが、Springの世界もまだいろいろと奥深いと感じました。これからも勉強ですね。&lt;/p></description></item><item><title>Streamを正しく使う</title><link>https://retheviper.github.io/posts/java-stream/</link><pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-stream/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Streamを正しく使う" />&lt;p>個人的には、関数型プログラミングにあまり詳しくはないですが、Java 1.8のStream APIは好んで使っています。他にもLambdaやOptionalといったAPIも好きですが、自分がJavaの資格を取った理由も、このStream APIについてもっと勉強したかったからと言っても過言ではないです。&lt;/p>
&lt;p>そんな私ですが、Streamについて勉強している中、疑問が出来ました。Streamは確かにいいAPIですが、伝統的なJavaのAPIとはかなり違うものです。これをJavaに導入したことで得られるメリットがあるから導入されたはず、というのは難しくない推論ですが、逆の場合はどうでしょうか？Streamを使った場合のデメリットは？そして自分が使っているStreamの書き方は正しいのか？などなど。&lt;/p>
&lt;p>今回のポストでは、そのような疑問について独自に調査したことを述べていきたいと思います。正解というより、こういう見解があるということとしてご理解ください。&lt;/p>
&lt;h2 id="streamは万能か">Streamは万能か？
&lt;/h2>&lt;p>まず最初の質問です。Streamは万能か？つまり、既存のコードをすべてStreamに書き換えても問題はないか？そしてなるべくこれから書くコードはStreamに変えるべきなのか？という質問ですね。確かに新しいAPIが出て、既存のコードと同じ役割ができるとしたら、それにはなんらかの理由があります。Javaの場合は、NIOがそうでした。一般的なI/OではOSのカーネルの機能を利用できなかったため、それを改善するために登場しましたね。しかし、NIOもまた、全ての場面で既存のI/Oより優れているとは言えない面がありました。そしたらStreamの場合も、その可能性はあると思いました。&lt;/p>
&lt;p>結論からいうと、「全てのコードをStreamに書き換える必要はない」です。その理由を、一つ一つ項目別に説明します。&lt;/p>
&lt;h3 id="性能は劣る場合も">性能は劣る場合も
&lt;/h3>&lt;p>Java 1.5では、伝統的なFor文意外にも、いわゆる拡張For文というものが登場しました。そして1.8では、Streamと共にforEach()というメソッドもできましたね。しかし、forEach()もStreamも性能は拡張For文より劣ります。また、とあるベンチマークでは、Streamを使った場合の処理はParallelを使っても拡張For文より性能は劣るという結果が出たらしいです。理由は簡単です。Streamを使うと、より複雑な処理が中に入るからです。特に配列をStreamに変換する時はラッピングが入るので、そこでもう処理が加えられるということを考えられますね。&lt;/p>
&lt;p>特に、オブジェクトを扱う場合の性能の差はそんなに大きくないものの、プリミティブ型を扱う場合は性能の差がより大きいらしいです。なので無理やり配列をStreamに変えて処理をする必要はありません。StreamやforEach()は、それを持って安定したコードを書けられる場合に限定して使う必要があります。そしてStreamを使う場合もプリミティブ型を扱う場合はIntStreamやToIntStreamといった、それぞれの型に合わせたクラスを使った方がより良い性能を出すので、そこもちゃんと考慮すべきですね。&lt;/p>
&lt;p>JVMが長い間伝統的なFor文に最適化されてきて、1.8になってやっと登場したStreamはそれほど最適化されてないので性能が劣るという話もありましたが、これは1.8がリリースされた当時の記事に書いてあったものなので14までバージョンアップがなされた今はどうかという疑問はあります。それでも伝統的なFor文の方がまだ性能では優秀ではないだろうかと思いますが。&lt;/p>
&lt;h3 id="途中でやめられない">途中でやめられない
&lt;/h3>&lt;p>Streamの処理は一般的なforループとは違って、continueやbreak、returnなどで一部の処理をスキップしたり途中で処理を止めることができません。基本的にStreamは全要素に対して処理をすることを前提にして設計されたからです。なのでそれぞれの目的に合わせて、Streamのメソッドを適切に使い分ける必要があります。例えばFor文での処理は以下のような変えられます。&lt;/p>
&lt;ul>
&lt;li>条件に合致する要素だけを処理したい場合(if)
&lt;ul>
&lt;li>filter()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Collectionにしたい場合(add)
&lt;ul>
&lt;li>collect()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要素を取り出したい場合(return)
&lt;ul>
&lt;li>findAny() / findFirst()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="ループ変数を使用できない">ループ変数を使用できない
&lt;/h3>&lt;p>拡張For文ではなく、伝統的なFor文ではループ変数を使って、現在のループが何回目かを数えることができます。しかし、Streamではループ変数を使うことができません。例えば、以下のようにStreamの外部に変数を置いてもコンパイルエラーとなります。&lt;/p>
&lt;p>int型のループ変数を使いたい場合はIntStreamを、ループ変数で処理をスキップしたい場合はskip()を使いましょう。もちろん、こういう場合は普通に既存のFor文を使った方が正解に違いです。&lt;/p>
&lt;h3 id="そもそもの関数型">そもそもの関数型
&lt;/h3>&lt;p>実は、Streamの中でも外部変数をループ変数として使う方法がなくはないです。AtomicIntegerでループ変数を使う方法がありますが、そこまでしてStreamを使う理由もなければ、関数型プログラミングの目的に合いません。&lt;/p>
&lt;p>関数型プログラミングのコンセプトの中では不変性(Immutability)というものがあります。以前&lt;a class="link" href="../java-thoughts-of-immutable" >Immutabilityについて述べたこと&lt;/a>がありますが、ここで重要なのはデータが変わることはない、ということです。データが変わらないならどうやって処理が行われるかというと、元のデータはそのままで、処理ではそのデータのコピーを作って作業することになります。&lt;/p>
&lt;p>Streaｍを持って処理をする場合に、その結果が新しいインスタンスになるのもそれが理由です。Listをループさせる場合は、元の要素を編集できます。しかし、Streamで処理する場合は変更された要素で構成された新しいListを返すようになりますね。中間操作で元の要素を編集するとしても、Streamは終端操作が終わるとクローズされ再利用できなくなります。これで元のデータは変えずに済みますね。&lt;/p>
&lt;p>なのでStreamを使う場面というのは、まず元のデータをどうするかによります。もちろん、Streamを使わない場合でも、関数型的なコードの作成がより場合も多いです。(ということで、まずは関数型プログラミングを勉強ですね…)&lt;/p>
&lt;h2 id="streamをより活用する">Streamをより活用する
&lt;/h2>&lt;p>次に、Streamを使う場合に、どうしたら正しく、より効率的に活用できるかに関する質問です。Streamは最初から再使用できないようになっていますが、場合によっては同じデータに対してそれぞれ違う処理を行う必要があるのでそれがどうやって実現できるか、という疑問がありました。例えば、普通のFor文だとループの中で分岐を置くことで二つのCollectionに要素を分配するような処理ができるのですが、Streamだと同じオブジェクトに対しての処理はできませんね。こういう場合は同じデータに対してどうやったらStream処理を2回以上できるか気になります。&lt;/p>
&lt;p>もう一つは、自分だけなのかもしれませんが、Stream以外でも、メソッドチェーニングを使えるAPIは非効率的な処理が入ってもすごく場合があって、それをどうしたら効率的な書き方にできるかという疑問がありました。例えばCollectionや配列をStreamに変換してからforEach()を使うこともできますが、CollectionだとstreamなしでもforEach()は使えますね。こういう場合は直感的にCollectionのforEach()の方が良さそうだとは思いますが、それ以外の場合はどうなのかよくわかりません。&lt;/p>
&lt;p>なので、この二つの疑問についても調査してみました。&lt;/p>
&lt;h3 id="再使用">再使用
&lt;/h3>&lt;p>Streaｍは何度も繰り返して中間操作が可能ですが、一度でも終端操作が行われるとクローズされ、再利用ができなくなります。なぜなら、Streamの目的はデータの処理であって、データの格納ではないからです。&lt;/p>
&lt;p>しかし、たまには同じデータに対してStreamを利用し、それぞれ違う処理を行たい場合もありますね。そういう時はどうしたらいいでしょう。Javaでデータを格納するためのものは配列やCollectionがありますので、必要なデータを予め定義して、場合によってそれをStreamに転換して使う方法があります。配列の場合は&lt;code>Arrays.stream()&lt;/code>や&lt;code>Stream.of()&lt;/code>があり、Collectionだと&lt;code>stream()&lt;/code>がありますね。例えば以下のような方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listで必要なデータを集めておく&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> names &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Eric&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Elena&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Java&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> name.&lt;span style="color:#a6e22e">contains&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1番目のStream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> firstElement &lt;span style="color:#f92672">=&lt;/span> names.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">findFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2番目のStream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> anyElement &lt;span style="color:#f92672">=&lt;/span> names.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">findAny&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>予め必要なデータはListとしてCollectし、必要な場合はそれをまたStreamに変換して使う例でした。データがそもそもCollectionや配列の場合は、必要に応じてstream()を呼び出すことでそれぞれ違う処理ができます。また、peek()を挟むことで違うCollectionにデータを追加することもできます。厳密にいうと再使用というよりはどうStreamを作るかに関する話となりますが、これで一つのデータから複数の処理結果を出すことは可能、ということになります。&lt;/p>
&lt;h3 id="短く書く">短く書く
&lt;/h3>&lt;p>先に述べましたが、StreamはメソッドチェーニングのできるAPIなので、非効率的なコードを書きやすい傾向がありました。なのでケース別により効率的な書き方を集めてみました。自分はEclipseを主に使っているのですが、Intellijだと、こうした方がいいよとオススメしてくれる部分らしいです。&lt;/p>
&lt;ul>
&lt;li>Collectionのメソッドを使う&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// CollectionのForEach&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>collection.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">forEach&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> collection.&lt;span style="color:#a6e22e">forEach&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collectionを配列に&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>collection.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">toArray&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> collection.&lt;span style="color:#a6e22e">toArray&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Streamを作る&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 配列からStreamに&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>().&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>() &lt;span style="color:#f92672">/&lt;/span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 空のStreamを作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Collections.&lt;span style="color:#a6e22e">emptyList&lt;/span>().&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Stream.&lt;span style="color:#a6e22e">empty&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 範囲指定で配列を作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IntStream.&lt;span style="color:#a6e22e">range&lt;/span>(expr1, expr2).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> array&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(array, expr1, expr2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 範囲指定でStreamを作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Collection.&lt;span style="color:#a6e22e">nCopies&lt;/span>(count, ...)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Stream.&lt;span style="color:#a6e22e">generate&lt;/span>().&lt;span style="color:#a6e22e">limit&lt;/span>(count)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>要素の判定&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 条件に一致する要素が存在するかの判定(1)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">filter&lt;/span>().&lt;span style="color:#a6e22e">findFirst&lt;/span>().&lt;span style="color:#a6e22e">isPresent&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">anyMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 条件に一致する要素が存在するかの判定(2)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">map&lt;/span>().&lt;span style="color:#a6e22e">anyMatch&lt;/span>(Boolean::booleanValue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">anyMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素が一つでも条件と一致しないかの判定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">!&lt;/span>stream.&lt;span style="color:#a6e22e">anyMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">noneMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 全要素が条件と一致するかの判定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">!&lt;/span>stream.&lt;span style="color:#a6e22e">anyMatch&lt;/span>(x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>(...))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">allMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ソートして最も先にある値を探す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">sorted&lt;/span>(comparator).&lt;span style="color:#a6e22e">findFirst&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Stream.&lt;span style="color:#a6e22e">min&lt;/span>(comparator)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>要素を集める&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素の数を数える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(counting())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">count&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 最も大きい要素を探す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(maxBy())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">max&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素を違うオブジェクトにマッピングする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(mapping())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">map&lt;/span>().&lt;span style="color:#a6e22e">collect&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素を一つにまとめる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(reducing())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">reduce&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素を数字の合計にする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(summingInt())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">mapToInt&lt;/span>().&lt;span style="color:#a6e22e">sum&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>要素の処理&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素の状態だけを変える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">map&lt;/span>(x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {...; &lt;span style="color:#66d9ef">return&lt;/span> x;})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">peek&lt;/span>(x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ...)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>関数型プログラミングに興味がないとしても、Streamそのものはかなり魅力的なAPIですので、皆さんにもぜひ使ってみて欲しいです。Java 1.8がリリースされた当時には性能も劣り読みにくいという批判も多かったのですが、もう時間は経ち、Javaのバージョンはすでに14となっているくらいです。もうそろそろStreamを使ってモダンな書き方を試してみても良いでしょう。&lt;/p>
&lt;p>そしてStreamを通じて、関数型プログラミングを味わえるのも一つのメリットではないかと思います。もちろん、Streamが完璧な関数型プログラミングの例だとは言い切れませんが、少なくとも、オブジェクト指向だけでなく新しいプログラミングのトレンドはどういうものかを経験できるということだけでも十分価値があるのではないでしょうか。もう関数型プログラミングの概念が登場してからも数年が経っています。プログラミングの世界は常に変化と発達が伴うものなので、少なくとも最近のトレンドが何であるかくらいは把握しておきたいものです。&lt;/p>
&lt;p>では、またあいましょう！&lt;/p></description></item><item><title>Oracle JavaSE 8 Goldについて</title><link>https://retheviper.github.io/posts/java-se-8-gold/</link><pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-se-8-gold/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Oracle JavaSE 8 Goldについて" />&lt;p>この度はJava SE 8 Goldを受験しました。Silverを取ったのが去年の9月末だったので、およそ半年ぶりの受験ですね。以前、Silverの方を受験した時は&lt;a class="link" href="../java-se-8-silver" >ポスト&lt;/a>でその感想を書いていたので、今回も同じくGold受験後の感想を書こうと思います。&lt;/p>
&lt;h2 id="generics">Generics
&lt;/h2>&lt;p>Genericsに関する問題は、型が明確ではない場合をとう問題が多かったです。例えばとあるクラスを継承しているクラスのみを引数として受けたい場合はどうするか、とかの問題ですね。&lt;code>&amp;lt;? super X&amp;gt;&lt;/code>と&lt;code>&amp;lt;? extends X&amp;gt;&lt;/code>の違いがよくわからないと難しくなる、そのような問題です。&lt;/p>
&lt;p>また、Genericsに関しての問題は&lt;code>Comparator&amp;lt;T&amp;gt;&lt;/code>と&lt;code>Comparable&amp;lt;T&amp;gt;&lt;/code>も登場していて、これからどう違うか、またどこで必要となるものかを理解していないと難しい問題になっていました。個人的にはあまり使ってないAPIだったので最初は苦戦した問題でした。理解できればなるほど、となりますが、これからもそんなに使うことあるかどうか…でも確かに知っておけば便利そうな気はしますので覚えておきたいAPIです。&lt;/p>
&lt;h2 id="lambda">Lambda
&lt;/h2>&lt;p>Java 1.8の重要機能であるLambdaはやはり問題数が多いです。Lambdaはただ単にメソッドの書き方が楽になったということだけではなく、それを活用できる関数型インタフェースやStreamなど、他の重要なAPIと関係がある重要なAPIですので、やはりこれがわからないと本当の意味でJava 1.8を理解していないと言えるでしょう。&lt;/p>
&lt;p>Lambdaに関する問題は、関数型インターフェースの条件(SAM)やjava.util.functionパッケージで提供しているインターフェースの種類を理解していないと解けないものが多い感じでした。また、Method Referenceに関する問題も出題されています。Lambdaをしっかり理解していれば書き方が違うだけというのがわかりますが、そうでないとコードすら読めないかもしれません。&lt;/p>
&lt;h2 id="stream">Stream
&lt;/h2>&lt;p>Streamは問題の割合が多いです。Java 1.8で追加された重要なAPIの一つでもあり、今までのJavaのAPIとは性格がちょっと違うものでもあるのでなんとなく感だけで使っていた自分には大変勉強となりました。今まではせいぜいstream()やcollect()くらいしか使ってなかったのですが、今回の試験でこれから色々Streamを活用できる箇所が増えていくような気がします。&lt;/p>
&lt;p>個人的には既存のコードが問題なく作動していていればわざわざStreamに変える必要があるくらいではないものの、関数型プログラミングの特徴を少しでも味わえる素敵なAPIと思います。例えば問題では中間操作と終端操作の違いやそれぞれのメソッドの活用方法などに関する質問が出ていて、それらしきメソッド名を並べては「次の中、〇〇APIのメソッドとして正しいものを選びなさい」のような意味のない問題に比べ、APIそのものの特徴と使い方を理解できないと解けない問題となっている感じがして好きでした。特に、peek()やsorted()、Collectors.groupingBy()のような良いメソッドが出てきて嬉しかったです。&lt;/p>
&lt;h2 id="io">I/O
&lt;/h2>&lt;p>基本的にはJava 1.7から追加されたNIOに関する問題が多かったです。これもまたStreamと結び付けるためか、lines()やlist()、walk()などのメソッドに関して問う問題が多かったですね。また、同じく1.7から登場したtry-with-resourceに関する問題も出たのでよかったと思います。&lt;/p>
&lt;p>自分の場合はファイルI/Oで主にNIOのFilesクラスを使うことが多いので馴染んでいるのもあって、close()をわざわざ呼び出さなくても安全なAPIを提示してくれるってことはこれからの習慣にもいい影響を与えるだろうと思います。&lt;/p>
&lt;p>個人的には仕事でもAutoCloseableを継承したクラスを作ったこともあったので嬉しかったです。&lt;/p>
&lt;h2 id="thread">Thread
&lt;/h2>&lt;p>並行性に関する問題も割合的には多い感じでした。AtomicIntegerやExecutorServiceのような重要なAPIを学ぶ良い機会となりましたが、せっかくRunnableやCallableまで扱っているので、CompletableFutureまで扱ってくれていたらよかったのでは、と思いました。CyclicBarrierが出ていましたが、最近はあまり使われてないらしいですしね。スレッドはそこまで難しくなく、ForkJoinPoolとCyclicBarrier、RunnableとCallableのシグニチャをちゃんと覚えておいたら解ける問題が多かった気がします。&lt;/p>
&lt;h2 id="temporal">Temporal
&lt;/h2>&lt;p>LocalDateTimeなどのAPIに関する問題が少し出ていましたが、割合は低め。Silverでも扱っていたAPIなので、こちらではフォーマッターや例外になるパターンに関する問題が多かったような気がします。ZoneIdなども出てきましたが、そこまで重要ではないような印象でした。&lt;/p>
&lt;h2 id="locale">Locale
&lt;/h2>&lt;p>こちらもまた割合は低め。ただ、プロパティーをどう読み込むかはLocaleだけでなく環境変数などを扱う時も必要な知識となるため、覚えておくかちはあると思います。APIのシグニチャを問う問題の場合はインターネットでも十分情報を得ることができるのでわざわざ覚える必要はあるのかな？といったところですが…&lt;/p>
&lt;h2 id="他に">他に
&lt;/h2>&lt;p>JDBCに関する問題も少々ありましたが、やはり今はあまり使われてないので問題の数は少なかったです。自分の場合はJavaでのDB処理にはMybatisやJPAを使っているのでわざわざJDBCを使うことはないのですが、基本的にJavaではこういう風にDBにアクセスして処理をしているんだな、ということだけ分かれば十分なのではと思っているので、問題の割合としては適切だったかなと。&lt;/p>
&lt;p>また、SilverまではJavaのAPIをちゃんと覚えているかを問う問題が多いような気がしますが、Goldからはクラス設計に関する問題もいくつか出ていて、カプセル化やシングルトンクラスをどう実装するべきかに関する問題や、Files.walk()による再帰処理などに関する問題もあったのですが、Goldを受験する人がそのような知識がないとは思えないのですね。&lt;/p>
&lt;p>一つ、せっかく同じような使い方(メソッドチェイン)をしていて、Streamで要素を取得する時も使えるOptionalについては言及されてないことは残念に思います。他と同じくJava 1.8で導入されたものなのになぜ…？って感じですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>去年はJava SE 11の資格も登場したので、最初からそちらにした方がよかったかなとも思いましたが、Oracleの公式ホームページの試験の紹介だとJava 9から導入されたモジュールシステム以外はあまり試験の内容が変わってないようです。&lt;/p>
&lt;p>8も11もLTSバージョンなので、次のLTSである17がリリースされたら、おそらく資格も更新される可能性があります。個人的には12から14まで導入された新機能の方が便利だと思うので、私のように勉強の目的で受験していて、元々8の資格を持っている方ならあまり11へのアップグレードはメリットがないかもしれません。もちろん、これから初めて資格を取得する人にとっては11の方が良いでしょう。自分はそんなことも知らずにとりあえず8を受験してしまったのですが…&lt;/p>
&lt;p>とりまとめ、資格取得は嬉しいことですが、何よりも勉強のため始めたJavaの資格が、思っていたより仕事で役立つ知識を提供していたので満足しました。問題自体はパターンをよく覚えだけで解けるものも多いのですが、JavaのAPIに対する理解を深めたい方なら、受験してみて損することはないと思います。受検料は高いですが…&lt;/p></description></item><item><title>Jasyptでプロパティを暗号化する</title><link>https://retheviper.github.io/posts/spring-settings-encryption/</link><pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-settings-encryption/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post Jasyptでプロパティを暗号化する" />&lt;p>Springでは、application.propertiesやapplication.ymlファイルに別途設定したい項目を定義することによってデータをアプリケーションの外に出すことができます。こうしてデータとアプリケーションを分離するのは、ハードコードすることによって変更が発生した場合にアプリケーションそのものを修正する不便からの開放されることができます。&lt;/p>
&lt;p>しかし、こうやって別途の外部ファイルに様々な設定値を書くということは、セキュリティ問題と繋がることになる場合もあるでしょう。例えばDBなどのクレデンシャル情報や、企業の業務と関連したコードなどが平文で記載されているとしたら、ハッキングでなくても、セキュリティ問題となる可能性は十分です。こういう場合に、記載したい各種設定値などを暗号化できるといいでしょう。それを可能にするAPIがすでに存在していて、今回紹介したいものは&lt;a class="link" href="http://www.jasypt.org" target="_blank" rel="noopener"
>Jasypt&lt;/a>というものです。&lt;/p>
&lt;p>Jasyptを使うと、平文を暗号化したり、暗号文を複合して平文に戻すことができます。Spring Boot Starterも提供しているのですでに作成済みのSpring Bootアプリケーションに暗号化機能を追加するのも簡単。では、Jasyptを使ってどうやって暗号化と複合の機能をSpring Bootアプリケーションに導入できるかを今回のポストで説明しましょう。&lt;/p>
&lt;h2 id="jasyptによる暗号化のフロー">Jasyptによる暗号化のフロー
&lt;/h2>&lt;p>Jasyptを使ってのSpring Bootアプリケーションの外部ファイルに記載した設定値の暗号化と複合は、以下のようになります。&lt;/p>
&lt;ol>
&lt;li>EncryptorクラスをBean登録&lt;/li>
&lt;li>Encryptorクラスで平文を暗号化&lt;/li>
&lt;li>YAMLに暗号文を記載&lt;/li>
&lt;li>アプリケーションを起動時、YAMLの暗号文を複合して使用&lt;/li>
&lt;/ol>
&lt;p>Jasyptで提供しているEncryptorは、デフォルトとして提供されるクラスもありますが、カスタマイズもできるので今回はその方法を紹介していきます。&lt;/p>
&lt;h2 id="依存関係を追加">依存関係を追加
&lt;/h2>&lt;p>Spring bootを基準に、依存関係は以下のように追加します。&lt;/p>
&lt;p>Mavenの場合&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.github.ulisesbocchio&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>jasypt-spring-boot-starter&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.0.2&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Gradleの場合&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>dependencies &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation &lt;span style="color:#e6db74">&amp;#39;com.github.ulisesbocchio:jasypt-spring-boot-starter:3.0.2&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Jasypt本体だけを普通のJavaアプリケーションで使うこともできますが、今回はSpring Bootアプリケーションを基準にしているので、設定が簡単な方を紹介しています。&lt;/p>
&lt;h2 id="カスタムencryptorを作る">カスタムEncryptorを作る
&lt;/h2>&lt;p>まずはSpringのBeanとしてEncrytorを登録します。Encryptorには様々なオプションが指定できますが、実際重要なのはパスワードとアルゴリズムです。パスワードとアルゴリズムが一致しない場合は複合ができないからです。ここではYAMLファイルにカスタム設定としてEncryptor用のパスワードを記載し、それを持ってEncryptorをBean登録する場合のコードを紹介します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StringEncryptorConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// YAMLから読み込むパスワード&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Value&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;${settings.jasypt.password}&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String password;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// encryptorBeanという名前でEncryptorをBean登録する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>(name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;encryptorBean&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> StringEncryptor &lt;span style="color:#a6e22e">stringEncryptor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PooledPBEStringEncryptor encryptor &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> PooledPBEStringEncryptor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SimpleStringPBEConfig config &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SimpleStringPBEConfig();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.&lt;span style="color:#a6e22e">setPassword&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;password&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.&lt;span style="color:#a6e22e">setAlgorithm&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;PBEWithMD5AndDES&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以下は必須項目ではない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.&lt;span style="color:#a6e22e">setKeyObtentionIterations&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.&lt;span style="color:#a6e22e">setPoolSize&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.&lt;span style="color:#a6e22e">setProviderName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;SunJCE&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.&lt;span style="color:#a6e22e">setSaltGeneratorClassName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;org.jasypt.salt.RandomSaltGenerator&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.&lt;span style="color:#a6e22e">setStringOutputType&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;base64&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> encryptor.&lt;span style="color:#a6e22e">setConfig&lt;/span>(config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> encryptor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでEncryptorのBean登録の設定は完了です。次は外部設定ファイルの設定ですね。&lt;/p>
&lt;h2 id="外部ファイルの設定">外部ファイルの設定
&lt;/h2>&lt;p>外部設定ファイルでは、Beanとして登録したEncryptorの名前を指定し、暗号化したプロパティを記載します。Encryptorの名前が一致しなかったり、記載されてない場合はアプリケーションの起動時のエラーとなるので注意しましょう。&lt;/p>
&lt;p>application.propertiesの場合&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-properties" data-lang="properties">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">jasypt.encryptor.bean&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">encryptorBean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">properties.password&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">ENC(askygdq8PHapYFnlX6WsTwZZOxWInq+i)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>application.ymlの場合&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jasypt&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">encryptor&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">bean&lt;/span>: &lt;span style="color:#ae81ff">encryptorBean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">properties&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">password&lt;/span>: &lt;span style="color:#ae81ff">ENC(askygdq8PHapYFnlX6WsTwZZOxWInq+i)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでお気づきの方もいらっしゃるだろうと思いますが、暗号化した項目は必ず&lt;code>ENC()&lt;/code>で囲まなければなりません。そうしなかった場合は、JasyptのEncryptorは設定値をそのまま文字列として読み込みますので複合されません。&lt;/p>
&lt;h2 id="暗号化のアルゴリズム">暗号化のアルゴリズム
&lt;/h2>&lt;p>Jasyptのパッケージを辿ると、基本的にいくつかのEncryptorが定義されていることがわかります。文字列だけでなく、数字タイプやバイナリーも暗号化できるので必要に応じてはSpringではなく、普通のJavaアプリケーションでもインポートして使うことができます。&lt;/p>
&lt;p>今回は文字列の暗号化だけを紹介しますが、この文字列のEncryptorには以下のようなものが予め定義されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// デフォルトとして使われるEncryptor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BasicTextEncryptor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">encryptor&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StandardPBEStringEncryptor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">encryptor&lt;/span>.&lt;span style="color:#a6e22e">setAlgorithm&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;PBEWithMD5AndDES&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// より強いアルゴリズムを使うEncryptor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">StrongTextEncryptor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">encryptor&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StandardPBEStringEncryptor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">encryptor&lt;/span>.&lt;span style="color:#a6e22e">setAlgorithm&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;PBEWithMD5AndTripleDES&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// AES256を使う最も強力なEncryptor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">AES256TextEncryptor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">encryptor&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StandardPBEStringEncryptor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">encryptor&lt;/span>.&lt;span style="color:#a6e22e">setAlgorithm&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;PBEWithHMACSHA512AndAES_256&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">encryptor&lt;/span>.&lt;span style="color:#a6e22e">setIvGenerator&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> RandomIvGenerator());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここに記載されているアルゴリズムは、そのままBeanとして定義するカスタムEncryptorにも使えます。ただし、アルゴリズムが複雑なものであるとそれだけ暗号化した結果は複合が難しくなるので安全ですが、アプリケーション起動が遅くなる可能性もあるので場合によって適切なものを選びましょう。また、AES256を使う場合はIvGeneratorも指定する必要があるということに注意しましょう。&lt;/p>
&lt;p>コード内で暗号化がしたい場合は、Bean登録したEncryptorを呼ぶか、新しいEncryptorのインスタンスを作成してencrypt()メソッドを呼び出すとできます。当然のことですが、同じパスワードを指定しないと正しく暗号化と複合ができないということに注意しましょう。&lt;/p>
&lt;h2 id="コマンドラインツール">コマンドラインツール
&lt;/h2>&lt;p>Jasyptを&lt;a class="link" href="https://github.com/jasypt/jasypt/releases/download/jasypt-1.9.3/jasypt-1.9.3-dist.zip" target="_blank" rel="noopener"
>ダウンロード&lt;/a>すると、コマンドラインツールで暗号化や複合ができるようになります。リンクからditributableバーションをダウンロードして解凍すると、binフォルダの中にbatファイルとshファイルが入っています。格ファイルの機能は以下となります。&lt;/p>
&lt;ol>
&lt;li>encrypt.sh(bat): パスワードベースで平文を暗号化する&lt;/li>
&lt;li>decrypt.sh(bat): パスワードベースで暗号文を複合する&lt;/li>
&lt;li>digest.sh(bat): 複合できないHashコードを生成する&lt;/li>
&lt;li>listAlgorithm.sh(bat): 暗号化に使えるアルゴリズムの種類を羅列する&lt;/li>
&lt;/ol>
&lt;p>encryptとdecryptでは、パスワードと暗号化・複合したい文をコマンドライン引数として入力するとその結果が標準出力で画面に表示されます。また、オプションとしては使いたいアルゴリズムを指定することもできます。使い方は以下のコマンドになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>bin % ./encrypt.sh password&lt;span style="color:#f92672">=&lt;/span>password input&lt;span style="color:#f92672">=&lt;/span>this_is_input
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコマンドでの出力結果は以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>----ENVIRONMENT-----------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Runtime: AdoptOpenJDK OpenJDK 64-Bit Server VM 11.0.6+10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>----ARGUMENTS-------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>input: this_is_input
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>password: password
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>----OUTPUT----------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2lgKlL4gECBBtjch4WZITWDBHWhIxvVz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、listAlgoritymを実行すると、以下のように現在のシステムで使えるアルゴリズムのリストが出力されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>PBE ALGORITHMS: &lt;span style="color:#f92672">[&lt;/span>PBEWITHHMACSHA1ANDAES_128, PBEWITHHMACSHA1ANDAES_256, PBEWITHHMACSHA224ANDAES_128, PBEWITHHMACSHA224ANDAES_256, PBEWITHHMACSHA256ANDAES_128, PBEWITHHMACSHA256ANDAES_256, PBEWITHHMACSHA384ANDAES_128, PBEWITHHMACSHA384ANDAES_256, PBEWITHHMACSHA512ANDAES_128, PBEWITHHMACSHA512ANDAES_256, PBEWITHMD5ANDDES, PBEWITHMD5ANDTRIPLEDES, PBEWITHSHA1ANDDESEDE, PBEWITHSHA1ANDRC2_128, PBEWITHSHA1ANDRC2_40, PBEWITHSHA1ANDRC4_128, PBEWITHSHA1ANDRC4_40&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このリストの中のアルゴリズムはEncryptorをBean登録する時指定できるもののリストでもあるので、必要に応じて適切なものを選びましょう。強力なアルゴリズムを使うとアプリケーションの起動が遅くなる可能性もあります。(Spring BootアプリケーションのYAMLファイルは起動時に読み込まれますので)&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>アプリケーションの作りで、セキュリティの重要性はいうまでもなく高いものですね。先にも述べましたが、Springの設定ファイルでは特に、DBや外部システム連携のための接続情報などの敏感な情報が書かれることが少なくないため、外部設定ファイルがそのまま流出されたら困ることも起こり得ると思います。普段からそのようなことが怒らないように気を付けることももちろん大事ですが、こうやって暗号化によって情報を守るという手段もまた良い方法になるのでは、と思います。&lt;/p>
&lt;p>特に、JasyptのEncryptorは外部設定ファイルだけでなく、コードの中でも使えるので、活用できる範囲が広いですね。敏感な情報を扱っている場合は、アプリケーションの中でも積極的に活用していきたいものです。性能も安定性も大事ですが、何より情報が漏れないように、ですね。&lt;/p></description></item><item><title>ServiceのImplクラスをYAMLで選択する</title><link>https://retheviper.github.io/posts/spring-switching-service/</link><pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-switching-service/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post ServiceのImplクラスをYAMLで選択する" />&lt;p>Springではビジネスロジックを書く場合、一般的にServiceというクラスを作成することになります。Serviceは重要な処理が入るため開発やテストでは重要なクラスですが、開発をしていると、状況によっては実装しても動かせない場合もあります。例えばまだ環境が整っていない、他のクラスに依存する設計となっているがそのクラスがまだ存在していないなどの場合ですね。こういう時は実際の処理が行われず、常に同じ結果を返すクラスを書いておく場合もあります。&lt;/p>
&lt;p>こういう場合に、予め複数のServiceクラスを書いておいて、外部の設定ファイル(&lt;code>application.yml&lt;/code>)に開発モード、テストモードなど状況に合わせてどちらのServiceクラスを使うかを選択できたら便利でしょう。実際、ServiceクラスはInterfaceと実装クラス(Implという名の)を分けて書く場合が多いので、複数のImplクラスを作って置いて、場合によって違うものがBeanとして登録されるようにすることも不可能ではありません。&lt;/p>
&lt;p>なので今回は、YAMLの設定を読み、場合によってどのServieImplをBeanとして登録するかを決める方法を紹介します。&lt;/p>
&lt;h2 id="serviceの元の構成">Serviceの元の構成
&lt;/h2>&lt;p>一般的なServiceクラスの構成は以下のようになります。Interfaceを作成して、それを具現化するサービスを作ることですね。そして中にはDBなどアプリの外部との連携を担当するクラスをDIして使ったりします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SomeService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SomeServiceImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> SomeService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> SomeRepository repository;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">SomeServiceImpl&lt;/span>(SomeRepository repository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span> &lt;span style="color:#f92672">=&lt;/span> repository;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで、テスト時に使いたいImplクラスを以下のように作成したとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SomeTestServiceImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> SomeService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> SomeTestRepository testRepository;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">SomeServiceImpl&lt;/span>(SomeTestRepository testRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">testRepository&lt;/span> &lt;span style="color:#f92672">=&lt;/span> testRepository;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こういう場合は、アプリケーションを起動するとSpringではInterfaceの実装クラスはどれ？と聞いてくることになります。一つのInterfaceに対して二つの実装クラスが存在していて、両方Beanとして登録しようとしているからです。&lt;/p>
&lt;h2 id="アノテーションを削除">アノテーションを削除
&lt;/h2>&lt;p>Serviceクラスには一般的に&lt;code>@Service&lt;/code>をつけることになります。このアノテーションをつけると、Springではこのクラスを自動的にBeanとして登録することになります。なので一つのInterfaceに対して複数の&lt;code>@Service&lt;/code>のついたクラスを作成すると、どれを使いたいかSpringとしてはわからなくなります。なので、ここでは&lt;code>@Service&lt;/code>アノテーションは使わないことにします。&lt;/p>
&lt;h2 id="yamlの作成">YAMLの作成
&lt;/h2>&lt;p>YAMLの作成は簡単です。今回はbooleanを使って、trueになっていればテストモード(SomeTestServiceImplを使用)、falseになっていれば通常モード(SomeServiceImplを使用)で動くようにします。例えば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">settings&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TestMode&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>application.ymlに直接このカスタムプロパティを書いても良いのですが、自作の設定なので、適当な名前をつけて別途のファイルにしても良いです。別途ファイルにした場合は、application.ymlでそのファイルを含むようにすることを忘れないようにしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spring&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">profile&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include&lt;/span>: &lt;span style="color:#ae81ff">settings&lt;/span> &lt;span style="color:#75715e"># ファイル名がapplication-settings.ymlの場合&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="configuration設定">Configuration設定
&lt;/h2>&lt;p>アノテーションを外したら、ServiceImplはBeanとして登録できなくなります。しかし、使いたいServiceImplクラスを選ぶということは、状況によって使いたいクラスをBeanとして登録したい、ということです。なのでどこかでクラスを選び、Beanとして登録するようにする必要がありますね。また、YAMLに書いた設定を読み込む必要もあります。これらをまとめて&lt;code>@Configuration&lt;/code>のついたクラスとして実装しましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SomeServiceConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// YAMLに設定した値を読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Value&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;${settings.TestMode:false}&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> testMode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// YAMLの設定からどのImplクラスを使うかを決定してBean登録&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> SomeService &lt;span style="color:#a6e22e">someService&lt;/span>(SomeRepository repository, SomeTestRepository testRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">testMode&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SomeTestSerivce(testRepository) : &lt;span style="color:#66d9ef">new&lt;/span> SomeServiceImple(repository);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Springでは&lt;code>@Value&lt;/code>や&lt;code>@ConfigurationProperties&lt;/code>を使うことでYAMLに指定した値を読み込むことができます。&lt;code>@ConfigurationProperties&lt;/code>だとクラス全体のフィールドに対してYAMLの値をマッチすることができますが、ここでは一つの値を読み込みたいだけなので、個別フィールドに対して使える&lt;code>@Value&lt;/code>を使います。YAMLファイルがない場合は例外となるため、デフォルト値としてfalseを指定しておきました。&lt;/p>
&lt;p>Bean登録は普通に&lt;code>@Bean&lt;/code>アノテーションをつけ、新しいインスタンスを作成して返すだけです。今回の例ではSerivceImplで依存しているRepositoryクラスをコンストラクターにAutowiredを使って注入しているため、そのインスタンスも必要となりますね。メソッドの引数にRepositoryを書いておけば、それがBeanとして登録されているクラスだと自動的に引数として入ってきます。なのであとはこれがテストモードであるか、通常モードであるかによってそれぞれのコンストラクターに合わせた引数を渡し、インスタンスをリターンすればBean登録も完了となります。簡単ですね！&lt;/p>
&lt;h2 id="アノテーションを使う場合">アノテーションを使う場合
&lt;/h2>&lt;p>Beanを状況により切り替えたいといった場合に、&lt;code>@Profile&lt;/code>アノテーションを使う方法もあります。こちらもやり方は難しくありません。まずYAMLファイルを以下のように定義したとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spring&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">profile&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">active&lt;/span>: &lt;span style="color:#ae81ff">dev&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>YAMLの定義ができたら、あとはどのプロファイルを使うかをアノテーションで指定します。以下のコードのようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SomeServiceConfig&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// devやdebugの場合はこちらをBean登録する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Profile&lt;/span>({&lt;span style="color:#e6db74">&amp;#34;dev&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;debug&amp;#34;&lt;/span>})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> SomeService &lt;span style="color:#a6e22e">someService&lt;/span>(SomeTestRepository testRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SomeTestSerivce(testRepository);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// prodの場合はこちらをBean登録する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Profile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;prod&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> SomeService &lt;span style="color:#a6e22e">someService&lt;/span>(SomeRepository repository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SomeServiceImple(repository);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>@Profile&lt;/code>アノテーションでは指定できるプロファイルを配列で指定できるため、YAMLの記載によってどんなBeanを登録するかを簡単に指定できます。どちらの方法をとっても良いので状況によって適切な方法を選びましょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最近はDjangoやExpressなど、他の言語のウェブフレームワークにも触れてみたいと思っていますが、日々新しい発見と勉強が続いているので、なかなかSpringから離れることができません。こうやってできること、知らなかったことを発見するたびに、他にも良いフレームワークがありながらSpringがエンタープライズ市場で長い間生き残ることができたのはこのようにできることが多いからなのではないか、という気もします。Springだけでもしばらくブログに載せる記事のネタは尽きないかもですね！&lt;/p></description></item><item><title>Rest APIからRest APIにファイルを送る</title><link>https://retheviper.github.io/posts/spring-rest-template/</link><pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-rest-template/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post Rest APIからRest APIにファイルを送る" />&lt;p>ウェブアプリケーションを開発していると、一つの&lt;code>Rest API&lt;/code>だけで全ての機能を自己完結させる必要はない時もあります。例えば組み込みたい機能がすでに実装されているサーバー(API)が存在している場合もありますね。そういう場合は、素直にそのAPIをコールするだけで簡単に目的を達成できます。実際、仕事で他のRest APIサーバーとの通信が必要となって調べてみましたが、Springではすでにそのような場合に対応できるようなクラスを用意していました。今回のポストの主人公であるRestTemplateです。&lt;/p>
&lt;p>RestTemplateを使うと、簡単にget・post・deleteと言ったHttpメソッドのAPIをコールできます。また、リクエストやレスポンスをカスタムして状況に合わせて使うこともできます。例えばカスタムヘッダーを作ったり、サイズの大きいファイルを転送するリクエストを作ることも可能ですね。なので今回はRestTemplateを利用し、ファイルをアップロードするとそのファイルになんらかの処理をして返してくれるAPIがすでに存在している場合で、そのAPIをコールする部品を作る方法を紹介します。&lt;/p>
&lt;h2 id="サーバー側の例">サーバー側の例
&lt;/h2>&lt;p>すでにファイルを処理するサーバーが存在している場合のことですので、まずはコールしたいAPIで利用するリクエストとレスポンスの形を把握する必要がありますね。ファイルをアップロードされたら、ヘッダーからファイル情報を読み込むようになっていて、ファイルデータが書かれているボディを読み込むようなメソッドがあるとしましょう。ヘッダーの情報に問題がなかったらローカルストレージにファイルを書き込み、処理を行います。そして処理の終わったファイルはレスポンスとして返すサーバーです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@PostMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/upload&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> ResponseEntity&lt;span style="color:#f92672">&amp;lt;&lt;/span>StreamingResponseBody&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">fileupload&lt;/span>(HttpServletRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// リクエストヘッダーからファイルサイズを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> fileLength &lt;span style="color:#f92672">=&lt;/span> request.&lt;span style="color:#a6e22e">getContentLengthLong&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルサイズが0だとIOException&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileLength &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IOException(&lt;span style="color:#e6db74">&amp;#34;data size is 0&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルを臨時ファイルとして保存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String fileName &lt;span style="color:#f92672">=&lt;/span> request.&lt;span style="color:#a6e22e">getHeader&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-File-Name&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Path tempFile &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">createTempFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;process_target_&amp;#34;&lt;/span>, fileName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream is &lt;span style="color:#f92672">=&lt;/span> request.&lt;span style="color:#a6e22e">getInputStream&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Files.&lt;span style="color:#a6e22e">copy&lt;/span>(is, tempFile);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IOException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...ファイルを持ってなんらかの処理を行う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンス用のヘッダーを作る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpHeaders headers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Headers();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 処理が終わったファイルを書き込むボディを作る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StreamingResponseBody body &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StreamingResponseBody() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">writeTo&lt;/span>(OutputStream outputStream) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bytes &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">readAllBytes&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> outputStream.&lt;span style="color:#a6e22e">write&lt;/span>(bytes);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ヘッダーとボディ、HttpStatusをセットしてレスポンスを返す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ResponseEntity&lt;span style="color:#f92672">&amp;lt;&lt;/span>StreamingResponseBody&lt;span style="color:#f92672">&amp;gt;&lt;/span>(body, headers, HttpStatus.&lt;span style="color:#a6e22e">OK&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>サーバーがこういう形になっている場合、APIをコールする側としてはRequestのヘッダーにはファイル情報を書き、ボディにはファイルのデータを書いて転送する必要がありますね。そして処理結果のResponseにもまたファイルデータが入ってあるので、それを受け止める処理が必要となります。そのためにリクエストもレスポンスもカスタムのものを作って、RestTemplateに載せることにしましょう。&lt;/p>
&lt;h2 id="resttemplateを使う">RestTemplateを使う
&lt;/h2>&lt;p>今回はRestTemplateのexecute()というメソッドを使いますが、このメソッドの引数は以下のようになります。&lt;/p>
&lt;ol>
&lt;li>APIのURL(StringもしくはURI)&lt;/li>
&lt;li>Httpメソッド(ENUM)&lt;/li>
&lt;li>リクエスト(RequestCallbackの実装クラス)&lt;/li>
&lt;li>レスポンス(ResponseExtractorの実装クラス)&lt;/li>
&lt;/ol>
&lt;p>get()・post()・delete()などのメソッドの時と違ってリクエストとレスポンスの方を両方指定する理由は、上に述べた通りリクエストとレスポンスの両方でファイルの転送が必要からです。また、execute()でも引数にURI変数を指定することもできますが、現在はURIが固定なので使いません。では、リクエストとレスポンスのインタフェースをどう実装するかをみていきましょう。&lt;/p>
&lt;h2 id="リクエスト">リクエスト
&lt;/h2>&lt;p>リクエストで使うRequestCallbackの実装クラスを作成します。このインタフェースにはコンストラクターの引数としてファイルを渡すとヘッダーとボディを作るようにしてみましょう。RequestCallbackをimplementsすると、doWithRequest()というメソッドをオーバーライドするようになります。このメソッドの引数であるClientHttpRequestにヘッダーとボディを設定することでリクエスト時のファイルアップロードができます。以下のコードを参照してください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FileTransferRequestCallback&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> RequestCallback {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// アップロードしたいファイル&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Path path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ヘッダーにファイル情報を載せるためのコンストラクター&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">PdfConvertRequestCallback&lt;/span>(File file) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">path&lt;/span> &lt;span style="color:#f92672">=&lt;/span> file.&lt;span style="color:#a6e22e">toPath&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doWithRequest&lt;/span>(ClientHttpRequest request) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルからヘッダーを作る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.&lt;span style="color:#a6e22e">getHeaders&lt;/span>().&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-Length&amp;#34;&lt;/span>, Files.&lt;span style="color:#a6e22e">size&lt;/span>(path));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> request.&lt;span style="color:#a6e22e">getHeaders&lt;/span>().&lt;span style="color:#a6e22e">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Content-File-Name&amp;#34;&lt;/span>, path.&lt;span style="color:#a6e22e">getFileName&lt;/span>().&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ボディにファイルを書き込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(file); OutputStream os &lt;span style="color:#f92672">=&lt;/span> request.&lt;span style="color:#a6e22e">getBody&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">transferTo&lt;/span>(os);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ヘッダーにはサーバーで要求するファイルサイズとファイル名を載せました。そしてアップロードするファイルをInputStreamとして取得して、OutputStreamであるボディに書き込みます。これでリクエストでのファイルアップロード設定は終わりです。次はレスポンスですね。&lt;/p>
&lt;h2 id="レスポンス">レスポンス
&lt;/h2>&lt;p>レスポンスでは、ResponseExctractorをimplementsします。この場合はextractData()というメソッドをオーバーライドするようになります。このメソッドの引数であるClientHttpResponseからはリクエストの時と同じくHttpステータスコード、ヘッダー、ボディを取得できます。このレスポンスの結果からResponseEntityのインスタンスを作成し、レスポンスの結果を載せて返すとRestTemplateからは通信の結果としてResponseEntityを返すようになります。&lt;/p>
&lt;p>ResponseEntityを返すためにはそのボディの型を指定する必要があります。InputStreamの型を指定して、レスポンスのボディがファイルであることを指定しましょう。また、ClientHttpResponseのボディをResponseEntityにそのまま載せると、InputSteamがCloseされるのでボディはコピーしておきます。私は一回byte[]に変えて、さらにByteArrayInputStreamを生成することにしました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FileTransferResponseExtractor&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> ResponseExtractor&lt;span style="color:#f92672">&amp;lt;&lt;/span>ResponseEntity&lt;span style="color:#f92672">&amp;lt;&lt;/span>InputStream&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ResponseEntity&lt;span style="color:#f92672">&amp;lt;&lt;/span>InputStream&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">extractData&lt;/span>(ClientHttpResponse response) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// レスポンスのボディをコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bytes &lt;span style="color:#f92672">=&lt;/span> response.&lt;span style="color:#a6e22e">getBody&lt;/span>().&lt;span style="color:#a6e22e">readAllBytes&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ステータスコード、ヘッダー、ボディのデータを載せてResponseEntityを返却&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ResponseEntity.&lt;span style="color:#a6e22e">status&lt;/span>(response.&lt;span style="color:#a6e22e">getStatusCode&lt;/span>()).&lt;span style="color:#a6e22e">headers&lt;/span>(response.&lt;span style="color:#a6e22e">getHeaders&lt;/span>()).&lt;span style="color:#a6e22e">body&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ByteArrayInputStream(bytes));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでレスポンスのファイルを取得できるようになりました。次は、RestTemplateでAPIをコールするだけです。&lt;/p>
&lt;h2 id="rest-apiのコール">Rest APIのコール
&lt;/h2>&lt;p>先に述べましたが、RestTemplateのメソッドを実行するのは簡単です。まずはURLと、アップロードしたいファイルのインスタンスを作っておきましょう。そして、先ほど作成したRequestCallbackとResponseExtractorのインスタンスも作成します(ResponseExtractorは、状態を持たないのでBeanとして登録しても良いです)。&lt;/p>
&lt;p>execute()の引数に、URL・Httpメソッドのタイプ・RequestCallback・ResponseExtractorを指定して実行すると、その結果をResponseEntityとして取得できて、そこからさらにステータスコード、ヘッダー、ボディを取得できます。これでアップロードしたファイルを処理してもらい、処理結果のファイルも即取得可能になりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RestTemplateに渡す引数を準備&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;http://api/v1/file/upload&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>File uploadFile &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> File(&lt;span style="color:#e6db74">&amp;#34;path/to/upload_file.txt&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FileTransferRequestCallback requestCallback &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileTransferRequestCallback(uploadFile);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FileTransferResponseExtractor responseExtractor &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileTransferResponseExtractor();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RestTemplateでAPIコールし、その結果を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ResponseEntity&lt;span style="color:#f92672">&amp;lt;&lt;/span>InputStream&lt;span style="color:#f92672">&amp;gt;&lt;/span> responseEntity &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RestTemplate().&lt;span style="color:#a6e22e">execute&lt;/span>(url, HttpMethod.&lt;span style="color:#a6e22e">POST&lt;/span>, requestCallback, responseExtractor);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ResponseEntityからHttpステータスを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (responseEntity.&lt;span style="color:#a6e22e">getStatusCode&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> HttpStatus.&lt;span style="color:#a6e22e">OK&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IOException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ResponseEntityからヘッダーを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HttpHeaders headers &lt;span style="color:#f92672">=&lt;/span> responseEntity.&lt;span style="color:#a6e22e">getHeaders&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ResponseEntityからボディを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (InputStream is &lt;span style="color:#f92672">=&lt;/span> responseEntity.&lt;span style="color:#a6e22e">getBody&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File downloadedFile &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> File(&lt;span style="color:#e6db74">&amp;#34;path/to/downloaded_file.txt&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Files.&lt;span style="color:#a6e22e">copy&lt;/span>(is, downloadedFile);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>意外と簡単！これで他のRest APIとのファイルのやりとりができるようになりました。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>クラスやメソッドを機能別に分けるだけでなく、Rest APIもまた機能によっては分離されることもありますね。今回の場合がまさにそのような例でした。もちろんネットを経由するのでこのようなやり方は一つのRest API内に機能をまとめて置くよりは安定性が劣るかもしれませんが、再使用性が確保できるという面では良い方法ではないかと思います。同じサーバー内だと通信失敗の確率も下がるだろうし、色々と活用できる余地はありそうですね。&lt;/p>
&lt;p>最近はなかなかブログに載せられるようなコンテンツがなかったので(勉強は続けているつもりですが…)、次は何を書けばいいかなと悩んでいましたが、ちょうど面白い部品を作ることができてよかったです。Springの世界も本当に広くて奥深いものですね。では、また！&lt;/p></description></item><item><title>Javaはこう進化して欲しい</title><link>https://retheviper.github.io/posts/java-wishes/</link><pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-wishes/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Javaはこう進化して欲しい" />&lt;p>Javaは長い間業界で生産性、性能、安定性で評判がよく、最近はバージョンアップも様々な機能が追加されています。仕事では主に11バージョンを使っていますが、次のLTSバージョンである17がリリーズされたらそちらを使うことになるのではないかと思います。なので今も新しいバージョンが発表されると一応更新履歴には目を通していますが、言語仕様そのものが変わる場合は新しいAPIの追加と比べ少ない気がしなくもないです。&lt;/p>
&lt;p>Javaが人気を得た理由の一つの生産性という部分では、今じゃPythonやJavaScriptなどに比べて劣る部分もあり、「コードが読みやすい」というメリットも、いつの間にか「冗長すぎる」という評価と変わってしまいましたね。自分はJavaが好きで、まだ言語そのものの仕様まで見切ってはいないですが、それでも使いながらこれは不便だな、これは他の言語と同じくなって欲しいなと思う時もあります。今回のポストでは仕事でJavaを扱いながら感じた不便なところ、また他の言語と比べて改善したいところについて述べたいと思います。こうして他の言語と比べ、Javaがどんなものであるかを把握していくのもまた一つの勉強になるのでは、と思いますので。&lt;/p>
&lt;h2 id="optional表記の改善">Optional表記の改善
&lt;/h2>&lt;p>以前のポスト](../java-optional)で紹介したOptionalですが、これはJavaだけでなく他の言語でも多く採用しているAPIの一つですね。むしろ、JavaのOptionalが他の言語から影響され導入されたものらしいです。今は私自身もよく使っていて、すごい便利だと思っていますが、それでも他の言語と比べたらやはり不便と思うところがあります。&lt;/p>
&lt;p>他の言語と比べてコードが冗長であることがJavaの特徴と先に述べましたが、実際のコードではどうかをまず比較してみましょう。複雑にネストしているオブジェクトのとあるフィールドを読み、Nullだった場合はデフォルト値を返却する例を持って説明します。&lt;/p>
&lt;h3 id="java">Java
&lt;/h3>&lt;p>Javaのコードでは、最初のオブジェクトをOptionalでラップし、ネストされているフィールドやメソッドに対してmap()をチェーニングしていくことで次から次へとラップの対象を変えていきます。そして最後に、ターゲットのオブジェクトがNullだった場合はorElse()などのメソッドでデフォルト値を設定しますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のオブジェクト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SomeClass object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複雑にネストされている&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(object).&lt;span style="color:#a6e22e">map&lt;/span>(obj::getProp1).&lt;span style="color:#a6e22e">map&lt;/span>(prop1::getProp2).&lt;span style="color:#a6e22e">map&lt;/span>(prop2::getProp3).&lt;span style="color:#a6e22e">orElse&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="c">C#
&lt;/h3>&lt;p>言語そのものがJavaと似ているC#ですが、より若いからか、Javaと比べ進んでいる部分がよく見当たるC#です。こちらでもKotlinとコードの書き方は同じです。違うのは、オブジェクトそのものがNullになる可能性を事前に宣言しないということだけですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object?&lt;/span>.prop1?.prop2?.prop3? ?? &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="javascript">JavaScript
&lt;/h3>&lt;p>JavaScriptのOptionalもまた、C#とあまり変わらないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">object&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">prop1&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">prop2&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">prop3&lt;/span>&lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#f92672">??&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="swift">Swift
&lt;/h3>&lt;p>Swiftでもそう変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>object?.prop1?.prop2?.prop3 ?? &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kotlin">Kotlin
&lt;/h3>&lt;p>Kotlinもデフォルト値指定のためのElvis opertor特有の表現を覗くと、一緒ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span>&lt;span style="color:#f92672">?.&lt;/span>prop1&lt;span style="color:#f92672">?.&lt;/span>prop2&lt;span style="color:#f92672">?.&lt;/span>prop3 &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他の言語の例と比べて見ると、JavaのOptionalは確かに冗長な印象ですね。なので今後Optionalを言語の基本仕様として導入し、ラップをするのではなく?として表現できるようにしたらどうかという気もします。?を導入したところでコードの読みやすさを損ねるわけでもないですので。&lt;/p>
&lt;h2 id="multiple-return-statements">Multiple Return Statements
&lt;/h2>&lt;p>Javaの仕様ではメソッドの戻り値となれるオブジェクトは常に一つのみですが、Pythonのような言語では戻り値を複数指定することができます。もちろん、Javaの戻り値が一つという制約を乗り越えるためによくBeanやCollectionに複数のオブジェクトやデータを入れて返すことはできるのでこれはシンタックスシュガー的なものになるだけですが、それでも便利な方法があったら使いたくもなります。&lt;/p>
&lt;h3 id="java-1">Java
&lt;/h3>&lt;p>メソッドの処理結果として複数のデータを受け取りたい場合、Javaだと先に述べたようにBeanやCollectionを使うことになりますね。以下は戻り値が複数の数字である例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(1, 2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 戻り値の取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> data &lt;span style="color:#f92672">=&lt;/span> multipleReturn();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="c-1">C#
&lt;/h3>&lt;p>C#でもJavaと似たようなやり方で複数のデータを取得することができますね。実際はref/outパラメータを使ったり、structやclassを使う方法もあるらしいですが、Javaと比べより便利ではないかと思うのはTupleを使う場合です。C#のバージョンによって書き方が違っていて、昔の書き方ではJavaでCollectionを使うのとあまり変わらないものの、新しい書き方ではかなり便利なものとなっています。以下はその二つの例のコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つメソッド(7以前)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Tuple&amp;lt;&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&amp;gt; oldMultipleReturn()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Tuple.Create(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// オブジェクトとして取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> result = oldMultipleReturn();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つメソッド(7以後)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>) newMultipleReturn()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 変数として取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">int&lt;/span> one, &lt;span style="color:#66d9ef">int&lt;/span> two) = newMultipleReturn();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="python">Python
&lt;/h3>&lt;p>Pythonの例では、7以後のC#と似たような感覚でコードを書けます。オブジェクト(tuple)として戻り値を全部取得するか、個別の変数として取得するか両方一つのfunctionでできるのがより便利な気もしますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 複数の戻り値を持つfunction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">multiple_return&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 個別の戻り値を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a, b &lt;span style="color:#f92672">=&lt;/span> multiple_return()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(a) &lt;span style="color:#75715e"># 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 戻り値をtupleとして全取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>d &lt;span style="color:#f92672">=&lt;/span> multiple_return()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(d) &lt;span style="color:#75715e"># (1, 2)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="javascript-1">JavaScript
&lt;/h3>&lt;p>ES6から導入された書き方ではPythonと似たようなコードで複数の戻り値を取得できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つfunction
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">funtion&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">first&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">second&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 個別の戻り値を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> (&lt;span style="color:#a6e22e">first&lt;/span>, &lt;span style="color:#a6e22e">second&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="swift-1">Swift
&lt;/h3>&lt;p>SwiftはやはりOptionalと同じく、JavaScriptとあまり変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つfunction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>() -&amp;gt; (Int, Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 個別の戻り値を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> (first, second) = multipleReturn()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kotlin-1">Kotlin
&lt;/h3>&lt;p>KotlinではPairかTripleなどがあり、使い方は簡単です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つfunction
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>(): Pair&amp;lt;Int, Int&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> to &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 個別の戻り値を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>first, second) = multipleReturn()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaでのコードの書き方の方がメソッドの役割をわかりやすいというメリットはありますが、戻り値のオブジェクトやデータをそのまま変数として使えるという面ではPythonのやり方がより便利ですね。このように複数の戻り値を持つメソッドを定義できるのは現代プログラミング言語ならどれもが持っている機能のようです。Javaにもいつかは導入されるのでしょうか？&lt;/p>
&lt;h2 id="引数の種類をor指定">引数の種類をor指定
&lt;/h2>&lt;p>たまに、一つのメソッドで引数の型を複数指定できたら便利ではないだろうかと思うことがあります。Javaではこれをオーバーロードで実現していますね。&lt;/p>
&lt;h3 id="java-2">Java
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(String value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Stringの場合の処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// intの場合の処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もちろん、引数の型をObjectとして宣言し、内部ではinstansofを使って判定することもできます。しかし、前者ならやりたいことに比べコードの量が増えすぎる問題がありますし、後者なら意図した型以外のObjectが渡された場合の挙動がおかしくなる可能性もあります。&lt;/p>
&lt;h3 id="typescript">TypeScript
&lt;/h3>&lt;p>TypeScriptでは、これを簡単に引数のタイプを複数指定できるようにすることで解決しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">checkString&lt;/span>(&lt;span style="color:#a6e22e">v&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#34;string&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これまで引数の種類だけ違う場合はオーバーロードして、共通処理だけprivateメソッドで書いていましたが、これならよりコードを簡単に把握できそうですね。ぜひ導入して欲しい機能の一つです。&lt;/p>
&lt;h2 id="ternary-operator-with-throw">Ternary Operator with Throw
&lt;/h2>&lt;p>結果が二択しかない場合は、なるべくifより三項演算子を使った方がコードも短くなり便利と思います。しかし、Javaの三項演算子では例外を投げることができません。条件式に当てはまらない場合はどうしても以下のようなコードを書くしかないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// xが0だとnumberも0で、0ではなかった場合は例外とする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> number &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>無理やり三項演算子で例外を投げようとしたら、以下のような方法はありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Genericな戻り値を持っていて、例外を投げるだけのメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> T &lt;span style="color:#a6e22e">throwSomeException&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// elseでメソッドを呼ぶ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> number &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">==&lt;/span> 0 &lt;span style="color:#f92672">?&lt;/span> x : throwSomeException();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的にif文は二択しかない結果のために使うのはスペースの無駄遣いと思いますし、無理やりメソッドを作ってまで三項演算子を使う必要はないので、三項演算子でelseの場合には単純に例外を投げられるといいな、と思っていました。そして調べてみると、他の言語ではそれができるようです。&lt;/p>
&lt;h3 id="c-2">C#
&lt;/h3>&lt;p>C#では、二つのやり方があります。まず7以前だと、elseの場合に例外を投げるFuncを実行させることで実現できます。そして7以後では普通に三項演算子でthrowできるようです。まさに私が望んでいた形ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 7以前&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> number = x == &lt;span style="color:#ae81ff">0&lt;/span> ? x : &lt;span style="color:#66d9ef">new&lt;/span> Func&amp;lt;&lt;span style="color:#66d9ef">int&lt;/span>&amp;gt;(() =&amp;gt; { &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Exception(); })();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 7以後&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> number = x == &lt;span style="color:#ae81ff">0&lt;/span> ? x : &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Exception();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kotlin-2">Kotlin
&lt;/h3>&lt;p>Kotlinでは三項演算子がなく、if-elseを使うことになるということだけで、簡単な形になっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> i = &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) x &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> Exception(&lt;span style="color:#e6db74">&amp;#34;error&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="javascript-2">JavaScript
&lt;/h3>&lt;p>JavaScriptでは、7以前のC#と似た形で例外を投げることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#66d9ef">function&lt;/span>() { &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#e6db74">&amp;#34;error&amp;#34;&lt;/span> }());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>わざわざ関数を実行してまで三項演算子で例外を投げたくはないですが、こういうやり方があるということがわかっただけでもかなり興味深いですね。JavaにもC#の7以後のような書き方ができるといいな、と思います。&lt;/p>
&lt;h2 id="アクセス修飾子の拡張">アクセス修飾子の拡張
&lt;/h2>&lt;p>Javaでのアクセス修飾子は、public・private・protectedをよく使っています。しかし、自作ライブラリーを作る場合はpublicとprivateの中間的なものもあって欲しいな、と思う時もあります。例えばJarにまとめた時、Jar以外ではアクセスできないようなアクセス制限をかけられるようなものですね。&lt;/p>
&lt;p>Java 9からモジュールが導入されましたが、自分が経験した問題もあるのでなるべくモジュールを使いたくはないなと思っているので…同じプロジェクトの中ならパッケージが違ってもアクセスできるような修飾子があったらいいな、と思います。また、protectedならサブパッケージでも参照できるなど。同じモジュール内でのみのアクセス修飾子はC#とSwift、KotlinでInternalとして提供しているので、Javaにも導入されるといいですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最近のJavaの更新履歴をみると、続々と便利な機能が導入され続けています。特に14では、recordでLombokの&lt;code>@Data&lt;/code>と同じ機能を持つクラス宣言ができるようになるらしいです。次のLTS版は17なので、まだ十分色々と改善される余地はありますね。1.8でも便利な機能は多いですが、これからもどんどん他の言語の良い点を吸収して変転できるといいなと思います。&lt;/p>
&lt;p>また、こうやって他の言語ではどうしているかを調べてみるのも良い勉強となりました。特にTypeScriptは最近注目している言語なので、機会があれば経験してみて、Javaとの比較もしてみたいものですね。では、また！&lt;/p></description></item><item><title>Jenkins Pipelineを使う</title><link>https://retheviper.github.io/posts/jenkins-pipeline/</link><pubDate>Sun, 26 Jan 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jenkins-pipeline/</guid><description>&lt;img src="https://retheviper.github.io/images/jenkins.webp" alt="Featured image of post Jenkins Pipelineを使う" />&lt;p>前回までご紹介したJenkinsでのジョブ生成は、どちらかというと、古いやり方によるものでした。実際、2016年にJenkinsが2.0にアップデートされながら、スクリプトでジョブを作成できるPipelineというものが導入されていました。&lt;/p>
&lt;p>Pipelineではgroovyを使って、実行したいコマンドやタスクなどをステージという単位で書きます。書いたスクリプトは上から順次実行され、各ステージごとに実行結果を画面上に表示してくれます。今までのJenkinsジョブと比べ使い方がかなり違うので、今回はそのPipelineジョブを作成する方法をサンプルを持って紹介したいと思います。&lt;/p>
&lt;h2 id="pipeline使うと何が嬉しい">Pipeline使うと何が嬉しい？
&lt;/h2>&lt;p>まずは普通のジョブと比べ、どんなメリットがあるかを知りたいですね。既存のFreestyleジョブでなく、PipelineでJenkinsのジョブを作成すると以下のようなメリットがあります。&lt;/p>
&lt;ul>
&lt;li>スクリプトなので管理がしやすい
&lt;ul>
&lt;li>ファイルとしても管理ができるので、Gitなどでバージョンコントロールができます。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>作成が簡単
&lt;ul>
&lt;li>Snippetを提供するので簡単にスクリプトを作成できます。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ジョブの成功・失敗履歴を簡単に確認できる
&lt;ul>
&lt;li>ステージ単位でジョブを実行するので、どのステージが成功・失敗したか簡単に確認できます。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Pipelineジョブ内のステージに関する実行履歴はGUIから表示され、簡単に確認できる実行ログを提供しています。以下のような画面です。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_stage_view.webp"
width="1536"
height="1148"
srcset="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_stage_view_hu_5b5881c7254c574f.webp 480w, https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_stage_view_hu_9065b43162b47c5a.webp 1024w"
loading="lazy"
alt="Jenkins Pipeline Stage View"
class="gallery-image"
data-flex-grow="133"
data-flex-basis="321px"
>&lt;/p>
&lt;h2 id="pipeline作成チュートリアル">Pipeline作成チュートリアル
&lt;/h2>&lt;h3 id="pipelineジョブの作成">Pipelineジョブの作成
&lt;/h3>&lt;p>では、まずPipelineジョブを作成する手順を簡単に説明していきましょう。ジョブ作成画面からジョブ名を入力して、Pipelineを選択します。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_create_pipeline.webp"
width="1944"
height="1540"
srcset="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_create_pipeline_hu_de3a08aba6610d7a.webp 480w, https://retheviper.github.io/posts/jenkins-pipeline/jenkins_create_pipeline_hu_4927ccf99f67579d.webp 1024w"
loading="lazy"
alt="Jenkins Create Pipeline"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="302px"
>&lt;/p>
&lt;h3 id="pipelineスクリプト">Pipelineスクリプト
&lt;/h3>&lt;p>Pipelineでジョブを作成すると、ジョブで実行する項目を指定する画面もFreestyleジョブとは違うものになります。ビルドトリガーなどの設定は同じですが、画面を下にスクロールしてみるとPipelineというタブがあることを確認できます。ここに直接スクリプトを書くか、Gitなどで管理しているスクリプトファイルを指定するかで何を実行するか選べられます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_script1.webp"
width="1950"
height="1532"
srcset="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_script1_hu_ddcb90d1e2faec45.webp 480w, https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_script1_hu_8730e69ad59149d9.webp 1024w"
loading="lazy"
alt="Jenkins Pipeline Script"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="305px"
>&lt;/p>
&lt;p>しかし、いきなりスクリプトを書くのも難しいことです。まず画面の右にあるtry sample Pipeline&amp;hellip;をクリックしてみましょう。まずはHello worldを選んでみます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_script2.webp"
width="1924"
height="1508"
srcset="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_script2_hu_75e89742017ed2ec.webp 480w, https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_script2_hu_39c883fc7a11c17a.webp 1024w"
loading="lazy"
alt="Jenkins Pipeline Script 2"
class="gallery-image"
data-flex-grow="127"
data-flex-basis="306px"
>&lt;/p>
&lt;p>Pipelineのスクリプトはgroovyを使っていますが、groovyの文法をまず勉強する必要はありません。サンプルのコードは他にもあるので、それらを参考してどんな書き方をするかを確認しましょう。&lt;/p>
&lt;p>また、Pipelineスクリプトに慣れてない人のためにJenkinsではSnippet作成機能を提供しています。実行したいタスクをドロップダウンメニューから選び、必要なパラメータなどを入力すると自動的にスクリプトを生成してくれる便利な機能です。Pipelineのスクリプト入力欄の下にあるPipeline Syntaxをクリックすると以下のような画面が表示されます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_snippet.webp"
width="2626"
height="1312"
srcset="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_snippet_hu_f9423d9496246a66.webp 480w, https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_snippet_hu_c6af6e3493c0e524.webp 1024w"
loading="lazy"
alt="Jenkins Pipeline Snippet"
class="gallery-image"
data-flex-grow="200"
data-flex-basis="480px"
>&lt;/p>
&lt;p>最初からスクリプトを手で書いても良いですが、どう書いたらわからない場合はこちらの機能を使いましょう。&lt;/p>
&lt;h3 id="pipelineの実行結果">Pipelineの実行結果
&lt;/h3>&lt;p>完成したPipelineジョブを実行するとステージ別に成功と失敗の結果が表示されます。先ほど作成したHello Worldサンプルの場合の実行結果画面です。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_result1.webp"
width="842"
height="922"
srcset="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_result1_hu_6c07fa3c4838c195.webp 480w, https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_result1_hu_21ed6a5168283f34.webp 1024w"
loading="lazy"
alt="Jenkins Pipeline Result"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="219px"
>&lt;/p>
&lt;p>ここでは各ステージをクリックすると、ステージ別に書いたタスクに対して結果を確認できます。Logsをクリックしてみましょう。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_result2.webp"
width="852"
height="922"
srcset="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_result2_hu_a0bf386dd7c09a54.webp 480w, https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_result2_hu_a84569debd6d6d27.webp 1024w"
loading="lazy"
alt="Jenkins Pipeline Result 2"
class="gallery-image"
data-flex-grow="92"
data-flex-basis="221px"
>&lt;/p>
&lt;p>Log画面ではステージで実行したコマンドやタスクの結果がそれぞれ出力され、実行時間と共に詳細を確認することもできます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_result3.webp"
width="1786"
height="1082"
srcset="https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_result3_hu_d86dbfb98809145a.webp 480w, https://retheviper.github.io/posts/jenkins-pipeline/jenkins_pipeline_result3_hu_35703b02dd1f115c.webp 1024w"
loading="lazy"
alt="Jenkins Pipeline Result 3"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="396px"
>&lt;/p>
&lt;h3 id="pipelineスクリプトの構造">Pipelineスクリプトの構造
&lt;/h3>&lt;p>では、簡単にPipelineスクリプトがどんな構造となっているかもみていきましょう。Pipelineスクリプトはまず以下のようなコードで定義します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>pipeline &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// この中に実行するエージェントやステージを書く
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="実行エージェントの設定">実行エージェントの設定
&lt;/h3>&lt;p>pipelineブロックを書いたら、次はpipelineを実行する環境を設定します。単純にJenkinsが起動しているインスタンスの中での実行ならagent anyと書くだけですが、最近はジョブを実行するためだけのDockerコンテナを使うことも多いようです。その場合は実行環境としてDockerコンテナを指定する必要がありますね。以下のようなコードでコンテナを指定します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>pipeline &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> agent &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> docker &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image &lt;span style="color:#e6db74">&amp;#39;実行したいイメージ&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args &lt;span style="color:#e6db74">&amp;#39;イメージを実行する時に渡すコマンドライン変数&amp;#39;&lt;/span> &lt;span style="color:#75715e">// 省略可能
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ステージを作る">ステージを作る
&lt;/h3>&lt;p>環境まで設定できたら、次は実行したいタスクを書きます。ここで大事なのはステージという概念です。Jenkinsの公式サイトではステージブロックを「Pipeline全体で実行するタスクの明確なサブセット」として定義しています。つまり、ステージ一つが一つのタスクの段階という意味でしょう。ステージの中では一つのタスク単位であるステップを定義し、ステップの中で実行するコマンドを書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>pipeline &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> agent &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Docker環境
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stages &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ステージ名1&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 実行したいコマンド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ステージ名2&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Pipelineそのものに対する説明は以上となります。では、次に実際のPipelineジョブを書いたらどんな形になるのかを紹介します。&lt;/p>
&lt;h3 id="pipelineスクリプト例題">Pipelineスクリプト例題
&lt;/h3>&lt;p>以下のジョブをPipelineで作ると仮定して、簡単な例題を作ってみました。&lt;/p>
&lt;ol>
&lt;li>実行環境はopenjdkコンテナ(rootユーザー)&lt;/li>
&lt;li>Gitでソースコードをチェックアウト(ディレクトリはspringboot)&lt;/li>
&lt;li>gradlewタスクを実行してwarファイルを作る&lt;/li>
&lt;li>出来上がったwarファイルをAzure Blobにアップロード&lt;/li>
&lt;/ol>
&lt;p>これを実際のコードで表現すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>pipeline &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> agent &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> docker &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image &lt;span style="color:#e6db74">&amp;#39;openjdk&amp;#39;&lt;/span> &lt;span style="color:#75715e">// openjdk公式イメージを使用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> args &lt;span style="color:#e6db74">&amp;#39;-u root&amp;#39;&lt;/span> &lt;span style="color:#75715e">// ユーザーをrootに指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stages &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Checkout&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">// Gitチェックアウトステージ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> steps &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> checkout&lt;span style="color:#f92672">([&lt;/span>$class&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;GitSCM&amp;#39;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> branches: &lt;span style="color:#f92672">[[&lt;/span>name: &lt;span style="color:#e6db74">&amp;#39;*/ブランチ&amp;#39;&lt;/span>&lt;span style="color:#f92672">]],&lt;/span> doGenerateSubmoduleConfigurations: &lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">,&lt;/span> extensions: &lt;span style="color:#f92672">[[&lt;/span>$class&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;RelativeTargetDirectory&amp;#39;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> relativeTargetDir: &lt;span style="color:#e6db74">&amp;#39;保存するディレクトリ&amp;#39;&lt;/span>&lt;span style="color:#f92672">]],&lt;/span> submoduleCfg: &lt;span style="color:#f92672">[],&lt;/span> userRemoteConfigs: &lt;span style="color:#f92672">[[&lt;/span>credentialsId: &lt;span style="color:#e6db74">&amp;#39;GitクレデンシャルID&amp;#39;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> url: &lt;span style="color:#e6db74">&amp;#39;https://Gitレポジトリ&amp;#39;&lt;/span>&lt;span style="color:#f92672">]]])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Build&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">// ビルドステージ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> steps &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dir&lt;span style="color:#f92672">(&lt;/span>path: &lt;span style="color:#e6db74">&amp;#39;springbootapi&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">// 作業ディレクトリを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> sh &lt;span style="color:#e6db74">&amp;#39;./gradlew bootWar&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Upload&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">// ビルドしたwarファイルをAzure Blobにアップロードするステージ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> steps &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dir&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;springbootapi/web/build/libs&amp;#39;&lt;/span>&lt;span style="color:#f92672">){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> azureUpload storageCredentialId: &lt;span style="color:#e6db74">&amp;#39;ストレージクレデンシャルID&amp;#39;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> storageType: &lt;span style="color:#e6db74">&amp;#39;blob&amp;#39;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> containerName: &lt;span style="color:#e6db74">&amp;#39;コンテナ名&amp;#39;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> filesPath: &lt;span style="color:#e6db74">&amp;#39;**/*.war&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Finalize&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">// 作業が終わるとワークスペースを削除するステージ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> steps &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cleanWs&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだPipelineのコードに慣れてないと難しいと思われるかもしれませんが、Pipeline Syntaxを活用するとすぐかけるものなので皆さんもぜひ挑戦してみてください。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最初Jenkinsに接した時もこんなに便利なツールがあるとは！と思いましたが、Pipelineの導入でさらに便利かつ明確にタスクがわかるようになっていて驚きました。最近はAzure Pipelinesを少し触る機会があったのですが、そちらのジョブ作成もこのJenkinsのPipelineを意識した感じです。これからのCI/CDツールは多分言語や文法は違っても、どれもこのような形になるのではないかと思うくらい良い変化です。皆さんもぜひJenkinsのPipelineに触れて、快適なビルド・デプロイを楽しんてみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>IOからNIOへ</title><link>https://retheviper.github.io/posts/java-nio/</link><pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-nio/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post IOからNIOへ" />&lt;p>私がそうでしたが、今でも初めてJavaでのI/Oを学ぶとしたら、やはりFileオブジェクトを生成してInputStreamで読み込んだり、OutputStreamで書き込むのが一般的なのではないかと思います。ここで少し発展すると、WriterやReaderなどのクラスを使ったり、StreamをBufferで包んだり、SerializableでオブジェクトのI/Oを行ったりするレベルまで行くのでしょう。&lt;/p>
&lt;p>昔のAPIだとしても、動作や性能に大した問題がなければあえて新しいAPIにコードを全部変える必要はないと思います。むしろ無理やり新しいAPIに書き換えたコードが問題を起こす可能性もあるし、常に優秀とは言えませんので。例えばJava 1.8で追加されたforEach()は便利で、Lambdaが好きな私は多くの場面で使っていますが、実際は今までのJVMは伝統的なforループに最適化されているのでforEach()は性能で劣るらしいです。今後、forEach()の性能がより良くなる可能性もなくはないでしょうが、最近のJavaのバージョンアップ履歴をみると関数型APIの性能改善にどれだけ時間がかかるかは少し謎です。&lt;/p>
&lt;p>新しいAPIを使うということにはこのような問題もあり、慎重ではければならないのですが、それでもAPIが新しくなるのには何らかの理由があるためなので、新しくコードを書いたり簡単なコードに変えたりするなどの理由があれば、積極的に新しいAPIを導入してみるということもそう悪くないと思います。今回紹介したいAPIもまたそのようなものです。ファイルI/Oを扱う新しい方式、NIOです。(と言っても、Java 1.7から導入されたので今はあまり新しくもないですが…)&lt;/p>
&lt;h2 id="nioって何">NIOって何？
&lt;/h2>&lt;p>NIOは、Javaの新しいI/Oのことです。Newの略かと思いがちなのですが、実際はNon-blockingの略らしいですね。JavaはCやC++と比べ遅いですが、その理由の一つがI/Oだったらしいです。なのでそれを改善するために出たのがこのNIOですと。&lt;/p>
&lt;p>BlockingかNon-blockingかによる違い、Stream基盤かChannel基盤かという違いなど様々な違いがありますが、一般的には頻繁なI/Oが要求される場合ではNIOを選択した方がより良い性能を期待できると言います。他には以下のようなメリットがあります。&lt;/p>
&lt;ul>
&lt;li>スレッドのブロックが発生しない&lt;/li>
&lt;li>コードがより簡潔&lt;/li>
&lt;li>コピー、移動、読み込みのオプション指定が簡単&lt;/li>
&lt;li>基本的にBufferを使うので、Buffered~でのラッピングが要らなくなる&lt;/li>
&lt;/ul>
&lt;p>あまりJVMの構造に詳しくないので、私がここで浅い知識を持って説明するようなことはしません。ただ、自分の観点からしてコードがより簡潔になるということは確かなメリットです。なので皆さんにもぜひ使ってみていただきたいと思います。&lt;/p>
&lt;p>それでは、実際のコードでNIOをどう使うかについて説明して行きます。&lt;/p>
&lt;h2 id="file--path">File → Path
&lt;/h2>&lt;p>NIOではFileオブジェクトよりPathオブジェクトを使います。PathはFileオブジェクトに比べ、ファイルパスをディレクトリとファイル名で分離して指定できるのが最大のメリットです。&lt;/p>
&lt;p>例えばファイルパスが複数のフォルダでネストされているとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数のディレクトリとファイルがそれぞれ文字列として存在(path/to/file.txt)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String rootDirectory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;path&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String toDirectory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;to&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String fileName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;file.txt&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この複数の文字列からインスタンスを作成するとしたら、Fileのコンストラクターは引数が一つの文字列なので以下のようになります。ディレクトリの文字列にスラッシュが含まれてないので、文字列を結合しながらスラッシュも一緒にいれる必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Fileオブジェクトの生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>File file &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> File(rootDirectory &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> toDirectory &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> fileName);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Pathの場合は指定できる文字列が複数でも構いません。ディレクトリとファイル名の文字列を順番通り指定するだけで良いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Pathオブジェクトの生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Path path &lt;span style="color:#f92672">=&lt;/span> Paths.&lt;span style="color:#a6e22e">get&lt;/span>(rootDirectory, directory, fileName);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、インスタンスの作成がより便利なのがPathです。また、どうしてもFileオブジェクトが必要な場合があるとしても、FileのメソッドからPathに変換できる機能があるので便利ですね。もちろん、その逆もできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathからFile生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Path path &lt;span style="color:#f92672">=&lt;/span> file.&lt;span style="color:#a6e22e">toPath&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// FileからPath生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>File file &lt;span style="color:#f92672">=&lt;/span> path.&lt;span style="color:#a6e22e">toFile&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にもtoURI()メソッドでURIオブジェクトを生成できるなど、PathにはFileと同じ機能をするようなメソッドが多いので、どちらか便利な方を使いましょう。&lt;/p>
&lt;h2 id="files">Files
&lt;/h2>&lt;p>昔ながらのI/Oでファイルのコピーや削除などの操作を行うためにはInputStream、OutputStream、Writer、Readerなどのクラスを活用してきました。NIOでは主にこれらの作業をFilesクラスを持って行います。また、FilesクラスにはWriterとReader、InputStreamとOutputStreamを生成する機能もあるので使い勝手が良いクラスです。&lt;/p>
&lt;h3 id="ファイルのコピー">ファイルのコピー
&lt;/h3>&lt;p>Filesクラスでのファイルコピーは簡単です。以下のコードを見てください。基本的にコピー元とコピー先のファイルをPathオブジェクトとして指定するだけです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathをPathにコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">copy&lt;/span>(source, target);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>FilesクラスでのコピーにはENUMでコピー時のオプションを指定することもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// オプションを指定(ファイル属性もコピー)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StandardCopyOption option &lt;span style="color:#f92672">=&lt;/span> StandardCopyOption.&lt;span style="color:#a6e22e">COPY_ATTRIBUTES&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">copy&lt;/span>(source, target, option);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、実際存在するファイルではなく、InputStreamをコピー元として指定することもできます。この場合、データをファイルに書き込むということもできますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// InputStreamをPathにコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">copy&lt;/span>(sourceStream, target);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルの削除">ファイルの削除
&lt;/h3>&lt;p>Filesクラスでのファイル削除はコピーと同じく、Pathオブジェクトを引数として渡します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 削除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">delete&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>戻り値がbooleanのメソッドも用意されています。ファイルが存在する場合は削除して、その結果をbooleanとして返します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 存在する場合削除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">deleteIfExists&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルの移動">ファイルの移動
&lt;/h3>&lt;p>ファイルの移動は、コピーと削除の組み合わせみたいなものですね。また、ファイル名を変える場合にも使えます。基本がコピーだからか、コピーの時と同じオプションを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 移動もしくはリネーム&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">move&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// オプションを指定(上書きする)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StandardCopyOption option &lt;span style="color:#f92672">=&lt;/span> StandardCopyOption.&lt;span style="color:#a6e22e">REPLACE_EXISTING&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">move&lt;/span>(path, option);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルの書き込み">ファイルの書き込み
&lt;/h3>&lt;p>InputStreamをcopy()で使えるのですが、ファイル書き込みの場合のメソッドもあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Pathにデータを書き込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">write&lt;/span>(path, content);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>write()メソッドの引数として渡せるのは&lt;code>byte[]&lt;/code>、&lt;code>List&amp;lt;String&amp;gt;&lt;/code>などがあります。また、コピーの場合のようにオプションが指定できます。こちらのオプションではファイルが存在する場合上書きするか、追記するかを選べるので場合によってはcopy()と分けて使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// オプション指定(追記)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StandardOpenOption option &lt;span style="color:#f92672">=&lt;/span> StandardOpenOption.&lt;span style="color:#a6e22e">APPEND&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">write&lt;/span>(path, content, option);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルの読み込み">ファイルの読み込み
&lt;/h3>&lt;p>書き込みが文字列かbyte[]で分けられているように、読み込みも同じ形でファイルを取得できるメソッドがあります。文字列取得の場合、シンタックスシュガーとして結果物がStreamかListかくらいの違いがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 文字列として全行を読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> lines &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">lines&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> liness &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">readAllLines&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// byte[]として読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bytes &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">readAllBytes&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Fileがそうであるように、Pathもまたファイルではなくディレクトリになれるので、Filesのメソッドもそれに対応しています。list()メソッドではディレクトリないのエントリをPathとして取得してStreamを生成します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ディレクトリ内のエントリを要素として持つStream取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream&lt;span style="color:#f92672">&amp;lt;&lt;/span>Path&lt;span style="color:#f92672">&amp;gt;&lt;/span> files &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">list&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ioとの組み合わせで使う">I/Oとの組み合わせで使う
&lt;/h3>&lt;p>先に述べたように、Filesのメソッドの一部は昔ながらのI/Oと組み合わせて使えるものもあります。その一部を紹介します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 読み込みの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InputStream is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BufferedReader br &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newBufferedReader&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 書き込みの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OutputStream os &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BufferedWriter bw &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newBufferedWriter&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もちろんOpenOptionの指定もできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ファイルがない場合は作成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StandardOpenOption option &lt;span style="color:#f92672">=&lt;/span> StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InputStream is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(path, option);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>どうでしたか。同じ機能をするだけならあまり使いたくなるメリットはないように見えるかもしれませんが、実際使ってみると、ENUMによるオプション指定でやりたいことが明確となって、コードの量も減らすことができる便利なクラスを提供するのがNIOだと思います。特にFileはそのまま使うとしても、Filesのメソッドは便利かつ強力なので、皆さんにぜひお勧めしたいものです。&lt;/p>
&lt;p>他にもFilesクラスには双方通信ができるというChannelクラスを提供するメソッドや、ファイルの属性、シンボリックリンクを取得したり指定したPathがディレクトリかを確認したり、二つのPathが同じファイルかをチェックするなど便利なメソッドが多いので、ぜひ使ってみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Nullチェックの地獄から脱出したい</title><link>https://retheviper.github.io/posts/java-optional/</link><pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-optional/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Nullチェックの地獄から脱出したい" />&lt;p>Javaでアプリケーションを組みながら最も遭遇率の高い例外が何かとしたら、それはNullPointerException(NPE)でしょう。初めてプログラミングを接する人に取っては「空白」と「Null」がどう違うのかを理解することもかなり難しいことではないのかと思いますが、Nullを理解できたとしても予想してなかったところで出てくるNPEで苦労する場合は決して少なくないと思います。ある意味、Javaでのアプリケーション開発はNPEとの戦いであるといっても過言ではないのではないでしょうか。&lt;/p>
&lt;p>なので今回は、NPEに対処するための方法を紹介します。Nullをチェックし、安全なコードを書く方法を探してみましょう。&lt;/p>
&lt;h2 id="nullチェックで十分か">Nullチェックで十分か？
&lt;/h2>&lt;p>とある学生の名前を取得するメソッドがあるとしましょう。データオブジェクトを引数として渡すと、そこから順番に学校、学年、組、学生の情報を取得して最後に学生の名前をStringとして返却するようなものです。これをコードで表現したら、例えば以下のように表現できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> School school &lt;span style="color:#f92672">=&lt;/span> data.&lt;span style="color:#a6e22e">getSchool&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Grade grade &lt;span style="color:#f92672">=&lt;/span> school.&lt;span style="color:#a6e22e">getGrade&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassName className &lt;span style="color:#f92672">=&lt;/span> grade.&lt;span style="color:#a6e22e">getClassName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> className.&lt;span style="color:#a6e22e">getStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> student.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをより簡潔なコードで表現するとしたら、以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> data.&lt;span style="color:#a6e22e">getSchool&lt;/span>().&lt;span style="color:#a6e22e">getGrade&lt;/span>().&lt;span style="color:#a6e22e">getClassName&lt;/span>().&lt;span style="color:#a6e22e">getStudent&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このメソッドが意図通りに作動するとしたら、シグネチャーとコードだけで意図と結果が明確なものとなるはずです。しかし、皆さんにもわかるように、このコードにはいつどこでも例外が発生する可能性があります。&lt;/p>
&lt;p>学生の名前フィールドがNullだとしたら？いや、そもそも学生が、もしくは組が、学年が、学校がNullだったら？引数がNullだとしたら？どれもNPEになりうる可能性があるので、極めて危険なコードとなっています。&lt;/p>
&lt;p>ここでまず考えられる対策は、事前にNullチェックの処理を入れNullでない場合にだけ次の処理に移行するようなコードを書くことでしょう。そしてNullだった場合にまた適切な処理(もしくはデフォルト値)を書くことで意図した通りに動かすことができます。&lt;/p>
&lt;p>では、上のコードにNullチェックの処理を入れ、をNull Safeなコードに変えてみましょう。例えば以下のように変えることができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (data &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> School school &lt;span style="color:#f92672">=&lt;/span> data.&lt;span style="color:#a6e22e">getSchool&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (school &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Grade grade &lt;span style="color:#f92672">=&lt;/span> school.&lt;span style="color:#a6e22e">getGrade&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (grade &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassRoom classRoom &lt;span style="color:#f92672">=&lt;/span> grade.&lt;span style="color:#a6e22e">getClassRoom&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (classRoom &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> classRoom.&lt;span style="color:#a6e22e">getStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (student &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String studentName &lt;span style="color:#f92672">=&lt;/span> student.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (studentName &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> studentName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のコードはネストしすぎて、極めて読みづらいコードとなっています。なのでもし一つの項目でもNullチェックが抜けているとしてもわからなくなります。また、コードを直すこともかなり困難になります。メソッドの目的はあくまで、「学生の名前が知りたい」というシンプルな要求に応えるためのものだったのですが、もはやNullチェックが入りすぎてなんのためのロジックなのかわかりづらいですね。&lt;/p>
&lt;p>ネストしている処理を避けるためif文をバラバラにしても結果はあまり変わりません。以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (data &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> School school &lt;span style="color:#f92672">=&lt;/span> data.&lt;span style="color:#a6e22e">getSchool&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (school &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Grade grade &lt;span style="color:#f92672">=&lt;/span> school.&lt;span style="color:#a6e22e">getGrade&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (grade &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassRoom classRoom &lt;span style="color:#f92672">=&lt;/span> grade.&lt;span style="color:#a6e22e">getClassRoom&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (classRoom &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> classRoom.&lt;span style="color:#a6e22e">getStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (student &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String studentName &lt;span style="color:#f92672">=&lt;/span> student.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (studentName &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> studentName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>if文のネストを無くして読みやすくしてみようとしました。でも、このやり方だとむしろreturnが多すぎてこれはこれであまりよくない処理になっています。&lt;/p>
&lt;p>このようなコードはどう直したらいいのか？という時に、使えるAPIをJavaでは用意しています。今回の主題であるOptionalです。&lt;/p>
&lt;h2 id="optionalを導入する">Optionalを導入する
&lt;/h2>&lt;p>現代の言語はこのNullによって起こり得る問題を最初からブロックするため最初からNullを代入することを許さなかったり、Nullになりえるオブジェクトを扱えるAPIを提供したりするようです。例えばKotlinやSwiftではNullableやOptionalを制約の一つとして使っているようで(触ってみたことがないのでこうとしかいえませんが)、Pythonの場合もUnionやOptionaと言ったAPIが用意されているようです。そしてJavaもそう言ったトレンドに答えるべく、Java 1.8でOptionalをAPIとして導入しています。&lt;/p>
&lt;p>Optionalは、Nullになる可能性のあるオブジェクトに対しての新しい(といってもJava 1.8で導入されたのでもうそんなに新くもないですが)方法です。基本的には関数型言語から影響を受けて作られているらしいですね。&lt;/p>
&lt;p>私自身は関数型言語に詳しくないのですが、確かにこのOptionalの使い方をみるとLambda同様、元のJavaの思想とはかなり違うもののような気がします。なぜなら、オブジェクトのNullチェックを比較演算してその後の処理を決めるわけではなく、メソッドの連鎖で決めていくような形になっていて、書き方がかなり異質的だからです。&lt;/p>
&lt;p>なら、そんな異質的なAPIをなぜ使うのか？それはOptionalがどんなものであり、どんな特徴を持っているかをまず見て判断することにしましょう。&lt;/p>
&lt;h3 id="使い方が簡単">使い方が簡単
&lt;/h3>&lt;p>map()やfilter()などCollection&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>やStream&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>と似たような機能をするメソッドがあり、さらに引数としてLambdaを使えるので、CollectionやStreamに慣れていると簡単に適応できます。&lt;/p>
&lt;p>Optionalを効率的に使うためにはメソッドチェーニング&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>やLambdaにまずなれる必要があるので、まずはjava.util.functionsになれるとしましょう。&lt;a class="link" href="../java-functional-interface" >以前のポスト&lt;/a>を参考にしてください。&lt;/p>
&lt;h3 id="見ただけでわかる">見ただけでわかる
&lt;/h3>&lt;p>Optionalはオブジェクトを包み、そのオブジェクトがNullである場合の処理のため作られたAPIです。なのでOptionalで包まれているオブジェクトがあると、そのオブジェクトはNullになる可能性があることを明らかにしているということです。なので戻り値だけでNullになる可能性があるコードを見分けることができるようになります。&lt;/p>
&lt;h3 id="可読性が上がる">可読性が上がる
&lt;/h3>&lt;p>Nullチェックという本来の目的に充実しながらも、コードが簡潔になるので読みやすいコードになります。取得したいオブジェクトがネストしている場合もOptionalで対応できます。最初のオブジェクトのNullチェックをして、さらにネストしているオブジェクトをNullチェックしていくような形です。&lt;/p>
&lt;h2 id="optionalでnullチェックを変えてみましょう">OptionalでNullチェックを変えてみましょう
&lt;/h2>&lt;p>では、実際のコードを持ってOptionalでのNullチェックがどう可能になるのかをコードを持ってみてみましょう。さっきのメソッドは以下のように変えることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Data::getSchool)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(School::getGrade)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Grade::getClassRoom)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Class::getStudent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Student::getName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">orElse&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Optionalが初めての方にはどんなことをしているか一見わからなくなるのではと思いますが、それでもコードの量が減り、可読性がよくなったのはわかるでしょう。もちろん、Nullチェックが省略されているわけでもありません。このように簡潔で分かり安く、安全なNullチェックを可能にするのがOptionalです。&lt;/p>
&lt;h2 id="optionalのメソッド">Optionalのメソッド
&lt;/h2>&lt;p>OptionalはSingletonの&lt;code>java.util.Optional&amp;lt;T&amp;gt;&lt;/code>をインポートしてオブジェクトを包み、包まれたオブジェクトがNullか否かによってどんな挙動をするかのメソッドを持っています。これからそれらのメソッドを一つづつ見ていきましょう。&lt;/p>
&lt;h3 id="empty">empty()
&lt;/h3>&lt;p>空のOptionalを作成します。空のOptionalはその名の通り空で、中にラップされたオブジェクトがNullの状態です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> emtpyName &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">empty&lt;/span>(); &lt;span style="color:#75715e">// StringはNull&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="get">get()
&lt;/h3>&lt;p>Optionalでラップされたオブジェクトを取得する時に使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optinal&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(name.&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// Sato&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="oft-value">of(T value)
&lt;/h3>&lt;p>引数として渡したオブジェクトを包むOptionalを生成します。ただ、引数のオブジェクトがNullの場合はget()の結果もNullになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optinal&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name.&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Null&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ofnullablet-value">ofNullable(T value)
&lt;/h3>&lt;p>引数として渡したオブジェクトを包むOptionalを生成するということではof()と同じですが、引数のオブジェクトがNullだった場合はempty()で生成されたOptionalを返却します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optinal&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name.&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Optional&amp;lt;String&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="mapfunction-super-t--extends-u-mapper">map(Function&amp;lt;? super T, ? extends U&amp;gt; mapper)
&lt;/h3>&lt;p>CollectionやStreamのmap()と似たようなメソッドです。複雑にネストされているフィールドを安全にチェックする時に使います。mapで取り出したオブジェクトは自動的にOptionalでラップされたクラスとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Student sato &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Student(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(sato);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String nameOfSato &lt;span style="color:#f92672">=&lt;/span> student.&lt;span style="color:#a6e22e">map&lt;/span>(Student::getName).&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Optional&amp;lt;Student&amp;gt; -&amp;gt; Optional&amp;lt;String&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで使われている::での表現式はMethod Referenceといい、ターゲットレファレンスとメソッドを書くだけで一般的なLambdaと同じ効果を期待できる書き方です。Lambdaで既存のコードをより簡潔に書くことができるようになりましたが、さらに引数の変数名を省略できるようにしたものですね。変数名を書かなくても指している対象が明確でメソッドも一つだけを呼ぶ場合に使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数を標準出力するLambdaの一般的な書き方&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Consumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> print &lt;span style="color:#f92672">=&lt;/span> name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Method Referenceに変えた形&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Consumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> print &lt;span style="color:#f92672">=&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>::print;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスの生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> String::&lt;span style="color:#66d9ef">new&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="filterpredicate-super-t-predicate">filter(Predicate&amp;lt;? super T&amp;gt; predicate)
&lt;/h3>&lt;p>filter()もまたCollectionやStreamのメソッドに慣れているなら簡単に使えるメソッドの一つです。条件と一致する場合(PredicateによりTrueとなる)にだけ値を返却します。単にNullかどうかの判定だけでなく、何かの処理を付け加えたい時に使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 伝統的なパターン&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getSato&lt;/span>(Student student) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#f92672">=&lt;/span> student.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (name &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> name.&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// filter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getSato&lt;/span>(Student student) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">getName&lt;/span>().&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Student::getName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Optionalの要素は一つしかないのでfilterで指定した条件の結果がfalseの時は以後のメソッドが無視されます。&lt;/p>
&lt;h3 id="ispresent">isPresent()
&lt;/h3>&lt;p>OptionalでラップしたクラスがNullであるかを判定するためのメソッド。Nullでない場合はTrue、Nullの場合はFalseとなるシンプルなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> studentName &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>studentName.&lt;span style="color:#a6e22e">isPresent&lt;/span>(); &lt;span style="color:#75715e">// true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ifpresentconsumer-super-t-consumer">ifPresent(Consumer&amp;lt;? super T&amp;gt; consumer)
&lt;/h3>&lt;p>ラップされたオブジェクトがNullでない場合にだけ実行するメソッドを記述します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name.&lt;span style="color:#a6e22e">ifPresent&lt;/span>(n &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(n));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="orelset-other">orElse(T other)
&lt;/h3>&lt;p>引数として渡したオブジェクトがNullの場合にデフォルト値を使います。このメソッドを使った場合はget()は記述しなくてもよくなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String defaultName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> name.&lt;span style="color:#a6e22e">orElse&lt;/span>(defaultName); &lt;span style="color:#75715e">// student.getName()がNullの場合defaultNameになる&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="orelsegetsupplier-extends-t-other">orElseGet(Supplier&amp;lt;? extends T&amp;gt; other)
&lt;/h3>&lt;p>引数として渡したオブジェクトがNullの場合にデフォルト値として指定したLambdaを実行し、その結果を返却します。このメソッドを使った場合はget()は記述しなくてもよくなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> name.&lt;span style="color:#a6e22e">orElseGet&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> student.&lt;span style="color:#a6e22e">getNumber&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;の名前がありません&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// student.getName()がNullの場合Lambdaを実行する&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="orelsethrowsupplier-extends-x-exceptionsupplier">orElseThrow(Supplier&amp;lt;? extends X&amp;gt; exceptionSupplier)
&lt;/h3>&lt;p>引数として渡したオブジェクトがNullの場合に例外を投げます。このメソッドを使った場合はget()は記述しなくてもよくなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> name.&lt;span style="color:#a6e22e">orElseThrow&lt;/span>((BusinessException::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="optionalで注意すべきこと">Optionalで注意すべきこと
&lt;/h2>&lt;p>Nullチェックで便利で安全なOptionalですが、全ての状況でNullに関する処理を全部Optionalに変える必要はありません。Optionalの導入を検討する時、注意すべきことについて説明します。&lt;/p>
&lt;h3 id="性能を意識する">性能を意識する
&lt;/h3>&lt;p>すでに気づいている方もいらっしゃると思いますが、Optionalはオブジェクトをラップするものなので必然的に性能の低下と繋がります。なのでNullチェックがいる場面では一旦Optionalを使う、ということはあまり良い考えではありません。簡単なNullチェックはOptionalでなくてもできますし、早いです。&lt;/p>
&lt;p>Optionalを使ってオブジェクトがNullの場合の処理を書く際もorElse()よりはorElseGet()を使った方が良いです。orElse()はNullではない場合も必ず実行されるからです。それに対してorElseGet()の場合はLazy&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>なメソッドなのでより良い性能を期待できます。&lt;/p>
&lt;p>ただ、場合によっては(staticなデフォルト値をフィールドとして持っているなど)、orElse()の方を使った方が良いケースもあるのでその場の判断が重要です。返却したいデフォルト値のインスタンスがどこで作成されるかの時点をよく把握しましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例(Nullではない場合捨てられるインスタンス)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Student &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student).&lt;span style="color:#a6e22e">orElse&lt;/span>(Student::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Student &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student).&lt;span style="color:#a6e22e">orElseGet&lt;/span>(Student::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、戻り値としてNullもしくは決まったデフォルト値を期待する場合はOptionalよりもNullチェックの方が良い場合もあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例(常に同じデフォルト値が決まっている場合)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Student defaultStudent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Student &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student).&lt;span style="color:#a6e22e">orElse&lt;/span>(defaultStudent);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Student &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> student &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> student : defaultStudent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ispresentとgetの組み合わせはng">isPresent()とget()の組み合わせはNG
&lt;/h3>&lt;p>isPresent()でオブジェクトがNullかを確認したあと、get()でオブジェクトを取得するようなコードは結局普通のNullチェックと変わりません。デフォルト値を使いたい場合はorElseGet()を、例外としたい場合はorElseThrow()を活用しましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (student.&lt;span style="color:#a6e22e">isPresent&lt;/span>()) { &lt;span style="color:#75715e">// (value != null)の方が良い&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> student.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> NullPointerException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> student.&lt;span style="color:#a6e22e">orElseThrow&lt;/span>(NullPointerException::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、オブジェクトがNullでない場合にだけ処理を行いたい場合なら、ifPresent()を使いましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">adjustScore&lt;/span>(String name, &lt;span style="color:#66d9ef">int&lt;/span> score) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (student.&lt;span style="color:#a6e22e">isPresent&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">setScore&lt;/span>(score);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">adjustScore&lt;/span>(String name, &lt;span style="color:#66d9ef">int&lt;/span> score) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student.&lt;span style="color:#a6e22e">ifPresent&lt;/span>(s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">setScore&lt;/span>(score));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="フィールドでは使わない">フィールドでは使わない
&lt;/h3>&lt;p>そもそもOptionalはフィールドとして使われる場合を想定していないようです。なぜなら、OptionalはSerializableを継承してないからです。なのでDTOなどでフィールドとしてOptionalを使うとNullチェック以前に問題が起こる可能性があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Serializable{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name; &lt;span style="color:#75715e">// 直列化できない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Serializable{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name; &lt;span style="color:#75715e">// 直列化できる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="引数では使わない">引数では使わない
&lt;/h3>&lt;p>メソッドやコンストラクターの引数としてOptionalを使うと、それを呼び出すたびに引数としてOptionalを生成する必要があります。また、内部的にOptionalでNullチェックのロジックが入るのでコードも複雑になりますね。こういう場合、内部でどんな処理が行われ、期待通りの処理になっているかわからなくなるので不便です。&lt;/p>
&lt;p>なのでメソッドやコンストラクターの引数は普通のオブジェクトにして、Nullチェックをした方が使いやすく意図した処理を期待できるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name) { &lt;span style="color:#75715e">// インスタンスを作成するたびOptionalも必要となる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name.&lt;span style="color:#a6e22e">orElseThrow&lt;/span>(NullPointerException::&lt;span style="color:#66d9ef">new&lt;/span>); &lt;span style="color:#75715e">// OptionalでNullチェックおよび代入が必要&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name; &lt;span style="color:#75715e">// 期待通りの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="collectionの中では使わない">Collectionの中では使わない
&lt;/h3>&lt;p>Collectionの中の要素は無理やり入れない限りNullが入らない場合もあれば、Nullチェックに対応するメソッドを含めている場合もあります。そして中の要素は複数になるので、Optionalを要素として使う場合は性能の低下が必然的に起こります。なので要素ではなるべくOptionalを使わないようにしましょう。また、フィールドや引数と同じく要素を追加したり取得する場合に毎回Optionalを経由しなければならないという不便さがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> names &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>names.&lt;span style="color:#a6e22e">add&lt;/span>(Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(name1)); &lt;span style="color:#75715e">// 要素を追加するたびラップが必要&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> names &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>names.&lt;span style="color:#a6e22e">add&lt;/span>(name1);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="collectionはcollectionで">CollectionはCollectionで
&lt;/h3>&lt;p>Collectionが戻り値のメソッドの場合、NullだとCollections.emptyList()やCollections.emptyMap()などで空のCollectionを返却した方が良い場合が多いです。Collectionは&lt;/p>
&lt;p>また、Spring Data JPAを使っている場合はそもそも戻り値がNullだと、自動的に空のListを生成してくれるので尚更Optionalを使う必要がありません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">listStudent&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> students &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">listStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(students);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">listStudent&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> students &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">listStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> students &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> students : Collections.&lt;span style="color:#a6e22e">emptyList&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="intlongdoubleはoptionalでラップしない">int/long/doubleはOptionalでラップしない
&lt;/h3>&lt;p>Optionalのバリエーションでは、一部プリミティブ型のためのクラスも用意されています。int/long/doubleの場合がそうです。これらはOptionalInt、OptionalLong、OptionalDoubleで包む方が良いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(100);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> countNum &lt;span style="color:#f92672">=&lt;/span> count.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OptionalInt count &lt;span style="color:#f92672">=&lt;/span> OptionalInt.&lt;span style="color:#a6e22e">of&lt;/span>(100);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> countNum &lt;span style="color:#f92672">=&lt;/span> count.&lt;span style="color:#a6e22e">getAsInt&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今は使われているJavaのバージョンが古くても、公式サポートなどの理由でJava 1.8以上にバージョンアップするところも多いと聞きます。ならばJavaプログラマーとして、未来に備えJava 1.8の重要なAPIに慣れて置いた方が良いでしょう。そういう意味でFunctionやOptionalは皆さんにもぜひ使ってみて欲しいAPIでもあります。そもそもJavaがこんなにメジャーな言語になり得たのは、開発しやすいというメリットがあったからなので、さらに開発が楽になるAPIは覚えておいて損はないでしょう。&lt;/p>
&lt;p>Javaもかなり古い言語ですが、最近は急激なバージョンアップと共に関数型言語など最近のトレンドを反映して変化しているところもあります。今は性能も書きやすさも優秀な言語が溢れ出している時代ですが、こんなJavaの変化がどこまで続き、いつまで生き残ることができるか気になります。JVMは依然として強力ですが、LLVMなどより性能が優れた技術も続々と登場していますしね。でも、Javaの変化に適応し、大体のAPIを使うことができたら、他の言語にも適応しやすくなるのではと思います。そういう理由ででも、みなさん、Java 1.8以後のAPIは注目してください。では！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>List, Set, Mapなど複数の要素を持つオブジェクトのことを指します。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>ファイルの入出力で使われるInputStreamやOutputStreamではなく、Collectionの要素を一つずつ巡回しながら特定のメソッド(主にLambda)を実行できるようにしてくれるJava 1.8のAPIです。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>戻り値が自分自身のため、何度もメソッドをつなげて書くことのできる仕組み。Builderパターンが代表的なメソッドチェーニングの例です。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>プログラミングでLazyということは、とある処理が常にではなく、呼ばれた際に初めて実行される仕組みのことを意味します。必要な時だけ処理が始まるので不要な処理が減ります。&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>newしたインスタンスの中でBeanを使いたい</title><link>https://retheviper.github.io/posts/spring-bean-with-yaml/</link><pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-bean-with-yaml/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post newしたインスタンスの中でBeanを使いたい" />&lt;p>一般的なJavaプロジェクトなら、外部設定ファイル(YAML)を記載してその値を読み込む場合なら私の&lt;a class="link" href="../java-yaml-for-configuration" >以前のポスト&lt;/a>のようにできます。しかし、今回はSpringプロジェクトとして同じようなことをするようになりました。SpringはYAMLを読み込む時に固有の仕様や使い方がありますね。そしてそうやって読み込んだYAMLの値はBeanに設定することができて、アプリケーションの中ではどこでも&lt;code>@Autowired&lt;/code>を使って呼び出せるというメリットがあります。&lt;/p>
&lt;p>しかし、そんな便利なDIですが、使い方の難点もあります。例えば、普通にnewして使うインスタンスのなかで&lt;code>@Autowired&lt;/code>は使えない問題があるということです。今回もかなりハマっていたことなのですが、Builderでオブジェクトを作成するようにして、使用者が指定してない値はYAMLから取得したBeanを使いたかったです。でもBuilderだと新しいインスタンスを作ってしまうので、Beanを読み込めなくなっていたのでかなりはまりました。&lt;/p>
&lt;p>結果的には違う方法をとると、&lt;code>@Autowired&lt;/code>なしでもBeanを取得することができるということがわかったので、今回のポストではそれに至るまでの過程をコードを持って述べていきたいと思います。YAMLの作成から、newしたインスタンス内でBeanを取得して使う方法を紹介します。&lt;/p>
&lt;h2 id="yamlからbeanを作る">YAMLからBeanを作る
&lt;/h2>&lt;p>Springではapplication.ymlに以下のように記載して、特定のYAMLを読み込むという指定ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spring&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">profiles&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">active&lt;/span>: &lt;span style="color:#ae81ff">buildingdefault&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでactiveに記載したものを使って、カスタムYAMLファイルを準備します。ファイル名のプレフィックスとしては&lt;code>application-&lt;/code>が入ります。なので今回のファイル名は&lt;code>application-buildingdefault.yml&lt;/code>になりますね。&lt;/p>
&lt;p>ファイルを作成して、以下のように項目と値を記載します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">settings&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">material&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cement&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作成したYAMLファイルはsrc/main/resourceにおきます。そしてこれからはSpringでYAMLを読み込むためのクラスを作成します。&lt;/p>
&lt;p>SpringでYAMLを読み込み、Beanを作成する方法は二つがあります。一つ目はまず、フィールドにアノテーションをつけてYAMLの項目と紐づくことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DefaultSettings&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Value&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;${settings.material}&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String material;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>フィールドに&lt;code>@Value&lt;/code>をつけて、アノテーションの引数としてYAMLの項目名を入力します。こうすることでYAMLから読み込まれた値はString形でBeanに取り込まれます。フィールドは必ずStringである必要はなく、intやdoubleなどのプリミティブ型はもちろん、ENUMにも対応しています。Localeならja_JPなどとYAMLに記載しておくと、ちゃんと取り込まれます。&lt;/p>
&lt;p>YAMLの値をBeanにするもう一つの方法は、フィールドではなくクラスにアノテーションをつけることです。以下のように&lt;code>@ConfigurationProperties&lt;/code>の引数にprefixを指定すると、指定した項目の配下にあるもの全てがフィールドのマッピング対象となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConfigurationProperties&lt;/span>(prefix &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;settings&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DefaultSettings&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String material;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="yamlから複数の設定を読み込みたい時">YAMLから複数の設定を読み込みたい時
&lt;/h2>&lt;p>YAMLから設定値を読み込む際に、設定を複数を記載して状況に合わせて使いたい場合もあります。もちろんYAMLでは配列での記載ができますし、Springで読み込む時もこれをListにすることができます。なのでどうやって複数の設定をBeanにするかを説明します。&lt;/p>
&lt;p>YAMLでは以下のように記載します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">settings&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">preset-name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">material&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cement&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">preset-name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;cabin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">material&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;wood&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでpreset-nameは、実際Javaで設定を使う時にそれぞれの設定セットを区別するためのキー的なものです。なくても値を読み込むには問題がないですが、こうやって名前をつけておくとのちにどれがどれかを分かりやすくなりますね。&lt;/p>
&lt;p>YAMLの記載が終わったら、それぞれの設定セットに合わせてBeanクラスを作成しておきます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Material&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String presetName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String material;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後に、YAMLを読み込むクラスを作成します。このクラスにBeanのListをフィールドとして記載すると、Springアプリケーションの起動と同時にこれらの設定が読み込まれることを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConfigurationProperties&lt;/span>(prefix &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;settings&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MultiSettings&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Material&lt;span style="color:#f92672">&amp;gt;&lt;/span> presets;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>のちにこのクラスからListを取得して、presetNameで各設定値を探すだけで簡単に使えるようになります。&lt;/p>
&lt;h2 id="builderからbeanを使う失敗の例">BuilderからBeanを使う(失敗の例)
&lt;/h2>&lt;p>今までの設定で、普通のSpringアプリケーション内ではBeanをDIして使うことができるようになります。しかし、今回はDIなしてBeanを取得する方法を説明するためのポストになっていますので、その過程を説明します。&lt;/p>
&lt;p>まず自分がやりたかったことは、先に述べましたが、Builderの中でYAMLの値を読み込んでいるBeanを使うことでした。ここでYAMLに記載した値はデフォルト値として使われて、必要に応じて一部の項目だけbuild()時に上書きしたいです。まず試して、ダメだったコードは以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Building&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">BuildingBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BuildingBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BuildingBuilder&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// DIができない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> DefaultSettings settings;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String material;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BuildingBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">material&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">settings&lt;/span>.&lt;span style="color:#a6e22e">getMaterial&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Builderを使うと、まずBuilderのインスタンスを新しく生成するしかないです。そしてnewしたインスタンスの中では&lt;code>@Autowired&lt;/code>で記載していても、DIがまともにできません。実際上のようなコードを書くと、BeanのフィールドがNullになっていることを確認できます。&lt;/p>
&lt;p>なのでDIのことは忘れて、newしたインスタンスの中でBeanを取得できる方法をとります。&lt;/p>
&lt;h2 id="applicationcontextproviderを作る">ApplicationContextProviderを作る
&lt;/h2>&lt;p>ApplicationContextは、SpringでBeanの生成やオブジェクト間の関係設定など様々な機能を担当するインタフェースです。ここで重要なのは、ApplicationContextがSpringアプリケーションを起動する時予め登録されたBeanを生成して管理するということです。つまり、このインタフェースにアクセスできればBeanを取得できるということになります。&lt;/p>
&lt;p>ただ、ApplicationContextそのものはあくまでインタフェースであるため、インスタンスを取得するためにはその役割をするクラスを作成する必要があります。以下のコードでインスタンスを取れるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ApplicationContextProvider&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> ApplicationContextAware {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ApplicationContext context &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ApplicationContext &lt;span style="color:#a6e22e">getApplicationContext&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">context&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setApplicationContext&lt;/span>(ApplicationContext context) &lt;span style="color:#66d9ef">throws&lt;/span> BeansException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">context&lt;/span> &lt;span style="color:#f92672">=&lt;/span> context;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>構造は簡単で、フィールドにApplicationContextがあって、それに対するGetterとSetterがあるだけです。これで動くのも不思議ですが、Springアプリケーションが動作すると自動的にApplicationContextのインスタンスがSetterを通じてフィールドにセットされます。ただ、このクラスのインスタンをnewしては使えなくなるのでフィールドとGetterはstaticにしておきます。&lt;/p>
&lt;h2 id="builderからbeanを使う成功の例">BuilderからBeanを使う(成功の例)
&lt;/h2>&lt;p>それでは、ApplicationContextのインスタンスを取得できるようになりましたので、Builderを修正します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Building&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">BuildingBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BuildingBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BuildingBuilder&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> DefaultSettings settings;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BuildingBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">settings&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ApplicationContextProvider.&lt;span style="color:#a6e22e">getApplicationContext&lt;/span>().&lt;span style="color:#a6e22e">getBean&lt;/span>(DefaultSettings.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さっき作成したApplicationContextProviderクラスからApplicationContextを取得して、さらにgetBean()を呼び出します。このgetBean()に引数として取得したいBeanのクラスを渡すと、そのBeanのインスタンスを取得することができます。もちろんコンストラクターではなく、フィールドそのものに書くこともできます。そうする場合は以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Building&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#a6e22e">BuildingBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BuildingBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BuildingBuilder&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> DefaultSettings settings &lt;span style="color:#f92672">=&lt;/span> ApplicationContextProvider.&lt;span style="color:#a6e22e">getApplicationContext&lt;/span>().&lt;span style="color:#a6e22e">getBean&lt;/span>(DefaultSettings.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BuildingBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修正したコードを動かしてみると、BeanのフィールドがNullではなくちゃんとYAMLから読み込んだ値が入っていることを確認できます。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>Springを使いながら、恥ずかしくも実際アプリケーションの内部ではどんなことが起きているかを知らなかったので今回は失敗したのではないかと思います。ただ単に動くことを確認するだけでなく、こうして自分の使っている言語やフレームワークの特性をちゃんと理解していないとこのようにハマることはなかったでしょう。なので新しい知識を得た同時に、自分に対する反省もすることになりました。これからはちゃんと自分が使っているものはどう、なぜ動くのかをちゃんと理解してから使わないとですね。&lt;/p></description></item><item><title>SpringのDIはコンストラクターでしましょう</title><link>https://retheviper.github.io/posts/spring-dependency-injection/</link><pubDate>Mon, 09 Dec 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/spring-dependency-injection/</guid><description>&lt;img src="https://retheviper.github.io/images/spring.webp" alt="Featured image of post SpringのDIはコンストラクターでしましょう" />&lt;p>Springの代表的な特徴といえば、それは色々ありますが、一つをあげるとしたらやはり&lt;code>@Autowired&lt;/code>によるDI&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>ではないかと思います。初めてSpringに接したときはオブジェクトが&lt;code>new&lt;/code>なしでも動くと言うことが何ともいえない不思議なことに見えました。これがデザインパターンの一つであるということを知ってからはますますすごいなぁと思いましたね。やはり良いコードを書くためには、様々な方面での工夫が必要なものですね。&lt;/p>
&lt;p>とにかく、こうも重要で便利なDIですが、最近Spring Bootを触りながら気になったことがありました。今までは当たり前のように、&lt;code>@Autowired&lt;/code>はフィールドに宣言していましたが、今回の案件ではコンストラクターにつけている場合がありました。なぜ一部はフィールドにつけ、一部はコンストラクターにつけるんだろう？と思いましたね。結果的には全てのアノテーションをコンストラクターにつけることになりましたが、それが特にフィールドにつける場合との違いを理解させたわけではないので、少し調べてみました。&lt;/p>
&lt;p>結論からいうと、大概の場合に&lt;code>@Autowired&lt;/code>はフィールドよりはコンストラクターにつけた方がいいらしいです。そしてこれを(フィールドやコンストラクターに&lt;code>@Autowired&lt;/code>をつけることを)、それぞれ「フィールドインジェクション」と「コンストラクターインジェクション」と呼ぶらしいです。では、これらをコードを持って説明していきましょう。&lt;/p>
&lt;h2 id="field-injection">Field Injection
&lt;/h2>&lt;p>まずインジェクションのために以下のようなコンフィギュレーションクラス&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>を定義したとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Mapper&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> ModelMapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Mapper mapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ModelMapper();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでは&lt;a class="link" href="http://modelmapper.org/" target="_blank" rel="noopener"
>ModelMapper&lt;/a>を使ってみます。ModelMapperに関しては、以前のポストにも書きましたが、互いにマッチングするGetter/SetterのあるBean同士のマッピングを自動で行ってくれる便利なライブラリーです。&lt;/p>
&lt;p>こうしてSpringでBeanを登録し、Autowiredアノテーションをフィールドにつけるサービスクラスの例が以下です。これをフィールドインジェクションと呼びます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ItemServiceImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> ItemService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Mapper mapper;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>自分が最初にSpring Frameworkについて学んだ時はこのようなフィールドインジェクトションが一般的でした。しかし、フィールドインジェクションでは致命的な問題があリます。ここでフィールドがNullだった場合もプログラムは動作するということです。クラスの動作に必要な要件が整ってないのにもかかわらず、プログラムが動作してしまうのはバグを呼ぶこととなりますね。なのでフィールドインジェクションはよくないです。&lt;/p>
&lt;h2 id="setter-injection">Setter Injection
&lt;/h2>&lt;p>実は、インジェクションはSetterを通じても可能らしいです。あまり一般的な方式ではありませんが、これをセッターインジェクションと呼び、コードで表現すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ItemServiceImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> ItemService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Mapper mapper;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setMapper&lt;/span>(Mapper mapper) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">mapper&lt;/span> &lt;span style="color:#f92672">=&lt;/span> mapper;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Setterによるインジェクションの問題は、フィールドインジェクションと同じです。Setterで必要なオブジェクトが注入されたかどうかと関係なくプログラムは動く可能性がありますね。この問題を解決できるのが、次に紹介するコンストラクターインジェクションです。&lt;/p>
&lt;h2 id="constructor-injection">Constructor Injection
&lt;/h2>&lt;p>コンストラクターによるインジェクションはコンストラクターインジェクションと呼び、コードは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ItemServiceImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> ItemService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Mapper mapper;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ItemServiceImpl&lt;/span>(Mapper mapper) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">mapper&lt;/span> &lt;span style="color:#f92672">=&lt;/span> mapper;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンストラクターによるインジェクションの良い点は、先に述べたような問題が発生する可能性をブロックできるということです。これはSpringというよりJavaの言語仕様の話ですが、コンストラクターで引数の要件が満たされてないクラスはインスタンスを生成できませんね。そしてNullを注入しない限り、NullPointerExceptionは発生しなくなります。&lt;/p>
&lt;p>また、コンストラクターインジェクションだと、循環参照&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>の問題を事前に防ぐことができるというメリットがあります。フィールドインジェクションやセッターインジェクションでは実際のコードが呼ばれるまでは問題を発見することができませんが、コンストラクターインジェクションで循環参照が発生する場合はSpringアプリケーションを起動する時に警告が出力されます。&lt;/p>
&lt;p>また、フィールドインジェクションの場合はそのクラスの単体テストができないという問題もあります。Autowiredアノテーションがついているフィールドに対してオブジェクトを注入できる方法がないですので。Setterを使うと一旦注入はできるようになりますが、あえてSetterを使う理由はないですね。&lt;/p>
&lt;p>コンストラクターインジェクションが良いもう一つの理由は、フィールドをfinal宣言できるということです。フィールドにfinalをつけることでクラス内でオブジェクトが変更されることを防止できるので、より安全になります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今までは自分も当たり前のことのようにフィールドインジェクションを使っていましたが、フィールドインジェクションの問題を知ってからはなるべくコンストラクターインジェクションとしてコードを書くようにしています。あえてそうしなくても、IntelliJでは常にコンストラクターインジェクションを使うことと警告まで出すみたいで、Springの公式のドキュメントでもそういう言及がありました。これは今までの認識を変えざるを得ません。&lt;/p>
&lt;p>SpringだけでなくJavaコーディングの話をすると、コンストラクターは基本的に書かなくても暗黙的に引数なしのものが生成されるのがJavaの仕様ですね。Singletonクラスや引数の初期化なしで動くと問題になるクラスではこれを防ぐためにわざとコンストラクターを書くこととなっています。なので常にコンストラクターは明示的に書いておく習慣も大事ですね。こういうことも含めて考えると、コンストラクターを記述することの重要性がわかるような気もします。やはり良いコードを書くには、様々な方面での工夫は必要なものですね！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Dependency Injection(依存性の注入)。ネット上に詳しい説明が多いので深くは入りませんが、簡単に概念を説明するとオブジェクトを外部から生成してコードに入れることでオブジェクトの依存性をコードから独立させることを意味します。注入されたオブジェクトはコードに依存してないので、どこで呼ばれても同じものとして機能することができます。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Configurationアノテーションをつけると自動的にSpring内で設定クラスとして認識されます。ここでオブジェクトをBeanとして定義すると、DIができるようになります。以前はxmlファイルに記入しておく場合もありました。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>循環参照とは、複数のオブジェクトが互いを参照していることを意味します。例えばAクラスのインスタンスを生成する時にBを参照することとなっていて、BクラスもAクラスを参照することとなっていると、どちらかのインスタンスを作成する時に互いの参照を繰り返す無限ループに落ちてしまいます。この無限ループの果てはStackOverflowですね。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>ルーターにSSL証明書を入れる</title><link>https://retheviper.github.io/posts/linux-implementation-ssl-in-router/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/linux-implementation-ssl-in-router/</guid><description>&lt;img src="https://retheviper.github.io/images/linux_terminal.webp" alt="Featured image of post ルーターにSSL証明書を入れる" />&lt;p>実家で使っているルーターは、Asus社のRT-AC58Uです。そして個人的に使っているものは同じくASUS社のRT-AC68U。この二つは単にマシンスペックだけでなく、ファームウェアレベルで提供している機能も少し違います。例えばAiMeshといった機能はRT-AC58Uでは対応していません。&lt;/p>
&lt;p>そしてこないだファームウェアをアップデートすると、管理ページにWANからアクセスするにはhttpsしかできないという制約ができました。RT-AC68Uの場合は&lt;a class="link" href="https://letsencrypt.org" target="_blank" rel="noopener"
>Let&amp;rsquo;s encrypt&lt;/a>でSSL証明書&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>を作成して更新まで自動で行われる機能を持っているので特に問題はないですが、残念ながらRT-AC58Uはそうではないです。なのでいつもブラウザからRT-AC58Uの管理ページに接続すると証明書がおかしいと怒られます。&lt;/p>
&lt;p>これから修正される可能性もなくはないと思いますが、最近は&lt;a class="link" href="https://ja.wikipedia.org/wiki/IEEE_802.11#IEEE_802.11ax" target="_blank" rel="noopener"
>802.11ax&lt;/a>に対応した新型が続々と登場しているので、もう古くなってしまったRT-AC58Uのファームウェアバージョンアップがいつまで続くかわからない状態です。そして毎回証明書がおかしいと怒られるのをみると少し不安になりますね。&lt;/p>
&lt;p>実家と家のルーターの場合、ソフトウェアそのものはそう変わらないだろうと思って調べてみたらやはりそうでしたので、手動でもSSL証明書を入れられる方法がありそうな気がしました。もっと調べてみるとOSはLinuxであって、結論から言うと58Uにも証明書を入れることは成功しました。&lt;/p>
&lt;p>今回はそのSSL証明書をRT-AC58Uに適用させるまでの方法を記載します。&lt;/p>
&lt;h2 id="システム構成">システム構成
&lt;/h2>&lt;p>現在のシステム構成図を絵で表現するとこちら。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/linux-implementation-ssl-in-router/ssl_organization.webp"
width="1563"
height="423"
srcset="https://retheviper.github.io/posts/linux-implementation-ssl-in-router/ssl_organization_hu_b0d8d6cfdbe7072f.webp 480w, https://retheviper.github.io/posts/linux-implementation-ssl-in-router/ssl_organization_hu_da62ad2e50f160cd.webp 1024w"
loading="lazy"
alt="構成図"
class="gallery-image"
data-flex-grow="369"
data-flex-basis="886px"
>&lt;/p>
&lt;p>ここでやりたいことは、DDNS&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>を登録したルーターにSSL証明書を入れ、httpsで接続した管理ページで怒られないようにすることです。これを試した理由のもう一つはのちにこのルーターの下にホームサーバーとして機能するLinuxのマシンもおきたいからでもあります。ホームサーバーにはのちに簡単なWebアプリケーションを置いて運用する予定で、今回試したことが成功したら同じ仕組みでそちらにもSSL証明書を適用できると思います。&lt;/p>
&lt;p>それでは、自分がどうやってSSL証明書を作成してルーターにアップロードし、適用したかを述べていきます。&lt;/p>
&lt;h2 id="ルーターの設定1">ルーターの設定(1)
&lt;/h2>&lt;p>ルーターではまず、DDNS設定が必要です。ASUS社のルーターの場合、Chromeなどのブラウザーから&lt;code>http://router.asus.com&lt;/code>を入力するとローカルのルーターの管理ページにアクセスできます。そして「詳細設定」メニューから「WAN]を選び、さらにDDNSのタブに入って好みのアドレスとして登録します。ASUS社のルーターはasuscomm.comという無料のサーバーを提供しているのでそちらを使いましょう。DDNSの登録ができたら、「管理」メニュー配下の「システム」タブで「WANからの接続を許可」を「はい」にしておきます。私は家から接続するために事前に実家のルーターで予めDDNSの設定をしておきました。&lt;/p>
&lt;p>DDNSでの管理ページ接続設定が終わったら、次はルーターへのSSH接続を設定します。こちらも同じく「管理」ページから設定することができます。SSHを接続設定が終わったらテストをして、なるべく公開鍵でアクセスできるようにして、ポート番号も変えておきましょう。SSHのポートを変えた場合は、ターミナルでは以下のコマンドでアクセスできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># SSHのポートが2022の場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ssh -p &lt;span style="color:#ae81ff">2022&lt;/span> retheviper@javaman.asuscomm.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SSH時のIDとアドレスは管理ページのIDとDDNSで登録したものとなります。ここまでできたらSSL証明書を作成するためのルーター側の準備はまず終わります。&lt;/p>
&lt;h2 id="macでの設定1">macでの設定(1)
&lt;/h2>&lt;p>ルーターのOSはLinuxとなっていますが、やはり重要なコマンドがいくつか足りていないです。代表的にパッケージ管理用の&lt;code>yum&lt;/code>や&lt;code>apt&lt;/code>、&lt;code>dnf&lt;/code>のどちらも搭載されていなく、CPUの性能も怪しいので重要な作業はまずmacで行うことにしました。&lt;/p>
&lt;p>また、SSL証明書自体はRT-AC68Uで対応しているLet&amp;rsquo;s encryptを使います。こちらは有効期間が90日にすぎないですが、発給も更新も無料となっているのでこういう簡単な作業で使うには最適です。&lt;/p>
&lt;p>まず、ターミナルでLet&amp;rsquo;s encryptをインストールします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>brew install letsencrypt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インストールが終わったら、&lt;code>certbot&lt;/code>コマンドで証明書を作成できます。ただ、証明書を作成する前にDDNSを登録して置く必要があります。私はすでにルーターで提供している機能でドメインを登録してあるので、それをそのまま使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo certbot certonly --manual
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コマンドを入力すると以下のような画面が出力されます。ただ、自分は何回か同じコマンドを実行しているので初めての実行で出力される画面は少し違う可能性はあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Saving debug log to /var/log/letsencrypt/letsencrypt.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Plugins selected: Authenticator manual, Installer None
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Please enter in your domain name&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>comma and/or space separated&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Enter &lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>to cancel&lt;span style="color:#f92672">)&lt;/span>: &lt;span style="color:#f92672">[&lt;/span>ドメイン&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ルーターで使っているDDNSのドメインを入力してエンターを押下すると次の画面へ。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Obtaining a new certificate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Performing the following challenges:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>http-01 challenge &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">[&lt;/span>ドメイン&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NOTE: The IP of this machine will be publicly logged as having requested this
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>certificate. If you&lt;span style="color:#e6db74">&amp;#39;re running certbot in manual mode on a machine that is not
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">your server, please ensure you&amp;#39;&lt;/span>re okay with that.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Are you OK with your IP being logged?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>Y&lt;span style="color:#f92672">)&lt;/span>es/&lt;span style="color:#f92672">(&lt;/span>N&lt;span style="color:#f92672">)&lt;/span>o: Y
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>IPが記録されることに同意しますかという質問が表示されます。同意するしかないので&lt;code>Y&lt;/code>を入力。すると以下の画面が現れます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Create a file containing just this data:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>コード&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>And make it available on your web server at this URL:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>httpアドレス&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Press Enter to Continue
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この画面で一旦作業を止め、画面に表示されるコードとURLはコピーしておきましょう。あとでここに戻ってきます。&lt;/p>
&lt;h2 id="pcでの設定">PCでの設定
&lt;/h2>&lt;p>先ほど出力された画面は、「このURLにリクエストを送るので、このコードがレスポンスとして取得できるようにしてください」という意味です。なので一時的にサーバーを立てて、レスポンスできるようにしておく必要があります。&lt;/p>
&lt;p>ただ単にサーバー上でアクセスできるファイルを作る方法もありますが、別の方法を試すことにしました。準備するものはルーターに繋がっているPC上でレスポンスの提供ができるサーバーを立てること。ルーターの性能が十分であればルーターでやっても良いのですが、自分のRT-AC58UはPythonをダウンロードして圧縮ファイルを解凍するだけでもしばらく死んでいました。ここではPCにNode.jsを使って簡単サーバーを作ってみます。他にPythonやRubyなどを使っても構いません。これはあくまで自分が最速でサーバーを立てられる方法がNode.jsだっただけです。&lt;/p>
&lt;p>実家のPCはWindowsなので、&lt;a class="link" href="https://nodejs.org" target="_blank" rel="noopener"
>公式ホームページ&lt;/a>からNode.jsをダウンロードしてインストールします。また、expressを使ってサーバーを構築することにします。インストールが終わったらコマンドラインからnpmを使えるようになリます。以下のコードでexpressのスタータープロジェクトを作ることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmd" data-lang="cmd">&lt;span style="display:flex;">&lt;span>&amp;gt; mkdir node
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; cd node
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; npm install express
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このあとはVSCodeなどのテキストエディタを使って、以下のコードを作成します。ファイル名は&lt;code>app.js&lt;/code>にして、先ほどexpressをインストールしたフォルダに保存します。先ほどコピーしておいたURLとコードはは忘れずに入力しておきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">express&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;express&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> , &lt;span style="color:#a6e22e">http&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">require&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;http&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> , &lt;span style="color:#a6e22e">app&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">express&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> , &lt;span style="color:#a6e22e">server&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">createServer&lt;/span>(&lt;span style="color:#a6e22e">app&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">app&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;/[コピーしておいたhttpアドレス]&amp;#39;&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span> (&lt;span style="color:#a6e22e">req&lt;/span>, &lt;span style="color:#a6e22e">res&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;コピーしておいたコード&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">server&lt;/span>.&lt;span style="color:#a6e22e">listen&lt;/span>(&lt;span style="color:#ae81ff">80&lt;/span>, &lt;span style="color:#66d9ef">function&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;Express server listening on port &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">server&lt;/span>.&lt;span style="color:#a6e22e">address&lt;/span>().&lt;span style="color:#a6e22e">port&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ファイルを保存したらコマンドラインから実行して、サーバーを起動します。以下のコマンドで実行できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cmd" data-lang="cmd">&lt;span style="display:flex;">&lt;span>&amp;gt; node app.js
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>サーバーが起動したら、ローカルからアクセスできるか確認します。ブラウザーでURLを入力してみて、ちゃんとコードが表示されるかを確認できたらPCでの設定は終わりです。&lt;/p>
&lt;h2 id="macでの設定2">macでの設定(2)
&lt;/h2>&lt;p>PCでサーバーを起動している状態でmacに戻ります。エンターを押下するとサーバーとの通信が始まって、結果として以下の画面が出力されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Waiting &lt;span style="color:#66d9ef">for&lt;/span> verification...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cleaning up challenges
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IMPORTANT NOTES:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - Congratulations! Your certificate and chain have been saved at:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /etc/letsencrypt/live/javaman.asuscomm.com/fullchain.pem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Your key file has been saved at:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /etc/letsencrypt/live/javaman.asuscomm.com/privkey.pem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Your cert will expire on 2020-02-14. To obtain a new or tweaked
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version of this certificate in the future, simply run certbot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> again. To non-interactively renew *all* of your certificates, run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;certbot renew&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - If you like Certbot, please consider supporting our work by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Donating to ISRG / Let&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>s Encrypt: https://letsencrypt.org/donate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Donating to EFF: https://eff.org/donate-le
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SSL認証書の作成が無事完了しました。この画面からは認証書が保存された位置と、満了日を確認できます。また、cerbot renewを入力すると更新ができるということを教えてくれます。&lt;/p>
&lt;p>SSL証明書を作成したので、あとはルーターにコピーして適用するだけです。まず画面に表示されたパスに入って、以下のファイルをコピーしておきましょう。&lt;/p>
&lt;ul>
&lt;li>cert.pem&lt;/li>
&lt;li>key.pem&lt;/li>
&lt;/ul>
&lt;p>コピーができたら、ルーターに接続します。&lt;/p>
&lt;h2 id="ルーターでの設定2">ルーターでの設定(2)
&lt;/h2>&lt;p>SSHでルーターに接続して以下のパスに移動します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cd /tmp/etc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ディレクトリー内のファイルをみると、先ほどコピーしておいたファイルと同じものが置かれてあるのを確認できます。viでファイルをあけ、先ほどコピーしておいたもので上書きします。&lt;/p>
&lt;p>cert.pemとkey.pemの上書きが終わったら、次にルーター内でのプロセス目録を確認します。すでに管理ページがhttpdsのサービスとして実行されているため、新しい証明書を適用するためには一回サービスを終了して再実行する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ps
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のコマンドを入力すると、現在実行中のプロセスの目録が出力されます。そのうち、&lt;code>httpds -s -i br0 -p 8443&lt;/code>があればそれを終了させます。8443は管理ページで指定したデフォルトのポート番号です。プロセスの左に出力されるのがプロセスのID(PID)なので覚えておきましょう。その後は以下のコマンドを入力します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># PIDが562の場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ kill &lt;span style="color:#ae81ff">562&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># プロセスの再実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ /usr/sbin/httpds -s -i br0 -p &lt;span style="color:#ae81ff">8443&lt;/span> &amp;amp;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>&amp;amp;&lt;/code>を入力しないと他のコマンドを入力できなくなるので注意しましょう。入力が終わり、もう一度&lt;code>ps&lt;/code>を入力してちゃんとプロセスが起動していたらこちらでの設定は終わり。&lt;code>exit&lt;/code>を押してsshから抜け出した後は、ブラウザからルーターの管理ページに接続して証明書で怒られるかを確認します。今までの過程で特に問題なかったら、問題ないはずです。&lt;/p>
&lt;p>ただ一つ、注意しなければならないことはルーターの再起動です。自分は週に一回は再起動するようにしていますが、こういう場合はせっかく入れたSSL証明書の値が初期化されるみたいです。なので再起動はなるべくしないか、再起動後には証明書を入れ直す必要があります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>以上のことで特に問題がなかったら、WANからルーターの管理ページにアクセスしても証明書がおかしいと怒られるようなことはなくなります。これで安心して外からの管理ができますね！&lt;/p>
&lt;p>ただ、これで全てが完璧になったわけではないです。残りのタスクは以下です。&lt;/p>
&lt;ul>
&lt;li>証明書の更新はどうするか&lt;/li>
&lt;li>ルーターの再起動にどう対応するか&lt;/li>
&lt;/ul>
&lt;p>Let&amp;rsquo;s encryptで作成してもらった証明書は有効期間が90日なので、のちに更新する必要があります。更新自体はcertbotのコマンドを打つだけで簡単に終わりますが、更新後の処理(ルーターにアップロードする、アプリケーションを再起動する)が必要となりますね。こちらは&lt;code>crontab&lt;/code>でスケジューリングすると何んとかなりそうですが、残念ながらルーターにはコマンドとして入ってなかったです。&lt;/p>
&lt;p>ルーターが再起動した時もどう対応できるかは検証対象ですね。最初はscpでファイルを上書き、httpsdプロセスも再起動するようなシェルスクリプトを作ることで対応できるかと思ったら、権限問題があったりするのでより簡単にできる方法はないか考えています。&lt;/p>
&lt;p>ま、結果的にLinuxでサーバー構築ができたらWANからルーターの管理ページに接続するようなことはなくなる可能性もなくはないですが。とにかく何かわかったらまたポストとして書くことにしましょう。&lt;/p>
&lt;p>それでは、皆さんもぜひ、SSL証明書で安全かつ快適なWeb生活を！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>SSL証明書とは、このサーバーは信頼できるかを証明してくれる電子文書のことです。SSL証明書を適用することによりhttpsでの通信は第三者の攻撃より守られます。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Dynamic Domain Name Systemの略で、家庭用のルーターはIPアドレスが動的に変わることが多いですが、これを文字列のホスト名とつなげてくれる便利なサービスです。ルーターのIPアドレスがどうかわろうが、DDNSの設定ができていたらいつでも同じURLからルーターにアクセスできます。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>外部設定ファイルを扱うクラスを作る</title><link>https://retheviper.github.io/posts/java-yaml-for-configuration/</link><pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-yaml-for-configuration/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post 外部設定ファイルを扱うクラスを作る" />&lt;p>アプリケーションを作る場合、考慮しなければならないことの一つは「設定ファイルを作る」ことです。設定値のデータがアプリケーションの内部にあると、ディコンパイルしない限りそれを変えられる方法がなくからですね。なので一般的にはアプリケーションの柔軟性のためにも動的に変える必要のある設定値はアプリケーションの外に別途のファイルとして置く場合が多いです。ゲームでいえばセーブファイルみたいなものですね。&lt;/p>
&lt;p>外部のファイルを読み込むことに関してはすでに様々な方法があるとは思いますが、今回は自分で使っている方法を共有します。簡単に、外部設定ファイルは&lt;a class="link" href="https://ja.wikipedia.org/wiki/YAML" target="_blank" rel="noopener"
>YAML&lt;/a>で記載してプログラムの起動時に読み込んでシングルトンクラスのフィールドとして持す方法です。I/Oを一回だけにできて、どこからも参照できるというメリットがあります。設定ファイルのフォーマットとしてYAMLを選定したのは、書きやすく読みやすいというメリットもあって、自分が主に扱っているSpringで使っているためでもあります。JSONでも問題はないですが、項目が増えるほどJSONは読みづらくなるので…&lt;/p>
&lt;p>とにかく、準備するものはYAMLを読み込むためのライブラリーです。ここでは&lt;a class="link" href="https://bitbucket.org/asomov/snakeyaml/src/default" target="_blank" rel="noopener"
>SnakeYaml&lt;/a>を使います。ファイルを読み込んでオブジェクト化するだけなので他のライブラリーを使っても構いません。&lt;/p>
&lt;p>では、まず以下のようなYAMLファイルがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Development&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;develop&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">use_local_storage&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Debugging&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;debug&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">use_local_storage&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DevelopmentとDebuggingという二つのケースでそれぞれ違う値を使いたい、というシナリオで簡単に書いてみました。これを利用するコードは以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 共用の設定情報クラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Settings&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// シングルトンクラスなので自分のインスタンスを持っている&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Settings UNIQUE_INSTANCE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Settings();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 設定ファイルから読み込んだ値を一次的に入れておくためのフィールド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> SETTINGS_FROM_FILE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 設定ファイル名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String SETTINGS_FILENAME &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;application-settings.yml&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Developmentの設定情報が入るMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Getter&lt;/span>(lazy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> developmentSettings &lt;span style="color:#f92672">=&lt;/span> setDevelopmentSettings();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Debuggingの設定が入るMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Getter&lt;/span>(lazy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> debuggingSettings &lt;span style="color:#f92672">=&lt;/span> setDebuggingSettings();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// イニシャライザーブロックで最初からファイルを読み込む処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルを指定して読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassLoader classloader &lt;span style="color:#f92672">=&lt;/span> UNIQUE_INSTANCE.&lt;span style="color:#a6e22e">getClassLoader&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL resource &lt;span style="color:#f92672">=&lt;/span> classloader.&lt;span style="color:#a6e22e">getResource&lt;/span>(SETTINGS_FILENAME);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStreamReader reader &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> InputStramReader(resource.&lt;span style="color:#a6e22e">openStream&lt;/span>())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 読み込んだYAMLファイルをパースしてMapに値を取り込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Yaml yaml &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Yaml();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> importedMap &lt;span style="color:#f92672">=&lt;/span> autoCast(yaml.&lt;span style="color:#a6e22e">load&lt;/span>(reader));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 読み込んだ値をフィールドのMapに移す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map.&lt;span style="color:#a6e22e">Entry&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> entry : importedMap.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SETTINGS_FROM_FILE.&lt;span style="color:#a6e22e">put&lt;/span>(entry.&lt;span style="color:#a6e22e">getKey&lt;/span>(), entry.&lt;span style="color:#a6e22e">getValue&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IOException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 例外処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// コンストラクターは外部からアクセスできない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">Settings&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Lazy Getterで要請が入った時点でインスタンスを作るためのメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">setDevelopmentSettings&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableMap&lt;/span>(SETTINGS_FROM_FILE.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Development&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Lazy Getterで要請が入った時点でインスタンスを作るためのメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">setDebuggingSettings&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableMap&lt;/span>(SETTINGS_FROM_FILE.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Debugging&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 外部からインスタンスを取得するためのGetter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Settings &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> UNIQUE_INSTANCE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オブジェクトのキャストをより簡単にするためのメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@SuppressWarnings&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unchecked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> T &lt;span style="color:#a6e22e">autoCast&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Object object) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (T)object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここではLazy Getterを使ってDevelopmentとDebuggingの設定のフィールドが、get要請が入った時点でインスタンスが作られるようにしています。こうしている理由は、イニシャライザーブロックでファイルを読み込んだ後から個別フィールドに値を入れたい + フィールドはprivate finalにしたい + Settingsクラスはシングルトンとしてプログラムの起動時にインスタンスが生成されるようにしたいからです。Lazy Getterを設定しておくとprivate finalを維持しつつ、フィールドの初期化は後に担保できて、一度インスタンスが生成されるとキャッシュとして残りますので便利です。もしこうでなく、コンストラクターやフィールドで初期化しようとするとその時点がファイルを読み込む前となってしまうので注意しましょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回紹介したコードを使うと、設定クラスはシングルトンクラスとしてアプリケーションの起動時にインスタンスが生成され、その時ファイルを読み込んでMapとしてメモリー上に載せ、どこからでも固定された値をGetterで取得できます。もしYAMLの設定がより深くネストしたり、項目が増えたり、ファイル名が変わったりする場合はMapとフィールドを調整するだけで簡単に変更ができますね。&lt;/p>
&lt;p>単純に動くだけでなく、維持補修が簡単で無駄のないコードを書くことこそが重要なので、何か頻繁に変わるデータを扱うためにはこう言った仕組みを(自分が紹介したものと同じではなくても)考える必要があるのでは、と思います。これからもどんなものが良いコードなのかを常に意識しないと、ですね。&lt;/p></description></item><item><title>Javaの色々なコーディングスキル</title><link>https://retheviper.github.io/posts/java-skills/</link><pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-skills/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Javaの色々なコーディングスキル" />&lt;p>今回のポストでは、スキルといっても大したものはないですが、自分がコードを書きながらこれは便利だな(もしくは単に格好いいな)と思ったコーディングスキル的なものをいくつか集めました。&lt;/p>
&lt;h2 id="streamでlistの変換">StreamでListの変換
&lt;/h2>&lt;p>以下のような二つのクラスがあるとしましょう。コードの量を減らすためLombokを使っていると仮定します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Item&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Setter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>業務的にこの二つのクラスのフィールドである&lt;code>value&lt;/code>が同一なものと仮定します。そうすると、Itemクラスから&lt;code>value&lt;/code>を取得してProductクラスに取り込むことが必要な状況もあるでしょう。このような場合、オブジェクトがそれぞれ一つだけだとあまり問題にならないですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Product &lt;span style="color:#a6e22e">setProductValueFromItemValue&lt;/span>(Item item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Product product &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Product();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> product.&lt;span style="color:#a6e22e">setValue&lt;/span>(item.&lt;span style="color:#a6e22e">getValue&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> product;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>複数の項目をマッピングする必要があるなら、&lt;a class="link" href="http://modelmapper.org/" target="_blank" rel="noopener"
>ModelMapper&lt;/a>のようなライブラリを使う方法もあります。同じような名前のGetter/Setterがあると自動でマッピングしてくれるので便利ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Product &lt;span style="color:#a6e22e">setProductValueFromItemValue&lt;/span>(Item item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ModelMapper mapper &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ModelMapper();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Product product &lt;span style="color:#f92672">=&lt;/span> mapper.&lt;span style="color:#a6e22e">map&lt;/span>(item, Product.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> product;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これらがListやMapに入っているとどうするのでしょうか。普通にFor文のなかで同じくマッピングをさせる方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">itemListToProductList&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> itemList) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> productList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Item item : itemList) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> productList.&lt;span style="color:#a6e22e">add&lt;/span>(mapper.&lt;span style="color:#a6e22e">map&lt;/span>(item, Product.&lt;span style="color:#a6e22e">class&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> productList;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをStreamとLambdaを利用して、より簡単なコードにすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">itemListToProductList&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> itemList) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> productList &lt;span style="color:#f92672">=&lt;/span> itemList.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">map&lt;/span>(item &lt;span style="color:#f92672">-&amp;gt;&lt;/span> mapper.&lt;span style="color:#a6e22e">map&lt;/span>(item, Product.&lt;span style="color:#a6e22e">class&lt;/span>)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> productList;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>やっていることはFor文とあまり変わりません。元のリストから要素を一つづつ取り出し、マッピングして新しいオブジェクトを作る。そしてそれを取り集めて新しいListを生成していますね。ただ、&lt;code>map()&lt;/code>の引数はLambdaなのでただのマッピングだけでなく、より複雑な処理を入れることもできます。同じことをするとしてもより簡単で短いコードが完成されます。&lt;/p>
&lt;h2 id="collectionでimmutable">CollectionでImmutable
&lt;/h2>&lt;p>Immutable、すなわち不変クラスについては&lt;a class="link" href="../java-thoughts-of-immutable" >前回のポスト&lt;/a>でも扱いました。今回はCollectionを使って、そのクラスのListやMapもImmutableにする方法について述べます。下のコードは、Listの例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">returnAsUnmodifiableList&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collentions.&lt;span style="color:#a6e22e">unmodifiableList&lt;/span>(list);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じ方法で、&lt;code>Collentions.unmodifiableMap()&lt;/code>でラッピングするとMapもImmutableにできます。こう変換されたListやMapは変更が不可能になるため設定系などのデータを持っている場合に有効活用できます。ただ、Nullが入るとNullPointerExceptionが発生するため注意しましょう。包みたいListがNullになる可能性がある場合は&lt;code>Collection.emptyList()&lt;/code>を代わりに入れることができます。&lt;/p>
&lt;p>逆に、ImmutableになったListやMapを変更したい場合は新しいオブジェクトに複製します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">returnAsModifiableList&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(list);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうしてオブジェクトを複製してデータを変更する場合、元のImmutableなListにも反映されるので注意する必要があります。&lt;/p>
&lt;h2 id="カスタムクラスをiterableにする">カスタムクラスをIterableにする
&lt;/h2>&lt;p>とあるクラスの中に、子要素のクラスがListとして入っているとします。例えば、以下のようなイメージです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Container&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> baggages &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>場合によっては、このクラスの中の子要素を全部取り出してFor文を書きたい場合もあるはずです。そういう場合は普通、こんな形で使うのではないかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printBaggageNames&lt;/span>(Container container) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> baggages &lt;span style="color:#f92672">=&lt;/span> container.&lt;span style="color:#a6e22e">getBaggages&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Baggage baggage : baggages) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(baggage.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>でも、このクラス自体を拡張For文のなかで使えるとしたら、より便利になりますね。つまり、以下のように使えるとしたいということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printBaggageNames&lt;/span>(Container container) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Baggage baggage : container) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(baggage.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしこれができたら、Getterは要らなくなって、よりシンプルなコードがかけますね。また、Listそのものを取得させるわけではないので、Immutableにする必要もなくなります。&lt;/p>
&lt;p>これはIterableを使うことで具現化できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Container&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> baggages &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Iterator&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">iterator&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> baggages.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうすることで簡単に、親クラスから子要素を拡張For文の中で使えるようになります。簡単ですね！&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>そこまで高級スキル的なものはなかったのですが、覚えておくとどこかで必ず役に立ちそうなスキルをいくつか集めてみました。これらは実際の仕事でも使っているものであって、とりあえず「動けばいい」レベルを超えて行きたい時に有効活用できるようなものではないかと思いました。こういう細かいところでのスキルの差が、プログラマーとしての実力に繋がるものではないでしょうか。そう思って、今後からも何かわかったらまたポストとして作成したいと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Gradleのdependenciesはどう書くべきか</title><link>https://retheviper.github.io/posts/gradle-dependencies/</link><pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/gradle-dependencies/</guid><description>&lt;img src="https://retheviper.github.io/images/gradle.webp" alt="Featured image of post Gradleのdependenciesはどう書くべきか" />&lt;p>現代のプログラミングは、半分インターネットでなされていると言っても過言ではないでしょう。言語やMWの公式ガイドラインだけではなく、ウェブ上の数多くのコミュニティで情報を得られる時代ですからね。そしてMavenやGradleのように、依存関係の管理自体がネットに繋がっていることを前提としているものもあります。私もそういうトレンドから離れてはなく、自分が書いているコードで問題が発生するととりあえず検索で調べてみる方です。時間はかかっても、大概はそうすることで解決できますね。&lt;/p>
&lt;p>しかし、そんな便利ながらもネットで知識を求める行動にはリスクもあります。果たしてその情報が正しいかという問題ですね。まずコーディングに関する情報だと、私の基準では2年以上立っているものなら信じがたいものとなります。当時はそれが正解だったとしても、今はそうではない可能性がありますので。例えば同じライブラリーを使っているとしても、バージョンアップによりパッケージの構成が変わったり、メソッドのシグニチャーが変わったりしますが、ネットにある全ての情報がそのような変更まで全部反映しているとは思えません。実際動いたというコードが書かれているとしても、そのコードはあくまで普通のテキストであって、現在コンパイルして動かすことのできるものでもないですしね。&lt;/p>
&lt;p>今回の主題である&lt;code>Gradleのdependenciesをどう書くべきか&lt;/code>というのも、そういう意味でのものです。私自身も今まで依存関係を書くときは、公式で提案しているコードやブログなどを参照してコピペしていました。しかし、そうしていると同じライブラリーでも&lt;code>complie&lt;/code>だったり&lt;code>implementation&lt;/code>だったり&lt;code>runtime&lt;/code>だったりしていて、かなり混乱するものでした。結局どんな書き方をとるとしてもその結果は同じように見えるのに、こうして区分している理由は何かと思いました。&lt;/p>
&lt;p>そして結局、その疑問の答えは自分がとある問題に直面することで得られました。なので今回はただ単に理論の話ばかりではなく、問題が起こり得る場所とその解決法についてのものでもあります。&lt;/p>
&lt;h3 id="compile-implementation">compile? implementation?
&lt;/h3>&lt;p>ネットでGradleで依存関係を書く方法を調べると、同じライブラリーでもその書き方が&lt;code>compile&lt;/code>だったり&lt;code>implementation&lt;/code>だったりしますね。現時点でそのうちどれを使ってもまず動きはするので、一見何の問題も内容に感じされます。&lt;/p>
&lt;p>しかし、問題は&lt;code>compile&lt;/code>です。このキーワードは多分、依存関係を表現する最も古い記述法です。実際の検索結果が一番多いような気もしますね。意味的にも、&lt;code>このライブラリーをコンパイル時に使う&lt;/code>のような感覚なのでわかりやすいと思います。&lt;/p>
&lt;p>ただ、Gradleの&lt;a class="link" href="https://docs.gradle.org/4.7/userguide/java_plugin.html#sec:java_plugin_and_dependency_management" target="_blank" rel="noopener"
>4.7バージョンのJava Library Plugin&lt;/a>のDependency managementタブを参照すると、compileは&lt;code>Deprecated&lt;/code>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>と書いてあります。このポストを書く時点での安定化バージョンは5.6で、今後6.0が予定されているのでこちらはなるべく使わない方が良さそうです。&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.gradle.org/5.6.4/userguide/java_library_plugin.html#sec:java_library_separation" target="_blank" rel="noopener"
>公式の文書を参照&lt;/a>すると、&lt;code>compile&lt;/code>は&lt;code>implementation&lt;/code>と&lt;code>api&lt;/code>の二つに分けられたらしいです。つまり、これからはcompileの代わりにそのどちらかを選ぶのが望ましいということですね。&lt;/p>
&lt;h2 id="implementationとapi">implementationとapi
&lt;/h2>&lt;p>既存の&lt;code>compile&lt;/code>だと、必ず「依存関係の伝播」が発生していたらしいです。つまり、Aというライブラリーを使って新しくBというライブラリーを作成したとしましょう。そしてまた、Bに依存するCを作成します。こういった場合、CではBを依存することだけでAにも触れられるようになります。このような状況は、場合によってはまあり望ましくないことになる可能性もありますね。Aをラッピングして、仕様を絞る目的としてBを作成したとしてもCからAを直接扱うことができますから。これはJavaのカプセル化の観点からしてもあまり望ましくないです。&lt;/p>
&lt;p>&lt;code>implementation&lt;/code>では、この依存関係の伝播に制約をかけています。つまり、BからAに依存するとき、&lt;code>compile&lt;/code>ではなく&lt;code>implementation&lt;/code>で記述するとCからAを直接参照できなくなるということです。この理由から、最近は多くの場合に&lt;code>compile&lt;/code>の代わりに&lt;code>impelementation&lt;/code>を使うことを推奨しているらしいですね。&lt;/p>
&lt;p>それに対して&lt;code>api&lt;/code>では従来通り依存関係の伝播が発生します。BがAに依存しているとき、完全なラッピングではなく、CからAも参照させたいならこちらを使うべきですね。実際、業務でライブラリーをいくつか作っていましたが、一部では大元のライブラリーを参照させる必要があるものもありました。この場合に&lt;code>implementation&lt;/code>を使うとCからのAに対する直接的な参照がGradleとしては認識できなくなったらしく、コンパイルでのエラーが発生することもありました。なのでdependenciesの記述では、自分が作成しているものの性質を正しく理解し記述方法を決めるということも大事ですね。&lt;/p>
&lt;p>これらの関係を簡単な図として表現すると、このようになります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/gradle-dependencies/gradle_implementation_api.webp"
width="863"
height="400"
srcset="https://retheviper.github.io/posts/gradle-dependencies/gradle_implementation_api_hu_6b977cc1845e4171.webp 480w, https://retheviper.github.io/posts/gradle-dependencies/gradle_implementation_api_hu_7906710700a1cb2b.webp 1024w"
loading="lazy"
alt="Gradle Implemenatation API"
class="gallery-image"
data-flex-grow="215"
data-flex-basis="517px"
>&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>これでシンプルに、Gradleのdependenciesはどう書くべきかについて述べてみました。実際は&lt;code>implementation&lt;/code>と&lt;code>api&lt;/code>意外にもランタイムのみ参照の&lt;code>runtimeOnly&lt;/code>やテスト用の&lt;code>testImplementation&lt;/code>など、様々な記述方法があるので、状況と場合によっては柔軟な対応が必要かと思います。ただ、大抵の場合は依存関係を整理し、&lt;code>implementation&lt;/code>と&lt;code>api&lt;/code>の使い分けを確かにすることが最も重要なことなのではないでしょうか。&lt;/p>
&lt;p>また、先に述べたように、ネットから得られた情報がAPIの更新事項を確かに反映しているかのチェックも重要ですね。古い情報だと今のコードでは問題を起こす可能性がありますので。そういう意味では、このポストも時間がたてばいつか正しくない情報となる可能性はあります。いや、このポストだけでなく、もしかしたらこのブログ全体で私が書いている情報の全てがそうなのかもしれません。&lt;/p>
&lt;p>コードを書きながら、ネットの情報を参照するときは常にそれが書かれた日付を確認し、公式のドキュメントと見比べる必要があるのではないかと思います。勉強も最新化の方針で！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Deprecatedは、「オススメしない」という意味です。プログラミングの世界では、何らかの問題があったり必要が無くなったりするなどの理由でこれからなくなる可能性の高い関数を指す言葉となっています。実際、EclipseではJavaの関数に&lt;code>@Deprecated&lt;/code>をつけると関数名に打ち消し線が現れることを確認できます。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Enumを使いましょう</title><link>https://retheviper.github.io/posts/java-enum/</link><pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-enum/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Enumを使いましょう" />&lt;p>JavaのEnumは興味深いものです。読みやすく、同時に複数の値を持たせるということが魅力的です。なので複数のクラスで共通のコード値を扱う必要があったり、DBに連携する場合に使うと便利ですね。私も現在の仕事では積極的に活用しています。また、完全なクラスとして機能しているので単に定数のため使うだけでなく、処理を記述することも可能なので活用できる範囲はかなり広いのでは、と思います。&lt;/p>
&lt;p>なので今回はJavaのEnumの活用法やメリットについて、自分の経験と調べたことをまとめ紹介したいと思います。&lt;/p>
&lt;h2 id="読みやすい">読みやすい
&lt;/h2>&lt;p>コードが読みやすいということは、つまり維持補修に有利ということですね。個人的にはプログラミングの段階は「とにかく動く物を作る」→「共通(重複)処理をメソッドやクラスで分離する」→「他人がみてもわかりやすいコードにする」順に進むべきだと思います。そして全ての段階が最初の設計からできていればなおさらですね。&lt;/p>
&lt;p>テーブルにとあるコード値が項目として存在するとしましょう。DBの種類によってはその項目を&lt;code>boolean&lt;/code>にすることもできますが、&lt;code>char(1)&lt;/code>になる場合もあります。そしてこういった場合はそのコード値は二つの状態だけでなく、3つ以上の状態を持つ場合もありますね。サンプルとしてJava内での状態をStringとして持ち、DBには&lt;code>char(1)&lt;/code>として記録するとしましょう。そういう場合は以下のようなコードが必要となるはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Stringで記述されている状態をDBのコード値に変換するメソッドの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">toCodeValue&lt;/span>(String status) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (status.&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;TRUE&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このメソッドを使うコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// itemオブジェクトにステータスを指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setStatusTrue&lt;/span>(Item item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;TRUE&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ハードコーディングされた&lt;code>status&lt;/code>を定数かすることは可能です。定数は普通のクラス内でも持たせますね。しかし、そういう場合は定数がどのクラスで定義されているかをまず知る必要があります。とこで定数が定義されているかわからない場合は修正も難しくなるし、重複して同じ定数をそれぞれ違うクラスに作成することになる可能性もありますね。&lt;/p>
&lt;p>そして、このコードでは処理の結果を見る前まで状態がどうなっているか確認できなくなる可能性があるという欠点があります。もしどこかで指定された&lt;code>status&lt;/code>が&lt;code>TRUE&lt;/code>でも&lt;code>FALSE&lt;/code>でもない第三の文字列だったら？そういう場合は&lt;code>if&lt;/code>の分岐を増やすしかないでしょう。&lt;/p>
&lt;p>これをEnumを使うコードに変えてみましょう。コードは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> StatusEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TRUE(&lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FALSE(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Integer codeValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringEnum(Integer codeValue) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">codeValue&lt;/span> &lt;span style="color:#f92672">=&lt;/span> codeValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Integer &lt;span style="color:#a6e22e">getCodeValue&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> codeValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>定数名にそれぞれのコード値を設定し、フィールド・コンストラクタ・Getterを用意するだけです。構造からわかるように、このようなEnumクラスはLombokのアノテーションでも簡単に作ることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> StatusEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TRUE(&lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FALSE(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Integer codeValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作成したEnumを実際活用する場合のコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// itemオブジェクトにステータスを指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Item item &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Item();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(StatusEnum.&lt;span style="color:#a6e22e">TRUE&lt;/span>.&lt;span style="color:#a6e22e">getCodeValue&lt;/span>()); &lt;span style="color:#75715e">// &amp;#34;0&amp;#34;となる&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Enumを作成することで、入れたい値が明確になります。また、Enumは独立したクラスなのでパッケージを分けて保存することで管理がより簡単になります。あとでコード値が増える場合にもそちらのEnumを修正するだけで住みますね。また、Enum自体をフィールドとして宣言することも可能です。その場合は以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// フィールドにEnumがある例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Item {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> StatusEnum status;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>フィールドがEnumの場合は、値の指定がより簡単になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Item item &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Item();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(StatusEnum.&lt;span style="color:#a6e22e">TRUE&lt;/span>); &lt;span style="color:#75715e">// TRUEとして保存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コード値を抽出したいときのコード&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String itemCodeValue &lt;span style="color:#f92672">=&lt;/span> item.&lt;span style="color:#a6e22e">getStatus&lt;/span>().&lt;span style="color:#a6e22e">getCodeValue&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="複数の値を持つことが可能">複数の値を持つことが可能
&lt;/h2>&lt;p>そこまで読み易くはならないのでは？と思われる可能性もありますね。確かに、一つの定数につき値が一つだけの場合はそうかもしれません。しかし、Enumの良いところは、定数に複数の値を持たせることも可能ということです。&lt;/p>
&lt;p>例えば二つ以上のDBを使っていて、同じ項目を片方のテーブルは&lt;code>char(1)&lt;/code>、またの方は&lt;code>boolean&lt;/code>で管理しているとしましょう。Enumでは両方を一つの定数として管理することができます。それがどういうことか、以下のコードで確認してみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> MultiValueEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Y(&lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> N(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Integer charValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> booleanValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードを見ると簡単に理解できると思いますが、どちらのGetterを使うかによって同じ定数でも違うデータ型のコード値を返却します。これを実際のコードで使うとしたら、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBの項目がchar(1)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Item item &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Item();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(MultiValueEnum.&lt;span style="color:#a6e22e">Y&lt;/span>.&lt;span style="color:#a6e22e">getCharValue&lt;/span>()); &lt;span style="color:#75715e">// &amp;#34;0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBの項目がboolean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(MultiValueEnum.&lt;span style="color:#a6e22e">Y&lt;/span>.&lt;span style="color:#a6e22e">getBooleanValue&lt;/span>()); &lt;span style="color:#75715e">// true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>複数の値を指定可能ということは、配列やListでも可能ということではないか？と思う方もいるかもしれません。結論からいうとYesです。自分も最初からわかっていたわけではありませんが、調べてみると&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener"
>Stream&lt;/a>を使うと値としてListを持たせ、さらにそのListの中の値との比較もできるようです。この場合のコードは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> ListValueEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Y(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Good&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;Excellent&amp;#34;&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> N(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Bad&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Unavailable&amp;#34;&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL(&lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> codeValueList;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Listの中に値があるかチェック&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">hasCodeValue&lt;/span>(String codeValue){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> codeValueList.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">anyMatch&lt;/span>(code &lt;span style="color:#f92672">-&amp;gt;&lt;/span> code.&lt;span style="color:#a6e22e">equals&lt;/span>(codeValue));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Listの中の値と一致する場合、その定数を返す(&amp;#34;Good&amp;#34;ならListValueEnum.Yを返却)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ListValueEnum &lt;span style="color:#a6e22e">findByValue&lt;/span>(String codeValue) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(ListValueEnum.&lt;span style="color:#a6e22e">getCodeValueList&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(listValueEnum &lt;span style="color:#f92672">-&amp;gt;&lt;/span> listValueEnum.&lt;span style="color:#a6e22e">hasCodeValue&lt;/span>(codeValue))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">findAny&lt;/span>().&lt;span style="color:#a6e22e">orElse&lt;/span>(NULL); &lt;span style="color:#75715e">// 当てはまる値がない場合はNullを返す・&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだStreamは一部でしか使ってみたことがないのでこういう活用方法は考えてみたことがないですが、どこかで使えそうなコードです。&lt;/p>
&lt;p>また、フィールドとして使うEnumに特に値がない場合は以下のようなアノテーションを使うことも可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Item&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// StringEnum.YESのまま使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Enumerated&lt;/span>(EnumType.&lt;span style="color:#a6e22e">STRING&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> StringEnum codeValue1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="classらしき活用">Classらしき活用
&lt;/h2>&lt;p>Enumはクラスなので、もちろん処理を持たせる方法もあります。処理を持たせるというのは難しく感じるかもしれませんが、処理をメソッドと思えば良いだけの話です。メソッドのフィールド化する方法についてはLambdaに関する&lt;a class="link" href="../java-functional-interface" >以前のポスト&lt;/a>を参照してください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> CalculateEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Lambdaでフィールドを指定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TYPE_1(num &lt;span style="color:#f92672">-&amp;gt;&lt;/span> num),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TYPE_2(num &lt;span style="color:#f92672">-&amp;gt;&lt;/span> num &lt;span style="color:#f92672">+&lt;/span> 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Function&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> calculate;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 値を入れると処理結果が帰ってくる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pulbic Integer &lt;span style="color:#a6e22e">calculate&lt;/span>(Integer number) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> calculate.&lt;span style="color:#a6e22e">apply&lt;/span>(number);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような形のEnumを使う場合のコードは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 処理結果を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Integer type_1 &lt;span style="color:#f92672">=&lt;/span> CalculateEnum.&lt;span style="color:#a6e22e">TYPE_1&lt;/span>.&lt;span style="color:#a6e22e">calculate&lt;/span>(10); &lt;span style="color:#75715e">// 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Integer type_2 &lt;span style="color:#f92672">=&lt;/span> CalculateEnum.&lt;span style="color:#a6e22e">TYPE_2&lt;/span>.&lt;span style="color:#a6e22e">calculate&lt;/span>(10); &lt;span style="color:#75715e">// 20&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>共通の部品として使われるものが重複されていると管理もその値の理解も難しくなり、余計なコードが増えるますね。これをEnumで克服できるということを伝えたかったのですが、いかがでしょうか。ただ、定数を必ずEnumにする必要があるかは、よく考えてみる問題だと思います。場合によってはテーブルとして管理した方が良いのかもしれません。そしてある特定のクラス内でしか使われていないなら、あえてEnumを作る必要もないでしょう。&lt;/p>
&lt;p>それでもこのようにAPIの活用方法を理解し、覚えておくと、どこかで使っていい場合が現れるのではないかと思います。最初はLambdaをただの「読みづらいコード」としか認識していなかった私も、Functionの存在を知ってからは積極的に使っています。知識のみでなく、その知識を適材適所で活かしていけるようになることが真のプログラマーと思います。まずその判断は難しいかもしれませんが、知識を先に持つことで見えてくるものもあるのではないでしょうか。なので、これからも新しく得られた知識があれば、このブログで紹介していきたいと思います。&lt;/p></description></item><item><title>Gradleでマルチプロジェクトを作る</title><link>https://retheviper.github.io/posts/gradle-multi-project/</link><pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/gradle-multi-project/</guid><description>&lt;img src="https://retheviper.github.io/images/gradle.webp" alt="Featured image of post Gradleでマルチプロジェクトを作る" />&lt;p>もともと自分が学んでいたのはMavenを利用したSpring MVCのプロジェクトを作る方法でしたが、最近はGradleで管理されるSpring Bootプロジェクトを触っています。最初はGradleを単純にMavenと似たような依存関係用のツールだとしか思ってなかったですが、直接タスクを作ったりJarをビルドしたり色々挑戦してみてからそう単純なものではないということに気付きました。&lt;/p>
&lt;p>その中でも最も良いと思ったのは、それぞれ違う機能を持つ個別のプロジェクトをマルチプロジェクトという概念で管理できることでした。OOPの観点からしてクラスやパッケージだけを分けるのではなく、プロジェクト単位の分け方によってより維持保守に長けているアプリケーションを作られるのではないか、と思います。&lt;/p>
&lt;p>なのでここではまず簡単にGradleのマルチプロジェクトが何であり、その作り方について簡単に説明したいと思います。&lt;/p>
&lt;h2 id="gradle-multi-project">Gradle Multi Project
&lt;/h2>&lt;p>Graldeのマルチプロジェクトは、その名の通り複数のプロジェクトで構成されているプロジェクトのことを意味します。具体的には全ての起点となるルートプロジェクトがあり、その配下に複数のGradleプロジェクトが入っている形になります。ルートプロジェクトの配下で管理されるプロジェクトたちはサブプロジェクトといいます。&lt;/p>
&lt;p>こういうマルチプロジェクトの作り方は今回紹介する方法とはまた違うものもあるらしく、プロジェクトのフォルダ構成にも違いがあるようです。&lt;/p>
&lt;p>ただ、マルチプロジェクトは複数プロジェクトの管理を簡単にさせるということにその目的があると思いますので、一つのリポジトリ単位で管理できるようにルートプロジェクトの中にサブプロジェクトが入っている形を採用します。これは実際自分が仕事で書いているSpring Bootプロジェクトの構成でもあります。&lt;/p>
&lt;p>また、ここで紹介しているのはEclipseを基準にした説明となります。(他のIDEはまだ詳しくないので…)&lt;/p>
&lt;h2 id="root-project">Root Project
&lt;/h2>&lt;p>全てのサブプロジェクトを含む大元となるルートプロジェクトを作ります。一般的なGradleプロジェクトをまず作成します。ただ&lt;code>build.gradle&lt;/code>はこれからサブプロジェクトに使う予定なので、コピーしておきましょう。あとはいらなくなったファイルとフォルダを削除します。ここで残すファイルとフォルダは以下だけです。&lt;/p>
&lt;ul>
&lt;li>gradle(フォルダ)&lt;/li>
&lt;li>build.gradle&lt;/li>
&lt;li>gradlew&lt;/li>
&lt;li>gradlew.bat&lt;/li>
&lt;/ul>
&lt;p>以上のファイルとフォルダを残したら、次は&lt;code>build.gradle&lt;/code>ファイルを修正します。ルートプロジェクトはサブプロジェクトの管理だけをしていて、必要なタスクやプラグイン、依存関係の設定はサブプロジェクトで記述します。なのでなるべくシンプルにしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>subprojects &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repositories &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mavenCentral&lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでやっていることは、サブプロジェクトのリポジトリ指定だけですが、同じやり方でサブプロジェクトの&lt;code>build.gradle&lt;/code>に共通記述しなければならないことはなんでも入れていいです。例えばプラグインとかがあるでしょう。&lt;/p>
&lt;p>次に、&lt;code>settings.gradle&lt;/code>ファイルを作成します。このファイルはルートプロジェクトとサブプロジェクトを紐付け、プロジェクト名を決める役割をします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>include &lt;span style="color:#e6db74">&amp;#39;core&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>include &lt;span style="color:#e6db74">&amp;#39;web&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rootProject&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;TestProject&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rootProject&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">each&lt;/span> &lt;span style="color:#f92672">{&lt;/span> it&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> rootProject&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> it&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>include&lt;/code>と書いたものはサブプロジェクトで、&lt;code>rootProject.name&lt;/code>はその名の通りルートプロジェクト名を意味します。他にも命名できる方法はありますが、あくまでルートプロジェクト名がこのプロジェクト全体を意味するもので、サブプロジェクトはそのうちの一つの機能単位という感覚て命名しています。&lt;/p>
&lt;p>&lt;code>rootProject.children.each { it.name = rootProject.name + '-' + it.name }&lt;/code>では、ルートプロジェクト名にダッシュをつけ、その下にサブプロジェクト名を付けています。これは以下の方法でも表現できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>rootProject&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">each&lt;/span> &lt;span style="color:#f92672">{&lt;/span> p &lt;span style="color:#f92672">-&amp;gt;&lt;/span> p&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;${rootProject.name}-${p.name}&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この命名法によりそれぞれのサブプロジェクトは&lt;code>TestProject-core&lt;/code>や&lt;code>TestProject-web&lt;/code>のように命名されます。&lt;/p>
&lt;p>こう構成したプロジェクトをEclipseのパッケージエクスプローラからみると、以下のように見えるようになります。&lt;/p>
&lt;ul>
&lt;li>TestProject&lt;/li>
&lt;li>TestProject-core&lt;/li>
&lt;li>TestProject-web&lt;/li>
&lt;/ul>
&lt;p>あとでもしサブプロジェクトを追加する必要があるとしたら、ルートプロジェクトの&lt;code>include&lt;/code>を記述することで自動的に&lt;code>TestProject-...&lt;/code>という風にサブプロジェクト名が付けられることとなります。&lt;/p>
&lt;h2 id="sub-project">Sub Project
&lt;/h2>&lt;p>ルートプロジェクトの準備が終わったら次は、子要素のサブプロジェクトを作ります。サブプロジェクトは普通のGradleプロジェクトでも良く、ルートプロジェクトの配下に置くだけで使えるようになりますが、ここでは空のフォルダを作成して作る方法を紹介します。&lt;/p>
&lt;p>まずルートプロジェクトの配下にサブプロジェクトとして使うフォルダを作ります。フォルダ名をサブプロジェクト名として使う予定なので、適したフォルダ名を選びます。ここでフォルダ名はルートプロジェクトの&lt;code>settings.gradle&lt;/code>で記述した&lt;code>include&lt;/code>と一致しなければならないです。例えば上のルートプロジェクトでは&lt;code>core&lt;/code>と&lt;code>web&lt;/code>をすでに書いているので、それに合わせて&lt;code>core&lt;/code>と&lt;code>web&lt;/code>のフォルダを作成します。&lt;/p>
&lt;p>フォルダを作成したら、その中にルートプロジェクトを作成した時コピーしておいた&lt;code>build.gradle&lt;/code>を置いて編集します。今回はEclipseを基準にJavaプロジェクトを生成するので以下のようなプラグインが必要です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>plugins &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id &lt;span style="color:#e6db74">&amp;#39;eclipse&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ファイルを保存してルートプロジェクトから&lt;code>gradlew tasks&lt;/code>を実行すると、ide節に&lt;code>eclipse&lt;/code>があります。こちらのタスクを実行します。コマンドラインだと&lt;code>gradlew eclipse&lt;/code>を入力することで実行できます。もちろんEclipse上でも実行できますが、更新に時間がかかる場合があるのでコマンドラインの方をお勧めします。&lt;/p>
&lt;p>このタスクを実行することで、作成したフォルダの中にEclipseプロジェクトとして機能するための準備ができます。あとは普通のJavaプロジェクトのようにソースフォルダ(src/main/java)を生成し、パッケージを作成してサブプロジェクトの中を埋めていきます。&lt;/p>
&lt;p>もしマルチプロジェクトがEclipse上で正しく認識されない場合は、プロジェクトを右クリックしてリフレッシュしたり、Gradleメニューから&lt;code>Gradleプロジェクトのリフレッシュ&lt;/code>を実行してください。&lt;/p>
&lt;h2 id="sub-project-dependency">Sub Project Dependency
&lt;/h2>&lt;p>この方法で作成したマルチプロジェクトでは、サブプロジェクト同士で依存することもできます。例えば&lt;code>web&lt;/code>プロジェクトの起動に&lt;code>core&lt;/code>プロジェクトで作成したクラスを読み込む必要があるときは、&lt;code>web&lt;/code>の&lt;code>build.gralde&lt;/code>で以下のように記述すると&lt;code>core&lt;/code>のクラスをインポートできるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>dependencies &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation &lt;span style="color:#a6e22e">project&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;:TestProject-core&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただこの場合、&lt;code>web&lt;/code>の起動時に一度&lt;code>core&lt;/code>プロジェクトをコンパイルすることになるのでテスト時に&lt;code>core&lt;/code>側の修正事項は即反映されないので注意しましょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>まだEclipse上でGradleのマルチプロジェクトの生成を簡単にできる方法がなく、このような多少不便な方法でしかプロジェクトの作成ができないというところが不便ですね。のちに追加されるかもしれませんが…&lt;/p>
&lt;p>でもまずはマルチプロジェクトを構成する方法とその構造がどんなものかが理解できれば、これから活用できる道が増えていくのはでないかと思います。特にプロジェクトの規模が大きくなればなるほど、こういう管理の仕方だ必要になるのではないでしょうか。&lt;/p>
&lt;p>それでは皆さんもぜひ、Gradleのマルチプロジェクトを試してみてください！&lt;/p></description></item><item><title>Oracle JavaSE 8 Silverについて</title><link>https://retheviper.github.io/posts/java-se-8-silver/</link><pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-se-8-silver/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Oracle JavaSE 8 Silverについて" />&lt;p>今回、Oracle認定JavaSE 8 Silverを受験しました。仕事でしばらくJavaを使うことになって、自分の実力がどのレベルなのかを確かめたかったので受けてみましたが、運よくも合格。Java Silverで検索すると合格した人たちはどう勉強したか、難易度はどうなのかについてのブログが多いのでここでは書きません。&lt;/p>
&lt;p>それでもあえてポストとして資格試験のことを書く理由は、どうしても資格とは実際の業務で必要となる知識とは乖離があるものだからです。資格をまず取得して業務に入る人もいれば、私のように業務でのお作法を経験してから受験する人もいるだろうと思います。なので、私と全く同じ状況ではないとしてもテストで困る問題は多分ある程度その領域が重なるのでは、と思います。その結果として他の多くの方が書いているものとあまり変わらないことを述べているのではないか、とも思いますが…&lt;/p>
&lt;p>もしこれからJavaSE Silverを受験しようとしている方がこのポストを見つけた場合に、少しでも役に立てるような情報になれるといいなと思い、自分の経験として意外とハマったところについて述べます。&lt;/p>
&lt;h2 id="全体的な印象">全体的な印象
&lt;/h2>&lt;p>業務では使わない知識が要求される場合が少なくないです。ただそれが全部無駄な知識とは言えない印象でした。一旦覚えておくと業務でも活かせるのでは、と思う問題もありました。大きく分けてAPIに対する単なる知識を聞く問題と、コードを読んで理解する能力を要求するような問題があります。&lt;/p>
&lt;p>意外と難しいなと思ったのは、IDEに依存できない問題でした。代表的にimportの書き方、コンパイルエラーの見つけだしなどがあります。実際の業務でIDEを使わず、単なるテキストエディタでJavaを書くことはないと思いますが、試験としてはそのような問題の頻度が決して低くないので、問題で提示されるコードはちゃんと読む必要があります。&lt;/p>
&lt;p>それでは、以下ではテストの個別項目について感じたことを述べていきます。&lt;/p>
&lt;h3 id="データ型">データ型
&lt;/h3>&lt;p>データ型で最も多く使われるのは、int/double/Stringの三つだと思います。テストでもbyte型やfloat型の範囲などを聞く問題はなかったですが、一部の問題でこれらが出てくる場合があります。例えばswitch文の条件文で使えないデータ型は何かを選ぶ問題など。Bronzeならもっとデータ型について詳しく聞く問題が出てくるのでBronzeの次にSilverを受けるならともかく、私みたいにSilverから挑戦する人なら少し困るかもしれません。&lt;/p>
&lt;p>他にもデータ型と関連する問題の種類は、型変換(暗黙的な型変換とそうではない場合を選ぶ)があります。こちらもbyte, short, long, floatの特徴を確かに覚えないと、意外と正解がわからなくなる問題でした。&lt;/p>
&lt;h3 id="string--stringbuilder">String / Stringbuilder
&lt;/h3>&lt;p>StringやStringBuilderのメソッドに関する問題が多かったです。ただ普段はあまり意識してなかった部分ですが、StringはImmutableなオブジェクトになるためreplaceやsubstringなどのメソッドを使うと新しいインスタンスが返却されるということをちゃんと覚えておく必要があります。例えば以下のような問題があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 出力される文字列を当てる問題&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is string&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s.&lt;span style="color:#a6e22e">substring&lt;/span>(0, 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(s);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元のString自体は変わってないので最初に宣言した通り出力されるのが当たり前ですが、注意深くコードを読まないとsubstringで切り取った文字が出力されるように勘違いしやすいです。(自分だけかもしれませんが…)&lt;/p>
&lt;h3 id="配列">配列
&lt;/h3>&lt;p>配列をあえて使う場合があまりなく、ほとんどListを使っていたのでこちらの問題でも苦戦しました。配列の宣言の仕方から、配列の中の要素を処理する方法などの問題がよく出てきましたが、配列の宣言には様々な方法があるので少し選択肢が怪しく思われます。&lt;/p>
&lt;p>もちろんListは基本が可変・スレッドセーフではないので場合によっては業務でも配列を導入する必要はあるかもしれません。覚えておいて損ではないと思いますので、配列については確実に覚えておきたいと思いました。&lt;/p>
&lt;h3 id="アクセス修飾子--継承">アクセス修飾子 / 継承
&lt;/h3>&lt;p>defaultとprotectedの違いを問う問題があります。普段からパッケージ構成や継承を考慮した実装をしていたならともかく、大抵の場合はpublicとprivateのみを使っていて他を忘れやすい場合もあると思うので、ちゃんと覚えておきたいものでした。&lt;/p>
&lt;p>また、継承の問題でアクセス修飾子が重要なキーワードとなる問題もありました。例えばスーパークラスからオーバーライドーしているメソッドをより狭い範囲にするようなコードを提示して、そのコードを実行したらどうなるかを聞く問題など。正常実行されると思ってその結果を答えとして選んでも、「コンパイルエラー」が正解だったりします。&lt;/p>
&lt;p>継承に関してはかなり問題の量が多いような印象を受けました。Interfaceとabstractの違い、継承の仕方、インスタンスと参照の違い、キャストなどバリエーションも多く、どれも実務では使われているので慣れてはいるものの、問題自体もそのためか知識だけよりは少し複雑な方法でミスを招こうとしている印象でした。コードを注意深く読む必要があります。&lt;/p>
&lt;h3 id="ラベル">ラベル
&lt;/h3>&lt;p>ラベルについてはこの度初めて接したので全然知らなかったですね。しかし二重ループで使うとかなりパフォーマンスの改善を図れると思いますので、これはテストだけではなく覚えておくと良いこつと思います。ただ、ループ以外で使うことはそんなにないかも…とも思います。&lt;/p>
&lt;p>問題としてはラベルがついたループ文ないでif文を書き、結果がどうなるかを聞く問題が少しありました。例えば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 出力がどうなるかを問う問題&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> 5 &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ラベル自体よりは条件文とcontinue / breakの違いをちゃんと理解しているかを聞くような問題とも言えると思いますが、とにかくラベルとはなんぞや？となると、一旦答えることができなくなります。もちろん知識としてラベルをつけることができるのはどこか、という問題もありました。&lt;/p>
&lt;h3 id="例外">例外
&lt;/h3>&lt;p>Javaの例外の特徴や、try-catch文での挙動に関する問題が出てきます。業務ではカスタム例外を作ることもあるのでExceptionとRuntimeExceptionの違いについて理解しているならそこまで問題となることはないと思いますが、提示されるコードで見逃す可能性があるのは「throws宣言があるかどうか」、「catchでスーパークラスの例外を宣言しておいてその次にサブクラスをまた書いてコンパイルエラーになる場合であるか」のような部分です。上位の例外をcatchすると、下位の例外は書く必要がないので注意しましょう。&lt;/p>
&lt;p>IDEを使える環境だったらあまり気にする必要ない部分なので、意外と見逃せやすい部分ではないかと思います。&lt;/p>
&lt;h3 id="lambda">Lambda
&lt;/h3>&lt;p>JavaSE SilverではJava8ならではのAPIについて聞く場合が少なくないです。Lambdaもそうですね。ただ、大抵のLambda関連の問題は正しい書き方やFunctionの種類に関する知識を問う問題です。慣れてなくても、覚えておくと大丈夫でした。&lt;/p>
&lt;p>書き方については括弧とreturnの省略が正しく書いてあるのかについての問題で、例外同様IDEだとすぐコンパイルエラーになるため見逃しやすい部分でした。&lt;/p>
&lt;h3 id="localdate--localtime--localdatetime">LocalDate / LocalTime / LocalDateTime
&lt;/h3>&lt;p>今まで自分が使っていた日付関連のAPIは&lt;code>java.util.Date&lt;/code>と&lt;code>java.sql.Date&lt;/code>しかなかったので、苦戦した問題でした。こちらもStringと同じくImmutableなので、似たような問題が出てきます。例えば以下のような問題です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 出力がどうなるかを問う問題&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LocalDate date &lt;span style="color:#f92672">=&lt;/span> LocalDate.&lt;span style="color:#a6e22e">now&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date.&lt;span style="color:#a6e22e">plusDays&lt;/span>(5);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(date);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Stringと同じく、Local〜類のAPIは値を操作するメソッドが新しいインスタンスを返却することを覚えておくと良いだけです。ただ、時間や日付の出力フォーマットに関する問題が出るのでこちらは覚えておく必要がありました。APIを見ると&lt;code>java.sql.Data&lt;/code>にも変換ができるのですが、変換に関する問題は出てませんでした。&lt;/p>
&lt;h3 id="その他">その他
&lt;/h3>&lt;p>問題集だけだと複数の選択肢を選ぶ問題なのに一つしか選んでなかったりしていて、本場でこうなると困るな…と思っていましたが、実際のテストでは単一選択肢だとラジオボタン、複数だとチェックボックスで選ぶようになっているので心配ありませんでした。チェックスボックスなのに一つだけ選んでいたりすると次の問題に移る前に警告も出ました。&lt;/p>
&lt;p>一部ループでの処理などを直接計算する必要がある場合もありますが、多くは時間がかからなく即答できるものです。時間が足りないということはほぼないと思いますので、問われているAPIに関してその特徴をよく覚えると簡単に合格できる資格なのでは、と思います。&lt;/p>
&lt;p>ただ逆に、私みたいに業務に慣れていて基本を忘れていたり知らなかったりするとハマるところも少なくないと思います。先に述べたように時間が足りなくなることはあまりないので、コードが提示される問題は注意深く読みましょう。そしてコードが提示される問題の答えは実質的に「処理の結果が出力される」、「コンパイルエラーになる」、「実行時に例外がスローされる」の三つだけなので、まずどれに当て嵌まるかを考えてみると良いと思います。&lt;/p>
&lt;p>それでは、これから受験する皆さんも合格できますように！&lt;/p></description></item><item><title>Gradleからコマンドライン引数を渡す</title><link>https://retheviper.github.io/posts/gradle-command-line/</link><pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/gradle-command-line/</guid><description>&lt;img src="https://retheviper.github.io/images/gradle.webp" alt="Featured image of post Gradleからコマンドライン引数を渡す" />&lt;p>最近仕事で作っているのは、固有ライブラリーです。ただ思っていたことと違ったのは、まず完全自作ではなく既存のライブラリーを改良するような物であるという点。そして二つ目はSpring Bootで作られているということです。Spring bootは今回初めて触れましたが、以前Spring MVCでWebサイトを作ってみた経験はありました。ただSpringはWebアプリケーションを作るためのフレームワークなので、これを持ってライブラリーを作ったり、Webページのないアプリケーションを作るということは想像もしたことがなかったです。&lt;/p>
&lt;p>それが仕事で両方の使い道に触れることがあって、まだ世の中自分の知らないものばかりだなと思いました。プログラミングとは言語やフレームワークを使えるかどうかの問題だけでなく、どう活用してどんな物を作るかの問題も含めて考えなければならない物ですね。そして画面はなくてもMainクラスを作ることでJarから独立実行ができて、インポートしてはライブラリーとして使える独特？なしようとなりました。そしてもちろんそうするためには少し準備は必要となりました。&lt;/p>
&lt;p>表題では短くなりましたが、今回の主題であり仕事での要件は実際はこういう物でした。&lt;/p>
&lt;h2 id="gradleのtaskで実行するspring-bootアプリケーションにして起動時にはコマンドライン引数を渡す">Gradleのtaskで実行するSpring bootアプリケーションにして、起動時にはコマンドライン引数を渡す
&lt;/h2>&lt;p>こうして書いてみると複雑のようですが、実際はそこまで難しい概念ではないと思います。まずGradleはMavenのようなライブラリー管理ツールとして知られていて、&lt;code>gradlew&lt;/code>に様々なオプションをつけることでJarのビルド、テストなどの行為ができますね。ここでしたいのは、そんなGradleでできるタスク(オプション)を追加することです。そして追加されたタスクを実行すると、Spring Bootプロジェクトとして作成されているライブラリーのMainクラスを起動させることです。&lt;/p>
&lt;p>ただ、皆さんにもわかるように、Sping BootプロジェクトでMainクラスが用意されていると、普通に&lt;code>java -jar project.jar&lt;/code>という風にコマンドラインから起動させることができます。なのになぜあえてGraleのタスクに入れようとしたかというと、以下のような理由があります。&lt;/p>
&lt;h3 id="マルチプロジェクト構造となっている">マルチプロジェクト構造となっている
&lt;/h3>&lt;p>現在の設計で、ライブラリー全体のプロジェクトは複数のサブプロジェクトを含むマルチプロジェクトとなっています。これでちゃんと伝わるか分かりませんが、とにかく表で表現すると以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>rootproject
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>┣ target
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>┣ generator
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>┗ runtime
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>簡単に説明しますと、現在のライブラリーはgeneratorというサブプロジェクトを利用して(runtimeはその時generatorから参照します)targetプロジェクトのコードを操作します。ここで最終的にgeneratorとruntimeはJarとして提供され、使用者はこのライブラリーでの処理を適用したいプロジェクトをtargetの位置に置いて使うことになります。こうなった場合に、コマンドラインからruntimeに依存しているgeneratorのJarを起動してtargetのソースファイルを操作するように指定するのはかなり面倒臭い作業となりますね。これを自動化したかったです。&lt;/p>
&lt;h3 id="起動時に渡したい引数が多い">起動時に渡したい引数が多い
&lt;/h3>&lt;p>Gradleのタスクとして実行したかったもう一つの理由は、ライブラリーが処理を行うために必要な引数の種類が7つくらいがあって、これを全部覚えるのは難しいからです。それにタイポにより処理に失敗する可能性も上がりますね。ここで思ったのが&lt;code>.bat&lt;/code>ファイルを用意していて、使用者がそれを修正したらいいだけの話ではないかと一瞬思いましたが、やはりあまり良い方法ではなかったです。Gradle自体も今はそうなっていますが、別途のファイルを用意するということは、OSごとにそのファイルを作成する必要があるということですね。使用者がどんな環境で実行するかわからないのでとりあえず&lt;code>.bat&lt;/code>と&lt;code>.sh&lt;/code>の両方を準備する必要がありますね。&lt;/p>
&lt;p>それに、このライブラリーがWindowsやLinuxでしか使用されないだろうと言い切れないので、そういう場合はより変数は多くなります。そうなるといちいちOSや環境に合わせて、コマンドライン引数を渡すための方法を作らなければならないですね。わざわざそんなことをするよりは、Gradleのタスクとして用意し(もちろん引数はファイルに記載して読み込まれるように)、環境のことはGradleにお任せした方がコードの管理や便宜性という面からして良さげな気がしました。統一感もあって、使用者にも良い印象になりそうですしね。&lt;/p>
&lt;h2 id="target-buildgradle">[target] build.gradle
&lt;/h2>&lt;p>まずはタスクを実行したいtargetプロジェクトの方から始めましょう。Gradleプロジェクトは基本的に&lt;code>build.gradle&lt;/code>というファイルを持ち、このファイルを修正することで依存関係やプラグインなど様々な設定ができますね。同じく、カスタムタスクを追加したい場合もこちらに追加したいタスクの内容を記載します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>apply from: &lt;span style="color:#e6db74">&amp;#39;default.gradle&amp;#39;&lt;/span> &lt;span style="color:#75715e">// このファイルを読み込むという意味
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>task &lt;span style="color:#a6e22e">taskname&lt;/span>&lt;span style="color:#f92672">(&lt;/span>type: GradleBuild&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">// タスク名とタイプの設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> group &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;application&amp;#39;&lt;/span> &lt;span style="color:#75715e">// gradlew tasks コマンドから、applicationタブにこのタスクが追加される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;run program&amp;#39;&lt;/span> &lt;span style="color:#75715e">// このタスクの説明
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> dir &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;../generator&amp;#39;&lt;/span> &lt;span style="color:#75715e">// タスクの実行基準位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> tasks &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#39;bootRun&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#75715e">// 実行する内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> startParameter&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">projectProperties&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span>args: &lt;span style="color:#e6db74">&amp;#39;${defaultArgs}&amp;#39;&lt;/span>&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#75715e">// コマンドライン引数としてdefaultArgsを読み込む
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>default.gradle&lt;/code>を読み込んでいる理由は、そのファイルにデフォルト値を記載しておき、タスクを実行する時に読み込んだ値をコマンドライン引数として使うためです。最後の行で&lt;code>defaultArgs&lt;/code>と書いてありますが、これがデフォルト値を変数にしたものです。こうやってファイルを分離することで実際の使用者がこのタスクを実行するときは、&lt;code>default.gradle&lt;/code>を修正して引数として渡される値だけを調節することになります。&lt;/p>
&lt;h2 id="target-defaultgradle">[target] default.gradle
&lt;/h2>&lt;p>次に、&lt;code>build.gradle&lt;/code>でタスクを実行する時に読み込まれるファイルの設定は以下のようになります。ここでは読み込まれる対象としての設定と、変数の形で宣言したコマンドライン引数を記載するだけです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>ext &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">// 読み込まれる対象と表記
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> defaultArgs &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-arg1 value -arg2 value&amp;#39;&lt;/span> &lt;span style="color:#75715e">// arg1とarg2の二つの引数がある場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こちらは簡単ですね。引数名が書いてあるので順番は関係なく、あとはそれぞれの値を変えるだけでよくなります。&lt;/p>
&lt;h2 id="generator-buildgradle">[generator] build.gradle
&lt;/h2>&lt;p>それでは続いて、タスクで実行される側の設定です。 targetのタスクでgeneratorを&lt;code>bootRun&lt;/code>すると指定していたので、それに合わせて&lt;code>bootRun&lt;/code>時の挙動を設定します。例えば引数をどんな形で受け取るか、メインクラスはどれかという設定ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>bootRun &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">// bootRun時の挙動
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>project&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">hasProperty&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;args&amp;#39;&lt;/span>&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args project&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">split&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;\\s+&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// コマンドライン引数がある場合、空白を基準に分割する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jar &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#75715e">// Jarとしての設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> manifest &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attributes &lt;span style="color:#e6db74">&amp;#39;Main-Class&amp;#39;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#39;com.package.Main&amp;#39;&lt;/span> &lt;span style="color:#75715e">// メインクラスのクラスパス(パッケージとクラス名)の指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コマンドライン引数を分割する理由は、皆さんも予想しているとは思いますが、Javaのメインメソッドは普通文字列の配列として引数を受け入れるからです。こうやって分割しておくと実際の処理で引数のパースが簡単になりますね。&lt;/p>
&lt;p>ここまでこればGradleの設定は終わりです。あとはJavaでのメインクラスの設定です。&lt;/p>
&lt;h2 id="generator-mainjava">[generator] Main.java
&lt;/h2>&lt;p>generatorのJarを実行した時に呼ばれるメインクラスを作ります。ここでは一般的なJavaのメインメソッドと、Spring bootとしてのメインクラスの作法、JCommanderでコマンドライン引数をパースするための作法、Lombokが混在していますのでそれぞれに対する知識のない方には少し難しいコードになっているかもしれません。&lt;/p>
&lt;p>ただ、実行されている時の動作としては単純なものになっているので、Springのアノテーションにある程度慣れている方ならすぐに理解できると思います。まずコードは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SpringBootApplication&lt;/span> &lt;span style="color:#75715e">// Spring bootとしてのメインクラスにつける&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@EnableAutoConfiguration&lt;/span>(exclude &lt;span style="color:#f92672">=&lt;/span> { DataSourceAutoConfiguration.&lt;span style="color:#a6e22e">class&lt;/span> }) &lt;span style="color:#75715e">// H2関連エラーが出たので付けました&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> CommandLineRunner {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> CoreProcessClass coreProcessClass; &lt;span style="color:#75715e">// @Componentとなっている実際の処理クラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String... args) &lt;span style="color:#66d9ef">throws&lt;/span> Exception { &lt;span style="color:#75715e">// CommandLineRunnerを継承するして実行時の動作をオーバーライドする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> CommandLineOptions options &lt;span style="color:#f92672">=&lt;/span> CommandLineOptions.&lt;span style="color:#a6e22e">parse&lt;/span>(args); &lt;span style="color:#75715e">// パースと同時にBeanを生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coreProcessClass.&lt;span style="color:#a6e22e">startProcess&lt;/span>(options.&lt;span style="color:#a6e22e">getArg1&lt;/span>, options.&lt;span style="color:#a6e22e">getArg2&lt;/span>); &lt;span style="color:#75715e">// 本処理開始&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SpringApplication.&lt;span style="color:#a6e22e">run&lt;/span>(Main.&lt;span style="color:#a6e22e">class&lt;/span>, args); &lt;span style="color:#75715e">// メインメソッドとしては引数を渡すだけ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CommandLineOptions&lt;/span> { &lt;span style="color:#75715e">// コマンドライン引数をパースするクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// JCommanderを使用した引数の設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Parameter&lt;/span>(names &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;-arg1&amp;#34;&lt;/span>, description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;File&amp;#34;&lt;/span>, required &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>, converter &lt;span style="color:#f92672">=&lt;/span> ArgumentsToFileConverter.&lt;span style="color:#a6e22e">class&lt;/span>) &lt;span style="color:#75715e">// 引数は文字列なので、コンバータクラスを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> File arg1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Parameter&lt;/span>(names &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;-arg2&amp;#34;&lt;/span>, description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;String&amp;#34;&lt;/span>, required &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#75715e">// 普通の文字列の場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String arg2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">CommandLineOptions&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> CommandLineOptions &lt;span style="color:#a6e22e">parse&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String... args) { &lt;span style="color:#75715e">// 実際のパースを行うメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> CommandLineOptions options &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CommandLineOptions();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JCommander.&lt;span style="color:#a6e22e">newBuilder&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addObject&lt;/span>(options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">acceptUnknownOptions&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">build&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">parse&lt;/span>(args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> options;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (ParameterException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">getJCommander&lt;/span>().&lt;span style="color:#a6e22e">usage&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> e;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ArgumentsToFileConverter&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> IStringConverter&lt;span style="color:#f92672">&amp;lt;&lt;/span>File&lt;span style="color:#f92672">&amp;gt;&lt;/span> { &lt;span style="color:#75715e">// JCommanderで引数をオブジェクトに変えるためのクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> File &lt;span style="color:#a6e22e">convert&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> String argument) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> File(argument);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="http://jcommander.org" target="_blank" rel="noopener"
>JCommander&lt;/a>を使うことでコマンドラインのパースは簡単にできます。ここでいうパースは単純に文字列だけを意味することではなく、必須項目としての指定(ない場合は例外となる)やオブジェクト変換などの様々なことができるという意味です。例えば引数として渡した文字列があるものはファイルパスだとしたら、それを読み込んでFileオブジェクト化したり複数の引数をListとして取得することもできます。&lt;/p>
&lt;p>そしてパースしたオブジェクトを、本処理で使われるオブジェクトに渡すだけで終わり。意外と簡単に終わりますね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>実は、今まで説明した内容は自分で考えて作り出したものではないです。最初はGradleタスクを作るために導入した&lt;a class="link" href="../java-conflict-of-module" >ライブラリーの問題&lt;/a>があってなかなか仕事が進まなく、すでに出来上がっていたものを参考にしたものにすぎません。でもここであえて紹介するのは、皆さんに共有する価値があると思ったからです。&lt;/p>
&lt;p>特にサーバーで動くアプリケーションを作る場合はやはりコマンドラインで起動させる場合が多いですし、環境によっては引数で違う値を渡す必要があるかもしれません。そのような時に、このようにファイルから引数を渡して実行するタスクを作成して環境ごとに設定を変えたり違うファイルを読むようにするとかなり便利そうですね。なので皆さんにもぜひ紹介したいと思いました。&lt;/p>
&lt;p>そして個人的には、今は自分も先輩方の成したものから学ぶばかりですが、いつかはこんな考え方もあるんだと後輩に伝えられたらいいなと思わせる、大事な経験でした。これから先はまだまだ遠いですね！&lt;/p></description></item><item><title>Moduleの問題に会った話</title><link>https://retheviper.github.io/posts/java-conflict-of-module/</link><pubDate>Sun, 08 Sep 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-conflict-of-module/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Moduleの問題に会った話" />&lt;p>最近のJavaはバージョンアップが早いですね。自分が初めて学んだものは1.8でしたが、すぐ9がでて今は13もリリースを目前としています。バージョンアップはバグ修正や性能の向上など良い面が多いためなるべく自分が使っているプログラムは常に最新のバージョンを維持したいですが、言語のバージョンが上がる度、何が変わったかを確認しすでに存在するコードを見直すのは簡単な問題ではいですね。&lt;/p>
&lt;p>Javaはかなり歴史が長いので、現在のトレンドと比べてみると不便(パラダイムが変わったからという理由が多いと思いますが)な面が多いです。そして1.8が維持された期間が長かったのですが、そのため流行には遅れていますね。10になって型推論が導入されるなどトレンドを追いかけているような面もありますが、Kotlinのように同じくJVMを使う言語と比べてみるとまだ先が遠い印象はあります。&lt;/p>
&lt;p>もちろん変化は肯定的なものであって、元の特徴を維持しながらもトレンドに合う書き方ができるようになったというのは、その言語を使えるユーザーのプールが広くなったとも評価できるでしょう。でも、全ての要素において「古いものと新しいもの共存」ができるわけではなさそうです。そういう場合はどちらを使うかを選択する必要がありますね。&lt;/p>
&lt;p>今回のポストで話たいModuleがその代表的なものです。昔からの問題を改善するために導入されたものですが、結局は既存のコードに影響を与えてしまい、対応が必要となる部分です。最初は自分が書くコードでは考慮する必要がないものだろうと思っていたのですが、どうもそうはいかなかったです。なのでここでは、JavaのModuleが何であり、どんな問題を経験したかを述べたいと思います。&lt;/p>
&lt;h2 id="project-jigsaw">Project Jigsaw
&lt;/h2>&lt;p>ModuleはProject Jigsawという名で、1.7から導入を検討していたものらしいです。Moduleという名からわかるように、アプリケーションを起動する時読み込むライブラリー(Java内臓の)を選択することができるシステムです。1.8まではコマンドラインで起動するアプリケーションを作るとしても、基本的なシステムライブラリーであるSwingなどが含まれていたのですが、それを調整できるようになりました。要らないシステムライブラリーを除去するとアプリケーションのサイズも小さくなりますし、メモリーを節約できるというメリットもありますね。また、Javaの特徴でもあった「完璧にロードされるまでには時間がかかる」という問題も、このModuleの設定である程度解消できるようになりました。&lt;/p>
&lt;p>そのほかにも、パッケージの「Publicすぎる問題」も、Moduleで解消できるようです。JavaのクラスはProtected宣言で同じパッケージでアクセスできるようにできますが、パッケージが細かく分けられた場合は同じライブラリーの中でもアクセスできませんでした。そういう場合はPublicで宣言するしかなかったですね。Publicで宣言されたクラスはライブラリーの中だけではなく、どこでもアクセスできるようになるため問題が生じる可能性もあります。ライブラリーを作りながらクライアントに使って欲しいクラスと使って欲しくないクラスを分けることが難しいことだったということです。これをModule設定により外部へ公開するクラスと、ライブラリー内部に向けて公開されるクラスで分けられるようになりました。&lt;/p>
&lt;h2 id="moduleの実例">Moduleの実例
&lt;/h2>&lt;p>では、Public問題をModuleでどう解消できたかを、コードを持って説明します。まだ自分もModuleを積極的に使っているわけではないので基本となる部分だけですが、重要なポイントは以下の三要素だそうです。&lt;/p>
&lt;ul>
&lt;li>Name&lt;/li>
&lt;li>Exports&lt;/li>
&lt;li>Requires&lt;/li>
&lt;/ul>
&lt;p>まずNameは、Moduleそのものの名称を意味します。パッケージ名と同じ命名規則で書きます。次にExportsは、このModuleから外へ公開するパッケージのことを意味します。ModuleではPublicであっても、Exportsと明示されていないパッケージは外部からアクセスすることができません。そして最後にRequiresは他のModuleに対する依存関係を表します。&lt;/p>
&lt;p>これらを実際のコードで書くと、以下のようになります。デフォルト・パッケージに&lt;code>module-info.java&lt;/code>として記述されます。(Java9以後のシステムライブラリーから確認できます)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// module-info.javaの書き方&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>module com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">mylibrary&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exports com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">mylibrary&lt;/span>.&lt;span style="color:#a6e22e">api&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> requires com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">exlibrary&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Exportsの場合、公開対象を指定することができます。つまり、アクセスできるMobuleを指定することができるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// exlibrary限定のPublic設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>module com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">mylibrary&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exports com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">mylibrary&lt;/span>.&lt;span style="color:#a6e22e">api&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> to com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">exlibrary&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Moduleはもちろん外部ライブラリーに対しても使うことができます。&lt;code>module-info.java&lt;/code>を作成する方法もありますが、Java9以前に作られたライブラリーの場合にはそれがない可能性が高いですね。このようにModuleかされていないライブラリーを含ませる必要がある場合は&lt;code>Automatic Module&lt;/code>か&lt;code>Unnamed Module&lt;/code>の二つの方法からライブラリーを分けて使うことになります。両方自動的にModuleとして扱われるという面では同じで、全てのパッケージにアクセスできるという面では同じですが、前者は&lt;code>modulepath&lt;/code>に属するものとして名前がある(Jarファイル名となります)ことに対して、後者は&lt;code>classpath&lt;/code>に属するもので名称がないためRequiresで指定することができません。&lt;/p>
&lt;h2 id="moduleでハマったところ">Moduleでハマったところ
&lt;/h2>&lt;p>自分がModuleであった問題は、同じパッケージをもつ二つのライブラリーの競合によるものでした。問題が生じたのは、既存のプロジェクトにGradleのタスクを追加しようとしていたので原因でした。Gradleのタスクを作成する方法は&lt;code>build.gradle&lt;/code>に直接taskを作成することでもできますが、最初自分が参考にしていた方法(Gradleの公式文書に従いました)では&lt;code>java-gradle-plugin&lt;/code>というプラグインを含ませる方法でした。こうすると自動的にJavaのライブラリーが追加されて、Javaでプラグインを書けられるようになりますが、ここに含まれているライブラリーがJavaのシステムライブラリーと競合を起こしました。&lt;/p>
&lt;p>元のプロジェクト(Java11を使っています)では&lt;code>javax.xml&lt;/code>をインポートしていて、これがJava9からは&lt;code>Deprecated&lt;/code>になり、最終的にJava11から除去されたらしいです。それがEclipse上では&lt;code>Unnnamed Module&lt;/code>として読み込まれていたらしく、ちょうど&lt;code>java-gradle-plugin&lt;/code>のパッケージにも同一名のパッケージが含まれていたので競合が起こったのです。そもそも除去されている扱いなので競合が生じるのがおかしいですが…エラ〜メッセージでは&lt;code>The package javax.xml.transform is accessible from more than one module: &amp;lt;unnamed&amp;gt;, javax.xml&lt;/code>と出力されていました。&lt;/p>
&lt;p>&lt;a class="link" href="https://stackoverflow.com/questions/51094274/eclipse-cant-find-xml-related-classes-after-switching-build-path-to-jdk-10" target="_blank" rel="noopener"
>似たような事例&lt;/a>を参考にすると、二つの解決法が提示されていましたがどちらも自分のプロジェクトでは使えませんでした。&lt;code>module-info.java&lt;/code>を作成するとマルチプロジェクトとなっていてサブプロジェクト間のパッケージ依存関係まで考慮するには複雑な手続きが必要でしたし、Eclipseのモジュール依存関係設定からシステムライブラリーの&lt;code>javax.xml&lt;/code>を除去すると、他にインポートしている&lt;code>java.sql&lt;/code>が&lt;code>javax.xml&lt;/code>に依存しているのでこちらも使えなくなるという問題がありました。&lt;/p>
&lt;p>そしてリンクの文を読んでみると、最新のJava13までこの問題(自分のケースと完璧に一致しているとは言えませんが)は解決されてないというので、どうしようもない状態でした。&lt;code>java-gradle-plugin&lt;/code>はGradleで管理されているライブラリーなのでこちらからうかつに手を出すこともできませんでした。&lt;/p>
&lt;h2 id="結局どうしたらいいか">結局どうしたらいいか
&lt;/h2>&lt;p>現時点では、外部ライブラリーを維持したまま競合だけを避ける方法はなさそうです。自分のModuleに対する理解がまだ足りてないことも原因かとは思いますが、結局はこのような事態が発生するとなるべく競合の原因となるライブラリーを除外するしか他の道はなさそうですね。便利さのために導入された新しい機能が、思わぬところで問題を起こしてしまうのはそう珍しいことでもないですが…3日ほど悩んだ私の選択は結局、そのライブラリーを使わないということしかなかったです。&lt;/p>
&lt;p>もちろん、Moduleの問題なのでバージョンに対するこだわりがなければJavaを1.８に下げるという方法もあります。ただ1.8はいずれサポートが終わるはずで、これからもJavaのバージョンはどんどん上がっていくはずなのでいつかは直面することになるかもしれない問題ですね。どうかJava14ではこのような問題が起こらないことを祈ります。&lt;/p></description></item><item><title>インスタンスをImmutableにするための工夫</title><link>https://retheviper.github.io/posts/java-thoughts-of-immutable/</link><pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-thoughts-of-immutable/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post インスタンスをImmutableにするための工夫" />&lt;p>Pythonのような本格的なオブジェクト指向言語ではあまり見かけられないことですが、Javaではいわゆる参照型の以外にもプリミティブ型というものがありますね。どうもJavaが初めて世に出た時代はまだオブジェクト指向という概念が生まれたばかりだったのでそうなったのではないかと思います。このプリミティブ型が存在するという点から、Javaは完全なオブジェクト指向言語ではないという話もあるようです。&lt;/p>
&lt;p>プリミティブ型に対する定義は言語ごとに少し違うようですが、私が知っているのはJavaだけなのでJavaの基準からいうと、プリミティブ型はオブジェクトではないデータ型を指す言葉です。そしてそれは、メモリー上に載せたデータをどう持つかの観点がオブジェクトとは違うということです。オブジェクトはメモリー上のデータが位置する「アドレス」を指すことに対して、プリミティブ型はそれぞれ独立したメモリー領域にデータを載せます。&lt;/p>
&lt;p>これを証明するのが、条件文での演算子の違いです。プリミティブ型で、二つの変数が同一なデータを持っているかを比較する演算子は&lt;code>==&lt;/code>ですね。しかし、同じ方法でオブジェクト、よく挙げられている例としてStringだと、同じ方法を使えません。&lt;code>equals()&lt;/code>を使わないとStringでの正確な値の比較はできなくなりますね。なぜならオブジェクトが持っている値そのものはメモリーのアドレスなので、「同じ値を入れた」つもりでもそれぞれのオブジェクトが指しているメモリーのアドレスは違う可能性があるからです。&lt;/p>
&lt;p>このように、メモリー問題はプログラミングに対してはかなり重要なものです。いくらメモリーの絶対値が増えても、メモリーに載せられたデータをどう参照するか、どう扱うかを間違えたら思い通りにプログラムは動かない可能性があるからです。そしてまた重要なのは、メモリー上に載せたデータを参照する方法だけではなく、どう管理するかということです。正確なデータを入れたつもりが、途中で変わったりすると、参照の仕方が正しくてもプログラムが正常動作しない可能性がありますからね。&lt;/p>
&lt;p>そういう意味で、今回はImmutableなクラスについて述べたいと思います。&lt;/p>
&lt;h2 id="immutable-objectとは">Immutable Objectとは
&lt;/h2>&lt;p>Immutavle Objectとは、簡単にいうと「一度インスタンスが生成されたら、そのインスタンスが持つデータが変わらない」オブジェクトのことです。逆に、インスタンスの生成以後もデータが変わる可能性のあるオブジェクトはMutableと言います。代表的なMutableクラスとしてはBeanを挙げられますね。Setterを通じて自由にデータを変えることができます。そしてImmutableなクラスとして代表的なのは、Stringと言います。Stringは値を代入しても、元のデータはGarbage Collectorの対象になるまでメモリーに残り、そのStringオブジェクトが指すメモリーのアドレスだけ変わるからです。&lt;/p>
&lt;p>先に述べたように、プログラムの中でオブジェクトが持っているデータが途中で変わると、安定的な動作を保証できなくなります。そしてマルチスレッド環境では、二つのオブジェクトが同じメモリーアドレスを参照していると、スレッドそのものが止まってしまう可能性もあります。もしそのような場合が生じるとどこで問題が起きたか調べることも難しいですね。このような問題を回避するため、Immutableなクラスを作成するときは「インスタンスの生成以後はデータが変わらない」ことと、「クラスの持つデータが同じメモリーアドレスを参照しないように」します。&lt;/p>
&lt;p>それでは、Immutableなクラスを作成する方法にはどんなものがあるか、見ていきましょう。&lt;/p>
&lt;h2 id="setterは使わない">setterは使わない
&lt;/h2>&lt;p>最近はかなりLombokを使う場合が多く、ある程度定型的なコードを生成してくれるので、Lombokのアノテーションを使って生成されるコードを持って説明したいと思います。Lombok自体の紹介は、&lt;a class="link" href="../java-design-pattern-builder" >以前のポスト&lt;/a>を参照してください。&lt;/p>
&lt;p>Lombokでは、アノテーションをつけることで簡単にBeanを生成できます。クラスの上に&lt;code>@Data&lt;/code>をつけることで、簡単にSetterとGetterができますね。これを使った場合、直接メソッドを手で書くより安定的でコードの量も減るため積極的に使えます。&lt;/p>
&lt;p>しかし、Setterが生成されるということはImmutableなオブジェクトにならないことを意味します。次は実際、&lt;code>@Data&lt;/code>をつけることで生成されるコードの例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @Dataの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドだけを定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以下のメソッドたちが自動生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setName&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setColor&lt;/span>(String color) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span> &lt;span style="color:#f92672">=&lt;/span> color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getColor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうなった場合、フィールドが&lt;code>final&lt;/code>で守られていないといつでもSetterにより値が変わる可能性があります。そして一部Setterメソッドが使われていない場合は全フィールドに値が設定されてないままnullになってしまう可能性もありますね。これはImmutableの定義にふさわしくないコードとなっています。&lt;/p>
&lt;p>幸い、Lombokで提供するアノテーションの中にはImmutableなクラスを生成するためのアノテーションもあります。&lt;code>@Value&lt;/code>というものです。これを使うと、&lt;code>@Data&lt;/code>と同じ機能をしながら(インスタンスの生成とフィールドの値を指定する方法は変わりますが)もImmutableなクラスを生成することができます。こちらのアノテーションを使ったコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @Valueの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドだけを定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以下のメソッドたちが自動生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span>(String name, String color) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span> &lt;span style="color:#f92672">=&lt;/span> color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getColor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最初、インスタンスを生成するときはコンストラクターで全フィールドを引数として指定します。フィールドが多いとどれがどれかわからなくなりますが、フィールドの値指定が漏れる可能性は無くなります。そしてSetterがないため一度生成されたインスタンスに対してはフィールドを変更できなくなります。&lt;/p>
&lt;p>そしてこの&lt;code>@Value&lt;/code>アノテーションの良いところは、Builderパターンと両立できるというところです。&lt;code>@Builder&lt;/code>をつけることで、インスタンスの生成時にそれぞれのフィールドがどんなものであるかを明確に確認できますね。ただ、Builderパターンでは全フィールドに値を指定する義務はないので注意が必要です。この問題は、手で&lt;code>build()&lt;/code>メソッドを書くことで回避できます。ある意味、オーバーライドに近いことだと言えますね。コードで表現すると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以下のコードだけを作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> CarBuilder {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// nullのフィールドがあったらNPEを発生させる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Car &lt;span style="color:#a6e22e">build&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> NullPointException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> NullPointException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Car(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はやはりコードが複雑になり、フィールドが増えるとまたそれに対応しなければならなくなりますね。フィールドがまた&lt;code>List&lt;/code>だったりすると、ループでnull検査をする必要もあるはずです。このように&lt;code>@Value&lt;/code>だけを使う場合に比べ、コードが複雑になっているので、便宜生と安全性でどちらを選ぶかを考える必要がありますね。&lt;/p>
&lt;h2 id="final宣言">final宣言
&lt;/h2>&lt;p>Beanを使うしかない場合もありますね。例えばフィールドがnullになっても良い場合もあるはずです。それともそのBeanを持って処理をするメソッドでnullを検査するなど、何かの措置をしといたら良い場合もあるはずでしょう。&lt;/p>
&lt;p>そしてBeanを使う場合、フィールドを&lt;code>private&lt;/code>に宣言して外部からの直接的なアクセスを防ぐということは常識となっています。&lt;code>public&lt;/code>で宣言されたフィールドだと、どこでもアクセスできるようになり知らないうちに値が変更される可能性がありますからね。それを防ぐために、Beanのフィールドに直接的なアクセスを許容しなく、Setterメソッドで値を指定してGetterメソッドで値を参照することは暗黙のルールとなっています。&lt;/p>
&lt;p>Setterメソッドによってフィールドに直接アクセスせずに値を指定することで最低限の安全は確保したと言いたいところですが、実はそうでもありません。なぜなら、依然としてフィールドの値は何度でも変わる可能性があるからです。一度Setterで値を入れて、その後にまたどこかでSetterを読んでいたら、Beanの持つフィールドの値は上書きされます。&lt;/p>
&lt;p>これを防ぐためには、フィールドに&lt;code>final&lt;/code>を使うべきです。final宣言されたフィールドは、初期化以後にその値が代入されないため、安定性が上がります。final宣言されたフィールドに値を代入しようとするとコンパイルエラーとなるため、エラーを見つけやすいというところも良いですね。&lt;/p>
&lt;p>また、全フィールドがfinalで宣言されている場合、&lt;code>@Data&lt;/code>アノテーションは実質的に&lt;code>@Value&lt;/code>アノテーションと同じコードを生成します。もちろん、場合によってはfinalではないフィールドを持たせることもできます。そういう場合のコードは以下のようになります。場合によってはこれも必要かもですね！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @Dataの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// colorだけがfinal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以下のメソッドたちが自動生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span>(String color) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span> &lt;span style="color:#f92672">=&lt;/span> color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setName&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getColor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、finalとなっているのはあくまでもこのクラスのフィールドのみということに気をつけなければならないです。Carオブジェクトを生成時に使われたデータが、以後も固定されて更新ができなくなります。&lt;/p>
&lt;h2 id="浅いコピーと深いコピー">浅いコピーと深いコピー
&lt;/h2>&lt;p>Setterメソッドのもう一つの問題は、オブジェクトをコピーした場合に、コピー先のオブジェクトの値を変えるためにSetterを使うとそれがコピー元に影響するということです。簡単に以下のようなコードを作成したとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @DataのCarクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Car car1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Car();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car1.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;My car&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car1.&lt;span style="color:#a6e22e">setColor&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;red&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 友達が私と同じ車を買った&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Car car2 &lt;span style="color:#f92672">=&lt;/span> car1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Your car&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 出力してみる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(car1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(car2);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコマンドをコンパイルして実行してみると、どちらのCarも&lt;code>name&lt;/code>が&lt;code>Your car&lt;/code>になっていることを確認できます。なぜこうなったのでしょう？先はStringがImmutableと言っていましたけどね。&lt;/p>
&lt;p>これは、&lt;code>car1&lt;/code>の値だけを&lt;code>car2&lt;/code>にコピーするという意図から書かれたコードが、実は&lt;code>car1&lt;/code>と&lt;code>car2&lt;/code>は「同じメモリーアドレスを参照する」というコードになってしまったからです。同じアドレスから値を参照するため、そのアドレスの値が変わると両方に影響するわけです。&lt;/p>
&lt;p>このようにオブジェクトは参照が変わるだけなので、代入だけではそれぞれが独立していると言えなくなります。プリミティブ型が値そのものを保存するので代入でも安全なのとはまた違うところですね。このようにオブジェクトの「参照」だけが変わる状況を「浅いコピー」と言います。&lt;/p>
&lt;p>今までの展開から推測できるように、オブジェクトの参照を分離する必要があるでしょう。参照が独立していると、片方の値が変わっても他には影響ないはずですからね。参照がオブジェクトごとに違うというのは、同じ値を持ってメモリーに新しいオブジェクトを生成するということと同じ意味です。そしてこれを「深いコピー」と呼びます。&lt;/p>
&lt;p>深いコピーには様々な方法があります。まずはフィールドのオブジェクトを新しく生成することです。例えば、以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスを生成して値を入れてみる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Car car2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Car();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> String(car1.&lt;span style="color:#a6e22e">getName&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> String(car1.&lt;span style="color:#a6e22e">getColor&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 値を変えてみる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> String(&lt;span style="color:#e6db74">&amp;#34;Your car&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じく出力してみると、今回はちゃんと&lt;code>car2&lt;/code>の値だけが変わったことを確認できます。しかし、全てのフィールドに対してこうするのはあまり便利ではないですね。とこかでメソッド化することはできないのでしょうか？&lt;/p>
&lt;p>簡単なのは、インタフェースを利用することです。&lt;code>Cloneable&lt;/code>を継承することで簡単にオブジェクトをクローンできるようになります。ただ少し、メソッドを作成する必要はありますがね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Cloneable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// cloneメソッドを作る &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Car &lt;span style="color:#a6e22e">clone&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> CloneNotSupportedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (Car) &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうすると、以下のような方法で深いコピーができるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> car2 &lt;span style="color:#f92672">=&lt;/span> car1.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Your car&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">catch&lt;/span> (CloneNotSupportedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法を使うときに注意すべきことがあります。クラスに&lt;code>clone()&lt;/code>を定義したからって、全てのフィールドに対して深いコピーを保証するわけではないということです。例えば&lt;code>Car&lt;/code>クラス内にさらに&lt;code>Engine&lt;/code>のような、Beanクラスがフィールドとして定義されていると、そのフィールドは浅いコピーになる可能性があるということです。これを回避するためには、&lt;code>Engine&lt;/code>クラスにも&lt;code>Cloneable&lt;/code>を継承させる必要があります。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Cloneable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 追加したフィールド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Engine engine;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドも深いコピーをさせる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Car &lt;span style="color:#a6e22e">clone&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> CloneNotSupportedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Car car &lt;span style="color:#f92672">=&lt;/span> (Car) &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> car.&lt;span style="color:#a6e22e">engine&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">engine&lt;/span>.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> car;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Engine&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Cloneable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String cylinders;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// cloneメソッドを作る &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Engine &lt;span style="color:#a6e22e">clone&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> CloneNotSupportedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (Engine) &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ListやMapの場合はどうクローンしたら良いでしょうか？同じくオブジェクトをクローンする観点からすると、両方とも方式は似ています。ループによるクローンですね。例えば以下のような方法でクローンができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listのコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> carList1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> carList2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Car car : catList1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carList2.&lt;span style="color:#a6e22e">add&lt;/span>(car.&lt;span style="color:#a6e22e">clone&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Mapのコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> carMap1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> carMap2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry : carMap1.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carMap2.&lt;span style="color:#a6e22e">put&lt;/span>(entry.&lt;span style="color:#a6e22e">getKey&lt;/span>(), entry.&lt;span style="color:#a6e22e">getValue&lt;/span>().&lt;span style="color:#a6e22e">clone&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでImmutableなクラスを作り、コピーもできるようになりますね。&lt;/p>
&lt;h2 id="immutableなクラスで注意すること">Immutableなクラスで注意すること
&lt;/h2>&lt;p>&lt;a class="link" href="../java-reflection" >Reflectionに関するポスト&lt;/a>でも紹介したように、Reflectionを使うとフィールドに直接アクセスができ、privateで宣言されていてもアクセスを可能にすることもできます。つまりいくらImmutableなクラスを作ったとしても、Reflectionを使うとフィールドの値を変えることはできるということですね。&lt;/p>
&lt;p>そしてImmutableなクラスを作るということは、結局メモリーの使用量が上がるということでもあります。常に新しくオブジェクトを生成し、それぞれがメモリーを占有することになりますからね。もちろん現代のマシンのメモリーは多少のオブジェクトが作られても耐えられるメモリーを持っていますし、GCも活発に動いてくれるので一般的には心配するようなことではないですがね。&lt;/p>
&lt;h2 id="singletonクラスの変数には注意">Singletonクラスの変数には注意
&lt;/h2>&lt;p>Immutableとも関係があることですが、以前紹介した&lt;a class="link" href="../java-design-pattern-singleton" >Singletonクラス&lt;/a>を作成する場合にも、そのクラスが持つフィールドには注意しなければならないです。このクラスはインスタンスが生成されるとアプリケーションが終了するまで一つのインスタンスが使われるため、フィールドの値が変更される可能性があったら致命的です。処理ごとに結果が変わる可能性があるからです。なのでSingletonクラスにはなるべくフィールドを持たせないようにするか、final宣言をしておくなど、フィールドの値が変わる可能性を最初から封鎖しておく必要があります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>個人的に、プログラミングの始まりが「どう実現するか」だとすると、プログラミングの完成は「どう安定させるか」であると思います。もちろん、性能を改善させたり、維持補修を簡単にさせたりするテクニックも大事ですが、安定的に動作するプログラムを作るということがもっとも難しいものですからね。要件が増えれば増えるほど、コードは複雑になり、例外が発生する可能性も高くなります。Immutableなクラスを作るということは、そのような例外を回避するための一歩であるゆえ、信頼できるプログラムを作り出せるという面で大事な知識なのではないかと思います。&lt;/p>
&lt;p>これからもこのような知識に触れ、身につけていきたいですね！&lt;/p></description></item><item><title>デザインパターン、Singleton</title><link>https://retheviper.github.io/posts/java-design-pattern-singleton/</link><pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-design-pattern-singleton/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post デザインパターン、Singleton" />&lt;p>昔からPCを使うといつも問題となるのはメモリーだった覚えがあります。私が初めてPCに触れたのは父が仕事て使っていたもので、当時はOSとしてDOSを採用していてゲームでもしたいときはいつもメモリーの設定を変える必要がありました。そのときはそれが不便だとも思わず、ただゲームができればいいと思っていました。&lt;/p>
&lt;p>しかし時間が経ち、大学でのプレゼンテーションを準備しながら感じたのは、やはりメモリーが十分でないとマルチタスクがきついということでした。今はPCのパーツの中でもっともアップグレードした時に性能向上を感じられるのはSSDと言いますが、それはあくまでCPUとメモリーを安定的に確保できる時代になったおかげと思います。まずメモリーが足りないととにかく遅いとしか思えない時代もありましたからね。&lt;/p>
&lt;p>そしてプログラムを作る立場となってからは、メモリー問題はより現実的な問題となりました。例えばとあるシステムを構築し、複数の使用者がそのシステムを利用するとしたら、限定された資源であるメモリーが足りなくなる可能性はハードウェアが飛躍的な発展を成している現在でも存在しています。オブジェクトを作るたび、残りのメモリーは減り続けるので。&lt;/p>
&lt;p>ならば最適化という面で、メモリーを節約するには、無駄なオブジェクトの生成は抑えるべきでしょう。そのためにできる方法がないかと思っていたら、すでに存在していました。今回のポストの主題となる、Singletonパターンです。&lt;/p>
&lt;h2 id="singletonパターンとは">Singletonパターンとは
&lt;/h2>&lt;p>Singletonパターンは、アプリケーション内でインスタンスが一度だけ生成され、そのアプリケーションが終了するまで使われるクラスを作るためのデザインパターンです。Beanの場合はそれぞれ違うデータを持つインスタンスをたくさん生成して使いますが、こちらはインスタンスが一つしかないため動的なフィールドを持たせないですね。なのでどこからでもアクセスできるような不変のデータを持ったり、特定の処理を繰り返す必要がある時このSingletonパターンでのクラスを作る場合があります。&lt;/p>
&lt;p>このようなクラスがあって何が良いかというと、先に述べたメモリー問題です。例えばグローバル変数の場合、どんなクラスからもアクセスできるのであまりSingletonと変わらないようにも見えます。しかしグローバル変数の場合は、それが使われるが使われないが常にメモリーのなかにあって、無駄になってしまう可能性もあります。しかしSingletonの場合は、必要であれば生成し、必要でなければ生成しないこともできます。なのでメモリーを節約できますね。&lt;/p>
&lt;p>仕事では主に、ユーティリティークラスとしてSingletonクラスを作ることが多かったです。データの処理を繰り返して行う必要がある時、毎回インスタンスを生成することはメモリー問題もあって、コードが無駄に冗長になる傾向がありました。これをデータはそれぞれ違うインスタンスのBeanに持たせ、Singletonクラスに処理を任せることでコードの量も減らし、メモリーも節約することができました。&lt;/p>
&lt;h2 id="古典的singletonパターン">古典的Singletonパターン
&lt;/h2>&lt;p>それではSingletonクラスをどうやって作るのかを紹介します。デザインパターンでは様々なパターンがあって、その中の一つであるSingletonもまた様々な方法で具現できます。まずは古典的な方式を紹介します。&lt;/p>
&lt;p>ここで目的はインスタンスを一つだけにすることなので、外部からすでに生成されているインスタンスにアクセスはできても、そのインスタンスを勝手に作れないようにします。そうするにはコンストラクターにアクセスの制限が必要ですね。まずコードで紹介しましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// クラスはpublicにして外部からアクセスできるようにする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// コンストラクターはprivateにして、外部からはアクセスできないようにする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかしこれだけでは十分ではありません。どこかでインスタンスを生成する必要がありますね。また、先に述べたようにインスタンスの生成の時点は外部で制御できるようにしなければなりません。なのでprivateのコンストラクターにアクセスできるメソッドを用意する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスを保存するための静的フィールド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスの返却(インスタンスが生成されたない場合は生成してから返却する)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uniqueInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniqueInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SingletoneClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 普通のメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まずstaticで、自分のインスタンスを保存できるフィールドを宣言します。外部からSingletonクラスのインスタンスを取得するためにはこれを使うようになります。宣言だけで、この段階でインスタンスを生成しないのはグローバル変数と区別するためです。&lt;/p>
&lt;p>次に、インスタンスが生成されてない場合でもアクセスできるstaticメソッドを作成します。ここからこのSingletonクラスのインスタンスを取得するようになります。メソッドの中はでは戻り値としてインスタンスのフィールドをセットし、もしインスタンスが生成されてない場合にだけnewをするようにします。&lt;/p>
&lt;p>これで外部からは以下のように使えるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスの取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SingletonClass singletonInstance &lt;span style="color:#f92672">=&lt;/span> SingletonClass.&lt;span style="color:#a6e22e">getInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスのメソッドを使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>singletonInstance.&lt;span style="color:#a6e22e">doSomething&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでどこからでも同一なインスタンスでつかけるSingletonクラスができました。&lt;/p>
&lt;h2 id="古典的singletonパターンの問題">古典的Singletonパターンの問題
&lt;/h2>&lt;p>マルチスレッドを考える必要がない場合なら気にすることはないですが、現代のプログラミングはそうでもないですね。特に何かのシステムを作り、サービスとして提供する場合は複数の使用者によって同じクラスが要請される場合があります。&lt;/p>
&lt;p>そしてクラスの中が複雑でインスタンスの生成に時間がかかったり、ほぼ同時のタイミングでインスタンスが要請されると古典的なSingletonパターンでは複数のインスタンスが生成されることを塞げられない場合があります。この場合は元の設計通り動かなくなり予想できない例外が発生する可能性がありますね。&lt;/p>
&lt;p>もちろんこれらを解決するためにいくつかの方法が提示されてはいますが、それらの解決策にもデメリットはあります。まずどんな方法があり、それぞれのデメリットには何があるか見ていきましょう。&lt;/p>
&lt;h2 id="マルチスレッド問題を開所するために">マルチスレッド問題を開所するために
&lt;/h2>&lt;p>他にも方法はありそうですが、スレッドセーフなSingletonクラスを生成する方法は以下のようなものがあります。&lt;/p>
&lt;ol>
&lt;li>インスタンスの生成をシンクロさせる&lt;/li>
&lt;li>Double-Checked Lockingを使う&lt;/li>
&lt;li>JVMのクラスローダーにお任せ&lt;/li>
&lt;/ol>
&lt;p>まずインスタンスの生成をシンクロさせる方法は簡単です。インスタンスを取得するための&lt;code>getInstance()&lt;/code>メソッドに&lt;code>synchronized&lt;/code>を追加することです。コードで見るとあまり変わらないので、古典的Singletonパターンのクラスがあればもっとも簡単に適用できる方法ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスを提供するメソッドをシンクロさせる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">synchronized&lt;/span> SingletonClass &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uniqueInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniqueInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SingletoneClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、&lt;code>synchronized&lt;/code>の問題は性能です。100倍以上も処理の速度が遅くなる場合もあるらしいので、マルチスレッドを性能のために使う場合があれば、あまり望ましくないですね。&lt;/p>
&lt;p>次の方法は、二重チェックです。インスタンスがnullであればシンクロさせます。この方法だと毎回シンクロさせる必要がないので(2回目からはインスタンスがnullでないため)最初の一回以外は性能が低下しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// volatile宣言で安定性を確保&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスの二回確認&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uniqueInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (SingletonClass.&lt;span style="color:#a6e22e">class&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uniqueInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniqueInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SingletoneClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>volatile宣言を使う理由は、変数がCPUのキャッシュメモリーに入ることを防止するためだそうです。プログラムのデータは最初ハードディスクから読み込まれシステムメモリーに載せられますが、そのあとCPUでの処理が行われる時にはさらにCPUのキャッシュメモリーに載せられることがあります。&lt;/p>
&lt;p>最近は複数のCPUを搭載しているシステムも少なくないので、それぞれ違うCPUのキャッシュメモリーにインスタンスが入ってしまうとインスタンスが生成されているかどうかわからなくなりますね。volatile宣言でシステムメモリーにフィールドを乗せることで、インスタンスの生成がより安定的に行われます。でも依然として、同期化による性能低下を一回は経験しなければならないという問題があります。&lt;/p>
&lt;p>最後は、JVMが起動する時にインスタンスを生成させる方法です。この方法では外部からは確実にインスタンスの制御ができなく、常にインスタンスが生成されるためマルチスレッド問題を回避できますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドにインスタンスの生成を宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass uniqueInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SingletonClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスのチェックも要らなくなる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>クラスが読み込まれる時点でJVMからインスタンスを生成してしまうので、どんなスレッドからも静的フィールドにはアクセスできなくなります。ただ、これならグローバル変数で宣言することとあまり変わらないので、使われなくてもメモリー上にはインスタンスが生成されたままであるという問題は残ります。もちろん、グローバル変数宣言とは違ってインスタンスは唯一であることが違うところです。グローバル変数だとstaticでフィールドを宣言しても、違うクラスでまたを宣言できますので。そもそもグローバル変数には何が入っているかわからなくなる場合が少なくないので、乱発しないほうがいいですね。&lt;/p>
&lt;h2 id="メソッドとフィールドを全部staticに宣言して良いのでは">メソッドとフィールドを全部staticに宣言して良いのでは？
&lt;/h2>&lt;p>もちろんその方法もありです。しかし、初期化の過程が極めて簡単な場合にだけ有効(フィールドが何もないなど)な方法と言えます。クラス自体が単純な構造をしていて、メソッドは単純に外部から入れられたデータを処理して返すだけならできる方法ですね。実際使えない方法ではないですが、後の機能拡張などを考えると良い方法ではなくなりますね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>Singletonパターンは幅広く使われていて、確かに魅力的なクラスの設計の方法ではあります。しかしマルチスレッド問題を回避するため工夫しなければならない問題があり、唯一なインスタンスなためフィールドの処理にも気をつけなければならない面があります。とあるスレッドでインスタンスが使われていて、フィールドにデータを入れたのをまた違うスレッドでアクセスしようとすると問題が起こり得る可能性がありますので。&lt;/p>
&lt;p>他にもOOPの原則である、「一つのクラスは一つだけの責任を持つ」ということからしても、Singletonクラスは問題を持っています。何かの処理を担当していながらも、自分自身でインスタンスを管理するという二つの責任を持っていますからね。そしてコンストラクターがprivateであるため、サブクラスを作られなくなるという問題があります。サブクラスを生成するためにコンストラクターをpublicやprotectedに変えるとSingletonではなくなるジレンマもできますね。&lt;/p>
&lt;p>それでもSingletonパターンで作られたクラスは、確かな魅力を持っています。ちゃんとインスタンスの管理さえできていれば、どこでも呼びたして使うことができますからね。常にメモリーに載せる必要があるクラスができたら、検討したくなるパターンです。&lt;/p></description></item><item><title>Lombokのバグにあった話</title><link>https://retheviper.github.io/posts/java-lombok-annotation-bug/</link><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-lombok-annotation-bug/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post Lombokのバグにあった話" />&lt;p>&lt;a class="link" href="../java-design-pattern-builder" >前回のポスト&lt;/a>で、Builderパターンとともに&lt;code>Lombok&lt;/code>を紹介しました。Beanだけでなく、Immutableなクラス&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>やBuilderを作れるなど便利な機能が集まっていて、さらにアノテーションで様々なオプションが指定できたり(フィールドのアクセスレベルを指定できるなど)、必要なメソッドは追記しても良いなど使い道が多いですね。ただ、今回はそのLombokを使いながらバグらしき現象を発見したのでポストします。&lt;/p>
&lt;h2 id="バグの発生したところ">バグの発生したところ
&lt;/h2>&lt;p>どこでバグが発生したかを述べる前に、まずどんなLombokのアノテーションを使っていて、それらがそれぞれどんな機能をしているかを紹介したいと思います。なぜなら今回の場合は二つ以上のLombokアノテーションを組み合わせて使っていて、ほかにも自分と同じような組み合わせでLombokを使って同じバグを経験される方がいるかも知れないからです。&lt;/p>
&lt;p>Lombokの&lt;code>@Builder&lt;/code>には、&lt;code>(toBuilder=true)&lt;/code>のオプションをつけられます。これを使うと、基本的に新しいインスタンスの生成はstaticメソッドを呼ぶ事でできるようになって、すでに存在しているインスタンスから一部の値を変えて違うインスタンスに再生成する事ができます。コードで表現すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @Builderだけを使って新しいインスタンスを生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>House house2 &lt;span style="color:#f92672">=&lt;/span> House.&lt;span style="color:#a6e22e">builder&lt;/span>().&lt;span style="color:#a6e22e">type&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;wooden&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// toBuilderオプションで既存のインスタンスから値を変えて再生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>House house3 &lt;span style="color:#f92672">=&lt;/span> house2.&lt;span style="color:#a6e22e">tobuilder&lt;/span>().&lt;span style="color:#a6e22e">type&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;block&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてBuilderを使いながらも、元のクラスのフィールドの中でBuilderにデフォルト値として渡したいものもあります。つまり、Nullにしたくない場合ですね。自分の場合は、Listでした。インスタンスが生成される場合にはとにかくListを初期化して、Builderを使ってListそのものを代入したり、&lt;code>addList()&lt;/code>のようなメソッドを作って個別の要素を追加できるようにしたかったです。&lt;/p>
&lt;p>これを実現するためには、元のクラスでListを初期化して、その状態でBuilderに渡す必要はありました。Lombokのアノテーションではフィールドに&lt;code>@Builder.Default&lt;/code>をつけることでできるようになります。そしてBuilderのアノテーションでは生成されない、&lt;code>addList()&lt;/code>的なメソッドだけを実装することですね。コードで表現すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>(toBuilder&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Wallet&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Builderでインスタンスが生成されるときはNullにしたくない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Builder.Default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> cards &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// カスタムメソッドをBuilderに追加するための宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">WalletBuilder&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 元のBuilderではListそのものを代入する方法しかないので、個別要素を追加できるメソッドを書く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> WalletBuilder &lt;span style="color:#a6e22e">addCard&lt;/span>(String card) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">cards&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(card);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうした実装で期待していた動きは以下のようなものでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスを生成しながらListにAddする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wallet myWallet &lt;span style="color:#f92672">=&lt;/span> Wallet.&lt;span style="color:#a6e22e">builder&lt;/span>().&lt;span style="color:#a6e22e">addCard&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Apple Card&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 既存のインスタンスにAddする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wallet newWallet &lt;span style="color:#f92672">=&lt;/span> myWallet.&lt;span style="color:#a6e22e">toBuilder&lt;/span>().&lt;span style="color:#a6e22e">addCard&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;American Express Card&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、実際テストをしてみるとこの二つのアノテーションによりバグが発生したのです。&lt;/p>
&lt;h2 id="それでどんなバグが">それでどんなバグが？
&lt;/h2>&lt;p>既存のインスタンス(Listの操作を一切していない)では&lt;code>add&lt;/code>が思い通りになったのですが、インスタンスを生成すると同時に&lt;code>add&lt;/code>した場合はNPE&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>が発生していました。場所を調べてみると&lt;code>this.cards.add(card);&lt;/code>のところで例外が発生していたので、生成されてないオブジェクトに要素を追加しようとしていたとのことですね。つまり、Listがちゃんと初期化されてないという事です。&lt;/p>
&lt;p>少し調べてみると、&lt;a class="link" href="https://github.com/rzwitserloot/lombok/issues/1347" target="_blank" rel="noopener"
>Githubでのイシュー&lt;/a>がありました。2017年に書かれたもので今となってはずいぶん古い感じもしましたが、読んでみると今の自分が経験している現象と似ていましたね。しかも、Lombokの&lt;code>1.18.2&lt;/code>バージョンで解消されたという話もありましたが、今の自分が使っているバージョンは&lt;code>1.18.8&lt;/code>でした。解消されているはずがちゃんと想定通りならなかったのか、バージョンアップにより再発したのかわかりませんが、ともかく同じ現象が起きていましたね。&lt;/p>
&lt;h2 id="解決策">解決策
&lt;/h2>&lt;p>それではどう解決したらいいか？他にも方法があるのかもしれませんが、自分の場合は&lt;code>toBuilder=true&lt;/code>と&lt;code>@Builder.Default&lt;/code>の両方を使わない事で解決できました。Builderにちゃんとフィールドが渡らない時点で後者は意味がなくなりました。そして&lt;code>toBuilder&lt;/code>の場合も、二つのメソッドが追加されるだけなのでそれを手書きで確実に値を渡せるようにしました。上で提示した&lt;code>Wallet&lt;/code>クラスをこのやり方で直すと、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// toBuilderオプションを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Wallet&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// @Builder.Defaultを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> cards &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// toBuilderメソッドも手書きする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> WalletBuilder &lt;span style="color:#a6e22e">toBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> WalletBuilder().&lt;span style="color:#a6e22e">cards&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">cards&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで元の想定通り、インスタンスを生成する時もちゃんと初期化されたListが渡るようになりました。めでたしめでたし。&lt;/p>
&lt;h2 id="教訓">教訓？
&lt;/h2>&lt;p>ライブラリーを使ってコードの量を減らし、自動化することは生産性の向上という面では大事な事ではありますが、人間の書いたコードはどこでバグが発生するかわからないので(想定していない使い方をする場合もありますし)、たまには手間がかかっても確実なコードを書くのが安全な場合もありますね。特にこの場合、アノテーションを諦めずコードを直そうとしていたらいつまでたってもバグは回避できなかったのかもしれません。そういう意味で、よい勉強になったと思える事件ではなかったのだろうかと思います。&lt;/p>
&lt;p>もしこのポストを読まれる方の中、私と同じような実装を考えている方がいたら、こんなこともあるんだなと参考できるようなことになっていると嬉しいです。それではまた会いましょう！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>一度インスタンスを生成すると、途中で値を変える事が出来ないクラス。Stringの場合がそうです。値を代入すると、メモリーに載せてある値を捨てて新しく生成します。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Null Pointer Exception、ヌルポとも呼ぶ例外です。参照しようとしているオブジェクトがメモリー上にありませんよーとのことで、Javaで最も遭遇しやすい例外ですね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>関数型インタフェースを使う</title><link>https://retheviper.github.io/posts/java-functional-interface/</link><pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-functional-interface/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post 関数型インタフェースを使う" />&lt;p>今回も、いつもと同じく仕事で得られた知識です。とあるIterableなクラスを作り、Forループをさせる必要がありました。これはそんなに難しいことではなかったです。まずフィールドにリストを持たせる。またIterableをインプリメントし、戻り値がIteratorであるメソッドを作るだけでしたね。しかし問題は、そのクラスのループの途中で、「使用者が指定したルールによりループを終了させる機能のあるクラスを作ること」でした。つまり、ループを終了させるには引数でループ中の要素を受け入れる引数を持つメソッドが内臓されていて、そのメソッドはインスタンスごとの基準となるデータを持っているということですね。&lt;/p>
&lt;h2 id="メソッドをフィールドとして使う">メソッドをフィールドとして使う？
&lt;/h2>&lt;p>メソッドとして機能しながらフィールドみたいにデータを持つ？それをさらに使用者が指定できるようにする？難しい注文だったので一瞬迷いましたが、「functionを使うといい」というアドバイスを受け、調べてみました。なるほど、これを使ったらフィールドとして宣言しながらもメソッドの機能を期待でき流みたいです。早速適用してみて、それがどう機能するかをまず紹介したいと思います。&lt;/p>
&lt;p>まずはIterableなクラスを用意します。ループの対象となるのはこちらです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Lineというクラスをリストとして持ち、Iterate可能なクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Factory&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> lines &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Iterator&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">iterator&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">lines&lt;/span>.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次はこのFactoryクラスを持ってループをさせる例です。ループの途中で&lt;code>Rule&lt;/code>クラスの&lt;code>isEnd(Line)&lt;/code>での判定が入ります。Lineインスタンスの中で何か条件に当たるものがあったら、戻り値がTrueとなってループから抜ける構造です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Iterableクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Factory factory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Factory();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// forループでFactoryの中のLineオブジェクトを処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Line line : factory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Ruleクラスのループ終了判定メソッドを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (Rule.&lt;span style="color:#a6e22e">isEnd&lt;/span>(line)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何らかの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで判定を行うRuleクラスの場合は、以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Rule&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 判定のルールをフィールドとして持っている&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> endRule &lt;span style="color:#f92672">=&lt;/span> line &lt;span style="color:#f92672">-&amp;gt;&lt;/span> line.&lt;span style="color:#a6e22e">isBroken&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 引数のLineがPredicateの条件に当たるかを判定するメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isEnd&lt;/span>(Line line) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> endRule.&lt;span style="color:#a6e22e">test&lt;/span>(line);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RuleBuilder&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 中身は普通のBuilder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> endRule;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> RuleBuilder &lt;span style="color:#a6e22e">endRule&lt;/span>(Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> endRule) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">endRule&lt;/span> &lt;span style="color:#f92672">=&lt;/span> endRule;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まずPredicateが何であり、Lambdaだけであれができる？と思われそうなコードです。しかしちゃんと動いてくれています。それはなぜか？今までよくしらなかったですが、Java8から追加された&lt;code>java.util.function&lt;/code>によるマジックでした。フィールドはデータを持つためのものである、とは思っていましたが、そのデータというのがメソッドそのものにも慣れるとは知らなかったですね。&lt;/p>
&lt;p>それでは、その&lt;code>java.util.function&lt;/code>が一体どんなものかを、それに含まれている様々なインタフェースたちを持って紹介したいと思います。&lt;/p>
&lt;h2 id="functional-interface">Functional Interface
&lt;/h2>&lt;p>&lt;code>java.util.function&lt;/code>に含まれている様々なインタフェースたちを、関数型インタフェースと呼ぶらしいです。Java8で追加されたLambdaを「実装すべき抽象メソッドが一つしかないインタフェースを具現化したもの」と言いますが、ここでいう「実装すべき抽象メソッドが一つしかないインタフェース」のことが関数型インタフェースです。&lt;/p>
&lt;p>言葉として表現すると難しいですが、要は一つです。中身をLambdaで満たせて完成するインタフェース。様々なタイプのものがあって、ぞれぞれの特徴は少しづつ違いますが、どんなことがして欲しいかによって選択するものが違うだけで、実際はそんな難しくもないです。むしろ難しいと言えばLambdaの方かな…&lt;/p>
&lt;p>とにかくこれらの関数型インタフェースを、一つづつ紹介しましょう。&lt;/p>
&lt;h3 id="function">Function
&lt;/h3>&lt;p>Functionは、そのなの通り典型的な関数です。引数と戻り値を指定して宣言します。実行は&lt;code>apply(適用)&lt;/code>となります。コードで見ると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Integerが引数で、Stringが戻り値となる例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Function&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> function &lt;span style="color:#f92672">=&lt;/span> number &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">valueof&lt;/span>(number);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Functionの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> function.&lt;span style="color:#a6e22e">apply&lt;/span>(12);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="bifunction">BiFunction
&lt;/h4>&lt;p>Function以外にも「Bi」が付くいくつかの関数型インタフェースがあります。何が違うかというと、そのなのとおり引数が二つ。他は元のものとほぼ一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 二つのStringが引数で、Integerが戻り値となる例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BiFunction&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> biFunction &lt;span style="color:#f92672">=&lt;/span> (string1, string2) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(string1) &lt;span style="color:#f92672">+&lt;/span> Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(string2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BiFunctionの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> biFunction.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="predicate">Predicate
&lt;/h3>&lt;p>先に紹介したものですね。&lt;code>Predicate&lt;/code>は「述語」の意味を持っています。その名の通り、「引数がTrueかFalseかを述べる」ようなものです。引数は一つです、戻り値がBooleanです。実行は&lt;code>test&lt;/code>です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数がStringの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> predicate &lt;span style="color:#f92672">=&lt;/span> string &lt;span style="color:#f92672">-&amp;gt;&lt;/span> string.&lt;span style="color:#a6e22e">isEmpty&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Predicateの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> predicate.&lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;空じゃない！&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="bipredicate">BiPredicate
&lt;/h4>&lt;p>引数が二つのPredicateです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数がStringの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BiPredicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> biPredicate &lt;span style="color:#f92672">=&lt;/span> (string, number) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> string.&lt;span style="color:#a6e22e">equals&lt;/span>(Integer.&lt;span style="color:#a6e22e">toString&lt;/span>(number));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BiPredicateの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> biPredicate.&lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>, 1);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="consumer">Consumer
&lt;/h3>&lt;p>&lt;code>Consume&lt;/code>は消費するという意味がありますね。引数を受けて戻り値はない(&lt;code>void&lt;/code>となる)ものです。実行するときは&lt;code>accept(受納)&lt;/code>となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数がStringの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Consumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> consumer &lt;span style="color:#f92672">=&lt;/span> string &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Consumerの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>consumer.&lt;span style="color:#a6e22e">accept&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;吸収！&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="biconsumer">BiConsumer
&lt;/h4>&lt;p>引数が二つのConsumerです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数がStringとIntegerの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BiConsumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> biConsumer &lt;span style="color:#f92672">=&lt;/span> (string, number) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(string &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> number);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BiConsumerの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>biConsumer.&lt;span style="color:#a6e22e">accept&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;今年儲かる確率は&amp;#34;&lt;/span>, 0);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="unaryoperator">UnaryOperator
&lt;/h3>&lt;p>&lt;code>Unary&lt;/code>は「単項」の意味。&lt;code>Operate&lt;/code>は作用するという意味を持っていますね。引数と戻り値が同じもので、引数に何かの操作をしてから返すという印象です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>UnaryOperator&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> uOperator &lt;span style="color:#f92672">=&lt;/span> string &lt;span style="color:#f92672">-&amp;gt;&lt;/span> string &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;完成されます&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UnaryOperatorの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> uOperator.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;この文字を入れると&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="binaryoperator">BinaryOperator
&lt;/h4>&lt;p>引数が二つのOperatorです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>BinaryOperator&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> biOperator &lt;span style="color:#f92672">=&lt;/span> (string1, string2) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> string1 &lt;span style="color:#f92672">+&lt;/span> string2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ではないです&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BinaryOperatorの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> biOperator.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;私は&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;大丈夫&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="supplier">Supplier
&lt;/h3>&lt;p>&lt;code>Supply&lt;/code>は「補給」の意味。Consumerとは真逆のもので、引数がなく戻り値だけがあるものです。実行は&lt;code>get&lt;/code>となります。引数がないためこちらはBiSupplierのようなインタフェースがないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> supplier &lt;span style="color:#f92672">=&lt;/span> () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;例えば引数なしで文字列が帰ってくる！&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Supplierの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> supplier.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>Java8が出てから数年、もうJavaも12までバージョンアップしています。でもまだJava8が使われている場面は多く、なるべくJava8の機能を最大限に活かしたコードを書きたいものですね。LambdaもStreamも難しいですが、Functionみたいにどこかで使うことになってまた今まではできなかったことをできるようになりたいです。&lt;/p>
&lt;p>今回も色々と勉強になりました。Javaの世界はまだまだ広くて奥深いものですね！&lt;/p></description></item><item><title>ReflectionとGenericを活用する</title><link>https://retheviper.github.io/posts/java-reflection/</link><pubDate>Tue, 30 Jul 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-reflection/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post ReflectionとGenericを活用する" />&lt;p>今回の仕事で学んだことは、自分のコードを他人がライブラリーとして使うときはどのように実装していくかの方法です。とある機能をするスクリプトを書くこと、エンドユーザーが使うUIやそコンテンツを処理するロジックなどだけに関わったことのない自分にとってはとても新しい経験になりました。今までだと自分が担当した機能を具現し、それを最適化していいだけでした。でも、ライブラリーは基本的にコードを扱える人が使うものなので設計が全く違いますね。&lt;/p>
&lt;p>そして、難しかった部分の一つは、柔軟性を持たせることでした。例えばデータを受け取り、処理していく中で、今までは自分が実装したBeanにデータがマッピングされていることを第一の前提条件としていました。それが今の仕事では、「どんなBeanが入ってくるかわからないから、それに対応する」ようにする必要がありました。&lt;/p>
&lt;p>まずクラスやインスタンスを引数として受け取る方法を知る必要がありますね。最初はObjectそのものを使おうと思いましたが、調べてみると&lt;code>Generic&lt;/code>というものがあったので、そちらを使うことにしました。&lt;/p>
&lt;p>次にそのGenericを使って、引数として受け取ったBeanです。自分が設計したBeanだけを使うなら、Beanが持つフィールドのデータ型も知っていいて、Getter/Setterからデータのやりとりができますね。しかし自分が作ったものではないと、フィールドのデータ型もGetter/Setterメソッドもどう呼ぶかもわからなくなります。ここでどう対応したらいいだろうか…と悩み、探し出した答えが&lt;code>Reflection&lt;/code>でした。&lt;/p>
&lt;p>今回のポストはその二つを使い、どう「自分が作っていないBeanを処理」したかについて述べ地と思います。&lt;/p>
&lt;h2 id="generic">Generic
&lt;/h2>&lt;p>Genericとは、「データのタイプを一般化」するということです。総称型とも呼ぶらしいです。クラスの中で使うタイプを、クラスの外部から設定するとき用いられると言いますね。今までは主に複数のデータ型やオブジェクトを処理したい場合は&lt;code>Object&lt;/code>を使ってきました。Javaでは一部のPrimitive(参照型)を覗くと、ほとんどのデータががオブジェクトとして扱われているので、もっとも上位のタイプであるObjectに変えられらからです。&lt;/p>
&lt;p>しかし、Objectを引数として使うと、メソッドの中のフィールドが何があるかわからなくなります。また、Getter/Setterによる値の指定・取得などの操作もできませんね。なのでオブジェクトそのものを受け取るだけでなく、インスタンスの中を直接覗く必要があります。&lt;/p>
&lt;p>ここでGenericを使うと、Objectと同じ機能(どんなインスタンスやクラスでも受け取れる)をしながらも、最初に具体的なタイプが決まるのでキャストがいらなくなります。これなら性能的にもよく、より安全な挙動を期待できますね。あとは実際どんな構造をしているかわからないObjectに対し、Reflectionを活用して、クラスやインスタンスの中を覗いたらメソッドもフィールドも取得できるというメリットもあります。&lt;/p>
&lt;p>まずインスタンスを引数として受け取る方法から見てみましょう。引数として&lt;code>T&lt;/code>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>を指定します。これでGenericタイプの引数を受け入れられます。つまり、インスタンス自体が引数となるということです。ただ、引数が&lt;code>T&lt;/code>の場合はメソッドの戻り値の前でも&lt;code>&amp;lt;T&amp;gt;&lt;/code>を宣言する必要があります。コードで表現すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Beanのインスタンスを受け取るメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (T parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BeanObject beanObject &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanObject();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (isBean(beanObject)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listの中にもGenericを使うことができます。たとえば以下のように書くと、どんなタイプも受け入れられるようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インスタンスではなく、クラスそのものをGenericで受け入れるには以下のように書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Beanのクラスを受け取るメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 継承もできる(限定)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isStringBean&lt;/span> (Class&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> String&lt;span style="color:#f92672">&amp;gt;&lt;/span> parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (isBean(BeanObject.&lt;span style="color:#a6e22e">class&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやってGenericの引数を渡してもらう準備は完了です。次は、そうやって受け取った引数を扱うReflectionについて調べてみましょう。&lt;/p>
&lt;h2 id="reflection">Reflection
&lt;/h2>&lt;p>クラスの具体的なタイプをわからなくても、メソッド・コンストラクター・フィールドなどににアクセスできるようにしてくれるAPIをReflectionと言います。取得したメソッド・コンストラクター・フィールドはいずれもそのまま使ったり、値(戻り値)を取得したり、つけられているアノテーションを取得するなど、普通のクラスでできることは全部できます。&lt;/p>
&lt;p>では、このReflectionを実際どう使うかを以下のコードで紹介します。まずはインスタンスからクラスを取得する方法と、さらに取得したクラスからコンストラクターを取得するコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (T object) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスからクラスを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> objectClass &lt;span style="color:#f92672">=&lt;/span> object.&lt;span style="color:#a6e22e">getClass&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クラスからさらにインスタンスを生成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object instance &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">newInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クラスのパッケージ名を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">= &lt;/span>objectClass.getPackage();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// パッケージを含むクラス名を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Stirng classNamePackageInvolved &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クラス名だけを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String className &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getSimpleName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列でpublicコンストラクターたちをを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Constructor&lt;span style="color:#f92672">[]&lt;/span> constructors &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getConstructors&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のpublicコンストラクターを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Constructor constructor &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getConstructor&lt;/span>(parameter1, parameter2, ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 取得したコンストラクターからインスタンスを生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object instance2 &lt;span style="color:#f92672">=&lt;/span> constructor.&lt;span style="color:#a6e22e">newInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>クラス自体を扱うことができるので、その中身がわかれば新しいインスタンスを生成して使うこともできますね。それでは次に、フィールドを取得する方法を紹介します。&lt;/p>
&lt;h2 id="fieldの取得">Fieldの取得
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (T object) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> objectClass &lt;span style="color:#f92672">=&lt;/span> object.&lt;span style="color:#a6e22e">getClass&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列でpublicフィールドたちを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field&lt;span style="color:#f92672">[]&lt;/span> fields &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getFields&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のpublicフィールドを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field field &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getField&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;フィールド名&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列で全フィールドたちを取得(public以外も)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field&lt;span style="color:#f92672">[]&lt;/span> declaredFields &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getDeclardFields&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のフィールドを取得(public以外も)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field declaredFiled &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getDeclaredField&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;フィールド名&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Fieldでできること&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドに値を設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field.&lt;span style="color:#a6e22e">set&lt;/span>(object, parameter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドの値を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String fieldValue &lt;span style="color:#f92672">=&lt;/span> field.&lt;span style="color:#a6e22e">get&lt;/span>(object);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドのアノテーションを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Annotation&lt;span style="color:#f92672">[]&lt;/span> annotations &lt;span style="color:#f92672">=&lt;/span> field.&lt;span style="color:#a6e22e">getAnnotations&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで注意すべき部分は、フィールドを取得するときはクラスからであって、実際値を代入したり取得するときはその対象としてインスタンスを使うということです。クラスが設計図であり、インスタンスがその設計図で生成されたものだということが明確になる瞬間ですね。Reflectionを使うことのメリットはここにもあるのかもしれません。&lt;/p>
&lt;p>次には、メソッドをみていきます。&lt;/p>
&lt;h2 id="methodの取得">Methodの取得
&lt;/h2>&lt;p>メソッドもフィールドの場合とそう変わりません。クラスからメソッドを取得し、そのメソッドからさらに色々できるようになります。またコードを以下に用意しました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (T objectClass) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> objectClass &lt;span style="color:#f92672">=&lt;/span> object.&lt;span style="color:#a6e22e">getClass&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列でpublicメソッドたちを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Method&lt;span style="color:#f92672">[]&lt;/span> methods &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getMethods&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のpublicメソッドを取得 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Method method &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getMethod&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;メソッド名&amp;#34;&lt;/span>, parameter1, parameter2, ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列でメソッドたちを取得(public以外も)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Method&lt;span style="color:#f92672">[]&lt;/span> declaredMethods &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getDeclaredMethods&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のメソッドを取得(public以外も)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Method declaredMethod &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getDeclaredMethod&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;メソッド名&amp;#34;&lt;/span>, parameter1, parameter2, ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Methodでできること&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// メソッド名の取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String methodName &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// メソッドの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object methodInvoked &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">invoke&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 引数のアノテーションを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Annotation&lt;span style="color:#f92672">[]&lt;/span> parameterAnnotations &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">getParameterAnnotations&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 引数を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Parameter&lt;span style="color:#f92672">[]&lt;/span> parameters &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">getParameters&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>アノテーションの場合はクラスでもフィールドでも取得できますが、メソッドの場合はそれに加えて引数のアノテーションも取得できるということが特徴です。また、引数そのものを取得することもできますね。もちろん&lt;code>Parameter&lt;/code>クラスでも引数名を取得するなど色々な操作ができます。&lt;/p>
&lt;h2 id="結論">結論
&lt;/h2>&lt;p>結局、道が見えてくると、解決の方法も見えてくるものです。メソッドをやコンストラクターに触れる必要もなく、引数で受け取ったインスタンスからフィールドを取得して、その値をObjectに代入する。そしてinstanceofを活用して分岐させ、キャストすることでデータを扱う、というシンプルな構造で自分のタスクは完成されました。簡単なコードで表現すると以下のような形ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// クラスをわからないBeanを引数とするメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">processSomething&lt;/span>(T bean) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 複数のタイプのオブジェクトがある&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String stringObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Integer intObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クラスとフィールドの取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> beanClass &lt;span style="color:#f92672">=&lt;/span> bean.&lt;span style="color:#a6e22e">getClass&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field&lt;span style="color:#f92672">[]&lt;/span> beanFields &lt;span style="color:#f92672">=&lt;/span> beanClass.&lt;span style="color:#a6e22e">getDeclardFields&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ループで個別フィールドを取得し、一致するタイプのオブジェクトにフィールドの値を入れる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Field field : beanFields) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// privateフィールドの場合はアクセスできない場合があるためアクセス可能にする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (field.&lt;span style="color:#a6e22e">canAccess&lt;/span>(bean)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field.&lt;span style="color:#a6e22e">setAccessible&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドの値を取得し、型を判断&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object value &lt;span style="color:#f92672">=&lt;/span> field.&lt;span style="color:#a6e22e">get&lt;/span>(bean);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (value &lt;span style="color:#66d9ef">instanceof&lt;/span> String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stringObject &lt;span style="color:#f92672">=&lt;/span> (String)value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (value &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> intObject &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)value();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>どうですか。方法がわかれば簡単にできるものなのでは。さらに応用して、インスタンスの一部の値だけを修正して返すなどの挙動もできそうです。色々活用できそうな面が多いですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>このようにだいたいフィールドとメソッドがわかれば、これでどんなインスタンスやクラスが入ってきても、対応できそうな気がします。実際どうかはコンパイルして実行してみない限りわからないものですが…でも一つ、賢くなったような気はします。皆さんもぜひ、Reflectionを通じてクラスとインスタンスに対する理解を深めてみてください。&lt;/p>
&lt;p>それでは、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Typeのこと。ただ、E(Element)やK(Key)、N(Number)、V(Value)も使えるらしいです。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>JenkinsのJobを実行する</title><link>https://retheviper.github.io/posts/jenkins-build-trigger/</link><pubDate>Sat, 20 Jul 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jenkins-build-trigger/</guid><description>&lt;img src="https://retheviper.github.io/images/jenkins.webp" alt="Featured image of post JenkinsのJobを実行する" />&lt;p>今回は、Jenkinsで生成したJobを実行する方法について述べたいと思います。基本的にJenkinsの管理コンソールでJobを実行することは可能ですが、いちいちログインしてJobを起動することは便利ではないです。なので「とある条件でJobを自動的に実行したい」と思うようになりますね。例えば簡単に考えられるものとしてまず「定期的実行」があるでしょう。特定の時間、もしくは頻度などを指定して自動的に実行してくれるバッチ的な処理にはこのような設定が必要ですね。また、とある条件が満たされた時にだけ実行したい場合もあります。たとえばGitのリポジトリにコミットが発生したときは、その時だけビルドしたいですね。&lt;/p>
&lt;p>JenkinsのJobではこのような、条件によるJobの自動実行を設定することが可能です。これを&lt;code>Build Trigger&lt;/code>と呼びます。基本設定でも必要なパターンの最低限は揃えていますし、プラグインの組み合わせによってはより多彩な設定でJobを実行するように設定できます。今回のポストでは、そのビルドトリガーにどんなものがあるか、またどのように使えるかということを述べたいと思います。&lt;/p>
&lt;h2 id="build-triggerの種類">Build Triggerの種類
&lt;/h2>&lt;p>JenkinsでJobを生成すると、GeneralとSource Code Managementのタブの後にBuild Triggerというタブがあることを確認できます。プラグインの構成が違うと増えたり減ったりもするので一度確認してみてください。私はJenkinsをインストールするときオススメのプラグイン構成を選んでいるので、以下の構成になっています。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_triggers.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_triggers_hu_7d58d1481b92ac72.webp 480w, https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_triggers_hu_1660893df079aed7.webp 1024w"
loading="lazy"
alt="Jenkins Build Triggers"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;ul>
&lt;li>Trigger builds remotely&lt;/li>
&lt;li>Build after other projects are built&lt;/li>
&lt;li>Build periodically&lt;/li>
&lt;li>GitHub hook trigger for GITScm polling&lt;/li>
&lt;li>Poll SCM&lt;/li>
&lt;/ul>
&lt;p>では、これらの機能がそれぞれどんな意味を持ち、どう活用できるかを一つづつ見てみましょう。&lt;/p>
&lt;h2 id="trigger-builds-remotely">Trigger builds remotely
&lt;/h2>&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_trigger_remote.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_trigger_remote_hu_748cf1d86a584d22.webp 480w, https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_trigger_remote_hu_c676d6a20ecca59d.webp 1024w"
loading="lazy"
alt="Jenkins Build Triggers Remote"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>これは、「遠隔」という表現通り、Jenkinsの管理コンソールに接続しなくてもJobを外部から実行できるようにするという意味です。このメニューを選ぶと、URLでJobをコールできるようになります。&lt;code>Authentication Token&lt;/code>に認証として使うトークン名を入力すると、以下のようなURLでJobをコールできます。&lt;/p>
&lt;p>(JenkinsのURLが&lt;code>192.168.0.2:8080&lt;/code>、Job名が&lt;code>TriggerTest&lt;/code>、トークン名が&lt;code>buildToken&lt;/code>であると仮定)&lt;/p>
&lt;ol>
&lt;li>&lt;code>http://192.168.0.2:8080/job/TriggerTest/build?token=buildToken&lt;/code>&lt;/li>
&lt;li>&lt;code>http://192.168.0.2:8080/job/TriggerTest/buildWithParameters?token=buildToken&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>１番の設定は、パラメーターなしでただJobを実行するときに用います。２番目の場合は、パラメーターを渡したいときに使えますね。ここで受け取るパラメーターは、Generalタブで&lt;code>This project is parameterized&lt;/code>をチェックし、パラメーターを追加すると設定できます。パラメーターで受け取った値はJobの中のシェルスクリプトなどで外部変数として使うことができます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_parameter.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_parameter_hu_1db5efa072aab3e1.webp 480w, https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_parameter_hu_9e6df51a5241d4f6.webp 1024w"
loading="lazy"
alt="Jenkins Build Parameter"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>LinuxのCurlなど、外部からのコールが必要である時使うと便利な機能です。&lt;/p>
&lt;h2 id="build-after-other-projects-are-built">Build after other projects are built
&lt;/h2>&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_after.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_after_hu_845156a04b57fbfd.webp 480w, https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_after_hu_414de91941073231.webp 1024w"
loading="lazy"
alt="Jenkins Build After"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>JenkinsではJobを複数生成することができます。そしてJobを複数生成することはそれぞれ違う機能をするJobをそれぞれの目的に合わせて分けるという意味でしょう。ただ場合によってはそれらのJobを連携する必要もあるかもしれません。同じプログラムの中でもメソッドやクラスは分けてもそれらを繋いで使うことになりますので。&lt;/p>
&lt;p>こちらのオプションをチェックすると、どんなJobの後にビルドするかを入力できます。複数のJobを登録することもできますね。&lt;code>Projects to watch&lt;/code>に先にビルドしたいJob名を入力し、下の三つのオプションを選びます。JenkinsのJobの実行結果には&lt;code>stable&lt;/code>(成功)&lt;code>unstable&lt;/code>(一部成功)&lt;code>fail&lt;/code>(失敗)の三段階があって、ここで選ぶのは前段階のJobがその三つのうちどのような結果になったかという判定の条件です。&lt;/p>
&lt;ul>
&lt;li>Trigger only if build is stable&lt;/li>
&lt;li>Trigger even if the build is unstable&lt;/li>
&lt;li>Trigger even if the build fails&lt;/li>
&lt;/ul>
&lt;p>１番目は、前段階のJobが成功的にビルドできた場合。成果物が必要だったりするとこちらのオプションですね。２番目はビルドが不安定でも実行する。また３番目は失敗しても実行する。各自目的と用途が違うので、必要に合わせて適合したものを選びましょう。&lt;/p>
&lt;h2 id="build-periodically">Build periodically
&lt;/h2>&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_period.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_period_hu_45c7f6aa3dd48ef1.webp 480w, https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_build_period_hu_4a9b89cf5c2106c6.webp 1024w"
loading="lazy"
alt="Jnekins Build Period"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>時間による定期実行が欲しい場合はこちらのオプションを使います。&lt;code>Schedule&lt;/code>の欄に、Jenkins固有のルールに合わせて周期を書くと自動的に条件に合わせてJobのビルドが繰り返されます。かなり複雑ではありますが、一旦紹介します。&lt;/p>
&lt;p>&lt;code>基本フォーマット&lt;/code>&lt;/p>
&lt;ol>
&lt;li>時間単位は空白を基準に分ける&lt;/li>
&lt;li>記入順は分(minute)、時間(hour)、日付(day of month)、月(month)、週(week)
&lt;ol>
&lt;li>分(minute): 0から59までの数字&lt;/li>
&lt;li>時間(hour): 0から23までの数字&lt;/li>
&lt;li>日付(day of month): 1から31までの数字&lt;/li>
&lt;li>月(month): 1から12までの数字&lt;/li>
&lt;li>週(week): 0から7前での数字(0と７は日、1は月、2は火、3は水、4は木、5は金、6は土)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;code>*&lt;/code>は入力できる全範囲の値を許容するという意味(分の位置に入力すると0~59までの全数字)&lt;/li>
&lt;li>&lt;code>M-N&lt;/code>のように&lt;code>-&lt;/code>を入れると範囲の指定が可能(&lt;code>2-4&lt;/code>は2から4までの値)&lt;/li>
&lt;li>&lt;code>M-N/X&lt;/code>または&lt;code>*/X&lt;/code>は合間の意味(時間の位置に&lt;code>*/2&lt;/code>と入力すると、２時間置きという意味になる)&lt;/li>
&lt;li>&lt;code>A,B,C&lt;/code>のように複数の値を列挙できる&lt;/li>
&lt;/ol>
&lt;p>そのほかに、周期的に実行されるJobが複数ある場合は&lt;code>H&lt;/code>を使うことがオススメです。例えばJobが10種類あって、それぞれを&lt;code>0 0 * * *&lt;/code>にすると、全てのJobが毎日0時に実行されることになりますね。もしサーバーのスペックがあまりよくなかったり、Jobの数がそれ以上になると負荷は無視できないレベルになるはずです。&lt;/p>
&lt;p>そこで&lt;code>H H * * *&lt;/code>に指定すると、Jenkinsで自動判断を行い、サーバーへの負荷があまり発生しない時間帯にJobが実行されるようになります。もちろん&lt;code>H&lt;/code>でも範囲の指定ができますので&lt;code>H H(0-1) * * *&lt;/code>のように指定すると、毎日0時から1時までの間、負荷の低い時間帯にビルドが行われます。&lt;/p>
&lt;p>このフォーマットに従って書かれたいくつかの例を見てみましょう。&lt;/p>
&lt;ul>
&lt;li>15分置きでビルド実行: &lt;code>H/15 * * * *&lt;/code>&lt;/li>
&lt;li>毎時間の30分までに、10分置きでビルド実行(1時から1時半まで、2時から2時半までなど): &lt;code>H(0-29)/10 * * * *&lt;/code>&lt;/li>
&lt;li>平日の9時から16時の間、２時間置きにビルド実行: &lt;code>H 9-16/2 * * 1-5&lt;/code>&lt;/li>
&lt;li>1月から11月の間、1日と15日だけビルド実行: &lt;code>H H 1,15 1-11 *&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>フォーマットになれるまでは少し時間がかかりそうですが、かなり複雑なルールまで対応できるので魅力的なプションですね。&lt;/p>
&lt;h2 id="github-hook-trigger-for-gitscm-polling">GitHub hook trigger for GITScm polling
&lt;/h2>&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_github_hook.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_github_hook_hu_6c9b8f2395afef42.webp 480w, https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_github_hook_hu_761803495b00f345.webp 1024w"
loading="lazy"
alt="Jenkins GitHub Hook"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>このオプションは&lt;a class="link" href="https://github.com" target="_blank" rel="noopener"
>GitHub&lt;/a>との連動で、リポジトリにPushが発生するとビルドが行われるということです。Jenkins内ではこのオプションを選ぶだけであまり複雑な設定はないですが、GitHubのリポジトリでPushが発生したということをJenkins側に知らせるための設定が必要となります。&lt;/p>
&lt;p>GitHubのリポジトリに入ると、上段に&lt;code>Settings&lt;/code>というタブがあります。それをクリックし、さらに&lt;code>Webhooks&lt;/code>というメニューに入ります。そうすると以下のような画面が現れます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-build-trigger/github_webhook1.webp"
width="2056"
height="1014"
srcset="https://retheviper.github.io/posts/jenkins-build-trigger/github_webhook1_hu_f2eb6f8b64705e66.webp 480w, https://retheviper.github.io/posts/jenkins-build-trigger/github_webhook1_hu_ee394cb4beabedd6.webp 1024w"
loading="lazy"
alt="GitHub Webhook"
class="gallery-image"
data-flex-grow="202"
data-flex-basis="486px"
>&lt;/p>
&lt;p>ここで&lt;code>Add Webhooks&lt;/code>ボタンを押すと、また以下のような画面になります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-build-trigger/github_webhook2.webp"
width="2044"
height="1592"
srcset="https://retheviper.github.io/posts/jenkins-build-trigger/github_webhook2_hu_3a114d3a052bc98f.webp 480w, https://retheviper.github.io/posts/jenkins-build-trigger/github_webhook2_hu_d121a124147cece2.webp 1024w"
loading="lazy"
alt="GitHub Webhook 2"
class="gallery-image"
data-flex-grow="128"
data-flex-basis="308px"
>&lt;/p>
&lt;p>ここでも複雑な設定はいらなく、&lt;code>Payload URL&lt;/code>にJenkinsのURL/github-webhookと書くだけです。例えばJenkinsのURLが&lt;code>192.168.0.2:8080&lt;/code>だとすると、&lt;code>http://192.168.0.2:8080/github-webhook/&lt;/code>と書きます。これでリポジトリにPushが発生したら、Jobは自動ビルドされます。WebサーバーでのGit管理もこれで簡単にできますね。&lt;/p>
&lt;h2 id="poll-scm">Poll SCM
&lt;/h2>&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_poll_scm.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_poll_scm_hu_395a97a0b34b5bb7.webp 480w, https://retheviper.github.io/posts/jenkins-build-trigger/jenkins_poll_scm_hu_5e53441e6417bc14.webp 1024w"
loading="lazy"
alt="Jenkins Poll SCM"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>'&lt;/p>
&lt;p>SCMとは、&lt;code>Source Control Management(ソース管理構成)&lt;/code>のことです。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>GitやSVNなどのツールによる意味します。Poll SCMを選択すると、&lt;code>Build periodically&lt;/code>同様&lt;code>Schedule&lt;/code>の入力欄が現れます。ここに同じく周期を入力します。ただ何が違うかというと、設定した時間になっても必ずしもビルドが行われるのではないということです。設定した時間になるとソースの確認をして、そこで変更があった場合のみビルドが行われるらしいですね。GitやSVNの連動で使える設定みたいです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>様々なビルドトリガーの指定ができるゆえ、活用できる方法が多いという面もまたJenkinsの魅力ではないかと思います。Jenkins自体のアップデート対応も、周期的に&lt;code>yum update&lt;/code>するようなJobを構成するとできそうな気がしますね。そのほか、Git連動と&lt;code>systemctl&lt;/code>でのサービス管理機能を組み合わせて&lt;code>Tomcat&lt;/code>や&lt;code>Node.js&lt;/code>の管理もローカルでできますので便利です。&lt;/p>
&lt;p>それではまた、便利な使い方を見つけたらJenkinsのポストを載せましょう！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>ソフトウェアエンジニアリングの観点からは、Software Configuration Management(ソフトウェア構成管理)の略でもあります。簡単にいうとソースコードだけでなく、開発環境やビルド構造などの全般的な環境情報を定義・管理することを構成管理というらしいです。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>デザインパターン、Builder</title><link>https://retheviper.github.io/posts/java-design-pattern-builder/</link><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-design-pattern-builder/</guid><description>&lt;img src="https://retheviper.github.io/images/java.webp" alt="Featured image of post デザインパターン、Builder" />&lt;p>以前、自分より開発者として日本就職が早かった大学の後輩がいて、どんな言語やフレームワークを勉強した方がいいかを聞いたことがあります。周りではC#をやるといい、ReactやNode.jsのような流行りのライブラリーを学んだ方がいいという人もいましたが、現場で使われている人の意見が聞きたかったからです。そして彼は、言語やフレームワークはメインとしている言語をマスターしたらいつでも変えられるもので、実質的に必要となるスキルはデザインパターンと言っていました。&lt;/p>
&lt;p>それから本を買い、いくつかのデザインパターンを見たことはありますが、そのパターンたちをどう使ったらいいか一人で考えるのは難しいことでした。一人でコードを書く時は、自分が理解できるコードを書けばいいだけなのでそこまで考える余裕が無くなりますね。また、エンドユーザーだけを意識したコードになりがちだったのであまりパターンを含むコードの書き方をする必要もなかったです。&lt;/p>
&lt;p>それが今はJavaでのフレームワーク開発に関わることとなり、自分の買いたコードを違う人が使えるように書けとの指示を受けましたが、いつも通りDTOを元とするWrapperクラスを生成して行けばいいのかなと思っていたら、実装してみてからはこれはダメだなと感じました。なぜなら数十から数百に至る変数の設定値があって、引数として渡すのも単純な数字や文字などではなかったからです。自分の作ったコードが使う側として接した場合は、これはダメと思うはず。&lt;/p>
&lt;p>どう改善したらいいかと悩んでいたら、指示を出した方からBuilderパターンを使うといいだろうというアドバイうをもらいました。これなら引数は最低限にして、直観的に使えるらしいです。なので実際使ってみました。そして伝統的なDTOと比べてみると、確かになと思いましたね。何が違ってなぜ違うのかを、DTOとBuilderパターンの比べでこれから述べたいと思います。&lt;/p>
&lt;h2 id="telescoping-constructor-pattern">Telescoping Constructor Pattern
&lt;/h2>&lt;p>テレスコープとは望遠鏡のこと。どこが望遠鏡的かというと、だんだん伸びていくコンストラクターの形が望遠鏡の伸縮みたいでこんな名前になったようです。最近はJava Beanの中でもよく使われるパターンなのですね。オブジェクトを生成する時に引数の数によって値を入れる変数の数を調節できます。Method Overloading&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>で複数のコンストラクターを用意するだけです。&lt;/p>
&lt;p>例えばカフェでコーヒーを注文する過程を、Javaのクラスで具現化するとしましょう。カップのサイズ、ホットかアイスか、シロップは入れるか、クリームは入れるか…様々なオプションがありますね。これをTelescoping Constructor Patternで書くと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(size, hot, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot, &lt;span style="color:#66d9ef">boolean&lt;/span> addCream){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(size, hot, addCream, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot, &lt;span style="color:#66d9ef">boolean&lt;/span> addCream, &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(size, hot, addCream, addSugar, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot, &lt;span style="color:#66d9ef">boolean&lt;/span> addCream, &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar, &lt;span style="color:#66d9ef">boolean&lt;/span> takeout){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span> &lt;span style="color:#f92672">=&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span> &lt;span style="color:#f92672">=&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでオーダを定義するクラスが一つ、できました。実際使ってみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cafe&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オーダーごとのオブジェクトを生成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(&lt;span style="color:#e6db74">&amp;#34;tall&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(&lt;span style="color:#e6db74">&amp;#34;grande&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_3 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(&lt;span style="color:#e6db74">&amp;#34;venti&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(&lt;span style="color:#e6db74">&amp;#34;tall&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このパターンのよくない点は、オブジェクトを生成する時、引数の意味を分かりにくいという点です。実際クラスの中身をみないと、連続している&lt;code>false&lt;/code>や&lt;code>true&lt;/code>の意味が分かりませんね。そして例えば、サイズとシロップだけを引数として入れたい場合は、それに合わせてまたコンストラクターを作成しなければならないです。変数が増えれば増えるほど、それに合わせコンストラクターを用意する必要があるという問題もあります。あとでオーダーのオプションが増えたり減ったりするとそれに対応するのが難しいですね。&lt;/p>
&lt;h2 id="java-bean-dtovo">Java Bean, DTO(VO)
&lt;/h2>&lt;p>JavaでOOP&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>の概念を学ぶ時、初めて接したのがこの&lt;code>Java Bean&lt;/code>です。これも一つのパターンと言えますね。みなさんがよく知っているよう、&lt;code>Getter&lt;/code>と&lt;code>Setter&lt;/code>で値を渡すパターンです。同じくオーダーのクラスを作ってみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(){}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setSize&lt;/span>(String size){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getSize&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setHot&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> hot){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span> &lt;span style="color:#f92672">=&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getHot&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setAddCream&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> addCream){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getAddCream&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setAddSugar&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> addSugar){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getAddSugar&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setTakeout&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> takeout){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span> &lt;span style="color:#f92672">=&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getTakeout&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンストラクターとして引数を受け取るパターンも含める場合はありますが、Java Beanとしての特徴はこのGetterとSetterにあるので、ここでは省略。では同じく、これでオーダーを生成してみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cafe&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オーダーの内容はSetterで設定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_1.&lt;span style="color:#a6e22e">setSize&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tall&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_1.&lt;span style="color:#a6e22e">setHot&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_2.&lt;span style="color:#a6e22e">setSize&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;grande&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_2.&lt;span style="color:#a6e22e">setHot&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_2.&lt;span style="color:#a6e22e">setAddCream&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さっきよりは個別項目ごとに値を設定することができ、それぞれのSetterをみてどんなオーダーを出しているのかがより明確になりますね。また変数が増えてもそれに合わせてGetterとSetterを用意するだけで良いです。&lt;/p>
&lt;p>ただ、一つの注文を完成する時、オプションの数が増えると無題に長いコードになってしまうという問題がありますね。今は5つのフィールドを使っているだけですが、もし20、30のオプションがあったら？それをいちいち書くのはかなり時間もかかることですね。私が失敗したのはこの部分でした。なのでBuilderを使い、この問題を解決してみます。&lt;/p>
&lt;h2 id="builder-pattern">Builder Pattern
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot, &lt;span style="color:#66d9ef">boolean&lt;/span> addCream, &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar, &lt;span style="color:#66d9ef">boolean&lt;/span> takeout){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span> &lt;span style="color:#f92672">=&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span> &lt;span style="color:#f92672">=&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Builder &lt;span style="color:#a6e22e">builder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Builder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Builder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Builder&lt;/span>(){}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">size&lt;/span>(String size){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">hot&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> hot){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span> &lt;span style="color:#f92672">=&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">addCream&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> addCream){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">addSugar&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> addSugar){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">takeout&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> takeout){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span> &lt;span style="color:#f92672">=&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">build&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(size, hot, addCream, addSugar, takeOut);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Inner Classも入り、何か複雑になったように見えますが、実際使ってみるとそうでもないです。このようなBuilderクラスを使うとどうなるのか、また確認してみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cafe&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オーダーを生成してBuilderを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_1.&lt;span style="color:#a6e22e">Builder&lt;/span>().&lt;span style="color:#a6e22e">size&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tall&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">hot&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder().&lt;span style="color:#a6e22e">Builder&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">size&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;grande&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">hot&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addCream&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">takeout&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Setterと似たような使い方で、一回だけで複雑なオプションを全部処理できます。また、生成と同時にもオーダーを完成できます。Builderが戻り値として自分自身を使っていて、連続してメソッドを呼び出すことができるからです。これならいくら変数が増えても対応できますね！&lt;/p>
&lt;h2 id="lombokを使う">Lombokを使う
&lt;/h2>&lt;p>以上のパターンは&lt;a class="link" href="https://projectlombok.org" target="_blank" rel="noopener"
>Lombok&lt;/a>を使うとアノテーションだけで設定できるらしいです。例えばコンストラクターは&lt;code>@NoArgsConstructor&lt;/code>や&lt;code>@RequiredArgsConstructor&lt;/code>、&lt;code>@AllArgsConstructor&lt;/code>でできます。Java Beanなら&lt;code>@Data&lt;/code>をつけることでGetterとSetterができるらしいですね。また、Builderの場合は&lt;code>@Builder&lt;/code>でできると言います。以下はLombokを使った場合の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> lombok.Builder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに&lt;code>@Builder(toBuilder = true)&lt;/code>にすると、インスタンスの新規生成では&lt;code>CoffeOrder.builder()&lt;/code>から直接Builderにアクセスできるようになります。また、既存のインスタンスの値を受け継ぐ場合は&lt;code>order_1.toBuilder()&lt;/code>を使えるようになります。実際は以下のコードになるようなものとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> lombok.Builder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>(toBuilder &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 基本的なBuilder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrderBuilder &lt;span style="color:#a6e22e">toBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrderBuilder().&lt;span style="color:#a6e22e">size&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>).&lt;span style="color:#a6e22e">hot&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span>).&lt;span style="color:#a6e22e">addCream&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addSugar&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span>).&lt;span style="color:#a6e22e">takeout&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてBuilderを使うとき、親クラスのフィールドをそのまま継承したい場合はフィールドに&lt;code>@Builder.Default&lt;/code>をつけることでそのまま受け継がれます。他にもフィールドにつけてアクセスレベルを指定できるなど便利な機能が多いので、ぜひ使いたいものですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>デザインパターンの種類に何があって、どんな構造をしているかを把握することも大事ですが、何より大事なことは適材適所に使えることではないかと思いました。最初から自分がBuilderパターンを知っていたとしても、それを使ったらいいと言われなかったら果たして使おうとしていただろうかと思うと、そうでもないような気がしますね。なのでこれからはデザインパターン自体の研究とともに、それをどの場合に使えるかという面から考察していきたいと思います。&lt;/p>
&lt;p>それでは、また会いましょう！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>引数の数や種類を変えることで、同名のメソッドを複数作成する記法。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Object Oriented Programing.オブジェクト指向プログラミングとも言いますね。コードをひたすら上から下まで流れる処理として扱うのではなく(手続き型プログラミング)、隔離されたオブジェクト間のデータ交換として成立するプログラミングのパラダイムです。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Linuxのシステムサービスを作る</title><link>https://retheviper.github.io/posts/linux-systemctl-service/</link><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/linux-systemctl-service/</guid><description>&lt;img src="https://retheviper.github.io/images/linux_terminal.webp" alt="Featured image of post Linuxのシステムサービスを作る" />&lt;p>サーバーで動くプログラムなら、一般的なエンドユーザー用のプログラムとはその挙動が違うということは明らかでしょう。どんなデータを持ち、どんな処理をするかの問題でもありますが、今回は簡単に「実行」の面で書いてみたいと思います。簡単にいうと、誰かが止めるまではずっと実行され続けるようなプログラムをLinuxではどう実現したらいいかの話です。&lt;/p>
&lt;p>CentOSやRHELでは、&lt;code>service&lt;/code>というコマンドがあります。&lt;code>yum&lt;/code>のようなパッケージ管理プログラムを使って、様々なプログラムをインストールしていくとその中には一回だけの実行で終わらず、メモリー常に常住させる必要のあるものもありますね。以前このブログで紹介したことのある&lt;code>Jenkins&lt;/code>もまたそのようなプログラムの一つです。&lt;/p>
&lt;p>そのようなプログラムは一回インストールしたら自動的に&lt;code>service&lt;/code>コマンドで動かしたり止めたりすることができるようになりますが、例えば自作したプログラムをそのように動作させることはできるのでしょうか？ユーザーがなんでもできるLinuxならできそうですが。&lt;/p>
&lt;p>そう思っていたら、ちょうど仕事でJavaアプリケーションをサービスとして登録し、管理する必要があることになりました。私はJenkinsのタスクを管理していたため、実際はJavaアプリケーションがGitにコミットされたらPull→ビルド→実行されているJavaアプリケーションを止めて新しくビルとした物を実行するというタスクが必要となったのです。実際はサービスに触れる必要はなく、ビルドの後にサービスを止めたり再開させたりするシェルコマンドを実行するように仕組んだだけだったのですが、一体これはどう動いてるのか気になりましたので調べてみました。&lt;/p>
&lt;h2 id="servicedaemonを作ること">Service(Daemon)を作ること
&lt;/h2>&lt;p>サービスになるものは、&lt;code>Demon&lt;/code>とも呼ぶらしいです。少し調べてみると「システムに常住しながら、とある状態になると自動動作するプログラム」「周期的なサービス要請を処理するために実行され続けるプログラム」「バックグラウンドで動いている」などという定義がありました。これでだいたいどんな性格のプログラムのことを指しているかがわかりますね。&lt;code>Spring&lt;/code>や&lt;code>Node.js&lt;/code>などで作られたWebサーバプログラムとかがこの定義に該当するでしょう。&lt;/p>
&lt;p>それでは早速、そのサービス(もしくはデーモン)を実現するためにはどうしたらいいかを説明していきたいと思います。準備するものは大きくサービスとして登録したいプログラム、そのプログラムをどんなサービスにするかを書いたサービスの設定ファイル、コマンドでのサービス登録と実行などがあります。仕事では&lt;code>Spring Boot&lt;/code>で作られたプログラムをサービスにしていますが、これの場合は実行するためのシェルスクリプトの設定や外部ファイルの参照なども必要となるので比較的簡単な、&lt;code>Node.js&lt;/code>を使ったプログラムを例として使います。&lt;/p>
&lt;p>&lt;code>Node.js&lt;/code>の場合、&lt;code>$ node /node/index.js&lt;/code>みたいな簡単なコマンドで実行できますね。これをサービスに登録する場合は以下のようになります。&lt;/p>
&lt;h2 id="serviceファイルを作成する">serviceファイルを作成する
&lt;/h2>&lt;p>まずはサービスとしてどんな動きをしてほしいか、どんな名前でサービス化するかなどを記述したファイルを作ります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>vi /etc/systemd/system/NodeServer.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>それでは以下のような形で中を書いていきます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># サービスとしての設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Description &lt;span style="color:#f92672">=&lt;/span> NodeServer &lt;span style="color:#75715e"># この名称でサービスが登録される&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>After &lt;span style="color:#f92672">=&lt;/span> syslog.target network.target &lt;span style="color:#75715e"># システム起動時の実行の優先順位(syslogとnetworkの後に実行する)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 実行するプログラムの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Service&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type &lt;span style="color:#f92672">=&lt;/span> simple &lt;span style="color:#75715e"># 動作の様子を決める・デフォルトはsimple&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ExecStart &lt;span style="color:#f92672">=&lt;/span> /usr/bin/node /node/index.js &lt;span style="color:#75715e"># node /node/index.jsと同じだがシンボリックリンクなしで記述する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Restart &lt;span style="color:#f92672">=&lt;/span> on-failure &lt;span style="color:#75715e"># 起動に失敗すると再実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>User &lt;span style="color:#f92672">=&lt;/span> nodeservice &lt;span style="color:#75715e"># 実行するユーザー、権限に注意！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># シンボリックリンクや別名などの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Install&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WantedBy &lt;span style="color:#f92672">=&lt;/span> multi-user.target &lt;span style="color:#75715e"># どこのフォルダにシンボリックリンクを作るかを指定、これが一般的らしい&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも様々なオプションがありますが、基礎的な情報はこのくらいかと。テストのために作成しておいたNode.jsでのWebサーバーはこれで動きました。(と言っても&lt;code>Hello Node.js!&lt;/code>を出力するだけの簡単なものですが…)&lt;/p>
&lt;p>実際仕事で扱っていたJavaアプリケーションは、PID&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>を管理するスクリプトの指定や、止める時実行するシェルスクリプトの指定もありました。例えば&lt;code>ExecStop&lt;/code>を使うとサービスを修理するために実行したいコマンドを、&lt;code>ExecReload&lt;/code>を使うとリロードする時に実行したいコマンドを書くことができるらしいです。シェルスクリプトから実行する場合や状態が変わった時何かの措置が必要な場合に考えられるオプションですね。&lt;/p>
&lt;p>このようにserviceファイルを作成したら、次はプロセスをシステムサービスに登録して実行します。&lt;/p>
&lt;h2 id="enable--start-service">Enable &amp;amp; Start Service
&lt;/h2>&lt;p>先に&lt;code>service&lt;/code>というコマンドを言及しましたが、CentOS7からは&lt;code>systemctl&lt;/code>を使うらしいです。&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>実際、CentOS7では&lt;code>service&lt;/code>だけではシステムサービスの登録は不可能なので&lt;code>systemctl&lt;/code>を使うことになります。このコマンドでできることはサービスの登録や解除、実行と停止、再実行などがあります。まずサービスをシステムサービスに登録すると、システムが起動する時に実行されるようになります。&lt;/p>
&lt;p>Windowsに例えると、「スタートアップ」にプログラムを登録したり解除することと、タスクマネージャーによってプロセスを管理するような機能が一緒になっている感じですね。&lt;/p>
&lt;p>こちらはコマンドだけなので、簡単に紹介します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># システムサービスとして登録&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ systemctl enable NodeServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ systemctl start NodeServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 実行されているサービスの中で検索する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ systemctl list-units | grep NodeServer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># serviceファイルを修正した場合はリロードする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ systemctl daemon-reload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 停止と再起動&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ systemctl stop NodeServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ systemctl restart NodeServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># サービスの状態を確認する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ systemctl status NodeServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># システムサービスから解除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ systemctl enable NodeServer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 実行に問題があった場合は以下のコマンドでサービスのログを参照できる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ journalctl -xe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>サービスの登録や解除はできなくても、&lt;code>service&lt;/code>コマンドでの制御もできます。ただいずれは消えるかもしれないコマンドなので、なるべく&lt;code>systemctl&lt;/code>に慣れた方が良いかもしれませんね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># serviceでできること&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ service NodeServer start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ service NodeServer status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ service NodeServer stop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ service NodeServer restart
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで私の作った簡単なNode.jsのWebサーバーがシステムサービスとなって、止まることなく動くようになりました。めでたしめでたし。他にも何か自動化のプログラムを作ることになったら有効活用できそうな知識ではないのかと思います。&lt;/p>
&lt;p>それでは今回のポストはここまで。また会いましょう！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Process IDの略で、実行中のプロセスに与えられるIDです。こちらは&lt;code>ps&lt;/code>コマンドで確認できて、PIDからプロセス名を参照したりプロセス名からPIDを参照することもできます。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>CentOS7でもserviceは健在ですが、systemctlにリダイレクトされるみたいですね。CentOS6までは/etc/rc.d/init.dからサービスを管理していて、７からはサービスユニットという名称になったらしいです。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Ansibleでサーバーを構築する</title><link>https://retheviper.github.io/posts/ansible-server-automation/</link><pubDate>Fri, 05 Jul 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/ansible-server-automation/</guid><description>&lt;img src="https://retheviper.github.io/images/ansible.webp" alt="Featured image of post Ansibleでサーバーを構築する" />&lt;p>この度は&lt;a class="link" href="https://www.ansible.com/" target="_blank" rel="noopener"
>Ansible&lt;/a>を少し、使ってみる機会がありました。&lt;code>Ansible&lt;/code>もまた一つの自動化ツールで、あらかじめタスクを指定することで複数の環境で適用できるという意味ではJenkinsと似たようなものでした。ただ違う点は、Jenkinsは主にデプロイとリリース、テストなどの自動化に特化しているのに対し、Ansibleはサーバーの自動構築にその目的があるということです。&lt;/p>
&lt;p>つまり、Ansibleを使えば複数の環境を同じくセッティングできます。例えば私の経験した範囲では「開発」→「内結」→「外結」という流れになっていて、それぞれで使う環境が変わっていました。段階が変わるたびに同じくサーバーを構築するのは時間の無駄で、セッティングすべき項目が増えると人の手では様々な面でミスが起こり得るので、Ansibleで自動化したいというのが今回のタスク。&lt;/p>
&lt;p>ちょっと調べてみると、Ansibleでは&lt;code>Playbook&lt;/code>と呼ばれるYAMLファイル&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>を使ってサーバーの設定を行います。深く入るとより複雑な動きもできるようですが、基本は接続先の情報(hostsファイル)とセッティングの値を保存したYAMLで起動します。できることはフォルダーやユーザーの作成、&lt;code>yum&lt;/code>によるプログラムのインストール、シェルコマンド実行、ファイル転送などができて、うまく設定ができたら複数のサーバーを分散して使う時などに有効活用できそうな印象でした。&lt;/p>
&lt;p>ただYAMLファイルとフォルダー構成などが少し複雑なので、ここでは一つ一つのファイルの設定を述べてみようと思います。以下のYAML設定は、AMAZON Linuxを基準に書かれています。&lt;/p>
&lt;h2 id="ansibleのインストール">Ansibleのインストール
&lt;/h2>&lt;p>Ansibleは&lt;code>yum&lt;/code>、&lt;code>brew&lt;/code>、&lt;code>pip&lt;/code>、&lt;code>apt-get&lt;/code>でインストールできます。簡単ですね！ただ場合によってはPython2やPIPが必要となるので、事前にインストールしておきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ brew install ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pip install ansible
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sudo apt-get install ansible
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使っている環境に適した方法でインストールしましょう。&lt;/p>
&lt;h2 id="batchserveryml">batchserver.yml
&lt;/h2>&lt;p>まずはサーバーごとのYAMLファイルを生成します。Ansible実行時に使われるのはこっちで、どのサーバーでどんな動作をするかを記述します。サーバーごとにしたいことに関しては別のYAMLファイルを用意し、共通、バッチサーバー、WEBAPサーバー用のYAMLファイルをそれぞれ作るというイメージです。&lt;/p>
&lt;p>以下のコードは、バッチサーバーを想定した場合の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">hosts&lt;/span>: &lt;span style="color:#ae81ff">batchserver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">become&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">roles&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">common&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">batch&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>hosts&lt;/code>はhostsファイルに記述されたホストのことを意味します。ここで&lt;code>batchserver&lt;/code>と書くと、Ansibleの実行時は自動的にhostsファイルからbatchserverというグルーブに属している全サーバーに接続し同じ動きをします。全グループに対して実行したい場合は&lt;code>all&lt;/code>と書きましょう。&lt;/p>
&lt;p>そして&lt;code>become&lt;/code>を&lt;code>true&lt;/code>に設定すると、接続先での全ての命令ががsudoとして実行されます。&lt;code>roles&lt;/code>はサーバーで行う行動を指定したYAMLファイルのことを記述していて、私の場合はどんなサーバーでも共通的に実行したことを書いた&lt;code>common&lt;/code>とバッチサーバーでだけ実行したい&lt;code>batch&lt;/code>を区分しておいたので両方を書いています。&lt;/p>
&lt;h2 id="hosts">hosts
&lt;/h2>&lt;p>このファイルは上述した通り、Ansibleで自動設定を行いたい接続先のことを書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>[batchserver]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.0.1 ansible_ssh_user=batchuser1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.0.2 ansible_ssh_user=batchuser2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[webapserver]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.10.1 ansible_ssh_user=webapuser1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.10.2 ansible_ssh_user=webapuser2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基本はグルーブを指定して、ホストの情報を書いておくと自動的に分類されます。上に書いたYAMLファイルではまず&lt;code>batchserver&lt;/code>だけを指定しているので実行時に&lt;code>webapserver&lt;/code>のグループは無視されます。そして&lt;code>ansible_ssh_user&lt;/code>はその名の通りAnsibleでSSH接続する時に使われるユーザー名を指定しています。もちろんこうしなくても実行時にユーザー名やパスワードを入れることもできます。&lt;/p>
&lt;h2 id="roles--batch--tasks--mainyml">roles / batch / tasks / main.yml
&lt;/h2>&lt;p>ここは&lt;code>batchserver.yml&lt;/code>で指定した&lt;code>roles&lt;/code>で、実際どんなことがしたいかを記述するYAMLファイルが入ります。&lt;code>roles&lt;/code>は同盟のフォルダーの下に作っておいたものしか実行できませんので注意してください。&lt;/p>
&lt;p>本格的にやりたいことを書くファイルなので、どんな行動が指定できるかまず参考にしてください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Create user groups&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{ { item.group_name } }&amp;#34;&lt;/span> &lt;span style="color:#75715e"># マークダウンの仕様のためスペースを入れているが、実際はスペースなし&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">gid&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{ { item.group_id } }&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with_items&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - { &lt;span style="color:#f92672">group_name: &amp;#39;group01&amp;#39;, group_id&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;101&amp;#39;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - { &lt;span style="color:#f92672">group_name: &amp;#39;group02&amp;#39;, group_id&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;201&amp;#39;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Create users&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">user&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{ { item.user_name } }&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">password&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{ { item.user_passwd } }&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uid&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{ { item.user_id } }&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{ { item.user_group } }&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">shell&lt;/span>: &lt;span style="color:#ae81ff">/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with_items&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - { &lt;span style="color:#f92672">user_name: &amp;#39;user01&amp;#39;, user_group: &amp;#39;group01&amp;#39;, user_id: &amp;#39;101&amp;#39;, user_passwd&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;user01&amp;#39;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - { &lt;span style="color:#f92672">user_name: &amp;#39;user02&amp;#39;, user_group: &amp;#39;group02&amp;#39;, user_id: &amp;#39;201&amp;#39;, user_passwd&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;user02&amp;#39;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name &lt;/span>: &lt;span style="color:#ae81ff">Create folders&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">file&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">path={ { item } }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">owner=user01&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">group=user01&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">mode=0755&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">state=directory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with_items&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">/user01&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Package install by yum&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">yum&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{ { packages } }&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">vars&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">packages&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">python2-pip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">postgresql&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">postgresql-devel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Upgrade pip by shell command&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">shell&lt;/span>: &lt;span style="color:#ae81ff">bash -lc &amp;#34;pip install --upgrade pip&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Install python modules&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pip&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{ { item } }&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">executable&lt;/span>: &lt;span style="color:#ae81ff">pip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with_items&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">cx_Oracle&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">psycopg2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">boto3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">paramiko&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Copy files&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">copy&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">src= { { item.source } }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">dest= { { item.dest } }&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">owner=root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">group=root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">mode=0755&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with_items&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - { &lt;span style="color:#f92672">source: etc/somefile.zip, dest&lt;/span>: &lt;span style="color:#ae81ff">/etc/somefile.zip }&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上から順番に、ユーザーグループ作成、ユーザー作成、フォルダー作成、&lt;code>yum&lt;/code>でパッケージインストール、シェルコマンドの実行、ファイル転送となります。結局はSSH接続してシェルスクリプトを実行するようなものですね。でもYAMLファイルにより簡単に設定できるということが良いところではないかと思います。なんども繰り返して実行しても良いですしね。&lt;/p>
&lt;p>ただSSH接続したあとはYAMLファイルの上から一行づつ読みコマンドを実行していくので、実行したいことの順番には気をつける必要があります。例えば当たり前なことなんですが、ユーザーグループを作成する前に特定のグループにユーザーを作成するとかはできないので注意してください。&lt;/p>
&lt;h2 id="roles--batch--files">roles / batch / files
&lt;/h2>&lt;p>このフォルダーには転送に使いたいファイルをおきます。例えば上の&lt;code>main.yml&lt;/code>に書いた&lt;code>etc/somfile.zip&lt;/code>を転送したい場合は、このフォルダーの配下に同じパスのファイルを置きます。もちろん複数のファイルを転送することも、それぞれ違うフォルダーに分けておくことも可能です。&lt;/p>
&lt;h2 id="roles--common--tasks--mainyml">roles / common / tasks / main.yml
&lt;/h2>&lt;p>このファイルはどんなサーバーでも共通的に実行したいコマンドを集めています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Upgrade all packages by yum&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">yum&lt;/span>: &lt;span style="color:#ae81ff">name=* state=latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Install openjdk 11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">shell&lt;/span>: &lt;span style="color:#ae81ff">bash -lc &amp;#34;amazon-linux-extras install java-openjdk11&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Correct java version selected&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">alternatives&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">java&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">path&lt;/span>: &lt;span style="color:#ae81ff">/usr/lib/jvm/java-11-openjdk-11.0.2.7-0.amzn2.x86_64/bin/java&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このファイルでやっていることは、&lt;code>yum&lt;/code>による全パッケージのアップデートと、OpenJDKのインストールです。JDKをインストールするだけではサーバーでJava実行時の基本バージョンがOpenJDK11にならないのでAlternativeからJavaのバージョンを選択するところまで入れています。同じやり方でPython3をインストールしてAlternativeで基本実行のバージョンを指定するなどのこともできます。&lt;/p>
&lt;p>ここまでくるとAnsibleによる基本設定は終わり。難しくないですね！(深く入れば難しくなりそうですが)&lt;/p>
&lt;h2 id="実行する">実行する
&lt;/h2>&lt;p>それではPlaybookが用意されたので実行します。以下のコマンドで実行できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 一般的な実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ansible-playbook server.yml -i hosts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Dry runの場合(Playbookの文法チェック用)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ansible-playbook server.yml -i hosts -C
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># SSH接続ユーザー名を入れる場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ansible-playbook server.yml -i hosts -u hostuser
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こちらも簡単ですね。実行時にSSH接続するユーザーのパスワードを要求される場合がありますが、これはあらかじめSSH接続するユーザーの公開鍵を登録しておくことで回避できます。&lt;code>sudo&lt;/code>の場合は接続先で&lt;code>visudo&lt;/code>から&lt;code>NOPASSWD&lt;/code>を設定しておくと便利です。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>どうでしたか。最近はなんでも自動化が進んでいて、JenkinsとAnsibleがあればサーバー構築から作成物のデプロイまで簡単にできる環境を構築できるので、ますます生産性が上がりそうな気がします。まだ手動でサーバーの構築をやっている方にはぜひ一度使ってみてくださいとオススメしたいですね。&lt;/p>
&lt;p>それでは今回のポストはここで終わり。また会いましょう！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>データフォーマットの一種で、その構造がJSONとかなり似ています。ただJSONと比べてみるとよりマークアップ言語に近い感じですね。多少癖はあるものの、JSONよりは直観的な表現ができます。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>PythonでDBの処理がしたい</title><link>https://retheviper.github.io/posts/python-blob-to-binary/</link><pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/python-blob-to-binary/</guid><description>&lt;img src="https://retheviper.github.io/images/python.webp" alt="Featured image of post PythonでDBの処理がしたい" />&lt;p>あまり詳しくない上に、何か新しいプログラムを作り出すこととは少し距離があるなと思ってDBにはあまり興味を持ってなかった私ですが、ITの業界で働きながらDBと接しないのは難しいことです。そしてそうやって接するDBはまた優しくない課題になってきますね。この度の仕事でも主にPythonを使ってスクリプトを書いたものの、そのタスクのメインとなるものはDBとの連携でした。なので今回のポストではどうやってPythonでDBに繋ぎ、SQL文を発行し、そのデータを扱ったかについて述べたいと思います。&lt;/p>
&lt;p>今回私に与えられたタスクは、DBからバイナリーのデータを抽出して、それをAWSのS3&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>にアップロードするスクリプトを作ることでした。また、アップロードが終わった時点でテーブルを更新する必要がありますが、抽出の対象となるDBと更新の対象となるDBがそれぞれ違うものでした。片方はOracleで片方はPostgreSQL。そしてロガーを入れ各DBやS3の接続に失敗するなどの時にはログで分かるようにしたり、DBの接続情報を外出しにして外部ファイルから読み込むようにするなどの条件がありました。ロガーについては[前回のポスト](../../../06/15/python-logger/で述べましたので、今回は省略とさせていただきます。他にバイナリーデータを抽出するには引数を受け、最終更新日を確認した上でそれより後のファイルを保存する、S3にアップロードする際はテーブルのカラムからパス名を決める、画像のアップロードの後には最終更新日を更新する、などの条件がありました。&lt;/p>
&lt;p>要略すると、今回作るスクリプトの仕様は以下となります。&lt;/p>
&lt;ol>
&lt;li>コマンドラインで引数を受ける&lt;/li>
&lt;li>引数からPostgreSQLのテーブル(1)を参照し、引数に当たる作業の最終更新日を取得する&lt;/li>
&lt;li>OcaleDBのテーブルから最終更新日以後のバイナリーデータをSELECTしてJPGファイルとして保存する&lt;/li>
&lt;li>PostgreSQLのテーブル(2)からファイルの保存先のパスとなるカラムを取得する。&lt;/li>
&lt;li>S3へJPGファイルごとのフォルダーに画像をアップロードする&lt;/li>
&lt;li>PostgreSQLのテーブル(3)にアップロードされたJPGファイルの情報を記録する&lt;/li>
&lt;li>PostgreSQLのテーブル(1)最終更新日を更新する&lt;/li>
&lt;li>正常終了したらexitコード0となり、例外が発生するとexitコード9を出力して終了する&lt;/li>
&lt;/ol>
&lt;p>PostgreSQLの場合は参照するテーブルが多く、処理の順番があるので少し複雑にも感じられますが、まずはDBとの連動を試しみスクリプトを組むことにしました。&lt;/p>
&lt;h2 id="pythonでdbを連動する">PythonでDBを連動する
&lt;/h2>&lt;p>案外、PythonでDBに接続することはそんな難しいことではなかったです。それぞれ違うモジュールを使っていてコマンドにも違いがあるわけですが、検索してみると例題が多かったですね。Oracleの場合はホスト名、ポート、サービス名、ユーザー名、パスワードを用意します。使うモジュールは&lt;code>cx_Oracle&lt;/code>です。&lt;/p>
&lt;p>PostgreSQLの場合は、&lt;code>psycopg2&lt;/code>を使います。接続に必要となる情報はホスト名、ポート、DB名、ユーザー名、パスワードです。ただし、モジュールは両方&lt;code>pip&lt;/code>からインストールできますが、psycopg2の場合はライブラリー依存性があるのでAmazon Linuxを基準に&lt;code>postgresql-develop&lt;/code>をyumからインストールする必要があります。他は触れたことがないのでよくわかりませんが、CentOSも同様かと。psycopg2のインストールに問題が生じたらエラーメッセージを確認して、必要なPosgreSQLのライブラリーをインストールしましょう。&lt;/p>
&lt;p>二つのDBに接続するための手順には少し違いがありますが、接続した後の処理は同じです(本当はSQL文の文法も少し違うようですが…)。それではOracleとPostgreSQLの接続方法と接続以後の処理を分けて説明しましょう。&lt;/p>
&lt;h3 id="接続oracleの場合">接続(Oracleの場合)
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> cx_Oracle
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tns &lt;span style="color:#f92672">=&lt;/span> cx_Oracle&lt;span style="color:#f92672">.&lt;/span>makedsn(&lt;span style="color:#e6db74">&amp;#39;ホスト名&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;ポート&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;サービス名&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connect &lt;span style="color:#f92672">=&lt;/span> cx_Oracle&lt;span style="color:#f92672">.&lt;/span>connect(&lt;span style="color:#e6db74">&amp;#39;ユーザー名&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;パスワード&amp;#39;&lt;/span>, tns)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>cx_Oracleの&lt;code>makedsn&lt;/code>にホスト名、ポート、サービス名を入れます。そしてその情報を&lt;code>connect&lt;/code>を使う際にユーザー名、パスワードと共に入れます。これでOracleの接続設定は終わりです。&lt;/p>
&lt;h3 id="接続postgresqlの場合">接続(PostgreSQLの場合)
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> psycopg2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connect &lt;span style="color:#f92672">=&lt;/span> psycopg2&lt;span style="color:#f92672">.&lt;/span>connect(&lt;span style="color:#e6db74">&amp;#39;host=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;ホスト名&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; port=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;ポート&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; dbname=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;DB名&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; user=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;ユーザー名&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; password=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;パスワード&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>PostgreSQLの場合はより簡単です。Linuxで使うコマンドラインツールの&lt;code>psql&lt;/code>みたいに、接続に必要な情報を文字列として並び&lt;code>connect&lt;/code>すれば終了です。&lt;/p>
&lt;h3 id="db処理の共通部分">DB処理の共通部分
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 実際DBに接続してカーソルを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cursor &lt;span style="color:#f92672">=&lt;/span> connect&lt;span style="color:#f92672">.&lt;/span>cursor()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># カーソルからSQL文の実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cursor&lt;span style="color:#f92672">.&lt;/span>execute(&lt;span style="color:#e6db74">&amp;#39;発行したいSQL文&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># SQL文を実行した結果を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 一件だけの結果が必要な時&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>result &lt;span style="color:#f92672">=&lt;/span> cursor&lt;span style="color:#f92672">.&lt;/span>fetchone()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 結果を1000件づつフィッチして処理したい場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>result &lt;span style="color:#f92672">=&lt;/span> cursor&lt;span style="color:#f92672">.&lt;/span>fetchmany(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 結果を全部フェッチしたい場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>result &lt;span style="color:#f92672">=&lt;/span> cursor&lt;span style="color:#f92672">.&lt;/span>fetchall()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># カーソルをクローズする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cursor&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># SQL文をコミットする(INSERT/UPDATEなどの変動)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connect&lt;span style="color:#f92672">.&lt;/span>commit()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># コネクションを切る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connect&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接続したあとはカーソルを取得し、そのカーソルでSQL文を発行します。SQL文の実行結果を取得するには&lt;code>fecth&lt;/code>を使いますが、処理したい結果の規模によって三つの選択肢があります。あと、大量のデータを処理したい場合はなるべく&lt;code>fetchall&lt;/code>よりは&lt;code>fetchmany&lt;/code>でフェッチサイズを指定して使う方が良いらしいです。データが多すぎると性能に影響が出ますので。フェッチまで終わって取得した結果は、Pythonでは一つのレコードを配列にして、それらを集めたリストになります。コードで言いますと以下のような形となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># &amp;#39;SELECT column_1, column2 FROM TABLE&amp;#39;の場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>result &lt;span style="color:#f92672">=&lt;/span> cursor&lt;span style="color:#f92672">.&lt;/span>fetchmany(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> row &lt;span style="color:#f92672">in&lt;/span> result: &lt;span style="color:#75715e"># 結果は1000件のリストとなる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print row[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># column_1の内容が出力される&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print row &lt;span style="color:#75715e"># column_2の内容が出力される&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでDBの連動の基礎は終わりです。それでは早速、スクリプトのコードをいかに公開します。&lt;/p>
&lt;h2 id="画像ファイルをs3へアップロードするコード">画像ファイルをS3へアップロードするコード
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -*- coding: UTF-8 -*-&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> os&lt;span style="color:#f92672">,&lt;/span> sys&lt;span style="color:#f92672">,&lt;/span> cx_Oracle&lt;span style="color:#f92672">,&lt;/span> psycopg2&lt;span style="color:#f92672">,&lt;/span> json&lt;span style="color:#f92672">,&lt;/span> boto3&lt;span style="color:#f92672">,&lt;/span> datetime&lt;span style="color:#f92672">,&lt;/span> shutil
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>function_code &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;引数で受け取る&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 以下、DB環境情報(DBConnection.confから読み込む)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HOST_POST &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;PostgreSQLの接続ホスト名&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PORT_POST &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;PostgreSQLの接続ポート&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DB_NAME_POST &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;PostgreSQLのDM名&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>USER_POST &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;PostgreSQLのユーザ名&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PWD_POST &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;PostgreSQLのパスワード&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HOST_ORAC &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Oracleの接続ホスト名&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PORT_ORAC &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Oracleの接続ポート&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVICE_NAME &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Oracleのサービス名&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>USER_ORAC &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Oracleのスキーマ名&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PWD_ORAC &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Oracleのパスワード&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># コマンドライン引数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>args &lt;span style="color:#f92672">=&lt;/span> sys&lt;span style="color:#f92672">.&lt;/span>argv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 環境関連変数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>imageFolder &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/tmp/images&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 差分連携のための前処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">GetProcdate&lt;/span>(args):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> function_code
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> function_code &lt;span style="color:#f92672">=&lt;/span> args[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># PostgreSQL接続&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Starting Job. The function Code is: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> function_code)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect &lt;span style="color:#f92672">=&lt;/span> psycopg2&lt;span style="color:#f92672">.&lt;/span>connect(&lt;span style="color:#e6db74">&amp;#39;host=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> HOST_POST &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; port=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> PORT_POST &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; dbname=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> DB_NAME_POST &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; user=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> USER_POST &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; password=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> PWD_POST)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor &lt;span style="color:#f92672">=&lt;/span> connect&lt;span style="color:#f92672">.&lt;/span>cursor()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Unable to connect PostgreSQL. quitting.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectSQL &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SELECT last_date FROM date_table WHERE function_code=&amp;#39;&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> (function_code,)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor&lt;span style="color:#f92672">.&lt;/span>execute(selectSQL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> cursor&lt;span style="color:#f92672">.&lt;/span>fetchone()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 結果があった場合最終更新日を変数として保存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last_date &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; No data matches with &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> function_code &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;. quitting.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 次の処理へ移行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GetImageFromTable(last_date)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># OracleにSQL文を発行してファイルを読み込み保存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">GetImageFromTable&lt;/span>(last_date):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> imageFolder
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Oracle接続開始&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tns &lt;span style="color:#f92672">=&lt;/span> cx_Oracle&lt;span style="color:#f92672">.&lt;/span>makedsn(HOST_ORAC, PORT_ORAC, SERVICE_NAME)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect &lt;span style="color:#f92672">=&lt;/span> cx_Oracle&lt;span style="color:#f92672">.&lt;/span>connect(USER_ORAC, PWD_ORAC, tns)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor &lt;span style="color:#f92672">=&lt;/span> connect&lt;span style="color:#f92672">.&lt;/span>cursor()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Unable to connect Oracle DB. quitting.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Oracleのテーブルから商品画像ファイル取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor&lt;span style="color:#f92672">.&lt;/span>execute(&lt;span style="color:#e6db74">&amp;#34;SELECT image_data, image_name FROM WHERE &amp;gt;=(:last_date)&amp;#34;&lt;/span>, {&lt;span style="color:#e6db74">&amp;#39;last_date&amp;#39;&lt;/span>: last_date})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># フォルダがなかったら作成・あったら削除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>exists(imageFolder):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> shutil&lt;span style="color:#f92672">.&lt;/span>rmtree(imageFolder)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os&lt;span style="color:#f92672">.&lt;/span>mkdir(imageFolder)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 1000件づつ取り出し&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows &lt;span style="color:#f92672">=&lt;/span> cursor&lt;span style="color:#f92672">.&lt;/span>fetchmany(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 結果がない場合はループから出る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(rows) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 画像ファイル置き場に画像ファイル保存(イメージネーム.webp)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> image &lt;span style="color:#f92672">in&lt;/span> rows:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileNameS &lt;span style="color:#f92672">=&lt;/span> imageFolder &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> str(image[&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.jpg&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageFile &lt;span style="color:#f92672">=&lt;/span> open(fileNameS, &lt;span style="color:#e6db74">&amp;#39;wb+&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageFile&lt;span style="color:#f92672">.&lt;/span>write(image[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>read())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageFile&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> counter &lt;span style="color:#f92672">=&lt;/span> counter &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 保存されたファイルの数をカウント&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileCount &lt;span style="color:#f92672">=&lt;/span> len([name &lt;span style="color:#66d9ef">for&lt;/span> name &lt;span style="color:#f92672">in&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>listdir(imageFolder) &lt;span style="color:#66d9ef">if&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>isfile(os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>join(imageFolder, name))])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; As result: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> str(fileCount) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; files were written.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Finished job. Closing connection.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileUploadToS3()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># S3へ画像ファイルを格納&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">FileUploadToS3&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># グローバル変数取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> imageFolder
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> function_code
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ファイル名リスト(イメージネーム)取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> files &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>listdir(imageFolder)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> item_cd_list &lt;span style="color:#f92672">=&lt;/span> [os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>splitext(f)[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> files &lt;span style="color:#66d9ef">if&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>isfile(os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>join(imageFolder, f))]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># PostgreSQL接続&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect &lt;span style="color:#f92672">=&lt;/span> psycopg2&lt;span style="color:#f92672">.&lt;/span>connect(&lt;span style="color:#e6db74">&amp;#39;host=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> HOST_POST &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; port=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> PORT_POST &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; dbname=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> DB_NAME_POST &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; user=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> USER_POST &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; password=&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> PWD_POST)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor &lt;span style="color:#f92672">=&lt;/span> connect&lt;span style="color:#f92672">.&lt;/span>cursor()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Unable to connect PostgreSQL. quitting.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 結果確認用のファイル数カウンター&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> item_cd &lt;span style="color:#f92672">in&lt;/span> item_cd_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># アイテム管理用テーブルからコードと一致するレコード取得⇒ファイル格納パス用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectSQL1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SELECT file_path1, file_path2, file_path3 FROM item_table WHERE item_cd=&amp;#39;&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> (str(item_cd),)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor&lt;span style="color:#f92672">.&lt;/span>execute(selectSQL1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resultMaster &lt;span style="color:#f92672">=&lt;/span> cursor&lt;span style="color:#f92672">.&lt;/span>fetchone()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 一致するレコードがなかった場合でも処理続行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> resultMaster &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Result was 0. continue job.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 結果から必要な情報を取得し変数に保存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> image_id &lt;span style="color:#f92672">=&lt;/span> str(resultMaster[&lt;span style="color:#ae81ff">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path &lt;span style="color:#f92672">=&lt;/span> str(resultMaster[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> str(resultMaster[&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> str(resultMaster[&lt;span style="color:#ae81ff">2&lt;/span>]) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># アイテムイメージ管理用テーブルからコードと一致するレコード取得⇒分岐処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectSQL2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SELECT * FROM WHERE image_table image_id=&amp;#39;&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#e6db74">&amp;#39;;&amp;#34;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> (image_id,)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor&lt;span style="color:#f92672">.&lt;/span>execute(selectSQL2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> cursor&lt;span style="color:#f92672">.&lt;/span>fetchone()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uploadToS3(item_cd, path)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileCount &lt;span style="color:#f92672">=&lt;/span> fileCount &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Processing file upload.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 作業完了日時を更新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updateProcSQL &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;UPDATE date_table SET last_date = CURRENT_TIMESTAMP WHERE function_code=&amp;#39;&lt;/span>&lt;span style="color:#e6db74">%s&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span> &lt;span style="color:#f92672">%&lt;/span> (function_code,)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor&lt;span style="color:#f92672">.&lt;/span>execute(updateProcSQL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 作業終了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; As result: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> str(fileCount) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; files were uploaded.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Finished job. Closing connection and quit.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cursor&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect&lt;span style="color:#f92672">.&lt;/span>commit()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># S3へ画像ファイルをアップロード&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">uploadToS3&lt;/span>(item_cd, path):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> imageFolder
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Upload image files to AWS S3.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bucket_name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;image&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s3 &lt;span style="color:#f92672">=&lt;/span> boto3&lt;span style="color:#f92672">.&lt;/span>resource(&lt;span style="color:#e6db74">&amp;#39;s3&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># サーバーに保存されたファイルを指定したパスに保存(file_path1/file_path2/file_path3/1_1_YYYYMMDD.webp)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s3&lt;span style="color:#f92672">.&lt;/span>Bucket(bucket_name)&lt;span style="color:#f92672">.&lt;/span>upload_file(imageFolder &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> item_cd &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.jpg&amp;#39;&lt;/span>, path &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/1_1_&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> datetime&lt;span style="color:#f92672">.&lt;/span>datetime&lt;span style="color:#f92672">.&lt;/span>today()&lt;span style="color:#f92672">.&lt;/span>strftime(&lt;span style="color:#e6db74">&amp;#39;%Y%m&lt;/span>&lt;span style="color:#e6db74">%d&lt;/span>&lt;span style="color:#e6db74">%H%M%S&amp;#39;&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.jpg&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Image file uploaded. (Item code: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> item_cd &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;)&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Unable to upload files. quitting.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># コネクション情報を入力ファイルから読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">getDBConnection&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># DBConnection接続情報ファイルのパスを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pwd &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>dirname(os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>abspath(__file__))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbConnection &lt;span style="color:#f92672">=&lt;/span> pwd&lt;span style="color:#f92672">.&lt;/span>rsplit(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/env/DBConnection.conf&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ファイルがない場合異常終了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">not&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>exists(dbConnection)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Please check DBConnection.conf. quitting.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ファイルを読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connectionInfo &lt;span style="color:#f92672">=&lt;/span> open(dbConnection, &lt;span style="color:#e6db74">&amp;#39;r&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lines &lt;span style="color:#f92672">=&lt;/span> connectionInfo&lt;span style="color:#f92672">.&lt;/span>readlines()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># グローバル変数として保存するための宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> HOST_POST
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> PORT_POST
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> DB_NAME_POST
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> USER_POST
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> PWD_POST
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> HOST_ORAC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> PORT_ORAC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> SERVICE_NAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> USER_ORAC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">global&lt;/span> PWD_ORAC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 条件と一致するデータがある場合変数に保存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> line &lt;span style="color:#f92672">in&lt;/span> lines:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (len(line) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">and&lt;/span> &lt;span style="color:#e6db74">&amp;#39;POSTGRESQL&amp;#39;&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#f92672">in&lt;/span> line &lt;span style="color:#f92672">and&lt;/span> &lt;span style="color:#e6db74">&amp;#39;ORACLE&amp;#39;&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#f92672">in&lt;/span> line):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> line&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">&amp;#39;=&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;HOST_POST&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HOST_POST &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;PORT_POST&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PORT_POST &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;DB_NAME_POST&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DB_NAME_POST &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;USER_POST&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> USER_POST &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;PWD_POST&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PWD_POST &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;HOST_ORAC&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HOST_ORAC &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;PORT_ORAC&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PORT_ORAC &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;SERVICE_NAME&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SERVICE_NAME &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;USER_ORAC&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> USER_ORAC &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;PWD_ORAC&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> result[&lt;span style="color:#ae81ff">0&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PWD_ORAC &lt;span style="color:#f92672">=&lt;/span> result[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 起動部&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getDBConnection()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 引数がない場合は異常終了処理分岐&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (len(args) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;&amp;gt;&amp;gt; Please check arguement. quitting.&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GetProcdate(args)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DBConnectionファイルを読み込む処理に関してはより良い書き方があるのではないかと思います…が、Python特有のGetter/Setterの書き方にあまり慣れてないゆえ、自分が理解できるコードとして書いた結果がこうです。グローバル変数がメソッド内で&lt;code>global&lt;/code>宣言をしないと使えないというところがJavaに慣れていた自分にはかなり新鮮でした。逆にグローバル変数をそれぞれ違うメソッドではなるべく使うなという意味もあるような気もします。&lt;/p>
&lt;p>あとはファイル書き込みがテキストだけでなく、バイナリーデータの場合も簡単にかけるということが魅力的ですね。Javaだったらストリームやバッファーをはじめとしてかなり複雑な書き方になっていただろうと思いますが(しかも私はテキストしか扱ったことがないので、同じやり方でバイナリーまでかけるかどうかわかりません)、Pythonではモジュールのインポートもなしで簡単にできますね。もちろん性能を考えるとJavaでかいた方がよかったかもしれませんが、こういう簡単さんがやっぱり生産性の向上に役立つのではないかと思います。&lt;/p>
&lt;p>あと、やはりPythonはLinux親和的な構造が魅力的だと思います。処理の結果を判別するために&lt;code>sys.exit()&lt;/code>を設定すると終了コードを簡単に確認できますし、&lt;code>sys.args&lt;/code>を通じてコマンドラインから引数を受け入れることもできます。簡単かつLinux親和的なので、Linuxでのスクリプト処理が必要な場合はシェルスクリプトよりもPythonを用いる方が良いのでは、と思うようになりました。性能もシェルより良いところもあるという話もありますしね。&lt;/p>
&lt;p>結果的にPythonを褒めるようなポストとなりましたが、私としてはプログラミングの初心者もしくはLinuxサーバーからスクリプトを組むことの多い開発者に魅力的な言語と思うので、皆さんにもぜひPythonを使って欲しいです。楽しく、楽に開発しましょう！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Simple Storage Serviceの略で、その名の通りOSにマウントして普通のディスクのように使えるサービスだそうです。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Tera Termを使う</title><link>https://retheviper.github.io/posts/linux-teraterm-macro/</link><pubDate>Mon, 24 Jun 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/linux-teraterm-macro/</guid><description>&lt;img src="https://retheviper.github.io/images/linux_terminal.webp" alt="Featured image of post Tera Termを使う" />&lt;p>PuttyやMacのターミナルは使ってみたことがありますが(CLIの範囲まで行くとMS-DOSも)、&lt;a class="link" href="https://ttssh2.osdn.jp/" target="_blank" rel="noopener"
>Tera term&lt;/a>を使ったことはなかったです。でも仕事ではAWSでLinuxのサーバーを立てて使っているのでSSH接続が必要となります。ここで私が初めてしたことはそのSSH接続ができるようにTera termのマクロを作ることでした。それまでは主に文書作業をしていたので、やっとコーディングのようなことができて嬉しく思いましたね。&lt;/p>
&lt;p>他にも色々良いツールはあるのではないかと思いますが、マクロで簡単にシェルのコマンドが発行できたり、画面のカスタマイズが簡単だということが便利ですね。最近はWindows 10でもターミナルが使えるようになったりWSLというサービスができましたが、まだ会社で支給されるパソコンがWindows 10ではない場合にはこちらの方を使うのが便利だろうと思います。&lt;/p>
&lt;p>それでは、設計と実際のコードでどうマクロを作ったかを紹介します。&lt;/p>
&lt;h2 id="マクロの設計">マクロの設計
&lt;/h2>&lt;p>全てのAWS EC2がそうなのかわかりませんが、今回の案件ではいわゆる「踏み台サーバー」を経由してからEC2サーバーに接続することができています。最初はその概念すらなかったのでなぜこんな構造になるのか疑問でしたが、それぞれのEC2サーバーが直接インターネットに繋がっている訳ではないのでこういう手続きが必要となるらしいです。なのでまず踏み台サーバーに接続し、そこからSSHコマンドを発行しそれぞれのEC2サーバーに接続できるようなマクロを作ります。&lt;/p>
&lt;p>そして今回はバッチサーバー、WebAPサーバー、CIサーバーという三つの構成となるので踏み台からそれぞれのサーバーに接続できるようにしたいです。また、同時に複数のサーバーで作業する場合を踏まえてサーバーごとのターミナル画面を少しカスタマイズしたいです。少し調べてみると、マクロには接続の手続きを書き、マクロからあらかじめ画面の設定をしておいたINIファイルを読み込むようにすればいいらしいです。またCIサーバーではJenkinsのようなサービスもポートフォワードで使いたいのですが、その設定もこのINIファイルに記録されるみたいなのでマクロからCIサーバーに接続する場合に限定してポートフォワード設定が入ったINIファイルを呼ぶようにしたいです。&lt;/p>
&lt;p>以上の要件を整理すると、マクロの仕組みは以下となります。&lt;/p>
&lt;ol>
&lt;li>リストから接続先を選択する(選択肢は3つ)&lt;/li>
&lt;li>まず踏み台サーバーに接続し、そこからさらに選択したサーバーへSSH接続する&lt;/li>
&lt;li>接続が終わると選択したサーバーごとのINIファイルを読み込む&lt;/li>
&lt;/ol>
&lt;p>INIファイルの設定はUIからターミナルとウィンドウ、フォント、ポートフォワードを予め設定し、それぞれの接続先に合わせ3つを用意しておきました。あとはマクロから読み込むだけです。では肝心のマクロのコードはどうなかったかというと、以下のようになります。&lt;/p>
&lt;h2 id="マクロのコード">マクロのコード
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; 踏み台ユーザーID／PW
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>USERNAME &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;踏み台ユーサーID&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PASSWORD &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;踏み台ユーザーPW&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; 踏み台サーバーIPアドレス
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HOSTIP &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;ここにIP&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; 接続先別作業用ユーザーID
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strdim WORKUSERLIST &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WORKUSERLIST&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;バッチサーバーのユーザーID&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WORKUSERLIST&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;WebAPサーバーのユーザーID&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WORKUSERLIST&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;CIサーバーのユーザーID&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; 接続先別作業用ユーザPW
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strdim WORKPWLIST &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WORKPWLIST&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;バッチサーバーのユーザーPW&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WORKPWLIST&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;WebAPサーバーのユーザーPW&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WORKPWLIST&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;CIサーバーのユーザーPW&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; サーバーIP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strdim SERVERipLIST &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVERipLIST&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;バッチサーバーのIP&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVERipLIST&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;WebAPサーバーのIP&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVERipLIST&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;CIサーバーのIP&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; リストに表示されるサーバー名称設定
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strdim SERVERnameLIST &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVERnameLIST&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;バッチサーバー&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVERnameLIST&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;WebAPサーバー&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SERVERnameLIST&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;CIサーバー&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; サーバー別INIファイル
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strdim INILIST &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INILIST&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/BatchServer.INI&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INILIST&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/WebAPServer.INI&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INILIST&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/CIServer.INI&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; 接続先ホスト選択画面
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>listbox &lt;span style="color:#e6db74">&amp;#39;サーバーを選択して下さい&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;決定&amp;#39;&lt;/span> SERVERnameLIST
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> result &amp;gt;&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SERVERIP &lt;span style="color:#f92672">=&lt;/span> SERVERipLIST&lt;span style="color:#f92672">[&lt;/span>result&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WORKUSER &lt;span style="color:#f92672">=&lt;/span> WORKUSERLIST&lt;span style="color:#f92672">[&lt;/span>result&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WORKPASSWORD &lt;span style="color:#f92672">=&lt;/span> WORKPWLIST&lt;span style="color:#f92672">[&lt;/span>result&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INIFILE &lt;span style="color:#f92672">=&lt;/span> INILIST&lt;span style="color:#f92672">[&lt;/span>result&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> end
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>endif
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; INIファイルのパスの読み込み
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>getdir INIPATH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat INIPATH INIFILE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; 踏み台サーバーへの接続用コマンド組立て + 接続コマンド実行
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PROXY &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;-proxy=http://proxy.server.com:6000&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>COMMAND &lt;span style="color:#f92672">=&lt;/span> PROXY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat COMMAND &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat COMMAND HOSTIP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat COMMAND &lt;span style="color:#e6db74">&amp;#39;:22 /ssh /auth=password /user=&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat COMMAND USERNAME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat COMMAND &lt;span style="color:#e6db74">&amp;#39; /passwd=&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat COMMAND PASSWORD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>connect COMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wait &lt;span style="color:#e6db74">&amp;#39;$&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; 接続先別SSH接続処理
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SSHCOMMAND &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;ssh &amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat SSHCOMMAND WORKUSER
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat SSHCOMMAND &lt;span style="color:#e6db74">&amp;#39;@&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>strconcat SSHCOMMAND SERVERIP
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendln SSHCOMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; 初SSHログイン処理
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wait &lt;span style="color:#e6db74">&amp;#39;Are you sure you want to continue connecting (yes/no)?&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#39;s password: &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sendln &lt;span style="color:#e6db74">&amp;#39;yes&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wait &lt;span style="color:#e6db74">&amp;#34;&amp;#39;s password: &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>elseif result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> goto INPUTPWD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>endif
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>:INPUTPWD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendln WORKPASSWORD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wait &lt;span style="color:#e6db74">&amp;#39;$&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendln &lt;span style="color:#e6db74">&amp;#39;sudo su -&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wait &lt;span style="color:#e6db74">&amp;#39;sudo&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendln WORKPASSWORD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wait &lt;span style="color:#e6db74">&amp;#39;#&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>restoresetup INIPATH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;; マクロ終了
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>;&lt;span style="color:#f92672">==============================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="コードの説明">コードの説明
&lt;/h2>&lt;p>最初は踏み台サーバーに指定しといたユーザーID、PW、IPからコマンドを組み立ててへSSH接続する構造となっています。具現化したものをみるとstconcatで文字列を繋ぎコマンドを叩いています。また仕事ではプロキシサーバーも使っているので踏み台サーバー接続のコマンドに入れていますが、ない場合はそこだけを取り除くことになります。ただ踏み台サーバー接続の後に違うサーバーに接続するのがメインなので、これの前にマクロを起動した時点ではまずリスト画面から接続先の3つのサーバーを選ぶようになっていますね。&lt;/p>
&lt;p>まず接続先のそれぞれのユーザーID、PW、IP、画面に表示するサーバー名を配列(strdim)として用意します。そして画面にはlistboxで選択できるリストを表示します。listboxで接続先を選択して決定ボタンを押すと、その結果がresultという変数に数字として入力されるのでそれを配列のインデックスとして踏み台サーバー接続のコマンドのように文字列を繋ぎSSH接続を行います。また、同じく配列で接続先ごとのINIファイル名を用意し、getdirからマクロの相対パスを取得、INIファイル名と結合したあとrestoresetupでINIファイルを読み込むようにします。(マクロファイルとINIファイルは同じフォルダーにある前提です)&lt;/p>
&lt;p>コマンドの発行では、waitを使ってターミナルの反応を待ちます。これはシェルでのexpectと同じ機能をします。いきなりコマンドを連続で発行してもサーバー側の反応とずれると想定通りにならないことを防ぐためです。waitでサーバーに次のコマンドを発行できるかどうかを判断してからsendlnでコマンドを発行するようになっています。このwaitとifを組み立てることで初接続時に「本当に接続しますか？」という文が出力されても対応できるようにマクロを作ることができます。他にはそんなに難しい部分はないと思うので説明はここまでにします。&lt;/p>
&lt;p>このマクロを&lt;code>.ttl&lt;/code>という拡張子で保存し、Tera termから読み込むかマクロから直接実行するか(Tera termのインストール時にオプションとしてマクロを直接実行できるように設定できます)で終わりです。思ったより簡単ですね！&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ifとwaitを活用してだいたいなんでもコマンドを発行できるので、ある意味シェルのようなこともできるのがこのTera termのマクロの魅力かと思います。ここのコードではマクロを起動することでrootまで行くようにしていますが、他に作業パスを変えたりとあるシェルスクリプトを実行させたりもできますね。構造的にはターミナルでコマンドを発行するようになっているだけですので。&lt;/p>
&lt;p>それでは今回のポストはここまで。楽なSSH生活のため、みなさんもぜひTera termを使ってください。&lt;/p></description></item><item><title>Pythonでxmlファイルを操作する(2)</title><link>https://retheviper.github.io/posts/python-xml-modifier-2/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/python-xml-modifier-2/</guid><description>&lt;img src="https://retheviper.github.io/images/python.webp" alt="Featured image of post Pythonでxmlファイルを操作する(2)" />&lt;p>&lt;a class="link" href="../python-xml-modifier-1" >前回のポスト&lt;/a>で、xmlファイルを操作するスクリプトを紹介しました。しかし、仕事でそのスクリプトをしばらく使わない方針となったため実際使うことがなく放置していましたが、方針が変わり作成しておいたスクリプトを実際適用してみるととある問題が出てきました。最初はスクリプトが問題だろうとは思わず、原因究明にだいぶ時間がかかりましたが、なんとか解決できた今はホッとしています。やはりコーディングという行為は設計通りの実装よりも変な挙動をしていないか確認するのが大事なのではないかと、今回も思いました。&lt;/p>
&lt;p>それでは具体的にどんな問題があり、どうコードを改善したかを今回のポストで述べていきたいと思います。厳密にいうとバグというよりは、詳細設計の段階でミスを起こしたという表現が正しいのかもしれませんが、理由はどうあれ当初の計画通り動かないコードを書いたことは反省しないといけないなと思うきっかけとなりました。これでまた成長できたと言えたらいいですね。&lt;/p>
&lt;h2 id="旧スクリプトの問題">旧スクリプトの問題
&lt;/h2>&lt;p>前回のポストで紹介したスクリプトは、一見思い通りに動いているように見えました。実際テストをしてみたときも、指定したエレメントのテキスト部はちゃんと変えてくれてましたね。しかし問題は、処理すべきxmlファイルのエレメント数が想定よりも多かったというところから発生しました。つまり、旧スクリプトではSELECT文を発行するDBのエレメントが一つ、INSERT文を発行するDBのエレメントが一つというシンプルな構成になっていましたが、今回は複数のエレメントを処理しなければならない状況となりました。&lt;/p>
&lt;p>それを旧スクリプトで処理しようとすると、一つのエレメントを書き換えたあと、残りのエレメントは無視して次のファイルに処理が移行していったのです。それがわからないまま処理が終わった時点で設計通りに動作してくれていると信じ、処理の終わったファイルを使うとエラーが発生した、というのがこのスクリプトを改修するきっかけとなりました。&lt;/p>
&lt;p>まず原因をわかったので、スクリプトの目標を修正します。今回の目標は「条件と一致する全エレメントの修正」です。&lt;/p>
&lt;h2 id="コードを改修する">コードを改修する
&lt;/h2>&lt;p>目標に合わせてコードを修正すると同時に、些細な問題も改善することにします。前回のスクリプトではフォルダー内のファイルをリストとして取得するために&lt;code>glob&lt;/code>のモジュールを使いました。わずかのコードで再帰的に下位フォルダー内のファイルまで収集してくれるので便利だったのですが、globのrecursiveオプションはPython3.5以上でしか使えないという問題があります。普段からPython3を使っていたなら問題はあまりないはずですが、他に使っているPythonのスクリプトは全てPython2を基準に作成されています。なのでこれをPython2でも使えるオプションに変えることにします。&lt;/p>
&lt;p>そしてメインとなる改善点としては、&lt;code>find&lt;/code>を&lt;code>findall&lt;/code>に変えることにします。まずDBコネクションのエレメントを全部取得し、ここで&lt;code>if&lt;/code>文を使えばDBのコネクション名によって分岐処理ができるはずです。また、今回変えたいDBコネクション名は&lt;code>From_PostgreSQL_01&lt;/code>のようにアンダースコアで連番が付いているものを&lt;code>From_PostgreSQL&lt;/code>のように連番だけ外すということなので、その仕組みも考えておきます。&lt;code>replace&lt;/code>を使う方法もありますが、これなら全てのケースに対して条件を書かなければならないですし、条件指定の例によっては重複の可能性もあります。なので&lt;code>rsplit&lt;/code>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>を使い、アンダースコアを基準に元の文字列を分割した後元のテキストを代替することにします。&lt;/p>
&lt;p>これらの要件定義から変わったことは以下となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -*- coding: UTF-8 -*-&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> xml.etree.ElementTree &lt;span style="color:#66d9ef">as&lt;/span> ET
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> os
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 名前空間（prefix）をマップで宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ns &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#39;fb&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;http://builder&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;fe&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;http://engine&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;mp&amp;#39;&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;http://mapper&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># xmlファイル名を再帰的に取得(Python2向け)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fileList &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>base_dir &lt;span style="color:#f92672">=&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>normpath(&lt;span style="color:#e6db74">&amp;#39;./baseFolder&amp;#39;&lt;/span>) &lt;span style="color:#75715e"># 検索するディレクトリの起点を設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (path, dir, files) &lt;span style="color:#f92672">in&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>walk(base_dir):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># xml2というファイルは消し、xmlファイルだけ書き換えしたいので分岐をかけ、xmlファイルだけをリスト化する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> fname &lt;span style="color:#f92672">in&lt;/span> files:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;.xml2&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> fname):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fullfname &lt;span style="color:#f92672">=&lt;/span> path &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> fname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os&lt;span style="color:#f92672">.&lt;/span>remove(fullfname)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;.xml&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> fname &lt;span style="color:#f92672">and&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.xml2&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> fname):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fullfname &lt;span style="color:#f92672">=&lt;/span> path &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> fname
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileList&lt;span style="color:#f92672">.&lt;/span>append(fullfname)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 取得したファイルを巡回しながらコネクション名の書き換え処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> fileName &lt;span style="color:#f92672">in&lt;/span> fileList:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ファイルをパーシング開始&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree &lt;span style="color:#f92672">=&lt;/span> ET&lt;span style="color:#f92672">.&lt;/span>parse(fileName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># INSERTのコンポーネントのコネクション名に&amp;#39;_01&amp;#39;などの文字がついていると取る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PutConnections &lt;span style="color:#f92672">=&lt;/span> tree&lt;span style="color:#f92672">.&lt;/span>findall(&lt;span style="color:#e6db74">&amp;#34;fe:Flow/fe:Component[@type=&amp;#39;RDB(Put)&amp;#39;]/fe:Property[@name=&amp;#39;Connection&amp;#39;]&amp;#34;&lt;/span>, ns)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> PutConnection &lt;span style="color:#f92672">in&lt;/span> PutConnections:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;_0&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> PutConnection&lt;span style="color:#f92672">.&lt;/span>text):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PutConnection&lt;span style="color:#f92672">.&lt;/span>text &lt;span style="color:#f92672">=&lt;/span> PutConnection&lt;span style="color:#f92672">.&lt;/span>text&lt;span style="color:#f92672">.&lt;/span>rsplit(&lt;span style="color:#e6db74">&amp;#39;_&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># rsplitで分割し、その結果物を元のテキストに入れる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># SELECTのコンポーネントのコネクション名に&amp;#39;_01&amp;#39;などの文字がついていると取る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GetConnections &lt;span style="color:#f92672">=&lt;/span> tree&lt;span style="color:#f92672">.&lt;/span>findall(&lt;span style="color:#e6db74">&amp;#34;fe:Flow/fe:Component[@type=&amp;#39;RDB(Get)&amp;#39;]/fe:Property[@name=&amp;#39;Connection&amp;#39;]&amp;#34;&lt;/span>, ns)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> GetConnection &lt;span style="color:#f92672">in&lt;/span> GetConnections:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;_0&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> GetConnection&lt;span style="color:#f92672">.&lt;/span>text):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GetConnection&lt;span style="color:#f92672">.&lt;/span>text &lt;span style="color:#f92672">=&lt;/span> GetConnection&lt;span style="color:#f92672">.&lt;/span>text&lt;span style="color:#f92672">.&lt;/span>rsplit(&lt;span style="color:#e6db74">&amp;#39;_&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#75715e"># rsplitで分割し、その結果物を元のテキストに入れる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># prefixが変わることを防止&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ET&lt;span style="color:#f92672">.&lt;/span>register_namespace(&lt;span style="color:#e6db74">&amp;#39;fb&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;http://builder&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ET&lt;span style="color:#f92672">.&lt;/span>register_namespace(&lt;span style="color:#e6db74">&amp;#39;fe&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;http://engine&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ET&lt;span style="color:#f92672">.&lt;/span>register_namespace(&lt;span style="color:#e6db74">&amp;#39;mp&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;http://mapper&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 書き換え処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree&lt;span style="color:#f92672">.&lt;/span>write(fileName, &lt;span style="color:#e6db74">&amp;#39;UTF-8&amp;#39;&lt;/span>, &lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ファイル取得部は&lt;code>glob&lt;/code>オプションで簡単にできたことに比べ少し複雑になっています。&lt;code>os.walk()&lt;/code>で起点のディレクトリを指定してパスとファイル名を取得します。ただ&lt;code>os.walk()&lt;/code>だとファイル名とパスは分離されるのでそれをつなぐ作業が必要ですね。そこで処理するファイルのリストに入れたり消したりする処理を加えます。これで以前の&lt;code>glob&lt;/code>と似たような挙動ができます。&lt;/p>
&lt;p>そして&lt;code>rsplit('_', 1)&lt;/code>で、まず&lt;code>From_PostgreSQL_01&lt;/code>という文字列は&lt;code>From_PostgreSQL&lt;/code>と&lt;code>01&lt;/code>に1回だけ分割されます。そして分割された文字列は配列になるので[0]を指定すると意図通り&lt;code>From_PostgreSQL_01&lt;/code>が&lt;code>From_PostgreSQL&lt;/code>に代替されます。また&lt;code>find&lt;/code>を&lt;code>findall&lt;/code>に変えただけで条件に一致する全エレメントをファイル内で探してリストにしてくれます。その中でループ処理するだけですね。これがわからなかった時は以前のコードにさらにループをかけたりして失敗していましたが、意外と簡単な解決策があったものです。&lt;/p>
&lt;p>これで完成されたコードは意図通りに動いてくれました。あとで変動があっても少しだけ変えればいいので個人的には満足しています。より綺麗な書き方はあるかもしれませんがね。そして教訓として、いつもテストは大事だなということを改めて覚えられました。常に確認と確認です。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;code>rsplit&lt;/code>と&lt;code>split&lt;/code>の違いは、方向です。前者が文字列の右側を基準に分割するなら、後者は左側からです。今回は文字列の末尾の連番を取りたいので、&lt;code>rsplit&lt;/code>を選びました。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Pythonでログを出したい</title><link>https://retheviper.github.io/posts/python-logger/</link><pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/python-logger/</guid><description>&lt;img src="https://retheviper.github.io/images/python.webp" alt="Featured image of post Pythonでログを出したい" />&lt;p>コーディングにおいて、ロジックを組むこと異常に重要なことがあるとしたらそれは自分の書いているコードが正しいかどうかを確認することだと思います。まず仕様書などを書き、要件を満たしているかどうかをチェックしながら、コードを書いていきます。しかし、実行してみない限り思い通りにコードが動いてくれるかどうかは確認できませんね。そしてその動作が正しいかどうかを判別するためにはコードの中で扱っている変数やオブジェクトに正しいデータが入っているかどうかをみます。EclipseなどのIDEにはデバッグ機能があるので、チェックポイントを設定してコードの流れをモニタリングしながらそれを追うことができますが、それを利用できない場合もありますね。では標準出力という方法もありますが、実行後に記録を追うことができないという面で不安です。&lt;/p>
&lt;p>そういう時にカスタムログを利用するのも一つの方法ですね。ちゃんとしたログを吐くように最初からロガーを作っておくと、自分の作ったプログラムが設計通りに動いているかどうかを判断できます。そしてプログラムが完成した後もネットワークの障害やデータの問題を確認するために有効活用できるという面もありますね。といっても、カスタムログを吐くロガーを書くということは難しいことのように思われます。最初ログを吐くようにしろという指示を受けて、私はどうしたらいいか？標準と言えるひな形はないのか？と悩みましたね。でもそんな難しく思うようなことはなくて、状況による分岐(メッセージやコードなど)を決め、それをテキストファイルとして出力するようにすれば良いだけの話でした。&lt;/p>
&lt;p>それでは、実際のロガーをどう作ったかをこれからコードを通じて見せましょう。&lt;/p>
&lt;h2 id="ロガーを作る">ロガーを作る
&lt;/h2>&lt;p>今回私た作りたいロガーの構造は簡単です。メインプログラムで呼び出された時に、引数としてログコード(分類番号的な)やジョブコード(作業の処理番号など)を受け、ログコードから出力するメッセージを決めます。ジョブコードは必須ではないが、ログコードは必須卯にしたいです。また、ログの書かれた時点を知りたいため日時もメッセージに入れます。この要件から出力されるログの形は以下となります。&lt;/p>
&lt;blockquote>
&lt;p>2019/06/15 12:00:00 LOG0001: Job code 1234は正常終了しました。&lt;/p>&lt;/blockquote>
&lt;p>また、ログファイルの最上段には&lt;code>---- Job Log ----&lt;/code>を入れ、これがログファイルであることを示したいです。このように基本要件を決め、実装していきます。私が実装したコードの簡略化したバージョンは以下となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ログファイルの存在有無を確認するためのosと日付を残すためのdatetimeをインポート&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> os
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> datetime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ログをかく関数(job_codeは与えられない場合があるのでデフォルト値を設定)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">writeLog&lt;/span>(log_code, job_code&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ログファイルのパスを指定(絶対経路)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log_path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;/log/program_log.log&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ログコード判定によりメッセージを決める&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (log_code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;LOGI001&amp;#39;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log_message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Job code &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> job_code &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;を実行します。&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (log_code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;LOGI002&amp;#39;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log_message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Job code &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> job_code &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;は正常終了しました。&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (log_code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;LOGW001&amp;#39;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log_message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Job codeがありません。プログラムの起動に失敗しました。&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span> (log_code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;LOGE001&amp;#39;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log_message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Job code &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> job_code &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;は異常終了しました。&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log_message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;原因を特定できないエラーが発生しました。&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ログファイルが存在しない場合は先端にログであることを示すコードを含むファイルを生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">not&lt;/span> os&lt;span style="color:#f92672">.&lt;/span>path&lt;span style="color:#f92672">.&lt;/span>exists(log_path)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(log_path, mode&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> log:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log&lt;span style="color:#f92672">.&lt;/span>write(&lt;span style="color:#e6db74">&amp;#39;----- Job Log -----&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ログファイルがすでに存在する場合は追記する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(log_path, mode&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> log:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log&lt;span style="color:#f92672">.&lt;/span>write(datetime&lt;span style="color:#f92672">.&lt;/span>datetime&lt;span style="color:#f92672">.&lt;/span>today()&lt;span style="color:#f92672">.&lt;/span>strftime(&lt;span style="color:#e6db74">&amp;#39;%Y/%m/&lt;/span>&lt;span style="color:#e6db74">%d&lt;/span>&lt;span style="color:#e6db74"> %H:%M:%S&amp;#39;&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> log_code &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> log_message &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでメインプログラムでロガーを呼び、そのタイミングでログコードやジョブコードを渡すだけでログは残されます。ログの種類を減らしたい、もしくは増やしたい場合はif文を修正するだけで対応できます。&lt;/p>
&lt;h2 id="メインプログラムでロガーを呼び出す">メインプログラムでロガーを呼び出す
&lt;/h2>&lt;p>メインプログラムでまずログを書く(ロガーを呼ぶ)タイミングを決めます。例えば今回はDBに接続するタスクがあったので、DBの接続に失敗した場合にロガーを書くようにしました。そのほかにも処理の開始や終了時のステータスなどに関してもログを残したいですね。&lt;/p>
&lt;p>同じく簡略化したメインプログラムのコードは以下のような形です。先に作成して置いたロガーをインポートし、ログを出したい場合に呼び出すだけでいいです。ただロガーファイルの位置が実行するメインプログラムと違うパスにある場合はインポートの形が変わるので注意が必要です。ここではメインプログラムとロガーは同じパスから実行される場合を想定して実装しています。それでは下のコードをどうぞ。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 簡略化したメインプログラム&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 終了時のリターンコードと起動時の引数のためsysを、ログを書くためにロガーのwriteLog関数をインポート&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> sys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> logger &lt;span style="color:#f92672">import&lt;/span> writeLog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 起動時にコマンドラインから引数を受けるための変数宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>args &lt;span style="color:#f92672">=&lt;/span> sys&lt;span style="color:#f92672">.&lt;/span>argv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 関数の例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">program&lt;/span>(job_code):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 処理開始の時点でログを書く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> writeLog(&lt;span style="color:#e6db74">&amp;#39;LOGI001&amp;#39;&lt;/span>, job_code)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 正常処理時の挙動を書く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print (&lt;span style="color:#e6db74">&amp;#39;何かの処理を行う&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 正常終了のコードでログを書く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> writeLog(&lt;span style="color:#e6db74">&amp;#39;LOGI002&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 正常終了の場合は終了時のリターンコードが0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 処理に問題が起きた場合の処理を書く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 異常終了のコードでログを書く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> writeLog(&lt;span style="color:#e6db74">&amp;#39;LOGE001&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 異常終了の場合は終了時のリターンコードが9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">9&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># プログラムの起動部&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;__main__&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 引数(ジョブコード)が入力されなかった場合のチェック&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (args[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">in&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 警告終了のコードでログを書く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> writeLog(&lt;span style="color:#e6db74">&amp;#39;LOGW001&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 警告終了の場合は終了時のリターンコードが1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys&lt;span style="color:#f92672">.&lt;/span>exit(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> program(args[&lt;span style="color:#ae81ff">1&lt;/span>])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>どんなログを吐き出して欲しいかによってロガーを呼び出す位置を決めます。そして引数を渡すことでどんな場合にどんなログを出力するかを決められます。実装が難しい作業ではないですが、こうやってロガーを分離して必要な時だけ呼び出すことでメインプログラムのコードがいくら長くなっても関数を呼び出すだけで済むという効率的な構造となっています。そもそも関数というものは、反復を減らすために書くものでもありますしね。&lt;/p>
&lt;p>あと少し調べたところ、Pythonではモジュールとしてloggerをすでに提供しているとのことです。標準出力としてログのレベルを指定して文字列を出力できるらしいですね。これを応用してファイルに描くようにコードを書くこともまた良い方法になるのではないかと思います。&lt;/p>
&lt;p>仕事でコードを書きながら、大事なのはどんなコマンドと関数名を覚えているかではなく、どんな構造で実装していくかなのではないかと思うようになりました。最近は本でもインターネットでも基礎文法に関する講座やTipは簡単に得られますが、こういう設計の仕方に関しては、やはり実戦ではないとなかなか得られない分野の知識ではないかとも思います。またこれからどんなコードを書くようになるだろうか、色々楽しみです。&lt;/p></description></item><item><title>macOSでもショートカットが使いたい</title><link>https://retheviper.github.io/posts/linux-mac-shortcut/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/linux-mac-shortcut/</guid><description>&lt;img src="https://retheviper.github.io/images/linux_terminal.webp" alt="Featured image of post macOSでもショートカットが使いたい" />&lt;h2 id="お知らせ">お知らせ
&lt;/h2>&lt;p>macOSがCatalina(10.15)になってから、ターミナルの基本シェルがbashから&lt;a class="link" href="https://ja.wikipedia.org/wiki/Z_Shell" target="_blank" rel="noopener"
>zsh&lt;/a>に変わりました。なのでこのポストをそのまま適用すると、追加したコマンドを使えない場合があります。&lt;/p>
&lt;p>すでにBashにコマンドを追加した場合は以下の手順で移行ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cat ~/.bash_profile &amp;gt;&amp;gt; ~/.zprofile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>新規で追加する場合は、下の「プロファイルを作る」節のコマンドの代わりに以下を入力します。そのあとは同じ手順で進めてください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>vi ~/.zprofile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下、前のポストです。&lt;/p>
&lt;hr>
&lt;p>パソコンではMS-DOSとWindowsしか使ってみたことのない私がmacを使ってかれこれ一年となります。macといえばやはり高く、Windowsとは全く違う環境なので使いづらいのではないかなと思っていました。動画や音楽の編集には最適だという話もありましたが、自分とは関係のない世界の話でした。&lt;/p>
&lt;p>そんな私がmacを使うきっかけとなったのは、様々な理由がありますが、開発の仕事をしている今は何よりもUnix系のOSということが最大のメリットとなっているのではないかと思います。仕事ではLinuxを触ることが多いのですが、macのターミナルでのほぼ同じことができますので。&lt;/p>
&lt;p>ただ、同じくBashを使っているといっても、macとLinuxは完全に同一ではありません。例えばショートカットがそうです。Linuxの便利なショートカットがmacにはないですね。でも調べてみると、やはり方法は存在していました。&lt;/p>
&lt;p>今回のポストはそのLinuxのショートカットをmacで使うための設定の話です。といっても、自分が研究した訳ではなく、インターネットで拾ってきた情報にすぎませんがね。でもこの設定をみるだけでも様々なコマンドやAliasを勉強できて、かなり貴重な資料ではないかと思います。誰か知りませんが、作った方には敬意を。&lt;/p>
&lt;h2 id="プロファイルを作る">プロファイルを作る
&lt;/h2>&lt;p>まずはBashのプロファイルを作ります。ターミナルで以下のように入力します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>vi ~/.bash_profile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>bash_profile&lt;/code>と&lt;code>bashrc&lt;/code>の違いは、前者がターミナルを開くときすぐ適用される設定なら、後者はターミナルで改めてBashを実行した時に適用される設定という違いがあるらしいです。ただコマンドでわかりますが、現在ユーザーのホームにプロファイルを作るのでユーザーが変わる場合はまた同じことをする必要があります。&lt;/p>
&lt;h2 id="プロファイルの内容">プロファイルの内容
&lt;/h2>&lt;p>以下のコードをプロファイルに入れます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#.bash_profile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -f ~/.bashrc &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>. ~/.bashrc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#============================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ALIASES AND FUNCTIONS&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Arguably, some functions defined here are quite big.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># If you want to make this file smaller, these functions can&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#+ be converted into scripts and removed from here.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#============================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Personnal Aliases&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias rm&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;rm -i&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias cp&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;cp -i&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias mv&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;mv -i&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias cl&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;clear&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -&amp;gt; Prevents accidentally clobbering files.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias mkdir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;mkdir -p&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias h&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;history&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;jobs -l&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias which&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;type -a&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias ..&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;cd ..&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Pretty-print of some PATH variables:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias path&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;echo -e ${PATH//:/\\n}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias libpath&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;echo -e ${LD_LIBRARY_PATH//:/\\n}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias du&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;du -kh&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Makes a more readable output.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias df&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;df -kTh&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------------------------------------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># The &amp;#39;ls&amp;#39; family (this assumes you use a recent GNU ls).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------------------------------------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Add colors for filetype and human-readable sizes by default on &amp;#39;ls&amp;#39;:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias ls&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ls -h&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias lx&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ls -lXB&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Sort by extension.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias lk&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ls -lSr&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Sort by size, biggest last.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias lt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ls -ltr&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Sort by date, most recent last.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias lc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ls -ltcr&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Sort by/show change time,most recent last.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias lu&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ls -ltur&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Sort by/show access time,most recent last.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># The ubiquitous &amp;#39;ll&amp;#39;: directories first, with alphanumeric sorting:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias ll&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ls -alv&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias lm&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ll |more&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Pipe through &amp;#39;more&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias lr&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ll -R&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Recursive ls.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias la&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ll -A&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Show hidden files.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias tree&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;tree -Csuh&amp;#39;&lt;/span> &lt;span style="color:#75715e"># Nice alternative to &amp;#39;recursive ls&amp;#39; ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------------------------------------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Tailoring &amp;#39;less&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------------------------------------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias more&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;less&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PAGER&lt;span style="color:#f92672">=&lt;/span>less
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESSCHARSET&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;latin1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESSOPEN&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;|/usr/bin/lesspipe.sh %s 2&amp;gt;&amp;amp;-&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Use this if lesspipe.sh exists.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;-i -N -w -z-4 -g -e -M -X -F -R -P%t?f%f \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">:stdin .?pb%pb\%:?lbLine %lb:?bbByte %bb:-...&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># LESS man page colors (makes Man pages more readable).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESS_TERMCAP_mb&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">$&amp;#39;\E[01;31m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESS_TERMCAP_md&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">$&amp;#39;\E[01;31m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESS_TERMCAP_me&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">$&amp;#39;\E[0m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESS_TERMCAP_se&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">$&amp;#39;\E[0m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESS_TERMCAP_so&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">$&amp;#39;\E[01;44;33m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESS_TERMCAP_ue&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">$&amp;#39;\E[0m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LESS_TERMCAP_us&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">$&amp;#39;\E[01;32m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------------------------------------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Spelling typos - highly personnal and keyboard-dependent :-)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------------------------------------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias xs&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;cd&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias vf&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;cd&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias moer&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;more&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias moew&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;more&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias kk&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ll&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------------------------------------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Using in MAC&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#-------------------------------------------------------------&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias desk&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;cd ~/Desktop&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias cl&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;clear&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして&lt;code>source ~/.bash_profile&lt;/code>を叩き、現在のユーザーに適用すれば終わりです。ユーザーのプロファイルに保存されるので、複数のユーザーを使う場合(rootを含め)はまた同じやり方で適用することを忘れずにしましょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>&lt;code>ll&lt;/code>をmacでも使えないかなーという軽い気持ちで調べて得られた情報ですが、まさか&lt;code>ll | more&lt;/code>みたいなものまでAliasの指定ができるとは知らなかったです。またよく&lt;code>cd&lt;/code>を&lt;code>xs&lt;/code>に間違えたりしていますが、それもあえでコマンドとして登録するという発想も斬新ですね。まだまだ知らないコマンドもたくさんありますし、軽い気持ちから始まった作業にしては貴重な情報が得られ他ので嬉しい限りです。これがインターネット時代の恩義というものではないでしょうか。&lt;/p>
&lt;p>一部はLinuxでも登録すると便利そうなショートカットが多いように見えるので、Linuxを使われる肩がいらっしゃるのならぜひ一度は試してみてくださいとオススメしたいです。では、楽なBashライフをお楽しみください。&lt;/p></description></item><item><title>Pythonでxmlファイルを操作する(1)</title><link>https://retheviper.github.io/posts/python-xml-modifier-1/</link><pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/python-xml-modifier-1/</guid><description>&lt;img src="https://retheviper.github.io/images/python.webp" alt="Featured image of post Pythonでxmlファイルを操作する(1)" />&lt;p>IT関係の仕事を選び、最も良いと思うところはやはり色々な状況に置かれることによって得られる経験が多いということではないかと思います。なぜかというと、独学だけでは言語の基礎文法はわかっても実際のコーディングではどう設計したらいいか、どんなモジュール(ライブラリーを含め)を使ったらいいかわからない場合があるからです。そもそも何を作ればいいかわからない場合が多いですね。大分類としてはウェブアプリケーションか、バッチで動くコードかということなどがあり、細かくはどんなDBを使って、どんな作業をしたいか(結合する対象など)の詳細を一人で全部想定することはかなり難しい作業ではないかと思います。しかし仕事ではある程度要件が決まっているので、その結合の方法と必要な作業がわかればあとは頑張るだけですから。目標設定が何よりも重要だということはまさにこれのことかもしれません。&lt;/p>
&lt;p>なので今回も仕事で任されたことです。要件はこうです。とあるツールを使って開発をしています。このツールではGUIでマップ上にアイコンを配置し、そのアイコンが一つの作業単位となっています。そしてアイコンとアイコンを結び、各アイコンにとある行動を設定することで全体なワークフローが出来上がる構造となっています。例えばDBのアイコンに接続先のDBの情報と発行するSQL文を入力し、ファイル出力のアイコンに繋ぐとそれを実行した時にDBからSQL文を実行した結果がファイルとして保存されます。このツールで作られたワークフローはxmlファイルとして保存されます。&lt;/p>
&lt;p>問題は、開発環境と本場環境での設定が違うところがあるということです。主にこのツールを通してやっている作業はDB関係のものですが、開発環境と本場環境でそれぞれDBの接続先情報が違います。そしてそのDBの接続先の設定はxmlファイルに保存されているので、開発の終わったxmlファイルを本場環境にデプロイするときはただのコピーでは不完全なので「DBの接続先情報を書き換える」作業が必要です。この作業をどう実装したから今回のポストのテーマとなります。&lt;/p>
&lt;h2 id="事前準備">事前準備
&lt;/h2>&lt;p>デプロイ先と、デプロイ元のサーバーは両方Linuxを使っています。そしてxmlファイルのソースはGitで管理することになっています。なのでまずデプロイ元からはGit pullし、DB情報を書き換えたあとはrsyncなどのコマンドでコピーすれば簡単に終わります。こちらの作業はJenkinsで自動化することにしました。ならば、残る問題はDB情報を書き換える作業をどう実装するかですね。&lt;/p>
&lt;p>xmlを分析してみたら、各アイコンのタグの下にはそのアイコンの詳細設定情報がありました。DBの処理を行うアイコンは二つあって、一つ目はSELECTを発行する(以下、From)もので、二つ目はINSERTを発行する(以下、To)ものでした。FromとToで接続先のDBは種類も違って(片方はPostgreSQLで、片方はSQLServer)スキーマやテーブル名も違うので分けて処理する必要があります。&lt;/p>
&lt;p>そして環境から考えると、Linuxで使える言語を選んだほうがいいでしょう。まずはシェルスクリプトを使ってコードを書いてみようと思いました。これが私の初のシェルスクリプトとなります。Javaよりは簡単ではないだろうか、という根拠のない自信からシェルを選びました。LinuxにはPythonも入っていましたが、そちらも触ったことがなかったのでまずシェルでやってみて、ダメだったらPythonに挑戦してみようかなと軽く思っていました。それが結果的には最初からPythonで書けばよかった…ってことになりましたが。&lt;/p>
&lt;p>ともかくやりたいこと、環境、道具が揃ったので早速実装に入りました。&lt;/p>
&lt;h2 id="シェルスクリプトでコーディング">シェルスクリプトでコーディング
&lt;/h2>&lt;p>シェルは初めてだったので、試行錯誤が多かったです。最初に学んだのがJavaだったので、同じ感覚で書こうとしたら全然動きません。何回か失敗を重ねながら得られた結論は、関数を使うという考え方を捨てて、どうコマンドを組み合わせるかが重要だということでした。それに気づくにはだいぶ時間がかかりましたが、まず大事なことはわかったのであとはどんなことをするかですね。&lt;/p>
&lt;p>まずはファイルを読み込むことからです。xmlファイルも結局はテキスト基盤なので、シェルでも読み込みはできます。For文一つで特定の拡張子をもつファイルを巡回しながら一行づつ読むことができるらしいです。そして既存のアイコン(このファイルを使うツールの表現を借りると、コンポーネント)のDB接続先の情報の行を把握し、書き換えれば完了。&lt;/p>
&lt;p>ただ、前述したようにFromとToのコンポーネントを区別する必要があります。xmlファイルを覗くとどうやらコンポーネントの構造(タグの種類)はほぼ同じみたいなので、どう判定するかが問題でした。シェルではxmlをパーシングできるモジュールなどはないみたいですからね。それでまずは行数を比較して、Fromのコンポーネントがより上にあったら１番目に引っかかったDB設定がFromのやつだ、という風に判定することにしました。以下はその実装のコードです。&lt;/p>
&lt;h2 id="コードの例シェルスクリプト">コードの例(シェルスクリプト)
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e"># 下のフォルダを巡回しながらxmlの拡張子を持つファイルを変数のfileNameに入れる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> fileName in &lt;span style="color:#e6db74">`&lt;/span>&lt;span style="color:#ae81ff">\f&lt;/span>ind . -name &lt;span style="color:#e6db74">&amp;#39;*.xml&amp;#39;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># コンポーネントの行数をつかめる(grepでコンポーネントのタグかを確認し、sedで行数を確保)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getComponentLine&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>grep -n RDBGet &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span> | grep Component | sed -e &lt;span style="color:#e6db74">&amp;#39;s/:.*//g&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> putComponentLine&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>grep -n RDBPut &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span> | grep Component | sed -e &lt;span style="color:#e6db74">&amp;#39;s/:.*//g&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># コネクションの行数をつかめる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConnectionOneLine&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>grep -n Connection &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span> | sed -e &lt;span style="color:#e6db74">&amp;#39;s/:.*//g&amp;#39;&lt;/span> | awk &lt;span style="color:#e6db74">&amp;#39;NR==1&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConnectionTwoLine&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>grep -n Connection &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span> | sed -e &lt;span style="color:#e6db74">&amp;#39;s/:.*//g&amp;#39;&lt;/span> | awk &lt;span style="color:#e6db74">&amp;#39;NR==2&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># コネクション名をつかめる(cutでDB設定名だけを取り、awkで2種類以上の結果からどちらかを取る)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConnectionOneName&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>grep Connection &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span> | cut -d &lt;span style="color:#e6db74">&amp;#34;&amp;gt;&amp;#34;&lt;/span> -f &lt;span style="color:#ae81ff">2&lt;/span> | cut -d &lt;span style="color:#e6db74">&amp;#34;&amp;lt;&amp;#34;&lt;/span> -f &lt;span style="color:#ae81ff">1&lt;/span> | awk &lt;span style="color:#e6db74">&amp;#39;NR==1&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ConnectionTwoName&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>grep Connection &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span> | cut -d &lt;span style="color:#e6db74">&amp;#34;&amp;gt;&amp;#34;&lt;/span> -f &lt;span style="color:#ae81ff">2&lt;/span> | cut -d &lt;span style="color:#e6db74">&amp;#34;&amp;lt;&amp;#34;&lt;/span> -f &lt;span style="color:#ae81ff">1&lt;/span> | awk &lt;span style="color:#e6db74">&amp;#39;NR==2&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>getComponentLine&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -lt &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>putComponentLine&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># get &amp;lt; putの場合ConnectionOneLineはgetのコネクション&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sed -i -e &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>ConnectionOneLine&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> s/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>ConnectionOneName&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/HONBADBFROM/g&amp;#34;&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sed -i -e &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>ConnectionTwoLine&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> s/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>ConnectionTwoName&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/HONBADBTO/g&amp;#34;&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># get &amp;gt; putの場合ConnectionOneLineはputのコネクション&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sed -i -e &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>ConnectionTwoLine&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> s/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>ConnectionTwoName&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/HONBADBFROM/g&amp;#34;&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sed -i -e &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>ConnectionOneLine&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> s/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>ConnectionOneName&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/HONBADBTO/g&amp;#34;&lt;/span> &lt;span style="color:#e6db74">${&lt;/span>fileName&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="問題点">問題点
&lt;/h2>&lt;p>ファイルの形式がxmlであり、タグのパーシングで確実にコンポーネントを分けて処理していない現行の方式ではあまり安全だとは言えない処理です。そしてこの方式だとFromとToのコンポーネントがそれぞれ一つづつある場合は大丈夫かもしれませんが、どちらかのコンポーネントが一つでも増えたら処理の方法を変えるしかないです。もしかしたらそんなケースが増えると、そのケースに合わせてそれぞれ違うコードを書く必要があるかもしれません。そしてそれはいちいちファイルをチェックしてそれにあうコードとマッチさせる必要がありますね。これなら手書きで変えるのとあまり変わらないのでは…と思いますね。&lt;/p>
&lt;p>結果的に汎用性もなく、安全でもないコードとなってしまいました。こんなコードは本場では使えません。なので方法を変えることにしました。&lt;/p>
&lt;h2 id="pythonで書き直す">Pythonで書き直す
&lt;/h2>&lt;p>次の方法として、Pythonを使ってちゃんとパーシングを行うことにしました。挑戦してみてからわかったのですが、こんな簡単な作業をするときはPythonが正解なのではないかと思うくらい簡単でした。それにLinuxの環境では基本的にPythonが入っている場合も多いようなので(yumがPythonを使う代表的な例です)、インストールしなくてもいいというのがメリットでもあります。それにBashがLinuxの基本機能であるのでPythonよりは速度が早いのではないかと思っていましたが、必ずしもそうでもないらしいですね。ならばますますシェルスクリプトにこだわる理由は無くなります。&lt;/p>
&lt;p>ただLinuxに内蔵されているPythonは2が多いらしく(確認してみると、私の使うMacでもPython2が入っていました)、Pythonは2と3で文法が違うところも多くて特定の機能を使うには注意がいるらしいです。実際私の書いたコードでは、Python3でしか使えない部分があります。alternativeのようなコマンドでPythonのリンクを3に指定するという方法もありますが、それならPython2を使うプログラムで問題が起こる可能性があります。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>なので最初からPython2のコードに書くか、実行するコードをPython3として実行するようにするか、Python2を使うプログラムの実行環境を変えるかの方法を工夫する必要がありました。&lt;/p>
&lt;p>ここで私は、自分が書いたコードをPython3で実行するよう(Jenkinsに埋め込むので、そちらの設定を通しています)にしました。コードは以下となります。&lt;/p>
&lt;h2 id="コードの例python">コードの例(Python)
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># -*- coding: UTF-8 -*-&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 日本語のコメントのために最初にエンコードを指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># xmlパーサーとフォルダからファイルを取得するモジュールをインポート&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> xml.etree.ElementTree &lt;span style="color:#66d9ef">as&lt;/span> ET
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> glob
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 名前空間（prefix）をマップで宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ns &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#e6db74">&amp;#39;fb&amp;#39;&lt;/span>:&lt;span style="color:#e6db74">&amp;#39;http://foo.com/builder&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;fe&amp;#39;&lt;/span>:&lt;span style="color:#e6db74">&amp;#39;http://foo.com/engine&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;mp&amp;#39;&lt;/span>:&lt;span style="color:#e6db74">&amp;#39;http://foo.com/mapper&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ファイル名を再帰的に取得(recursiveオプションはPython3専用)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fileList &lt;span style="color:#f92672">=&lt;/span> glob&lt;span style="color:#f92672">.&lt;/span>glob(&lt;span style="color:#e6db74">&amp;#34;**/HOGE*.xml&amp;#34;&lt;/span>, recursive&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 取得したファイルを巡回しながらコネクション名の書き換え処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> fileName &lt;span style="color:#f92672">in&lt;/span> fileList:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># ファイルをパーシング開始&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree &lt;span style="color:#f92672">=&lt;/span> ET&lt;span style="color:#f92672">.&lt;/span>parse(fileName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Toのコンポーネントで子要素であるコネクション名を取得(prefix内)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> putCon &lt;span style="color:#f92672">=&lt;/span> tree&lt;span style="color:#f92672">.&lt;/span>find(&lt;span style="color:#e6db74">&amp;#34;fe:WorkFlow/fe:Component[@type=&amp;#39;RDB(Put)&amp;#39;]/fe:Property[@name=&amp;#39;Connection&amp;#39;]&amp;#34;&lt;/span>, ns)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> putCon&lt;span style="color:#f92672">.&lt;/span>text &lt;span style="color:#f92672">=&lt;/span> putCon&lt;span style="color:#f92672">.&lt;/span>text &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;x&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Fromのコンポーネントで子要素であるコネクション名を取得(prefix内)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getCon &lt;span style="color:#f92672">=&lt;/span> tree&lt;span style="color:#f92672">.&lt;/span>find(&lt;span style="color:#e6db74">&amp;#34;fe:WorkFlow/fe:Component[@type=&amp;#39;RDB(Get)&amp;#39;]/fe:Property[@name=&amp;#39;Connection&amp;#39;]&amp;#34;&lt;/span>, ns)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getCon&lt;span style="color:#f92672">.&lt;/span>text &lt;span style="color:#f92672">=&lt;/span> getCon&lt;span style="color:#f92672">.&lt;/span>text &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;y&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 書き込みの時prefixが変わることを防止&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ET&lt;span style="color:#f92672">.&lt;/span>register_namespace(&lt;span style="color:#e6db74">&amp;#39;fb&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;http://foo.com/builder&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ET&lt;span style="color:#f92672">.&lt;/span>register_namespace(&lt;span style="color:#e6db74">&amp;#39;fe&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;http://foo.com/engine&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ET&lt;span style="color:#f92672">.&lt;/span>register_namespace(&lt;span style="color:#e6db74">&amp;#39;mp&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;http://foo.com/mapper&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 書き換え処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tree&lt;span style="color:#f92672">.&lt;/span>write(fileName, &lt;span style="color:#e6db74">&amp;#39;UTF-8&amp;#39;&lt;/span>, &lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>コードの量もそんなに長くないし、ちゃんとパーシングで要素を捉えているのでシェルスクリプトに比べ安全な書き方になっています。それにタグによってコンポーネントを区別しているので、コンポーネントを数に変動があってもそのまま使えるという長所がありますね。タグに名前空間があると初期設定と書き込み直前にその処理が必要となるので少し面倒な部分はありますが&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>、確かにシェルスクリプトに比べ維持補修の面で手間がかからなくなったので満足できるコードを書けたと思います。速度も直接測定してみた訳ではないですが、相当早かったです(ただ単にPythonは遅いだろうという自分の偏見が問題だったかもしれません)。いやーPythonいいですね。&lt;/p>
&lt;p>何よりもメインの関数やクラスを省略しても、本当にスクリプトぽい書き方でもちゃんと意図通りに動くということが素晴らしいですね。これからもLinux環境で簡単な反復作業を自動化したいという場合には、皆さんもぜひPythonを使ってみてくださいとオススメしたいくらいです。とても簡単な言語なので、これからもどんどん使って色々やってみたいなと思います。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>例えば、yumで問題が発生しています。これはyumの実行環境を変える方法(/usr/bin/yumの設定を参照してください)もありますが、どれがPython2を使うかいちいち確認はできないのであまりおすすめしたくはない方法です。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>特に最後の方の&lt;code>ET.register_namespace()&lt;/code>がないと、名前空間が勝手に変わってしまいます。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>JenkinsでJarファイルをデプロイする</title><link>https://retheviper.github.io/posts/jenkins-java-deploy/</link><pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jenkins-java-deploy/</guid><description>&lt;img src="https://retheviper.github.io/images/jenkins.webp" alt="Featured image of post JenkinsでJarファイルをデプロイする" />&lt;p>今回のポストではビルドしたJarファイルをデプロイするJobを作りたいと思います。デプロイといっても、実際このポストを書くきっかけとなったタスクは単純です。&lt;a class="link" href="../../../05/30/jenkins-javabuild" >前回のポスト&lt;/a>のようなJobで生成したJarファイルを違うサーバに転送して実行するだけです。これを繋いで一連の作業にした方が良いのではと思ったのですが、どうやらプロジェクトの設計はそうではなかったみたいです。理由は各サーバの利用目的が違うから、らしいです。&lt;/p>
&lt;p>ともかく、JarファイルをSSHで転送するJobを作ります。もうすでにJarファイルをビルドするJobを作りましたので、そちらのソースを利用します。&lt;/p>
&lt;h2 id="成果物の確保">成果物の確保
&lt;/h2>&lt;p>まずJarファイルをどうやって新規Jobのワークスペースに持ってくるかを考えたいですね。単純には、前回生成したJobにビルドの後、シェルコマンドでファイルをコピーするようなタスクを追加することを考えられます。実際仕事でも一番最初に試した方法でもあります。&lt;/p>
&lt;p>でもファイルのパスやJarファイルの名称などが変わったりするとコマンドの修正が必要となりますし、あまりスマートな方法だとは思えません。なので今回はプラグインによる方法を使いたいと思います。Jenkinsのメイン画面から順番に&lt;code>Manage Jenkins&lt;/code>、&lt;code>Manage Plugins&lt;/code>をクリックしてプラグインのインストール画面に移動します。そして&lt;code>Availale&lt;/code>をクリックした後、右上の&lt;code>Filter&lt;/code>に&lt;code>Copy&lt;/code>を入力します。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactInstall.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactInstall_hu_23f421bea89a8080.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactInstall_hu_a448289bf1c8896.webp 1024w"
loading="lazy"
alt="Jenkins Artifact Install"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>&lt;code>Copy Artifact&lt;/code>というプラグインがリストに出ることを確認できます。これをチェックし、インストールします。なるべくプラグインのインストールやアップデートをした後にはJenkinsを再起動するようにしましょう。再起動中には以下のような画面が現れます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_restart.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_restart_hu_b6fc8c6e0ac4b3a1.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_restart_hu_b79d80d8498bcf5b.webp 1024w"
loading="lazy"
alt="Jenkins Restart"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>ターミナルから直接&lt;code>service jenkins restart&lt;/code>というコマンドを入力することでも再起動はできますが、プラグインのインストールとアップデートの後のオプションでもできます。再起動の後には自動的に元の画面に戻ります。&lt;/p>
&lt;p>再起動が終わり、無事プラグインがインストールされたらちゃんとJobからプラグインを使えるようになったか確認してみます。まずこのプラグインはJobが終わったあと成果物を指定して保存するように設定できます。またそうやって保存された成果物は他のJobから利用できるようにワークスペースにコピーすることができます。なのでまずはコピー元となるJobに成果物を保存するための工程を追加しましょう。&lt;/p>
&lt;p>前回作成した&lt;code>JavaBuild&lt;/code>のJobの設定に入り、&lt;code>Post-build actions&lt;/code>タブから&lt;code>Archive the artifacts&lt;/code>を選択します。そして保存したい成果物の経路を入力します。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactpost.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactpost_hu_73ccdfa2f3b86d5d.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactpost_hu_181c21e4563a7bdb.webp 1024w"
loading="lazy"
alt="Jenkins Artifact Post"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>Jobに変更が発生すると保存してチェックです。ビルドしてみないと思い通りに動くかどうかわからないのがJenkinsの数少ない短所の一つではないかと思いますが、それでもチェックは大事ですので。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactpostcheck.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactpostcheck_hu_6d72f842d35dd16f.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactpostcheck_hu_ecd7a30b2157ca3f.webp 1024w"
loading="lazy"
alt="Jenkins Artifact Post Check"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>ちゃんとビルドできました。保存された成果物に関してはJobのメイン画面から確認できます。どんなファイルが保存できたか確認しましょう。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactpostcheck2.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactpostcheck2_hu_10ab21136b7b59a8.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactpostcheck2_hu_c23481ccc2502af7.webp 1024w"
loading="lazy"
alt="Jenkins Artifact Post Check 2"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>狙い通り、ビルドしたファイルだけ保存できました。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;code>*.jar&lt;/code>と指定していますが、それでもビルドされるファイルは一つしかなったので当たり前な結果ですね。ともかくこれでこちらのJobでの設定は終了です。次の作業に移行しましょう。&lt;/p>
&lt;h2 id="成果物を引き継ぐ">成果物を引き継ぐ
&lt;/h2>&lt;p>今回はデプロイ専用として&lt;code>JavaDeploy&lt;/code>というJobを生成してみました。こちらではまず保存した成果物をワークスペースに持ってくる設定が必要ですね。&lt;/p>
&lt;p>Jobの設定画面から&lt;code>Build&lt;/code>のタブに移動し、&lt;code>Add Build Step&lt;/code>をクリックしてみると&lt;code>Copy artifacts from another project&lt;/code>という項目がドロップダウンメニューに現れたことを確認できます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactconfig.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactconfig_hu_c4d7a240927e2fd5.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactconfig_hu_f0289653485b5f2a.webp 1024w"
loading="lazy"
alt="Jenkins Artifact Config"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>&lt;code>Project name&lt;/code>で、他のJob名を選びます。私は前回生成したJob名にしました。&lt;code>Which build&lt;/code>では、指定したJobのどんなビルドから成果物を持ってくるかを指定します。様々なオプションがありますが、&lt;code>Lastest successful build&lt;/code>が良さげではないかと思います。&lt;code>Stable build only&lt;/code>オプションは念のためチェックします。あとはコピー元のファイルパスと、コピー先のパスを指定すればオッケーです。&lt;/p>
&lt;p>コピーしたくないファイルがあれば&lt;code>Artifacts not to copy&lt;/code>に書くといいです。私はビルドしたJarファイルだけをこのJobのワークスペースにコピーするので、以下のように設定しました。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactconfig2.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactconfig2_hu_12ae4bee95b8f7c0.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifactconfig2_hu_1924d9003d102a47.webp 1024w"
loading="lazy"
alt="Jenkins Artifact Config 2"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>ではまたJobをビルドして思い通りになるか試してみましう。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifatccopied.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifatccopied_hu_60bd89bc93123159.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifatccopied_hu_fee648168861bbaa.webp 1024w"
loading="lazy"
alt="Jenkins Artifact Copied"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>無事ビルドが終わり、成果物をコピーされました。&lt;/p>
&lt;p>次にはこの成果物を他の環境に転送することですね。&lt;/p>
&lt;h2 id="成果物を転送する1">成果物を転送する(1)
&lt;/h2>&lt;p>sshによるファイル転送をするには、&lt;code>Publish over SSH&lt;/code>というプラグインが必要です。このプラグインを通じでSSH接続を行い、ファイル転送やリモートでのシェルコマンドが実行できます。プラグインのインストールメニューに移動し、sshでフィルターを指定すると目録からこのプラグインを見ることができます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifatccopied.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifatccopied_hu_60bd89bc93123159.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_artifatccopied_hu_fee648168861bbaa.webp 1024w"
loading="lazy"
alt="Jenkins Arfact Copied"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>プラグインをインストールして、Jenkinsの再起動まで終わったあとは接続先の設定が必要です。Jenkinsの設定から&lt;code>Configure System&lt;/code>に入ると、Publish over SSHの設定項目ができたことを確認できます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_publishoversshserversetting1.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_publishoversshserversetting1_hu_63cb7815ade146ec.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_publishoversshserversetting1_hu_cd37c22de6562ea4.webp 1024w"
loading="lazy"
alt="Jenkins Publish Over SSH Server Setting"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>&lt;code>Key&lt;/code>に公開鍵を入力することでも接続できますが、まだその設定はしてないため普通にIDとパスワードで接続設定を進めます。&lt;code>SSH Servers&lt;/code>の&lt;code>Add&lt;/code>ボタンを押すと、接続先の情報を入力できるフィールドができます。&lt;code>Name&lt;/code>には接続先の自由な名称を書き、&lt;code>Hostname&lt;/code>には実際のIPアドレスやホスト名を書きます。今回、私は自分のmacに接続してみるので(SSH接続できるようなサーバーを持ってないからですが)ルーターでの内部IPとmacのアカウントをそのまま使います。&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>&lt;code>Username&lt;/code>にはIDを入力します。また、パスワード入力で接続するためパスワードを書くフィールドも必要ですね。&lt;code>Advanced&lt;/code>ボタンをクリックし、&lt;code>Use password authentication, or use a different key&lt;/code>をチェックしたあと&lt;code>Passphrase / Password&lt;/code>にパスワードを入力します。またSSH用の基本設定のポートは22となっていますが、こちらもちゃんとポートが開放されているか確認しましょう。必要な情報を全部入力したら&lt;code>Test configuration&lt;/code>ボタンを押すことで接続できるかかチェックできます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_publishoversshserversetting2.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_publishoversshserversetting2_hu_74b3964f1399657f.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_publishoversshserversetting2_hu_76f6e41b698ea243.webp 1024w"
loading="lazy"
alt="Jenkins Publish Over SSH Server Setting 2"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>入力した情報に間違いがないと、&lt;code>Test configuration&lt;/code>を押した後に&lt;code>Success&lt;/code>が出力されます。設定を保存してJobに戻ります。&lt;/p>
&lt;h2 id="成果物を転送する2">成果物を転送する(2)
&lt;/h2>&lt;p>Jobdの設定に入って&lt;code>Build Environment&lt;/code>のタブにいくと、&lt;code>Send files or execute commands over SSH before the build starts&lt;/code>と&lt;code>Send files or execute commands over SSH after the build runs&lt;/code>の項目ができています。今は成果物を格納した後からSSHを開始したいので後者を選択します。もちろん&lt;code>Build&lt;/code>のタブにも&lt;code>Send files or execute commands over SSH&lt;/code>というメニューができるので、こちらで設定しても良いです。&lt;/p>
&lt;p>&lt;code>Name&lt;/code>ではJenkinsの設定から入力したSSH接続先のサーバーを選択します。そして&lt;code>Source files&lt;/code>では転送したいファイルのパスを入力します。あとはオプションですが、&lt;code>Remove prefix&lt;/code>でファイルパスを入力すると入力したところまでのパスが消えます。また、&lt;code>Remote directory&lt;/code>ではどのフォルダにファイルを転送するかを指定できます。&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_transfer1.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_transfer1_hu_ff9765b6e0e133c8.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_transfer1_hu_4d0ef21b27f8d41b.webp 1024w"
loading="lazy"
alt="Jenkins Transfer"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>私の設定はこうです。フォルダを同じく作成したくはないのでファイルのみの設定としました。思い通りになったら、ユーザーのホームフォルダ配下のfromJenkinsというフォルダに転送されるはずです。念の為、転送先のフォルダの権限や所有者もチェックしておきましょう。そしてJobのビルドです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_transfer2.webp"
width="1680"
height="988"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_transfer2_hu_c4b0e50dda8a04da.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_transfer2_hu_7376adce16c63b96.webp 1024w"
loading="lazy"
alt="Jenkins Transfer 2"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="408px"
>&lt;/p>
&lt;p>ビルドは無事成功しました。コンソールを見ると転送に成功したファイルの個数が表示されます。では本当に転送に成功したか、macの方から確認してみます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_transfered.webp"
width="1834"
height="1164"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_transfered_hu_f99f751d0307a090.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_transfered_hu_23a60510b06105cf.webp 1024w"
loading="lazy"
alt="Jenkins Transferred"
class="gallery-image"
data-flex-grow="157"
data-flex-basis="378px"
>&lt;/p>
&lt;p>こちらでも確認できました。これでファイル転送というタスクは成功です。せっかくですのでmacの方からJarファイルを実行してみます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_jar.webp"
width="1834"
height="1154"
srcset="https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_jar_hu_39b4967cf046f84c.webp 480w, https://retheviper.github.io/posts/jenkins-java-deploy/jenkins_jar_hu_80b16188904ff595.webp 1024w"
loading="lazy"
alt="Jenkins JAR"
class="gallery-image"
data-flex-grow="158"
data-flex-basis="381px"
>&lt;/p>
&lt;p>テスト用のデモなので&lt;code>test&lt;/code>という字を出力するだけにしていますが、とにかく見事実行は成功です。今回のポストでのタスクもこれで終わりました。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回はただ単にファイルをコピーする作業を二つ繋げただけですが、ここからは既存のJarファイルの実行を終了し、新しくデプロイされたファイルを起動するなどのJobを作っていくなど連携の方法は色々ありそうです。何もかも応用次第ですからね！このポストを読まれる皆さんもJenkinsで自動化を試し、私以上に応用できることになるといいなと思います。&lt;/p>
&lt;p>それでは、今回はここまで。また初心者向けの情報が集まったら、新しいポストでお目にかかりましょう。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>この画面からはまるでzipファイルになっているようにも見えますが、実際はzipファイルでダウンロードできるという意味です。成果物はちゃんとフォルダの中に元の形で保存されています。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>ただ、スクショにはもしものことなので実際の情報は書いていません。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>基本的にはSSH接続したユーザーのホームディレクトリが基準となります。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>JenkinsでJavaプロジェクトをビルドする</title><link>https://retheviper.github.io/posts/jenkins-java-build/</link><pubDate>Sun, 26 May 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jenkins-java-build/</guid><description>&lt;img src="https://retheviper.github.io/images/jenkins.webp" alt="Featured image of post JenkinsでJavaプロジェクトをビルドする" />&lt;p>今回はJenkinsで一つのJobを生成することまでやりたいと思います。まず前回も書きましたが、私に要求されたタスクは次のようなことです。「GitにSpring Bootのアプリケーションがあるので、それをビルドするJobを作って欲しい」とのこと。リポジトリを覗き、JavaとGradleはインストールしたので早速Jobの生成に取り掛かることにしました。&lt;/p>
&lt;p>今回は当時と似たような環境を作るためにあらかじめSpring Bootプロジェクトを作成してGitにアップロードしています。&lt;/p>
&lt;h2 id="それでjobとは">それでJobとは？
&lt;/h2>&lt;p>Jenkinsを使う理由は、このJobのためです。Jobは&lt;code>自動化されたタスク&lt;/code>で、実行の条件から頻度、タスクの内容を組み込むことができます。例えばGitのリポジトリに誰かがPushしたらJobを実行するように設定できるし、実行したら自動的にGitをPullするように設定できるということです。&lt;/p>
&lt;p>なのでJenkinsをサーバ上で起動しておいて、必要に応じてJobを組んでおけば大変手間が省けるという話は全てこのJobのおかげだと言えます。今回はこのJobの生成の手順から説明しましょう。&lt;/p>
&lt;h2 id="jobを生成する">Jobを生成する
&lt;/h2>&lt;p>Jenkinsのメインページに入ります。何もJobがない状態なので、メイン画面に&lt;code>create new jobs&lt;/code>というリンクがあることを確認できます。Jobが無い場合はこちらでもJobを生成することができます。しかし何かしらのJobがある場合は、左のメニューで&lt;code>New item&lt;/code>をクリックすれば新しいJobの生成画面に移行します。どちらかをクリックします。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_mainpage.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_mainpage_hu_b472cb8b8b4c97ce.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_mainpage_hu_9c8dcae304c3b4ff.webp 1024w"
loading="lazy"
alt="Jenkins Mainpage"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>&lt;code>Enter an item name&lt;/code>でJobの名前を指定します。また、下にはどんなJobを生成するかに対するいくつかのテンプレートがあります。ここでは&lt;code>Freestyle project&lt;/code>を選びます。ちなみに、Job生成時に指定した名前と同じ名のフォルダがJenkinsの&lt;code>Workspace&lt;/code>というフォルダの下に生成されるので、なるべく半角英文字・スペースなしで生成することをお勧めします。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_createjob.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_createjob_hu_35fc987227341c3e.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_createjob_hu_2f18519811fd1477.webp 1024w"
loading="lazy"
alt="Jenkins Create Job"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>Jobの名前とテンプレートを選んだなら、&lt;code>Ok&lt;/code>を押してJobを生成します。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_jobmain.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_jobmain_hu_ab4bb0931080787c.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_jobmain_hu_94a27cd869690be2.webp 1024w"
loading="lazy"
alt="Jenkins Job Main"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>ここがJob設定のメイン画面です。画面の最上段にある各タブの機能は以下のようになります。&lt;/p>
&lt;ul>
&lt;li>&lt;code>General&lt;/code>: Job全般の設定。Jobの説明を記述したり（どんなタスクなのかなど）、ビルド&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>時以前のビルドを削除するかなどの設定ができます。&lt;/li>
&lt;li>&lt;code>Source Code Management&lt;/code>: バージョン管理に関する設定です。GitとSubversionに対応しています。今回はGitを使うことになりますね。&lt;/li>
&lt;li>&lt;code>Build Triggers&lt;/code>: Jobをどう実行するかに対するトリガーの設定です。リモートからURLを通じた実行になるか、定期的に実行するかなどの設定ができます。&lt;/li>
&lt;li>&lt;code>Build Environment&lt;/code>: Jobのビルド時に使われる環境に関しての設定です。基本的にJobはWorkspaceという空間を占め、ビルド時に使われたファイルなどは全てそのフォルダに保存されます。基本パスは&lt;code>/var/lib/jenkins/workspace/[生成したJobの名前]&lt;/code>となります。&lt;/li>
&lt;li>&lt;code>Build&lt;/code>: Jobのビルド時のアクション（タスク）を指定します。ここで主な処理が行われます。&lt;/li>
&lt;li>&lt;code>Post-build Actions&lt;/code>: Jobのビルドが終わった後に遂行するアクションを指定します。他のJobをビルドするなどの行動が指定できます。&lt;/li>
&lt;/ul>
&lt;p>各タブはどんなプラグインをインストールしたかによって指定できる動作の項目が増えることがあります。また違うポストで扱うかもしれませんが、例えば&lt;code>Publish over SSH&lt;/code>という&lt;/p>
&lt;h2 id="gitのレポジトリを設定">Gitのレポジトリを設定
&lt;/h2>&lt;p>それでは本格的に今回のタスクを作ってみましょう。まずGitからJavaのコードを持ってくる必要があるので、&lt;code>Source Code Management&lt;/code>からGitを選択します。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitconfigure.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitconfigure_hu_e40a306ff8a274f1.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitconfigure_hu_2d534d1867fb78.webp 1024w"
loading="lazy"
alt="Jenkin Git Config"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>&lt;code>Repository URL&lt;/code>にはGitのリポジトリを入力します。最初何も入力されてない時は接続エラーが出ていますが、URLを入力すると自動的にリポジトリへの接続を試し、問題がないとエラーは消えます。また、&lt;code>Credentials&lt;/code>から接続するIDなどの認証情報を選択します。最初は何もないので、&lt;code>Add&lt;/code>をクリックし新しい認証情報を入力しましょう。&lt;/p>
&lt;p>今の所、私の作ったリポジトリはブランチが一つしかないのですが、もし特定のブランチだけをPullしたい場合は&lt;code>Branches to Build&lt;/code>のフィールドにブランチ名を入力することで指定できます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitcredential.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitcredential_hu_94b861929710014c.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitcredential_hu_f720d2fa409480e3.webp 1024w"
loading="lazy"
alt="Jenkins Git Credential"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>他はデフォルト値で、GitのIDとパスワードだけを入力して&lt;code>Add&lt;/code>を押せば終了。こちらで入力した認証情報は全域設定なので、他のJobでも使えます。&lt;/p>
&lt;p>認証情報まで無事入力ができたら、&lt;code>Save&lt;/code>を押して一旦作業を保存しましょう。そうすると、以下のような画面に戻ります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_jobsaved.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_jobsaved_hu_2aa29c0cf2a107ae.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_jobsaved_hu_d85c24c2a5c059c3.webp 1024w"
loading="lazy"
alt="Jenkins Job Saved"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;h2 id="ビルドしてみる1">ビルドしてみる(1)
&lt;/h2>&lt;p>これまででGitからPullするというタスクの設定は終わっています。ちゃんとタスクが意図通りに動作するかを検証するため、ビルドしてみましょう。左のメニューから&lt;code>Build now&lt;/code>をクリックすると、しばらくして左下の&lt;code>Build History&lt;/code>という領域に初めてのビルドが表示されることを確認できます。&lt;code>#1&lt;/code>の所に青い丸が付いていたらビルドが成功したという意味です。不安定だったら黄色、失敗だと赤の丸がつくのでビルドの状態を確認できます。&lt;/p>
&lt;p>ビルドに成功したら、&lt;code>#1&lt;/code>をクリックしてビルドの詳細を確認します。以下のような画面が現れます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitjob1.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitjob1_hu_12947c3ddb0df519.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitjob1_hu_f970a53afa284677.webp 1024w"
loading="lazy"
alt="Jenkins Git Job"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>実際のビルドでどんな処理が行われたかを確認するには、左のメニューから&lt;code>Console Output&lt;/code>をクリックします。Linuxのコンソールのような画面で表示されます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitjob2.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitjob2_hu_7b6c0905c2565e85.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitjob2_hu_9f57b368d5d2e3b0.webp 1024w"
loading="lazy"
alt="Jenkins Git Job 2"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>ちゃんと指定した通り、Gitのリポジトリ（ブランチはマスター）からPullしてきたことを確認できます。コミットメッセージまで出力してくれてますね。&lt;/p>
&lt;p>Linuxのコンソールから&lt;code>/var/lib/jenkins/workspace/&lt;/code>配下のフォルダを直接確認することもできますが、JenkinsのWebコンソールからもJobのワークスペースを確認することができます。左のメニューで&lt;code>Back to Project&lt;/code>をクリックし、&lt;code>Workspace&lt;/code>をクリックすると以下のような画面が現れます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitjob3.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitjob3_hu_731caebebce69c81.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_gitjob3_hu_1d4372c94c3711e.webp 1024w"
loading="lazy"
alt="Jenkins Git Job 3"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>実際GitのPullが正しく行われ、フォルダとファイルが生成されたことをこちらで確認できます。&lt;/p>
&lt;h2 id="gradleの設定">Gradleの設定
&lt;/h2>&lt;p>それでは次に、Gradleによるビルドの設定です。歯車のアイコンの付いた&lt;code>Configure&lt;/code>をクリックし、Jobの設定画面に戻ります。GradleでJarファイルをビルドするのが目的なので、GitでPullした後のタスクになりますね。&lt;/p>
&lt;p>&lt;code>Build&lt;/code>のタブに移動し、&lt;code>Add build step&lt;/code>をクリック、ドロップダウンメニューから&lt;code>Invoke Gradle script&lt;/code>を選択します。そして&lt;code>Advanced...&lt;/code>をクリックしましょう。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradleconfigure1.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradleconfigure1_hu_4e856be8b3a15b91.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradleconfigure1_hu_f5566f63f1fc9284.webp 1024w"
loading="lazy"
alt="Jenkins Gradle Config"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>ここで&lt;code>Invoke Gradle&lt;/code>には前回のポストで入れといたGraldeをドロップダウンメニューで選択します。&lt;/p>
&lt;p>そして次に、&lt;code>Use Gradle Wrapper&lt;/code>の下のTasksに&lt;code>bootJar&lt;/code>を入力します。このコマンドで実行可能なJarファイルが生成されます。また、&lt;code>bootJar&lt;/code>コマンドでは&lt;code>build.gradle&lt;/code>のパスを確保する必要があるので（GraldeがWorkspaceのJob名のフォルダで実行されるので、その同じパスに&lt;code>build.gradle&lt;/code>がある場合でないと必須です）下の&lt;code>Build File&lt;/code>にちゃんとパスを書きます。&lt;/p>
&lt;p>もちろんGradleのコマンドではビルドファイルのパスを指定するオプションもあるので、&lt;code>bootJar&lt;/code>だけでなく&lt;code>-b SpringBootDemo/build.gradle bootJar&lt;/code>のようにコマンドを書いても同じくビルドはできます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradleconfigure2.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradleconfigure2_hu_61cf9a19a2f1dffd.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradleconfigure2_hu_ccd263ced53fc38b.webp 1024w"
loading="lazy"
alt="Jenkins Gradle Config 2"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>これでGradleでのビルド設定は終わり。次にGitの時と同じく、検証してみます。&lt;/p>
&lt;h2 id="ビルドしてみる2">ビルドしてみる(2)
&lt;/h2>&lt;p>ビルドの手順もGitの時と変わりません。&lt;code>Build Now&lt;/code> → &lt;code>#2&lt;/code> → &lt;code>Console Output&lt;/code>の手順でビルドのコンソール出力を確認します。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradlebuild.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradlebuild_hu_bed3310da4af2c04.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradlebuild_hu_13980ca0e5d9f107.webp 1024w"
loading="lazy"
alt="Jenkins Gradle Build"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>無事Gradleでのビルドが終わりました。それではJarファイルがちゃんとできたか確認しましょう。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradlebuildjar.webp"
width="1440"
height="838"
srcset="https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradlebuildjar_hu_be911c52bf1b75da.webp 480w, https://retheviper.github.io/posts/jenkins-java-build/jenkins_gradlebuildjar_hu_cef35a447f32e336.webp 1024w"
loading="lazy"
alt="Jenkins Gradle Build JAR"
class="gallery-image"
data-flex-grow="171"
data-flex-basis="412px"
>&lt;/p>
&lt;p>ちゃんと&lt;code>build/libs&lt;/code>フォルダにJarファイルができたことを確認できます。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>Jenkinsでできることはこれだけではありません。ビルド終了後にデプロイのJobを作り、そのJobを実行するように連携もできれば、JUnitとの連携でテストを行えうように設定も可能です。なので今後のポストでは出来上がったJarファイルをテストしデプロイする方法について書きたいと思います。&lt;/p>
&lt;p>また、Jobの設定で&lt;code>Build Environment&lt;/code>タブにある&lt;code>Delete workspace before build starts&lt;/code>というオプションをチェックしておくのも良いと思います。Jobの実行時にWorkspaceフォルダをまず掃除してからタスクを実行していきますが、これによって前回のビルドで生成されたファイルによる異常動作を防げられますので。&lt;/p>
&lt;p>仕事で触れた部分が少ないのでまだ私も全部の機能を試した訳ではありませんが、Jenkinsは各種プラグインとその組み合わせによって可能性は無限大に違いのではないかと思うくらい良いツールです。また色々研究したいものですね。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>JenkinsのJobにおいてのビルドは、Jobのバージョンに近いイメージです。特定時点のJobを設定〜実行までの単位をビルドと言います。Javaのビルドとは少し違う概念なので混同しないようにしましょう。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>知っていれば便利なLinuxのコツ</title><link>https://retheviper.github.io/posts/linux-command-tips/</link><pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/linux-command-tips/</guid><description>&lt;img src="https://retheviper.github.io/images/linux_terminal.webp" alt="Featured image of post 知っていれば便利なLinuxのコツ" />&lt;p>小学校の頃初めてMS-DOSに触れ、その後ずっとWindowsのPCを使っていたので私はLinuxにそう詳しくないです。&lt;code>CLI&lt;/code>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>には&lt;code>GUI&lt;/code>とは違う感性があると思っていたくらいです。初めてCentOSを仮想マシンでインストールして見たときも、「あ、DOSに似ている」くらいの印象しかなかったです。でも仕事で使いながら思ったより便利ではやいと思いました。さすがサーバーで人気ナンバーワンのマケットシェアを誇るだけはあるんだなと思うくらいです。&lt;/p>
&lt;p>それで、今回は&lt;code>cd&lt;/code>や&lt;code>mkdir&lt;/code>のような基礎の中の基礎しか知らない私が仕事で肩ごしで学んだコツをいくつか書こうと思います。これも基礎ですが、実際使ってみないとわからないだろうなと思っていたことが多く、コマンドやショートカットは本当に使い方次第だなと思ったのでその整理のためでもあります。&lt;/p>
&lt;h2 id="tabキーで自動補完">tabキーで自動補完
&lt;/h2>&lt;p>&lt;code>GUI&lt;/code>に比べ&lt;code>CLI&lt;/code>が難しいと思われる理由は、何よりもコマンドの入力がベースになっているからと思います。ファイルを元のフォルダから違うフォルダに移動するという単純な動作も、GUIではマウスでドラッグすればいいだけのものをCLIではいちいちコマンドを打ちます。そもそも&lt;code>mv&lt;/code>のようなコマンドを知っていなければ成立できないことで、コマンドのオプションでまったく違う結果になったりもしますね。そして何よるも面倒なことは、ファイルやフォルダのパスをいちいち入力しなければならないということです。&lt;/p>
&lt;p>そしてそれが不便と思ったのは多分私だけじゃなかったみたいです。いつから存在していたのかわからないショートカットですが、なんとtabを押すことで自動補完ができるのでした。これなら長いアルファベットでも、スペースが含まれていても大丈夫です。tabでの自動補完は以下のように動作します。&lt;/p>
&lt;ol>
&lt;li>ファイルやフォルダ名を入力する&lt;/li>
&lt;li>書いている途中でtabキーを押す&lt;/li>
&lt;li>自動補完でファイルやフォルダ名が完成&lt;/li>
&lt;li>２つ以上のファイルやフォルダがある場合はリストを出力&lt;/li>
&lt;/ol>
&lt;p>例えば &lt;code>/home/retheviper/task01&lt;/code>というフォルダに移動するとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>cd h &lt;span style="color:#75715e"># ここでtab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd home/ &lt;span style="color:#75715e"># 自動補完される&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd home/r &lt;span style="color:#75715e"># ここでtab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd home/retheviper/ &lt;span style="color:#75715e"># 自動補完される&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd home/retheviper/t &lt;span style="color:#75715e"># ここでtab&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>task01 task02 task03 &lt;span style="color:#75715e"># tから始まるフォルダが複数存在しているのでリストを出力する&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>かなり便利なショートカットなので覚えておきたいコツです。&lt;/p>
&lt;h2 id="フォルダ移動と目録の出力関連コマンド">フォルダ移動と目録の出力関連コマンド
&lt;/h2>&lt;p>現在のフォルダに何が入っているかをみるコマンドは&lt;code>ls&lt;/code>や&lt;code>ll&lt;/code>などがありますね。このコマンドにもう少しコマンドを付け加えることで違うフォルダの内容も出力できます。当たり前なことですが、同じような動作をするために私が主に使っていた方式はこうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 現在のフォルダの内容を確認&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ll
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># /varフォルダがあったため、その中を覗く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd var
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ll
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># スタート時点より上のフォルダがみたい&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd ..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd ..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ll
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし少しの応用でフォルダを変更せずにも違うフォルダを覗くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 絶対経路を使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ll /var/lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 下のフォルダを覗く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ll ./lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ll lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 上のフォルダを覗く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ll ../
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># さらに上のフォルダを覗く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ll ../../
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他には、パスが長くて以前の位置に戻るのに時間がかかる場合は、簡単に戻ることもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 長いパスのフォルダの中にいる状態&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pwd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/jenkins/workspace/job01/git_repository/git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># また長いパスで全く違う経路のフォルダに入る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd /home/retheviper/todo/task01/awesomeblog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pwd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/home/retheviper/todo/task01/awesomeblog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 以前のフォルダに戻りたい&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cd -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pwd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/var/lib/jenkins/workspace/job01/git_repository/git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、&lt;code>cd -&lt;/code>を使ってフォルダを移動する場合は直前の経路だけに戻れないので注意してください。2回連続で入力すると２つのパスだけを繰り返して往復することになります。&lt;/p>
&lt;h2 id="ファイル同期ができるrsyncコマンド">ファイル同期ができるrsyncコマンド
&lt;/h2>&lt;p>Linuxでのファイルコピーは、&lt;code>scp&lt;/code>がもっとも多く使われているようです。でも&lt;code>rsync&lt;/code>コマンドの方がより効率的であるので私はこちらをオススメしたいです。&lt;code>rsync&lt;/code>は単純にファイルをコピーするだけでなく、フォルダやファイルの同期ができます。リモートのフォルダーを同期したい場合も公開鍵による認証を入れておけば、パスワードなしでコピーできるというところがまたいいです。&lt;/p>
&lt;p>また、同期ができるということは差分を見つけ出すことも可能ということです。すでにコピー先にファイルがあるときはコピー元のファイルを比較し、差分だけを転送するので性能がよりいいです。また、コピー元でファイルが消されている場合はオプションでコピー先のファイルも消すことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># フォルダを同期する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ rsync origin destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># コピー元から消されたファイルはコピー先でも消す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ rsync --delete origin destination
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、他のコマンドでもそうですが、rsyncでコピーの対象を指定するときは&lt;code>/&lt;/code>の有無がかなり重要です。&lt;/p>
&lt;p>例えばコピー元のフォルダを指定するとき&lt;code>folder&lt;/code>のように書くとそのフォルダごとコピーされますが、&lt;code>folder/&lt;/code>のように指定するとフォルダの下が対象となります。そしてコピー先のフォルダに権限がなかったり所有者名が違うとコピーできないどでご注意を。権限は&lt;code>chmod&lt;/code>、所有者は&lt;code>chown&lt;/code>で変えられます。&lt;/p>
&lt;p>また、同期したいフォルダに消してはならないフォルダーがある場合は、オプションで指定することもできます。&lt;code>--exclude='folder'&lt;/code>というオプションを入れることで、指定したフォルダーは同期の対象から外されます。このオプションはコピー元からでもコピー先からでも適用されるので、便利ですね。&lt;/p>
&lt;h2 id="システムのスペックと状態を見る">システムのスペックと状態を見る
&lt;/h2>&lt;p>仕事で性能テストがあって、特定作業でサーバーのシステム状態をモニタリングする必要がありました。まずサーバーのマシンスペックから確認したいですね。/procフォルダにカーネルで使われる情報が集まっているらしいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># CPUの詳細情報を見る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ less /proc/cpuinfo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># メモリーの詳細情報を見る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ less /proc/meminfo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>リアルタイムでCPUやメモリーの使用量をみたい場合は&lt;code>vmstat&lt;/code>を活用します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 現在のステータスを出力する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ vmstat
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># メモリーの使用量を出力する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ vmstat -s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># ディスクの活動を出力する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ vmstat -d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 1秒単位で更新しながら出力する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ vmstat &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>メモリーとディスク、CPUの使用量をモニタリングできるため覚えておきたいコマンドですね。&lt;/p>
&lt;h2 id="長い出力を少しづつ見たい">長い出力を少しづつ見たい
&lt;/h2>&lt;p>&lt;code>ls -al&lt;/code>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>などのコマンドでとある内容を出力する場合、リストが多すぎて画面に全部表示されない場合があります。こういうときは&lt;code>more&lt;/code>コマンドで出力がターミナルを全部満たした場合、エンターキーを押すことで次のリストを表示することになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ls -al | more
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この他にも色々と覚えておくと便利なコマンドやショートカットはたくさんありそうですね。こういうのがLinuxの魅力ではないかとも思います。使えば使うほどLinuxが好きになるかも。&lt;/p>
&lt;p>それでは、今回のポストはこれにて。私のようなLinux初心者の方が実戦で応用できるような知識になればなと思います。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>私はどっちかというとCUIという言葉に慣れていますが（Character User Interfaceとかの略だと思っていたので）、正確な名称はCommand Line Interfaceの略であるCLIらしいですね。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>&lt;code>ll&lt;/code>は&lt;code>ls -l&lt;/code>のショートカットらしいです。同じ文字を2回入力するだけでも大体の内容を出力してくれるので便利ですね。ただ、&lt;code>ls -al&lt;/code>では隠されているファイルやフォルダも表示してくれます。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Jenkinsで何もかも楽にしたい(3)</title><link>https://retheviper.github.io/posts/jenkins-automation-3/</link><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jenkins-automation-3/</guid><description>&lt;img src="https://retheviper.github.io/images/jenkins.webp" alt="Featured image of post Jenkinsで何もかも楽にしたい(3)" />&lt;p>仕事でJenkinsを使って、自動化したいと言われたのはいくつかのタスクがあります。そしてそのタスクを実行するにもまたいくつかの手順が入りますね。こんなことがしたいという想像力ももちろん大事なものですが、何かをするにはそれに必要な環境を整えることが何よりも大事なのではないかと思います。今回のポストでは仕事で与えられた作業と、それを準備した過程を述べたいと思います。&lt;/p>
&lt;p>まずGitからSpring bootアプリケーションをPullしてきて、ビルドすること。まず私はSpring Framework&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>は扱ってみたことがありますが、Spring Bootは今回が初めてでした。そしてMavenは使ったことがあるものの、今回のようにGradleを使ったプロジェクトには触れたことがなかったです。Spring Bootが（そしてGradleが）以前と比べ初期設定が簡単とは言われていますが、Eclipeの上でしかアプリケーションを実行した経験しかないので、最初はどうやったらいいかイメージすらなかったです。&lt;/p>
&lt;p>そしてJenkinsでどのようにJobを構成すればいいかもわからなかったので、まずJenkinsでどのようにJobを構成し自動化ができるかを調べることから始めました。&lt;/p>
&lt;p>Jenkinsでは、Jobという名称のタスクを作り、とある行動を中に仕組み、それを一つの単位として実行することができます。全てのプログラムがそうでありますが、Linuxでのシェルスクリプトみたいに、繰り返す必要のある行為を自動化するようなものです。そして出来がったJobは手動実行するか、条件（トリガー）を指定して実行するようになります。&lt;/p>
&lt;p>今回のタスクを振り返ってみましょう。JavaアプリケーションがGitにあります。それをPullし（Jenkinsが実行されているサーバにソースコードを持ってきて）、ビルド（実行可能なパッケージにする）する。これでJenkinsは最新のソースコードを確保しつつ、実行可能なアプリケーションをデプロイできる状態になります。それではまず必要な道具はJDKとGradleです。&lt;/p>
&lt;h2 id="openjdkをインストールしましょう">OpenJDKをインストールしましょう
&lt;/h2>&lt;p>まずJenkinsはJava８でも実行できますが、今回のアプリケーションはなんとJava11を使っていました。OpenJDK11&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>をインストールします。&lt;code>yum install java&lt;/code>をするとOracleのJavaがインストールされるので、OpenJDKをインストールしたい場合はまた少しの手順が必要となります。今回はwgetではなく、curlを使ってみます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -O https://download.java.net/java/GA/jdk11/13/GPL/openjdk-11.0.1_linux-x64_bin.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>curl -OはURLからファイルをダウンロードして保存するということです。ダウンロードしたファイルは圧縮されているので解凍します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>tar zxvf openjdk-11.0.1_linux-x64_bin.tar.gz
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>tarは圧縮したり解凍するとき使うコマンド。zは.gzファイルを、xは圧縮ファイルの展開、vは処理したファイルを表示、fはこのファイルを指定するという意味らしいです。解凍が終わったらファイルを適切な場所に格納しましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mv jdk-11.0.1 /usr/local/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に簡単なシェルスクリプトを書きます。Linuxでの環境変数を設定するためです。まずviやvimでファイルを作りましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>vi /etc/profile.d/jdk11.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>iを押して以下の内容を書きます。Javaを格納したパスを確認してください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export JAVA_HOME&lt;span style="color:#f92672">=&lt;/span>/usr/local/jdk-11.0.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:$JAVA_HOME/bin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>esc⇨:wqで保存と終了。そしてすぐシェルスクリプトを今の状態に適用させます。sourceコマンドを使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>source /etc/profile.d/jdk11.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでOpenJDK11は準備されました。私はCentOS7を使っているのですが、ubuntuなどの違うLinuxではまた手順も色々あるようです。とにかくインストールがちゃんと終わっているか&lt;code>java -version&lt;/code>で確認してみましょう。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_java8.webp"
width="894"
height="619"
srcset="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_java8_hu_59562312e3d382c1.webp 480w, https://retheviper.github.io/posts/jenkins-automation-3/jenkins_java8_hu_436a6f8c55aaf373.webp 1024w"
loading="lazy"
alt="Java version is 8"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>あれ？Javaのバージョンが8です。すでにインストールされていたんですね。&lt;/p>
&lt;h2 id="使いたいjavaのバージュヨンを切り替える">使いたいJavaのバージュヨンを切り替える
&lt;/h2>&lt;p>すでに違うバージョンのJDKがインストールされた場合は、次の手順で使いたいJavaのバージョンを選択できます。
まず新しくインストールしたJavaを選択できるよう登録します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>alternatives --install /usr/bin/java java $JAVA_HOME/bin/java &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>登録が終わったら、以下のコマンドで現在登録されているJavaを表示します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>alternatives --config java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CentOSインストール時にすでに二つのバージョンのJavaがインストールされてましたね。Java11が3番目になったので3を入力します。これでJavaは準備オッケーです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_alter.webp"
width="894"
height="619"
srcset="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_alter_hu_1db65fa0a2914a1c.webp 480w, https://retheviper.github.io/posts/jenkins-automation-3/jenkins_alter_hu_b17fb077cf90aa55.webp 1024w"
loading="lazy"
alt="Jenkins Alter"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>ちなみに、JenkinsもまたJavaで作られているので場合によってはJava11のJVMで起動できます。Java11のJVMをJenkinsに登録するには以下の手順になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>vi /etc/init.d/jenkins
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Jenkinsの設定ファイルです。candidatesという部分に様々なバージョンのJVMの経路が機材されていますので、ここにOpenJDK11のbinフォルダのパスを追加します。esc⇨:wqで終了！&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_jvm.webp"
width="894"
height="619"
srcset="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_jvm_hu_c375a19f36f7f7fe.webp 480w, https://retheviper.github.io/posts/jenkins-automation-3/jenkins_jvm_hu_a14e171fb2ff7502.webp 1024w"
loading="lazy"
alt="Jenkins JVM"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;h2 id="gradleもインストールしよう">Gradleもインストールしよう
&lt;/h2>&lt;p>次にGradleをインストールします。macOSでは&lt;code>brew install gradle&lt;/code>で簡単にインストールできましたが、LinuxではどうもまたOpenJDKと同じ手順が必要なようです。wgetをまた使ってみます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>wget https://services.gradle.org/distributions/gradle-5.4.1-bin.zip -P /tmp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>-Pオプションをつけると指定したフォルダにファイルを保存します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo unzip -d /opt/gradle /tmp/gradle-5.4.1-bin.zip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>zipファイルンなので、unzipコマンドで解凍します。-dもまたフォルダ（ディレクトリ）を指定するオプションです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo nano /etc/profile.d/gradle.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回はnanoを使ってスクリプトを作ってみます。よりGUIに近い感じがしますね。nanoがなければ&lt;code>yum install nano&lt;/code>でインストールしてもいいし、viを使っても良いです。&lt;/p>
&lt;p>私はどこでも使えるということ（環境によってはsudoの権限があるとしても、勝手に色々インストールできない場合もあるので)からviを使うことが多いですが、nanoはより直観的で使いやすいと思います。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-3/gradle_sh.webp"
width="894"
height="619"
srcset="https://retheviper.github.io/posts/jenkins-automation-3/gradle_sh_hu_9bd6d7a83c7c0aa7.webp 480w, https://retheviper.github.io/posts/jenkins-automation-3/gradle_sh_hu_c2b313ba6cc935ae.webp 1024w"
loading="lazy"
alt="Gradle SH"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>添付の画像のように、以下の内容を入力します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export GRADLE_HOME&lt;span style="color:#f92672">=&lt;/span>/opt/gradle/gradle-5.4.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>GRADLE_HOME&lt;span style="color:#e6db74">}&lt;/span>/bin:&lt;span style="color:#e6db74">${&lt;/span>PATH&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>nanoではctrl+xを押すと編集した内容を保存するかを聞いてきます。Yのあとエンターを押すと保存。US標準のキーボードを使う私にとっては:wqより入力が簡単で好きです。&lt;/p>
&lt;p>あとは作られたスクリプトに実行の権限を与え、&lt;code>source&lt;/code>コマンドで環境変数として登録。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo chmod +x /etc/profile.d/gradle.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ source /etc/profile.d/gradle.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>chmod 755のようなコマンドを書いたことが多いですが、+xで実行の権限だけ与える方が習慣的には良さそうですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gradle -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インストールに成功したかを確認するにはやはりバージョンの確認ですね。以下のような画面が表示されたらGradleのインストールも成功です。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-3/gradle_version.webp"
width="894"
height="619"
srcset="https://retheviper.github.io/posts/jenkins-automation-3/gradle_version_hu_8b899efa6aef3c50.webp 480w, https://retheviper.github.io/posts/jenkins-automation-3/gradle_version_hu_1abeb2a237855048.webp 1024w"
loading="lazy"
alt="Jenkins Gradle Version"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>最新のバージョンではSwift5をサポートするようですね。こちらもいつか扱いたいと思います。&lt;/p>
&lt;p>それではいよいよJenkinsに戻り、JenkinsにJDKとGradleを環境として登録します。&lt;/p>
&lt;h2 id="jenkinsにjdkとgradleをつなげる">JenkinsにJDKとGradleをつなげる
&lt;/h2>&lt;p>やっとJenkinsに戻りました。もうこれがJenkinsのポストかLinuxのポストカわからないくらいになっていましたが、とにかく戻ってきました。&lt;/p>
&lt;p>ウェブブラウザに&lt;code>localhost:Jenkinsのポート番号&lt;/code>を入力してJenkinsのメイン画面に入ります。その後は、左のメニューから&lt;code>Manage Jenkins&lt;/code>をクリックします。そうすると以下のような画面が現れます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_manage.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_manage_hu_582be7486c5b4c7.webp 480w, https://retheviper.github.io/posts/jenkins-automation-3/jenkins_manage_hu_f8027b7c0c4d263c.webp 1024w"
loading="lazy"
alt="Jenkins Manage"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>&lt;code>Global Tool Configuration&lt;/code>を押します。ここがJenkinsで使われる環境変数的なものを設定する画面です。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_globaltoolsettings.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_globaltoolsettings_hu_7f4100b151c4a03.webp 480w, https://retheviper.github.io/posts/jenkins-automation-3/jenkins_globaltoolsettings_hu_90610b3a215184db.webp 1024w"
loading="lazy"
alt="Jenkins Global Tool Settings"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>JDK項目の&lt;code>ADD JDK&lt;/code>を押します。&lt;code>install automatically&lt;/code>というオプジョンが基本的にチェックされていますが、これはOracleのJavaしかインストールできないオプションです。またバージョンに制限があるので（私の場合はJava9までしか設定できませんでした）、チェックを外して&lt;code>JAVA_HOME&lt;/code>にインストールしたJava11のパスをいれます。以下のような感じです。Nameも必要なので適当な文句をいれます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_jdk.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_jdk_hu_bed8a5ba1a68d9a2.webp 480w, https://retheviper.github.io/posts/jenkins-automation-3/jenkins_jdk_hu_4eac676feff6b4ea.webp 1024w"
loading="lazy"
alt="Jenkins JDK"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>次にGradleです。こちらもJavaと同様、自動インストールのオプションがあります。でも我々がインストールしたのよりはバージョンが低いですね。なのでこちらも自動インストールのオプションを外し、パスをいれます。以下のようになります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_gradle.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-3/jenkins_gradle_hu_38bc9351a7aacbb9.webp 480w, https://retheviper.github.io/posts/jenkins-automation-3/jenkins_gradle_hu_52c7931b6b4b004c.webp 1024w"
loading="lazy"
alt="Jenkins Gradle"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>&lt;code>Save&lt;/code>を押して保存することを忘れずに！&lt;/p>
&lt;p>これでJenkinsでのJDKとGradleの設定は終わりです。これからはJavaアプリケーションをビルドできるようになりました。次のポストで実際Spring Bootで作られたアプリケーションをGitでPullし、ビルドするタスクを作ってみたいと思います。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>厳密には、Spring Frameworkというよりは旧バージョンと言えるでしょう。Spring BootはSpring Frameworkに含まれるものなんですからね。いつかSpring Bootに関しても勉強したいと思うので、機会があればポストしたいと思います。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>現在はJava12まで出ていますが、JenkinsでJava11をサポートし始めたのも最近のことなので（2019年３月）、まずJava 11を選びました。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Jenkinsで何もかも楽にしたい(2)</title><link>https://retheviper.github.io/posts/jenkins-automation-2/</link><pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jenkins-automation-2/</guid><description>&lt;img src="https://retheviper.github.io/images/jenkins.webp" alt="Featured image of post Jenkinsで何もかも楽にしたい(2)" />&lt;p>前回から続きます。Jenkinのインストールが終わったら、初期設定の番です。どんなことでも始めが一番面倒なものですが、それだけ初期設定をちゃんとやっていると後の作業が楽になるものですね。なので今回はJenkinsの初期設定に関してまず述べたいと思います。&lt;/p>
&lt;p>Jenkinsの初期設定はだいたい以下の順になります。他にも色々しておいたら便利な設定があるかもしれませんが、あくまで初心者の私の観点が基準なので参考までにしてください。&lt;/p>
&lt;h2 id="ポートの設定">ポートの設定
&lt;/h2>&lt;p>Jenkinsの基本ポートは&lt;code>8080&lt;/code>です。このままJenkinsを起動すると、Webブラウザから&lt;code>Jenkinsを起動中のシステムのIPアドレス:8080&lt;/code>でJenkinsに接続できます。&lt;/p>
&lt;p>しかし、Webアプリケーションを開発してみた経験のある方には8080というポートはあまり良い選択肢ではないことがわかるはずです。同じポートに設定されている二つ以上のサービスが問題を起こす可能性がありますからね。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>私はのちにTomcatを使うことがあるかもしれないと思い、Jenkinのポートは&lt;code>8088&lt;/code>に変えました。&lt;code>vi&lt;/code>や&lt;code>vim&lt;/code>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>でJenkinsのシステムコンフィグファイルを開けます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo vim /etc/sysconfig/jenkins
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そうすると、以下のような画面が現れます。少し下にスクロールしたら&lt;code>JENKINS_PORT&lt;/code>と、親切に書いてあるのが見えますね！&lt;code>I&lt;/code>を押してインサートモードに切り替え、好きなポートに変えましょう。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_configport.webp"
width="974"
height="643"
srcset="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_configport_hu_d3f8ad3c0c5c6da2.webp 480w, https://retheviper.github.io/posts/jenkins-automation-2/jenkins_configport_hu_b30ace423bc9970f.webp 1024w"
loading="lazy"
alt="Jenkins Config Port"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>&lt;/p>
&lt;p>書き換えが終わったら&lt;code>ESC&lt;/code> ⇨ &lt;code>:wq&lt;/code>で保存後終了を忘れずにしましょう。&lt;/p>
&lt;h2 id="起動初期パスワードの設定">起動〜初期パスワードの設定
&lt;/h2>&lt;p>Jenkinsは初起動で初期パスワードを要求します。この初期パスワードが格納されてある位置は、基本的に&lt;code>/var/lib/jenkins/secrets/initialAdminPassword&lt;/code>というパスに保存されるようですが、OSなどの環境によってパスが変わる場合もありますからね。&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>でも、一度Jenkinsを起動したら初期設定のページからパスを確認できるので心配いりません。&lt;/p>
&lt;p>ポート設定が終わったら（8080をそのまま使いたいならそのままでもいいです）、まずJenkinsを起動します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>service jenkins start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>[OK]&lt;/code>というメッセージが出力されるはずですが（ポート設定に問題がある場合もあるので）念の為起動状況を確認します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>service jenkins status
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実は、仕事で１日前は元気だったJenkins先生が、いきなり接続できなくなっていたことがったのです。やはり人は何かよくないことを経験すると、慎重になるものです。&lt;code>Active: active (running)&lt;/code>というメッセージを確認できたら、いよいよJenkinsのページに接続です。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_servicestatus.webp"
width="894"
height="619"
srcset="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_servicestatus_hu_869a37a5c46ae3f8.webp 480w, https://retheviper.github.io/posts/jenkins-automation-2/jenkins_servicestatus_hu_30dc410119962db7.webp 1024w"
loading="lazy"
alt="Jenkins Service Status"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="346px"
>&lt;/p>
&lt;p>&lt;code>Jenkinsを起動中のシステムのIPアドレス:ポーと番号&lt;/code>をWebブラウザに入力してJenkinsのページへ接続します。もちろん、起動中のシステムからは&lt;code>localhost:8080&lt;/code>などでも接続できます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_initpass.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_initpass_hu_d51e3cab82d0bd6d.webp 480w, https://retheviper.github.io/posts/jenkins-automation-2/jenkins_initpass_hu_6b3cac5c18cc33f0.webp 1024w"
loading="lazy"
alt="Jenkins Init Pass"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>やはりパスは&lt;code>/var/lib/jenkins/secrets/initialAdminPassword&lt;/code>でした。ポート設定と同じく、viやvimで中を覗き、そのパスワードを入力します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo vim /var/lib/jenkins/secrets/initialAdminPassword
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="プラグインと管理者アカウントの設定">プラグインと管理者アカウントの設定
&lt;/h2>&lt;p>パスワードの入力に成功するとしばらくして、プラグインの設定画面が現れます。自分でプラグインを選んでも良さそうですが、私は自信がないのでオススメのボタンを押します。当たり前なことですが、プラグインは後ででもインストールできます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_initplugins.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_initplugins_hu_2bdcd21a5545c6b.webp 480w, https://retheviper.github.io/posts/jenkins-automation-2/jenkins_initplugins_hu_ece23031b6a547ae.webp 1024w"
loading="lazy"
alt="Jenkins Init Plugins"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>オススメのボタンを押すと自動的にプラグインのインストールを進めてくれるので、待ちましょう。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_installingplugins.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_installingplugins_hu_e547fdb87943177a.webp 480w, https://retheviper.github.io/posts/jenkins-automation-2/jenkins_installingplugins_hu_e98fa9f429cb7dc6.webp 1024w"
loading="lazy"
alt="Jenkins Installing Plugins"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>プラグインのインストールが終わったら次は管理者アカウントの設定です。一つでも満たしてない項目があったら怒られるので全部書きます。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_setupadmin.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_setupadmin_hu_e8a9ebaaea18aa35.webp 480w, https://retheviper.github.io/posts/jenkins-automation-2/jenkins_setupadmin_hu_49f4d097b5da0679.webp 1024w"
loading="lazy"
alt="Jenkins Setup Admin"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>管理者アカウント設定の次は接続アドレスの設定。私は今のままでいいと思うので（仮想マシンでCentOSをインストールしてJenkinsを動かしています）そのままにします。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_addresssetting.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_addresssetting_hu_20e8bffdfc22c39c.webp 480w, https://retheviper.github.io/posts/jenkins-automation-2/jenkins_addresssetting_hu_ec37ac53972cad12.webp 1024w"
loading="lazy"
alt="Jenkins Address Setting"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>そして、Jenkinsが用意されたという画面が出ます。長かったですね…早速使うというボタンを押します。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_ready.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_ready_hu_2c5bda0f106fec60.webp 480w, https://retheviper.github.io/posts/jenkins-automation-2/jenkins_ready_hu_c3158d1735fe529f.webp 1024w"
loading="lazy"
alt="Jenkins Ready"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>ジャジャーン。ようやくたどり着きました。Jenkinsのメイン画面です。ここまでの旅も本当に長かったですね。それでもJenkinsは強力なツールなので、ここまでする価値があると私は思います。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_mainpage.webp"
width="1280"
height="706"
srcset="https://retheviper.github.io/posts/jenkins-automation-2/jenkins_mainpage_hu_b472cb8b8b4c97ce.webp 480w, https://retheviper.github.io/posts/jenkins-automation-2/jenkins_mainpage_hu_9c8dcae304c3b4ff.webp 1024w"
loading="lazy"
alt="Jenkins Mainpage"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>それでは、次からは具体的にJenkins先生と共にどんなタスク（Job）を作り、実行したかを述べたいと思います。また会いましょう！&lt;/p>
&lt;p>（続きます）&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>特にSpring FrameworkなどでWebアプリケーションを実装する場合にそうですね。Tomcatの基本ポートも&lt;code>8080&lt;/code>になっていますから。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>viとvimのうち、どれを選ぶかはいつも悩ましいことです。vimの方がよりカラフルでコードを読みやすいという点では良いですが、システムによってはインストールされてないですからね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>macOSでインストールしたら、初期パスワードのパスが&lt;code>ユーザホームディレクトリ&lt;/code>の直下だった場合もありました。rootではないユーザでインストールしたからかもしれませんが。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Jenkinsで何もかも楽にしたい(1)</title><link>https://retheviper.github.io/posts/jenkins-automation-1/</link><pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/jenkins-automation-1/</guid><description>&lt;img src="https://retheviper.github.io/images/jenkins.webp" alt="Featured image of post Jenkinsで何もかも楽にしたい(1)" />&lt;p>世の中、なんでも自動化がトレンドのようです。AIの話も究極的には、そういう自動化の範疇に入るようなものではないかと思います。まだ人間がAIに仕事を奪われるような時代になるまではもう少し時間がいるのでは、と思いますがね。&lt;/p>
&lt;p>そういう意味で、&lt;a class="link" href="https://jenkins.io/" target="_blank" rel="noopener"
>Jenkins&lt;/a>について調べました。もちろん、まだ何が何だかわからないひよっ子みたいな自分に「今回はJenkinsで面倒なことは全部自動化して手間を減らそう」みたいな考えがあったわけではなく、あくまで仕事で使われているから、というシンプルな理由です。&lt;/p>
&lt;h2 id="それでjenkinsとは">それで、Jenkinsとは？
&lt;/h2>&lt;p>そもそもJenkinsがどんなものか知りたい。仕事で使うということは、なんらかの理由があるはずです。また、この業界で使われるミドルウェアは、結局何か便利（手間を省ける）な面があるから使われるのでしょうね。ならJenkinsは何が便利で使いたくなるのか？という観点から調べてみました。&lt;/p>
&lt;h3 id="継続的インテグレーション">継続的インテグレーション
&lt;/h3>&lt;p>と言われましても…な気がしました。つまりビルドからテスト、検証などをしてくれるツールらしいです。最初はGitに連動して使うと言われましたので、もうバージョン管理をGitでしているのに、また何かツールを連携して使うメリットがあるのか？と思いましたが、この「継続的インテグレーション」という行動が自動化できるからいいということです。&lt;/p>
&lt;p>GitやSubversionでのバージョン管理をしても、誰がいつPushしたのか、ログを見るまではわからない。また、Pushしたことをわかったら人の手でテストをしてまたMergeするしかない。これがなんとJenkinsで解決できるということです。例えば誰かがPushしたらJenkinsに通知が送られ（これには別作業が要るらしいですが）、Pull・ビルド・JUnitでのテストまでしてくれて、結果を通知してくれるとか。また設定次第ではテストが無事終わったらデプロイ&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>もしてくれるすごいツールらしいです。&lt;/p>
&lt;h2 id="でも使ってみないとわからない">でも使ってみないとわからない
&lt;/h2>&lt;p>それでは早速Jenkinsのすごい自動化を経験するために、インストールから始めます。仕事で使う環境はLinux。すぐyumでインストールできるのではないかなと思いましたが、どうもそうではないようです。&lt;/p>
&lt;p>&lt;a class="link" href="https://jenkins.io/" target="_blank" rel="noopener"
>Jenkinsのホームページ&lt;/a>に接続してみると、Linuxでのインストールの手順がありました。幸い、仕事で使うLinuxはAWSなのですが、RedHat Linux&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>と同じ手順でインストールできました。&lt;/p>
&lt;h2 id="それではインストールしましょう">それではインストールしましょう
&lt;/h2>&lt;p>まず、Jenkinsのリポジトリを持ってきます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでwget -Oはフォルダを読み、ファイルとして出力するオプションらしいですね。ここでも勉強になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rpmはパッケージをインストールする時使うコマンドなのですが、ここでは&amp;ndash;importオプションでキーを持って検証を行いますね。&lt;/p>
&lt;p>ここまで終わったら、普通のパッケージと同じくyumでインストールできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>yum install jenkins
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでインストールは終わり。問題なければ、ポートの設定をやって起動するまでです。&lt;/p>
&lt;p>（続きます）&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>他のサーバなどに配置すること。例えば開発環境と本場環境は分離する必要があるので、開発環境で動作の検証が終わったものを本場環境に置いて実行することになりますね。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>FedoraとCentOSでも同じくできるらしいです。うちではCentOS7で検証してみました。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>はじめに</title><link>https://retheviper.github.io/posts/new-start/</link><pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/new-start/</guid><description>&lt;img src="https://retheviper.github.io/images/tools.webp" alt="Featured image of post はじめに" />&lt;p>まだSEになってからの日が浅いので、業界の動向や流行りの言語はおろか、プログラミングの基礎もまだわからないことが多いです。それでも仕事で学び、覚えられるようなことは多いので、それらの知識をただ頭に入れておくということは無理なのではないかと思います。日々新しい言語、フレームワーク、ライブラリーが登場している中、自分は今までの技術もまともに習得していないのです。それならばせめて、どこかに自分が触れたことのある知識をまとめ参考にしたい。そういう考えからブログを始めることにしました。&lt;/p>
&lt;p>人間の文明の発達の歴史は、記録によるものという話がありました。人類の持つ知識の総量が一人の脳内に収められないくらい膨大になってから、人間が考案した方法は外部媒体による記録であるということです。そのおかげで我々は代々受け継がれてきた知識に触れることができ、最初から知識を持ってなくても臨機応変できるようになったと私は思います。例えば、携帯が生まれてからは誰も人の電話番号を覚えなくなりました。それでも連絡できる人の数はむしろ増えましたね。つまり、知識の外部記録できるようになって、個人が持つ知識の総量よりは、時と場合に適合な知識を探し出す能力が大事な時代になったのではないかと思います。&lt;/p>
&lt;p>プログラミングの世界もそうではないかと思います。bash&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>は依然として強力なツールであり、GUIより便利な時もあります。しかし全てのコマンドを覚え、パスを入力することはあまり効率的ではないです。むしろ必要な時に適切なコマンドを入力できるかどうかの方がより重要なのではないでしょうか。そのためにコマンどを集めたスクリプトが現れ、今の時代は簡単にコピペするだけでその時必要な操作ができたらいいのではないかと思います。&lt;/p>
&lt;p>自分がブログに勉強したことをまとめる時もなるべくそのような使い方ができるようなポストになったらいいなと思います。例えばAというサーバからBというサーバにフォルダをコピーしたいというなら、ただSCPやRSYNCのようなコマンドを書くだけでなくssh認証をはじめとしてSCPとRSYNCの違いまで比べるという一連の流れとしての知識を残す。そのような情報が得られるようなブログになったらいいなと思っています。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Linuxだけに限らず、macOSのterminalやWindowsのPowershellなどを含め&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>