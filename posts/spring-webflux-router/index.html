<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="以前、Spring WebFluxに関するポストを書いたことがあって、そこで少しだけMVCパターン(Controller/Service)とF"><title>WebFluxではFunctional Enpointを使うべきか</title>
<link rel=canonical href=https://retheviper.github.io/posts/spring-webflux-router/>
<link rel=stylesheet href=/scss/style.min.1b3ac667198cb83edcc9c45e606a6f4dd6910b8ada6b74d7fd988f1b2dfd0c7c.css><meta property="og:title" content="WebFluxではFunctional Enpointを使うべきか">
<meta property="og:description" content="以前、Spring WebFluxに関するポストを書いたことがあって、そこで少しだけMVCパターン(Controller/Service)とF">
<meta property="og:url" content="https://retheviper.github.io/posts/spring-webflux-router/">
<meta property="og:site_name" content="Korean-man in Tokyo">
<meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="spring"><meta property="article:tag" content="webflux"><meta property="article:tag" content="kotlin"><meta property="article:tag" content="rest api"><meta property="article:published_time" content="2021-05-30T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-30T00:00:00+00:00"><meta property="og:image" content="https://retheviper.github.io/images/spring.jpg">
<meta name=twitter:title content="WebFluxではFunctional Enpointを使うべきか">
<meta name=twitter:description content="以前、Spring WebFluxに関するポストを書いたことがあって、そこで少しだけMVCパターン(Controller/Service)とF"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://retheviper.github.io/images/spring.jpg">
<link rel=apple-touch-icon sizes=57x57 href=/favicon/apple-icon-57x57.png>
<link rel=apple-touch-icon sizes=60x60 href=/favicon/apple-icon-60x60.png>
<link rel=apple-touch-icon sizes=72x72 href=/favicon/apple-icon-72x72.png>
<link rel=apple-touch-icon sizes=76x76 href=/favicon/apple-icon-76x76.png>
<link rel=apple-touch-icon sizes=114x114 href=/favicon/apple-icon-114x114.png>
<link rel=apple-touch-icon sizes=120x120 href=/favicon/apple-icon-120x120.png>
<link rel=apple-touch-icon sizes=144x144 href=/favicon/apple-icon-144x144.png>
<link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-icon-152x152.png>
<link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-icon-180x180.png>
<link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png>
<link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png>
<link rel=manifest href=/favicon/manifest.json>
<meta name=msapplication-TileColor content="#ffffff">
<meta name=msapplication-TileImage content="/favicon/ms-icon-144x144.png">
<meta name=theme-color content="#ffffff">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-139986442-1','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class="has-image main-article">
<header class=article-header>
<div class=article-image>
<a href=/posts/spring-webflux-router/>
<img src=/../../images/spring.jpg loading=lazy alt="Featured image of post WebFluxではFunctional Enpointを使うべきか">
</a>
</div>
<div class=article-details>
<header class=article-category>
<a href=/categories/spring/ style=background-color:#2a9d8f;color:#fff>
spring
</a>
</header>
<h2 class=article-title>
<a href=/posts/spring-webflux-router/>WebFluxではFunctional Enpointを使うべきか</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>May 30, 2021</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
15 minute read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<p>以前、<a class=link href=../spring-webflux/>Spring WebFluxに関するポストを書いたこと</a>があって、そこで少しだけMVCパターン(<code>Controller</code>/<code>Service</code>)と<code>Functional Endpoint</code>(<code>Router</code>/<code>Handler</code>)に関して触れました。結論だけ先に述べますと、Functional Endpointの導入はMVCパターンは長く使われている良いパターンでありますが、性能や関数型プログラミングには適してないのという問題があるので、それを改善するためのものだといえます。</p>
<p>さて、その説明だけだと、Spring WebFluxを使う際にはなるべくFunctional Endpointを使うべきな気もします。しかし、実際はどうでしょうか？例えば、従来のSpring MVCと同じくController/Serviceを使う場合は本当にRouter/Handlerを使う時と比べ性能が劣るのか？また、Functional Endpointを使う際に考慮すべき、「MVCパターンにはなかった問題」はないか？といったことを考えられます。</p>
<p>なので、今回はその二つのパターンを用いて、Spring WebFluxによるサーバサイドアプリケーションを実装するときに考えたいことを少しまとめてみました。</p>
<h2 id=プログラミングのパラダイムとして>プログラミングのパラダイムとして</h2>
<p>SpringのMVCパターンは、アノテーションによるメタプログラミングとオブジェクト指向といった昔ながらの考え方に基づいたパラダイムに近いといえます。もちろん、AOPやDIといったSpring Framework特有の特徴はありますが、<a class=link href=https://www.reactive-streams.org target=_blank rel=noopener>Reactive Streams</a>の実現体である<code>Mono</code>/<code>Flux</code>で書かれたWebFluxのコードと比べたら、まだ伝統的な書き方に近いという感覚はありますね。</p>
<p>ここでオブジェクト指向と関数型のうち、どれが良いかという議論はしません。また、Javaは元々オブジェクト指向の言語としてデザインされましたが、1.8以降はFunctional Interfaceの導入である程度関数型プログラミングができるようになりましたし、Kotlinでもそれは大きく変わらないことです。なので、Spring MVCとSpring WebFluxのうちどれかを選ぶということがコードをオブジェクト指向として書くか、関数型として書くかという結論にもなりません。</p>
<p>しかし、Spring WebFluxでは、MVCパターンとFunctional Endpointのどれかを選べるという点からして、どちらかのパラダイムに寄せた書き方はできるというのも事実です。ここでどれを取るかを判断するには、コードを書く人同士の合意がもっとも重要なのではないかと思います。なぜかというと、結局プログラミングのパラダイムというものは何よりもプログラミングの「効率」のために発展してきたからです。</p>
<p>なので、ここでの判断基準は「如何に読みやすいか」「如何に早く成果を出せるか」など、実利的なものとなるべきでしょう。例えば、すでにサービスとして機能しているアプリケーションの同時実行性能を向上させたい場合は、MVCパターンとして書いた方がすぐにサービスを立ち上げられるので良いと思ったら、それで理由は十分かと思います。もしくは、すでにFunctional Endpointに慣れているプログラマが多い場合は積極的にそれを導入するとかですね。つまり、私の観点からすると、プログラミングのパラダイムは実務者の立場からすると効率により選択するべきものではないかと思います。</p>
<p>では、Contorller/ServiceのパターンとRouter/Handlerのパターンの実際はどう違うのかを、コードを通じて見ていきたいと思います。</p>
<h3 id=mvcパターンで書く場合>MVCパターンで書く場合</h3>
<p>Spring WebFluxのMVCパターン、つまりContoller/Serviceのパターンは、その名の通り既存のSpring MVCと比べあまり変わらない感覚で書くことができます。なので、例えば以下のようなコードを書くとしたら、これだけではSpring MVCとの違いがあまりわからないくらいですね。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=nd>@RestController</span>
<span class=k>class</span> <span class=nc>HelloController</span><span class=p>(</span><span class=k>private</span> <span class=k>val</span> <span class=py>service</span><span class=p>:</span> <span class=n>HelloService</span><span class=p>)</span> <span class=p>{</span>

    <span class=nd>@GetMapping</span><span class=p>(</span><span class=s2>&#34;/hello&#34;</span><span class=p>)</span>
    <span class=k>fun</span> <span class=nf>hello</span><span class=p>():</span> <span class=n>ResponseEntity</span> <span class=p>=</span> 
        <span class=n>ResponseEntity</span>
            <span class=p>.</span><span class=n>ok</span><span class=p>()</span>
            <span class=p>.</span><span class=n>contentType</span><span class=p>(</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON</span><span class=p>)</span>
            <span class=p>.</span><span class=n>body</span><span class=p>(</span><span class=n>service</span><span class=p>.</span><span class=n>getHello</span><span class=p>())</span>
<span class=p>}</span>

<span class=nd>@Service</span>
<span class=k>class</span> <span class=nc>HelloService</span> <span class=p>{</span>

    <span class=k>fun</span> <span class=nf>getHello</span><span class=p>():</span> <span class=n>String</span> <span class=p>=</span> <span class=s2>&#34;Hello Spring WebFlux&#34;</span>
<span class=p>}</span>
</code></pre></div><p>ただ、Spring WebFluxでは、DB接続を含め完全なノンブロッキングを実現するためには[R2DBC]のようなノンブロッキング対応のAPIを使う必要があります。これはつまり、<code>Reactive Stream</code>を使う必要があるとのことであって、必然的にその実現体であるMono/Fluxを使う必要があるということです。</p>
<p>なので、とりあえずRepositoryからMono/Fluxを取得し、Reactive Stream固有の書き方に合わせてコードを書いていくしかないということになります。問題は、Reactive Streamはその名前から普通にJavaのStreamの感覚で扱えば良い印象ですが、実際の処理はそう簡単じゃないということです。例えば、JPAやMyBatisのような既存のブロッキングベースのAPIを使う場合は、Serviceのメソッドでは以下のようなコードを書くことになりますね。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=c1>// ユーザIDでユーザ情報とメール送信履歴を取得する
</span><span class=c1></span><span class=k>fun</span> <span class=nf>getMemberWithMailRecord</span><span class=p>(</span><span class=n>memberId</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>MemberWithMailRecord</span> <span class=p>{</span>
    <span class=c1>// ユーザ情報を取得する
</span><span class=c1></span>    <span class=k>val</span> <span class=py>member</span> <span class=p>=</span> <span class=n>memberRepository</span><span class=p>.</span><span class=n>getMember</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=n>memberId</span><span class=p>)</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find member&#34;</span><span class=p>)</span>
    <span class=c1>// ユーザが作成したメール送信履歴を取得する
</span><span class=c1></span>    <span class=k>val</span> <span class=py>mailRecord</span> <span class=p>=</span> <span class=n>mailRecordRepository</span><span class=p>.</span><span class=n>getMailRecord</span><span class=p>(</span><span class=n>memberId</span> <span class=p>=</span> <span class=n>memberId</span><span class=p>)</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find mailRecord&#34;</span><span class=p>)</span>
    <span class=c1>// ユーザ情報とメール送信履歴を合わせて返却
</span><span class=c1></span>    <span class=k>return</span> <span class=n>MemberWithMailRecord</span><span class=p>(</span>
            <span class=n>member</span> <span class=p>=</span> <span class=n>member</span><span class=p>,</span>
            <span class=n>mailRecord</span> <span class=p>=</span> <span class=n>mailRecord</span>  
        <span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>しかし、Mono/Fluxを返すAPIを使う場合は、以下のようなコードになります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>fun</span> <span class=nf>getMemberWithMailRecord</span><span class=p>(</span><span class=n>memberId</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>Mono</span><span class=p>&lt;</span><span class=n>MemberWithMailRecord</span><span class=p>&gt;</span> <span class=p>=</span>
    <span class=n>memberRepository</span><span class=p>.</span><span class=n>getMember</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=n>memberId</span><span class=p>)</span>
        <span class=p>.</span><span class=n>switchIfEmpty</span><span class=p>(</span><span class=n>Mono</span><span class=p>.</span><span class=n>error</span><span class=p>(</span><span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find member&#34;</span><span class=p>)))</span>
        <span class=p>.</span><span class=n>zipWith</span><span class=p>(</span><span class=n>mailRecordRepository</span><span class=p>.</span><span class=n>getMailRecord</span><span class=p>(</span><span class=n>memberId</span> <span class=p>=</span> <span class=n>memberId</span><span class=p>).</span><span class=n>switchIfEmpty</span><span class=p>(</span><span class=n>Mono</span><span class=p>.</span><span class=n>error</span><span class=p>(</span><span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find mailRecord&#34;</span><span class=p>)))</span>
        <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=n>MemberWithMailRecord</span><span class=p>(</span>
              <span class=n>member</span> <span class=p>=</span> <span class=k>it</span><span class=p>.</span><span class=n>t1</span><span class=p>,</span>
              <span class=n>mailRecord</span> <span class=p>=</span> <span class=k>it</span><span class=p>.</span><span class=n>t2</span>
          <span class=p>)</span>
        <span class=p>}</span>
</code></pre></div><p>やっていることは同じでも、果たしてこれが書きやすく、読みやすいコードであるかどうかは悩ましいですね。他にもFluxで取得したデータをListに変えたい場合、取得したMonoのデータでさらにMonoを取得したい場合など、より複雑な処理が必要な場面ではますます書き方は複雑になります。</p>
<p>幸い、Kotlinには<a class=link href=https://kotlinlang.org/docs/coroutines-overview.html target=_blank rel=noopener>Coroutines</a>があるので、このような複雑な書き方をより簡単に書くことはできます。Corutinesを適用したら、Mono/Fluxを使う場合でも上記のコードは以下のようになりますね。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>getMemberWithMailRecord</span><span class=p>(</span><span class=n>memberId</span><span class=p>:</span> <span class=n>Int</span><span class=p>):</span> <span class=n>MemberWithMailRecord</span> <span class=p>{</span>
    <span class=k>val</span> <span class=py>member</span> <span class=p>=</span> <span class=n>memberRepository</span><span class=p>.</span><span class=n>getMember</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=n>memberId</span><span class=p>).</span><span class=n>awaitFirstOrNull</span><span class=p>()</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find member&#34;</span><span class=p>)</span>
    <span class=k>val</span> <span class=py>mailRecord</span> <span class=p>=</span> <span class=n>mailRecordRepository</span><span class=p>.</span><span class=n>getMailRecord</span><span class=p>(</span><span class=n>memberId</span> <span class=p>=</span> <span class=n>memberId</span><span class=p>).</span><span class=n>awaitFirstOrNull</span><span class=p>()</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find mailRecord&#34;</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>MemberWithMailRecord</span><span class=p>(</span>
            <span class=n>member</span> <span class=p>=</span> <span class=n>member</span><span class=p>,</span>
            <span class=n>mailRecord</span> <span class=p>=</span> <span class=n>mailRecord</span>  
        <span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>Coroutinesを使う場合はスコープの指定が必要となるのが一般的ですが、実際はControllerのメソッドまでを<code>suspend</code>として定義しておくと良いみたいです。ただ、既存のプロジェクトをSpring MVCからWebFluxに移行する場合にこうやって多くの処理をsuspendメソッドにすると、ユニットテストの方を直すのが大変になる可能性もあるのでそこは要注意です。</p>
<h3 id=functional-endpointで書く場合>Functional Endpointで書く場合</h3>
<p>続いて、Functional Endpontを使う場合のコードです。MVCパターンの問題としてアノテーションがあげられていますが、Router/Handlerでもアノテーションを使うことはできますし、アプリケーションのアーキテクチャによっては必然的にクラスを分けてアノテーションで管理することになるのが一般的かなと思います。なので、そのようなケースではRouterを<code>@Bean</code>として登録したり、Handlerも<code>@Component</code>として定義する場合もあります。そういう場合は、以下のようなコードになります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=nd>@Configuration</span>
<span class=k>class</span> <span class=nc>HelloRouter</span><span class=p>(</span><span class=k>private</span> <span class=k>val</span> <span class=py>handler</span><span class=p>:</span> <span class=n>HelloHanlder</span><span class=p>)</span> <span class=p>{</span>

    <span class=nd>@Bean</span>
    <span class=k>fun</span> <span class=nf>hello</span><span class=p>():</span> <span class=n>router</span> <span class=p>{</span>
        <span class=n>GET</span><span class=p>(</span><span class=s2>&#34;/hello&#34;</span><span class=p>,</span> <span class=n>handler</span><span class=o>::</span><span class=n>getHello</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=nd>@Component</span>
<span class=k>class</span> <span class=nc>HelloHandler</span> <span class=p>{</span>

    <span class=k>fun</span> <span class=nf>getHello</span><span class=p>(</span><span class=n>request</span><span class=p>:</span> <span class=n>ServerRequest</span><span class=p>):</span> <span class=n>Mono</span><span class=p>&lt;</span><span class=n>ServerResponse</span><span class=p>&gt;</span> <span class=p>=</span>
        <span class=n>ServerResponse</span>
            <span class=p>.</span><span class=n>ok</span><span class=p>()</span>
            <span class=p>.</span><span class=n>contentType</span><span class=p>(</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON</span><span class=p>)</span>
            <span class=p>.</span><span class=n>body</span><span class=p>(</span><span class=n>Mono</span><span class=p>.</span><span class=n>Just</span><span class=p>(</span><span class=s2>&#34;Hello Spring WebFlux&#34;</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></div><p>Functional Endpointを使う場合の特徴は、RouterはあくまでエンドポイントとHandlerをつなぐ役割をするだけなので、Handlerで<a class=link href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerRequest.html target=_blank rel=noopener>ServerRequest</a>を受け取り<a class=link href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/function/server/ServerResponse.html target=_blank rel=noopener>ServerResponse</a>を返す処理までを書くことになるということです。MVCパターンではRestControllerの戻り値としてResponseEntityや自分で定義したクラスを自由に指定でるし、Serviceではビジネスロジックだけを担当するパターンが多いのを考えるとかなり独特であるといえます。</p>
<p>このようにServerRequestとServerResponseを使うため、HandlerはServiceと比べビジネスロジック部分が一回層が深くなった形になります。ServerResponseのbodyでロジックを書いて、それを返す形ですね。例えば以下のようなコードになります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>fun</span> <span class=nf>getMember</span><span class=p>(</span><span class=n>request</span><span class=p>:</span> <span class=n>ServerRequest</span><span class=p>):</span> <span class=n>Mono</span><span class=p>&lt;</span><span class=n>ServerResponse</span><span class=p>&gt;</span> <span class=p>=</span>
    <span class=n>ServerResponse</span>
        <span class=p>.</span><span class=n>ok</span><span class=p>()</span>
        <span class=p>.</span><span class=n>contentType</span><span class=p>(</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON</span><span class=p>)</span>
        <span class=p>.</span><span class=n>body</span><span class=p>(</span><span class=n>memberRepository</span><span class=p>.</span><span class=n>getMember</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>PathVariable</span><span class=p>(</span><span class=s2>&#34;id&#34;</span><span class=p>))</span>
            <span class=p>.</span><span class=n>switchIfEmpty</span><span class=p>(</span><span class=n>Mono</span><span class=p>.</span><span class=n>error</span><span class=p>(</span><span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find member&#34;</span><span class=p>)))</span>
            <span class=p>.</span><span class=n>zipWith</span><span class=p>(</span><span class=n>mailRecordRepository</span><span class=p>.</span><span class=n>getMailRecord</span><span class=p>(</span><span class=n>memberId</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>PathVariable</span><span class=p>(</span><span class=s2>&#34;id&#34;</span><span class=p>)).</span><span class=n>switchIfEmpty</span><span class=p>(</span><span class=n>Mono</span><span class=p>.</span><span class=n>error</span><span class=p>(</span><span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find mailRecord&#34;</span><span class=p>)))</span>
            <span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=n>MemberWithMailRecord</span><span class=p>(</span>
                <span class=n>member</span> <span class=p>=</span> <span class=k>it</span><span class=p>.</span><span class=n>t1</span><span class=p>,</span>
                <span class=n>mailRecord</span> <span class=p>=</span> <span class=k>it</span><span class=p>.</span><span class=n>t2</span>
                <span class=p>)</span>
            <span class=p>}</span>
        <span class=p>)</span>

</code></pre></div><p>この場合でもでもCoroutinesを使うことはもちろんできます。Corutinesを使う場合は、以下のような書き方ができるでしょう。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>getMember</span><span class=p>(</span><span class=n>request</span><span class=p>:</span> <span class=n>ServerRequest</span><span class=p>):</span> <span class=n>Mono</span><span class=p>&lt;</span><span class=n>ServerResponse</span><span class=p>&gt;</span> <span class=p>{</span>
    <span class=k>val</span> <span class=py>member</span> <span class=p>=</span> <span class=n>memberRepository</span><span class=p>.</span><span class=n>getMember</span><span class=p>(</span><span class=n>id</span> <span class=p>=</span> <span class=n>memberId</span><span class=p>).</span><span class=n>awaitFirstOrNull</span><span class=p>()</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find member&#34;</span><span class=p>)</span>
    <span class=k>val</span> <span class=py>mailRecord</span> <span class=p>=</span> <span class=n>mailRecordRepository</span><span class=p>.</span><span class=n>getMailRecord</span><span class=p>(</span><span class=n>memberId</span> <span class=p>=</span> <span class=n>memberId</span><span class=p>).</span><span class=n>awaitFirstOrNull</span><span class=p>()</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>RuntimeException</span><span class=p>(</span><span class=s2>&#34;Can&#39;t find mailRecord&#34;</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>ServerResponse</span>
                    <span class=p>.</span><span class=n>ok</span><span class=p>()</span>
                    <span class=p>.</span><span class=n>contentType</span><span class=p>(</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON</span><span class=p>)</span>
                    <span class=p>.</span><span class=n>bodyValueAndAwait</span><span class=p>(</span>
                        <span class=n>Mono</span><span class=p>.</span><span class=n>just</span><span class=p>(</span>
                            <span class=n>MemberWithMailRecord</span><span class=p>(</span>
                                <span class=n>member</span> <span class=p>=</span> <span class=k>it</span><span class=p>.</span><span class=n>t1</span><span class=p>,</span>
                                <span class=n>mailRecord</span> <span class=p>=</span> <span class=k>it</span><span class=p>.</span><span class=n>t2</span>
                            <span class=p>)</span>
                        <span class=p>)</span>
                    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h2 id=性能>性能</h2>
<p>MVCパターンの問題としてあげられるものの一つとして、アノテーションがあります。アノテーションを使うということは、必然的にリフレクションを使うことになるので、自然に性能の低下にもつながるという話ですね。これだけみると、WebFluxではMVCパターンよりもFunctional Endpointを使ったほうが性能でも有利であるように見えます。しかし実際はどうでしょうか？</p>
<p><a class=link href=https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-programming-models target=_blank rel=noopener>Springの公式ドキュメント</a>では、Functional Enddpointのことを<code>lightweight(軽量)</code>とは表現しているものの、それ以外に性能がどうという話は一切述べてないです。多くの場合、性能の比較はSpring MVCとSpring WebFluxを対象としていて、WebFluxでのMVCパターンとFunctional Endpointのケースはあまり探せませんでした。なので、ここでは簡単にベンチマークを行うことで二つのパターンでの性能の違いを検証してみました。</p>
<p>ベンチマークツールとしては、Jmeterを使うこともできましたが、短いコマンドで測定ができるのもあり、今回は<a class=link href=https://httpd.apache.org/docs/2.4/en/programs/ab.html target=_blank rel=noopener>Apache HTTP server benchmarking tool</a>を使ってテストを実施しています。</p>
<h3 id=使ったコード>使ったコード</h3>
<p>性能測定として知りたいのは「実装パターンで性能が変わるか」ということなので、あえてDB接続は排除しました。比較のために作ったサンプルアプリケーションでは、単純にデータを生成する共通のロジックと、それを返すだけのContoller/Service, Router/Hanlderのセットで構成されています。</p>
<h4 id=共通>共通</h4>
<p>データを生成するロジックそのものは共通で、単純にループでListを生成するようにしています。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=c1>// 固定値のデータを生成し返すクラス
</span><span class=c1></span><span class=k>object</span> <span class=nc>DataCreationUtil</span> <span class=p>{</span>

    <span class=c1>// 1970年1月1日から2021年12月31日まで
</span><span class=c1></span>    <span class=k>var</span> <span class=py>data</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Person</span><span class=p>&gt;</span> <span class=p>=</span> <span class=p>(</span><span class=m>0.</span><span class=p>.</span><span class=m>18992</span><span class=p>)</span>
        <span class=p>.</span><span class=n>map</span> <span class=p>{</span>
            <span class=n>Person</span><span class=p>(</span>
                <span class=n>id</span> <span class=p>=</span> <span class=k>it</span><span class=p>.</span><span class=n>toLong</span><span class=p>(),</span>
                <span class=n>name</span> <span class=p>=</span> <span class=s2>&#34;Person</span><span class=si>${it}</span><span class=s2>&#34;</span><span class=p>,</span>
                <span class=n>birth</span> <span class=p>=</span> <span class=n>LocalDate</span><span class=p>.</span><span class=n>ofEpochDay</span><span class=p>(</span><span class=k>it</span><span class=p>.</span><span class=n>toLong</span><span class=p>()),</span>
                <span class=n>joined</span> <span class=p>=</span> <span class=n>LocalDate</span><span class=p>.</span><span class=n>ofEpochDay</span><span class=p>(</span><span class=k>it</span><span class=p>.</span><span class=n>toLong</span><span class=p>()</span> <span class=p>+</span> <span class=m>10000</span><span class=p>)</span>
            <span class=p>)</span>
        <span class=p>}.</span><span class=n>toList</span><span class=p>()</span>
<span class=p>}</span>

<span class=c1>// 生成されるデータ
</span><span class=c1></span><span class=k>data</span> <span class=k>class</span> <span class=nc>Person</span><span class=p>(</span>
    <span class=k>val</span> <span class=py>id</span><span class=p>:</span> <span class=n>Long</span><span class=p>,</span>
    <span class=k>val</span> <span class=py>name</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span>
    <span class=k>val</span> <span class=py>birth</span><span class=p>:</span> <span class=n>LocalDate</span><span class=p>,</span>
    <span class=k>val</span> <span class=py>joined</span><span class=p>:</span> <span class=n>LocalDate</span>
<span class=p>)</span>
</code></pre></div><h4 id=controllerserviceの実装>Controller/Serviceの実装</h4>
<p>MVCパターンについてはコードだけでも十分わかると思いますので、説明は割愛します。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=nd>@RestController</span>
<span class=k>class</span> <span class=nc>PerformanceTestController</span><span class=p>(</span>
    <span class=k>private</span> <span class=k>val</span> <span class=py>service</span><span class=p>:</span> <span class=n>PerformanceTestService</span>
<span class=p>)</span> <span class=p>{</span>

    <span class=nd>@GetMapping</span><span class=p>(</span><span class=s2>&#34;/performance-controller&#34;</span><span class=p>)</span>
    <span class=k>fun</span> <span class=nf>getData</span><span class=p>():</span> <span class=n>ResponseEntity</span><span class=p>&lt;</span><span class=n>List</span><span class=p>&lt;</span><span class=n>Person</span><span class=p>&gt;&gt;</span> <span class=p>=</span>
        <span class=n>ResponseEntity</span>
            <span class=p>.</span><span class=n>ok</span><span class=p>()</span>
            <span class=p>.</span><span class=n>contentType</span><span class=p>(</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON</span><span class=p>)</span>
            <span class=p>.</span><span class=n>body</span><span class=p>(</span><span class=n>service</span><span class=p>.</span><span class=n>getData</span><span class=p>())</span>
<span class=p>}</span>

<span class=nd>@Service</span>
<span class=k>class</span> <span class=nc>PerformanceTestService</span> <span class=p>{</span>

    <span class=k>fun</span> <span class=nf>getData</span><span class=p>():</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Person</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>service</span><span class=p>.</span><span class=n>getData</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></div><h4 id=routerhandlerの実装>Router/Handlerの実装</h4>
<p>Functional Endpointでは、MVCパターンと比べ処理と言えるものは全部Handlerの方に書かれてある、という違いがあります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=nd>@Configuration</span>
<span class=k>class</span> <span class=nc>PerformanceTestRouter</span><span class=p>(</span><span class=k>private</span> <span class=k>val</span> <span class=py>handler</span><span class=p>:</span> <span class=n>PerformanceTestHandler</span><span class=p>)</span> <span class=p>{</span>

    <span class=nd>@Bean</span>
    <span class=k>fun</span> <span class=nf>route</span><span class=p>()</span> <span class=p>=</span> <span class=n>router</span> <span class=p>{</span>
        <span class=n>GET</span><span class=p>(</span><span class=s2>&#34;/performance-router&#34;</span><span class=p>,</span> <span class=n>handler</span><span class=o>::</span><span class=n>getData</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=nd>@Component</span>
<span class=k>class</span> <span class=nc>PerformanceTestHandler</span> <span class=p>{</span>

    <span class=k>fun</span> <span class=nf>getData</span><span class=p>(</span><span class=n>request</span><span class=p>:</span> <span class=n>ServerRequest</span><span class=p>):</span> <span class=n>Mono</span><span class=p>&lt;</span><span class=n>ServerResponse</span><span class=p>&gt;</span> <span class=p>=</span>
        <span class=n>ServerResponse</span>
            <span class=p>.</span><span class=n>ok</span><span class=p>()</span>
            <span class=p>.</span><span class=n>contentType</span><span class=p>(</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON</span><span class=p>)</span>
            <span class=p>.</span><span class=n>body</span><span class=p>(</span><span class=n>Flux</span><span class=p>.</span><span class=n>fromIterable</span><span class=p>(</span><span class=n>DataCreationUtil</span><span class=p>.</span><span class=k>data</span><span class=p>))</span>
<span class=p>}</span>
</code></pre></div><h3 id=テスト結果>テスト結果</h3>
<p>テストは以下のような条件で実施しました。</p>
<ul>
<li>ユーザ数は5000, ユーザごとのリクエストは50に設定</li>
<li>ワームアップ時間を考慮して、パターンごとにテストを分ける
<ul>
<li>サーバの再起動後にテストを実施</li>
<li>テストは10回ループ</li>
</ul>
</li>
</ul>
<p>実際に使ったスクリプトは以下のようなものです。サーバの起動後にこれを実行し、10回のループが終わったら再起動後にFunctional Endpointのテストを実施しています。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=cp>#!/bin/bash
</span><span class=cp></span>
<span class=k>for</span> i in <span class=o>{</span>1..10<span class=o>}</span>
<span class=k>do</span>
 ab -n <span class=m>5000</span> -c <span class=m>50</span> http://localhost:8080/performance-controller
<span class=k>done</span>
</code></pre></div><p>ただ、こうやってもやはりテスト結果では周回ごとに偏差があったので、ここでは中間値に当てはまる結果を紹介します。その結果は、以下の通りになりますが、あらかじめ結論だけ先に言いますとMVCパターンでもFunctional Endpointでもその性能の違いというものは「誤差範囲以内」と表現しても良いかなと思います。</p>
<h4 id=controllerserviceの結果>Controller/Serviceの結果</h4>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>Server Software:        
Server Hostname:        localhost
Server Port:            <span class=m>8080</span>

Document Path:          /performance-controller
Document Length:        <span class=m>1440242</span> bytes

Concurrency Level:      <span class=m>50</span>
Time taken <span class=k>for</span> tests:   24.989 seconds
Complete requests:      <span class=m>5000</span>
Failed requests:        <span class=m>0</span>
Total transferred:      <span class=m>7201590000</span> bytes
HTML transferred:       <span class=m>7201210000</span> bytes
Requests per second:    200.09 <span class=o>[</span><span class=c1>#/sec] (mean)</span>
Time per request:       249.892 <span class=o>[</span>ms<span class=o>]</span> <span class=o>(</span>mean<span class=o>)</span>
Time per request:       4.998 <span class=o>[</span>ms<span class=o>]</span> <span class=o>(</span>mean, across all concurrent requests<span class=o>)</span>
Transfer rate:          281433.26 <span class=o>[</span>Kbytes/sec<span class=o>]</span> received

Connection Times <span class=o>(</span>ms<span class=o>)</span>
              min  mean<span class=o>[</span>+/-sd<span class=o>]</span> median   max
Connect:        <span class=m>0</span>    <span class=m>1</span>   1.4      <span class=m>0</span>      <span class=m>11</span>
Processing:    <span class=m>29</span>  <span class=m>248</span>  79.8    <span class=m>242</span>     <span class=m>516</span>
Waiting:       <span class=m>24</span>  <span class=m>192</span>  60.8    <span class=m>185</span>     <span class=m>442</span>
Total:         <span class=m>29</span>  <span class=m>249</span>  79.4    <span class=m>243</span>     <span class=m>516</span>

Percentage of the requests served within a certain <span class=nb>time</span> <span class=o>(</span>ms<span class=o>)</span>
  50%    <span class=m>243</span>
  66%    <span class=m>275</span>
  75%    <span class=m>295</span>
  80%    <span class=m>309</span>
  90%    <span class=m>354</span>
  95%    <span class=m>394</span>
  98%    <span class=m>430</span>
  99%    <span class=m>449</span>
 100%    <span class=m>516</span> <span class=o>(</span>longest request<span class=o>)</span>
</code></pre></div><h4 id=routerhandlerの結果>Router/Handlerの結果</h4>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>Server Software:        
Server Hostname:        localhost
Server Port:            <span class=m>8080</span>

Document Path:          /performance-router
Document Length:        <span class=m>1440257</span> bytes

Concurrency Level:      <span class=m>50</span>
Time taken <span class=k>for</span> tests:   25.541 seconds
Complete requests:      <span class=m>5000</span>
Failed requests:        <span class=m>0</span>
Total transferred:      <span class=m>7201775000</span> bytes
HTML transferred:       <span class=m>7201285000</span> bytes
Requests per second:    195.76 <span class=o>[</span><span class=c1>#/sec] (mean)</span>
Time per request:       255.410 <span class=o>[</span>ms<span class=o>]</span> <span class=o>(</span>mean<span class=o>)</span>
Time per request:       5.108 <span class=o>[</span>ms<span class=o>]</span> <span class=o>(</span>mean, across all concurrent requests<span class=o>)</span>
Transfer rate:          275360.22 <span class=o>[</span>Kbytes/sec<span class=o>]</span> received

Connection Times <span class=o>(</span>ms<span class=o>)</span>
              min  mean<span class=o>[</span>+/-sd<span class=o>]</span> median   max
Connect:        <span class=m>0</span>    <span class=m>1</span>   3.2      <span class=m>0</span>     <span class=m>151</span>
Processing:    <span class=m>33</span>  <span class=m>253</span>  80.4    <span class=m>246</span>     <span class=m>612</span>
Waiting:       <span class=m>28</span>  <span class=m>194</span>  59.8    <span class=m>184</span>     <span class=m>475</span>
Total:         <span class=m>39</span>  <span class=m>254</span>  80.0    <span class=m>247</span>     <span class=m>613</span>

Percentage of the requests served within a certain <span class=nb>time</span> <span class=o>(</span>ms<span class=o>)</span>
  50%    <span class=m>247</span>
  66%    <span class=m>286</span>
  75%    <span class=m>302</span>
  80%    <span class=m>312</span>
  90%    <span class=m>361</span>
  95%    <span class=m>398</span>
  98%    <span class=m>441</span>
  99%    <span class=m>459</span>
 100%    <span class=m>613</span> <span class=o>(</span>longest request<span class=o>)</span>
</code></pre></div><h2 id=ドキュメンテーション>ドキュメンテーション</h2>
<p>次にドキュメンテーションの観点からすると、Functional Endpointはまだ導入するには早い気がします。ここでいうドキュメンテーションは、JavaDocやKdocのようなコメントのことではなく、最近よく使われる<a class=link href=https://swagger.io target=_blank rel=noopener>Swagger</a>のことを指します。</p>
<p>最近は<a class=link href=http://springfox.github.io/springfox target=_blank rel=noopener>SpringFox</a>などを使うと簡単にAPIのドキュメンテーションが可能ですが、Functional Endpointだとそう簡単にはできません。すでに理由がわかる方もいらっしゃるかと思いますが、Routerには引数としてエンドポイントとHandlerの処理を渡しているだけで、Handlerは引数がServerRequest、戻り値はServerResponseに固定されてあるのが理由です。</p>
<p>もちろん、ServerRequestとServerResponseを使う場合でもそれを自分の欲しいデータとして扱うことはできます。例えば、リクエストからパラメータを取る方法は以下のようになります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=c1>// Path Variableで渡されたIDを持ってユーザ情報を取得する
</span><span class=c1></span><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>getMember</span><span class=p>(</span><span class=n>request</span><span class=p>:</span> <span class=n>ServerRequest</span><span class=p>):</span> <span class=n>ServerResponse</span> <span class=p>{</span>
    <span class=c1>// Path Variableを取得する
</span><span class=c1></span>    <span class=k>val</span> <span class=py>id</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>pathVariable</span><span class=p>(</span><span class=s2>&#34;id&#34;</span><span class=p>)</span>
    <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>

<span class=c1>// Request Bodyで渡されたデータを元に新しいユーザを作成する
</span><span class=c1></span><span class=k>suspend</span> <span class=k>fun</span> <span class=nf>createMember</span><span class=p>(</span><span class=n>request</span><span class=p>:</span> <span class=n>ServerRequest</span><span class=p>):</span> <span class=n>ServerResponse</span> <span class=p>{</span>
    <span class=c1>// Request Bodyをクラスにマッピングする
</span><span class=c1></span>    <span class=k>val</span> <span class=py>form</span> <span class=p>=</span> <span class=n>request</span><span class=p>.</span><span class=n>bodyToMono</span><span class=p>(</span><span class=n>MemberCreateForm</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>).</span><span class=n>awaitFirst</span><span class=p>()</span>
    <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span> 
</code></pre></div><p>ただ、SpringFoxのように自動でAPIのドキュメンテーションを行ってくれるような便利なAPIは、おそらくリフレクションを使っています。なので、Handlerで実際はどんな処理が行われているかを判断するのは難しいでしょう。</p>
<p>幸い、この問題はSpringの開発者も認識しているようで、<a class=link href=https://springdoc.org target=_blank rel=noopener>springdoc-openapi</a>を使うとFunctional EndpointでもAPIのドキュメンテーションは可能になります。ただ、この場合でも現時点ではやはり問題があります。なぜなら、これはAPIのドキュメンテーションを自動化するものではなく、「ドキュメンテーションのための手段を提供する」だけだからです。なので、以下のように、RouterやHandlerに関して一つ一つアノテーションを指定する必要があります。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=nd>@Bean</span>
<span class=nd>@RouterOperations</span><span class=p>(</span>
    <span class=n>value</span> <span class=p>=</span>
<span class=na>        [
</span><span class=na>            RouterOperation(
</span><span class=na>                path = &#34;/api/v1/members&#34;,
</span><span class=na>                beanClass = MemberHandler::class,
</span><span class=na>                beanMethod = &#34;listMember&#34;,
</span><span class=na>                method = [RequestMethod.GET]</span><span class=p>,</span>
                <span class=n>produces</span> <span class=p>=</span> <span class=p>[</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON_VALUE</span><span class=p>]</span>
            <span class=p>),</span>
            <span class=n>RouterOperation</span><span class=p>(</span>
                <span class=n>path</span> <span class=p>=</span> <span class=s2>&#34;/api/v1/members/{id}&#34;</span><span class=p>,</span>
                <span class=n>beanClass</span> <span class=p>=</span> <span class=n>MemberHandler</span><span class=o>::</span><span class=k>class</span><span class=p>,</span>
                <span class=n>beanMethod</span> <span class=p>=</span> <span class=s2>&#34;getMember&#34;</span><span class=p>,</span>
                <span class=n>method</span> <span class=p>=</span> <span class=p>[</span><span class=n>RequestMethod</span><span class=p>.</span><span class=n>GET</span><span class=p>],</span>
                <span class=n>produces</span> <span class=p>=</span> <span class=p>[</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON_VALUE</span><span class=p>]</span>
            <span class=p>),</span>
            <span class=n>RouterOperation</span><span class=p>(</span>
                <span class=n>path</span> <span class=p>=</span> <span class=s2>&#34;/api/v1/members&#34;</span><span class=p>,</span>
                <span class=n>beanClass</span> <span class=p>=</span> <span class=n>MemberHandler</span><span class=o>::</span><span class=k>class</span><span class=p>,</span>
                <span class=n>beanMethod</span> <span class=p>=</span> <span class=s2>&#34;createMember&#34;</span><span class=p>,</span>
                <span class=n>method</span> <span class=p>=</span> <span class=p>[</span><span class=n>RequestMethod</span><span class=p>.</span><span class=n>POST</span><span class=p>],</span>
                <span class=n>produces</span> <span class=p>=</span> <span class=p>[</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON_VALUE</span><span class=p>]</span>
            <span class=p>),</span>
            <span class=n>RouterOperation</span><span class=p>(</span>
                <span class=n>path</span> <span class=p>=</span> <span class=s2>&#34;/api/v1/members/{id}&#34;</span><span class=p>,</span>
                <span class=n>beanClass</span> <span class=p>=</span> <span class=n>MemberHandler</span><span class=o>::</span><span class=k>class</span><span class=p>,</span>
                <span class=n>beanMethod</span> <span class=p>=</span> <span class=s2>&#34;updateMember&#34;</span><span class=p>,</span>
                <span class=n>method</span> <span class=p>=</span> <span class=p>[</span><span class=n>RequestMethod</span><span class=p>.</span><span class=n>PUT</span><span class=p>],</span>
                <span class=n>produces</span> <span class=p>=</span> <span class=p>[</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON_VALUE</span><span class=p>]</span>
            <span class=p>),</span>
            <span class=n>RouterOperation</span><span class=p>(</span>
                <span class=n>path</span> <span class=p>=</span> <span class=s2>&#34;/api/v1/members/{id}&#34;</span><span class=p>,</span>
                <span class=n>beanClass</span> <span class=p>=</span> <span class=n>MemberHandler</span><span class=o>::</span><span class=k>class</span><span class=p>,</span>
                <span class=n>beanMethod</span> <span class=p>=</span> <span class=s2>&#34;deleteMember&#34;</span><span class=p>,</span>
                <span class=n>method</span> <span class=p>=</span> <span class=p>[</span><span class=n>RequestMethod</span><span class=p>.</span><span class=n>DELETE</span><span class=p>],</span>
                <span class=n>produces</span> <span class=p>=</span> <span class=p>[</span><span class=n>MediaType</span><span class=p>.</span><span class=n>APPLICATION_JSON_VALUE</span><span class=p>]</span>
            <span class=p>),</span>
        <span class=p>]</span>
    <span class=p>)</span>
<span class=k>fun</span> <span class=nf>routeMember</span><span class=p>()</span> <span class=p>=</span> <span class=n>coRouter</span> <span class=p>{</span>
    <span class=n>GET</span><span class=p>(</span><span class=s2>&#34;/api/v1/members&#34;</span><span class=p>)</span> <span class=p>{</span> <span class=n>handler</span><span class=p>.</span><span class=n>listMember</span><span class=p>()</span> <span class=p>}</span>
    <span class=n>GET</span><span class=p>(</span><span class=s2>&#34;/api/v1/members/{id}&#34;</span><span class=p>,</span> <span class=n>handler</span><span class=o>::</span><span class=n>getMember</span><span class=p>)</span>
    <span class=n>POST</span><span class=p>(</span><span class=s2>&#34;/api/v1/members&#34;</span><span class=p>,</span> <span class=n>handler</span><span class=o>::</span><span class=n>createMember</span><span class=p>)</span>
    <span class=n>PUT</span><span class=p>(</span><span class=s2>&#34;/api/v1/members/{id}&#34;</span><span class=p>,</span> <span class=n>handler</span><span class=o>::</span><span class=n>updateMember</span><span class=p>)</span>
    <span class=n>DELETE</span><span class=p>(</span><span class=s2>&#34;/api/v1/members/{id}&#34;</span><span class=p>,</span> <span class=n>handler</span><span class=o>::</span><span class=n>deleteMember</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>ご覧の通り、ドキュメンテーションのためのアノテーションが実際のコードよりも長くなっています。Functional EndpointでもSwaggerを利用できる手段ができたのは良いことですが、MVCパターンと比べやはり不便ではありますね。なので、ドキュメンテーションが大事であるなら、まだFunctional Pointを使うべきではないかも知れません。</p>
<h2 id=最後に>最後に</h2>
<p>今回は、Spring WebFluxのMVCパターン及びFunctional Endpointをコードの書き方、性能、ドキュメンテーションという観点から比較してみました。Spring WebFluxも発表されたのが2017年なので、もう今年で5年目になりますが、まだまだMVCパターンに比べては色々と補完すべき点が多い印象です。自分の場合はWebFluxのメインコンセプトであるノンブロッキングや関数型プログラミングを活かすためにはやはりFunctional Endpointを選んだ方が良さそうな気はしていますが、まだあえてそうする必要はないのではないか、という感覚です。特にエンタプライズのアプリケーションを書くことになるとますますそうでしょう。もちろん、そもそもWebFluxそのものを導入すべきかということから考える必要がありますが。</p>
<p>それでも、やはりFunctional Endpointという実装方式には色々と可能性があると思います。Spring WebFluxでなくても、最近のウェブフレームワークでは多く採用されているものですからね。例えばTechEmpowerの<a class=link href=https://www.techempower.com/benchmarks target=_blank rel=noopener>ベンチマーク</a>でJavaのフレームワークのうちではもっとも性能がよかった<a class=link href=https://jooby.io target=_blank rel=noopener>jooby</a>でもMVCパターンとFunctional Endpointとよく似たScript Routeパターンに対応していますし、JetBrainsで開発しているKotlin用のウェブフレームワークである<a class=link href=https://ktor.io target=_blank rel=noopener>Ktor</a>ではMVCパターンなしで、同じくFunctional Endpointとよく似たRoutingにのみ対応しています。なので、他にも<a class=link href=https://expressjs.com/ja target=_blank rel=noopener>Express</a>や<a class=link href=https://github.com/gin-gonic/gin target=_blank rel=noopener>Gin</a>のようなフレームワークでも似たようなAPIの実装方法を提供しているので、余裕があったら個人的に試してみて慣れるのも良い勉強になるかも知れません。また、関数型プログラミングはこれからも幅広く使われそうなので、これを持って練習してみるのも良いかも知れませんね。</p>
<p>では、また！</p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/spring/>spring</a>
<a href=/tags/webflux/>webflux</a>
<a href=/tags/kotlin/>kotlin</a>
<a href=/tags/rest-api/>rest api</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=/posts/spring-webflux-dividing-router-and-handler/>
<div class=article-image>
<img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg>
</div>
<div class=article-details>
<h2 class=article-title>WebFluxのFunctional Enpointに対する小考察</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/posts/spring-webflux-and-nonblocking/>
<div class=article-image>
<img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg>
</div>
<div class=article-details>
<h2 class=article-title>Spring WebFlux、少し触ってみてからの話</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/posts/spring-webflux/>
<div class=article-image>
<img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg>
</div>
<div class=article-details>
<h2 class=article-title>Spring WebFluxって何？</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/posts/spring-rest-api-security-handling/>
<div class=article-image>
<img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg>
</div>
<div class=article-details>
<h2 class=article-title>REST APIでのSpring Securityの例外ハンドリングを実装する</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/posts/spring-rest-api-login-with-jwt/>
<div class=article-image>
<img src=/../../images/spring.jpg loading=lazy data-key data-hash=/../../images/spring.jpg>
</div>
<div class=article-details>
<h2 class=article-title>JWTによるREST APIのログインを実現する</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2019 -
2022 Korean-man in Tokyo
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.7.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#プログラミングのパラダイムとして>プログラミングのパラダイムとして</a>
<ol>
<li><a href=#mvcパターンで書く場合>MVCパターンで書く場合</a></li>
<li><a href=#functional-endpointで書く場合>Functional Endpointで書く場合</a></li>
</ol>
</li>
<li><a href=#性能>性能</a>
<ol>
<li><a href=#使ったコード>使ったコード</a>
<ol>
<li><a href=#共通>共通</a></li>
<li><a href=#controllerserviceの実装>Controller/Serviceの実装</a></li>
<li><a href=#routerhandlerの実装>Router/Handlerの実装</a></li>
</ol>
</li>
<li><a href=#テスト結果>テスト結果</a>
<ol>
<li><a href=#controllerserviceの結果>Controller/Serviceの結果</a></li>
<li><a href=#routerhandlerの結果>Router/Handlerの結果</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#ドキュメンテーション>ドキュメンテーション</a></li>
<li><a href=#最後に>最後に</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>