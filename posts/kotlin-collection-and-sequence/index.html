<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="とある処理を書く方法が色々ある場合は、どれを選んだ方がもっとも良いかと悩ましくなります。こういう場合は、コードの読みやすさやコードの長さ、予"><title>Sequenceは常にいいか</title><link rel=canonical href=https://retheviper.github.io/posts/kotlin-collection-and-sequence/><link rel=stylesheet href=/scss/style.min.fbb68fe51fb77bdd639dccfe1c7b590d2330cf8b81da91f1585b35c3d07fbac8.css><meta property="og:title" content="Sequenceは常にいいか"><meta property="og:description" content="とある処理を書く方法が色々ある場合は、どれを選んだ方がもっとも良いかと悩ましくなります。こういう場合は、コードの読みやすさやコードの長さ、予"><meta property="og:url" content="https://retheviper.github.io/posts/kotlin-collection-and-sequence/"><meta property="og:site_name" content="Korean-man in Tokyo"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="kotlin"><meta property="article:tag" content="java"><meta property="article:tag" content="stream"><meta property="article:published_time" content="2021-06-13T00:00:00+00:00"><meta property="article:modified_time" content="2021-06-13T00:00:00+00:00"><meta property="og:image" content="https://retheviper.github.io/images/kotlin.jpg"><meta name=twitter:title content="Sequenceは常にいいか"><meta name=twitter:description content="とある処理を書く方法が色々ある場合は、どれを選んだ方がもっとも良いかと悩ましくなります。こういう場合は、コードの読みやすさやコードの長さ、予"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://retheviper.github.io/images/kotlin.jpg"><link rel=apple-touch-icon sizes=57x57 href=/favicon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/favicon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/favicon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/favicon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/favicon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/favicon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/favicon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/favicon/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><script async src="https://www.googletagmanager.com/gtag/js?id=G-BYJBEJB6DX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BYJBEJB6DX",{anonymize_ip:!1})}</script></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/kotlin-collection-and-sequence/><img src=/../../images/kotlin.jpg loading=lazy alt="Featured image of post Sequenceは常にいいか"></a></div><div class=article-details><header class=article-category><a href=/categories/kotlin/ style=background-color:#2a9d8f;color:#fff>kotlin</a></header><h2 class=article-title><a href=/posts/kotlin-collection-and-sequence/>Sequenceは常にいいか</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jun 13, 2021</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>17 minute read</time></div></footer></div></header><section class=article-content><p>とある処理を書く方法が色々ある場合は、どれを選んだ方がもっとも良いかと悩ましくなります。こういう場合は、コードの読みやすさやコードの長さ、予想される問題のようなさまざまな観点からそれぞれの方式を比較してどれを選ぶか判断することになりますね。ただ、このような観点から判断するのは多くの場合「書き方が全く違う」場合に有効であって、そもそも似たようなコードを書くことになる場合は他の観点からも考える必要があります。ほんの少しだけ違うから、見た目だけでは違いがわからない場合。こういう時はそのAPIの内部、メカニズムからちゃんと考えて選ぶ必要がありますね。</p><p>そういう意味で、今回はKotlinのCollectionの処理に使える方法の二つ、「Collectionのoperation直接使う」場合と「Sequenceに変換してから処理する」場合の違いに関して述べたいと思います。</p><h2 id=処理方式の違い>処理方式の違い</h2><p>Javaでは、Collectionの要素を持って処理をする方法は色々とありますが、大きく分けて1.8以前の方法(<code>for</code>や<code>while</code>などを利用したループ)と1.8以降の方法(<code>Stream</code>を使った方法)があると言ってもいいのではないかと思います。この二つの方法はそもそもベースとなっているパラダイムそのものが違うので、コードを書くスタイルから大きく違います。例えば同じ処理をしたい場合でも、以下のコードで確認できるように、見た目が完全に違います。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#6272a4>// forループの場合
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>filterEven</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>Integer<span style=color:#ff79c6>&gt;</span> list <span style=color:#ff79c6>=</span> List<span style=color:#ff79c6>.</span><span style=color:#50fa7b>of</span><span style=color:#ff79c6>(</span>1<span style=color:#ff79c6>,</span> 2<span style=color:#ff79c6>,</span> 3<span style=color:#ff79c6>,</span> 4<span style=color:#ff79c6>,</span> 5<span style=color:#ff79c6>,</span> 6<span style=color:#ff79c6>,</span> 7<span style=color:#ff79c6>,</span> 8<span style=color:#ff79c6>,</span> 9<span style=color:#ff79c6>,</span> 10<span style=color:#ff79c6>);</span>
</span></span><span style=display:flex><span>    List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> result <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> ArrayList<span style=color:#ff79c6>&lt;&gt;();</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> <span style=color:#ff79c6>(</span>Integer i <span style=color:#ff79c6>:</span> list<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>i <span style=color:#ff79c6>%</span> 2 <span style=color:#ff79c6>==</span> 0<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>            result<span style=color:#ff79c6>.</span><span style=color:#50fa7b>add</span><span style=color:#ff79c6>(</span>i<span style=color:#ff79c6>.</span><span style=color:#50fa7b>toString</span><span style=color:#ff79c6>());</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> <span style=color:#ff79c6>(</span>result<span style=color:#ff79c6>.</span><span style=color:#50fa7b>size</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>==</span> 3<span style=color:#ff79c6>)</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>break</span><span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> result<span style=color:#ff79c6>;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Streamを使う場合
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>List<span style=color:#ff79c6>&lt;</span>String<span style=color:#ff79c6>&gt;</span> <span style=color:#50fa7b>filterEvenStream</span><span style=color:#ff79c6>()</span> <span style=color:#ff79c6>{</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> List<span style=color:#ff79c6>.</span><span style=color:#50fa7b>of</span><span style=color:#ff79c6>(</span>1<span style=color:#ff79c6>,</span> 2<span style=color:#ff79c6>,</span> 3<span style=color:#ff79c6>,</span> 4<span style=color:#ff79c6>,</span> 5<span style=color:#ff79c6>,</span> 6<span style=color:#ff79c6>,</span> 7<span style=color:#ff79c6>,</span> 8<span style=color:#ff79c6>,</span> 9<span style=color:#ff79c6>,</span> 10<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>.</span><span style=color:#50fa7b>stream</span><span style=color:#ff79c6>()</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>.</span><span style=color:#50fa7b>filter</span><span style=color:#ff79c6>(</span>i <span style=color:#ff79c6>-&gt;</span> i <span style=color:#ff79c6>%</span> 2 <span style=color:#ff79c6>==</span> 0<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>.</span><span style=color:#50fa7b>map</span><span style=color:#ff79c6>(</span>i <span style=color:#ff79c6>-&gt;</span> i<span style=color:#ff79c6>.</span><span style=color:#50fa7b>toString</span><span style=color:#ff79c6>())</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>.</span><span style=color:#50fa7b>limit</span><span style=color:#ff79c6>(</span>3<span style=color:#ff79c6>)</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>.</span><span style=color:#50fa7b>collect</span><span style=color:#ff79c6>(</span>Collectors<span style=color:#ff79c6>.</span><span style=color:#50fa7b>toList</span><span style=color:#ff79c6>());</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>}</span>
</span></span></code></pre></div><p>Streamを使った処理の場合はoperationを積み重ねて行く形をしていますが、これは現代の関数型プログラミングに対応している言語ならどれも持っているAPIといえます。例えばKotlin, 公式的には呼び方が色々あるようですが、一部では<code>Functional function</code>という名で呼ばれているようで、今回はこの操作方式、Functional functionについて述べたいと思います。</p><p>KotlinではCollectionでもこのようなopreationがあり、Kotlin版のStreamとも言える<a class=link href=https://kotlinlang.org/docs/sequences.html target=_blank rel=noopener>Sequence</a>でも同様の操作できるようになっています。また、JavaのStreamをそのまま使うこともできるので、Functional functionを使った処理は三つがあるといえますね。それぞれの使い方もあまり変わりません。なので以下のようなコードで同じ処理ができますが、それが帰って悩ましくなるところでもあります。「どれを使ったらいい？」とですね。例えば同じ処理をしたい場合でも、Kotlinでは以下のように色々な方法を使えます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// Collectionの場合
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>filterEven</span>(): List&lt;String&gt; = listOf(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>).filter { <span style=color:#ff79c6>it</span> %<span style=color:#bd93f9>2</span> <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> }.map { <span style=color:#ff79c6>it</span>.toString() }.take(<span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// Sequenceを使う場合
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>filterEvenSequence</span>: List&lt;String&gt; = listOf(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>).asSequence().filter { <span style=color:#ff79c6>it</span> %<span style=color:#bd93f9>2</span> <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> }.map { <span style=color:#ff79c6>it</span>.toString() }.take(<span style=color:#bd93f9>3</span>).toList()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// JavaのStream APIを使う場合
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>filterEvenStream</span>(): List&lt;String&gt; = listOf(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>).stream().filter { <span style=color:#ff79c6>it</span> %<span style=color:#bd93f9>2</span> <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> }.map { <span style=color:#ff79c6>it</span>.toString() }.limit(<span style=color:#bd93f9>3</span>).collect(<span style=color:#50fa7b>Collectors</span>.toList())
</span></span></code></pre></div><p>上記のコードは見た目ではあまり違いがわからないですね。処理やロジックが大きく変わる訳でもありません。使い方があまり変わらなく、結果としても同じようなものを期待できるとしたら、やはり次に気にすべきは「性能」ではないかと思います。特にCollectionよりもSequenceの方がより性能がいいという話もありますので、それならなるべくSequenceを使った方が絶対良いはずですね。</p><p>しかし、それを事実と受け止めるとしたら、いくつかの疑問が残ります。常にSequenceの方が性能で有利だとしたら、なぜCollectionからFunctional functionを呼び出す時は内部でSequenceに変換するようにするのでなく、わざわざ<code>asSequence()</code>を呼び出して明示的な変換をさせるのでしょうか？もしくはなぜCollectionでもFunctional functionを呼び出せるようにしているのでしょうか？これはつまり、SequenceがCollectionよりも性能がよくなるのは「とある条件下に限る」ということではないでしょうか。なので、今回は主に性能の観点から、CollectionとSequenceの違いについて述べましょう。</p><h3 id=lazy-evaluation>Lazy evaluation</h3><p>KotlinのSequenceは、元々JavaのStreamと同じ名前になる予定だったそうです。これはただの偶然ではなく、実際の処理もStreamに似ているからです。何が似ているかというと、<a class=link href=https://ja.wikipedia.org/wiki/%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1 target=_blank rel=noopener>Lazy evaluation</a>という概念です。これは簡単に言いますと、「なるべく処理を遅延させる = 必要とされるまでは処理をしない」ということですね。そして多くの場合、Sequenceを使うとこのLazy evaluationのおかげで性能がよくなるという話があります。これはつまり、Sequenceは処理を遅延することでCollectionより良い性能を期待できる、ということになるでしょう。</p><p>しかし、単純に処理を遅延させることががなぜ性能を向上させる事になるのか、すぐに納得は行きません。まず、ループ処理の中で「必要によって処理をするかどうかを決定する」という概念がピンと来ないですね。我々が認識しているループ処理とは、対象となるデータモデルの全要素を巡回しながら処理をするという意味ですので。</p><p>だからSequenceを使った方が性能がよくなると言っても、パフォーマンスはさまざまな要素によって劣化も向上もするものなので、その話だけを信じて全ての処理をSequenceに変えるということは危ないです。そもそもSequenceがそんなに良いものであれば、全てのIterableなオブジェクトをなぜSequenceとして処理しないか、という疑問も湧いてきますね。なので、まずはCollectionとSequenceでFunctional functionがどう違うか、コードどそれを実行した結果で説明したいと思います。</p><h4 id=eager-evaluationのcollection>Eager evaluationのCollection</h4><p>CollectionでのFunctional functionは、Eager evalutionと言われています。これはLazy evaluationの逆で、必要とされてなくてもとりあえず処理を行っておくということです。こうする場合期待できることは、メモリ上にすでに処理の結果が残っていて、複数回呼ばれた場合はそのキャッシュを使うことができるということですね。</p><p>Eager evaluationだと、Functional functionが呼ばれるたび、その全要素に対しての処理をまず行うことになります。例えば、以下のような処理を書いたとしましょう。<code>onEach()</code>は処理の流れを視覚化するためのものです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>listOf(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>)
</span></span><span style=display:flex><span>    .filter { <span style=color:#ff79c6>it</span> %<span style=color:#bd93f9>2</span> <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> }
</span></span><span style=display:flex><span>    .onEach { println(<span style=color:#f1fa8c>&#34;Found even: </span><span style=color:#f1fa8c>$it</span><span style=color:#f1fa8c>&#34;</span>) }
</span></span><span style=display:flex><span>    .map { <span style=color:#ff79c6>it</span>.toString() }
</span></span><span style=display:flex><span>    .onEach { println(<span style=color:#f1fa8c>&#34;Now </span><span style=color:#f1fa8c>$it</span><span style=color:#f1fa8c> is String&#34;</span>) }
</span></span><span style=display:flex><span>    .take(<span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>    .onEach { println(<span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>$it</span><span style=color:#f1fa8c> has taken&#34;</span>) }
</span></span></code></pre></div><p>このコードを実行した結果は以下の通りです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Found even: <span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span>Found even: <span style=color:#bd93f9>4</span>
</span></span><span style=display:flex><span>Found even: <span style=color:#bd93f9>6</span>
</span></span><span style=display:flex><span>Found even: <span style=color:#bd93f9>8</span>
</span></span><span style=display:flex><span>Found even: <span style=color:#bd93f9>10</span>
</span></span><span style=display:flex><span>Now <span style=color:#bd93f9>2</span> is String
</span></span><span style=display:flex><span>Now <span style=color:#bd93f9>4</span> is String
</span></span><span style=display:flex><span>Now <span style=color:#bd93f9>6</span> is String
</span></span><span style=display:flex><span>Now <span style=color:#bd93f9>8</span> is String
</span></span><span style=display:flex><span>Now <span style=color:#bd93f9>10</span> is String
</span></span><span style=display:flex><span><span style=color:#bd93f9>2</span> has taken
</span></span><span style=display:flex><span><span style=color:#bd93f9>4</span> has taken
</span></span><span style=display:flex><span><span style=color:#bd93f9>6</span> has taken
</span></span></code></pre></div><p>つまり、CollectionでのFunctional functionでは以下のような順で処理します。</p><ol><li>Listからfilterのpredicateに当てはまる要素を探し、その結果でListを作る</li><li>filterされたListの要素をmapし、その結果でListを作る</li><li>mapされたListの要素からtakeする</li></ol><p>これを絵で表現すると以下の通りです。</p><p><figure class=gallery-image style=flex-grow:262;flex-basis:630px><a href=/posts/kotlin-collection-and-sequence/kotlin_list_processing.png data-size=990x377><img src=/posts/kotlin-collection-and-sequence/kotlin_list_processing.png width=990 height=377 srcset="/posts/kotlin-collection-and-sequence/kotlin_list_processing_hu8247a2d18d26f289432d35b2d30aabb1_33214_480x0_resize_box_3.png 480w, /posts/kotlin-collection-and-sequence/kotlin_list_processing_hu8247a2d18d26f289432d35b2d30aabb1_33214_1024x0_resize_box_3.png 1024w" loading=lazy alt="Kotlin List Processing"></a><figcaption>Kotlin List Processing</figcaption></figure><em>出典：Kotlin公式ドキュメント - <a class=link href=https://kotlinlang.org/docs/sequences.html#iterable target=_blank rel=noopener>Sequences</a></em></p><h5 id=collectionのopreation>Collectionのopreation</h5><p>Collectionでの処理は上記の通りですが、実装としてはどうでしょうか。ここではCollectionでの<code>map()</code>のコードを見ていきたいと思います。コードとしては以下のようになっています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>inline</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>, <span style=color:#50fa7b>R</span>&gt; <span style=color:#50fa7b>Iterable</span>&lt;T&gt;.map(transform: (T) <span style=color:#ff79c6>-&gt;</span> R): List&lt;R&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(<span style=color:#bd93f9>10</span>)), transform)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>mapTo()</code>という関数に、元のCollectionのサイズで新しくインスタンスを作成した<code>ArrayList</code>とLambdaを渡しています。ちなみに<code>collectionSizeOrDefault()</code>という関数は、以下のような実装となっています。Collectionである場合はそのサイズを、そうでない場合（Sequenceなど）はデフォルトとして10のサイズを持つListになるということがわかりますね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>internal</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>&gt; <span style=color:#50fa7b>Iterable</span>&lt;T&gt;.collectionSizeOrDefault(default: Int): Int = <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>this</span> <span style=color:#ff79c6>is</span> Collection&lt;*&gt;) <span style=color:#ff79c6>this</span>.size <span style=color:#ff79c6>else</span> default
</span></span></code></pre></div><p>また、<code>mapTo()</code>という関数の中では、元のCollectionをループしながら新しいListにLambdaの実行結果を追加するという実装となっています。実際のコードは、以下の通りです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>inline</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>, <span style=color:#50fa7b>R</span>, <span style=color:#50fa7b>C</span> : <span style=color:#50fa7b>MutableCollection</span>&lt;<span style=color:#ff79c6>in</span> <span style=color:#50fa7b>R</span>&gt;&gt; <span style=color:#50fa7b>Iterable</span>&lt;T&gt;.mapTo(destination: C, transform: (T) <span style=color:#ff79c6>-&gt;</span> R): C {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (item <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>this</span>)
</span></span><span style=display:flex><span>        destination.add(transform(item))
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> destination
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ここでわかるのは、一つのFunctional functionが呼ばれるたびにListに対するループが発生し、さらに新しいListを作ることになるということです。なので上記のサンプルコードの場合だとループは6回、Listの作成は4回であるといえます。<code>onEach()</code>を除外するとしてもループは3回なので、かなり多い印象ですね。</p><p>ここで考えられるものは、「Sequenceの方が性能がいい」という話は、Sequenceを使った場合にこのようなループ回数やListの作成を減らせられるということになるのではないか、ということですね。Sequenceではどんな処理をしていて、実際にこのようなループやListを作る回数などを減らしているということでしょうか。同じ処理を書いた場合にSequenceではどのようなことが起きるかを見ていきましょう。</p><h4 id=lazy-evaluationのsequence>Lazy evaluationのSequence</h4><p>Collectionは、<code>asSequence()</code>を呼び出すことで簡単にSequenceによる処理に変換することができます。ただ、このコードを実際に走らせるためにはJavaのStreamと同じく終端処理が必要となるのがポイントです。これも「必要とされるまでは実際の処理を行わない」Lazy evaluationの特徴といえます。例えば以下のようなコードを書いたとしましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>listOf(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>, <span style=color:#bd93f9>4</span>, <span style=color:#bd93f9>5</span>, <span style=color:#bd93f9>6</span>, <span style=color:#bd93f9>7</span>, <span style=color:#bd93f9>8</span>, <span style=color:#bd93f9>9</span>, <span style=color:#bd93f9>10</span>)
</span></span><span style=display:flex><span>    .asSequence() <span style=color:#6272a4>// Sequenceに変換
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    .filter { <span style=color:#ff79c6>it</span> %<span style=color:#bd93f9>2</span> <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> }
</span></span><span style=display:flex><span>    .onEach { println(<span style=color:#f1fa8c>&#34;Found even: </span><span style=color:#f1fa8c>$it</span><span style=color:#f1fa8c>&#34;</span>) }
</span></span><span style=display:flex><span>    .map { <span style=color:#ff79c6>it</span>.toString() }
</span></span><span style=display:flex><span>    .onEach { println(<span style=color:#f1fa8c>&#34;Now </span><span style=color:#f1fa8c>$it</span><span style=color:#f1fa8c> is String&#34;</span>) }
</span></span><span style=display:flex><span>    .take(<span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>    .onEach { println(<span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>$it</span><span style=color:#f1fa8c> has taken&#34;</span>) }
</span></span><span style=display:flex><span>    .toList() <span style=color:#6272a4>// Collectionに再変換（終端処理で処理を走らせる）
</span></span></span></code></pre></div><p>このコードを実行した結果は以下の通りです。Collectionの場合と結果は同じであるものの、処理の順番が変わっていることを確認できます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Found even: <span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span>Now <span style=color:#bd93f9>2</span> is String
</span></span><span style=display:flex><span><span style=color:#bd93f9>2</span> has taken
</span></span><span style=display:flex><span>Found even: <span style=color:#bd93f9>4</span>
</span></span><span style=display:flex><span>Now <span style=color:#bd93f9>4</span> is String
</span></span><span style=display:flex><span><span style=color:#bd93f9>4</span> has taken
</span></span><span style=display:flex><span>Found even: <span style=color:#bd93f9>6</span>
</span></span><span style=display:flex><span>Now <span style=color:#bd93f9>6</span> is String
</span></span><span style=display:flex><span><span style=color:#bd93f9>6</span> has taken
</span></span></code></pre></div><p>ここでわかるのは、そもそも8と10に対しての処理は行われてないということです。これはCollectionで全要素に対して一つのFunctional functionの処理が終わったあと、次のFunctional functionが実行される構造に対して、Sequenceは一つの要素に対しての全ての処理が終わったあと次の要素に対して同じ処理を繰り返しているということです。言葉で表現すると複雑ですが、以下のような順になっているということです。</p><ol><li>Listの要素にfilterを当てる</li><li>要素がfilterのpredicateに当てはまるものなら次の処理に移行する</li><li>filterされた要素をmapする</li><li>mapされた要素をtakeする</li><li>次の要素に対して同じ処理を繰り返す</li></ol><p>これを絵で表現すると以下の通りです。</p><p><figure class=gallery-image style=flex-grow:231;flex-basis:556px><a href=/posts/kotlin-collection-and-sequence/kotlin_sequence_processing.png data-size=990x427><img src=/posts/kotlin-collection-and-sequence/kotlin_sequence_processing.png width=990 height=427 srcset="/posts/kotlin-collection-and-sequence/kotlin_sequence_processing_huad9a91ec7000e356fa550a56d0b6e8a9_37351_480x0_resize_box_3.png 480w, /posts/kotlin-collection-and-sequence/kotlin_sequence_processing_huad9a91ec7000e356fa550a56d0b6e8a9_37351_1024x0_resize_box_3.png 1024w" loading=lazy alt="Kotlin Sequence Processing"></a><figcaption>Kotlin Sequence Processing</figcaption></figure><em>出典：Kotlin公式ドキュメント - <a class=link href=https://kotlinlang.org/docs/sequences.html#sequence target=_blank rel=noopener>Sequences</a></em></p><p>処理の順番や仕組みが違うので、Collectionの時とは実装もかなり違うだろうと予想ができますね。では、こちらの実装を見ていきましょう。</p><h5 id=sequenceでのoperation>Sequenceでのoperation</h5><p>Collectionと同じく、Sequenceの<code>map()</code>の実装を覗いてみましょう。先程のコードでSequenceの<code>map()</code>は中間処理であり、新しいCollectionを作り出すわけではないということはわかりました。実装を見ると、以下のようになっていて、処理結果が反映されたSequenceを返しているのがわかります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>, <span style=color:#50fa7b>R</span>&gt; <span style=color:#50fa7b>Sequence</span>&lt;T&gt;.map(transform: (T) <span style=color:#ff79c6>-&gt;</span> R): Sequence&lt;R&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> TransformingSequence(<span style=color:#ff79c6>this</span>, transform)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ただ、内部で<code>TransformingSequence</code>という新しいSequenceのインスタンスを作成しているのがわかりますね。このクラスの実装は以下の通りです。ここでループごとにLambdaの実行が行われていますね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>internal</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>TransformingSequence</span>&lt;T, R&gt;
</span></span><span style=display:flex><span><span style=color:#ff79c6>constructor</span>(<span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> sequence: Sequence&lt;T&gt;, <span style=color:#ff79c6>private</span> <span style=color:#ff79c6>val</span> transformer: (T) <span style=color:#ff79c6>-&gt;</span> R) : Sequence&lt;R&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>override</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>iterator</span>(): Iterator&lt;R&gt; = <span style=color:#ff79c6>object</span> : <span style=color:#50fa7b>Iterator</span>&lt;R&gt; {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>val</span> iterator = sequence.iterator()
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>override</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>next</span>(): R {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> transformer(iterator.next())
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>override</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>hasNext</span>(): Boolean {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> iterator.hasNext()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>internal</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>E</span>&gt; <span style=color:#50fa7b>flatten</span>(iterator: (R) <span style=color:#ff79c6>-&gt;</span> Iterator&lt;E&gt;): Sequence&lt;E&gt; {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> FlatteningSequence&lt;T, R, E&gt;(sequence, transformer, iterator)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上のコードの実行結果と実装でわかるように、Sequenceを使う場合は一つの要素を単位として処理を行っていくので、CollectionでFunctional functionを使う場合に発生し得る不要な処理(毎回Listを生成する、前要素に対してmapを行うなど)を減らせると期待できます。なので元のCollectionが大きい場合やoperationが多い場合はSequenceの方がより良いように見えます。</p><p>ただ、性能の観点で考えると、CollectionとSequenceの違いはもう一つ考慮すべきところがあります。それはデータ構造の違いです。</p><h2 id=stateless>Stateless</h2><p>JavaのStreamでもそうでしたが、Sequenceは状態(State)を持たないのが特徴です。ここで状態を持たないということは、持っている要素の数や順番などに対しての情報がないということを意味します。なぜかというと、SequenceがIteratorに基づいているものだからです。そしてそれが原因で、処理の種類によってCollectionよりも性能は劣る可能性もまたあります。</p><p>先に使っていたサンプルコードを持って考えてみましょう。サンプルコードでは、Sequenceの終端処理としてListを返すために<code>toList()</code>を呼び出していました。これは、「状態を持たない」ものから「状態を持つ」ものに変換することですね。簡単なやり方としては、MutableなListを作って、全要素を一つづつ<code>add()</code>していく方法があるでしょう。実際はどうでしょうか？まずは<code>toList()</code>のコードをみてみましょう。以下がその実装です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>&gt; <span style=color:#50fa7b>Sequence</span>&lt;T&gt;.toList(): List&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>this</span>.toMutableList().optimizeReadOnlyList()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>まずMutableなListに変換して、さらに読み込み専用（Immutable）のListに変換しているように見えます。さらにMutable Listに変えているところの実装をみてみましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>&gt; <span style=color:#50fa7b>Sequence</span>&lt;T&gt;.toMutableList(): MutableList&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> toCollection(ArrayList&lt;T&gt;())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ArrayListのインスタンスを作って、それを<code>toCollection()</code>に渡していますね。ここで<code>toCollection()</code>はSequenceをCollectionに帰る時の共通処理で、型を指定にするため引数にListを渡しているようです。さらに<code>toCollection()</code>の実装をみていきましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>, <span style=color:#50fa7b>C</span> : <span style=color:#50fa7b>MutableCollection</span>&lt;<span style=color:#ff79c6>in</span> <span style=color:#50fa7b>T</span>&gt;&gt; <span style=color:#50fa7b>Sequence</span>&lt;T&gt;.toCollection(destination: C): C {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> (item <span style=color:#ff79c6>in</span> <span style=color:#ff79c6>this</span>) {
</span></span><span style=display:flex><span>        destination.add(item)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> destination
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ここまでたどり着いてわかったのは、やはりSequenceの要素を一つ一つListの中に入れているということですね。ただ、単純な処理ではありますが、ここでは「Listに要素を足していく」ということ自体に注目する必要があります。</p><p>先に述べた通り、Sequenceは自分が持つ要素の数をわからないので、Listのインスタンスを作る時はサイズを「仮定」して処理するしかないです。そして基本的にMutableなListでは、現在のサイズよりも多くの要素を追加する必要がある時、内部のArrayより大きいサイズのArrayを新しく作り、そこに要素をコピーしていくことを繰り返します。そしてこれを全要素が揃うまで繰り返していきますね。ということは、Sequenceの要素が多ければ多いほどArrayのインタンス作成とコピーが多くなるということになります。</p><p>そしてコピーが全部終わった場合、実際の要素数よりArrayのサイズが大きい場合もありますね。その場合、メモリを無駄に使うだけでなく、実際のサイズもわからなくなるので、サイズを要素数に合わせて再調整する必要があります。<code>toList()</code>の実装で最後に<code>optimizeReadOnlyList()</code>を呼び出しているのは、おそらくその理由でしょう。<code>optimizeReadOnlyList()</code>の実装は以下の通りです。やはりサイズを再調整していますね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>internal</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span>&gt; <span style=color:#50fa7b>List</span>&lt;T&gt;.optimizeReadOnlyList() = <span style=color:#ff79c6>when</span> (size) {
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>-&gt;</span> emptyList()
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>1</span> <span style=color:#ff79c6>-&gt;</span> listOf(<span style=color:#ff79c6>this</span>[<span style=color:#bd93f9>0</span>])
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>-&gt;</span> <span style=color:#ff79c6>this</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>これでわかるように、Sequenceを使って処理したあと、Collectionにまとめるなら要素数が多ければ多いほどCollectionよりも性能が劣化する可能性は確かに存在します。CollectionでFunctional functionを呼び出す際にListを作るとしても、すでに要素数はわかっているので、Listのサイズが合わないためのArrayの生成とコピーの処理は不要ですね。なのでCollectionとSequenceのどちらを選ぶかの問題はFunctional functionを呼び出す回数や処理の種類だけでなく、要素の数まで考える必要がありそうです。</p><p>ただ、要素数が多い場合でも、終端処理の種類によってはSequenceの方が有利になる可能性もなくはないです。例えば<code>forEach()</code>や<code>onEach()</code>など、個別の要素に対して処理を行うだけの場合は依然としてSequenceの方で良い性能を期待できるでしょう。</p><p>要素数が多い場合に性能に影響する処理としてもう一つ考えられるのは、Sequenceを使う場合でも呼び出せるFunctional functionの中で明らかに「状態を必要とする」ものがあるということです。例えば以下の一覧のようなものです。</p><ul><li>どんな要素が含まれているかわかる必要がある<ul><li><code>distinct()</code></li><li><code>average()</code></li><li><code>min()</code></li><li><code>max()</code></li><li><code>take()</code></li></ul></li><li>要素の順番をわかる必要がある<ul><li><code>indexOf()</code></li><li><code>mapIndexed()</code></li><li><code>flatMapIndexed()</code></li><li><code>elementAt()</code></li><li><code>filterIndexed()</code></li><li><code>foldIndexed()</code></li><li><code>forEachIndexed()</code></li><li><code>reduceIndexed()</code></li><li><code>scanIndexed()</code></li></ul></li></ul><p>これらの処理をSequenceではどうしているのでしょうか。まずはその実装を覗いてみる必要がありそうですね。ここでは<code>sort()</code>の方をみていきたいと思います。実装は以下のようになっています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>fun</span> &lt;<span style=color:#50fa7b>T</span> : <span style=color:#50fa7b>Comparable</span>&lt;<span style=color:#50fa7b>T</span>&gt;&gt; <span style=color:#50fa7b>Sequence</span>&lt;T&gt;.sorted(): Sequence&lt;T&gt; {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>object</span> : <span style=color:#50fa7b>Sequence</span>&lt;T&gt; {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>override</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>iterator</span>(): Iterator&lt;T&gt; {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>val</span> sortedList = <span style=color:#ff79c6>this</span>@sorted.toMutableList()
</span></span><span style=display:flex><span>            sortedList.sort()
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span> sortedList.iterator()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>単純ですが、Sequenceを一度Listに変換してsortした後、またSequenceに変えて返していますね。ここでListに変えるために呼び出している関数は<code>toMutableList()</code>なので、結局<code>toList()</code>を呼び出す場合と同じようなことが起きるということです。なので、状態を必要とする操作の場合は要素数が多ければ多いほど性能はCollectionより劣化しやすい、ということがわかります。</p><p>ただ、逆に状態が必要にならない場合は、Collectionと違って中間結果のListを作成しなくなるので、依然としてSequenceが良い性能を見せるだろうと思えます。</p><h2 id=最後に>最後に</h2><p>だいぶ話が長くなりましたが、性能の観点でどれを選ぶべきか、という話の結論としては、「どんな処理をするか」によるということになりますね。簡単に整理すると、以下のようになるかと思います。</p><div class=table-wrapper><table><thead><tr><th>条件</th><th>おすすめ</th></tr></thead><tbody><tr><td>処理が複雑</td><td>Sequence</td></tr><tr><td>処理した結果としてCollectionが必要</td><td>Collection</td></tr><tr><td>ループするだけ</td><td>Sequence</td></tr><tr><td>処理に状態が必要</td><td>Collection</td></tr><tr><td>要素数が多い</td><td>Sequence</td></tr><tr><td>要素数が少ない</td><td>Collection</td></tr></tbody></table></div><p>もちろんこれらの条件が複数ある場合も十分考えられるので、必要な処理が何かをよく考えてどちらを使うかを慎重に考える必要がありそうです。多くの場合とりあえずCollectionを使うという方針だとしても特に問題はなさそうな気はしますが…</p><p>この度はKotlinにおいてのSequenceを紹介しましたが、実はイラストを含めてわかりやすく説明している<a class=link href=https://typealias.com/guides/when-to-use-sequences target=_blank rel=noopener>いつSequenceを使うべきか</a>という良い記事があるので、Sequenceについてより深く理解したい方にはこちらを参考した方が良さそうな気がします。</p><p>また、ここではKotlinのAPIでの処理のみを紹介しましたが、JavaのStreamを使う場合、Sequenceと違って<code>parallelStream()</code>を呼び出すことができます。なので並列で処理しても良い場合には、CollectionとSequenceのみでなく、Streamを使うことを検討するのもありですね。</p><p>では、また！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/kotlin/>kotlin</a>
<a href=/tags/java/>java</a>
<a href=/tags/stream/>stream</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/posts/kotlin-how-to-kotlin-like/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinはどう書いたらいいか</h2></div></a></article><article class=has-image><a href=/posts/kotlin-write-csv/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>data classのListをCSVにする</h2></div></a></article><article class=has-image><a href=/posts/kotlin-prospect/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinのこれからを語る</h2></div></a></article><article class=has-image><a href=/posts/effective-kotlin/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Effective Kotlinを読む</h2></div></a></article><article class=has-image><a href=/posts/kotlin-japanese-era/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinで和暦を使う</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2023 Korean-man in Tokyo</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.7.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#処理方式の違い>処理方式の違い</a><ol><li><a href=#lazy-evaluation>Lazy evaluation</a><ol><li><a href=#eager-evaluationのcollection>Eager evaluationのCollection</a></li><li><a href=#lazy-evaluationのsequence>Lazy evaluationのSequence</a></li></ol></li></ol></li><li><a href=#stateless>Stateless</a></li><li><a href=#最後に>最後に</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>