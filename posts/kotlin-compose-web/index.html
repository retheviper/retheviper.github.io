<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="世の中にはさまざまなプログラミング言語があり、それぞれの特徴も明確で、言語ごとにできる・できないことも違うケースが多いですね。企業ならエンジ"><title>Kotlinだけでファイルサーバを作ってみた</title><link rel=canonical href=https://retheviper.github.io/posts/kotlin-compose-web/><link rel=stylesheet href=/scss/style.min.fbb68fe51fb77bdd639dccfe1c7b590d2330cf8b81da91f1585b35c3d07fbac8.css><meta property="og:title" content="Kotlinだけでファイルサーバを作ってみた"><meta property="og:description" content="世の中にはさまざまなプログラミング言語があり、それぞれの特徴も明確で、言語ごとにできる・できないことも違うケースが多いですね。企業ならエンジ"><meta property="og:url" content="https://retheviper.github.io/posts/kotlin-compose-web/"><meta property="og:site_name" content="Korean-man in Tokyo"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="kotlin"><meta property="article:tag" content="compose"><meta property="article:tag" content="gui"><meta property="article:published_time" content="2022-10-10T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-10T00:00:00+00:00"><meta property="og:image" content="https://retheviper.github.io/images/kotlin.jpg"><meta name=twitter:title content="Kotlinだけでファイルサーバを作ってみた"><meta name=twitter:description content="世の中にはさまざまなプログラミング言語があり、それぞれの特徴も明確で、言語ごとにできる・できないことも違うケースが多いですね。企業ならエンジ"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://retheviper.github.io/images/kotlin.jpg"><link rel=apple-touch-icon sizes=57x57 href=/favicon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/favicon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/favicon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/favicon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/favicon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/favicon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/favicon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/favicon/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><script async src="https://www.googletagmanager.com/gtag/js?id=G-BYJBEJB6DX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BYJBEJB6DX",{anonymize_ip:!1})}</script></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/kotlin-compose-web/><img src=/../../images/kotlin.jpg loading=lazy alt="Featured image of post Kotlinだけでファイルサーバを作ってみた"></a></div><div class=article-details><header class=article-category><a href=/categories/kotlin/ style=background-color:#2a9d8f;color:#fff>kotlin</a></header><h2 class=article-title><a href=/posts/kotlin-compose-web/>Kotlinだけでファイルサーバを作ってみた</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Oct 10, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>15 minute read</time></div></footer></div></header><section class=article-content><p>世の中にはさまざまなプログラミング言語があり、それぞれの特徴も明確で、言語ごとにできる・できないことも違うケースが多いですね。企業ならエンジニアの採用や費用など現実的な観点から技術選定をするので、プロジェクトにおいてどの言語を使うかは明確かつ一般的な基準があるかと思います。しかし、個人のレベルだとチームでの作業を考慮すべきでもなく、その人の好みや慣れというものから言語を選ぶ傾向があるのではないかと思います。なので、割とマイナーな言語やフレームワークを使うケースもあるでしょう。</p><p>自分がまさにそうであって、個人的に使うために実装するアプリや自動化のスクリプトなどは、なるべくKotlinやPythonで作成しています。特にKotlinの場合、仕事でも使っているので最も慣れているからでもありますが、さまざまなフレームワークや言語自体の特徴によりサーバサイドというジャンルやJVMという環境に限らずいろいろなことにチャレンジできるのが魅力的で好きです。</p><p>というわけで、今回もプライベートでちょっと変わった形でウェブアプリを一つ作ってみた、という話です。どこが変わっているかというと、表題にも書いてある通りですが、「Kotlin」だけでファイルサーバのアプリを実装した話となります。</p><h2 id=背景>背景</h2><p>まず、どんなアプリをなぜ作ったかから述べないとですね。私の実家には、以前から使っていたWindowsのパソコンがあります。組み立てたのはおよそ8年ほど前のことで、最近は自分が実家に帰ることも少ないのであまり使われてないです。ただ、今のPC(Mac)からファイルを送ったりもらったりして使うことがあります。</p><p>ここでファイルのやりとりには、今までMicrosoft社の<a class=link href=https://www.microsoft.com/ja-jp/microsoft-365/onedrive/online-cloud-storage target=_blank rel=noopener>OneDrive</a>を使っていました。片方で必要なファイルをOneDriveのフォルダにコピーしておくと、そのファイルがクラウドにアップロードされ、自動的に同期される方式ですね。これでも問題は全然なく安定的に使ってはいましたが、ふと思うとクラウドを経由するというステップが無駄だという気がしました。また、同期の前後でファイルをコピーしたり移動したりすることもめんどい作業になっています。</p><p>ここで、自分でインターネット越しでファイルのやり取りができるアプリを作ってみたらどうかと思ったわけです。すでに自分が思っているような機能を提供している何らかのサービスはあるかもしれませんが、そこまで複雑なものでもないので、数日で作れるような気がしましたのでとりあえずチャレンジしてみることにしました。（SFTPというオプションもありましたが、GUIで楽にしたかったので却下です）</p><h2 id=要件>要件</h2><p>さて、作りたいものがあったらやることは決まっています。いつものことですが、アプリを作る前に簡単に要件を決めておきます。まず、機能的には以下のようなことができれば良いかなと思いました。</p><ul><li>サーバアプリを起動すると、クライアントからサーバのストレージにアクセスできる</li><li>サーバのパスを指定したらその中身（ファイルとフォルダ）が見える</li><li>フォルダをクリックすると表示中のパスが変わる</li><li>ファイルをクリックするとダウンロードできる</li><li>パスにファイルをアップロードできる</li></ul><p>機能が決まったらそれを実現するための技術の番ですね。ここでは、何よりもKotlinで全て解決したい！という考えで、技術選定は全てKotlinを中心にしています。</p><p>まずFrontendでは、ちょうどこないだ<a class=link href=https://www.jetbrains.com/lp/compose-desktop/ target=_blank rel=noopener>Compose for Desktop</a>で簡単なアプリを作ったとこのブログに書いたことがありましたが、<a class=link href=https://compose-web.ui.pages.jetbrains.team/ target=_blank rel=noopener>Compose for Web</a>というものもあったので、今回はこれを使ってみるとどうかなと思いました。これに関しては言語を統一したいという理由が最も大きいのですが、他にはFrontendの経験や知識があんまりないので少しでも触れてみた技術を使いたかったという理由もあります。</p><p>Backendのフレームワークは<a class=link href=https://ktor.io/ target=_blank rel=noopener>Ktor</a>にすることとしました。普段はSpringをやっているのでこちらの場合もあまり本格的な経験があるわけではありませんが、以前触れてみた感覚だとアプリの起動がはやく、実装も簡単だったので採用。また同じく、最も大きい理由はKotlin用ということです。</p><p>大きくはこの二つで、他にも当然色々とライブラリなどが必要となるわけですが、ここは実装を進めながら必要なものがKotlin製かJetBrainsのものかを基準に選んで実装することにしました。もしくは実装において参考となるだろう公式のドキュメントに出てくるものを採用するという方針です。</p><h2 id=frontend>Frontend</h2><p>Frontendでは、先に述べた通りCompose for Webを使いました。やはり初めてということもあったのですが、まだ新しい技術だったり、そもそも自分がFrontendに対してあまりわかってないということもあったので最も工数がかかった部分です。ここについては、肌で感じたことを良かった点・思ったことと違った点・問題だった点という三つの軸で分けて述べていきたいと思います。</p><h3 id=良かった点>良かった点</h3><p>良かった点としては、やはりComposeでデスクトップアプリを作ってみた経験を活かした実装ができたというところです。Composeでは<a class=link href=https://developer.android.com/jetpack/compose/state#state-in-composables target=_blank rel=noopener><code>remember</code>と<code>MutableState&lt;T></code></a>を組み合わせて状態を管理したり、<a class=link href=https://developer.android.com/reference/kotlin/androidx/compose/runtime/Composable target=_blank rel=noopener>@Composable</a>をつけた関数の単位で画面の構成要素を分けて実装することができますが、ここでもそれは同じでした。</p><p>なので、「指定したパスをブラウズ」する機能を実装した時、「一つ前のパスに戻る機能を追加したいな」と思ったときはそのパスを保持するために状態にパスを持たせたり、サーバから取得したパスの中身のオブジェクト（ファイルやフォルダなど）を画面に描画するためのコンポーネントを一つの<code>@Composable</code>関数として定義して使ったりなどが思ったよりも簡単にできたわけです。</p><p>他にもKotlinなのでCoroutineが簡単に使えたり、サーバサイドと同じリポジトリにソースコードを作成できるというところも良いところでした。特に後者の場合、GradleでKotlinのプラグインを<code>multiplatform</code>にすることでFrontendではJavaScriptにコンパイルされ、サーバサイドではいつも通りJVMのバイトコードにコンパイルされるようにできるという点がお気に入りです。</p><h3 id=思ったことと違った点>思ったことと違った点</h3><p>自分の考えが甘かったのですが、Desktopとはかなり違うところがありました。何かというと、言語としてはKotlinを使うとしても、HTMLやCSSを排除することはできないという点です。ここでもやはり<code>div</code>や<code>form</code>のようなタグを使ったり、タグにマウスオーバ時のカーソルを変えるためにタグの<code>attr</code>を変更する必要がありました。例えば、以下はファイルアップロードのコンポーネントですが、Kotlinで書いているだけで実際はHTMLをそのまま書いているような感覚です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>@Composable
</span></span><span style=display:flex><span><span style=color:#ff79c6>private</span> <span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>FileUploadForm</span>(currentPath: String) {
</span></span><span style=display:flex><span>    Div {
</span></span><span style=display:flex><span>        Form(
</span></span><span style=display:flex><span>            action = <span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>$API</span><span style=color:#f1fa8c>_URL</span><span style=color:#f1fa8c>$ENPOINT</span><span style=color:#f1fa8c>_UPLOAD&#34;</span>,
</span></span><span style=display:flex><span>            attrs = {
</span></span><span style=display:flex><span>                method(<span style=color:#50fa7b>FormMethod</span>.Post)
</span></span><span style=display:flex><span>                encType(<span style=color:#50fa7b>FormEncType</span>.MultipartFormData)
</span></span><span style=display:flex><span>                target(<span style=color:#50fa7b>FormTarget</span>.Blank)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        ) {
</span></span><span style=display:flex><span>            HiddenInput {
</span></span><span style=display:flex><span>                name(<span style=color:#f1fa8c>&#34;target&#34;</span>)
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>value</span>(currentPath)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Input(<span style=color:#50fa7b>InputType</span>.File) { name(<span style=color:#f1fa8c>&#34;file&#34;</span>) }
</span></span><span style=display:flex><span>            Input(<span style=color:#50fa7b>InputType</span>.Submit)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ここは完全に他のプラットフォームでのComposeを使うというよりは、Kotlinようにラップされたクラスを提供するだけという印象が強く、やはりある程度Frontendの知識が必要となる部分ではないかと思っています。なので、<a class=link href=https://reactjs.org/ target=_blank rel=noopener>React</a>や<a class=link href=https://vuejs.org/ target=_blank rel=noopener>Vue.js</a>などメジャーなFrontendのフレームワークの知識がある場合にはあまりComposeを選ぶ理由はなさそうな気がしています。</p><p>他には、いつもとは違ってKotlin/JSとKotlin/JVMが共存するプロジェクトとなっているためか、intellij上の自動補完やビルド時の挙動が少し違う感覚があります。例えば、Gradleで依存関係を変更してもすぐに反映されなかったり…</p><h3 id=問題だった点>問題だった点</h3><p>意外と問題になったのは、プロジェクトのビルドでした。Compose for Webでは<code>index.html</code>ファイルとWebpackなどを使ってビルドされた<code>js</code>ファイルを使うことになり、ビルド自体はGradleのコマンドひとつで簡単にできるものですが、どうやら内部的に<a class=link href=https://yarnpkg.com/ target=_blank rel=noopener>yarn</a>などを使っているようですが、intellijで生成したプロジェクトのデフォルト設定ではビルド時にエラーが出ることが多かったです。</p><p>調べてみると自分のようなエラーが出る場合、<a class=link href=https://github.com/Kotlin/kotlinx-datetime/issues/193 target=_blank rel=noopener>ビルドできない場合はKotlinのバージョンが<code>v1.6.20</code>以降だと解消される</a>らしいのですが、問題はComposeのバージョンでした。このアプリを実装した時点の最新は<a class=link href=https://github.com/JetBrains/compose-jb/releases/tag/v1.1.1 target=_blank rel=noopener>v1.1.1</a>なのですが、これだと対応しているKotlinのバージョンが<code>v1.6.10</code>までです。なので、自分の場合は<code>v1.2.0</code>のベータ版を使ってKotlinのバージョンを<code>v1.7.10</code>にしてから解消できました。これはマイナーなプロジェクトのハマりどころと言えるものかもしれないですね。</p><p>また、HTTPクライアントとしては<a class=link href=https://ktor.io/docs/getting-started-ktor-client.html target=_blank rel=noopener>Ktor Client</a>を使っていますが、大容量のファイルをアップロードする場合を想定して<code>form</code>タグでMultipartのデータを直接送るよりHTTPクライアントを使う方法を取ろうとするとうまくいかなかったです。Ktor ClientはMultiplatform対応のものなので、クライアントの宣言時に<a class=link href=https://ktor.io/docs/http-client-engines.html target=_blank rel=noopener>どのEngineを使うかを選択できる</a>のですが、Kotlin/JSで使えるEngineだと<a class=link href=https://ktor.io/docs/request.html#binary target=_blank rel=noopener>公式で紹介している内容</a>通りに実装しても<code>File</code>オブジェクトを直接扱えないので送信ができませんでした。ここは今後の改善に期待するか、Websocketなどを使うなど他の方法を取る必要がありそうです。</p><h2 id=backend>Backend</h2><p>次にBackendですが、こちらは自分の慣れている分野で、Ktor自体については他のポストでも述べたことがあり、技術的な面の話よりはロジック面で試行錯誤をしたことを中心に述べていきたいと思います。</p><h3 id=ファイルツリーのブラウズ>ファイルツリーのブラウズ</h3><p>このアプリにはまずファイルをブラウズする機能があるので、クライアントで指定したパスを探索して、その中にあるコンテンツ（ファイルとフォルダ）を返す必要があります。問題は、JSONの構造をどうするかですね。ここではまず一つの方法を試してみてから判断することにしました。</p><h4 id=全取得する>全取得する</h4><p>最初は、以下のような形で実装をしようと思いました。パスを指定したら、その配下にある全てのフォルダをたどり、親子関係をネストで表現する形です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;name&#34;</span>: <span style=color:#f1fa8c>&#34;Documents&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;type&#34;</span>: <span style=color:#f1fa8c>&#34;directory&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;children&#34;</span>: [
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>&#34;name&#34;</span>: <span style=color:#f1fa8c>&#34;SomeDocument.pdf&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>&#34;type&#34;</span>: <span style=color:#f1fa8c>&#34;file&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>&#34;size&#34;</span>: <span style=color:#f1fa8c>&#34;1391482&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>&#34;mimeType&#34;</span>: <span style=color:#f1fa8c>&#34;application/pdf&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;name&#34;</span>: <span style=color:#f1fa8c>&#34;Images&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;type&#34;</span>: <span style=color:#f1fa8c>&#34;directory&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;children&#34;</span>: []
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>このようなファイルツリー返すために、サーバ側のコードは以下のようなものを使いました。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// ルートとなるパスを指定すると、子要素（ファイルとフォルダ）を全て取得する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> files =  <span style=color:#50fa7b>Files</span>.list(root)
</span></span><span style=display:flex><span>        .filter { !<span style=color:#ff79c6>it</span>.isHidden() }
</span></span><span style=display:flex><span>        .map { <span style=color:#ff79c6>it</span>.toFileTree() }
</span></span><span style=display:flex><span>        .toList()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// PathをJSONオブジェクトとして加工する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>Path</span>.toFileTree(): FileTree {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> FileTree(
</span></span><span style=display:flex><span>        name = <span style=color:#ff79c6>this</span>.fileName.toString(),
</span></span><span style=display:flex><span>        size = <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>this</span>.isDirectory()) <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>this</span>.fileSize(),
</span></span><span style=display:flex><span>        type = <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>this</span>.isDirectory()) <span style=color:#50fa7b>FileType</span>.DIRECTORY <span style=color:#ff79c6>else</span> <span style=color:#50fa7b>FileType</span>.FILE,
</span></span><span style=display:flex><span>        children = <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>this</span>.isDirectory()) {
</span></span><span style=display:flex><span>            <span style=color:#50fa7b>Files</span>.list(<span style=color:#ff79c6>this</span>)
</span></span><span style=display:flex><span>                .filter { !<span style=color:#ff79c6>it</span>.isHidden() }
</span></span><span style=display:flex><span>                .map { <span style=color:#ff79c6>it</span>.toFileTree() }
</span></span><span style=display:flex><span>                .toList()
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a class=link href=https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walk-java.nio.file.Path-java.nio.file.FileVisitOption...- target=_blank rel=noopener>Files.walk()</a>を使うと、指定したパスを基準にネストされているファイルツリーを全て<code>Stream&lt;Path></code>として取得してくれますが、それだと上記のJSONの形として加工するのが簡単ではないです。一度取得した結果をもとに、親子関係を追跡しながらJSONオブジェクトとしてまとめるにはかなり複雑な処理になるっでしょう。</p><p>なので、ここでは<a class=link href=https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#list-java.nio.file.Path- target=_blank rel=noopener>Files.list()</a>を使って指定したパスに含まれた要素を取得し、その要素がディレクトリの場合はさらに子要素として取得するように再帰を使って子要素を再度取得するという形としてまとめています。単純な処理ですが、効率的になりましたね。</p><p>ただ、この方法で思った通りのファイルツリーをJSONとして返すことはできましたが、問題がありました。まず、指定したパスがルートに近くなればなるほど探索にかかる時間が長くなり、レスポンスも遅く慣ればJSONのサイズも大きくなるという問題がありました。また、JSONを受け取ったところで、Frontendで描画をするにも難点がありそうな気がしました。というわけで、この案はまず廃棄して、二つ目の方法を取ることにしました。</p><h4 id=ネストさせない>ネストさせない</h4><p>次に試した方法は、指定したパスのみに処理を制限することでした。何かというと、JSONオブジェクトのネストを無くして、指定したパスにどんなファイルとフォルダが含まれているかだけをリストとして返すということです。つまり、以下のような形になります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;name&#34;</span>: <span style=color:#f1fa8c>&#34;Documents&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;type&#34;</span>: <span style=color:#f1fa8c>&#34;directory&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;name&#34;</span>: <span style=color:#f1fa8c>&#34;Images&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&#34;type&#34;</span>: <span style=color:#f1fa8c>&#34;directory&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>こうなると、中のフォルダを辿る必要がなくなるのでレルポンスも早く、軽くなるわけです。最初からちゃんと考えるべきだったのですが、こちらの方がFrontendとしても実装が楽であって、さらにサブパスのフォルダにアクセスしたい場合はそのパスを再度Backendに送ればいいだけですね。コードとしては再帰を使わなくなったくらいです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> files =  <span style=color:#50fa7b>Files</span>.list(root)
</span></span><span style=display:flex><span>        .filter { !<span style=color:#ff79c6>it</span>.isHidden() }
</span></span><span style=display:flex><span>        .map { <span style=color:#ff79c6>it</span>.toFileTree() }
</span></span><span style=display:flex><span>        .toList()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// PathをJSONオブジェクトとして加工する
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>Path</span>.toFileTree(): FileTree {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> FileTree(
</span></span><span style=display:flex><span>        name = <span style=color:#ff79c6>this</span>.fileName.toString(),
</span></span><span style=display:flex><span>        size = <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>this</span>.isDirectory()) <span style=color:#ff79c6>null</span> <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>this</span>.fileSize(),
</span></span><span style=display:flex><span>        type = <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>this</span>.isDirectory()) <span style=color:#50fa7b>FileType</span>.DIRECTORY <span style=color:#ff79c6>else</span> <span style=color:#50fa7b>FileType</span>.FILE
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=ファイルアップロード>ファイルアップロード</h3><p>ファイルアップロードについては、Mutlipartとして送られているデータをどう扱うかですが、これはKtorらしく簡単な処理で対応できました。以下のコードが実際の実装となっています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// router
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>post(ENPOINT_UPLOAD) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Multipartデータを受信
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>val</span> multipart = call.receiveMultipart()
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ファイル保存先のパス
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>var</span> path = <span style=color:#50fa7b>Path</span>.of(ROOT_DIRECTORY)
</span></span><span style=display:flex><span>    multipart.forEachPart { part <span style=color:#ff79c6>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>when</span> (part) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// ルートでないパスを指定した場合は保存先を更新
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>is</span> <span style=color:#50fa7b>PartData</span>.FormItem <span style=color:#ff79c6>-&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> (part.name <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;target&#34;</span>) {
</span></span><span style=display:flex><span>                    path = path.resolve(part.<span style=color:#ff79c6>value</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// ファイルデータを保存
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>is</span> <span style=color:#50fa7b>PartData</span>.FileItem <span style=color:#ff79c6>-&gt;</span> {
</span></span><span style=display:flex><span>                withContext(<span style=color:#50fa7b>Dispatchers</span>.IO) {
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>val</span> file = <span style=color:#50fa7b>Files</span>.createFile(path.resolve(part.originalFileName<span style=color:#ff79c6>!!</span>))
</span></span><span style=display:flex><span>                    part.streamProvider().use { input <span style=color:#ff79c6>-&gt;</span>
</span></span><span style=display:flex><span>                        <span style=color:#50fa7b>Files</span>.newOutputStream(<span style=color:#ff79c6>file</span>).use { output <span style=color:#ff79c6>-&gt;</span>
</span></span><span style=display:flex><span>                            input.copyTo(output)
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// どちらでもない場合は一旦出力
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>-&gt;</span> {
</span></span><span style=display:flex><span>                println(<span style=color:#f1fa8c>&#34;Unknown part: </span><span style=color:#f1fa8c>$part</span><span style=color:#f1fa8c>&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 処理の終わったデータはdispose
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        part.dispose()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ただ、個人的にはストレージアクセスのある処理に対してはNIOを使いたいので、はじめは<a class=link href=https://docs.oracle.com/javase/jp/8/docs/api/java/nio/file/Files.html#copy-java.io.InputStream-java.nio.file.Path-java.nio.file.CopyOption...- target=_blank rel=noopener>Files.copy()</a>を使おうと思ったのですが、なぜかファイルの保存処理を以下のような作成するとうまくいかなったです。Coroutineとの相性に何か問題があるのかもしれないですので、ここは注意ですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> file = <span style=color:#50fa7b>Files</span>.createFile(path.resolve(part.originalFileName<span style=color:#ff79c6>!!</span>))
</span></span><span style=display:flex><span><span style=color:#50fa7b>Files</span>.copy(part.streamProvider(), <span style=color:#ff79c6>file</span>) <span style=color:#6272a4>// ファイルが保存されない
</span></span></span></code></pre></div><h3 id=ファイルダウンロード>ファイルダウンロード</h3><p>ファイルダウンロードの場合も、ロジックは特にないので、ほとんどKtorのみのコードとなっています。自分の好みでPathを使っているくらいですのでコードだけを紹介します。ひとつ注意すべきところは、アップロードする時もそうですが、ファイル名を返すときにURLパスとしてエンコードすることですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>get</span>(ENDPOINT_DOWNLOAD) {<span style=color:#ff79c6>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> filepath = call.request.queryParameters[<span style=color:#f1fa8c>&#34;filepath&#34;</span>] <span style=color:#ff79c6>?:</span> <span style=color:#f1fa8c>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> path = <span style=color:#50fa7b>FileService</span>.getFullPath(filepath) <span style=color:#6272a4>// ルートディレクトリからのフルパスを取得
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#ff79c6>if</span> (<span style=color:#50fa7b>Files</span>.notExists(path)) {
</span></span><span style=display:flex><span>        call.respond(<span style=color:#50fa7b>HttpStatusCode</span>.BadRequest, <span style=color:#f1fa8c>&#34;File not found&#34;</span>)
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        call.response.header(
</span></span><span style=display:flex><span>            name = <span style=color:#50fa7b>HttpHeaders</span>.ContentDisposition,
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>value</span> = <span style=color:#50fa7b>ContentDisposition</span>.<span style=color:#50fa7b>Attachment</span>.withParameter(
</span></span><span style=display:flex><span>                key = <span style=color:#50fa7b>ContentDisposition</span>.<span style=color:#50fa7b>Parameters</span>.FileName,
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>value</span> = path.fileName.toString().encodeURLPath()
</span></span><span style=display:flex><span>            ).toString()
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        call.respondFile(path.toFile())
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=注意すべきところ>注意すべきところ</h3><p>まず、一つのプロジェクトにKotlin/JSとKotlin/JVMを両立する場合、<code>dependencies</code>として記述するものに対しては<code>build.gradle.kts</code>ファイルで以下のように指定することができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>kotlin {
</span></span><span style=display:flex><span>    sourceSets {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// Kotlin/JSの依存関係
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>val</span> jsMain <span style=color:#ff79c6>by</span> getting {
</span></span><span style=display:flex><span>            dependencies {
</span></span><span style=display:flex><span>                implementation(compose.web.core)
</span></span><span style=display:flex><span>                implementation(compose.runtime)
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// ...省略
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// Kotlin/JVMの依存関係
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>val</span> jvmMain <span style=color:#ff79c6>by</span> getting {
</span></span><span style=display:flex><span>            dependencies {
</span></span><span style=display:flex><span>                implementation(<span style=color:#f1fa8c>&#34;io.ktor:ktor-server-core-jvm:</span><span style=color:#f1fa8c>$ktor</span><span style=color:#f1fa8c>_version&#34;</span>)
</span></span><span style=display:flex><span>                implementation(<span style=color:#f1fa8c>&#34;io.ktor:ktor-server-auth-jvm:</span><span style=color:#f1fa8c>$ktor</span><span style=color:#f1fa8c>_version&#34;</span>)
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// ...省略
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>しかし、Composeを使うためには<code>plugin</code>として指定する必要があり、これがプロジェクト全体の依存関係に追加されることになっていました。なので、アプリの作りとしてはまずFrontendのComposeをビルドし、サーバを起動したらビルドしたファイルをstaticとして提供する構造になっていますが、Backendの起動にもComposeのランタイムが必要になります。このランタイムを追加してくれないと、エラーが吐き出され、Ktorが起動できなくなっています。何かKotlin/JSのみの依存関係にpluginを追加する他の方法があるかもしれませんが、とりあえずはJVMの依存関係に以下のようにランタイムを追加することで問題は解消できました。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#ff79c6>val</span> jvmMain <span style=color:#ff79c6>by</span> getting {
</span></span><span style=display:flex><span>    dependencies {
</span></span><span style=display:flex><span>        implementation(<span style=color:#f1fa8c>&#34;io.ktor:ktor-server-core-jvm:</span><span style=color:#f1fa8c>$ktor</span><span style=color:#f1fa8c>_version&#34;</span>)
</span></span><span style=display:flex><span>        implementation(<span style=color:#f1fa8c>&#34;io.ktor:ktor-server-auth-jvm:</span><span style=color:#f1fa8c>$ktor</span><span style=color:#f1fa8c>_version&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// ...省略
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        implementation(compose.runtime) <span style=color:#6272a4>// Composeランタイム
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=その他>その他</h2><p>Kotlin/JSとKotlin/JVMを一つのプロジェクトとして扱う場合に、<code>common</code>というパッケージを設けることで、コードの共有ができるのが何より嬉しかったところです。例えば、JSONオブジェクトをdata classとして定義してcommonパッケージに置くことで、FrontendとBackendの両方で同じオブジェクトを使うことができます。他にももちろんEnumやconstを共有できたりするので、実装がかなり楽でした。</p><p>また、今回は採用しなかったのですが、Ktor Serverの場合<a class=link href=https://ktor.io/docs/type-safe-routing.html#resource_classes target=_blank rel=noopener>Type-safe Routing</a>というものに対応しているので、うまく活用できたらかなり良さそうな気がしました。これはKtor Clientでも<a class=link href=https://ktor.io/docs/type-safe-request.html#define_route target=_blank rel=noopener>Type-safe Request</a>として対応しているので、FrontendとBackend両方で使える機能です。またKtorを使う機会があったら、ぜひ使ってみたいと思っています。</p><h2 id=最後に>最後に</h2><p>ファイルアップロードが思った通り改善できなかったので、アプリの完成はまだ少し先のことになりそうですが、かなり面白い経験となりました。Kotlinでできることは色々とあるので、また何か作ってみたいものがあればチャレンジしてみたくなります。ただ、やはりまだ成熟してない技術なので、思ってもなかったところで問題が発生したりリファレンスがあまりないという点ではまだプロダクションレベルでは使えないものかなという気がします。</p><p>アプリ全体のコードはGitHubにて公開していますので、<a class=link href=https://github.com/retheviper/FileTransporter target=_blank rel=noopener>こちら</a>から参照できます。</p><p>では、また！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/kotlin/>kotlin</a>
<a href=/tags/compose/>compose</a>
<a href=/tags/gui/>gui</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/posts/kotlin-compose-desktop/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinでデスクトップアプリを作ってみた</h2></div></a></article><article class=has-image><a href=/posts/kotlin-conf-2023/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>KotlinConf'23を要約してみた</h2></div></a></article><article class=has-image><a href=/posts/kotlin-how-to-kotlin-like/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinはどう書いたらいいか</h2></div></a></article><article class=has-image><a href=/posts/kotlin-if-to-non-if/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>ifでの分岐を考える</h2></div></a></article><article class=has-image><a href=/posts/kotlin-write-csv/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>data classのListをCSVにする</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2023 Korean-man in Tokyo</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.7.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#背景>背景</a></li><li><a href=#要件>要件</a></li><li><a href=#frontend>Frontend</a><ol><li><a href=#良かった点>良かった点</a></li><li><a href=#思ったことと違った点>思ったことと違った点</a></li><li><a href=#問題だった点>問題だった点</a></li></ol></li><li><a href=#backend>Backend</a><ol><li><a href=#ファイルツリーのブラウズ>ファイルツリーのブラウズ</a><ol><li><a href=#全取得する>全取得する</a></li><li><a href=#ネストさせない>ネストさせない</a></li></ol></li><li><a href=#ファイルアップロード>ファイルアップロード</a></li><li><a href=#ファイルダウンロード>ファイルダウンロード</a></li><li><a href=#注意すべきところ>注意すべきところ</a></li></ol></li><li><a href=#その他>その他</a></li><li><a href=#最後に>最後に</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>