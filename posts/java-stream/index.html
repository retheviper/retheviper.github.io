<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="個人的には、関数型プログラミングにあまり詳しくはないですが、Java 1.8のStream APIは好んで使っています。他にもLambdaやOp"><title>Streamを正しく使う</title>
<link rel=canonical href=https://retheviper.github.io/posts/java-stream/>
<link rel=stylesheet href=/scss/style.min.1b3ac667198cb83edcc9c45e606a6f4dd6910b8ada6b74d7fd988f1b2dfd0c7c.css><meta property="og:title" content="Streamを正しく使う">
<meta property="og:description" content="個人的には、関数型プログラミングにあまり詳しくはないですが、Java 1.8のStream APIは好んで使っています。他にもLambdaやOp">
<meta property="og:url" content="https://retheviper.github.io/posts/java-stream/">
<meta property="og:site_name" content="Korean-man in Tokyo">
<meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="stream"><meta property="article:tag" content="java"><meta property="article:published_time" content="2020-04-06T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-06T00:00:00+00:00"><meta property="og:image" content="https://retheviper.github.io/images/java.jpg">
<meta name=twitter:title content="Streamを正しく使う">
<meta name=twitter:description content="個人的には、関数型プログラミングにあまり詳しくはないですが、Java 1.8のStream APIは好んで使っています。他にもLambdaやOp"><meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://retheviper.github.io/images/java.jpg">
<link rel=apple-touch-icon sizes=57x57 href=/favicon/apple-icon-57x57.png>
<link rel=apple-touch-icon sizes=60x60 href=/favicon/apple-icon-60x60.png>
<link rel=apple-touch-icon sizes=72x72 href=/favicon/apple-icon-72x72.png>
<link rel=apple-touch-icon sizes=76x76 href=/favicon/apple-icon-76x76.png>
<link rel=apple-touch-icon sizes=114x114 href=/favicon/apple-icon-114x114.png>
<link rel=apple-touch-icon sizes=120x120 href=/favicon/apple-icon-120x120.png>
<link rel=apple-touch-icon sizes=144x144 href=/favicon/apple-icon-144x144.png>
<link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-icon-152x152.png>
<link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-icon-180x180.png>
<link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png>
<link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png>
<link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png>
<link rel=manifest href=/favicon/manifest.json>
<meta name=msapplication-TileColor content="#ffffff">
<meta name=msapplication-TileImage content="/favicon/ms-icon-144x144.png">
<meta name=theme-color content="#ffffff">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-139986442-1','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class="has-image main-article">
<header class=article-header>
<div class=article-image>
<a href=/posts/java-stream/>
<img src=/../../images/java.jpg loading=lazy alt="Featured image of post Streamを正しく使う">
</a>
</div>
<div class=article-details>
<header class=article-category>
<a href=/categories/java/ style=background-color:#2a9d8f;color:#fff>
java
</a>
</header>
<h2 class=article-title>
<a href=/posts/java-stream/>Streamを正しく使う</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 06, 2020</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
10 minute read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<p>個人的には、関数型プログラミングにあまり詳しくはないですが、Java 1.8のStream APIは好んで使っています。他にもLambdaやOptionalといったAPIも好きですが、自分がJavaの資格を取った理由も、このStream APIについてもっと勉強したかったからと言っても過言ではないです。</p>
<p>そんな私ですが、Streamについて勉強している中、疑問が出来ました。Streamは確かにいいAPIですが、伝統的なJavaのAPIとはかなり違うものです。これをJavaに導入したことで得られるメリットがあるから導入されたはず、というのは難しくない推論ですが、逆の場合はどうでしょうか？Streamを使った場合のデメリットは？そして自分が使っているStreamの書き方は正しいのか？などなど。</p>
<p>今回のポストでは、そのような疑問について独自に調査したことを述べていきたいと思います。正解というより、こういう見解があるということとしてご理解ください。</p>
<h2 id=streamは万能か>Streamは万能か？</h2>
<p>まず最初の質問です。Streamは万能か？つまり、既存のコードをすべてStreamに書き換えても問題はないか？そしてなるべくこれから書くコードはStreamに変えるべきなのか？という質問ですね。確かに新しいAPIが出て、既存のコードと同じ役割ができるとしたら、それにはなんらかの理由があります。Javaの場合は、NIOがそうでした。一般的なI/OではOSのカーネルの機能を利用できなかったため、それを改善するために登場しましたね。しかし、NIOもまた、全ての場面で既存のI/Oより優れているとは言えない面がありました。そしたらStreamの場合も、その可能性はあると思いました。</p>
<p>結論からいうと、「全てのコードをStreamに書き換える必要はない」です。その理由を、一つ一つ項目別に説明します。</p>
<h3 id=性能は劣る場合も>性能は劣る場合も</h3>
<p>Java 1.5では、伝統的なFor文意外にも、いわゆる拡張For文というものが登場しました。そして1.8では、Streamと共にforEach()というメソッドもできましたね。しかし、forEach()もStreamも性能は拡張For文より劣ります。また、とあるベンチマークでは、Streamを使った場合の処理はParallelを使っても拡張For文より性能は劣るという結果が出たらしいです。理由は簡単です。Streamを使うと、より複雑な処理が中に入るからです。特に配列をStreamに変換する時はラッピングが入るので、そこでもう処理が加えられるということを考えられますね。</p>
<p>特に、オブジェクトを扱う場合の性能の差はそんなに大きくないものの、プリミティブ型を扱う場合は性能の差がより大きいらしいです。なので無理やり配列をStreamに変えて処理をする必要はありません。StreamやforEach()は、それを持って安定したコードを書けられる場合に限定して使う必要があります。そしてStreamを使う場合もプリミティブ型を扱う場合はIntStreamやToIntStreamといった、それぞれの型に合わせたクラスを使った方がより良い性能を出すので、そこもちゃんと考慮すべきですね。</p>
<p>JVMが長い間伝統的なFor文に最適化されてきて、1.8になってやっと登場したStreamはそれほど最適化されてないので性能が劣るという話もありましたが、これは1.8がリリースされた当時の記事に書いてあったものなので14までバージョンアップがなされた今はどうかという疑問はあります。それでも伝統的なFor文の方がまだ性能では優秀ではないだろうかと思いますが。</p>
<h3 id=途中でやめられない>途中でやめられない</h3>
<p>Streamの処理は一般的なforループとは違って、continueやbreak、returnなどで一部の処理をスキップしたり途中で処理を止めることができません。基本的にStreamは全要素に対して処理をすることを前提にして設計されたからです。なのでそれぞれの目的に合わせて、Streamのメソッドを適切に使い分ける必要があります。例えばFor文での処理は以下のような変えられます。</p>
<ul>
<li>条件に合致する要素だけを処理したい場合(if)
<ul>
<li>filter()</li>
</ul>
</li>
<li>Collectionにしたい場合(add)
<ul>
<li>collect()</li>
</ul>
</li>
<li>要素を取り出したい場合(return)
<ul>
<li>findAny() / findFirst()</li>
</ul>
</li>
</ul>
<h3 id=ループ変数を使用できない>ループ変数を使用できない</h3>
<p>拡張For文ではなく、伝統的なFor文ではループ変数を使って、現在のループが何回目かを数えることができます。しかし、Streamではループ変数を使うことができません。例えば、以下のようにStreamの外部に変数を置いてもコンパイルエラーとなります。</p>
<p>int型のループ変数を使いたい場合はIntStreamを、ループ変数で処理をスキップしたい場合はskip()を使いましょう。もちろん、こういう場合は普通に既存のFor文を使った方が正解に違いです。</p>
<h3 id=そもそもの関数型>そもそもの関数型</h3>
<p>実は、Streamの中でも外部変数をループ変数として使う方法がなくはないです。AtomicIntegerでループ変数を使う方法がありますが、そこまでしてStreamを使う理由もなければ、関数型プログラミングの目的に合いません。</p>
<p>関数型プログラミングのコンセプトの中では不変性(Immutability)というものがあります。以前<a class=link href=../java-thoughts-of-immutable>Immutabilityについて述べたこと</a>がありますが、ここで重要なのはデータが変わることはない、ということです。データが変わらないならどうやって処理が行われるかというと、元のデータはそのままで、処理ではそのデータのコピーを作って作業することになります。</p>
<p>Streaｍを持って処理をする場合に、その結果が新しいインスタンスになるのもそれが理由です。Listをループさせる場合は、元の要素を編集できます。しかし、Streamで処理する場合は変更された要素で構成された新しいListを返すようになりますね。中間操作で元の要素を編集するとしても、Streamは終端操作が終わるとクローズされ再利用できなくなります。これで元のデータは変えずに済みますね。</p>
<p>なのでStreamを使う場面というのは、まず元のデータをどうするかによります。もちろん、Streamを使わない場合でも、関数型的なコードの作成がより場合も多いです。(ということで、まずは関数型プログラミングを勉強ですね…)</p>
<h2 id=streamをより活用する>Streamをより活用する</h2>
<p>次に、Streamを使う場合に、どうしたら正しく、より効率的に活用できるかに関する質問です。Streamは最初から再使用できないようになっていますが、場合によっては同じデータに対してそれぞれ違う処理を行う必要があるのでそれがどうやって実現できるか、という疑問がありました。例えば、普通のFor文だとループの中で分岐を置くことで二つのCollectionに要素を分配するような処理ができるのですが、Streamだと同じオブジェクトに対しての処理はできませんね。こういう場合は同じデータに対してどうやったらStream処理を2回以上できるか気になります。</p>
<p>もう一つは、自分だけなのかも知れませんが、Stream以外でも、メソッドチェーニングを使えるAPIは非効率的な処理が入ってもすごく場合があって、それをどうしたら効率的な書き方にできるかという疑問がありました。例えばCollectionや配列をStreamに変換してからforEach()を使うこともできますが、CollectionだとstreamなしでもforEach()は使えますね。こういう場合は直感的にCollectionのforEach()の方が良さそうだとは思いますが、それ以外の場合はどうなのかよくわかりません。</p>
<p>なので、この二つの疑問についても調査してみました。</p>
<h3 id=再使用>再使用</h3>
<p>Streaｍは何度も繰り返して中間操作が可能ですが、一度でも終端操作が行われるとクローズされ、再利用ができなくなります。なぜなら、Streamの目的はデータの処理であって、データの格納ではないからです。</p>
<p>しかし、たまには同じデータに対してStreamを利用し、それぞれ違う処理を行たい場合もありますね。そういう時はどうしたらいいでしょう。Javaでデータを格納するためのものは配列やCollectionがありますので、必要なデータを予め定義して、場合によってそれをStreamに転換して使う方法があります。配列の場合は<code>Arrays.stream()</code>や<code>Stream.of()</code>があり、Collectionだと<code>stream()</code>がありますね。例えば以下のような方法です。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// Listで必要なデータを集めておく
</span><span class=c1></span><span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>names</span> <span class=o>=</span> 
  <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>(</span><span class=s>&#34;Eric&#34;</span><span class=o>,</span> <span class=s>&#34;Elena&#34;</span><span class=o>,</span> <span class=s>&#34;Java&#34;</span><span class=o>)</span>
  <span class=o>.</span><span class=na>filter</span><span class=o>(</span><span class=n>name</span> <span class=o>-&gt;</span> <span class=n>name</span><span class=o>.</span><span class=na>contains</span><span class=o>(</span><span class=s>&#34;a&#34;</span><span class=o>))</span>
  <span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>Collectors</span><span class=o>.</span><span class=na>toList</span><span class=o>());</span>

<span class=c1>// 1番目のStream
</span><span class=c1></span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>firstElement</span> <span class=o>=</span> <span class=n>names</span><span class=o>.</span><span class=na>stream</span><span class=o>().</span><span class=na>findFirst</span><span class=o>();</span>
<span class=c1>// 2番目のStream
</span><span class=c1></span><span class=n>Optional</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>anyElement</span> <span class=o>=</span> <span class=n>names</span><span class=o>.</span><span class=na>stream</span><span class=o>().</span><span class=na>findAny</span><span class=o>();</span>
</code></pre></div><p>予め必要なデータはListとしてCollectし、必要な場合はそれをまたStreamに変換して使う例でした。データがそもそもCollectionや配列の場合は、必要に応じてstream()を呼び出すことでそれぞれ違う処理ができます。また、peek()を挟むことで違うCollectionにデータを追加することもできます。厳密にいうと再使用というよりはどうStreamを作るかに関する話となりますが、これで一つのデータから複数の処理結果を出すことは可能、ということになります。</p>
<h3 id=短く書く>短く書く</h3>
<p>先に述べましたが、StreamはメソッドチェーニングのできるAPIなので、非効率的なコードを書きやすい傾向がありました。なのでケース別により効率的な書き方を集めてみました。自分はEclipseを主に使っているのですが、Intellijだと、こうした方がいいよとオススメしてくれる部分らしいです。</p>
<ul>
<li>Collectionのメソッドを使う</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// CollectionのForEach
</span><span class=c1></span><span class=n>collection</span><span class=o>.</span><span class=na>stream</span><span class=o>().</span><span class=na>forEach</span><span class=o>()</span> 
  <span class=err>→</span> <span class=n>collection</span><span class=o>.</span><span class=na>forEach</span><span class=o>()</span>
  
<span class=c1>// Collectionを配列に
</span><span class=c1></span><span class=n>collection</span><span class=o>.</span><span class=na>stream</span><span class=o>().</span><span class=na>toArray</span><span class=o>()</span> 
  <span class=err>→</span> <span class=n>collection</span><span class=o>.</span><span class=na>toArray</span><span class=o>()</span>
</code></pre></div><ul>
<li>Streamを作る</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 配列からStreamに
</span><span class=c1></span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>().</span><span class=na>stream</span><span class=o>()</span> 
  <span class=err>→</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>()</span> <span class=o>/</span> <span class=n>Stream</span><span class=o>.</span><span class=na>of</span><span class=o>()</span>

<span class=c1>// 空のStreamを作成
</span><span class=c1></span><span class=n>Collections</span><span class=o>.</span><span class=na>emptyList</span><span class=o>().</span><span class=na>stream</span><span class=o>()</span> 
  <span class=err>→</span> <span class=n>Stream</span><span class=o>.</span><span class=na>empty</span><span class=o>()</span>

<span class=c1>// 範囲指定で配列を作成
</span><span class=c1></span><span class=n>IntStream</span><span class=o>.</span><span class=na>range</span><span class=o>(</span><span class=n>expr1</span><span class=o>,</span> <span class=n>expr2</span><span class=o>).</span><span class=na>mapToObj</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=n>array</span><span class=o>[</span><span class=n>x</span><span class=o>])</span> 
  <span class=err>→</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>stream</span><span class=o>(</span><span class=n>array</span><span class=o>,</span> <span class=n>expr1</span><span class=o>,</span> <span class=n>expr2</span><span class=o>)</span>

<span class=c1>// 範囲指定でStreamを作成
</span><span class=c1></span><span class=n>Collection</span><span class=o>.</span><span class=na>nCopies</span><span class=o>(</span><span class=n>count</span><span class=o>,</span> <span class=o>...)</span> 
  <span class=err>→</span> <span class=n>Stream</span><span class=o>.</span><span class=na>generate</span><span class=o>().</span><span class=na>limit</span><span class=o>(</span><span class=n>count</span><span class=o>)</span>
</code></pre></div><ul>
<li>要素の判定</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 条件に一致する要素が存在するかの判定(1)
</span><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>filter</span><span class=o>().</span><span class=na>findFirst</span><span class=o>().</span><span class=na>isPresent</span><span class=o>()</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>anyMatch</span><span class=o>()</span>

<span class=c1>// 条件に一致する要素が存在するかの判定(2)
</span><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>map</span><span class=o>().</span><span class=na>anyMatch</span><span class=o>(</span><span class=n>Boolean</span><span class=o>::</span><span class=n>booleanValue</span><span class=o>)</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>anyMatch</span><span class=o>()</span>

<span class=c1>// 要素が一つでも条件と一致しないかの判定
</span><span class=c1></span><span class=o>!</span><span class=n>stream</span><span class=o>.</span><span class=na>anyMatch</span><span class=o>()</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>noneMatch</span><span class=o>()</span>

<span class=c1>// 全要素が条件と一致するかの判定
</span><span class=c1></span><span class=o>!</span><span class=n>stream</span><span class=o>.</span><span class=na>anyMatch</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=o>!(...))</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>allMatch</span><span class=o>()</span>

<span class=c1>// ソートして最も先にある値を探す
</span><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>sorted</span><span class=o>(</span><span class=n>comparator</span><span class=o>).</span><span class=na>findFirst</span><span class=o>()</span> 
  <span class=err>→</span> <span class=n>Stream</span><span class=o>.</span><span class=na>min</span><span class=o>(</span><span class=n>comparator</span><span class=o>)</span>
</code></pre></div><ul>
<li>要素を集める</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 要素の数を数える
</span><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>counting</span><span class=o>())</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>count</span><span class=o>()</span>

<span class=c1>// 最も大きい要素を探す
</span><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>maxBy</span><span class=o>())</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>max</span><span class=o>()</span>

<span class=c1>// 要素を違うオブジェクトにマッピングする
</span><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>mapping</span><span class=o>())</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>map</span><span class=o>().</span><span class=na>collect</span><span class=o>()</span>

<span class=c1>// 要素を一つにまとめる
</span><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>reducing</span><span class=o>())</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>reduce</span><span class=o>()</span>

<span class=c1>// 要素を数字の合計にする
</span><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>collect</span><span class=o>(</span><span class=n>summingInt</span><span class=o>())</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>mapToInt</span><span class=o>().</span><span class=na>sum</span><span class=o>()</span>
</code></pre></div><ul>
<li>要素の処理</li>
</ul>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=c1>// 要素の状態だけを変える
</span><span class=c1></span><span class=n>stream</span><span class=o>.</span><span class=na>map</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=o>{...;</span> <span class=k>return</span> <span class=n>x</span><span class=o>;})</span> 
  <span class=err>→</span> <span class=n>stream</span><span class=o>.</span><span class=na>peek</span><span class=o>(</span><span class=n>x</span> <span class=o>-&gt;</span> <span class=o>...)</span>
</code></pre></div><h2 id=最後に>最後に</h2>
<p>関数型プログラミングに興味がないとしても、Streamそのものはかなり魅力的なAPIですので、皆さんにもぜひ使ってみて欲しいです。Java 1.8がリリースされた当時には性能も劣り読みにくいという批判も多かったのですが、もう時間は経ち、Javaのバージョンはすでに14となっているくらいです。もうそろそろStreamを使ってモダンな書き方を試してみても良いでしょう。</p>
<p>そしてStreamを通じて、関数型プログラミングを味わえるのも一つのメリットではないかと思います。もちろん、Streamが完璧な関数型プログラミングの例だとは言い切れませんが、少なくとも、オブジェクト指向だけでなく新しいプログラミングのトレンドはどういうものかを経験できるということだけでも十分価値があるのではないでしょうか。もう関数型プログラミングの概念が登場してからも数年が経っています。プログラミングの世界は常に変化と発達が伴うものなので、少なくとも最近のトレンドが何であるかくらいは把握しておきたいものです。</p>
<p>では、またあいましょう！</p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/stream/>stream</a>
<a href=/tags/java/>java</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article class=has-image>
<a href=/posts/java-new-methods-from-9-to-11/>
<div class=article-image>
<img src=/../../images/java.jpg loading=lazy data-key data-hash=/../../images/java.jpg>
</div>
<div class=article-details>
<h2 class=article-title>9からの新メソッドめぐり</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/posts/java-collection-loop/>
<div class=article-image>
<img src=/../../images/java.jpg loading=lazy data-key data-hash=/../../images/java.jpg>
</div>
<div class=article-details>
<h2 class=article-title>今更なループの話</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/posts/java-compare-and-merge-lists/>
<div class=article-image>
<img src=/../../images/java.jpg loading=lazy data-key data-hash=/../../images/java.jpg>
</div>
<div class=article-details>
<h2 class=article-title>二つのListを結合する</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/posts/java-enter-to-17/>
<div class=article-image>
<img src=/../../images/java.jpg loading=lazy data-key data-hash=/../../images/java.jpg>
</div>
<div class=article-details>
<h2 class=article-title>Java 17は何が変わったか</h2>
</div>
</a>
</article>
<article class=has-image>
<a href=/posts/java-string-concat-and-split/>
<div class=article-image>
<img src=/../../images/java.jpg loading=lazy data-key data-hash=/../../images/java.jpg>
</div>
<div class=article-details>
<h2 class=article-title>今更な文字列操作の話</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<footer class=site-footer>
<section class=copyright>
&copy;
2019 -
2022 Korean-man in Tokyo
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.7.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#streamは万能か>Streamは万能か？</a>
<ol>
<li><a href=#性能は劣る場合も>性能は劣る場合も</a></li>
<li><a href=#途中でやめられない>途中でやめられない</a></li>
<li><a href=#ループ変数を使用できない>ループ変数を使用できない</a></li>
<li><a href=#そもそもの関数型>そもそもの関数型</a></li>
</ol>
</li>
<li><a href=#streamをより活用する>Streamをより活用する</a>
<ol>
<li><a href=#再使用>再使用</a></li>
<li><a href=#短く書く>短く書く</a></li>
</ol>
</li>
<li><a href=#最後に>最後に</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>