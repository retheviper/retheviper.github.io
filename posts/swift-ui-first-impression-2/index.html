<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="前回に続いて、今回はSwiftUIを触りながら感じたことについて述べたいと思います。自分のように、今までバックエンドの実績しかないエンジニア"><title>SwiftUIを触ってみた〜その2〜</title><link rel=canonical href=https://retheviper.github.io/posts/swift-ui-first-impression-2/><link rel=stylesheet href=/scss/style.min.fbb68fe51fb77bdd639dccfe1c7b590d2330cf8b81da91f1585b35c3d07fbac8.css><meta property="og:title" content="SwiftUIを触ってみた〜その2〜"><meta property="og:description" content="前回に続いて、今回はSwiftUIを触りながら感じたことについて述べたいと思います。自分のように、今までバックエンドの実績しかないエンジニア"><meta property="og:url" content="https://retheviper.github.io/posts/swift-ui-first-impression-2/"><meta property="og:site_name" content="Korean-man in Tokyo"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="swift"><meta property="article:tag" content="swiftui"><meta property="article:tag" content="gui"><meta property="article:tag" content="kotlin"><meta property="article:tag" content="compose"><meta property="article:published_time" content="2022-08-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-20T00:00:00+00:00"><meta property="og:image" content="https://retheviper.github.io/images/swift.jpg"><meta name=twitter:title content="SwiftUIを触ってみた〜その2〜"><meta name=twitter:description content="前回に続いて、今回はSwiftUIを触りながら感じたことについて述べたいと思います。自分のように、今までバックエンドの実績しかないエンジニア"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://retheviper.github.io/images/swift.jpg"><link rel=apple-touch-icon sizes=57x57 href=/favicon/apple-icon-57x57.png><link rel=apple-touch-icon sizes=60x60 href=/favicon/apple-icon-60x60.png><link rel=apple-touch-icon sizes=72x72 href=/favicon/apple-icon-72x72.png><link rel=apple-touch-icon sizes=76x76 href=/favicon/apple-icon-76x76.png><link rel=apple-touch-icon sizes=114x114 href=/favicon/apple-icon-114x114.png><link rel=apple-touch-icon sizes=120x120 href=/favicon/apple-icon-120x120.png><link rel=apple-touch-icon sizes=144x144 href=/favicon/apple-icon-144x144.png><link rel=apple-touch-icon sizes=152x152 href=/favicon/apple-icon-152x152.png><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-icon-180x180.png><link rel=icon type=image/png sizes=192x192 href=/favicon/android-icon-192x192.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=96x96 href=/favicon/favicon-96x96.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/manifest.json><meta name=msapplication-TileColor content="#ffffff"><meta name=msapplication-TileImage content="/favicon/ms-icon-144x144.png"><meta name=theme-color content="#ffffff"><script async src="https://www.googletagmanager.com/gtag/js?id=G-BYJBEJB6DX"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-BYJBEJB6DX",{anonymize_ip:!1})}</script></head><body class="article-page has-toc"><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/swift-ui-first-impression-2/><img src=/../../images/swift.jpg loading=lazy alt="Featured image of post SwiftUIを触ってみた〜その2〜"></a></div><div class=article-details><header class=article-category><a href=/categories/swift/ style=background-color:#2a9d8f;color:#fff>swift</a></header><h2 class=article-title><a href=/posts/swift-ui-first-impression-2/>SwiftUIを触ってみた〜その2〜</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Aug 20, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>14 minute read</time></div></footer></div></header><section class=article-content><p>前回に続いて、今回はSwiftUIを触りながら感じたことについて述べたいと思います。自分のように、今までバックエンドの実績しかないエンジニアがGUIを作るとしたら、画面のレイアウトや色合い、画面間の繊維など「今までなかった概念」で混乱することも多いかなと思います。そしてその中でも特に難しい、うまく扱えない機能などもあるかなと思います。</p><p>自分の場合、プロダクションレベルのコードを書いたことはないものの、以前から<a class=link href=https://reactnative.dev/ target=_blank rel=noopener>React Native</a>, <a class=link href=https://flutter.dev/ target=_blank rel=noopener>Flutter</a>, <a class=link href=https://developer.android.com/jetpack/compose target=_blank rel=noopener>Jetpack Compose</a>には少し触れたことがあったためSwiftUIで「画面を構成する方式」については少し理解しているつもりでした。しかし、やはりバックエンドでは存在しない機能がありました。</p><p>今回はそのSwiftUIの話となりますが、中でも私が注目した機能もしくは概念について述べたいと思います。</p><h2 id=swiftui>SwiftUI</h2><p>まずは、SwiftUIそのものに対して簡単に紹介しましょう。SwiftUIはいわゆる宣言型(Declarative)UIのフレームワークで、<a class=link href=https://ja.reactjs.org/ target=_blank rel=noopener>React</a>や<a class=link href=https://vuejs.org/ target=_blank rel=noopener>Vue</a>などのフロントエンドからの影響が見えます。要するに、画面を構成する要素(Widget, Component, Materialなどフレームワークやライブラリによって呼び方は様々ですが)を一つのオブジェクトとして「宣言」し、それらの要素の組み合わせによって一つの画面を完成するという形になっているということです。このような宣言型UIはSwiftUIだけでなく、モバイルに限定してもReact NativeやFlutter、Jetpack Composeなど様々なフレームワークやライブラリで採択しているものでもあります。</p><p>そして、要素の実装についてもフレームワークやライブラリによって色々と方法が分かれますが、SwiftUIでは、個別の要素はViewといい、<a class=link href=https://developer.apple.com/documentation/swiftui/view target=_blank rel=noopener>View</a>というprotocolをstructとして実装していきます。なので、一覧を表示する画面であれば、一つの行としてデータを表示するView、その行をリストとして表示するためのView、さらに一覧の上や下にメニューを表示するViewなどが一つ一つのstructとして定義されていく形ということです。</p><p>このような画面の作り方は、フレームワークのパラダイム・コンセプトとして決まってあるものなので、それに従って実装を進めることには私のようにバックグラウンドが全く違うエンジニアでも特に問題はないかなと思います。</p><p>ただ、実際のアプリを作るとしましょう。画面に対してはフレームワークで提示する通り要素を実装して作ったとしたら、アプリを実行してなんらかの処理を行うためにはバックエンドを繋げるか、アプリ内でなんらかの処理を行うかなど「ロジック」とつなげる必要があるはずです。ここで常にとは言い難いのですが、バックエンドでは見慣れない概念が出てくる場合があります。「状態」というものです。</p><h2 id=状態>状態</h2><p>バックエンドのアプリを実装している場合は、リクエストがあり、それに対してのレスポンス（HTTPステータスのみだとしても）がある、という明確なプロセスがありますね。この一連の処理には、「途中で変化する」という概念はありません。この場合のデータは永続化されるか、処理が終了するまでの一時的な物が多いです。</p><p>しかし、画面の世界だと話は変わってきます。多くのモバイルアプリではスライダ、ボタン、テキストボックスなどいろいろな要素で構成されてあり、それらの要素に関する状態が常に変わってくるケースもあるのです。ファイルをダウンロードしている状態を表示するためのプログレスバーがあるとしたら、単純に進行状況を見せるとしたら一つのスレッドを割り当てて処理するだけで良いでしょう。</p><p>ここで一つ、もしダウンロードに「一時停止」のような機能があったらどうでしょうか。プロセスが進行中にボタンを押下したら止まり、再度押下したら再開されるような機能です。他にも色々と考慮すべきものはあるかと思いますが、この「停止している」「再開した」という概念をどこかに記憶しておく必要はあるでしょう。つまり、画面においてのユーザの入力に対して、なんらかの処理を実際に行うまで記憶しておくための機構が必要ということですね。</p><p>SwiftUIでももちろん、状態を管理するためのものがあります。ただ、ユースケースで考えると画面の要素(View)一つに限って必要なものか、それとも複数の要素において必要なものか、複数の画面（アプリ全体）にかけて必要なものかという、スコープによって必要な状態は違うものになります。View一つで必要なものをアプリ全体で管理する必要もなければ、複雑になりがちだからですね。なので、ここではそのスコープ別に状態を管理するためにどんなものがあるのかについて述べていきたいと思います。</p><h3 id=個別viewの状態>個別Viewの状態</h3><p>まずは最も小さい単位、Viewの場合です。先に述べた、一覧の画面が良い例になりそうですね。Appleのチュートリアルでは、以下のような一覧の画面を作ることになります。</p><p><figure class=gallery-image style=flex-grow:48;flex-basis:117px><a href=/posts/swift-ui-first-impression-2/view_list.png data-size=860x1756><img src=/posts/swift-ui-first-impression-2/view_list.png width=860 height=1756 srcset="/posts/swift-ui-first-impression-2/view_list_hu0267d8896987db251873bf1e3d824beb_440048_480x0_resize_box_3.png 480w, /posts/swift-ui-first-impression-2/view_list_hu0267d8896987db251873bf1e3d824beb_440048_1024x0_resize_box_3.png 1024w" loading=lazy alt="List View"></a><figcaption>List View</figcaption></figure></p><p>この画面では右上のボタンを押すことで、一覧に表示するアイテムをフィルタリングできる機能があります。たとえば一部の行にハートマークがついてありますが、これは「お気に入り」を意味していて、そのお気に入りとして登録したものだけをフィルタするか、アイテムのカテゴリでフィルタするかなどの機能が入っています。</p><p>そしてこの画面では、「フィルタするカテゴリ」や「お気に入りだけを表示する」を状態として扱っていますが、この状態は他の画面では知る必要がないデータとなっています。この場合に使えるのが、<a class=link href=https://developer.apple.com/documentation/swiftui/state target=_blank rel=noopener>@State</a>です。コードとしては、以下のようになっています。(一部省略)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#6272a4>// 一覧画面</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>struct</span> <span style=color:#50fa7b>LandmarkList</span>: View {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// お気に入りだけを表示するかどうか</span>
</span></span><span style=display:flex><span>    @State <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>showFavoritesOnly</span> = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// フィルタするカテゴリ</span>
</span></span><span style=display:flex><span>    @State <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>filter</span> = FilterCategory.all
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// カテゴリの種類</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>enum</span> <span style=color:#50fa7b>FilterCategory</span>: <span style=color:#8be9fd;font-style:italic>String</span>, CaseIterable, Identifiable {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>case</span> all = <span style=color:#f1fa8c>&#34;ALL&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>case</span> lakes = <span style=color:#f1fa8c>&#34;Lakes&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>case</span> rivers = <span style=color:#f1fa8c>&#34;Rivers&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>case</span> mountains = <span style=color:#f1fa8c>&#34;Mountains&#34;</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>id</span>: FilterCategory { <span style=color:#ff79c6>self</span> }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// アイテムにフィルタを適用</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>filteredLandmarks</span>: [Landmark] {
</span></span><span style=display:flex><span>        modelData.landmarks.filter { landmark <span style=color:#ff79c6>in</span>
</span></span><span style=display:flex><span>            (<span style=color:#ff79c6>!</span>showFavoritesOnly <span style=color:#ff79c6>||</span> landmark.isFavorite)
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>&amp;&amp;</span> (filter == .all <span style=color:#ff79c6>||</span> filter.rawValue == landmark.category.rawValue )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>body</span>: some View {
</span></span><span style=display:flex><span>        NavigationView {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// アイテムの表示部</span>
</span></span><span style=display:flex><span>            List(selection: $selectedLandmark) {
</span></span><span style=display:flex><span>                ForEach(filteredLandmarks) { landmark <span style=color:#ff79c6>in</span>
</span></span><span style=display:flex><span>                    NavigationLink {
</span></span><span style=display:flex><span>                        LandmarkDetail(landmark: landmark)
</span></span><span style=display:flex><span>                    } label: {
</span></span><span style=display:flex><span>                        LandmarkRow(landmark: landmark)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            .toolbar {
</span></span><span style=display:flex><span>                ToolbarItem {
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// ツールバーにフィルタを適用するためのボタンを追加</span>
</span></span><span style=display:flex><span>                    Menu {
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// 選択できるカテゴリ</span>
</span></span><span style=display:flex><span>                        Picker(<span style=color:#f1fa8c>&#34;Category&#34;</span>, selection: $filter) {
</span></span><span style=display:flex><span>                            ForEach(FilterCategory.allCases) { category <span style=color:#ff79c6>in</span>
</span></span><span style=display:flex><span>                                Text(category.rawValue).tag(category)
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        .pickerStyle(.inline)
</span></span><span style=display:flex><span>                        
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// お気に入りだけを表示するかどうかのトグル</span>
</span></span><span style=display:flex><span>                        Toggle(isOn: $showFavoritesOnly) {
</span></span><span style=display:flex><span>                            Label(<span style=color:#f1fa8c>&#34;Favorites only&#34;</span>, systemImage: <span style=color:#f1fa8c>&#34;heart.fill&#34;</span>)
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    } label: {
</span></span><span style=display:flex><span>                        Label(<span style=color:#f1fa8c>&#34;Filter&#34;</span>, systemImage: <span style=color:#f1fa8c>&#34;slider.horizontal.3&#34;</span>)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>このように、一つのViewにおいて状態を管理するためには、<code>@State</code>を使うことになります。</p><h3 id=親子関係のviewが共有する状態>親子関係のViewが共有する状態</h3><p>さて、一つのViewでの状態を管理することはできましたが、次に気になるのは複数のView、特に親子関係になるView間でどうやって状態を共有できるかです。たとえば先ほどの一覧画面だと、一つ一つの行がViewになっているものなのですが、</p><p>実は、親のViewから子Viewに状態を渡すというのは、すでに先ほどのコードに表れています。「お気に入りだけを表示するかどうか」のトグルがあるのですが、ここで<code>isOn</code>に親の状態を渡していますね。ただ、トグル時の挙動を<code>@State</code>で定義したBooleanと結びつけるために<code>isOn</code>として渡す際、<code>$</code>をつけることに注目する必要があります。<code>$</code>をつけることで、Booleanではなく、<a class=link href=https://developer.apple.com/documentation/swiftui/binding target=_blank rel=noopener>Binding</a>という形でプロパティを渡すことになります。こうしてラッパーを渡すことで、<a class=link href=https://developer.apple.com/documentation/swiftui/toggle/ target=_blank rel=noopener>Toggle</a>の中でも親の状態を変更できるようになります。<code>Toggle</code>は確かに一覧の画面とは別のViewになりますが、押下するたびに親の状態である<code>showFavoritesOnly</code>の値が変わるということです。</p><p>後でまた関連したポストを書きたいと思いますが、Jetpack Composeでも何となく似たような形で状態の管理ができる方法があります。例えば、<code>@State</code>のように簡単な状態を管理するためには以下のような書き方ができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// true/falseの状態
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>var</span> toggle: Boolean <span style=color:#ff79c6>by</span> remember { mutableStateOf(<span style=color:#ff79c6>false</span>) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>if</span> toggle {
</span></span><span style=display:flex><span>    println(<span style=color:#f1fa8c>&#34;On!&#34;</span>)
</span></span><span style=display:flex><span>    toggle = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>    println(<span style=color:#f1fa8c>&#34;Off!&#34;</span>)
</span></span><span style=display:flex><span>    toggle = <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上記のような書き方はいわゆる<a class=link href=https://kotlinlang.org/docs/delegation.html target=_blank rel=noopener>Delegation</a>によるもので、<code>mutableStateOf&lt;T></code>が返すのは<a class=link href=https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState target=_blank rel=noopener>MutableState</a>ですが、<code>by</code>を使うことで実際は<code>Boolean</code>そのものを扱うようになります。</p><p>そして<code>MutableState&lt;T></code>を分解し、以下のように状態と、状態を変化させる処理の処理を指定することもできます。これもまた、先ほどの<code>Binding</code>のような役割をするようなものですね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// テキストの状態と値の変更
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> (content: String, onValueChange: (String) <span style=color:#ff79c6>-&gt;</span> Unit) = remember { mutableStateOf(<span style=color:#f1fa8c>&#34;&#34;</span>) }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// テキストフィールドに状態を表示し、変化があった場合は状態を変更させる
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>TextField(<span style=color:#ff79c6>value</span> = content, onValueChange = onValueChange)
</span></span></code></pre></div><p>こうやって他の要素に状態の変更を可能にするためには、基本的にその状態をラップしているオブジェクトを利用するという考えは、SwiftUIでもJetpack Composeでも一緒のようです。ただ、<code>$</code>というキーワードを使ってラッパーにアクセスできるSwiftと、状態のオブジェクトをどうやって宣言するかを考える必要のあるKotlinの違いがまた面白いポイントです。</p><h3 id=アプリ全体で共有する状態>アプリ全体で共有する状態</h3><p>さて、次はもっと大きい単位としての状態について述べたいと思います。アプリの画面は色々とあり、仲には親子の関係ではない場合もあります。Appleのチュートリアルのアプリをまたの例としてあげますと、以下のように、タブが分かれている場合が代表的なものと言えるかも知れません。</p><p><figure class=gallery-image style=flex-grow:49;flex-basis:119px><a href=/posts/swift-ui-first-impression-2/view_menu.png data-size=732x1466><img src=/posts/swift-ui-first-impression-2/view_menu.png width=732 height=1466 srcset="/posts/swift-ui-first-impression-2/view_menu_hu9c7790eb6847b0c09531674054eff1d4_1201768_480x0_resize_box_3.png 480w, /posts/swift-ui-first-impression-2/view_menu_hu9c7790eb6847b0c09531674054eff1d4_1201768_1024x0_resize_box_3.png 1024w" loading=lazy alt="Menu View"></a><figcaption>Menu View</figcaption></figure></p><p>ここで、下にある「Featured」や「List」をタッチすることにより表示される画面が変わるわけですが、この二つの画面は親子といえる関係ではありません。以下のコードをご覧ください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>struct</span> <span style=color:#50fa7b>ContentView</span>: View {
</span></span><span style=display:flex><span>    @State <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>selection</span>: Tab = .featured
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>enum</span> <span style=color:#50fa7b>Tab</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>case</span> featured
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>case</span> list
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>body</span>: some View {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// タブメニュー</span>
</span></span><span style=display:flex><span>        TabView(selection: $selection) {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Featured画面</span>
</span></span><span style=display:flex><span>            CategoryHome()
</span></span><span style=display:flex><span>                .tabItem {
</span></span><span style=display:flex><span>                    Label(<span style=color:#f1fa8c>&#34;Featured&#34;</span>, systemImage: <span style=color:#f1fa8c>&#34;star&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                .tag(Tab.featured)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// LandmarkList画面</span>
</span></span><span style=display:flex><span>            LandmarkList()
</span></span><span style=display:flex><span>                .tabItem {
</span></span><span style=display:flex><span>                    Label(<span style=color:#f1fa8c>&#34;List&#34;</span>, systemImage: <span style=color:#f1fa8c>&#34;list.bullet&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                .tag(Tab.list)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>要件によっては、この対等な関係にある画面間でも状態を共有する必要はあります。たとえば、ショッピングのアプリを作るとしたら、自分のアカウントの画面を開いている場合でもカートに入れている商品の情報は維持される必要がありますね。このように、現在表示している画面とは関係なく、アプリ全体で共有する状態が必要な場面があります。</p><p>この場合は、どうしたらいいでしょうか？もちろん、起点となるViewがあるので、そこに<code>@State</code>を定義しておくというのも一つの方法かも知れません。ただ、状態として管理したい項目が増えれば増えるほど複雑になりがちですね。起点のViewには複数の<code>@State</code>が必要となり、画面ごとにそれらを渡す必要があります。だとすると、やはり一つのオブジェクトに状態をまとめて置いて使いまわしたいものです。</p><p>Appleのチュートリアルでもそれを提示していて、画面間で共有するデータとしてLandmarkのデータと、ユーザのプロフィールをまとめて共有できるオブジェクトとして提供する方法があります。まずは、以下がその状態のオブジェクトのコードとなります。（一部省略）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#ff79c6>final</span> <span style=color:#8be9fd;font-style:italic>class</span> <span style=color:#50fa7b>ModelData</span>: ObservableObject {
</span></span><span style=display:flex><span>    @Published <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>landmarks</span>: [Landmark] = load(<span style=color:#f1fa8c>&#34;landmarkData.json&#34;</span>)
</span></span><span style=display:flex><span>    @Published <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>profile</span> = Profile.<span style=color:#ff79c6>default</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ここでアプリ内でLandmarkの情報はjsonから読み取ったものとなっていて、プロフィールはEnumとなっています。そして<a class=link href=https://developer.apple.com/documentation/combine/observableobject target=_blank rel=noopener>ObservableObject</a>というプロトコールが使われているのが見えますね。<code>ObservableObject</code>を使うことで、このModelDataというクラスは変更される状態を保持し、値の変更があった場合はそれを参照する画面に通知する<code>Publisher</code>として機能することになります。そしてそれぞれの状態となるプロパティについては、<a class=link href=https://developer.apple.com/documentation/combine/published target=_blank rel=noopener>@Published</a>をつけることで状態として指定することになります。</p><p>こうして状態を保持するためのオブジェクトを定義したら、次はアプリ内でどうやって使用するかですね。チュートリアルでは、以下のようにアプリのメインとなるstructに以下のように定義しています。（一部省略）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span>@main
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>struct</span> <span style=color:#50fa7b>LandmarksApp</span>: App {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ModelDataを状態のオブジェクトとして宣言</span>
</span></span><span style=display:flex><span>    @StateObject <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>modelData</span> = ModelData()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>body</span>: some Scene {
</span></span><span style=display:flex><span>        WindowGroup {
</span></span><span style=display:flex><span>            ContentView()
</span></span><span style=display:flex><span>                .environmentObject(modelData) <span style=color:#6272a4>// メイン画面に状態オブジェクトを渡す</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>コードでわかるように、アプリでは定義しておいた状態オブジェクトを<a class=link href=https://developer.apple.com/documentation/swiftui/stateobject target=_blank rel=noopener>@StateObject</a>をつけて、メイン画面に渡すことで使うようになります。ちなみにこうやって<code>View</code>として定義された画面にならどんなものでも<code>environmentObject()</code>に状態オブジェクトを渡すことができるので、画面の一部だけをプレビューとして表示する場合でも、プレビューに表示する画面に状態オブジェクトを渡すことで動作を試すこともできます。例えば、先ほどのLandmarkの一覧画面のプレビューだと、以下のようになっています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>struct</span> <span style=color:#50fa7b>LandmarkList_Previews</span>: PreviewProvider {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>static</span> <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>previews</span>: some View {
</span></span><span style=display:flex><span>        LandmarkList()
</span></span><span style=display:flex><span>            .environmentObject(ModelData()) <span style=color:#6272a4>// 状態オブジェクトを渡す</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>こうして状態オブジェクトを画面に渡したら、中では使うだけです。<a class=link href=https://developer.apple.com/documentation/swiftui/environmentobject target=_blank rel=noopener>@EnvironmentObject</a>というアノテーションを使って、状態を持つオブジェクトを宣言するだけで自動的にオブジェクトはDIされ、その画面で使えるようになります。また一覧の画面の話となりますが、以下のコードを見てください。<code>landmarks</code>のデータを使って一覧を表示しているのがわかります。（一部省略）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>struct</span> <span style=color:#50fa7b>LandmarkList</span>: View {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 状態オブジェクト</span>
</span></span><span style=display:flex><span>    @EnvironmentObject <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>modelData</span>: ModelData
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 状態オブジェクトからデータを取り出しフィルタを適用</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>filteredLandmarks</span>: [Landmark] {
</span></span><span style=display:flex><span>        modelData.landmarks.filter { landmark <span style=color:#ff79c6>in</span>
</span></span><span style=display:flex><span>            (<span style=color:#ff79c6>!</span>showFavoritesOnly <span style=color:#ff79c6>||</span> landmark.isFavorite)
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>&amp;&amp;</span> (filter == .all <span style=color:#ff79c6>||</span> filter.rawValue == landmark.category.rawValue )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>ちなみに、Jetpack Composeの場合はこのような方法ではなく、オブジェクトそのものを<code>remember</code>するように使うようです。例えば以下のような形になります。そもそも要素を作成するアプローチが違うのが理由の一つなのかも知れませんね。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#6272a4>// アプリ全体で共有する状態
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>ApplicationState</span>(
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> environment: MutableState&lt;Environment&gt;,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>val</span> hash: MutableState&lt;String&gt;
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 状態の初期化
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>@Composable
</span></span><span style=display:flex><span><span style=color:#ff79c6>fun</span> <span style=color:#50fa7b>rememberApplicationState</span>(
</span></span><span style=display:flex><span>    environment: MutableState&lt;Environment&gt; = mutableStateOf(<span style=color:#50fa7b>Environment</span>.PRODUCTION),
</span></span><span style=display:flex><span>    hash: MutableState&lt;String&gt; = mutableStateOf(<span style=color:#f1fa8c>&#34;&#34;</span>)
</span></span><span style=display:flex><span>): ApplicationState {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> remember(environment, hash) {
</span></span><span style=display:flex><span>        ApplicationState(environment, hash)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 状態の定義
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>val</span> appState = rememberApplicationState()
</span></span></code></pre></div><h3 id=永続化できる状態>永続化できる状態</h3><p>今までの状態は、アプリが実行中のみ有効なものでした。それだけでも十分な場合もありますが、場合によっては状態を永続化したい場合もあるでしょう。例えば、学習用のアプリだとしたらどこまで進行したかなどを保存しておきたいかなと思います。このような種のデータは、アプリを再起動しても変わらないことを期待しますね。</p><p>もちろん、この場合のためにDBがあり、ネットワーク機能のあるアプリならサーバ側にデータを保存したりするでしょう。ただ、この場合は「状態」とは言えないものですね。なぜなら、状態は画面の更新を伴うものだからです。画面をタッチした回数を、画面に表示しながら同時に保存しておきたい場合は毎回DBの更新と参照で実装したくない場合もあるかなと思います。そこで使えるのが、<a class=link href=https://developer.apple.com/documentation/swiftui/appstorage target=_blank rel=noopener>@AppStorage</a>です。これを使うことで、画面の更新と永続化を同時に行うことができます。</p><p>また、チュートリアルによると、いくつかデフォルトとして保存されているデータに関してもこのアノテーションでアクセスできるようにになっています。一覧画面に表示される「お気に入り」ボタンの例ですが、ボタンのアイコンを<code>@AppStorage</code>から参照するようになっています。コードは以下です。（一部省略）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-swift data-lang=swift><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>struct</span> <span style=color:#50fa7b>FavoriteButton</span>: View {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// ボタンはハートのアイコンとして表示する</span>
</span></span><span style=display:flex><span>    @AppStorage(<span style=color:#f1fa8c>&#34;Favorite.iconType&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>private</span> <span style=color:#8be9fd;font-style:italic>var</span> <span style=color:#8be9fd;font-style:italic>iconType</span>: IconType = .heart
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=最後に>最後に</h2><p>いかがでしたか。自分の感想としては、やはり今まで自分が触れてきた分野とは全く違う概念やアプローチが多かったので、大変興味深いと思いつつ、「これであっているのか」という疑問もかなり湧いてくるような経験となっています。全く経験のない分野に足を踏み入れるのは常にそういうものなのかも知れませんが。</p><p>ただこれで、ある程度アプリを作る場合にどうやって処理を行うべきかについての疑問の一つは解けたような気がします。本当は画面を作る分、他にも色々と新しい概念が出てきたり、画面のレイアウトやUXの観点で色々と難しいものが出てくるかも知れませんが、とにかく「動く」ものを作れそうな気はしますね。何卒自分のようにバックエンドのみを経験してきた形にとって参考できるような記事となっていればと思います。</p><p>では、また！</p></section><footer class=article-footer><section class=article-tags><a href=/tags/swift/>swift</a>
<a href=/tags/swiftui/>swiftui</a>
<a href=/tags/gui/>gui</a>
<a href=/tags/kotlin/>kotlin</a>
<a href=/tags/compose/>compose</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article class=has-image><a href=/posts/swift-ui-first-impression-1/><div class=article-image><img src=/../../images/swift.jpg loading=lazy data-key data-hash=/../../images/swift.jpg></div><div class=article-details><h2 class=article-title>SwiftUIを触ってみた〜その1〜</h2></div></a></article><article class=has-image><a href=/posts/my-roadmap-in-2022/><div class=article-image><img src=/../../images/map.jpg loading=lazy data-key data-hash=/../../images/map.jpg></div><div class=article-details><h2 class=article-title>個人的な2022年のロードマップ</h2></div></a></article><article class=has-image><a href=/posts/kotlin-compose-web/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinだけでファイルサーバを作ってみた</h2></div></a></article><article class=has-image><a href=/posts/kotlin-compose-desktop/><div class=article-image><img src=/../../images/kotlin.jpg loading=lazy data-key data-hash=/../../images/kotlin.jpg></div><div class=article-details><h2 class=article-title>Kotlinでデスクトップアプリを作ってみた</h2></div></a></article><article class=has-image><a href=/posts/languages-comparsion-sorting/><div class=article-image><img src=/../../images/magic.jpg loading=lazy data-key data-hash=/../../images/magic.jpg></div><div class=article-details><h2 class=article-title>色々な言語でやってみた（ソート編）</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2019 -
2022 Korean-man in Tokyo</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.7.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#swiftui>SwiftUI</a></li><li><a href=#状態>状態</a><ol><li><a href=#個別viewの状態>個別Viewの状態</a></li><li><a href=#親子関係のviewが共有する状態>親子関係のViewが共有する状態</a></li><li><a href=#アプリ全体で共有する状態>アプリ全体で共有する状態</a></li><li><a href=#永続化できる状態>永続化できる状態</a></li></ol></li><li><a href=#最後に>最後に</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>