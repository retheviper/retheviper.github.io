<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java on Korean-man in Tokyo</title><link>https://retheviper.github.io/categories/java/</link><description>Recent content in java on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 21は何が変わったか</title><link>https://retheviper.github.io/posts/java-enter-to-21/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-enter-to-21/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Java 21は何が変わったか" />&lt;p>Java 17がリリースされてから約2年、今月にはJava 21がリリースされます。まだ案件によっては1.7など古いバージョンを使っている場合も多いと思いますが、21は新しいLTSなので、今後新しいプロジェクトを始めるときは採用を検討するのも良いかもしれません。そこで今回はJava 21で何が変わったのかをざっくりとまとめてみました。&lt;/p>
&lt;p>今回の記事はJava 17からの変化について述べているので、Java 11から17までの変化については&lt;a class="link" href="../java-enter-to-17/" >前回のポスト&lt;/a>を参照してください。&lt;/p>
&lt;h2 id="言語スペック">言語スペック
&lt;/h2>&lt;h3 id="string-templates-preview">String Templates (Preview)
&lt;/h3>&lt;p>Kotlinのような言語にはいわゆるString Interpolationという機能があります。これは文字列の中に変数を埋め込むことができる機能ですね。例えばxとyという変数があったとして、それをStringに埋め込むときにKotlinだと以下のように書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> s = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$x&lt;/span>&lt;span style="color:#e6db74"> plus &lt;/span>&lt;span style="color:#e6db74">$y&lt;/span>&lt;span style="color:#e6db74"> equals &lt;/span>&lt;span style="color:#e6db74">${x + y}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをJavaで実現するためには以下のように書くことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String concatenation&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; plus &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> y &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; equals &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> (x &lt;span style="color:#f92672">+&lt;/span> y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// StringBuilder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#e6db74">&amp;#34; plus &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#e6db74">&amp;#34; equals &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">append&lt;/span>(x &lt;span style="color:#f92672">+&lt;/span> y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String.format&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%2$d plus %1$d equals %3$d&amp;#34;&lt;/span>, x, y, x &lt;span style="color:#f92672">+&lt;/span> y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String t &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;%2$d plus %1$d equals %3$d&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">formatted&lt;/span>(x, y, x &lt;span style="color:#f92672">+&lt;/span> y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// MessageFormat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MessageFormat mf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MessageFormat(&lt;span style="color:#e6db74">&amp;#34;{0} plus {1} equals {2}&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> mf.&lt;span style="color:#a6e22e">format&lt;/span>(x, y, x &lt;span style="color:#f92672">+&lt;/span> y);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらの方法はどれも冗長で、可読性が低いです。そこでJava 21ではString Templatesという機能が追加されました。これは文字列の中に変数を埋め込むことができる機能です。なので、Javaでももっと簡単な方法でStringを作成することができるようになりました。&lt;/p>
&lt;p>ただ、String InterpolationにはSQL Injectionのような問題があるので、Javaでは別のアプローチを取りました。これは文字列の中に変数を埋め込むのではなく、文字列の中に変数を埋め込むための&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/lang/StringTemplate.html" target="_blank" rel="noopener"
>テンプレート&lt;/a>をまず作成して、それを使って文字列を作成するという方法になっています。なのでコード以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// STRを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Joan&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String info &lt;span style="color:#f92672">=&lt;/span> STR.&lt;span style="color:#e6db74">&amp;#34;My name is \{name}&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// My name is Joan&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// RAWを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Joan&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringTemplate st &lt;span style="color:#f92672">=&lt;/span> RAW.&lt;span style="color:#e6db74">&amp;#34;My name is \{name}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String info &lt;span style="color:#f92672">=&lt;/span> STR.&lt;span style="color:#a6e22e">process&lt;/span>(st); &lt;span style="color:#75715e">// My name is Joan&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/lang/StringTemplate.html#STR" target="_blank" rel="noopener"
>STR&lt;/a>や&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/lang/StringTemplate.html#RAW" target="_blank" rel="noopener"
>RAW&lt;/a>はStringTemplateのインスタンスをまず作るようになっていますが、このStringTemplateのインスタンスにはfragmentsというフィールドとvaluesという配列があります。fragmentsは文字列の中に変数があるところを空文字列に置き換えたものの配列で、valuesは変数の値の配列です。なので、変数を埋め込んだ結果の文字列だけでなく実際与えられた変数の値も取得することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> 10, y &lt;span style="color:#f92672">=&lt;/span> 20;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringTemplate st &lt;span style="color:#f92672">=&lt;/span> RAW.&lt;span style="color:#e6db74">&amp;#34;\{x} plus \{y} equals \{x + y}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> st.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// StringTemplate{ fragments = [ &amp;#34;&amp;#34;, &amp;#34; plus &amp;#34;, &amp;#34; equals &amp;#34;, &amp;#34;&amp;#34; ], values = [10, 20, 30] }&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、StringTemplateにはProcessorというInterfaceがあり、Functional Interfaceとして独自の実装をすることも可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Processor Interface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">StringTemplate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@FunctionalInterface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Processor&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>R, E &lt;span style="color:#66d9ef">extends&lt;/span> Throwable&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> R &lt;span style="color:#a6e22e">process&lt;/span>(StringTemplate st) &lt;span style="color:#66d9ef">throws&lt;/span> E;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> INTER &lt;span style="color:#f92672">=&lt;/span> StringTemplate.&lt;span style="color:#a6e22e">Processor&lt;/span>.&lt;span style="color:#a6e22e">of&lt;/span>(StringTemplate::interpolate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> INTER.&lt;span style="color:#e6db74">&amp;#34;\{x} plus \{y} equals \{x + y}&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだPreviewなので、このような使い方は今後変わる可能性がありますが、かなり面白いアプローチなので今後の動向に注目したい機能でした。&lt;/p>
&lt;h3 id="sequenced-collections">Sequenced Collections
&lt;/h3>&lt;p>JavaのCollectionの場合、種類によって最後の要素を取るためには色々書き方が変わったり、冗長になったりしますね。例えば、最初の要素と最後の要素を取る場合Collecitonの種類によって以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// List&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> firstOnList &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> lastOnList &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(list.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Deque&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> firstOnDeque &lt;span style="color:#f92672">=&lt;/span> deque.&lt;span style="color:#a6e22e">getFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> lastOnDeque &lt;span style="color:#f92672">=&lt;/span> deque.&lt;span style="color:#a6e22e">getLast&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// SortedSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> firstOnSortedSet &lt;span style="color:#f92672">=&lt;/span> sortedSet.&lt;span style="color:#a6e22e">first&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> lastOnSortedSet &lt;span style="color:#f92672">=&lt;/span> sortedSet.&lt;span style="color:#a6e22e">last&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// LinkedHashSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> firstOnLinkedHashSet &lt;span style="color:#f92672">=&lt;/span> linkedHashSet.&lt;span style="color:#a6e22e">iterator&lt;/span>().&lt;span style="color:#a6e22e">next&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> lastOnLinkedHashSet &lt;span style="color:#f92672">=&lt;/span> linkedHashSet.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">reduce&lt;/span>((first, second) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> second).&lt;span style="color:#a6e22e">orElse&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、ループを逆順にする場合もコードは冗長になったり、使い勝手が悪く感じられる場合もあります。例えば以下のコードを見ると、やろうとしていることは一緒なのに、コードが全然違うということがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// NavigableSet with descendingSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> e: navigableSet.&lt;span style="color:#a6e22e">descendingSet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Deque with reverse Iterator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> deque.&lt;span style="color:#a6e22e">descendingIterator&lt;/span>(); it.&lt;span style="color:#a6e22e">hasNext&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> e &lt;span style="color:#f92672">=&lt;/span> it.&lt;span style="color:#a6e22e">next&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// List with reverse ListIterator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> it &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">listIterator&lt;/span>(list.&lt;span style="color:#a6e22e">size&lt;/span>()); it.&lt;span style="color:#a6e22e">hasPrevious&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> e &lt;span style="color:#f92672">=&lt;/span> it.&lt;span style="color:#a6e22e">previous&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また実装クラスによっては要素の順番が保持されるCollectionからそうでないものにダウングレードされるケースもあります。例えばLinkedHashSetをCollections::unmodifiableSetでラップすると、LinkedHashSetの順番が失われることになります。&lt;/p>
&lt;p>そこでJava 21では&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/SequencedCollection.html" target="_blank" rel="noopener"
>SequencedCollection&lt;/a>および&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/SequencedSet.html" target="_blank" rel="noopener"
>SequencedSet&lt;/a>というInterfaceを追加して、上記の問題を解決します。これらInterfaceは以下のようなメソッドを提供します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SequencedCollection&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Collection&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// new method&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedCollection&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">reversed&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// methods promoted from Deque&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addFirst&lt;/span>(E);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addLast&lt;/span>(E);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E &lt;span style="color:#a6e22e">getFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E &lt;span style="color:#a6e22e">getLast&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E &lt;span style="color:#a6e22e">removeFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> E &lt;span style="color:#a6e22e">removeLast&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SequencedSet&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>, SequencedCollection&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedSet&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">reversed&lt;/span>(); &lt;span style="color:#75715e">// covariant override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>またMapにおいても&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/SequencedMap.html" target="_blank" rel="noopener"
>SequencedMap&lt;/a>というInterfaceが追加されていて、以下のようなメソッドを提供します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SequencedMap&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>K,V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>K,V&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// new methods&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>K,V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">reversed&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedSet&lt;span style="color:#f92672">&amp;lt;&lt;/span>K&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">sequencedKeySet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedCollection&lt;span style="color:#f92672">&amp;lt;&lt;/span>V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">sequencedValues&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SequencedSet&lt;span style="color:#f92672">&amp;lt;&lt;/span>Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K,V&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">sequencedEntrySet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V &lt;span style="color:#a6e22e">putFirst&lt;/span>(K, V);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V &lt;span style="color:#a6e22e">putLast&lt;/span>(K, V);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// methods promoted from NavigableMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">firstEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">lastEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">pollFirstEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>K, V&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">pollLastEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらの新しいInterfaceが追加されることで、Collection全体の継承関係が以下のように変更されました。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/java-enter-to-21/SequencedCollectionDiagram20220216.webp"
width="1512"
height="840"
srcset="https://retheviper.github.io/posts/java-enter-to-21/SequencedCollectionDiagram20220216_hu52eadc6c156a34b7d2f6c016bafa6cff_17846_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/java-enter-to-21/SequencedCollectionDiagram20220216_hu52eadc6c156a34b7d2f6c016bafa6cff_17846_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Sequenced Collections"
class="gallery-image"
data-flex-grow="180"
data-flex-basis="432px"
>
&lt;em>出典：OpenJDK - &lt;a class="link" href="https://openjdk.org/jeps/431" target="_blank" rel="noopener"
>JEP 431: Sequenced Collections&lt;/a>&lt;/em>&lt;/p>
&lt;p>継承関係によってダウンキャストが発生する場合もあるかなと思いますが、Listの場合はSequencedCollectionを継承しているのでそのまま新しいメソッドを使うことができます。&lt;/p>
&lt;h3 id="generational-zgc">Generational ZGC
&lt;/h3>&lt;p>ZGCはJava 11で導入されたGarbage Collectorですが、Java 21ではGenerational ZGCという機能が追加されました。これはZGCの性能を向上させるために、ZGCのヒープをYoung GenerationとOld Generationに分けることになります。これによって、Young GenerationのGCをより頻繁に行うことができるようになり、Young GenerationのGCの時間を短縮することができ、メモリやCPUのオーバーヘッドを減らすことができるらしいです。&lt;/p>
&lt;p>Generational ZGCを使うには以下のように起動オプションを指定します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>java -XX:+UseZGC -XX:+ZGenerational
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、新しいGCに関しては&lt;a class="link" href="https://openjdk.org/jeps/439" target="_blank" rel="noopener"
>公式のドキュメント&lt;/a>を参照すると色々と設計や実装について述べていますが、アプリケーションエンジニアの立場としてはそれを使った場合の実際の性能上の利点がどれくらいあるのかが気になるところですね。なので、実際にGenerational ZGCを使った場合の性能については&lt;a class="link" href="https://timefold.ai/blog/2023/java-21-performance/" target="_blank" rel="noopener"
>こちらの記事&lt;/a>が参考になるかと思います。結論としてはまだParallelGCがもっとも性能が良いということになっています。もちろんこれはマシンスペック（特にメモリ）によっても変わってくると思うので、自分の環境で試してみるのが良いかと思います。&lt;/p>
&lt;h3 id="record-patterns">Record Patterns
&lt;/h3>&lt;p>Java 16では&lt;a class="link" href="https://openjdk.org/jeps/394" target="_blank" rel="noopener"
>Pattern Matching&lt;/a>という機能が導入され、instanceOfで型チェックをした後にキャストするというコードを簡潔に書くことができるようになりました。例えば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Prior to Java 16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (obj &lt;span style="color:#66d9ef">instanceof&lt;/span> String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String s &lt;span style="color:#f92672">=&lt;/span> (String)obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... use s ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (obj &lt;span style="color:#66d9ef">instanceof&lt;/span> String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... use s ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java 21ではこのPattern Matchingを、同じくJava 16で導入された&lt;a class="link" href="https://openjdk.org/jeps/395" target="_blank" rel="noopener"
>Record&lt;/a>にも適用することができるようになりました。例えば以下のようなコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">Point&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> y) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printSum&lt;/span>(Object obj) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (obj &lt;span style="color:#66d9ef">instanceof&lt;/span> Point p) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> p.&lt;span style="color:#a6e22e">x&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> p.&lt;span style="color:#a6e22e">y&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(x&lt;span style="color:#f92672">+&lt;/span>y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printSum&lt;/span>(Object obj) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (obj &lt;span style="color:#66d9ef">instanceof&lt;/span> &lt;span style="color:#a6e22e">Point&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x, &lt;span style="color:#66d9ef">int&lt;/span> y)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(x&lt;span style="color:#f92672">+&lt;/span>y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらにネストしたRecordにも適用することができます。例えば以下のようなコードも可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printXCoordOfUpperLeftPointWithPatterns&lt;/span>(Rectangle r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (r &lt;span style="color:#66d9ef">instanceof&lt;/span> &lt;span style="color:#a6e22e">Rectangle&lt;/span>(ColoredPoint(Point(&lt;span style="color:#66d9ef">var&lt;/span> x, &lt;span style="color:#66d9ef">var&lt;/span> y), &lt;span style="color:#66d9ef">var&lt;/span> c),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> lr)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Upper-left corner: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="pattern-matching-for-switch">Pattern Matching for switch
&lt;/h3>&lt;p>Pattern Matchingの改善はswitchにも適用されています。例えば以下のように、switchのcaseにnullを指定することができたり、スマートキャストが使えたり、さらにwhenを使った条件分岐ができるようになりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">testStringEnhanced&lt;/span>(String response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;y&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Y&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;You got it&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;n&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;N&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Shame&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> String s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> when s.&lt;span style="color:#a6e22e">equalsIgnoreCase&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;YES&amp;#34;&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;You got it&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> String s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> when s.&lt;span style="color:#a6e22e">equalsIgnoreCase&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;NO&amp;#34;&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Shame&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> String s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Sorry?&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この改善はEnumにも適用されています。例えば以下のようなコードが可能になりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">exhaustiveSwitchWithBetterEnumSupport&lt;/span>(CardClassification c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Suit.&lt;span style="color:#a6e22e">CLUBS&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s clubs&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Suit.&lt;span style="color:#a6e22e">DIAMONDS&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s diamonds&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Suit.&lt;span style="color:#a6e22e">HEARTS&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s hearts&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Suit.&lt;span style="color:#a6e22e">SPADES&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s spades&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Tarot t &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;It&amp;#39;s a tarot&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだprimitive typeには適用されないのですが、これは今後改善する予定らしいので、また次のバージョンで期待したいところです。&lt;/p>
&lt;h3 id="foreign-fuctions-and-memory-access-api-third-preview">Foreign Fuctions and Memory Access API (Third Preview)
&lt;/h3>&lt;p>Java 19から導入された機能で、Java runtime外のコードやデータにアクセスできるようなAPIが追加されます。これはJava 21ではThird Previewとして提供されていて、JavaからCやC++のコードを呼び出すことができるようになります。例えば以下のようなコードでCのライブラリを呼び出すことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. Find foreign function on the C library path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Linker linker &lt;span style="color:#f92672">=&lt;/span> Linker.&lt;span style="color:#a6e22e">nativeLinker&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SymbolLookup stdlib &lt;span style="color:#f92672">=&lt;/span> linker.&lt;span style="color:#a6e22e">defaultLookup&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MethodHandle radixsort &lt;span style="color:#f92672">=&lt;/span> linker.&lt;span style="color:#a6e22e">downcallHandle&lt;/span>(stdlib.&lt;span style="color:#a6e22e">find&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;radixsort&amp;#34;&lt;/span>), ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2. Allocate on-heap memory to store four strings&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> javaStrings &lt;span style="color:#f92672">=&lt;/span> { &lt;span style="color:#e6db74">&amp;#34;mouse&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cat&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;dog&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;car&amp;#34;&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3. Use try-with-resources to manage the lifetime of off-heap memory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (Arena offHeap &lt;span style="color:#f92672">=&lt;/span> Arena.&lt;span style="color:#a6e22e">ofConfined&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 4. Allocate a region of off-heap memory to store four pointers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemorySegment pointers
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> offHeap.&lt;span style="color:#a6e22e">allocateArray&lt;/span>(ValueLayout.&lt;span style="color:#a6e22e">ADDRESS&lt;/span>, javaStrings.&lt;span style="color:#a6e22e">length&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 5. Copy the strings from on-heap to off-heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> javaStrings.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemorySegment cString &lt;span style="color:#f92672">=&lt;/span> offHeap.&lt;span style="color:#a6e22e">allocateUtf8String&lt;/span>(javaStrings&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pointers.&lt;span style="color:#a6e22e">setAtIndex&lt;/span>(ValueLayout.&lt;span style="color:#a6e22e">ADDRESS&lt;/span>, i, cString);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 6. Sort the off-heap data by calling the foreign function&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> radixsort.&lt;span style="color:#a6e22e">invoke&lt;/span>(pointers, javaStrings.&lt;span style="color:#a6e22e">length&lt;/span>, MemorySegment.&lt;span style="color:#a6e22e">NULL&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;\0&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 7. Copy the (reordered) strings from off-heap to on-heap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> javaStrings.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MemorySegment cString &lt;span style="color:#f92672">=&lt;/span> pointers.&lt;span style="color:#a6e22e">getAtIndex&lt;/span>(ValueLayout.&lt;span style="color:#a6e22e">ADDRESS&lt;/span>, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> javaStrings&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> cString.&lt;span style="color:#a6e22e">getUtf8String&lt;/span>(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// 8. All off-heap memory is deallocated here&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">assert&lt;/span> Arrays.&lt;span style="color:#a6e22e">equals&lt;/span>(javaStrings,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span> {&lt;span style="color:#e6db74">&amp;#34;car&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;cat&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;dog&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;mouse&amp;#34;&lt;/span>}); &lt;span style="color:#75715e">// true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今はJavaを使って他の言語で作られたライブラリやアプリケーションを参照する場合、WrapperやRuntimeを利用した形が多いかなと思いますが、これを使うことでより簡単に他の言語のライブラリを呼び出すことができ、アプリケーションのサイズを減らしたり、パフォーマンスを向上させることができるようになるかなと思います。ただ、まだPreviewなので今後変わる可能性があるのと、直接メモリにアクセスするのでメモリリークの可能性があるかなと思いますので、使用時には注意が必要かと思います。&lt;/p>
&lt;h3 id="unnamed-patterns-and-variables-preview">Unnamed Patterns and Variables (Preview)
&lt;/h3>&lt;p>処理の中で使われてない変数を&lt;code>_&lt;/code>で表現することができるようになりました。なので、以下のようなコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Loop&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> acc &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Order _ : orders) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (acc &lt;span style="color:#f92672">&amp;lt;&lt;/span> LIMIT) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... acc&lt;span style="color:#f92672">++&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Multiple assignment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> q &lt;span style="color:#f92672">=&lt;/span> ... &lt;span style="color:#75715e">// x1, y1, z1, x2, y2, z2, ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (q.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> q.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> _ &lt;span style="color:#f92672">=&lt;/span> q.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> _ &lt;span style="color:#f92672">=&lt;/span> q.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... &lt;span style="color:#66d9ef">new&lt;/span> Point(x, 0) ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Catch block&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... i ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">catch&lt;/span> (NumberFormatException _) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Bad number: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// try-with-resources&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> _ &lt;span style="color:#f92672">=&lt;/span> ScopedContext.&lt;span style="color:#a6e22e">acquire&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... no use of acquired resource ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Lambda&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toMap&lt;/span>(String::toUpperCase, _ &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;NODATA&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="virtual-threads">Virtual threads
&lt;/h3>&lt;p>Project Loomという名で長い間開発されていた機能です。個人的な意見ですが、Java 21においてもっとも注目されている機能ではないかと思います。既存のマルチスレッドプログラミングでは生成できるスレッドの数において物理的な制約があったのですが、今回の導入される仮想スレッドはそのOSのスレッドをさらに細かく分けて使うことになるので、より多くのスレッドを同時に扱うことができるのが特徴です。&lt;/p>
&lt;p>使い方としては既存の物理スレッドと大きく変わるわけではないので、以下のようなコードで使うことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> executor &lt;span style="color:#f92672">=&lt;/span> Executors.&lt;span style="color:#a6e22e">newVirtualThreadPerTaskExecutor&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IntStream.&lt;span style="color:#a6e22e">range&lt;/span>(0, 10_000).&lt;span style="color:#a6e22e">forEach&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executor.&lt;span style="color:#a6e22e">submit&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(Duration.&lt;span style="color:#a6e22e">ofSeconds&lt;/span>(1));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// executor.close() is called implicitly, and waits&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>仮想スレッドは実際のOSのスレッドに1:1対応しないので、既存のようにThreadPoolを作成してスレッドの数を制限する必要はほとんどありません。公式でもPoolを使うことをおすすめしないと言っているくらいです。&lt;/p>
&lt;p>実際&lt;a class="link" href="https://kt.academy/article/dispatcher-loom" target="_blank" rel="noopener"
>KotlinでJavaの仮想スレッドを利用するようにDispatcherを実装して実験した記事&lt;/a>によると、30スレッドのマシンでも100万の
仮想スレッドを作成して処理を行うことができるのがわかります。JVM言語で作成されたサーバーサイドアプリケーションの場合、従来のスレッドモデルではスレッドの数を制限する必要があったので、この仮想スレッドの導入によって、より多くのリクエストを同時に処理することができるようになるかなと思います。&lt;/p>
&lt;h3 id="unnamed-classes-and-instance-main-methods-preview">Unnamed Classes and Instance Main Methods (Preview)
&lt;/h3>&lt;p>関数をトップレベルに定義することができるようになりました。なので、伝統のHello Worldのサンプルは以下のようなコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Prior to Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HelloWorld&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, World!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello, World!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>トップレベルの関数やフィールドもUnnamed Classのメンバー扱いとなるので、以下のようなコードも問題なく動きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Method&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String &lt;span style="color:#a6e22e">greeting&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, World!&amp;#34;&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(greeting());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Field&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String greeting &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, World!&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(greeting);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、main関数を持つUnnamed Classは以下のように実行することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">new&lt;/span> Object() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// the unnamed class&amp;#39;s body&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}.&lt;span style="color:#a6e22e">main&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="scoped-values-preview">Scoped Values (Preview)
&lt;/h3>&lt;p>Webアプリケーションの場合、一つのリクエストに対してはスレッドが割り当てられ、一貫したコンテキストの中で実行されるようにするのが一般的です。ただ、そこでコンテキストをオブジェクトとして扱う場合、既存だと実行される関数の引数として渡す必要があります。例えば以下のようなコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">handle&lt;/span>(Request request, Response response, FrameworkContext context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> userInfo &lt;span style="color:#f92672">=&lt;/span> readUserInfo(context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> UserInfo &lt;span style="color:#a6e22e">readUserInfo&lt;/span>(FrameworkContext context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (UserInfo)framework.&lt;span style="color:#a6e22e">readKey&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;userInfo&amp;#34;&lt;/span>, context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/ThreadLocal.html" target="_blank" rel="noopener"
>ThreadLocal&lt;/a>を使用して以下のように書くこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Framework&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Application application;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Framework&lt;/span>(Application app) { &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">application&lt;/span> &lt;span style="color:#f92672">=&lt;/span> app; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>FrameworkContext&lt;span style="color:#f92672">&amp;gt;&lt;/span> CONTEXT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">serve&lt;/span>(Request request, Response response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> context &lt;span style="color:#f92672">=&lt;/span> createContext(request);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CONTEXT.&lt;span style="color:#a6e22e">set&lt;/span>(context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Application.&lt;span style="color:#a6e22e">handle&lt;/span>(request, response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> PersistedObject &lt;span style="color:#a6e22e">readKey&lt;/span>(String key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> context &lt;span style="color:#f92672">=&lt;/span> CONTEXT.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> db &lt;span style="color:#f92672">=&lt;/span> getDBConnection(context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#a6e22e">readKey&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、ThreadLocalを使う場合は色々と問題があります。まずThreadLocalの値そのものが変更されるということです。そして不要になったThreadLocalの値を適宜削除する必要があったり、オーバーヘッドが発生するということです。&lt;/p>
&lt;p>そこでJava 21では&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/lang/ScopedValue.html" target="_blank" rel="noopener"
>ScopedValue&lt;/a>というクラスが追加されました。これを使うと以下のようにスレッドあたりの値を設定することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Framework&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ScopedValue&lt;span style="color:#f92672">&amp;lt;&lt;/span>FrameworkContext&lt;span style="color:#f92672">&amp;gt;&lt;/span> CONTEXT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> ScopedValue.&lt;span style="color:#a6e22e">newInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">serve&lt;/span>(Request request, Response response) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> context &lt;span style="color:#f92672">=&lt;/span> createContext(request);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScopedValue.&lt;span style="color:#a6e22e">where&lt;/span>(CONTEXT, context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">run&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Application.&lt;span style="color:#a6e22e">handle&lt;/span>(request, response));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> PersistedObject &lt;span style="color:#a6e22e">readKey&lt;/span>(String key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> context &lt;span style="color:#f92672">=&lt;/span> CONTEXT.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> db &lt;span style="color:#f92672">=&lt;/span> getDBConnection(context);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#a6e22e">readKey&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ScopedVlaueにはsetterがないですが、だからと言って他の値を与えられないわけではないです。ThreadLocalとは別のアプローチで、特定の値を渡してrun()関数を実行することができるようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> ScopedValue&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> X &lt;span style="color:#f92672">=&lt;/span> ScopedValue.&lt;span style="color:#a6e22e">newInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScopedValue.&lt;span style="color:#a6e22e">where&lt;/span>(X, &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">run&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> bar());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">bar&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(X.&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// prints hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScopedValue.&lt;span style="color:#a6e22e">where&lt;/span>(X, &lt;span style="color:#e6db74">&amp;#34;goodbye&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">run&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> baz());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(X.&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// prints hello&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">baz&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(X.&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// prints goodbye&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このScopedValueはスレッドの実行中にだけ値が保持されないので、ThreadLocalより安全な使い方ができるようになっています。&lt;/p>
&lt;h3 id="vector-api-sixth-incubator">Vector API (Sixth Incubator)
&lt;/h3>&lt;p>Java 1.0の時代の配列を扱う&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/Vector.html" target="_blank" rel="noopener"
>Vector&lt;/a>とは違って、数値（行列）の計算のためのVector APIが追加されました。基本的に以下のようなことができるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Prior to Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">scalarComputation&lt;/span>(&lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a, &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b, &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> a.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">*&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">*&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1.&lt;span style="color:#a6e22e">0f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// As of Java 21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> VectorSpecies&lt;span style="color:#f92672">&amp;lt;&lt;/span>Float&lt;span style="color:#f92672">&amp;gt;&lt;/span> SPECIES &lt;span style="color:#f92672">=&lt;/span> FloatVector.&lt;span style="color:#a6e22e">SPECIES_PREFERRED&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">vectorComputation&lt;/span>(&lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a, &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b, &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> upperBound &lt;span style="color:#f92672">=&lt;/span> SPECIES.&lt;span style="color:#a6e22e">loopBound&lt;/span>(a.&lt;span style="color:#a6e22e">length&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> upperBound; i &lt;span style="color:#f92672">+=&lt;/span> SPECIES.&lt;span style="color:#a6e22e">length&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// FloatVector va, vb, vc;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> va &lt;span style="color:#f92672">=&lt;/span> FloatVector.&lt;span style="color:#a6e22e">fromArray&lt;/span>(SPECIES, a, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> vb &lt;span style="color:#f92672">=&lt;/span> FloatVector.&lt;span style="color:#a6e22e">fromArray&lt;/span>(SPECIES, b, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> vc &lt;span style="color:#f92672">=&lt;/span> va.&lt;span style="color:#a6e22e">mul&lt;/span>(va)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">add&lt;/span>(vb.&lt;span style="color:#a6e22e">mul&lt;/span>(vb))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">neg&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vc.&lt;span style="color:#a6e22e">intoArray&lt;/span>(c, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> a.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">*&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">*&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1.&lt;span style="color:#a6e22e">0f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一般的なWebアプリケーションではあまり使われることはないかと思いますが、もしこのような計算が必要とされる処理を書く場合、従来のコードよりも高速で並列かもできるということなので、使う場面があるかもしれません。&lt;/p>
&lt;h3 id="deprecate-the-windows-32-bit-x86-port-for-removal">Deprecate the Windows 32-bit x86 Port for Removal
&lt;/h3>&lt;p>Windows x86-32のポートがいずれ終わるので、まずはDeprecatedにしてするということです。Virtual Threadが該当のOSだと期待通りの性能向上がなく、32bitに対応する最後のWindowsであるWindows 10が2025年10月にサポート終了となるための対応とされています。&lt;/p>
&lt;h3 id="prepare-to-disallow-the-dynamic-loading-of-agents">Prepare to Disallow the Dynamic Loading of Agents
&lt;/h3>&lt;p>Java agentによる動的ロードは、実行中のアプリケーションを変更することも可能です。しかしこのよう機能はアプリケーションの整合性を保証できなくする可能性もあります。そのような問題を防ぐために、将来は動的ロードを禁止し、Java 21ではまず警告を出力します。以下のようなメッセージが出力されることがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>WARNING: A {Java,JVM TI} agent has been loaded dynamically (file:/u/bob/agent.jar)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARNING: If a serviceability tool is in use, please run with -XX:+EnableDynamicAgentLoading to hide this warning
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARNING: If a serviceability tool is not in use, please run with -Djdk.instrument.traceUsage for more information
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>WARNING: Dynamic loading of agents will be disallowed by default in a future release
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような警告を回避するためにはアプリケーションの実行時に&lt;code>-XX:+EnableDynamicAgentLoading&lt;/code>というオプションを指定する必要があります。&lt;/p>
&lt;p>&lt;a class="link" href="https://www.datadoghq.com/" target="_blank" rel="noopener"
>Datadog&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/cd/F25597_01/document/products/wls/docs90/jmxinst/understanding.html" target="_blank" rel="noopener"
>JMX&lt;/a>などアプリケーションをモニタリングするためのツールがこのような機能に依存している場合があるので、今後のバージョンを使う際には何か実装の方法が変わるかもしれませんね。&lt;/p>
&lt;h3 id="key-encapsulation-mechanism-api">Key Encapsulation Mechanism API
&lt;/h3>&lt;p>最新の暗号化のアルゴリズムに対応するものです。量子コンピュータでは既存の暗号化アルゴリズムが通用しなくなるという話もあるので、その対応として導入されたものかと思われます（公式でも、&lt;code> Post-Quantum Cryptography standardization process&lt;/code>と述べています）。&lt;/p>
&lt;p>新しいアルゴリズムを用いた公開鍵・秘密鍵のペアの生成、カプセル化、カプセルの解除などの機能に対応しています。以下のような使い方となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Receiver side&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KeyPairGenerator g &lt;span style="color:#f92672">=&lt;/span> KeyPairGenerator.&lt;span style="color:#a6e22e">getInstance&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ABC&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KeyPair kp &lt;span style="color:#f92672">=&lt;/span> g.&lt;span style="color:#a6e22e">generateKeyPair&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>publishKey(kp.&lt;span style="color:#a6e22e">getPublic&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Sender side&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM kemS &lt;span style="color:#f92672">=&lt;/span> KEM.&lt;span style="color:#a6e22e">getInstance&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ABC-KEM&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PublicKey pkR &lt;span style="color:#f92672">=&lt;/span> retrieveKey();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ABCKEMParameterSpec specS &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ABCKEMParameterSpec(...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM.&lt;span style="color:#a6e22e">Encapsulator&lt;/span> e &lt;span style="color:#f92672">=&lt;/span> kemS.&lt;span style="color:#a6e22e">newEncapsulator&lt;/span>(pkR, specS, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM.&lt;span style="color:#a6e22e">Encapsulated&lt;/span> enc &lt;span style="color:#f92672">=&lt;/span> e.&lt;span style="color:#a6e22e">encapsulate&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SecretKey secS &lt;span style="color:#f92672">=&lt;/span> enc.&lt;span style="color:#a6e22e">key&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendBytes(enc.&lt;span style="color:#a6e22e">encapsulation&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sendBytes(enc.&lt;span style="color:#a6e22e">params&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Receiver side&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> em &lt;span style="color:#f92672">=&lt;/span> receiveBytes();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> params &lt;span style="color:#f92672">=&lt;/span> receiveBytes();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM kemR &lt;span style="color:#f92672">=&lt;/span> KEM.&lt;span style="color:#a6e22e">getInstance&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ABC-KEM&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>AlgorithmParameters algParams &lt;span style="color:#f92672">=&lt;/span> AlgorithmParameters.&lt;span style="color:#a6e22e">getInstance&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ABC-KEM&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>algParams.&lt;span style="color:#a6e22e">init&lt;/span>(params);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ABCKEMParameterSpec specR &lt;span style="color:#f92672">=&lt;/span> algParams.&lt;span style="color:#a6e22e">getParameterSpec&lt;/span>(ABCKEMParameterSpec.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>KEM.&lt;span style="color:#a6e22e">Decapsulator&lt;/span> d &lt;span style="color:#f92672">=&lt;/span> kemR.&lt;span style="color:#a6e22e">newDecapsulator&lt;/span>(kp.&lt;span style="color:#a6e22e">getPrivate&lt;/span>(), specR);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SecretKey secR &lt;span style="color:#f92672">=&lt;/span> d.&lt;span style="color:#a6e22e">decapsulate&lt;/span>(em);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="structured-concurrency-preview">Structured Concurrency (Preview)
&lt;/h3>&lt;p>並列処理をより簡単にするためのAPIです。複数のスレッドで実行される作業の単位を一つのタスクとして扱うことができます。&lt;/p>
&lt;p>例えば以下のようなコードがあったとします。userとorderのデータをそれぞれ違うスレッドで取得して、その結果を返す関数です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Response &lt;span style="color:#a6e22e">handle&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ExecutionException, InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Future&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> esvc.&lt;span style="color:#a6e22e">submit&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> findUser());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Future&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> order &lt;span style="color:#f92672">=&lt;/span> esvc.&lt;span style="color:#a6e22e">submit&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> fetchOrder());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String theUser &lt;span style="color:#f92672">=&lt;/span> user.&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Join findUser&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> theOrder &lt;span style="color:#f92672">=&lt;/span> order.&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Join fetchOrder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Response(theUser, theOrder);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードだと、以下のような問題が考えられます。&lt;/p>
&lt;ul>
&lt;li>findUser()で例外が発生してもfetchOrder()は実行されてリソースの無駄になる&lt;/li>
&lt;li>handle()を実行しているスレッドがインタラプトされた場合、findUser()とfetchOrder()は実行されたままになる&lt;/li>
&lt;li>findUser()の実行が長すぎる場合、fetchOrder()が失敗してもそれを待つことになる（結果的に失敗）&lt;/li>
&lt;/ul>
&lt;p>これらの問題が挙げられてということは、新しいAPIではそれを解決できるということですね。新しいAPIでは上記の問題を、以下のようなコードで解決します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Response &lt;span style="color:#a6e22e">handle&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ExecutionException, InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> scope &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StructuredTaskScope.&lt;span style="color:#a6e22e">ShutdownOnFailure&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> user &lt;span style="color:#f92672">=&lt;/span> scope.&lt;span style="color:#a6e22e">fork&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> findUser());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> order &lt;span style="color:#f92672">=&lt;/span> scope.&lt;span style="color:#a6e22e">fork&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> fetchOrder());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scope.&lt;span style="color:#a6e22e">join&lt;/span>() &lt;span style="color:#75715e">// Join both subtasks&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">throwIfFailed&lt;/span>(); &lt;span style="color:#75715e">// ... and propagate errors&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Here, both subtasks have succeeded, so compose their results&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Response(user.&lt;span style="color:#a6e22e">get&lt;/span>(), order.&lt;span style="color:#a6e22e">get&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/concurrent/StructuredTaskScope.html" target="_blank" rel="noopener"
>StructuredTaskScope&lt;/a>を利用して処理を行う場合、以下のメリットがあります。&lt;/p>
&lt;ul>
&lt;li>findUser()やfecthOrder()のどちらかが失敗したら、残りの処理はキャンセルされる&lt;/li>
&lt;li>handle()を実行しているスレッドがインタラプトされた場合、findUser()とfetchOrder()はキャンセルされる&lt;/li>
&lt;li>処理が明確に理解できる&lt;/li>
&lt;/ul>
&lt;h2 id="api">API
&lt;/h2>&lt;p>今回の新しいAPIに関しては、言語スペックでよく説明されており、新しいJavadocの方でそれぞれのバージョン別にどんなものが追加されたかフィルタしながら確認ができるので、ここでは&lt;a class="link" href="https://download.java.net/java/early_access/jdk21/docs/api/new-list.html" target="_blank" rel="noopener"
>Javadocのリンク&lt;/a>だけを貼っておきます。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがだったでしょうか。私はもうJavaでアプリを書くことはほとんどなく、主にKotlinを書いていて、新しいAPIもそこまでコードに影響を与えることはないのですが、それでもJavaの新しいバージョンがリリースされると、なんだか嬉しくなりますね。特にVirtual ThreadのようなAPIはKotlinでも使えるし、Javaで作成されたTomcatやNettyのようなミドルウェアの性能もこれを活用することでさらに性能が上がると思うとありがたいです。他にも追加されるAPIはKotlinとはまた違うアプローチをしているので大変勉強になるなと思いました。&lt;/p>
&lt;p>今は仕事でJava 17を使っているのですが、Java 21になったらすぐにでも使いたいと思います。特に来年はKotlinも2.0がリリースされるので、Javaの新機能を活かしてKotlinのビルドもパフォーマンスもさらに向上させていきたいなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Java 17は何が変わったか</title><link>https://retheviper.github.io/posts/java-enter-to-17/</link><pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-enter-to-17/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Java 17は何が変わったか" />&lt;p>今月は新しいLTSバージョンであるJava 17のリリースがありました。まだJava 1.8を使っている案件も多いかなと思いますが、Java 1.8は2022年まで、Java 11は2023年までのサポートとなるので、いずれにせよJava 17に移行する必要はあるかなと思います。特にJava 9からモジュールが導入されたため、8からの移行はかなり大変だったらしいですが、11から移行する場合はそれほどでもないと言われているので、今からでも17では何が変わっているか、目を通しておくのもそう悪くはないでしょう。&lt;/p>
&lt;p>現時点では&lt;a class="link" href="https://adoptium.net" target="_blank" rel="noopener"
>Eclipse Temurin&lt;/a>(旧AdoptOpenJDK)、&lt;a class="link" href="https://www.azul.com/downloads/" target="_blank" rel="noopener"
>Zulu&lt;/a>などの有名JDKはほとんどが17のリリースを完了しているか、対応の最中にありますね。また、&lt;a class="link" href="https://www.itmedia.co.jp/news/articles/2109/15/news147.html" target="_blank" rel="noopener"
>Oracle JDK 17は無料に&lt;/a>なったので、こちらを選ぶもの悪くない選択肢の一つかもしれません。&lt;/p>
&lt;p>また、こういう無料化やJDKの多様化のみでなく、GoogleとOracleの訴訟の件もGoogleの勝利で終わったので、AndroidでもJava 17を使える可能性ができた以上、これからJava 17を使える場面は増えてくるかもしれません。実際、まだ遠い話ではあります、Springを使う場合、2022年の&lt;a class="link" href="https://spring.io/blog/2021/09/02/a-java-17-and-jakarta-ee-9-baseline-for-spring-framework-6" target="_blank" rel="noopener"
>Spring 6はJava 17がベースラインとなる&lt;/a>らしいですね。なので、Java 11は採択されてなかった現場でも、サポート期間などを考慮して17に転換する可能性はあると思います。&lt;/p>
&lt;p>というわけで、今回はそんなJava 17では何が変わったかを述べていきますが、大きく分けて新しい予約語の追加、新しい書き方など言語スペックとして変わったものと、新しく追加されたAPIという二つの観点でその変化を辿っていきたいと思います。案件によってはJava 1.8から17に移行するケースもあるかと思いますが、9〜11までの間にあった変更事項や新しいAPIなどはこのブログでも扱っていて、他でも参考にできるサイトが多いと思いますので、今回は8~11までの変化については割愛し、11〜17の間の変化だけを扱うことにさせてください。&lt;/p>
&lt;h2 id="言語スペック">言語スペック
&lt;/h2>&lt;h3 id="new-macos-rendering-pipeline-17">New macOS Rendering Pipeline (17)
&lt;/h3>&lt;p>macOSでは長い間、SwingなどJavaの2Dレンダリングに&lt;a class="link" href="https://www.opengl.org/" target="_blank" rel="noopener"
>OpenGL&lt;/a>を使っていましたが、新しい&lt;a class="link" href="https://developer.apple.com/metal/" target="_blank" rel="noopener"
>Metal framework&lt;/a>を導入しながら、10.14からOpenGLは&lt;code>deprecated&lt;/code>となりました。&lt;/p>
&lt;p>従ってJava側でも、Metalを利用する新しいグラフィック・レンダリング・パイプラインを実装するという&lt;a class="link" href="https://openjdk.java.net/projects/lanai/" target="_blank" rel="noopener"
>Project Lanai&lt;/a>が進められていましたが、17から&lt;a class="link" href="https://openjdk.java.net/jeps/382" target="_blank" rel="noopener"
>New macOS Rendering Pipeline&lt;/a>という名で導入されました。JavaであまりGUIを使うことないのでは？と思いがちかと思いますが、intellijのようなJavaベースのIDEでも画面描画で性能向上があるという噂です。ただ、intellijでは基本的に&lt;a class="link" href="https://confluence.jetbrains.com/display/JBR/JetBrains&amp;#43;Runtime" target="_blank" rel="noopener"
>Jetbrains Runtime&lt;/a>を使っていて、現時点ではそれがJava 17に対応していないので少し待つ必要はあります。&lt;/p>
&lt;h3 id="macosaarch64-port-17">macOS/AArch64 Port (17)
&lt;/h3>&lt;p>17からはM1など、&lt;a class="link" href="https://openjdk.java.net/jeps/391" target="_blank" rel="noopener"
>Apple Siliconを搭載した新しいMacに対応&lt;/a>しました。&lt;a class="link" href="https://www.azul.com/downloads/" target="_blank" rel="noopener"
>Zulu&lt;/a>などの他のJDKでは独自に対応してるケースもありましたが、OpenJDK(OracleJDK)で対応したことで、これをベースとする&lt;a class="link" href="https://adoptium.net/" target="_blank" rel="noopener"
>Eclipse Temurin&lt;/a>や&lt;a class="link" href="https://www.microsoft.com/openjdk" target="_blank" rel="noopener"
>Microsoft Build of OpenJDK&lt;/a>のような他のJDKでも自然にARMベースMacでネイティブとして使えるということになると思います。&lt;/p>
&lt;h3 id="record-17">Record (17)
&lt;/h3>&lt;p>14からPreviewとして導入された&lt;code>Record&lt;/code>が、17ではstableになり正式に導入されました。指定したフィールドを&lt;code>private final&lt;/code>にして、コンストラクタ、&lt;code>getter&lt;/code>、&lt;code>toString&lt;/code>、&lt;code>hashcode&lt;/code>、&lt;code>equals&lt;/code>などを自動生成してくれるものです。最初は&lt;code>Lombok&lt;/code>の&lt;a class="link" href="https://projectlombok.org/features/Data" target="_blank" rel="noopener"
>@Data&lt;/a>のようなものかと思いきや、実際は&lt;a class="link" href="https://projectlombok.org/features/Value" target="_blank" rel="noopener"
>@Value&lt;/a>に近いものになっていますね。値はコンストラクタでしか渡せなくて、後から変更はできなくなります。こういうところは、フィールドを&lt;code>val&lt;/code>として指定したKotlinの&lt;code>data class&lt;/code>に近い感覚でもあります。なので、実際の使用例を見ると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Recordの定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">MyRecord&lt;/span>(String name, &lt;span style="color:#66d9ef">int&lt;/span> number) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスの作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MyRecord myRecord &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MyRecord(&lt;span style="color:#e6db74">&amp;#34;my record&amp;#34;&lt;/span>, 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// フィールドの取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String myRecordsName &lt;span style="color:#f92672">=&lt;/span> myRecord.&lt;span style="color:#a6e22e">name&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> myRecordsNumber &lt;span style="color:#f92672">=&lt;/span> myRecord.&lt;span style="color:#a6e22e">number&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>Named Arguments&lt;/a>に対応しているのですが、Javaではまだそのような機能がないので、&lt;code>Record&lt;/code>だとフィールドが多くなるとどれがどれだかわからなくなりそうな気はします。これに対してKotlin側で&lt;code>Record&lt;/code>を使う場合、何らかのラッパークラスを作って対応するなどの方法は考えられますね。もしくは普通に&lt;code>setter&lt;/code>をもつDTOを定義するか、builderパターンを利用する方が良いでしょう。&lt;/p>
&lt;p>また、&lt;code>Record&lt;/code>では&lt;code>getter&lt;/code>名もフィールド名そのままになるという特徴もありますが、自動生成されるコンストラクタをカスタマイズするときも少し書き方が違うという特徴があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">MyRecord&lt;/span>(String name, &lt;span style="color:#66d9ef">int&lt;/span> number) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// コンストラクタにバリデーションをつける例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> MyRecord {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (name.&lt;span style="color:#a6e22e">isBlank&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他に、&lt;code>Record&lt;/code>として定義しても実際は&lt;code>Class&lt;/code>が作られることになるので、以下のようなこともできます。&lt;/p>
&lt;ul>
&lt;li>コンストラクタを追加する&lt;/li>
&lt;li>&lt;code>getter&lt;/code>をオーバライドする&lt;/li>
&lt;li>インナークラスとして&lt;code>Record&lt;/code>を定義する&lt;/li>
&lt;li>インターフェイスを実装する&lt;/li>
&lt;/ul>
&lt;p>また、&lt;code>Reflection&lt;/code>でもクラスが&lt;code>Record&lt;/code>であるかどうかを判定する&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Class.html#isRecord%28%29" target="_blank" rel="noopener"
>isRecord&lt;/a>も追加されています。&lt;/p>
&lt;h3 id="text-blocks-15">Text Blocks (15)
&lt;/h3>&lt;p>Javaでは長い間、HTMLやJSON、SQLなどをリテラルとして使うためにはエスケープや文字列の結合などを使う必要がありました。これはあまり可読性という面でよくなく、コードの修正も難しくなる問題がありましたね。例えば、HTMLを表現するとしたら以下のようなことをしていたかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String html &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;lt;html&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34; &amp;lt;body&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34; &amp;lt;h1&amp;gt;This is Java&amp;#39;s new Text block!&amp;lt;/h1&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34; &amp;lt;/body&amp;gt;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;lt;/html&amp;gt;\n&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SELECT \&amp;#34;EMP_ID\&amp;#34;, \&amp;#34;LAST_NAME\&amp;#34; FROM \&amp;#34;EMPLOYEE_TB\&amp;#34;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;WHERE \&amp;#34;CITY\&amp;#34; = &amp;#39;INDIANAPOLIS&amp;#39;\n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ORDER BY \&amp;#34;EMP_ID\&amp;#34;, \&amp;#34;LAST_NAME\&amp;#34;;\n&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>幸い、15から&lt;a class="link" href="https://openjdk.java.net/jeps/378" target="_blank" rel="noopener"
>Text Blocks&lt;/a>が導入され、他の言語のように簡単かつ可読性の高い文字列を定義することができるようになりました。これを使うとエスケープを意識しなくて良いので、複数行でなくても色々な分野で有効活用できそうですね。&lt;code>Text Blocks&lt;/code>を使って上記のコードを変えると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String html &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;html&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;body&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;h1&amp;gt;This is Java&amp;#39;s new Text block!&amp;lt;/h1&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;/body&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;/html&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> SELECT &amp;#34;EMP_ID&amp;#34;, &amp;#34;LAST_NAME&amp;#34; FROM &amp;#34;EMPLOYEE_TB&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> WHERE &amp;#34;CITY&amp;#34; = &amp;#39;INDIANAPOLIS&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ORDER BY &amp;#34;EMP_ID&amp;#34;, &amp;#34;LAST_NAME&amp;#34;;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは全く同じ書き方で同じことができるので、ここでは割愛します。&lt;/p>
&lt;h3 id="sealed-class-17">Sealed Class (17)
&lt;/h3>&lt;p>JDK 15からPreviewで導入された&lt;a class="link" href="https://openjdk.java.net/jeps/409" target="_blank" rel="noopener"
>sealed classes&lt;/a>が、Stableとなりました。&lt;code>class&lt;/code>や&lt;code>interface&lt;/code>を&lt;code>sealed&lt;/code>にすれば、それを拡張・実装できるクラスやインターフェイスを限定できるようになります。こうすることで、ライブラリなどで勝手に拡張して欲しくないクラスやインターフェイスを守ることができますね。また、将来的には&lt;code>sealed&lt;/code>として定義されてあるクラスの子クラスを&lt;code>switch&lt;/code>の&lt;code>case&lt;/code>に指定するときは全部のケースが指定されているかどうかをコンパイラがチェックするようにするとかの話もあるようです。以下は、&lt;code>sealed&lt;/code>クラスが&lt;code>permits&lt;/code>キーワードを使って継承できるクラスを指定する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Shape&lt;/span> permits Circle, Rectangle, Square, WeirdShape { }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでも&lt;a class="link" href="https://kotlinlang.org/docs/sealed-classes.html" target="_blank" rel="noopener"
>Sealed Classes&lt;/a>は存在していますが、&lt;code>interface&lt;/code>を&lt;code>sealed&lt;/code>にするためには1.5以降を使う必要があって、拡張・実装できるクラスやインターフェイスを指定するわけではなく、コンパイルされたモジュール以外で&lt;code>sealed&lt;/code>として定義されているクラスやインターフェイスを拡張・実装できない仕様となっています。なので書き方的には、以下のようになります。より簡単ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">sealed&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">IOError&lt;/span>(): Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FileReadError&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> f: File): IOError()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DatabaseError&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> source: DataSource): IOError()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">RuntimeError&lt;/span> : Error
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、Javaの場合は&lt;code>Record&lt;/code>と同じく、このクラスが&lt;code>sealed&lt;/code>であるかどうかを判定する&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Class.html#isSealed%28%29" target="_blank" rel="noopener"
>isSealed&lt;/a>が追加されています。&lt;/p>
&lt;h3 id="switch-expressions-14">Switch Expressions (14)
&lt;/h3>&lt;p>Java 12からPreviewで&lt;a class="link" href="https://openjdk.java.net/jeps/361" target="_blank" rel="noopener"
>Switch Expressions&lt;/a>が導入され、14からはStableになっています。従来の&lt;code>switch&lt;/code>を改善したもので、以下のようなことができるようになりました。&lt;/p>
&lt;ul>
&lt;li>&lt;code>case&lt;/code>をまとめて指定できる&lt;/li>
&lt;li>&lt;code>case&lt;/code>の処理をラムダのような書き方で記述できる&lt;/li>
&lt;li>&lt;code>case&lt;/code>の処理を戻り値にして、&lt;code>switch&lt;/code>を式として使える&lt;/li>
&lt;/ul>
&lt;p>例えば、&lt;code>day&lt;/code>というenumの値を見て、int値を返すメソッドを実装するとしましょう。従来の方法では以下のようになるはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> numLetters;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">switch&lt;/span> (day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> MONDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> FRIDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> SUNDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#f92672">=&lt;/span> 6;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> TUESDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#f92672">=&lt;/span> 7;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> THURSDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> SATURDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#f92672">=&lt;/span> 8;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> WEDNESDAY:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> numLetters &lt;span style="color:#f92672">=&lt;/span> 9;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;Wat: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> day);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の処理は新しい&lt;code>switch&lt;/code>では以下のように書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> numLetters &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> MONDAY, FRIDAY, SUNDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 6;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> TUESDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 7;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> THURSDAY, SATURDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 8;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> WEDNESDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 9;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinだと以下のようになるはずですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> numLetters = &lt;span style="color:#66d9ef">when&lt;/span> (day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Day&lt;/span>.MONDAY, &lt;span style="color:#a6e22e">Day&lt;/span>.FRIDAY, &lt;span style="color:#a6e22e">Day&lt;/span>.SUNDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Day&lt;/span>.TUESDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Day&lt;/span>.THURSDAY, &lt;span style="color:#a6e22e">Day&lt;/span>.SATURDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Day&lt;/span>.WEDNESDAY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>when&lt;/code>だとargumentなしでも使えて分岐を条件文によるものにすることもできるなどの特徴もあるので、使い勝手はJavaの&lt;code>switch&lt;/code>よりいいかなと思います。ただ、Javaでもバージョンアップと共に後述する機能も追加されてあるので、今後Kotlinのように色々と改良が行われる可能性はあるかと思いますね。&lt;/p>
&lt;h3 id="pattern-matching-for-instanceof-16--switch-17">Pattern Matching for instanceof (16) / switch (17)
&lt;/h3>&lt;p>Java 14からは、&lt;a class="link" href="https://openjdk.java.net/jeps/394" target="_blank" rel="noopener"
>Pattern Matching for instanceof&lt;/a>が導入され、16ではStableになりましt。今までは&lt;code>instanceof&lt;/code>を使ってオブジェクトのインスタンスの種類を判定した後、そのインスタンスの種類にあった処理を行うには以下のようにキャストが必要でしたね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">formatter&lt;/span>(Object o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String formatted &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;unknown&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;int %d&amp;#34;&lt;/span>, (Integer) i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一度どれのインスタンスかわかった上でさらにキャストをする必要はあるのはだるいし、ミスをしたら例外の原因にもなり得る問題がありますね。なので、&lt;code>Pattern Matching&lt;/code>を利用して、キャストをなくすことができるようになりました。&lt;code>instanceof&lt;/code>を使った条件文の中に、キャストする変数名を指定しておくと、&lt;code>if&lt;/code>分の中でそのまま自動にキャストされた変数を使えるようになります。なので、以下のようなことができるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">formatter&lt;/span>(Object o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String formatted &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;unknown&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;int %d&amp;#34;&lt;/span>, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> Long l) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;long %d&amp;#34;&lt;/span>, l);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> Double d) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;double %f&amp;#34;&lt;/span>, d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#66d9ef">instanceof&lt;/span> String s) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> formatted &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;String %s&amp;#34;&lt;/span>, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> formatted;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに、17からはPreviewとして&lt;a class="link" href="https://openjdk.java.net/jeps/406" target="_blank" rel="noopener"
>Pattern Matching for switch&lt;/a>が導入されています。これを使うと、&lt;code>instanceof&lt;/code>なしで、&lt;code>switch&lt;/code>文を使ったよりシンプルな処理を書けるようになります。これを先に紹介した&lt;code>Switch Expressions&lt;/code>と組み合わせることで、上記の処理は以下に変えることが可能になります。かなりシンプルになったのがわかりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">formatterPatternSwitch&lt;/span>(Object o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Integer i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;int %d&amp;#34;&lt;/span>, i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Long l &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;long %d&amp;#34;&lt;/span>, l);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> Double d &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;double %f&amp;#34;&lt;/span>, d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> String s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;String %s&amp;#34;&lt;/span>, s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> o.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="packaging-tool-16">Packaging Tool (16)
&lt;/h3>&lt;p>実行できるバイナリを生成する&lt;a class="link" href="https://openjdk.java.net/jeps/392" target="_blank" rel="noopener"
>Packaging Tool&lt;/a>が導入されています。これを使うと、Java runtimeとライブラリ、それぞれのOSにあった実行ファイルが一つのパッケージになる機能です。Java runtimeが含まれるということはOSのJavaのバージョンに関係なく実行できるものになるという意味なので、Javaのバージョンを固定したり、複数のアプリでそれぞれ違うバージョンのJavaを使って起動したい場合は役立つ機能かもしれません。&lt;/p>
&lt;h2 id="api">API
&lt;/h2>&lt;p>Java 17からは、APIドキュメントから、新しく追加されたAPIの一覧だけを見られるタブができたということです。今回は11以降に追加されたもののみですが、今後新しいLTSバージョンがリリースすると、17以降のものをこちらから確認できそうですね。新しいAPIの一覧は&lt;a class="link" href="https://download.java.net/java/early_access/jdk17/docs/api/new-list.html" target="_blank" rel="noopener"
>こちら&lt;/a>から確認できます。&lt;/p>
&lt;p>ここで全てのAPIの詳細まで探るのは難しいと思いますので、個人的に興味深いと思ったのを一部紹介したいと思います。&lt;/p>
&lt;h3 id="serial-14">@Serial (14)
&lt;/h3>&lt;p>&lt;code>java.io&lt;/code>パッケージに、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serial.html" target="_blank" rel="noopener"
>Serial&lt;/a>というアノテーションが追加されました。これは&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html" target="_blank" rel="noopener"
>Serializable&lt;/a>を実装したクラスで、そのシリアライズのメカニズムを&lt;code>@Override&lt;/code>するような機能のようです。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SerializableClass&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Serializable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> ObjectStreamField&lt;span style="color:#f92672">[]&lt;/span> serialPersistentFields;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> serialVersionUID;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">writeObject&lt;/span>(ObjectOutputStream stream) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">readObject&lt;/span>(ObjectInputStream stream) &lt;span style="color:#66d9ef">throws&lt;/span> IOException, ClassNotFoundException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">readObjectNoData&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ObjectStreamException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object &lt;span style="color:#a6e22e">writeReplace&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ObjectStreamException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Serial&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object &lt;span style="color:#a6e22e">readResolve&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> ObjectStreamException {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このアノテーションをつけることで、コンパイルタイムでエラーをキャッチできるのも特徴的です。例えば、このアノテーションを以下のようなクラスのメンバに使う場合はコンパイルエラーとなります。&lt;/p>
&lt;ul>
&lt;li>Serializableを実装してないクラス&lt;/li>
&lt;li>Enumのように、Serializeの効果がないクラス&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Externalizable.html" target="_blank" rel="noopener"
>Externalizable&lt;/a>を継承しているクラス&lt;/li>
&lt;/ul>
&lt;p>このようなアノテーションが追加されたことによって、JacksonやGsonなどのライブラリの実装にも何か影響があるかもしれません。&lt;/p>
&lt;h3 id="string">String
&lt;/h3>&lt;p>同じ文字列だとしても、Javaでは&lt;code>java.lang.String&lt;/code>、Kotlinでは&lt;code>kotlin.text.String&lt;/code>を使うことになるので、Kotlinを使う場合はあまりJavaのAPIを使うことはないかと思います（また、JavaでのString関連のAPIは、Kotlinだと&lt;code>deprecated&lt;/code>になるケースが多いです）。なので、ここでは新しいAPIと、Kotlinで同じような処理をするために使える方法を中心に紹介します。&lt;/p>
&lt;h4 id="formatted-15">formatted (15)
&lt;/h4>&lt;p>Javaでは&lt;code>String.format()&lt;/code>をで文字列をフォーマットとして使うことができました。多くの場合、文字列は&lt;code>+&lt;/code>を使うよりフォーマットを使った方が性能が良いと言われていて、よく使っていたものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;formatted string&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 15以前&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String formattedString &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;this is %s&amp;#34;&lt;/span>, name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 15以降&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String newFormattedString &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is %s&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">formatted&lt;/span>(name);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Koltinだと&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/format.html" target="_blank" rel="noopener"
>String.format&lt;/a>と&lt;a class="link" href="https://kotlinlang.org/docs/basic-syntax.html#string-templates" target="_blank" rel="noopener"
>String Templates&lt;/a>が使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> name = &lt;span style="color:#e6db74">&amp;#34;formatted string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Format
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> formattedString = &lt;span style="color:#e6db74">&amp;#34;this is %s&amp;#34;&lt;/span>.format(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String Template
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> templateString = &lt;span style="color:#e6db74">&amp;#34;this is &lt;/span>&lt;span style="color:#e6db74">$name&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="indent-12">indent (12)
&lt;/h4>&lt;p>&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#indent%28int%29" target="_blank" rel="noopener"
>indent&lt;/a>では、対象の文字列に引数で指定した分のwhite spaceを入れます。引数が&lt;code>int&lt;/code>型なので、負数を渡すことでwhite spaceを減らすこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String nonIndent &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデントを追加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String indented10 &lt;span style="color:#f92672">=&lt;/span> nonIndent.&lt;span style="color:#a6e22e">indent&lt;/span>(10); &lt;span style="color:#75715e">// &amp;#34; A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデントを削除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String indented5 &lt;span style="color:#f92672">=&lt;/span> indented10.&lt;span style="color:#a6e22e">indent&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>5); &lt;span style="color:#75715e">// &amp;#34; A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの場合は、インデントを追加するための&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/prepend-indent.html" target="_blank" rel="noopener"
>prependIndent&lt;/a>や代替するするための&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/replace-indent.html" target="_blank" rel="noopener"
>replaceIndent&lt;/a>などがあり、渡すパラメータも文字列となるのでJavaのものとは少し使い方が違います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> nonIndent = &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデントを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> prepended = nonIndent.prependIndent(&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>) &lt;span style="color:#75715e">// &amp;#34; A&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデントを代替（なかった場合は追加）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> replaced = prepended.replaceIndent(&lt;span style="color:#e6db74">&amp;#34;|||||&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// &amp;#34;|||||A&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="stripindent-15">stripIndent (15)
&lt;/h4>&lt;p>&lt;code>Text Block&lt;/code>で複数行の文字列を扱う場合、ソースコード上の可読性の都合で任意のインデントを入れたら実際のデータとしては扱いづらい場合もあるはずです。ここでインデントを削除するためののものが&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#stripIndent%28%29" target="_blank" rel="noopener"
>stringIndent&lt;/a>です。&lt;/p>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html" target="_blank" rel="noopener"
>trimIndent&lt;/a>が同じ役割をしています。&lt;/p>
&lt;h4 id="transform-12">transform (12)
&lt;/h4>&lt;p>文字列に対して&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener"
>Function&lt;/a>を実行するという単純なAPIです。&lt;code>replace&lt;/code>では不可能な、条件による処理などが必要なときに使えそうです。実装を見ると極めて単純です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>R&lt;span style="color:#f92672">&amp;gt;&lt;/span> R &lt;span style="color:#a6e22e">transform&lt;/span>(Function&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> String, &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> R&lt;span style="color:#f92672">&amp;gt;&lt;/span> f) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> f.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは文字列でも&lt;code>map&lt;/code>・&lt;code>filter&lt;/code>・&lt;code>reduce&lt;/code>のような高階関数が使えるのでこれらを使うこともできますね。もしくは以下のような拡張関数を定義することで同じことができるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">R&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">String&lt;/span>.transform(f: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): R = f(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="translateescapes-15">translateEscapes (15)
&lt;/h4>&lt;p>エスケープになっている一部の文字をリテラルに変えてくれる機能です。こちらはコードを見た方が理解が早いかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this\\nis\\nmutli\\nline&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String escapeTranslated &lt;span style="color:#f92672">=&lt;/span> string.&lt;span style="color:#a6e22e">translateEscapes&lt;/span>() &lt;span style="color:#75715e">// &amp;#34;this\nis\nmutli\nline&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前は&lt;code>Matcher&lt;/code>と正規式を組み合わせるなど独自の処理を書くか、ライブラリに依存していたと思いますので、こういうのができると嬉しいですね。変換されるエスケープ文字は以下の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Escape&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Translation&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>\b&lt;/code>&lt;/td>
&lt;td>backspace&lt;/td>
&lt;td>U+0008&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\t&lt;/code>&lt;/td>
&lt;td>horizontal tab&lt;/td>
&lt;td>U+0009&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\n&lt;/code>&lt;/td>
&lt;td>line feed&lt;/td>
&lt;td>U+000A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\f&lt;/code>&lt;/td>
&lt;td>form feed&lt;/td>
&lt;td>U+000C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\r&lt;/code>&lt;/td>
&lt;td>carriage return&lt;/td>
&lt;td>U+000D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\s&lt;/code>&lt;/td>
&lt;td>space&lt;/td>
&lt;td>U+0020&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\&amp;quot;&lt;/code>&lt;/td>
&lt;td>double quote&lt;/td>
&lt;td>U+0022&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\'&lt;/code>&lt;/td>
&lt;td>single quote&lt;/td>
&lt;td>U+0027&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\\&lt;/code>&lt;/td>
&lt;td>backslash&lt;/td>
&lt;td>U+005C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\0 - \377&lt;/code>&lt;/td>
&lt;td>octal escape&lt;/td>
&lt;td>code point equivalents&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>\&amp;lt;line-terminator&amp;gt;&lt;/code>&lt;/td>
&lt;td>continuation&lt;/td>
&lt;td>discard&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Kotlinでは似たようなAPIがないので、必要なら独自の処理を書いた方が良さそうです。（ライブラリは知らず…）&lt;/p>
&lt;h3 id="mapentrycopyof-17">Map.Entry.copyOf (17)
&lt;/h3>&lt;p>&lt;code>Map.Entry&lt;/code>のコピーを作成します。コピーしたエントリは元のMapとは何の関係もないデータとなります。以下のようなサンプルコードを&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.Entry.html" target="_blank" rel="noopener"
>公式ドキュメント&lt;/a>から提示していますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> entries &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">entrySet&lt;/span>().&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">map&lt;/span>(Map.&lt;span style="color:#a6e22e">Entry&lt;/span>::copyOf).&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに&lt;code>Map&lt;/code>そのもののコピーは、10から追加された&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html#copyOf%28java.util.Map%29" target="_blank" rel="noopener"
>copyOf&lt;/a>でできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> copiedMap &lt;span style="color:#f92672">=&lt;/span> Map.&lt;span style="color:#a6e22e">copyOf&lt;/span>(map);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinだと、&lt;code>Entry&lt;/code>のコピーは以下のようにできます。型は&lt;code>List&amp;lt;MutableMap.MutableEntry&amp;lt;K, V&amp;gt;&amp;gt;&lt;/code>となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Map.Entryを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> entriesJava = map.entries.map { &lt;span style="color:#a6e22e">Map&lt;/span>.&lt;span style="color:#a6e22e">Entry&lt;/span>.copyOf(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// KotlinのMap.Entryを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> entriesKotlin = map.entries.toSet()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、Kotlinでの&lt;code>Map&lt;/code>のコピー方法は以下のようにできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> copiedMap = map.toMap()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="stream">Stream
&lt;/h3>&lt;h4 id="mapmulti-16">mapMulti (16)
&lt;/h4>&lt;p>16からStreamに&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html#mapMulti%28java.util.function.BiConsumer%29" target="_blank" rel="noopener"
>mapMulti&lt;/a>というメソッドが追加されました。基本的には「Streamの要素に1:Nの変換を適用して結果をStreamを返す」という処理なので、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Stream.html#flatMap%28java.util.function.Function%29" target="_blank" rel="noopener"
>flatMap&lt;/a>に似ていますが、以下のケースでは&lt;code>flatMap&lt;/code>を使う場合より良いと言われています。&lt;/p>
&lt;ul>
&lt;li>要素を減らす場合&lt;/li>
&lt;li>要素をStreamに変換するのが難しい場合&lt;/li>
&lt;/ul>
&lt;p>まずはオブジェクトがネストされているCollectionに対して&lt;code>flatMap&lt;/code>を使う場合を考えてみましょう。要素を減らすケースでは、&lt;code>flatMap&lt;/code>でまず全ての要素を展開し、&lt;code>filter&lt;/code>を使って条件に合う要素だけを取る必要があります。ここで要素を展開するには、全ての要素を&lt;code>Stream&lt;/code>に変換しなければならないので、全ての要素のグループに対して&lt;code>Stream&lt;/code>のインスタンスを作ることになります。また、オブジェクトがネストしている場合は、その個別の要素に対してどうやって&lt;code>Stream&lt;/code>に変換するか、処理の中で定義する必要があります。&lt;/p>
&lt;p>問題は&lt;code>Stream&lt;/code>のインスタンスを毎回作るためオーバヘッドが発生することにもなるし、要素がさまざまな型のオブジェクトである場合は&lt;code>Stream&lt;/code>に変換する処理を書くのも大変ということです。例えば以下のようなListがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> numbers &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(List.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2L), 3, List.&lt;span style="color:#a6e22e">of&lt;/span>(4, 5L, 6), List.&lt;span style="color:#a6e22e">of&lt;/span>(7L), 8L);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このListから、&lt;code>Integer&lt;/code>のみを抽出して別のListにしたい場合はどうしたら良いでしょうか。まず&lt;code>flatMap&lt;/code>を使うとしたら、以下のような処理を書くことになるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> integers &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">flatMap&lt;/span>( &lt;span style="color:#75715e">// 要素をStreamに変換する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (it &lt;span style="color:#66d9ef">instanceof&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> l) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> StreamSupport.&lt;span style="color:#a6e22e">stream&lt;/span>(l.&lt;span style="color:#a6e22e">spliterator&lt;/span>(), &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>(it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(it &lt;span style="color:#f92672">-&amp;gt;&lt;/span> it &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer) &lt;span style="color:#75715e">// Integerのみを取る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(it &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (Integer) it) &lt;span style="color:#75715e">// ObjectからIntegerへキャスト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを&lt;code>mapMulti&lt;/code>を使って処理する場合は以下のようになります。よりシンプルになりましたね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MultiMapper&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">expandIterable&lt;/span>(Object e, Consumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (e &lt;span style="color:#66d9ef">instanceof&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i.&lt;span style="color:#a6e22e">forEach&lt;/span>(ie &lt;span style="color:#f92672">-&amp;gt;&lt;/span> expandIterable(ie, c));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (e &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.&lt;span style="color:#a6e22e">accept&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> integers &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">mapMulti&lt;/span>(MultiMapper::expandIterable).&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/new-list.html#:~:text=java.util.stream.Stream.mapMultiToInt%28BiConsumer%3C%3F%20super%20T%2C%20%3F%20super%20IntConsumer%3E%29" target="_blank" rel="noopener"
>mapMultiToInt&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/new-list.html#:~:text=java.util.stream.Stream.mapMultiToLong%28BiConsumer%3C%3F%20super%20T%2C%20%3F%20super%20LongConsumer%3E%29" target="_blank" rel="noopener"
>mapMultiToLong&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/new-list.html#:~:text=java.util.stream.Stream.mapMultiToDouble%28BiConsumer%3C%3F%20super%20T%2C%20%3F%20super%20DoubleConsumer%3E%29" target="_blank" rel="noopener"
>mapMultiToDouble&lt;/a>などのメソッドも追加されていますので、数字を扱う場合はこちらを使った方が便利でしょう。例えば、上記の&lt;code>mapMulti&lt;/code>を&lt;code>mapMultiToInt&lt;/code>で書く場合は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MultiMapper&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">expandIterable&lt;/span>(Object e, IntConsumer c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (e &lt;span style="color:#66d9ef">instanceof&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i.&lt;span style="color:#a6e22e">forEach&lt;/span>(ie &lt;span style="color:#f92672">-&amp;gt;&lt;/span> expandIterable(ie, c));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (e &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.&lt;span style="color:#a6e22e">accept&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> integers &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">mapMultiToInt&lt;/span>(MultiMapper::expandIterable).&lt;span style="color:#a6e22e">boxed&lt;/span>().&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mapMultiToInt&lt;/code>の戻り値は&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/IntStream.html" target="_blank" rel="noopener"
>IntStream&lt;/a>なので、&lt;code>Stream&amp;lt;Integer&amp;gt;&lt;/code>に変換するために&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/IntStream.html#boxed%28%29" target="_blank" rel="noopener"
>boxed&lt;/a>を呼び出し、&lt;code>Consumer&lt;/code>が&lt;code>IntConsumer&lt;/code>に変わり、&lt;code>mapMulti&lt;/code>の型指定が変わるなど少しの違いがあります。&lt;/p>
&lt;p>Kotlinではそもそも&lt;code>flatMap&lt;/code>を&lt;code>Stream&lt;/code>として扱わないので、そもそもの処理を違う観点から考える必要があります。幸い、KotlinのCollectionには色々なAPIがあるので、そこまで難しくはないです。例えば、オブジェクトのインスタンスを基準に要素を集約したい場合は以下のようなコードを書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;B&amp;#39;&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>, setOf(&lt;span style="color:#e6db74">&amp;#34;D&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;E&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;F&amp;#34;&lt;/span>), listOf(&lt;span style="color:#e6db74">&amp;#39;G&amp;#39;&lt;/span>), &lt;span style="color:#e6db74">&amp;#39;H&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> result: List&amp;lt;String&amp;gt; = list.flatMap {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> Iterable&amp;lt;*&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.filterIsInstance&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listOf(&lt;span style="color:#66d9ef">it&lt;/span>).filterIsInstance&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// [A, C, D, F]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Javaでは&lt;code>List.of(1, 2L)&lt;/code>でListを作成した場合、1はint、2LはLongとして扱われますが、Kotlinでは&lt;code>listOf(1, 2L)&lt;/code>が&lt;code>List&amp;lt;Long&amp;gt;&lt;/code>となってしまうので、そもそもの型に注意する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2L&lt;/span>), &lt;span style="color:#ae81ff">3&lt;/span>, setOf(&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5L&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>), listOf(&lt;span style="color:#ae81ff">7L&lt;/span>), &lt;span style="color:#ae81ff">8L&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> result = list.flatMap {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> Iterable&amp;lt;*&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.filterIsInstance&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listOf(&lt;span style="color:#66d9ef">it&lt;/span>).filterIsInstance&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// [3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="tolist16">toList(16)
&lt;/h4>&lt;p>Streamの終端処理として使用頻度の高い「Listに集計する」をシンタックス・シュガーとして作ったような感覚のメソッドです。ここはKotlinの機能をJavaが受け入れたような気もしますね。処理の結果として生成されるListは&lt;code>Unmodifiable&lt;/code>です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;D&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 旧&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> upper &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">map&lt;/span>(String::toUpperCase).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toUnmodifiableList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 新&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> lower &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">map&lt;/span>(String::toLowerCase).&lt;span style="color:#a6e22e">toList&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは基本的にCollectionで高階関数を呼び出した結果が&lt;code>Unmodifiable&lt;/code>なListになるのですが、&lt;code>stream&lt;/code>に変換して使うこともできるので、場合によっては便利なのかもしれませんね。&lt;/p>
&lt;h3 id="collectorsteeing-12">Collectors.teeing (12)
&lt;/h3>&lt;p>Collectorsに、二つの&lt;code>Collector&lt;/code>を結合する&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html#teeing%28java.util.stream.Collector,java.util.stream.Collector,java.util.function.BiFunction%29" target="_blank" rel="noopener"
>teeing&lt;/a>というメソッドが追加されました。ちなみに&lt;code>Tee&lt;/code>は二つの水道管を接続して一つにしてくれる「T字継手」の意味を持つらしいです。引数に二つの&lt;code>Collector&lt;/code>と、それを結合する処理の&lt;code>BiFunction&lt;/code>を指定する形となっています。&lt;/p>
&lt;p>例えば以下のような&lt;code>Stream&lt;/code>があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">record&lt;/span> &lt;span style="color:#a6e22e">Member&lt;/span>(String name, &lt;span style="color:#66d9ef">boolean&lt;/span> enabled) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member1, enabled=false],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member2, enabled=true],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member3, enabled=false],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member4, enabled=true],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream&lt;span style="color:#f92672">&amp;lt;&lt;/span>Member&lt;span style="color:#f92672">&amp;gt;&lt;/span> members &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(1, 4).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(it &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Member(&lt;span style="color:#e6db74">&amp;#34;Member&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> it, it &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを&lt;code>teeing&lt;/code>を使って、&lt;code>Member&lt;/code>の&lt;code>enabled&lt;/code>を基準に二つのListに分けるとしたら以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member2, enabled=true],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member4, enabled=true]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* ],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* [
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member1, enabled=false],
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Member[name=Member3, enabled=false]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* ]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Member&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> members.&lt;span style="color:#a6e22e">collect&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">teeing&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">filtering&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Member::enabled,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">filtering&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Predicate.&lt;span style="color:#a6e22e">not&lt;/span>(Member::enabled),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (list1, list2) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(list1, list2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinではそもそも&lt;code>collect&lt;/code>する必要がないので、&lt;code>Collection&lt;/code>の高階関数を使った処理をした方が良いでしょう。（Javaでもそうした方がわかりやすいような…）&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがだったでしょうか。さすがに全ての変更事項を整理するのは難しかったので、目立っている変化だけをいくつか取り上げてみましたが、それでもかなりの量ですね。ただ確かなのは、Java 17が11よりもさらにモダンな言語になったバージョンであるので、Javaを使っている案件なら十分導入する価値がありそうです。また、Java 15からは11に比べてG1GCの改良による&lt;a class="link" href="https://www.optaplanner.org/blog/2021/01/26/HowMuchFasterIsJava15.html" target="_blank" rel="noopener"
>性能向上もあった&lt;/a>ようですので、性能という面でも良いですね。&lt;/p>
&lt;p>Kotlinを使っている場合でも、APIだけを見るとあまりメリットはないかもしれませんが、JVMを使っている限り性能向上などの恩恵を受けることはできると思われるので、導入を考慮しても良いかなと思います。また次のLTSでは色々と面白いAPIが続々と登場するかもしれませんしね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>今更な文字列操作の話</title><link>https://retheviper.github.io/posts/java-string-concat-and-split/</link><pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-string-concat-and-split/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post 今更な文字列操作の話" />&lt;p>もうこれで3回目の、「今更なシリーズ」です。このシリーズ自体は、またベンチマークとともに戻ってきました。さて、今回のテーマはJavaによる文字列の操作となりますが、その中でも&lt;code>連結(Join)&lt;/code>と&lt;code>分割(split)&lt;/code>について述べたいと思います。最初は単純に、文字列の分割は&lt;code>String.split()&lt;/code>でやるしかないのに、連結の場合は&lt;code>String.join()&lt;/code>とか&lt;code>Collectors.joining()&lt;/code>とか、色々あるなと思ったのがきっかけです。同じことが複数のAPIでできるのは、単純に&lt;a class="link" href="https://ja.wikipedia.org/wiki/%e7%b3%96%e8%a1%a3%e6%a7%8b%e6%96%87" target="_blank" rel="noopener"
>シンタックスシュガー&lt;/a>な場合もありますが、実際は全く実装が違うケースもありますね。特に、Javaのように長い間使われてきた言語こそそのようなケースが多いかと思います。&lt;/p>
&lt;p>また、単純なシンタックスシュガーに近い場合でも、その前後のコードや可読性など、周りの様相を考慮して適切なものを選ぶ必要がある場合もあります。例えば、以前紹介したInputStreamの&lt;code>transferTo()&lt;/code>がそのようなケースですね。なので、一つのAPIを使う場合は、できればその実装がどうなっているかを確認してみるのも、良いコードを書くための工夫となるのではないかと思います。&lt;/p>
&lt;p>ではでは、早速本題に入りましょう。まずは文字列の連結からです。&lt;/p>
&lt;h2 id="concatenating">Concatenating
&lt;/h2>&lt;p>文字列の連結といっても、色々なケースがありますね。そしてそういった場合は、&lt;code>String.concat()&lt;/code>、&lt;code>String.format()&lt;/code>などさまざまな方法があって、それら全部に対してシナリオを想定し検証するということは難しいと思います。なので今回は、「文字列の配列もしくはCollectionを、区切り文字でつないで一つの文字列にする」というケース一つに限定して述べたいと思います。&lt;/p>
&lt;p>Javaでの区切り文字を使った文字列の連結には、主に以下のような方法が考えられます。これら一つ一つのAPIの特徴と、実際の使い方を持って比較して見た後、いつもの通りベンチマークをするということで性能を測定することとします。(&lt;code>+&lt;/code>を使って文字列を繋ぐケースは、あまりよろしくないと思うのでケース外としています)&lt;/p>
&lt;ul>
&lt;li>&lt;code>String.join()&lt;/code>&lt;/li>
&lt;li>&lt;code>StringJoiner&lt;/code>&lt;/li>
&lt;li>&lt;code>StringBuffer&lt;/code>&lt;/li>
&lt;li>&lt;code>StringBuilder&lt;/code>&lt;/li>
&lt;li>&lt;code>Collectors.joining()&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="stringbuffer--stringbuilder">StringBuffer || StringBuilder
&lt;/h3>&lt;p>純粋に、Collectionや配列になっている複数の文字列を連結する場合もあるとは思いますが、普通、文字列の連結が必要となる場合では、「とある規則によって」という条件がつくケースが多いかなと思います。例えば、ダッシュ(-)、アンダースコア(_)、カンマ(,)などで並ぶようにですね。そしてこのような規則がある場合、&lt;code>StringBuffer&lt;/code>や&lt;code>StringBuilder&lt;/code>を使った方法は他と比べて少し不利です。なぜなら、最後に区切り文字(delimiter)が付かないように制御するにはかなりコードの書き方に注意しなければならないからです。以下のコードが、そのようなケースです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// StringBufferを使う例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String delimiter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringBuffer buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuffer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listの要素と区切り文字を足す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String string : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(delimiter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> buffer.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// A, B, C,&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あえて、文字列の末尾に区切り文字が付かないようにするとしたら、おそらくこういうコードを書く必要があるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String delimiter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> limit &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringBuffer buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuffer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listの要素と区切り文字を足す(最後のインデックスの前まで)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> limit; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(list.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(delimiter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 最後の要素を足す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>buffer.&lt;span style="color:#a6e22e">append&lt;/span>(list.&lt;span style="color:#a6e22e">get&lt;/span>(limit));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> buffer.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// A, B, C&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こういう問題があるのに比べて、他の方法(&lt;code>String.join()&lt;/code>、&lt;code>StringJoiner&lt;/code>、&lt;code>Collectors.joining()&lt;/code>)は、区切り文字が最後の要素の後に付かないので、よりシンプルなコードで書けるというメリットがありますね。なので、結論として&lt;code>StringBuffer&lt;/code>や&lt;code>StringBuilder&lt;/code>は、少なくとも「とある規則によって」複数の文字列を連結する場合には可読性という観点からしてあまり良い選択肢ではないということがわかります。&lt;/p>
&lt;h3 id="stringjoiner">StringJoiner
&lt;/h3>&lt;p>&lt;code>StringBuffer&lt;/code>と&lt;code>StringBuilder&lt;/code>ではループで文字列を連結して行くので、ループの中で条件分岐など他の処理も必要な場合に使えるのでは？と思われるかもしれません。しかし、そういう場合でも、&lt;code>StringJoiner&lt;/code>を使ったほうが良いですね。なぜなら、使い方はほぼ変わらなく、特に操作をしなくても常に末尾に区切り文字が付かないからです。以下は、&lt;code>StringJoiner&lt;/code>のもっともベーシックな使い方のコードとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 区切り文字を指定してインスタンスを作る&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringJoiner joiner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringJoiner(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// あとは要素を足していく&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String string : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> joiner.&lt;span style="color:#a6e22e">add&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> joiner.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// A, B, C&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>StringJoiner&lt;/code>を使った場合は、PrefixとSuffixの指定も可能です。これらを指定した場合、文字列の先頭と末尾に指定したPrefixとSuffixが付くようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 区切り文字とPrefix、Suffixまで指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StringJoiner joiner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringJoiner(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;[&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;]&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String string : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> joiner.&lt;span style="color:#a6e22e">add&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> joiner.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// [A, B, C]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使い方だけ見ても、区切り文字を持って文字列を繋ぐ場合は&lt;code>StringBuffer&lt;/code>や&lt;code>StringBuilder&lt;/code>より&lt;code>StringJoiner&lt;/code>の方がより簡単であるということが分かります。&lt;/p>
&lt;h4 id="番外stringjoinerの実装">番外：StringJoinerの実装
&lt;/h4>&lt;p>ついでに、StringJoinerはどんなコードで書かれているかを見ていきたいと思います。まずは&lt;code>add()&lt;/code>ですが、これは面白くも、&lt;code>ArrayList&lt;/code>の実装と似たような感じになっています。&lt;code>StringJoiner&lt;/code>クラスはフィールドとして&lt;code>String[]&lt;/code>を持っていて、&lt;code>add()&lt;/code>がよばれる度にそれより大きいコピーを作っていく形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> StringJoiner &lt;span style="color:#a6e22e">add&lt;/span>(CharSequence newElement) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String elt &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">valueOf&lt;/span>(newElement);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (elts &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elts &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">[&lt;/span>8&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">==&lt;/span> elts.&lt;span style="color:#a6e22e">length&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elts &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">copyOf&lt;/span>(elts, 2 &lt;span style="color:#f92672">*&lt;/span> size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len &lt;span style="color:#f92672">+=&lt;/span> delimiter.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len &lt;span style="color:#f92672">+=&lt;/span> elt.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elts&lt;span style="color:#f92672">[&lt;/span>size&lt;span style="color:#f92672">++]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> elt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして&lt;code>toString()&lt;/code>では、フィールドの&lt;code>String[]&lt;/code>をループしながら、区切り文字とともに繋げて行くのが分かります。少し変わっているのは、性能を意識しているからか、&lt;code>char[]&lt;/code>として文字列をつめた後から新しく&lt;code>String&lt;/code>のインスタンスを作って返しているというところですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">toString&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span> elts &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elts&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (elts &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> emptyValue &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> emptyValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> addLen &lt;span style="color:#f92672">=&lt;/span> prefix.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> suffix.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (addLen &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compactElts();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> size &lt;span style="color:#f92672">==&lt;/span> 0 &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> : elts&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String delimiter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">delimiter&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> chars &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">[&lt;/span>len &lt;span style="color:#f92672">+&lt;/span> addLen&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> getChars(prefix, chars, 0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+=&lt;/span> getChars(elts&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>, chars, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+=&lt;/span> getChars(delimiter, chars, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+=&lt;/span> getChars(elts&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>, chars, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> k &lt;span style="color:#f92672">+=&lt;/span> getChars(suffix, chars, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> String(chars);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="stringjoin">String.join()
&lt;/h3>&lt;p>&lt;code>String.join()&lt;/code>は、&lt;code>InputStream.transferTo()&lt;/code>のように、あくまでシンタックスシュガーとして存在するものだと言えます。以下は実際のコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">join&lt;/span>(CharSequence delimiter,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Iterable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> CharSequence&lt;span style="color:#f92672">&amp;gt;&lt;/span> elements) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(delimiter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(elements);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringJoiner joiner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringJoiner(delimiter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (CharSequence cs: elements) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> joiner.&lt;span style="color:#a6e22e">add&lt;/span>(cs);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> joiner.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>引数に対するNullチェック以外は、Prefix・Suffixなしの&lt;code>StringJoiner&lt;/code>での連結になっているということを確認できます。なので、より短いコードを書きたい場合は&lt;code>StringJoiner&lt;/code>を使うよりも、こちらの方が便利ではありますね。&lt;/p>
&lt;h3 id="collectorsjoining">Collectors.joining()
&lt;/h3>&lt;p>文字列の連結で&lt;code>Stream&lt;/code>を利用する場合、他にも&lt;code>filter()&lt;/code>、&lt;code>map()&lt;/code>、&lt;code>peek()&lt;/code>など、さまざまな処理をメソッドチェイニングで書けるというところが魅力的ですね。個人的には、処理の役割と目的・影響範囲が明確に見えるので、&lt;code>Stream&lt;/code>による処理を好んで使っています。ただ、以前のポストでも書いたことがありますが、多くの場合に&lt;code>Stream&lt;/code>は伝統的なループより性能面で不利ですので、時と場合によって適切に選ぶべきでしょう。&lt;/p>
&lt;p>さて、そんな&lt;code>Stream&lt;/code>ですが、中の実装はどうなっているのでしょうか。&lt;code>Collectors.joining()&lt;/code>の場合、以下のような実装となっています。結局は、&lt;code>StringJoiner&lt;/code>を内部で使っているだけですので、&lt;code>String.join()&lt;/code>・&lt;code>StringJoiner&lt;/code>と比べては、&lt;code>Stream&lt;/code>によるコードの変化や性能に影響されるだけと言えるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Collector&lt;span style="color:#f92672">&amp;lt;&lt;/span>CharSequence, &lt;span style="color:#f92672">?&lt;/span>, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">joining&lt;/span>(CharSequence delimiter,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CharSequence prefix,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CharSequence suffix) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CollectorImpl&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringJoiner(delimiter, prefix, suffix),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringJoiner::add, StringJoiner::merge,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringJoiner::toString, CH_NOID);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="tostring">toString()
&lt;/h3>&lt;p>実は、Collectionの場合(&lt;code>List&amp;lt;String&amp;gt;&lt;/code>)は、もっと簡単に文字列を作る方法がありますね。&lt;code>toString()&lt;/code>を呼ぶことで、簡単にカンマ区切りの文字列が出来上がります。ただ、そうして文字列を作った場合、先頭と末尾に&lt;code>[]&lt;/code>が入ってしまうので、場合によってはそれらを取り消すか、&lt;code>substring()&lt;/code>で抽出するかの追加的な処理が必要となりますね。以下は、&lt;code>substring()&lt;/code>を利用して&lt;code>[]&lt;/code>の中の文字列だけを切り取るサンプルとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String toString &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">toString&lt;/span>(); &lt;span style="color:#75715e">// [A, B, C]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> toString.&lt;span style="color:#a6e22e">substring&lt;/span>(1, toString.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1); &lt;span style="color:#75715e">// A, B, C&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、もし区切り文字がカンマではない場合は、とりあえず&lt;code>toString()&lt;/code>で文字列に変換した結果の文字列から、更に&lt;code>replace()&lt;/code>を呼び出し、区切り文字だけを入れ替えるというやり方でも対応はできます。ただ、これは非常に非効率的なやり方ではあります。なぜなら、&lt;code>replace()&lt;/code>のコードをみると、結局はループの中で&lt;code>StrinbBuilder&lt;/code>を使って新しく作り出すような構造となっているからです。実際のコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">replace&lt;/span>(CharSequence target, CharSequence replacement) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String tgtStr &lt;span style="color:#f92672">=&lt;/span> target.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String replStr &lt;span style="color:#f92672">=&lt;/span> replacement.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> indexOf(tgtStr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (j &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> tgtLen &lt;span style="color:#f92672">=&lt;/span> tgtStr.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> tgtLen1 &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(tgtLen, 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> thisLen &lt;span style="color:#f92672">=&lt;/span> length();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> newLenHint &lt;span style="color:#f92672">=&lt;/span> thisLen &lt;span style="color:#f92672">-&lt;/span> tgtLen &lt;span style="color:#f92672">+&lt;/span> replStr.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (newLenHint &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> OutOfMemoryError();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder(newLenHint);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sb.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, i, j).&lt;span style="color:#a6e22e">append&lt;/span>(replStr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">=&lt;/span> j &lt;span style="color:#f92672">+&lt;/span> tgtLen;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (j &lt;span style="color:#f92672">&amp;lt;&lt;/span> thisLen &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (j &lt;span style="color:#f92672">=&lt;/span> indexOf(tgtStr, j &lt;span style="color:#f92672">+&lt;/span> tgtLen1)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sb.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, i, thisLen).&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>少なくとも区切り文字がカンマではない場合は、&lt;code>toString()&lt;/code>と&lt;code>replace()&lt;/code>での文字列の生成よりは、他の方法をとったほうが性能面では有利ではないか、という推測が可能です。もちろん、要素数という変数があるので、実際の性能は測ってみないとわからないものですが…&lt;/p>
&lt;h3 id="ベンチマークしてみる1">ベンチマークしてみる(1)
&lt;/h3>&lt;p>では、文字列を連結するために使える色々なAPIと、その特徴を簡単に把握できたので、次に確認したいのは、やはり性能です。特に気になるのは、&lt;code>String.join()&lt;/code>や&lt;code>Collectors.joining()&lt;/code>でも結局は内部で&lt;code>StringJoiner&lt;/code>を使っているというところです。それはつまり、&lt;code>StringBuffer&lt;/code>や&lt;code>StringBuilder&lt;/code>よりも&lt;code>StringJoiner&lt;/code>が性能で有利だから、でしょうか。&lt;/p>
&lt;p>これらのAPIを利用して、実際のアプリケーションに使われるビジネスロジックのコードを書く立場としては、それはコードを簡単に書ける方が良いのは当然ですが、そもそもこういうAPIの場合は、手間を省けるために性能は良くても複雑なコードで実装する可能性もあるのですので、疑問になります。しかも、多くの場合、文字列の操作では&lt;code>StringBuilder&lt;/code>が早いと言われていますので、ますます性能差というのが気になってきます。なので、いつもの通りにベンチマークを実施してみました。&lt;/p>
&lt;p>ベンチマークは、カンマ区切りで文字列を連結する例として作成しています。以下がそのコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Benchmark&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StringConcatTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String DELIMITER &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> DecimalFormat format &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;0000000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span> &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 1000000).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> format.&lt;span style="color:#a6e22e">format&lt;/span>(i)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">toString&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String toString &lt;span style="color:#f92672">=&lt;/span> target.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(toString.&lt;span style="color:#a6e22e">substring&lt;/span>(1, toString.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stringJoin&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(String.&lt;span style="color:#a6e22e">join&lt;/span>(DELIMITER, target));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">collectorsJoining&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(target.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">joining&lt;/span>(DELIMITER)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stringBuffer&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> StringBuffer buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuffer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> limit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> limit; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(DELIMITER);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buffer.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(limit));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(buffer.&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stringBuilder&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> StringBuilder builder &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> limit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> limit; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builder.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builder.&lt;span style="color:#a6e22e">append&lt;/span>(DELIMITER);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builder.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(limit));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(builder.&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、結果は以下の通りです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StringConcatTest.toString thrpt 25 41.445 ± 0.461 ops/s
StringConcatTest.stringJoin thrpt 25 28.396 ± 0.447 ops/s
StringConcatTest.collectorsJoining thrpt 25 31.024 ± 1.313 ops/s
StringConcatTest.stringBuffer thrpt 25 30.570 ± 1.205 ops/s
StringConcatTest.stringBuilder thrpt 25 45.965 ± 1.736 ops/s
&lt;/code>&lt;/pre>&lt;p>この結果からわかるのは、やはり&lt;code>StringBuilder&lt;/code>の性能は優秀ということですね。ただ、よく知られているように、&lt;code>StringBuilder&lt;/code>はマルチスレッドを考慮したAPIではないので、スレッドセーフなAPIを使う必要のある環境であるなら、他のAPIを考慮すべきですね。そのような観点からすると、意外と、誤差範囲を踏まえて考えると&lt;code>String.join()&lt;/code>が&lt;code>Collectors.joining()&lt;/code>と大差ない性能を見せるという結果となりましたが…このような結果だとすると、気軽に&lt;code>Stream&lt;/code>を使っても良さそうな気がします。&lt;/p>
&lt;p>また、&lt;code>toString()&lt;/code>の結果は、やはり早いものとなっていますが、ここで&lt;code>replace()&lt;/code>を挟んだ瞬間性能は半分以下という結果となっています。なので、無理して&lt;code>toString()&lt;/code>を使う必要はあまりないかな、と思いますね。文字列の連結という目的に合うコードかどうかもすぐわからないし…&lt;/p>
&lt;p>もう一つ確かなのは、&lt;code>StringBuffer&lt;/code>はもう使わなくても良さそうということですね。もうレガシーなコードとして残しておいて、これからはなるべく違うAPIを使うべきなのではないかと思います。&lt;/p>
&lt;h2 id="split">Split
&lt;/h2>&lt;p>次に検証したいのは、文字列の分割です。先に述べたのように、文字列の分割は実質、&lt;code>String.split()&lt;/code>しかない状態と言えますね。&lt;code>substring()&lt;/code>でもなんとか分割はできるかもしれませんが、その場合はループと条件分岐なしでは話にならないので、そもそも論外かと思います。&lt;/p>
&lt;p>ただ、ここで注目したいのは分割した後のことです。&lt;code>String.split()&lt;/code>の戻り値は&lt;code>String[]&lt;/code>なので、場合によって&lt;code>Collection&lt;/code>に変えたくなりますね。なので、どちらかというと「配列をListに」する方法の検証ということとなりますが…とりあえずListをStringに変えてみたので、その逆の場合を考えてみるということで受け止めてくださると幸いです。&lt;/p>
&lt;h3 id="arraysaslist">Arrays.asList()
&lt;/h3>&lt;p>配列をListに変えるもっとも簡単な方法は、&lt;code>Arrays.asList()&lt;/code>だと思います。コードも簡単ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A, B, C&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// まずは分割する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> array &lt;span style="color:#f92672">=&lt;/span> string.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listに変える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(array);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうやって生成したListのインスタンスは、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%9F%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB" target="_blank" rel="noopener"
>Immutable&lt;/a>となってしまいます。中の要素を操作できないということですね。&lt;/p>
&lt;p>もちろん、これは新しいListのインスタンスに要素をコピーすることで解決できます。もっとも簡単なのは、コンストラクタの引数としてListを渡す方法ですね。なので、「配列をMutableなListにする」もっとも簡単な方法は、おそらく以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A, B, C&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// まずは分割する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> array &lt;span style="color:#f92672">=&lt;/span> string.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listに変える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(array);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// MutableなListのインスタンスを作成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> mutableList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(list);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="arraysstream">Arrays.stream()
&lt;/h3>&lt;p>配列をListにするまたの方法は、&lt;code>Stream&lt;/code>を利用することです。文字列の連結でも言及したことなのですが、&lt;code>Stream&lt;/code>の場合は、&lt;code>map()&lt;/code>や&lt;code>filter()&lt;/code>のような中間操作のメソッドを使えるというメリットがありますね。また、&lt;code>Collectors&lt;/code>のどのメソッドを呼ぶかによって結果として生成されるListがImmutableか、Mutableかを決定できるという面もメリット(可読性という観点で)ではないのかと思います。コードは&lt;code>Arrays.asList()&lt;/code>と比べて少し複雑になっているように見えるかもしれませんが。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A, B, C&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// まずは分割する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String&lt;span style="color:#f92672">[]&lt;/span> array &lt;span style="color:#f92672">=&lt;/span> string.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listに変える(Mutable)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> mutableList &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(array).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listに変える(Immutable)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> mutableList &lt;span style="color:#f92672">=&lt;/span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>(array).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toUnmodifiableList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ベンチマークしてみる2">ベンチマークしてみる(2)
&lt;/h3>&lt;p>では、次にまたベンチマークとなります。コード自体は明らかに&lt;code>Arrays.toList()&lt;/code>の方が簡単だったのですが、MutableなListを作るためにはListを生成した後にさらにインスタンスを作成する必要があるということで、性能面で損する可能性もあるのかなという気がします。なので、以上で紹介した&lt;code>Arrays.asList()&lt;/code>と&lt;code>Stream&lt;/code>によるListのインスタンスの作成を、Immutable・Mutableという二つのケースに分けて検証してみました。以下がそのベンチマークのコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Benchmark&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StringSplitTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String DELIMITER &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> DecimalFormat format &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;0000000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span> &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 1000000).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> format.&lt;span style="color:#a6e22e">format&lt;/span>(i)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">joining&lt;/span>(DELIMITER));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">arraysAsListImmutable&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(target.&lt;span style="color:#a6e22e">split&lt;/span>(DELIMITER)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">arraysAsListMutable&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(target.&lt;span style="color:#a6e22e">split&lt;/span>(DELIMITER))));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">streamCollectImmutable&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(target.&lt;span style="color:#a6e22e">split&lt;/span>(DELIMITER)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toUnmodifiableList&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">streamCollectMutable&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(target.&lt;span style="color:#a6e22e">split&lt;/span>(DELIMITER)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして結果は以下の通りです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StringSplitTest.arraysAsListImmutable thrpt 25 8.316 ± 1.085 ops/s
StringSplitTest.arraysAsListMutable thrpt 25 8.133 ± 0.435 ops/s
StringSplitTest.streamCollectImmutable thrpt 25 6.086 ± 0.312 ops/s
StringSplitTest.streamCollectMutable thrpt 25 7.247 ± 0.262 ops/s
&lt;/code>&lt;/pre>&lt;p>ここでは、&lt;code>Arrays.asList()&lt;/code>の方が、性能が高い結果となっていますね。途中で何かしらの操作が必要な場合は&lt;code>Stream&lt;/code>の方が良いかと思いますが、そうではなく、単純に配列をListに変えたい場合はやはり&lt;code>Arrays.AsList()&lt;/code>を使った方がコードもより簡単で、性能面でも少し優勢ということがわかりました。なので、(いつもそうですが)何をしたいかによって適切なコードを選ぶべきかんと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>他にも、文字列の操作に関しては&lt;a class="link" href="https://www.baeldung.com/java-string-performance" target="_blank" rel="noopener"
>Baeldungさんの記事&lt;/a>がかなり良かったので、皆さんにもおすすめしたいと思います。最近は特に、アプリケーションでもっともよく扱うデータ型が文字列となっているので、文字列の操作に関してはなるべく性能と可読性という観点から良い書き方を取りたいものです。個人的には&lt;code>Stream&lt;/code>が大好きなので、なるべくなんでも&lt;code>Stream&lt;/code>で解決したいものですが…Javaだけでなく、プログラミング言語にとって「どんなケースでも正解」というものはないので。&lt;/p>
&lt;p>しかし、Javaに触れてからもう3年も過ぎていますが、今更こんなことを考えるということが恥ずかしい限りですね…次からは、もっと興味深い(そしてこのブログを読まれる方々にも役立つような)ネタを探したいと思います。うまくいくかは少しわからない状態なのですが…！&lt;/p></description></item><item><title>今更なI/Oの話</title><link>https://retheviper.github.io/posts/java-file-copy/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-file-copy/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post 今更なI/Oの話" />&lt;p>以前、Java 1.7から導入されたNIOに関してのポストを書いたことがありますが、いまだにJavaにおけるファイルのI/Oに関しては悩ましいところが多いです。恥ずかしいことですが、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%8B%E3%83%A5%E3%83%BC%E3%82%B9%E3%83%AB%E3%83%BC%E3%83%A0" target="_blank" rel="noopener"
>Newsroom&lt;/a>のセリフでもあるように、「問題を解決する第一歩はそこに問題があるということを認識すること(First step in solving any problem is recognizing there is one)」ですね。なので、今までの自分が書いたコードを振り返り、どのように書いた方が良いかを反省することにしました。&lt;/p>
&lt;p>なので今回は、今までなんとなく使ってきたコードたちを振り返り、なるべくどのような方法をとった方が良いかを考えてみようと思います。ただ、考えられる全てのケースを網羅するのは難しいと思うので、この度はあくまで&lt;code>Javaのコードでファイルをコピーする&lt;/code>場合に限ります。なので、考えてみたいこと(検証対象)は以下の通りになります。&lt;/p>
&lt;ol>
&lt;li>InputStreamとOutputStreamはどう作った方がいいか
&lt;ol>
&lt;li>FileInputStreamとFileOutputStreamを使うか&lt;/li>
&lt;li>Filesのメソッドを使うか&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ファイルコピーはどのような方法を使った方がいいか
&lt;ol>
&lt;li>InputSteamからOutpuStreamへ書くか
&lt;ol>
&lt;li>readAllBytes()&lt;/li>
&lt;li>transferTo()&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Filesのメソッドを使うか&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>今回はこれらの疑問について、よく使われているファイルコピーのコードを一つ一つ見ていきながら、考えてみたいと思います。&lt;/p>
&lt;h2 id="inputstreamとoutputstreamはどう作るべきか">InputStreamとOutputStreamはどう作るべきか
&lt;/h2>&lt;p>まずはInputStreamとOutputStreamです。今も多くの場合、メモリー問題を考えて、ファイルはなるべくStreamとして扱っているのではないかと思います。特に今のJavaがよく使われている分野はWebアプリケーションですが、そのWebアプリケーションを作るための代表的なフレームワークであるSpringでもファイルのアップロードやダウンロードはStreamの形式となっていますし、ローカルのものかネットワーク越しのものかを問わずファイルのデータを取り扱えるという意味ではFileやPathというオブジェクトを使う場合に比べ汎用性という面でも良さそうな気がします。&lt;/p>
&lt;p>ただ、ローカルでファイルをコピーするために、InputStreamやOutputStreamを生成する方法は、Java 1.7以降だと二つの方法があります。一つはFileオブジェクトから&lt;code>FileInputStream&lt;/code>・&lt;code>FileOutputStream&lt;/code>を生成する方式であり、もう一つはPathオブジェクトとFilesクラスを利用して生成する方法ですね。&lt;/p>
&lt;p>なるべくこれからのコードはNIOを使って書きたいと思っていますが、本当にそれだけで十分か、既存のコード(FileInputStreamとFileOutputStreamを利用する)までもNIOのものに変える必要があるかをまず確認してみたいです。&lt;/p>
&lt;h3 id="コピーの方式">コピーの方式
&lt;/h3>&lt;p>まずは、JavaでInputStreamとOutputStreamを利用して、ファイルをコピーするコードから見ていきましょう。&lt;/p>
&lt;p>私を含め、初めてJavaに触れた多くの方々接することとなるファイルコピーのコードは、おそらく以下のようなものではないかと思います。いわば、最も一般的で、オーソドックスな形とも言えるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// byte[]を利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(File source, File dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileInputStream(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileOutputStream(dest);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>8192&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>(buffer)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(buffer, 0, length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BufferedStreamを利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(File source, File dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> buff &lt;span style="color:#f92672">=&lt;/span> 8192;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(&lt;span style="color:#66d9ef">new&lt;/span> FileInputStream(source), buff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(&lt;span style="color:#66d9ef">new&lt;/span> FileOutputStream(dest), buff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでまず、&lt;code>FileInputStream&lt;/code>は&lt;code>Files.newInputStream&lt;/code>、&lt;code>FileOutputStream&lt;/code>は&lt;code>Files.newOutputStream&lt;/code>に代替できます。まず目立つ違いとしては、&lt;code>FileInputStream&lt;/code>・&lt;code>FileOutputStream&lt;/code>は引数として&lt;code>File&lt;/code>を取り、&lt;code>Files.newInputStream&lt;/code>・&lt;code>Files.newOutputStream&lt;/code>は引数として&lt;code>Path&lt;/code>を取るという点がありますね。ただ、この違いは、&lt;code>File&lt;/code>と&lt;code>Path&lt;/code>の変換が自由なので、あまり決定的な違いとは言えません。つまり、どちらの方法にも簡単に切り替えができるということですね。&lt;/p>
&lt;p>一見、&lt;code>Files&lt;/code>クラスからInputStreamとOutputStreamのインスタンスを生成した方が、より最新のAPIを使っているので性能の面で良さそうな気はします。しかし、JavaのNIOは、必ず性能面で既存のIOと比べ優位にあるわけではないですね。実際、ファイルのI/Oに関しては、NIOを使ってもBlockingモードとしてしか動かないので、あまり性能は変わらないという話もあります。&lt;/p>
&lt;p>そういう場合は、特に問題を起こしてないのに、あえて既存のコードをNIOに切り替える必要は無くなりそうな気もします。しかし、本当にそれで大丈夫でしょうか。&lt;/p>
&lt;h3 id="fileinputstreamとfileoutputstreamの問題">FileInputStreamとFileOutputStreamの問題
&lt;/h3>&lt;p>実際は、そうでもないようです。&lt;code>FileInputStream&lt;/code>・&lt;code>FileOuputStream&lt;/code>には性能とは別の問題があります。GCによりアプリケーション全体が長くポーズの状態になる可能性があるということです。&lt;/p>
&lt;h4 id="finalizeのオーバライド問題">finalize()のオーバライド問題
&lt;/h4>&lt;p>GCによりアプリケーション全体がポーズされるということは、つまり、メモリがフルになるということです。ファイルI/Oで、InputStreamとOutputStreamを使ってメモリがフルになるということは、ちゃんと&lt;code>close()&lt;/code>されてないことですね。なので、&lt;code>単純にclose()すれば良いだけなのでは？&lt;/code>と思われます。&lt;/p>
&lt;p>しかし、本当の問題は&lt;code>FileInputStream&lt;/code>・&lt;code>FileOuputStream&lt;/code>のソースコードにあります。この二つのクラスは、&lt;code>finalize()&lt;/code>メソッドをオーバーロードしていて、ちゃんと&lt;code>close()&lt;/code>してもメモリー上にデータが残ってしまう可能性があるのです。この問題は、&lt;a class="link" href="https://dzone.com/articles/fileinputstream-fileoutputstream-considered-harmful" target="_blank" rel="noopener"
>こちらの記事&lt;/a>に説明されてある通り、Jenkinsでも&lt;a class="link" href="https://issues.jenkins.io/browse/JENKINS-42934" target="_blank" rel="noopener"
>問題視されたことがあり&lt;/a>、OpenJDKでも&lt;a class="link" href="https://bugs.openjdk.java.net/browse/JDK-8212050" target="_blank" rel="noopener"
>finalize()を消す必要がある&lt;/a>と指摘されたことがあります。&lt;/p>
&lt;p>JDKの対応としては、&lt;code>FileInputStream&lt;/code>・&lt;code>FileOuputStream&lt;/code>の&lt;code>finalize()&lt;/code>はJava 9から&lt;code>Deprecated&lt;/code>となり、Java 10からは別の実装を加えることで問題を解決していますが、Java 1.7や1.8を使う場合は依然として問題が起こり得るということになりますね。&lt;/p>
&lt;p>なので、これからはなるべく&lt;code>FileInputStream&lt;/code>・&lt;code>FileOutptStream&lt;/code>の利用は避けるようにする必要があると思います。習慣は怖いですので。&lt;/p>
&lt;h2 id="ファイルコピーはどのような方法を使った方がいいか">ファイルコピーはどのような方法を使った方がいいか
&lt;/h2>&lt;p>今までの結論で、InputStream及びOuputStreamのインスタンスはNIOを使うことにします。したがって前述のコードは以下のように直すことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// byte[]を利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source); &lt;span style="color:#75715e">// FileInputStreamを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest); &lt;span style="color:#75715e">// FileOutputStreamを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>8192&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>(buffer)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(buffer, 0, length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BufferedStreamを利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> buff &lt;span style="color:#f92672">=&lt;/span> 8192;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source), buff); &lt;span style="color:#75715e">// FileInputStreamを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest), buff); &lt;span style="color:#75715e">// FileOutputStreamを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="try-with-resource">try-with-resource
&lt;/h3>&lt;p>InputStreamやOutputStreamは最後に&lt;code>close()&lt;/code>しないと、すでに使ったものでもメモリ上にデータが残ってしまいますね。なのでfinallyブロックでクローズするのが一般的かなと思いますが、こうした場合、finallyブロックでも追加の例外処理が必要になるケースもありますし、毎回&lt;code>close()&lt;/code>するのは忘れられる可能性もあるので危険です。&lt;/p>
&lt;p>なのでJava 1.7からは&lt;code>AutoCloseable&lt;/code>と&lt;code>try-with-resource&lt;/code>が導入され、以下のようにより簡潔かつ安全なコードを書くことができるようになりました。例えば上記のコードは、&lt;code>try-with-resource&lt;/code>を使うと以下のようなコードに代替できますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// byte[]を利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>8192&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>(buffer)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(buffer, 0, length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BufferedStreamを利用した例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> buff &lt;span style="color:#f92672">=&lt;/span> 8192;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source), buff);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest), buff)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> is.&lt;span style="color:#a6e22e">read&lt;/span>()) &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> os.&lt;span style="color:#a6e22e">write&lt;/span>(length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>try-with-resourceでは、既存の方式と比べメリットしかないので、これは必ず使うことにします。&lt;/p>
&lt;h3 id="readallbytes">readAllBytes()
&lt;/h3>&lt;p>次に考えられるのは、ファイルコピーでのBufferです。以上の例では、&lt;code>byte[]&lt;/code>を使うか、&lt;code>BufferedInputStream&lt;/code>・&lt;code>BufferedOutputStream&lt;/code>を使っていますが、これは性能のためのものであるということは皆さんもご存知のはずなので、Bufferについては割愛します。&lt;/p>
&lt;p>我々が知る限り、Bufferのサイズが大きければ大きいほど、性能はよくなります。なら、メモリが許容する限り、できるだけ大きいサイズのBufferを指定したら自然に性能はマシンが出せる最大限となるはずです。&lt;/p>
&lt;p>そして、Java 9からは、InputStreamを一気に全部読み込み、&lt;code>byte[]&lt;/code>として返す&lt;code>readAllBytes()&lt;/code>というメソッドができました。このメソッドを使うと、&lt;code>Integer.MAX_VALUE&lt;/code>サイズの&lt;code>byte[]&lt;/code>を生成してInputStreamを全部読み込むことができます。理論的にはこれを使ったらファイルコピーもあっという間にできそうですね。&lt;/p>
&lt;p>しかし、考えなくてはならないのが、そうやって読み込んだデータはメモリ上に残ってしまうということです。例えば複数のユーザが使っているWebアプリケーションで、数GBに達するファイルをアップロードする場合が予想されるのに、&lt;code>readAllBytes()&lt;/code>を使ったらメモリはすぐ足りなくなるでしょう。いくらファイルコピーが早くなるとしても、同時に複数のユーザがファイルをアップロードする場合があれば、一周でのもメモリ上に大量のファイルデータが詰まってしまう可能性があるので、あまり良くない選択になります。なので、なるべく&lt;code>readAllBytes()&lt;/code>の仕様は控えるべきでしょう。&lt;/p>
&lt;h3 id="transferto">transferTo()
&lt;/h3>&lt;p>Java 9からは追加されたメソッドのうちには、InputStreamにはより簡単にOutputStreamにデータを転送することのできる&lt;code>transferTo()&lt;/code>というメソッドもあります。&lt;code>try-with-resource&lt;/code>に加え、&lt;code>transferTo()&lt;/code>を使うとさらに簡潔なコードでファイルのコピーができるようになります。例えば以下のようなものですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path dest) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream os &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(dest)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> is.&lt;span style="color:#a6e22e">transferTo&lt;/span>(os);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ソースコードを見るとわかることですが、&lt;code>transferTo()&lt;/code>ではデフォルトのBufferサイズで作ったbyte[]を使ってコピーをしているので、デフォルト値のBuffer(&lt;code>8192&lt;/code>バイト)を使う場合は、Bufferの指定もいらなくなるのが魅力的です。以下はソースコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">transferTo&lt;/span>(OutputStream out) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(out, &lt;span style="color:#e6db74">&amp;#34;out&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> transferred &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> buffer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>DEFAULT_BUFFER_SIZE&lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#75715e">// 8192&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> read;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((read &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">read&lt;/span>(buffer, 0, DEFAULT_BUFFER_SIZE)) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> out.&lt;span style="color:#a6e22e">write&lt;/span>(buffer, 0, read);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transferred &lt;span style="color:#f92672">+=&lt;/span> read;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> transferred;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ気になるのは、&lt;code>transerTo()&lt;/code>を使う場合は本当にBufferedが要らないかという点です。例えばInputStreamを&lt;code>BufferedInputStream&lt;/code>でラップすると、せめてファイルを読み込む速度は上がるのではないかという疑問が湧いてきます。とにかく、もしものことなので、簡単なベンチマークも実施してみました(実はやってみたかっただけですが)。10GBほどのファイルを生成し、以下のケースでテストしてみました。&lt;/p>
&lt;ul>
&lt;li>InputStream → OutputStream&lt;/li>
&lt;li>BufferedInputStream → OutputStream&lt;/li>
&lt;li>InputStream → BufferedIOutputStream&lt;/li>
&lt;li>BufferedInputStream → BufferedIOutputStream&lt;/li>
&lt;/ul>
&lt;p>そしてコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Benchmark&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@BenchmarkMode&lt;/span>(Mode.&lt;span style="color:#a6e22e">AverageTime&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StreamBufferTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Path source;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Path output &lt;span style="color:#f92672">=&lt;/span> Path.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/Users/retheviper/temp/benchmarkOutput&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テスト用のファイルを作成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/Users/retheviper/temp/benchmarkSource&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> RandomAccessFile file &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RandomAccessFile(path, &lt;span style="color:#e6db74">&amp;#34;rw&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> (1024 &lt;span style="color:#f92672">*&lt;/span> 1024 &lt;span style="color:#f92672">*&lt;/span> 1024) &lt;span style="color:#f92672">*&lt;/span> 10L; &lt;span style="color:#75715e">// 10GB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file.&lt;span style="color:#a6e22e">setLength&lt;/span>(size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">source&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Path.&lt;span style="color:#a6e22e">of&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">noBuffer&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">withInputBuffer&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">withOutputBuffer&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">withBothBuffer&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedOutputStream(Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてベンチマーク結果は、以下の通りです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StreamBufferTest.noBuffer avgt 25 13.055 ± 0.583 s/op
StreamBufferTest.withInputBuffer avgt 25 13.302 ± 0.460 s/op
StreamBufferTest.withOutputBuffer avgt 25 13.663 ± 0.535 s/op
StreamBufferTest.withBothBuffer avgt 25 12.668 ± 0.355 s/op
&lt;/code>&lt;/pre>&lt;p>予想通り、&lt;code>transferTo()&lt;/code>でのコピーの場合、BufferedInputStreamやBufferedOutputStreamを使わなくても性能はあまり変わりありませんでした。単純なファイルコピーではなかったり、InputStreamからOutputStreamというデータの転送ではない場合はまた必要となりそうな気はしますが、このメソッドが使える場合はあまり意識しなくても良さそうですね。&lt;/p>
&lt;h3 id="filescopyがいい">Files.copy()がいい？
&lt;/h3>&lt;p>Java 1.7では、&lt;code>Files.copy()&lt;/code>を通じて以下のファイルコピーができるようになっています。&lt;/p>
&lt;ul>
&lt;li>InputStream → Path&lt;/li>
&lt;li>Path → OutputStream&lt;/li>
&lt;li>Path → Path&lt;/li>
&lt;/ul>
&lt;p>そして一部では、JavaのNIOはネイティブコードで書かれてあるので、InputStreamからOutputStreamへの書き込みよりはFiles.copy()の方が性能がいいと言われる場合もありました。この話が本当さとすると少なくともローカルのファイルを扱う場合、InputStreamからOutputStreamへの書き込みよりはPathを使ったコピーが良さそうな気がします。&lt;/p>
&lt;h4 id="ソースで確認する">ソースで確認する
&lt;/h4>&lt;p>コードが違うと言われたからには、直接確認した方がいいですね。早速、以上であげた三つのメソッドのソースコードを確認することにします。まずは、&lt;code>InputStream → Path&lt;/code>と&lt;code>Path → OutputStream&lt;/code>です。こちらはシンプルに、&lt;code>Path&lt;/code>からOuputStreamもしくはInputStreamを生成し、&lt;code>transferTo()&lt;/code>を使ってコピーすることとなっています。(ただ、これはJava 11基準のソースコードなので、Java 9以前の場合は違うコードの可能性があります)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// InputStream → Path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(InputStream in, Path target, CopyOption... options) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// コピー以外の処理は省略&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream ostream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ostream &lt;span style="color:#f92672">=&lt;/span> newOutputStream(target, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE_NEW&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StandardOpenOption.&lt;span style="color:#a6e22e">WRITE&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (FileAlreadyExistsException x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (se &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> se;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// someone else won the race and created the file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do the copy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (OutputStream out &lt;span style="color:#f92672">=&lt;/span> ostream) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Path → OutputStream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, OutputStream out) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ensure not null before opening file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> newInputStream(source)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、やはり&lt;code>Path → Path&lt;/code>の場合は全く違うコードになっています。コピー元とコピー先が同じファイルシステムの場合は&lt;a class="link" href="https://docs.oracle.com/javase/7/docs/api/java/nio/file/spi/FileSystemProvider.html" target="_blank" rel="noopener"
>FileSystemProvider&lt;/a>を使い、そうではない場合はCopyMoveHelperを使うことになっていますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Path → Path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Path &lt;span style="color:#a6e22e">copy&lt;/span>(Path source, Path target, CopyOption... options) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileSystemProvider provider &lt;span style="color:#f92672">=&lt;/span> provider(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (provider(target) &lt;span style="color:#f92672">==&lt;/span> provider) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// same provider&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> provider.&lt;span style="color:#a6e22e">copy&lt;/span>(source, target, options);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// different providers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CopyMoveHelper.&lt;span style="color:#a6e22e">copyToForeignTarget&lt;/span>(source, target, options);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>CopyMoveHelper.copyToForeignTarget()&lt;/code>の場合は、結果的に&lt;code>Files.copy(InputStream, Path)&lt;/code>を呼ぶことになるのですが、前者の場合は全く違う方式になるのでやはり性能の差が発生する可能性もありそうですね。整理すると、&lt;code>同じシステム内で、Path → Pathでコピーする場合だけ性能がよくなる可能性がある&lt;/code>ということですね。&lt;/p>
&lt;p>ここはまた検証が必要なところなので、またベンチマークを実施してみました。もちろんファイルシステムの違いにより結果は変わる可能性があるので、これが絶対的だとは言えませんが、何らかの違いがあるかもしれません。他の&lt;code>Files.copy()&lt;/code>メソッドは実質的に&lt;code>transferTo()&lt;/code>と同じものなので、今回の比較は&lt;code>InputStream → OutputStream&lt;/code>と&lt;code>Path → Path&lt;/code>だけになります。また、比較のためのテストケースが少ないので、今回は&lt;code>transferTo()&lt;/code>のベンチマークよりもファイルサイズを大きくしてみました。以下は、そのテストコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Benchmark&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@BenchmarkMode&lt;/span>(Mode.&lt;span style="color:#a6e22e">AverageTime&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StreamCopyTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Path source;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Path output &lt;span style="color:#f92672">=&lt;/span> Path.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/Users/youngbinkim/Downloads/benchmarkOutput&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テスト用のファイルを作成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> String path &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/Users/youngbinkim/Downloads/benchmarkSource&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> RandomAccessFile file &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RandomAccessFile(path, &lt;span style="color:#e6db74">&amp;#34;rw&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> (1024 &lt;span style="color:#f92672">*&lt;/span> 1024 &lt;span style="color:#f92672">*&lt;/span> 1024) &lt;span style="color:#f92672">*&lt;/span> 10L; &lt;span style="color:#75715e">// 10GB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file.&lt;span style="color:#a6e22e">setLength&lt;/span>(size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">source&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Path.&lt;span style="color:#a6e22e">of&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">streamToStream&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStream in &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OutputStream out &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(output, StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>, StandardOpenOption.&lt;span style="color:#a6e22e">TRUNCATE_EXISTING&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> in.&lt;span style="color:#a6e22e">transferTo&lt;/span>(out);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pathToPath&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Files.&lt;span style="color:#a6e22e">copy&lt;/span>(source, output, StandardCopyOption.&lt;span style="color:#a6e22e">REPLACE_EXISTING&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、ベンチマークの結果は以下の通りです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StreamCopyTest.streamToStream avgt 25 12.128 ± 0.331 s/op
StreamCopyTest.pathToPath avgt 25 12.257 ± 0.342 s/op
&lt;/code>&lt;/pre>&lt;p>10GBのファイルでは誤差範囲以内の結果となったので、ファイルサイズだけを100GBに変えて同じくベンチマークを実施してみました。その結果は以下です。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
StreamCopyTest.streamToStream avgt 25 160.046 ± 2.538 s/op
StreamCopyTest.pathToPath avgt 25 153.505 ± 2.662 s/op
&lt;/code>&lt;/pre>&lt;p>100GBになってからやっと差が見えてくる、ということになりますが、結論としてはやはり、&lt;code>Path → Path&lt;/code>の方が早いという結果となりました。機会があれば、複数スレッドによるI/OやOSの違いまで考慮したベンチマークを書きたいものですが、とりあえずは予想通りの結果となったということで。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>以上のソースコードとベンチマークでわかったことをまとめると、Javaでのファイルコピーは、とりあえず以下のようなことで結論づけができそうです。&lt;/p>
&lt;ul>
&lt;li>Java 1.7以上の場合
&lt;ul>
&lt;li>&lt;code>FileInputStream&lt;/code>・&lt;code>FileOutputStream&lt;/code>の代わりに&lt;code>Files.newInputStream&lt;/code>・&lt;code>Files.newOutputStream&lt;/code>を使う&lt;/li>
&lt;li>&lt;code>try-with-resource&lt;/code>を使う&lt;/li>
&lt;li>コピー元とコピー先のどちらも同じファイルシステム上のパスであれば、両方&lt;code>Path&lt;/code>が引数の&lt;code>Files.copy()&lt;/code>を使う&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Java 9以上の場合
&lt;ul>
&lt;li>Bufferサイズが&lt;code>8192&lt;/code>の場合は&lt;code>transferTo()&lt;/code>を使う
&lt;ul>
&lt;li>&lt;code>transferTo()&lt;/code>を使う場合、&lt;code>BufferedInputStream&lt;/code>・&lt;code>BufferedOutputStream&lt;/code>は必須ではない&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>多くの場合、エンタープライズアプリケーションはLTSである1.8や11を使うと思われるので、実質的には以上に並べた項目全てが当てはまると言えましょう。&lt;/p>
&lt;p>かなり今更な感があるポストとなりましたが、個人的には自分の納得できる形で整理でき、スッキリしました。こうやって何気なく、「そう教わったから」使っていたコードを振り返ってみるのも良い勉強になりますね。次もまた、こうやってソースコードやベンチマークによる検証をやってみたいなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>9からの新メソッドめぐり</title><link>https://retheviper.github.io/posts/java-new-methods-from-9-to-11/</link><pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-new-methods-from-9-to-11/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post 9からの新メソッドめぐり" />&lt;p>仕事ではJava 11を扱うことが多いのですが、正直、自分の書いたコードを振り返ってみると、Java 9から新しく追加されたメソッドはあまり使ってないのが現実です。しかし、これら新しいメソッドたちは冗長さを隠してくれるシンタックスシュガーとして存在するだけでなく、性能や機能面でより優れているものもあるので、いますぐ使わないとしても目は通しておきたいものが多いなと思っています。&lt;/p>
&lt;p>2021年は次のLTSバージョンとなる17の登場が予告されている時点なので、今更な感はありますが、そろそろ私もSEになってから2年になるので、今回は今年、自分が書いたコードへの反省を含め、Java 9〜11まで新しく追加されたメソッドたちの中から、良さそうな(よく使えそうな)ものを選別してみました。そして今回のポストは、そう選別したメソッドの簡単な紹介となります。&lt;/p>
&lt;p>多くの場合、これらのメソッドを使える環境だとしたらJava 11を導入しているはずなのであまり意味はないのかもしれませんが、それぞれのメソッド名の右に、該当メソッドがどのバージョンから導入されたかを記入していますので参考にしてください。&lt;/p>
&lt;h2 id="stream">Stream
&lt;/h2>&lt;p>StreamこそJava 8のキモではないかと思います。そしてJava 9では、そのStreamの問題を色々と改善したり、より簡単に使えるようなメソッドを用意しています。なので、既存のforループにしか慣れてない人でも、簡単に入門できるようになったのではないかと思います。&lt;/p>
&lt;h3 id="iterate-9">Iterate (9)
&lt;/h3>&lt;p>&lt;code>iterate()&lt;/code>というメソッド名だけではすぐに意味がわからない場合もあると思いますが、このメソッドは伝統的なFor文と同じような構文でStreamでの処理を書くことができるようになります。つまり、「初期化・ループの継続条件・カウンタ変数の更新」を書くことで、Streaｍの要素数を決めることができるという意味です。例えば、以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 0~9までを出力&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(0, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1).&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはつまり、以下のコードと同じ意味を持ちます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、&lt;code>iterate()&lt;/code>で指定できる初期化の値が数字という制限はないので(&lt;code>T&lt;/code>です)、以下のようなこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Aで三角形を出力&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、ループの継続条件を指定しないこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Aで三角形を出力&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>継続条件を指定しないと、無限ループになってしまうのでは？と思われそうですね。確かにそうですが、同じくJava 9でStreamの要素数の上限を指定できる新しいメソッドが追加されています。次に紹介するものがそれです。&lt;/p>
&lt;h3 id="takewhile-9">takeWhile (9)
&lt;/h3>&lt;p>以前、Streamの問題として「途中でやめられない」と書きましたが、Java 9から導入された&lt;code>takeWhile()&lt;/code>メソッドを使うと、途中で処理を終了するようなことができるようになりました。既存にあった&lt;code>limit()&lt;/code>の場合は、「指定された回数分」という限界がありましたが、こちらはPredicate型の条件を指定できるというところが違います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// AAAAAAAAAまで出力する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">takeWhile&lt;/span>(s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、&lt;code>iterate()&lt;/code>の継続条件を書いてない場合には&lt;code>takeWhile()&lt;/code>を使ってどの条件で処理が終わるかを明示した方が良いですね。&lt;/p>
&lt;h3 id="dropwhile-9">dropWhile (9)
&lt;/h3>&lt;p>&lt;code>dropWhile()&lt;/code>は、その名からも推測できますが、&lt;code>takeWhile()&lt;/code>と真逆の機能をするメソッドです。このメソッドはStreamから与えられた条件と一致する要素を除いて、残りの要素を返却します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// AAAAAから出力する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">dropWhile&lt;/span>(s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>s.&lt;span style="color:#a6e22e">contains&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;AAAAA&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ofnullable-9">ofNullable (9)
&lt;/h3>&lt;p>Java 1.8のStreamでは、Null要素を追加するためにはまずその要素がNullかどうかをチェックして、Nullの場合に&lt;code>Stream.empty()&lt;/code>を呼ぶような形にする必要がありました。いつものJavaのNullチェックですね。例えば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素のNullチェックを含むStreamのCollect&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>keyList.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">flatMap&lt;/span>(k &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object value &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">get&lt;/span>(k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> value &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>(value) : Stream.&lt;span style="color:#a6e22e">empty&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、Java 9ではより簡単なコードで書くことができます。&lt;code>Optional&lt;/code>の&lt;code>ofNullable()&lt;/code>とあまり変わらない感覚ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>keyList.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">flatMap&lt;/span>(k &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Stream.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(map.&lt;span style="color:#a6e22e">get&lt;/span>(k)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="collectors">Collectors
&lt;/h2>&lt;p>Streamの要素を集約するためのCollectorを提供する&lt;code>Collectors&lt;/code> APIですが、こちらの変化は主にシンタックスシュガーなものが多い印象です。主にStreamでしかできなかったことや、既存のCollectorsのみだとかなり長くなるコードを簡潔に書くことができるようになっています。&lt;/p>
&lt;h3 id="filtering-9">filtering (9)
&lt;/h3>&lt;p>&lt;code>Stream&lt;/code>の&lt;code>filter()&lt;/code>と同じ処理を、&lt;code>Collector&lt;/code>でもできるようになりました。どちらを使うかは好みの問題な気がしますが、&lt;code>Collector&lt;/code>そのものを共通化するなどの処理ができそうな気はしますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 0~9までのリスト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> numbers &lt;span style="color:#f92672">=&lt;/span> Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(0, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Stream.filter()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>numbers.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(e &lt;span style="color:#f92672">-&amp;gt;&lt;/span> e &lt;span style="color:#f92672">&amp;gt;&lt;/span> 5)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()); &lt;span style="color:#75715e">// 6, 7, 8, 9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collectors.filtering()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>numbers.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">filtering&lt;/span>(e &lt;span style="color:#f92672">-&amp;gt;&lt;/span> e &lt;span style="color:#f92672">&amp;gt;&lt;/span> 5, Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>())); &lt;span style="color:#75715e">// 6, 7, 8, 9&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="flatmapping-9">flatMapping (9)
&lt;/h3>&lt;p>これもまた名前から推測できると思いますが、&lt;code>Collectors&lt;/code>でCollectionに変えるとき、要素のflatMappingをできるようにしてくれるようなものです。具体的には、以下のサンプルコードを参照してください。&lt;/p>
&lt;p>例えば、以下のようなクラスがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Selling&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String clientName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> products;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、このSellingのリストを、「clientNameをKeyに、productsをValueにしたMapにしたい」場合はどうしたら良いでしょうか。例えば以下のような方法を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> operations.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">groupingBy&lt;/span>(Selling::getClientName, Collectors.&lt;span style="color:#a6e22e">mapping&lt;/span>(Selling::getProducts, Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>())));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、問題は、&lt;code>List&amp;lt;Product&amp;gt;&lt;/code>をさらにListの中に入れてしまうことになります。これは本来の目的ともズレていて、無駄な処理が発生し、Valueを持ち出すときも不便なはずです。&lt;/p>
&lt;p>これを&lt;code>Map&amp;lt;String, List&amp;lt;Product&amp;gt;&amp;gt;&lt;/code>の形に変えるとしたら、以下のような方法が使えます。自作のCollectorを作るのですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> operations.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">groupingBy&lt;/span>(Selling::getClientName, Collectors.&lt;span style="color:#a6e22e">mapping&lt;/span>(Selling::getProducts,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collector.&lt;span style="color:#a6e22e">of&lt;/span>(ArrayList::&lt;span style="color:#66d9ef">new&lt;/span>, List::addAll, (x, y) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x.&lt;span style="color:#a6e22e">addAll&lt;/span>(y);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }))));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、毎回このような自作Collectorを作るというのはあまり効率的ではない方法ではないかと思います。それに、自作のCollectorを普段から使ってない場合はコードだけみても少しわかりづらくもありますね。なので、ここは新しく追加された&lt;code>flatMapping()&lt;/code>で変えてみると以下のようになります。より簡潔ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> operations.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">groupingBy&lt;/span>(Selling::getClientName, Collectors.&lt;span style="color:#a6e22e">flatMapping&lt;/span>(selling &lt;span style="color:#f92672">-&amp;gt;&lt;/span> selling.&lt;span style="color:#a6e22e">getProducts&lt;/span>().&lt;span style="color:#a6e22e">stream&lt;/span>(), Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>())));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="tounmodifiable-10">toUnmodifiable (10)
&lt;/h3>&lt;p>Java 10では&lt;code>Collectors&lt;/code>に以下の三つのメソッドが追加されています。&lt;/p>
&lt;ul>
&lt;li>&lt;code>toUnmodifiableList()&lt;/code>&lt;/li>
&lt;li>&lt;code>toUnmodifiableSet()&lt;/code>&lt;/li>
&lt;li>&lt;code>toUnmodifiableMap()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>これらのメソッドを使うと、既存の&lt;code>Collections&lt;/code>を呼ぶ必要なく、簡単に(もっと短いコードで)UnmodifiableなCollectionを作ることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collections.unmodifiableList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> collectionsUnmodifiable &lt;span style="color:#f92672">=&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableList&lt;/span>(Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(0, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collectors.toUnmodifiableList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> collectionsUnmodifiable &lt;span style="color:#f92672">=&lt;/span> Stream.&lt;span style="color:#a6e22e">iterate&lt;/span>(0, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10, i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toUnmodifiableList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>引数は、既存の&lt;code>toList()&lt;/code>・&lt;code>toSet()&lt;/code>・&lt;code>toMap()&lt;/code>と同じなので(&lt;code>toMap()&lt;/code>だけ、KeyとValueのマッピングを指定する必要がありますね)、既存のメソッドと同じ感覚で使うことができます。&lt;/p>
&lt;h2 id="collections">Collections
&lt;/h2>&lt;p>Collections APIの新しいメソッドは、かなり現代的な書き方を可能にします。Kotlinのような言語がJavaの冗長さを回避するための工夫をしているのであれば、Java側に新しく追加されたメソッドはそれをさらにJavaに似合うような形で受け入れたような印象です。(というか、それしか方法はなかったかもしれませんが…)&lt;/p>
&lt;h3 id="factory-method-9">Factory Method (9)
&lt;/h3>&lt;p>Java 9では、&lt;a class="link" href="https://ja.wikipedia.org/wiki/Factory_Method_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3" target="_blank" rel="noopener"
>ファクトリーメソッド&lt;/a>でCollectionの作成ができるようになりました。使い方としては、既存の&lt;code>Arrays.asList()&lt;/code>と似ているような感覚です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listの作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Setの作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> set &lt;span style="color:#f92672">=&lt;/span> Set.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2, 3);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mapの場合は、KeyとValueを順番に並ぶことでインスタンスを作成できますが、エントリーを定義することもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// KeyとValueのセットで定義する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> Map.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// エントリーを定義する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> Map.&lt;span style="color:#a6e22e">ofEntries&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map.&lt;span style="color:#a6e22e">entry&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map.&lt;span style="color:#a6e22e">entry&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map.&lt;span style="color:#a6e22e">entry&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのファクトリーメソッドで作成したCollectionの特徴は、最初からUnmodifiableなオブジェクトになるということです。なので、例えばアプリケーションの起動時にフィールドに定数をCollectionとして定義する、という場合に使えます。つまり、以下のような既存のコードを代替できるようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// もっとも基本的な方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> set &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashSet&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set &lt;span style="color:#f92672">=&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableSet&lt;/span>(set);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Double-brace initialization &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> set &lt;span style="color:#f92672">=&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableSet&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> HashSet&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add(&lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add(&lt;span style="color:#e6db74">&amp;#34;bar&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add(&lt;span style="color:#e6db74">&amp;#34;baz&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、このファクトリーメソッドで作ったCollectionは以下のような特徴を持ちますので、必要に応じて使うのが大事ですね。&lt;/p>
&lt;ul>
&lt;li>Immutable(Unmodifiable)になる&lt;/li>
&lt;li>Null要素を指定できない&lt;/li>
&lt;li>要素がSerializableだとCollectionもSerializableになる&lt;/li>
&lt;/ul>
&lt;h4 id="copyof-10">copyOf (10)
&lt;/h4>&lt;p>List, Set, Mapに&lt;code>copyOf()&lt;/code>というメソッドが追加されています。引数にそれぞれのCollectionを渡すと、Unmodifiableなコピーすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コピー元のリスト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> original &lt;span style="color:#f92672">=&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コピーする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> copy &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">copyOf&lt;/span>(original);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="optional">Optional
&lt;/h2>&lt;p>Optionalは積極的に使われていますか？私の場合は、Streamが返すもの以外で、自分でOptionalを使う場合はあまりないです。色々制約が多いので、複雑なNullチェックが必要な場合ではないと使いづらい気もしますね。ただ、9と10で追加されたメソッドでかなり便利に使えるものとなったので、たまには良いのかもしれません。&lt;/p>
&lt;h3 id="or-9">or (9)
&lt;/h3>&lt;p>Optionalの中身がNullの場合に実行されるメソッドです。既存の&lt;code>orElse()&lt;/code>や&lt;code>orElseGet()&lt;/code>と何が違うかというと、こちらはOptionalの中身ではなく、またのOptionalを返すということです。引数としてはSupplierをとります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> optional &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(optional.&lt;span style="color:#a6e22e">or&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>)).&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// &amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="orelsethrow-10">orElseThrow (10)
&lt;/h3>&lt;p>Optionalの中身がNullの場合は例外を投げる分岐です。NullのOptionalはもともと&lt;code>NoSuchElementException&lt;/code>を投げますが、ビジネスロジックなどによりカスタマイズした例外を投げたい場合などはこちらを使えますね。引数としてはSupplierをとります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> optional &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String throwing &lt;span style="color:#f92672">=&lt;/span> optional.&lt;span style="color:#a6e22e">orElseThrow&lt;/span>(RuntimeException::&lt;span style="color:#66d9ef">new&lt;/span>); &lt;span style="color:#75715e">// RuntimeException&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ifpresentorelse-9">ifPresentOrElse (9)
&lt;/h3>&lt;p>Optionalの中身がNullかどうかによって二つのアクションを指定して、分岐処理ができるようなメソッドです。第一引数としてはConsumerを指定することで中身がNullではない場合の処理を、第二引数としてはRunnableとして中身がNullだった場合の処理を書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> hasValue &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;proper value&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hasValue.&lt;span style="color:#a6e22e">ifPresentOrElse&lt;/span>(v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;the value is &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> v), () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;there is no value&amp;#34;&lt;/span>)); &lt;span style="color:#75715e">// the value is proper value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> hasNoValue &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">empty&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hasNoValue.&lt;span style="color:#a6e22e">ifPresentOrElse&lt;/span>(v &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;the value is &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> v), () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;there is no value&amp;#34;&lt;/span>)); &lt;span style="color:#75715e">// there is no value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="stream-9">stream (9)
&lt;/h3>&lt;p>Optionalを要素が一つか、Null(&lt;code>Stream.empty()&lt;/code>)のSteamに変えるメソッドです。もともとStreamから要素を取得するときもOptionalになっていたので、このようなメソッドが追加されたのも当たり前といえば当たり前ですね。要素が多くて一つなのにStreamに変える意味があるかというと、他のStreamと結合ができたりもするので色々と活用できる余地はありそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> optional &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;value&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> stream &lt;span style="color:#f92672">=&lt;/span> optional.&lt;span style="color:#a6e22e">stream&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="string">String
&lt;/h2>&lt;p>String APIの場合は、主にJava 11でかなりの変化がありました。Webアプリケーションのみならず、最近のアプリケーションは文字列を扱う場合が多いので、このような変化はありがたいですね。&lt;/p>
&lt;h3 id="repeat-11">repeat (11)
&lt;/h3>&lt;p>指定した数値分、文字列を繰り返します。同じ文字列の単純な繰り返しだとすると、StringBuilderやStrinbBufferなしでも簡単に使えるこちらのメソッドの方が良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String a10 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">repeat&lt;/span>(10); &lt;span style="color:#75715e">// &amp;#34;AAAAAAAAAA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="strip-11">strip (11)
&lt;/h3>&lt;p>文字列の前後の空白を除外するために、今までは&lt;code>trim()&lt;/code>を使うケースが多かったのではと思いますが、Java 11からは&lt;code>strip()&lt;/code>が追加され、&lt;code>trim()&lt;/code>を代替できます。この二つが何が違うかというと、まずそれぞれのメソッドで定義している「空白」が違います。&lt;code>trim()&lt;/code>はUnicodeを考慮してなかったため、半角スペースのみの対応となっていましたが、&lt;code>strip()&lt;/code>はUnicodeで指定されたWhitespace全部を対象とするので、全角スペースや改行にも対応できます。どの文字がWhitespaceとして扱われるかは、&lt;code>Character.isWhitespace()&lt;/code>のメソッドが基準となるので、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Character.html#isWhitespace%28char%29" target="_blank" rel="noopener"
>そちらのJavaDoc&lt;/a>を参照してください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String stripped &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n hello world \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">strip&lt;/span>(); &lt;span style="color:#75715e">// &amp;#34;hello world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>strip()&lt;/code>では前後の空白が全部削除されるのですが、文字列の前後を基準にして片方だけ削除したい場合は、前からだけを削除する&lt;code>stripLeading()&lt;/code>や後ろからだけを削除する&lt;code>stripTrailing()&lt;/code>も使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String stripLeading &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n hello world \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">stripLeading&lt;/span>(); &lt;span style="color:#75715e">// &amp;#34;hello world  &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String stripTrailing &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n hello world \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">stripTrailing&lt;/span>(); &lt;span style="color:#75715e">// &amp;#34;\n hello world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今までの説明だけでも十分&lt;code>strip()&lt;/code>を使う理由はあると思いますが、実はもう一つがあります。性能です。性能という面では&lt;code>strip()&lt;/code>の方が&lt;code>trim()&lt;/code>より&lt;a class="link" href="https://stackoverflow.com/questions/53640184/why-is-string-strip-5-times-faster-than-string-trim-for-blank-string-in-java" target="_blank" rel="noopener"
>5倍も早い&lt;/a>と言われているので、なるべく&lt;code>trim()&lt;/code>よりは&lt;code>strip()&lt;/code>を使うべきですね。&lt;/p>
&lt;h3 id="isblank-11">isBlank (11)
&lt;/h3>&lt;p>すでに&lt;code>isEmpty()&lt;/code>というメソッドがありますが、このメソッドと&lt;code>isBlank()&lt;/code>の違いは、&lt;code>trim()&lt;/code>と&lt;code>strip()&lt;/code>の関係と似ています。同じく、&lt;code>isEmpty()&lt;/code>と比べると&lt;code>isBlank()&lt;/code>の方がUnicodeに対応しているのでより多くのケースのWhitespaceに対応できて、性能でも優れています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> isEmpty &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">isEmpty&lt;/span>(); &lt;span style="color:#75715e">// false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> isBlank &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n \u2005&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">isBlank&lt;/span>(); &lt;span style="color:#75715e">// true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="lines-11">lines (11)
&lt;/h3>&lt;p>文字列に改行コード(&lt;code>\n&lt;/code>・&lt;code>\r&lt;/code>・&lt;code>\r\n&lt;/code>)を基準に分けた&lt;code>Stream&amp;lt;String&amp;gt;&lt;/code>を返却します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String multipleLine &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;first\nsecond\nthird&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> lines &lt;span style="color:#f92672">=&lt;/span> multipleLine.&lt;span style="color:#a6e22e">lines&lt;/span>().&lt;span style="color:#a6e22e">filter&lt;/span>(String::isBlank).&lt;span style="color:#a6e22e">count&lt;/span>(); &lt;span style="color:#75715e">// 3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="prediacte-not-11">Prediacte not (11)
&lt;/h2>&lt;p>LambdaやMethod Referenceで定義したPredicateの結果がFalseかどうかを判断するためのメソッドです。単純にtrueの否定になるだけなのですが、このメソッドの引数はPredicateなので、LambdaやMethod Referenceを使ってより単純に表現できるのがメリットといえますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 否定の条件式を使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(m &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>m.&lt;span style="color:#a6e22e">isPrepared&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Predicate.not()を使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(Predicate.&lt;span style="color:#a6e22e">not&lt;/span>(Man::isPrepared))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>2021年に次のLTSであるJava 17がリリースされると、今のJava 11を使う現場の場合は多くがJava 17に移行するのではないかと思います。12から16まで、さまざまなAPIや機能、JVMの改善などが含まれていて、すでに多くのブログなどで紹介されていますが、また既存のAPIにはどのような変化があるかまでは完全に把握していない状態です。なので、Java 17のリリースに合わせて、もう一度12〜17までの新しいメソッドの整理と紹介を行おうと思います。これだけでもかなり勉強になりますし、業務で使えそうなテクニックも増えていく感覚ですね。&lt;/p>
&lt;p>また、今年のポスティングはこれで終了となります。色々と大変な一年だったのですが、なんとか年末を迎えることができましたね。その間、このブログにも多くの方々がいらしてくださいました。まだジュニアレベルでしかない駆け出しエンジニアのブログなのであまり情報取集には役立たないかもしれませんが、少しでも私の書いたポストを読んでくださりありがとうございます。来年からは、より面白く、より良い情報を収取してブログに載せたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>今更なループの話</title><link>https://retheviper.github.io/posts/java-collection-loop/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-collection-loop/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post 今更なループの話" />&lt;p>Javaはもともと手続き型な言語ですが、賢い方法で関数型な言語の特徴を受け止めていて、言語の中に共存させていますね。個人的には関数型プログラミングというものに憧れているので、Javaの中でも好んでStreamやLambdaを使っていて、個人的にもKotlinとSpring WebFluxで色々試しているところです。&lt;/p>
&lt;p>ただ、Java 1.8から続いている話ですが、&lt;code>Streamは果たして全てのForループを代替できるのか？&lt;/code>というものがありますね。そしてここでForループを代替ない理由としてよく挙げられているものが、性能・可読性・デバッグの難しさです。つまり内部的により複雑な処理を行っているため性能もよくないし、例外が発生した時も理由を特定するのが難しい上に、多くの人は&lt;a class="link" href="https://en.wikipedia.org/wiki/Method_chaining" target="_blank" rel="noopener"
>Method Chaining&lt;/a>とLambdaに慣れてない、ということですね。&lt;/p>
&lt;p>以上の理由から、私も普段はやはりList = ArrayListで、ループは拡張For文(たまに、Listの要素をいじって新しいインスタンスを新しく生成する場合はStream)というルールを当たり前のように守ってきていますが、ふとこれで本当に良いのか、いう疑問が湧いてきました。Javaも16までバージョンアップしていて、そろそろ関数型プログラミングに転換しても良い時期なのでは？だったり、自分の知っているものは正しいのかという検証をしてみたいという風にですね。&lt;/p>
&lt;p>なので今更な感じではあるのですが、ちょっとしたベンチマークを兼ねて色々検証してみたり、考えてみました(本当は、ベンチマークがしてみたかっただけ)。&lt;/p>
&lt;h2 id="ループの方法">ループの方法
&lt;/h2>&lt;p>今更な紹介となりますが、そもそも今回のポストが今更な話をしているので、Collectionに関する4つのループ文の細かい話もして行こうかと思います。&lt;/p>
&lt;p>多くの場合、Collectionや配列のループ処理の方法は、以下の表通りに使われているのではないかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>種類&lt;/th>
&lt;th>使う場面&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>For&lt;/td>
&lt;td>インデックスが必要な時&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>拡張For&lt;/td>
&lt;td>他の方法を取る必要がない場合&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Iterator&lt;/td>
&lt;td>基本的に使わない&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>forEach()&lt;/td>
&lt;td>基本的に使わない&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上記のケースが成立する基準は、やっぱり&lt;code>性能&lt;/code>になっているのではないかと思います。他にも可読性だとか、色々考慮する要素はあると思いますが、何よりも性能が基準として優先されているのは否定できない事実かと思います。なぜなら、他の要素はチューニングが難しいか、できないものであり(例えばセキュリティやバグ防止のためのバリデーションチェックは、効率的なコードに書き換えることはできても、そもそも無くすというのは論外になりますね)、全ての要件が満たされたアプリケーションでリファクタリングにより「目に見える形で」改善できるのは性能しかないからでしょう。そもそも、同じ処理をするなら性能が良い方が絶対いいですし。&lt;/p>
&lt;p>なので、私が初めてループ処理に関して学んだ時は伝統的な形のFor文とWhileなのですが、のちにCollectionや配列だと拡張For文を使った方が良いという風に教わりましたが、その時も根拠としてあげられたのが「Forと拡張Forは性能上あまり違わない上に、拡張Forの方が常に要素数分だけループするのが保証されてあるから」ということでした。やはり性能から考えて、それから他のことも考慮するような話ですね。納得のいく話だったので、私自身もそれを信じて今までずっと拡張For文を使ってきました。&lt;/p>
&lt;p>でも、実際はどうか検証してみたことはあまりなかったですね。ネットなどで調べてみても、拡張For文は既存のループの書き方を向上させたものであるとか、Iteratorの&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E7%B3%96%E8%A1%A3%E6%A7%8B%E6%96%87" target="_blank" rel="noopener"
>Syntax Sugar&lt;/a>に過ぎないとかの話もあリました。聞いた話では、もっとも性能が良いのは&lt;/p>
&lt;p>ただ一つ、&lt;code>Stream&lt;/code>と&lt;code>forEach()&lt;/code>はどうでしょう。Javaでこれらが導入されてからもさらに時間が立っています。しかし、上述したとおり、依然として&lt;code>Stream&lt;/code>や&lt;code>forEach()&lt;/code>は&lt;code>性能が劣る&lt;/code>から多く使われてないような気がしています(他にも、&lt;code>あえて使う理由がわからない&lt;/code>・&lt;code>わかりにくい&lt;/code>などの理由があると思いますが)。最初Java 1.8リリース当時にも、多くの人が性能のテストを行い、少なくとも性能面では既存の方式が有利という結論を出していて、今もそれはあまり変わってないようです。Javaのバージョンも16にまで上がったのですが、それまで行われたチューニングを踏まえても&lt;code>Stream&lt;/code>や&lt;code>forEach()&lt;/code>が持つ根本的なアーキテクチャ(?)的な理由から、既存の方式よりも性能が劣るのはしょうがない、という風に認識されています。&lt;/p>
&lt;p>しかし、誰かにそう言われたから、そう思うというのはあまり良い考え方ではないでしょう。また、前述のとおり、Javaはすでに16までバージョンアップを重ねていて、大抵の変化というのは新しい機能の追加となっていますが、裏では何かJVMやコンパイラのチューニングなどでなんらかの目に見えない改善があったのかもしれません。関数型としてのコードの書き方に慣れているかどうかは、その人の問題として、性能面で改善されているとしたら、よりモダンな方法を使わない理由がないですね。そして、本当に拡張For文が全ての場合で良いかどうかの検証もあらかじめしておく必要があると思います。&lt;/p>
&lt;p>以上の理由から、まず検証で使う4つのループの紹介と、そのベンチマークについて紹介したいと思います。&lt;/p>
&lt;h3 id="for文">For文
&lt;/h3>&lt;p>まずは伝統的な形のFor文です。一部では&lt;code>c-style&lt;/code>とも呼ぶらしいですね。一番基本となるもので馴染みもありますが、やはり古い、という印象もあります。端的に、最近のいわゆる&lt;code>モダン&lt;/code>な言語では、このような形のループは使えない場合もありますね。基本的に以下のような形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(list.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>マイクロな最適化として、ループ対象のCollectionや配列の長さをあらかじめ宣言しておく場合もありますね。こうすると、ループ毎にループの対象となるCollectionや配列のサイズを毎回計算する必要がないため、少しは性能が有利になるという話があります。(コンパイラがこれぐらいの最適化は勝手にしてくれるという話もありますが)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この伝統的なFor文の良いところは、インデックスを基準にして処理をするため、インデックスが必要な場合はなんでもできるということです。例えば、以下のような場合があるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 偶数のインデックスのみ処理をしたい&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i &lt;span style="color:#f92672">+=&lt;/span> 2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(list.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 条件と一致する要素のインデックスが知りたい&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (list.&lt;span style="color:#a6e22e">get&lt;/span>(i).&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 前後の要素と比較したい&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i &lt;span style="color:#f92672">+=&lt;/span> 2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;インデックス&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> 1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;の長さ：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i &lt;span style="color:#f92672">-&lt;/span> 1).&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;、インデックス&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;の長さ：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i).&lt;span style="color:#a6e22e">length&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただし、For文で指定されてあるインデックスが必ずループ対象の範囲内にあるかどうか、わからなくなる場合もあります。0から始まるインデックスで&lt;code>i - 1&lt;/code>を指定してしまったり、iの範囲が対象のCollectionや配列よりも大きくなり例外を投げることになることもあるでしょう。また、インデックスを利用した場合、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%B8%E3%83%83%E3%82%AF%E3%83%8A%E3%83%B3%E3%83%90%E3%83%BC_%28%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%29" target="_blank" rel="noopener"
>マジックナンバー&lt;/a>になってしまう可能性もあるので、バグが発生する可能性が上がったり、可読性が悪くなるなどの問題があります。なので、インデックスを基準に処理をしたい場合は慎重にコードを作成する必要がありますね。&lt;/p>
&lt;h3 id="拡張for文">拡張For文
&lt;/h3>&lt;p>いわゆる&lt;code>for-each&lt;/code>文ですね。Colleciton/配列内の全要素を巡回しながら処理するには、これほど理解しやすく、安全なものはないかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最近は、Javaのみでなく他の言語でもこれが標準となっているようです(書き方は言語毎に少し違いますが)。それはつまり、インデックスによるループよりも、ループないで扱うオブジェクトを拡張For文で対象のCollection/配列内の要素に確実に制限した方が色々有利だということでしょう。実際、インデックスといいつつ、伝統的なForb文のものはCollection/配列のインデックスと同じものでもないですので、危険なコードでもありますから。&lt;/p>
&lt;p>伝統的なFor文と比べ、拡張For文の中ではインデックスを利用することができないという問題があります。ただ、全く方法がないわけではないです。どうしてもインデックスを拡張For文の中で使いたい場合は、ループの外に定数を宣言するか、Collectionなら利用できる&lt;code>indexOf()&lt;/code>か、&lt;code>Collections.binarySearch()&lt;/code>を使う方法があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 定数を利用する方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;のインデックス：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// indexOf()を利用する場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;のインデックス：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> list.&lt;span style="color:#a6e22e">indexOf&lt;/span>(element));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collections.binarySearch()を利用する場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;のインデックス：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Collections.&lt;span style="color:#a6e22e">binarySearch&lt;/span>(values, value));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ループの中で&lt;code>indexOf()&lt;/code>を使うのはあまり良い選択じゃないです。以下は&lt;code>ArrayList.indexOf()&lt;/code>の実装になりますが、結局Collectionの中をループしながらインデックスを探すことになるので、実質的に二重ループになっちゃいます。なのでインデックスがどうしても必要な場合は、なるべく定数を使うか、伝統的なFor文を使うべきですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ArrayList.indexOf()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">indexOf&lt;/span>(Object o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> indexOfRange(o, 0, size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">indexOfRange&lt;/span>(Object o, &lt;span style="color:#66d9ef">int&lt;/span> start, &lt;span style="color:#66d9ef">int&lt;/span> end) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object&lt;span style="color:#f92672">[]&lt;/span> es &lt;span style="color:#f92672">=&lt;/span> elementData;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> start; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> end; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (es&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> start; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> end; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (o.&lt;span style="color:#a6e22e">equals&lt;/span>(es&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Collections&lt;/code>の&lt;code>binarySearch()&lt;/code>を利用する場合も、結局ループしながらインデックスを探すというのは変わりませんので注意を。以下はその実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collections.binarySearch()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">binarySearch&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> list, T key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (list &lt;span style="color:#66d9ef">instanceof&lt;/span> RandomAccess &lt;span style="color:#f92672">||&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>()&lt;span style="color:#f92672">&amp;lt;&lt;/span>BINARYSEARCH_THRESHOLD)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">indexedBinarySearch&lt;/span>(list, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">iteratorBinarySearch&lt;/span>(list, key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">indexedBinarySearch&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> list, T key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> low &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> high &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>()&lt;span style="color:#f92672">-&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (low &lt;span style="color:#f92672">&amp;lt;=&lt;/span> high) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> mid &lt;span style="color:#f92672">=&lt;/span> (low &lt;span style="color:#f92672">+&lt;/span> high) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> midVal &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(mid);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cmp &lt;span style="color:#f92672">=&lt;/span> midVal.&lt;span style="color:#a6e22e">compareTo&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cmp &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (cmp &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> high &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mid; &lt;span style="color:#75715e">// key found&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>(low &lt;span style="color:#f92672">+&lt;/span> 1); &lt;span style="color:#75715e">// key not found&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">iteratorBinarySearch&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> list, T key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> low &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> high &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>()&lt;span style="color:#f92672">-&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListIterator&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">listIterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (low &lt;span style="color:#f92672">&amp;lt;=&lt;/span> high) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> mid &lt;span style="color:#f92672">=&lt;/span> (low &lt;span style="color:#f92672">+&lt;/span> high) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Comparable&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> midVal &lt;span style="color:#f92672">=&lt;/span> get(i, mid);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cmp &lt;span style="color:#f92672">=&lt;/span> midVal.&lt;span style="color:#a6e22e">compareTo&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cmp &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (cmp &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> high &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mid; &lt;span style="color:#75715e">// key found&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>(low &lt;span style="color:#f92672">+&lt;/span> 1); &lt;span style="color:#75715e">// key not found&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="iterator">Iterator
&lt;/h3>&lt;p>Iteratorは、個人的にあまり馴染まない(使いたくない)ものです。どのCollectionでもIteratorとして抽出ができてしまうので、CollectionよりもIteratorが主体になってしまうような感覚であり、定型文な書き方を矯正しているからです。少なくとも拡張ForではどんなCollectionのどんな要素を抽出して使っているのか明確ですが、Iteratorだとそれがわからないですね。&lt;/p>
&lt;p>とにかく、そんなIteratorですが、ForでもWhileでもループをかけるという特徴があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Forを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Iterator iterator &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">iterator&lt;/span>(); iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Whileを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Iterator iterator &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Iteratrorを使う場合の問題は、使い方がいまいち直感的ではないということです。例えば以下のような例をみましょう。&lt;code>getFoo()&lt;/code>と&lt;code>getBar()&lt;/code>は、同じオブジェクトから呼ばれているように勘違いしやすいのではないでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Iterator iterator &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">iterator&lt;/span>(); iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>().&lt;span style="color:#a6e22e">getFoo&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>().&lt;span style="color:#a6e22e">getBar&lt;/span>()); &lt;span style="color:#75715e">// 注意！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>面白いことに、拡張For文のバイトコードは、Iteratorを使うコードになるということです。なので少なくとも拡張For文は、Iteratorよりは発展した形と言えるのかもしれません。&lt;/p>
&lt;h3 id="foreach">forEach()
&lt;/h3>&lt;p>モダンな書き方としてのforEach()ですね。拡張For文とあまり違わないのですが、Lambdaやメソッド参照が使えるというメリットがありますね。また、Kotlinのスコープ関数のように、処理の範囲がはっきりするという意味で良いのかもしれません。何よりコードが短くなるのが好きですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>list.&lt;span style="color:#a6e22e">forEach&lt;/span>(System.&lt;span style="color:#a6e22e">out&lt;/span>::println)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実装としても、拡張For文の中でLambdaを実行するという単純な構造になっています。なので単純に考えて、拡張For文よりは性能が劣る可能性がありますね。以下はIterableの実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// IterableのforEach()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">forEach&lt;/span>(Consumer&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> action) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(action);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (T t : &lt;span style="color:#66d9ef">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action.&lt;span style="color:#a6e22e">accept&lt;/span>(t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ArrayListの場合は実装が大きく違います。なので性能も大きく変わる可能性がありますね。以下はその実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ArrayListのforEach()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">forEach&lt;/span>(Consumer&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">super&lt;/span> E&lt;span style="color:#f92672">&amp;gt;&lt;/span> action) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Objects.&lt;span style="color:#a6e22e">requireNonNull&lt;/span>(action);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> expectedModCount &lt;span style="color:#f92672">=&lt;/span> modCount;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> es &lt;span style="color:#f92672">=&lt;/span> elementData;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; modCount &lt;span style="color:#f92672">==&lt;/span> expectedModCount &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> size; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action.&lt;span style="color:#a6e22e">accept&lt;/span>(elementAt(es, i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (modCount &lt;span style="color:#f92672">!=&lt;/span> expectedModCount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentModificationException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> E &lt;span style="color:#a6e22e">elementAt&lt;/span>(Object&lt;span style="color:#f92672">[]&lt;/span> es, &lt;span style="color:#66d9ef">int&lt;/span> index) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (E) es&lt;span style="color:#f92672">[&lt;/span>index&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ベンチマークで検証してみると">ベンチマークで検証してみると
&lt;/h2>&lt;p>この度も、JMHを使って簡単なベンチマークを作ってみました。実はstatic finalなフィールドとして宣言しておくとそのオブジェクトを全てのベンチマークで使い回してくれるのかな、と思っていましたが、どうやらそうではなかったみたいです。なので今回は、ちゃんと@Setupアノテーションを使ってフィールドの初期化をしてみました。実際のコードは以下のとおりです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@State&lt;/span>(Scope.&lt;span style="color:#a6e22e">Thread&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LoopTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> values;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> DecimalFormat format &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;0000000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 9999999).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(format::format).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">indexLoop&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">size&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> length; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(values.&lt;span style="color:#a6e22e">get&lt;/span>(i));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">iteratorLoopFor&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Iterator iterator &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">iterator&lt;/span>(); iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>(); ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">iteratorLoopWhile&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Iterator iterator &lt;span style="color:#f92672">=&lt;/span> values.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (iterator.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(iterator.&lt;span style="color:#a6e22e">next&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">extendedLoop&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : values) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">forEachLoop&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values.&lt;span style="color:#a6e22e">forEach&lt;/span>(bh::consume);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてベンチマークの結果は、以下のとおりです。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
LoopTest.indexLoop thrpt 25 27.737 ± 0.475 ops/s
LoopTest.iteratorLoopFor thrpt 25 26.968 ± 0.556 ops/s
LoopTest.iteratorLoopWhile thrpt 25 27.250 ± 0.557 ops/s
LoopTest.extendedLoop thrpt 25 13.186 ± 0.152 ops/s
LoopTest.forEachLoop thrpt 25 12.479 ± 0.104 ops/s
&lt;/code>&lt;/pre>&lt;p>やはり、4つのループがそれぞれ違う結果を見せているのがわかります。少なくとも、ここでは伝統的なFor文を使った方がもっとも性能の面では有利のように見えますね。なるべく拡張For文を使った方が良い、という根拠として&lt;code>性能はあまり変わらないから&lt;/code>というのはなんだったんだろう、と思うくらいの差があります。&lt;/p>
&lt;p>しかし、本当にこれで、&lt;code>性能が良い方を選べば良い&lt;/code>という結論を出して良いのでしょうか？&lt;/p>
&lt;h2 id="考えたいこと">考えたいこと
&lt;/h2>&lt;p>処理としての結果が同じだとしたら、やはり性能の良い方を選びたくなるのは当然です。企業レベルの話だと、性能は費用と直結する問題でもありますしね。しかし、複雑化している現代のアプリケーションで考えるべきは、性能のみではありません。極端的な話だと、性能のためにをC、C++でWebアプリケーションを作るとしたら、他の言語に比べて生産性が下がってしまうでしょう。そして可読性や維持保守を考えず、性能を優先したコードだけを書いていくと、いわゆる&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%91%E3%82%B2%E3%83%86%E3%82%A3%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0" target="_blank" rel="noopener"
>スパゲティコード&lt;/a>になってしまう可能性もあります。&lt;/p>
&lt;p>なので、性能のみではなく、アプリケーションを開発するときには色々と考慮すべき要素があるのは確かです。例えば、Readability(可読性)、Error-proneness(エラー発生可能性)、Capability(処理能力)などがあるでしょう。今までは性能ばかりの話をしてきましたが、これらの観点から4つのループを比較してみたらどうでしょう。&lt;/p>
&lt;h3 id="可読性とエラー発生可能性の側面から考える">可読性とエラー発生可能性の側面から考える
&lt;/h3>&lt;p>拡張For文(forEach())では、Collectionそのものの要素をことができます。逆に、For文やIteratorでは可能ですね。ならば、Collectionや配列の中でとある条件と一致する要素だけのことしたい場合は、拡張For文よりもFor文やIteratorを使うべきであるようにも見えます。&lt;/p>
&lt;p>しかし、観点を変えてみると、元のオブジェクトそのものが変わることで起こり得るサイドエフェクトが発生する場合も考えられます。こういう場合、元のオブジェクトを直接操作できるということはメリットではなくデメリットになってしまいますね。なので、どちらかというと、与えられたCollection/配列から条件に一致する要素だけを抽出して新しいCollection/配列のインスタンスを生成するのが正解の可能性もあります。そしてそれをよりわかりやすいコードとして実現できるのは拡張For文(forEach())ですね。例えば、以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のリストが変わってしまう&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">filterFor&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (list.&lt;span style="color:#a6e22e">get&lt;/span>(i).&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;gt;&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list.&lt;span style="color:#a6e22e">remove&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のリストには影響がない - For文&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterFor&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list.&lt;span style="color:#a6e22e">size&lt;/span>(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String element &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (element.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(element);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のリストには影響がない - 拡張For文&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterForEach&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String element : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (element.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(element);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のリストには影響がない - Stream.forEach()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterStream&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">filter&lt;/span>(element &lt;span style="color:#f92672">-&amp;gt;&lt;/span> element.&lt;span style="color:#a6e22e">length&lt;/span>() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 10).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>良いコードは、短く、わかりやすいコードなのではないかと思っています。そしてわかり安いコードは、誰がメンテしてもバグを起こす可能性は低くなるはずでしょう。そういう観点からすると、伝統的なFor文とIteratorは、今は使うべきではないのかもしれません。&lt;/p>
&lt;h3 id="処理能力の側面から考える">処理能力の側面から考える
&lt;/h3>&lt;p>処理能力、というのはある程度性能ともつながるものですね。なので、性能という側面でもう一度考えてみます。互換性、汎用性などとも言える物かもしれません。ここで言いたいのは、Collection/配列がどんなものであれ、一定の性能を保証する実装を考える必要があるということです。&lt;/p>
&lt;p>引数として&lt;code>List&lt;/code>をとり、なんらかの処理をループで行うメソッドを実装するとしましょう。今まであげてきた、4つのループのパターンのうちどれを選ぶべきかは、その引数の実装クラスが何になるかわからない、という面も考慮する必要があります。なぜなら、Listは色々な実装クラスを持つインタフェースだからです。&lt;/p>
&lt;p>引数としてListをまず宣言しておくと、言語の仕様としてはListの実装クラスはどれでも許容することになりますね。なので引数として入ってくるのは&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ArrayList.html" target="_blank" rel="noopener"
>ArrayList&lt;/a>になる可能性もあり、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/LinkedList.html" target="_blank" rel="noopener"
>LinkedList&lt;/a>にな可能性もあり、極端的には&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/AbstractList.html" target="_blank" rel="noopener"
>AbstractList&lt;/a>で個人がカスタマイズしたものが来る場合もあると予想できます。他にもJava 11を基準に、java.util.Listを継承しているCollectionの実装クラスの場合、例えば&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/AbstractSequentialList.html" target="_blank" rel="noopener"
>AbstractSequentialList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/AttributeList.html" target="_blank" rel="noopener"
>AttributeList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CopyOnWriteArrayList.html" target="_blank" rel="noopener"
>CopyOnWriteArrayList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/relation/RoleList.html" target="_blank" rel="noopener"
>RoleList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/relation/RoleUnresolvedList.html" target="_blank" rel="noopener"
>RoleUnresolvedList&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Stack.html" target="_blank" rel="noopener"
>Stack&lt;/a>、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Vector.html" target="_blank" rel="noopener"
>Vector&lt;/a>などがあって、これらが全部Listになりえるので、どの実装でも対応する必要があります。&lt;/p>
&lt;p>もちろん、Javaでとあるインタフェースを継承するということは、処理の前提条件と結果結果が明確であることと同じ意味なので、実装クラスが変わったって、処理の結果が大きく変わることはないです。ただ、Listの実装クラスが複数存在するのは、それらを使う目的によってどちらかに偏ったパフォーマンスを見せるためであることをまず理解する必要がありますね。これはつまり、同じ条件下でも実装クラスによって処理の性能が大きく変わる可能性があるということです。一般的に多く使われているListの実装クラスはArrayListですが、参照以外の性能が劣るという理由からLinkedListが使われる場面もあると予想できます。だとすると、ArrayListで性能がよかったものがLinkedListでもそうとは限らないものですね。&lt;/p>
&lt;p>上記で実施したベンチマークだけをみて、性能は絶対これが有利だ、と言いきれない理由がここにあります。なぜなら、テストようのデータを&lt;code>Collectors.toList()&lt;/code>を使ってListとして作成していますが、以下のコードでわかるように、常にArrayListが生成されているからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> Collector&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, &lt;span style="color:#f92672">?&lt;/span>, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">toList&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CollectorImpl&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>((Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>) ArrayList::&lt;span style="color:#66d9ef">new&lt;/span>, List::add,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (left, right) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> { left.&lt;span style="color:#a6e22e">addAll&lt;/span>(right); &lt;span style="color:#66d9ef">return&lt;/span> left; },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CH_ID);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、ついでに他の実装クラスのベンチマークもしてみることにしました。ただ、Listの実装クラスを全部テストするのは無理があるので(特に、AbstractListやAbstractSequentialListは別途実装が必要ですし、CopyOnWriteArrayListはマルチスレッドでないと意味がないし、RoleListやVectorはほとんど使われてなく、Stackをループで利用するとは思わないので)、LinkedListの場合はどうかだけ確認してみました。まあ、ArrayListと違う反例は一つだけあったら十分ですしね。&lt;/p>
&lt;p>幸い、Collectorsには&lt;code>toCollection()&lt;/code>でCollectionの実装を指定できます。なので、上記のベンチマークのコードから、以下のような修正を入れるだけでListの実装を変えることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// LinkedListの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>values &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 9999999).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(format::format).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toCollection&lt;/span>(LinkedList::&lt;span style="color:#66d9ef">new&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>LinkedListの場合、要素数が増えると急激に性能が低下する傾向があります。なので、ArrayListの時よりも要素数は2桁ほど減らしてベンチマークを実施しました。結果は以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Benchmark Mode Cnt Score Error Units
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.indexLoop thrpt &lt;span style="color:#ae81ff">25&lt;/span> 0.084 ± 0.005 ops/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.iteratorLoopFor thrpt &lt;span style="color:#ae81ff">25&lt;/span> 854.459 ± 36.771 ops/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.iteratorLoopWhile thrpt &lt;span style="color:#ae81ff">25&lt;/span> 839.233 ± 18.142 ops/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.extendedLoop thrpt &lt;span style="color:#ae81ff">25&lt;/span> 659.999 ± 47.702 ops/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LoopTest.forEachLoop thrpt &lt;span style="color:#ae81ff">25&lt;/span> 780.463 ± 78.591 ops/s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ArrayListとは真逆の結果になったのがわかります。特に、インデックスによるループは使えるものにならないほど性能が低く、拡張For文よりも&lt;code>forEach()&lt;/code>の性能が高いという、意外の結果となっています。このベンチマークでの数値が絶対的なものとは言えませんが、結果から推論できるのは、やはりArrayListのインデックスを利用する伝統的なFor文でのループが一番早かったからという理由だけで、全てのListをFor文で処理するというのは危ないということです。なので「どの実装クラスでも、平均的に良い性能を出してくれる」方式を選ぶ必要があるという結論を出せるでしょう。(それがおそらく拡張For文な気がします)&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>全ての場面で最適なコードを書くのは難しいことで、過去に書いたコードはいずれ改善しなければならないものとなりますね。あまりエンジニアとしての歴の長くない自分でも、たまに入社前のコードをみるとびっくりするくらいです。なんとか動くようなものは作ったものの、重複するコードや無駄なインスタンス作りなど、至る所に自分のミスが散らかっています。&lt;/p>
&lt;p>なのでたまには、そのような過去の自分が書いたコードと向かい合って、それを直してみるのも良い経験になるのではないかと思ったりもします。特に今回みたいに、ループ処理は基本の中の基本ですが、その処理すらどれを選ぶかよくわかってないまま(そして副作用などは考えず)、ただひたすら書いてしまったものも多かったので、それに対する反省を兼ねて、そして自分の思うことの根拠を探すための勉強にもなりますので。そしてベンチマーク、意外と楽しいですので。これで自分の理論を証明していくのも良い経験ですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>パターンと一致する文字列かを判定する</title><link>https://retheviper.github.io/posts/java-string-pattern-validator/</link><pubDate>Sun, 22 Nov 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-string-pattern-validator/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post パターンと一致する文字列かを判定する" />&lt;p>一般的に、アプリケーションには要求される業務的な要件やセキュリティの観点から考慮すべきことがあるので、なんらかの機能を作るときはそれが「動くか」だけでなく、任意のロジックが必要となる場合がありますね。なのでその機能が動くにはとある場合で、動くときはとある条件に合わせて処理をする、といった制限が要求されることがあります。&lt;/p>
&lt;p>今回のポストも、またそのような業務上の要件から生まれた話です。現在、私が関わっている案件では、EC2で起動するSpring Boot基盤のアプリを作っています。このアプリでは、ファイルのデータとアップロード先のパスを指定すると、S3にアップロードするという単純な機能があり、それは自分の担当となっています。&lt;/p>
&lt;p>単純にアップロードパスとデータがあれば、動く機能を作るのは単純です。SpringにはSpring Cloudというフレームワークがあるので、すでに&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/ResourceLoader.html" target="_blank" rel="noopener"
>ResourceLoader&lt;/a>というクラスを持ってファイルアップロードを実現できます。Spring Cloudを使わない場合でも、&lt;a class="link" href="https://aws.amazon.com/jp/sdk-for-java" target="_blank" rel="noopener"
>AWS SDK&lt;/a>を使うと簡単に実装ができます。事実、こちらの昨日もアップロード先のパスとファイルだけあれば良いものとなっているので、実装というまででもないですね。&lt;/p>
&lt;p>ただ、この機能が呼び出されたとき、渡されたアップロード先のパスが「正しいもの」であるかを確認する必要がありました。つまり、業務上ファイルをS3に格納する際に決まったパスのルールがあって、この機能からはパラメータとして渡されたパスが規定のパターンと一致するかどうかを一度チェックする必要がありました。&lt;/p>
&lt;p>渡されたパスが「正しいもの」かどうかをチェックするための機能は、何で作ったら良いでしょうか。そしてどう作った方が良いでしょうか。色々な方法があるかと思いますが、まずここでは自分がどう実装したかを紹介していきたいと思います。&lt;/p>
&lt;h2 id="文字列のパターンは正規表現で">文字列のパターンは正規表現で
&lt;/h2>&lt;p>まず、ファイルのアップロード先(保存先)パスは文字列であり、特定のパターンである必要があります。文字列が特定のパターンで構成されているかどうかの判定は、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE" target="_blank" rel="noopener"
>正規表現&lt;/a>を使いますね。なので、「正しいもの」としてのパスのパターンは、正規表現としてあらかじめ宣言しておいて、渡されたパラメータがそれと一致するかをチェックすることとします。ただ、Javaでは正規表現を使って文字列のパターンを判定する方法がいくつかありますので、それらのうちにどれを選ぶべきかを考える必要があります。例えば、以下の方法がありますね。&lt;/p>
&lt;ol>
&lt;li>&lt;code>Pattern.matches()&lt;/code>を使う&lt;/li>
&lt;li>&lt;code>Pattern&lt;/code>から&lt;code>Matcher&lt;/code>を取得し使う&lt;/li>
&lt;li>&lt;code>Pattern&lt;/code>から&lt;code>Predicate&lt;/code>を取得し使う&lt;/li>
&lt;li>&lt;code>String.matches()&lt;/code>を使う&lt;/li>
&lt;/ol>
&lt;p>そして、これらの方法は、以下のコード通りに使うことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 正規表現の例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String patternRegex &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;^[0-9]*$&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 正規表現で判定したい文字列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;123456789&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Pattern.matches()を使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> patternMatches &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">matches&lt;/span>(patternRegex, value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Matcherを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pattern pattern &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(patternRegex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Matcher matcher &lt;span style="color:#f92672">=&lt;/span> pattern.&lt;span style="color:#a6e22e">matcher&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> matcherFind &lt;span style="color:#f92672">=&lt;/span> matcher.&lt;span style="color:#a6e22e">find&lt;/span>(); &lt;span style="color:#75715e">// 部分一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> matcherMatches &lt;span style="color:#f92672">=&lt;/span> matcher.&lt;span style="color:#a6e22e">matches&lt;/span>(); &lt;span style="color:#75715e">// 完全一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Predicateを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Pattern pattern &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(patternRegex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> matcherFind &lt;span style="color:#f92672">=&lt;/span> matcher.&lt;span style="color:#a6e22e">asPredicate&lt;/span>().&lt;span style="color:#a6e22e">test&lt;/span>(value); &lt;span style="color:#75715e">// 部分一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> matcherMatches &lt;span style="color:#f92672">=&lt;/span> matcher.&lt;span style="color:#a6e22e">asMatchPredicate&lt;/span>().&lt;span style="color:#a6e22e">test&lt;/span>(value); &lt;span style="color:#75715e">// 完全一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String.matches()を使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> stringMatches &lt;span style="color:#f92672">=&lt;/span> value.&lt;span style="color:#a6e22e">matches&lt;/span>(patternRegex);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>Matcher&lt;/code>や&lt;code>Predicate&lt;/code>を使う場合、部分一致を選べられるので、部分一致の場合はこれらを使うしかなさそうです。しかし、完全一致が必要な場合は何を基準に、どれを選ぶべきでしょうか。どれも同じような結果を出すのであれば、より効率的な方法を選びたくなります。そして、この場合、考えられるのは性能です。つまり、どれを使った時にもっとも早く判定の結果を得られるかということです。&lt;/p>
&lt;h2 id="どれも同じなら性能で">どれも同じなら性能で
&lt;/h2>&lt;p>前述の通り、文字列が与えられた正規表現のパターンと一致するかどうかを判断する様々な方法があるので、中でももっとも早いのはどれか、測定したいと思います。いわゆるストップウォッチ方式(処理終了時点の時間から、処理開始時点の時間を引く)が簡単ですが、より正確な比較がしたかったためOpenjdkから提供する&lt;a class="link" href="https://openjdk.java.net/projects/code-tools/jmh" target="_blank" rel="noopener"
>JMH&lt;/a>を使ってベンチマークを作りました。Java特有の起動が遅い問題で測定に影響が出るのを防ぐためか、何回かのウォーミングアップも含めて測定をしてくれるので、良いですね。&lt;/p>
&lt;p>実際にベンチマークを行うため使ったコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RegexTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String PATTERN_REGEX &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;^[0-9]*$&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> DecimalFormat DECIMAL_FORMAT &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;0000000&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Pattern PATTERN &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(PATTERN_REGEX);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Predicate PREDICATE &lt;span style="color:#f92672">=&lt;/span> PATTERN.&lt;span style="color:#a6e22e">asPredicate&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Predicate MATCH_PREDICATE &lt;span style="color:#f92672">=&lt;/span> PATTERN.&lt;span style="color:#a6e22e">asMatchPredicate&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> VALUES &lt;span style="color:#f92672">=&lt;/span> IntStream.&lt;span style="color:#a6e22e">rangeClosed&lt;/span>(0, 9999999).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(DECIMAL_FORMAT::format).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">patternMatches&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(Pattern.&lt;span style="color:#a6e22e">matches&lt;/span>(PATTERN_REGEX, value));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">matcherFind&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(PATTERN.&lt;span style="color:#a6e22e">matcher&lt;/span>(value).&lt;span style="color:#a6e22e">find&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">matcherMatches&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(PATTERN.&lt;span style="color:#a6e22e">matcher&lt;/span>(value).&lt;span style="color:#a6e22e">matches&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">predicate&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(PREDICATE.&lt;span style="color:#a6e22e">test&lt;/span>(value));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">matchPredicate&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(MATCH_PREDICATE.&lt;span style="color:#a6e22e">test&lt;/span>(value));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Benchmark&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">stringMatches&lt;/span>(Blackhole bh) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String value : VALUES) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bh.&lt;span style="color:#a6e22e">consume&lt;/span>(value.&lt;span style="color:#a6e22e">matches&lt;/span>(PATTERN_REGEX));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして、測定の結果は以下の通りです。実際の出力はメソッド名の順番が違いますが、コードでの並び順に合わせて変えています。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-dos" data-lang="dos">Benchmark Mode Cnt Score Error Units
RegexTest.patternMatches thrpt 25 0.591 ± 0.013 ops/s
RegexTest.matcherFind thrpt 25 1.525 ± 0.022 ops/s
RegexTest.matcherMatches thrpt 25 1.481 ± 0.030 ops/s
RegexTest.predicate thrpt 25 2.050 ± 0.182 ops/s
RegexTest.matchPredicate thrpt 25 1.733 ± 0.236 ops/s
RegexTest.stringMatches thrpt 25 0.609 ± 0.005 ops/s
&lt;/code>&lt;/pre>&lt;p>この結果からして、性能面では確かに&lt;code>Matcher&lt;/code>か&lt;code>Predicate&lt;/code>を使った方が良いと言えるでしょう。ただ、ベンチマークの結果としては&lt;code>Predicate&lt;/code>が誤差を含めても性能がもっとも良いこととなっていますが、&lt;code>Pattern.asPredicate()&lt;/code>はJava 1.8、&lt;code>Pattern.asMatchPredicate()&lt;/code>はJava 11から導入されたので、JDKのバージョンに合わせて適切な方を選ぶ必要があります。&lt;/p>
&lt;p>ただ、結果だけでなく理由も知りたくなります。性能がよかった&lt;code>Matcher&lt;/code>と&lt;code>Predicate&lt;/code>の場合、テストではあらかじめインスタンスを作成しておいたという共通点があります。なので、性能の低い&lt;code>Pattern.matches()&lt;/code>と&lt;code>String.matches()&lt;/code>の場合、メソッドが呼び出されるたびにインスタンスを作成しているため遅くなっているのではないか、という推測もできますね。実際はどうか、コードをみていきましょう。&lt;/p>
&lt;p>まず&lt;code>Pattern.matches()&lt;/code>ですが、実際のコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Pattern.matches&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>(String regex, CharSequence input) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pattern p &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(regex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Matcher m &lt;span style="color:#f92672">=&lt;/span> p.&lt;span style="color:#a6e22e">matcher&lt;/span>(input);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> m.&lt;span style="color:#a6e22e">matches&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをみると、&lt;code>Pattern&lt;/code>と&lt;code>Matcher&lt;/code>のインスタンスがメソッドを呼び出すたびに生成されるということがわかります(実際、&lt;code>Pattern.compile()&lt;/code>と&lt;code>Pattern.matcher()&lt;/code>のコードを追ってみるとインスタンスを作成するのがわかります)。なのでこちらが遅くなるのは当然のことですね。&lt;/p>
&lt;p>それでは、&lt;code>String.matches()&lt;/code>の場合はどうか、同じくコードから確認しましょう。実際のコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// String.matches&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">matches&lt;/span>(String regex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Pattern.&lt;span style="color:#a6e22e">matches&lt;/span>(regex, &lt;span style="color:#66d9ef">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これもまた、単に&lt;code>Pattern.matches()&lt;/code>を呼び出しているだけなので、遅いわけですね。ただ一つ違う点は、比較対象となる自分自身のインスタンスが必要なため、&lt;code>Pattern&lt;/code>とは違ってstaticメソッドではないというところといえますが、これは性能に影響する部分ではないので、ベンチマークでも誤差範囲の中の結果となったと思います。&lt;/p>
&lt;h2 id="実際のvalidatorを作る">実際のValidatorを作る
&lt;/h2>&lt;p>では、性能で&lt;code>Matcher&lt;/code>と&lt;code>Predicate&lt;/code>が有利であるということがわかったので、あとはこれを利用して、渡されたパスが許容できるものかどうかを判定するValidatorを作ります。今の案件ではJava 11を使うので、&lt;code>Predicate&lt;/code>を選びました。&lt;/p>
&lt;p>パスのパターンは複数あるので、配列やリストとしてパターンを指定して起きます。また、&lt;code>Predicate&lt;/code>で判定するので、あらかじめ指定したパターンでインスタンスを作成しておいて、判定が必要なときはパターンの配列やリストをループさせて、一致するものがあるかどうかを返すと良いでしょう。この要件から、実際のコードは以下のようになりました(パスの正規表現は、実際の業務とは違うものとなっていますが)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@NoArgsConstructor&lt;/span>(access &lt;span style="color:#f92672">=&lt;/span> AccessLevel.&lt;span style="color:#a6e22e">PRIVATE&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StorageValidator&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 許容されたパスのパターン
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> PATH_PATTERN_MATCHERS &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createMatcher(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;\\/contents\\/images\\/\\d{0,4}\\/(19[0-9]{2}|20[0-9]{2})(0[0-9]|1[0-2])\\/thumbnail\\.(?:bmp|jpg|jpeg|gif|png|BMP|JPG|JPEG|GIF|PNG)$&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> createMatcher(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;\\/contents\\/images\\/\\d{0,4}\\/(19[0-9]{2}|20[0-9]{2})(0[0-9]|1[0-2])\\/thumbnail_backup\\.(?:bmp|jpg|jpeg|gif|png|BMP|JPG|JPEG|GIF|PNG)$&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 与えられた文字列が、SPLで利用できる有効なファイルアップロードパスであるかどうかを判定する.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param path 判定対象の文字列(ファイルパス)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @return 判定結果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isValidUploadPath&lt;/span>(String path) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> PATH_PATTERN_MATCHERS.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">anyMatch&lt;/span>(predicate &lt;span style="color:#f92672">-&amp;gt;&lt;/span> predicate.&lt;span style="color:#a6e22e">test&lt;/span>(path));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 与えられた正規表現から、{@link Predicate}型のパターンマッチャーオブジェクトを返す.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param pattern 正規表現
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @return 生成されたパターンマッチャーオブジェクト
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">createMatcher&lt;/span>(String pattern) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(pattern).&lt;span style="color:#a6e22e">asMatchPredicate&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上で、渡されたパスが想定のパターンと一致するものかどうか判定することができるようになりました。簡単ですね。&lt;/p>
&lt;h3 id="番外kotlinで書いてみたら">番外：Kotlinで書いてみたら？
&lt;/h3>&lt;p>今回のポストの内容とはあまり関係のないものですが、ちょっとした興味本位から、Javaで作成したValidatorをKotlinのコードに変えてみました。幸い、intellijには、Javaで書かれたコードをKotlinに変えてくれる便利な機能がありますので簡単にできます。そもそもKotlinを作ったのがJetbrain社なので、Kotlinを普及するための機能であるとは思いますが、おかげでJavaプログラマがKotlinに入門するのも簡単になりますね。&lt;/p>
&lt;p>&lt;code>static final&lt;/code>なフィールドをKotlinでは&lt;code>companion object&lt;/code>として扱うことになるらしく、コード自体はそう変わらない感覚です。ただ、Kotlinでは&lt;code>stream()&lt;/code>を呼び出さなくてもCollectionから直接呼び出すことのできるメソッド(&lt;code>any&lt;/code>)があったり、&lt;code>List.of()&lt;/code>も&lt;code>listOf()&lt;/code>で代替できるのですが、自動変換ではそこまでしてくれなかったので、そういうところ自分で変えるしかないです。それで完成したコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StorageValidator&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> PATH_PATTERN_UPLOAD = listOf( &lt;span style="color:#75715e">// 画像の保存先パスのパターン(正規)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Pattern&lt;/span>.compile(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/contents&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/images&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">d{0,4}&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/(19[0-9]{2}|20[0-9]{2})(0[0-9]|1[0-2])&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/thumbnail&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">.(?:bmp|jpg|jpeg|gif|png|BMP|JPG|JPEG|GIF|PNG)$&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .asMatchPredicate(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Pattern&lt;/span>.compile(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/contents&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/images&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">d{0,4}&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/(19[0-9]{2}|20[0-9]{2})(0[0-9]|1[0-2])&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">/thumbnail_backup&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">.(?:bmp|jpg|jpeg|gif|png|BMP|JPG|JPEG|GIF|PNG)$&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .asMatchPredicate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">isValidUploadPath&lt;/span>(path: String): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">PATH_PATTERN_UPLOAD&lt;/span>.any { predicate &lt;span style="color:#f92672">-&amp;gt;&lt;/span> predicate.test(path) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>本当は、正規表現を使って文字列がパターンと一致するかどうかを判定する、という機能を作るのはそう難しいことではないですね。どちらかというと、正規表現そのものの書き方が難しいのでは、と思います。ただ、最近は&lt;a class="link" href="https://regexr.com" target="_blank" rel="noopener"
>RegExr&lt;/a>、&lt;a class="link" href="https://www.regextester.com" target="_blank" rel="noopener"
>RegEx Testing&lt;/a>、&lt;a class="link" href="https://regex101.com" target="_blank" rel="noopener"
>regular expressions 101&lt;/a>など、その場で入力した正規表現をテストしながら作成できるオンラインのツールなども多いので、じっくり時間をかけるといくらでも必要なパターンに合わせたものを作ることができると思います。&lt;/p>
&lt;p>個人的な感想としては、書いたコードは短く簡単でしたが、久々に色々と考えられる(効率の面で)チャンスとなったのでなかなか面白い作業になったと思っています。これからもこのような要件があるとしたら、また違う方法で挑戦してみたくなりますね。では、また！&lt;/p></description></item><item><title>二つのListを結合する</title><link>https://retheviper.github.io/posts/java-compare-and-merge-lists/</link><pubDate>Sun, 26 Jul 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-compare-and-merge-lists/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post 二つのListを結合する" />&lt;p>よく訪問しているサイトに、とある質問がありました。質問の内容とは、&lt;code>List二つを、重複する要素なしで一つにまとめる方法&lt;/code>ということでした。SQLなら簡単に解決できそうな問題でもありますが、クエリーを修正できない状態だったり、複数のAPIを呼び出してその戻り値を扱う場合は直接コードを書いて併合するしかないですね。今まであまり経験したことのない状況でしたが、個人的にも興味が沸いたのでいろいろ試しながらコードを書いてみました。&lt;/p>
&lt;h2 id="問題のコード">問題のコード
&lt;/h2>&lt;p>質問の作成者がやりたいことは、&lt;code>List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;&lt;/code>が二つあり、Listの中のMapの要素を確認し、重複する物があれば一つのListとしてまとめたいということです。ここで重複の条件は、MapのKeyとValueでした。&lt;/p>
&lt;p>今はコードは存在するものの、重複チェックのためのロジックが複雑になりすぎて、負荷も高く性能面でも問題があるらしいです。まず彼の後悔しているコードは、以下のようなものでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> list1 &lt;span style="color:#f92672">=&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> list2 &lt;span style="color:#f92672">=&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Object object : list1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String a1 &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Object object2 : list2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String a2 &lt;span style="color:#f92672">=&lt;/span> map2.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (a1.&lt;span style="color:#a6e22e">equals&lt;/span>(a2)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> keys &lt;span style="color:#f92672">=&lt;/span> map2.&lt;span style="color:#a6e22e">keySet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String key : keys) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String v &lt;span style="color:#f92672">=&lt;/span> map2.&lt;span style="color:#a6e22e">get&lt;/span>(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.&lt;span style="color:#a6e22e">put&lt;/span>(key, v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードをみると、3重ループになっていて、KeyとValueが一致する項目がないかを一つ一つチェックしています。そして実際のコードなのかよくわかりませんが、このコードだとキーがリテラルになっているので全体のキーを循環できるようなループがまた追加されるべきではないかと思います。そうするとまたループが追加されたりして、より複雑なコードになりそうですね。これをListの個数分回すとしたら、それは負荷が多いだろうなと思います。なのでこれをなるべく短く、より単純なコードにしてみたいと思います。&lt;/p>
&lt;p>Best Practiceではないのかもしれませんが、ひとまず自分の考えてコードを紹介します。&lt;/p>
&lt;h2 id="streamを使ってみる">Streamを使ってみる
&lt;/h2>&lt;p>Listの要素を一つづつ処理したい場合は、まずStreamを使う方法がないかをまず考えてみました。ネットで調べてみるとやはりStreamを使って複数のListをマージする方法がいくつかあります。それらを使って検証してみました。&lt;/p>
&lt;h3 id="結合と重複の除外">結合と重複の除外
&lt;/h3>&lt;p>&lt;code>Stream.concat()&lt;/code>を使うと、二つのStreamをつなげることができます。また、Streamでは&lt;code>distinct()&lt;/code>で重複を除外することができます。これらの組み合わせを使うと、二つのListを重複する要素なしで結合することができます。まず簡単な例題を使うと以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 結合したいList&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list1 &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;d&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;e&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list2 &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;d&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;f&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 結合と重複の除外(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;f&amp;#34;)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> concat &lt;span style="color:#f92672">=&lt;/span> Stream.&lt;span style="color:#a6e22e">concat&lt;/span>(list1.&lt;span style="color:#a6e22e">stream&lt;/span>(), list2.&lt;span style="color:#a6e22e">stream&lt;/span>()).&lt;span style="color:#a6e22e">distinct&lt;/span>().&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Stream.concat()&lt;/code>の引数は二つしか指定できないので、3つ以上のListを繋ぐ場合はループを使うのを考慮すると良いです。また、&lt;code>distinct()&lt;/code>の場合、&lt;code>equals()&lt;/code>がちゃんと定義されてあるという前提ならどんなオブジェクトでも重複検査ができます。なのでLombokの&lt;code>@Data&lt;/code>のようなアノテーションのついたクラスでも重複を除外して一つのListに納めることができます。&lt;/p>
&lt;h3 id="限界">限界
&lt;/h3>&lt;p>質問の作成者は、Listの中のMapの要素に対して重複チェックを行いたいと行っていますが、この方法ではそのようにはなりません。なぜなら、Mapそのものを&lt;code>equals()&lt;/code>で比較してしまい、中の要素一つ一つに対してはチェックしない構造となっているからです。なのでこのようなコードだと、二つのListを繋いだような物ができてしまうだけです。&lt;/p>
&lt;h2 id="forループを使ってみる">Forループを使ってみる
&lt;/h2>&lt;p>今回は質問者のコードを直して、より効率的に変えてみます。あえてForループを使っているのは、条件に一致した場合に一回だけ&lt;code>put()&lt;/code>を実行するためです。&lt;code>Stream&lt;/code>や&lt;code>forEach()&lt;/code>は全ての要素に対して処理を行うためのものなので、除きました。&lt;/p>
&lt;p>Mapには&lt;code>put()&lt;/code>以外でも&lt;code>putAll()&lt;/code>があるので、要素を巡回しながら一つづつ一つでもループは消すことができます。そして&lt;code>putAll()&lt;/code>を実行したら、次の要素までチェックする必要はなくなるので&lt;code>continue&lt;/code>を実行して次のループは飛ばすようにして、無駄な処理を無くします。そうするとまず以下のようにコードを帰ることができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Object object : list1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String a1 &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Object object2 : list2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String a2 &lt;span style="color:#f92672">=&lt;/span> map2.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (a1.&lt;span style="color:#a6e22e">equals&lt;/span>(a2)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ループを一回無くす&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.&lt;span style="color:#a6e22e">putAll&lt;/span>(map2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで、MapのKeyを指定しているところも直します。リテラルで指定しなく、Entryを巡回しながら比較することにするのでループは一つ増えます。そして、Entryは&lt;code>Set&lt;/code>で取得できるので、Collectionのメソッドである&lt;code>contains()&lt;/code>を使って比較することができます。なので比較したいMapのうち、どちらかのEntryを巡回しながら要素が違う方のMapに入っているのかを確認するだけで良いですね。これを反映して直したコードが以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Object object : list1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Object object2 : list2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 &lt;span style="color:#f92672">=&lt;/span> (HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>) object2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Entryで比較する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map.&lt;span style="color:#a6e22e">Entry&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, DataClass&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry : map2.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map1.&lt;span style="color:#a6e22e">entrySet&lt;/span>().&lt;span style="color:#a6e22e">contains&lt;/span>(entry)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map1.&lt;span style="color:#a6e22e">putAll&lt;/span>(map02);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは最初からあらかじめListの型変換をして、ループ毎に型変換をしないようにすることですね。あまりこれで性能の改善は期待できないのかもしれませんが…&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// あらかじめ型変換をしておく&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> convertedList1 &lt;span style="color:#f92672">=&lt;/span> (List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>) list1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> convertedList2 &lt;span style="color:#f92672">=&lt;/span> (List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>) list2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map : convertedList1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 : convertedList2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map.&lt;span style="color:#a6e22e">Entry&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, DataClass&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry : map2.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map1.&lt;span style="color:#a6e22e">entrySet&lt;/span>().&lt;span style="color:#a6e22e">contains&lt;/span>(entry)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map1.&lt;span style="color:#a6e22e">putAll&lt;/span>(map02);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは場合によってMapのKeyをソートするなどの処理が必要になるかもですが、一旦これで要件は満たしたような気がします。&lt;/p>
&lt;h2 id="条件が違う場合">条件が違う場合
&lt;/h2>&lt;p>質問者のコードからは、推論するしかないことですが、もしListのインデックスを基準に比較するという条件があるとしたら、コードはより減らすことができます。list1とlist2の同じインデックスに、同じ要素を持つMapがあるかを確認するということです。もしこの条件があるとしたら、ループは2重に納めることができます。以下はその場合のコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map : list1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map.&lt;span style="color:#a6e22e">Entry&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry : map.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// List2と同じインデックスを比較する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> map2 &lt;span style="color:#f92672">=&lt;/span> list2.&lt;span style="color:#a6e22e">get&lt;/span>(list1.&lt;span style="color:#a6e22e">indexOf&lt;/span>(map));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (map2.&lt;span style="color:#a6e22e">entrySet&lt;/span>().&lt;span style="color:#a6e22e">contains&lt;/span>(entry)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> map.&lt;span style="color:#a6e22e">putAll&lt;/span>(map2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法を使うためには二つのListが同じサイズを持っているという前提が必要となるのでそこには気をつけなくではならなくなります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>たまにこうやって、自分ではまだ遭遇していない場合に対して考えられるチャンスとなるので、コミュニティに注目するのは良い経験となると思います。調べている間に普段は使ってみたことのないメソッドやAPIを調べてみたり、自分が書いていたコードを振り返ってみる良い機会にもなりますね。&lt;/p>
&lt;p>他にもKeyは構わなく、重複するValueがある場合のみチェックするとか、要素のフィールドが重複している場合をチェックするかなどさまざまなバリエーションを考えられると思います。どれも面白い主題なのですが、今回の主題とは少し乖離があるため、機会があればいつかそのようなケースに対してのコードもブログに載せたいと思います。では、また！&lt;/p></description></item><item><title>Streamを正しく使う</title><link>https://retheviper.github.io/posts/java-stream/</link><pubDate>Mon, 06 Apr 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-stream/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Streamを正しく使う" />&lt;p>個人的には、関数型プログラミングにあまり詳しくはないですが、Java 1.8のStream APIは好んで使っています。他にもLambdaやOptionalといったAPIも好きですが、自分がJavaの資格を取った理由も、このStream APIについてもっと勉強したかったからと言っても過言ではないです。&lt;/p>
&lt;p>そんな私ですが、Streamについて勉強している中、疑問が出来ました。Streamは確かにいいAPIですが、伝統的なJavaのAPIとはかなり違うものです。これをJavaに導入したことで得られるメリットがあるから導入されたはず、というのは難しくない推論ですが、逆の場合はどうでしょうか？Streamを使った場合のデメリットは？そして自分が使っているStreamの書き方は正しいのか？などなど。&lt;/p>
&lt;p>今回のポストでは、そのような疑問について独自に調査したことを述べていきたいと思います。正解というより、こういう見解があるということとしてご理解ください。&lt;/p>
&lt;h2 id="streamは万能か">Streamは万能か？
&lt;/h2>&lt;p>まず最初の質問です。Streamは万能か？つまり、既存のコードをすべてStreamに書き換えても問題はないか？そしてなるべくこれから書くコードはStreamに変えるべきなのか？という質問ですね。確かに新しいAPIが出て、既存のコードと同じ役割ができるとしたら、それにはなんらかの理由があります。Javaの場合は、NIOがそうでした。一般的なI/OではOSのカーネルの機能を利用できなかったため、それを改善するために登場しましたね。しかし、NIOもまた、全ての場面で既存のI/Oより優れているとは言えない面がありました。そしたらStreamの場合も、その可能性はあると思いました。&lt;/p>
&lt;p>結論からいうと、「全てのコードをStreamに書き換える必要はない」です。その理由を、一つ一つ項目別に説明します。&lt;/p>
&lt;h3 id="性能は劣る場合も">性能は劣る場合も
&lt;/h3>&lt;p>Java 1.5では、伝統的なFor文意外にも、いわゆる拡張For文というものが登場しました。そして1.8では、Streamと共にforEach()というメソッドもできましたね。しかし、forEach()もStreamも性能は拡張For文より劣ります。また、とあるベンチマークでは、Streamを使った場合の処理はParallelを使っても拡張For文より性能は劣るという結果が出たらしいです。理由は簡単です。Streamを使うと、より複雑な処理が中に入るからです。特に配列をStreamに変換する時はラッピングが入るので、そこでもう処理が加えられるということを考えられますね。&lt;/p>
&lt;p>特に、オブジェクトを扱う場合の性能の差はそんなに大きくないものの、プリミティブ型を扱う場合は性能の差がより大きいらしいです。なので無理やり配列をStreamに変えて処理をする必要はありません。StreamやforEach()は、それを持って安定したコードを書けられる場合に限定して使う必要があります。そしてStreamを使う場合もプリミティブ型を扱う場合はIntStreamやToIntStreamといった、それぞれの型に合わせたクラスを使った方がより良い性能を出すので、そこもちゃんと考慮すべきですね。&lt;/p>
&lt;p>JVMが長い間伝統的なFor文に最適化されてきて、1.8になってやっと登場したStreamはそれほど最適化されてないので性能が劣るという話もありましたが、これは1.8がリリースされた当時の記事に書いてあったものなので14までバージョンアップがなされた今はどうかという疑問はあります。それでも伝統的なFor文の方がまだ性能では優秀ではないだろうかと思いますが。&lt;/p>
&lt;h3 id="途中でやめられない">途中でやめられない
&lt;/h3>&lt;p>Streamの処理は一般的なforループとは違って、continueやbreak、returnなどで一部の処理をスキップしたり途中で処理を止めることができません。基本的にStreamは全要素に対して処理をすることを前提にして設計されたからです。なのでそれぞれの目的に合わせて、Streamのメソッドを適切に使い分ける必要があります。例えばFor文での処理は以下のような変えられます。&lt;/p>
&lt;ul>
&lt;li>条件に合致する要素だけを処理したい場合(if)
&lt;ul>
&lt;li>filter()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Collectionにしたい場合(add)
&lt;ul>
&lt;li>collect()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要素を取り出したい場合(return)
&lt;ul>
&lt;li>findAny() / findFirst()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="ループ変数を使用できない">ループ変数を使用できない
&lt;/h3>&lt;p>拡張For文ではなく、伝統的なFor文ではループ変数を使って、現在のループが何回目かを数えることができます。しかし、Streamではループ変数を使うことができません。例えば、以下のようにStreamの外部に変数を置いてもコンパイルエラーとなります。&lt;/p>
&lt;p>int型のループ変数を使いたい場合はIntStreamを、ループ変数で処理をスキップしたい場合はskip()を使いましょう。もちろん、こういう場合は普通に既存のFor文を使った方が正解に違いです。&lt;/p>
&lt;h3 id="そもそもの関数型">そもそもの関数型
&lt;/h3>&lt;p>実は、Streamの中でも外部変数をループ変数として使う方法がなくはないです。AtomicIntegerでループ変数を使う方法がありますが、そこまでしてStreamを使う理由もなければ、関数型プログラミングの目的に合いません。&lt;/p>
&lt;p>関数型プログラミングのコンセプトの中では不変性(Immutability)というものがあります。以前&lt;a class="link" href="../java-thoughts-of-immutable" >Immutabilityについて述べたこと&lt;/a>がありますが、ここで重要なのはデータが変わることはない、ということです。データが変わらないならどうやって処理が行われるかというと、元のデータはそのままで、処理ではそのデータのコピーを作って作業することになります。&lt;/p>
&lt;p>Streaｍを持って処理をする場合に、その結果が新しいインスタンスになるのもそれが理由です。Listをループさせる場合は、元の要素を編集できます。しかし、Streamで処理する場合は変更された要素で構成された新しいListを返すようになりますね。中間操作で元の要素を編集するとしても、Streamは終端操作が終わるとクローズされ再利用できなくなります。これで元のデータは変えずに済みますね。&lt;/p>
&lt;p>なのでStreamを使う場面というのは、まず元のデータをどうするかによります。もちろん、Streamを使わない場合でも、関数型的なコードの作成がより場合も多いです。(ということで、まずは関数型プログラミングを勉強ですね…)&lt;/p>
&lt;h2 id="streamをより活用する">Streamをより活用する
&lt;/h2>&lt;p>次に、Streamを使う場合に、どうしたら正しく、より効率的に活用できるかに関する質問です。Streamは最初から再使用できないようになっていますが、場合によっては同じデータに対してそれぞれ違う処理を行う必要があるのでそれがどうやって実現できるか、という疑問がありました。例えば、普通のFor文だとループの中で分岐を置くことで二つのCollectionに要素を分配するような処理ができるのですが、Streamだと同じオブジェクトに対しての処理はできませんね。こういう場合は同じデータに対してどうやったらStream処理を2回以上できるか気になります。&lt;/p>
&lt;p>もう一つは、自分だけなのかもしれませんが、Stream以外でも、メソッドチェーニングを使えるAPIは非効率的な処理が入ってもすごく場合があって、それをどうしたら効率的な書き方にできるかという疑問がありました。例えばCollectionや配列をStreamに変換してからforEach()を使うこともできますが、CollectionだとstreamなしでもforEach()は使えますね。こういう場合は直感的にCollectionのforEach()の方が良さそうだとは思いますが、それ以外の場合はどうなのかよくわかりません。&lt;/p>
&lt;p>なので、この二つの疑問についても調査してみました。&lt;/p>
&lt;h3 id="再使用">再使用
&lt;/h3>&lt;p>Streaｍは何度も繰り返して中間操作が可能ですが、一度でも終端操作が行われるとクローズされ、再利用ができなくなります。なぜなら、Streamの目的はデータの処理であって、データの格納ではないからです。&lt;/p>
&lt;p>しかし、たまには同じデータに対してStreamを利用し、それぞれ違う処理を行たい場合もありますね。そういう時はどうしたらいいでしょう。Javaでデータを格納するためのものは配列やCollectionがありますので、必要なデータを予め定義して、場合によってそれをStreamに転換して使う方法があります。配列の場合は&lt;code>Arrays.stream()&lt;/code>や&lt;code>Stream.of()&lt;/code>があり、Collectionだと&lt;code>stream()&lt;/code>がありますね。例えば以下のような方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listで必要なデータを集めておく&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> names &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Eric&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Elena&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Java&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> name.&lt;span style="color:#a6e22e">contains&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1番目のStream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> firstElement &lt;span style="color:#f92672">=&lt;/span> names.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">findFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2番目のStream&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> anyElement &lt;span style="color:#f92672">=&lt;/span> names.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">findAny&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>予め必要なデータはListとしてCollectし、必要な場合はそれをまたStreamに変換して使う例でした。データがそもそもCollectionや配列の場合は、必要に応じてstream()を呼び出すことでそれぞれ違う処理ができます。また、peek()を挟むことで違うCollectionにデータを追加することもできます。厳密にいうと再使用というよりはどうStreamを作るかに関する話となりますが、これで一つのデータから複数の処理結果を出すことは可能、ということになります。&lt;/p>
&lt;h3 id="短く書く">短く書く
&lt;/h3>&lt;p>先に述べましたが、StreamはメソッドチェーニングのできるAPIなので、非効率的なコードを書きやすい傾向がありました。なのでケース別により効率的な書き方を集めてみました。自分はEclipseを主に使っているのですが、Intellijだと、こうした方がいいよとオススメしてくれる部分らしいです。&lt;/p>
&lt;ul>
&lt;li>Collectionのメソッドを使う&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// CollectionのForEach&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>collection.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">forEach&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> collection.&lt;span style="color:#a6e22e">forEach&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collectionを配列に&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>collection.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">toArray&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> collection.&lt;span style="color:#a6e22e">toArray&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>Streamを作る&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 配列からStreamに&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>().&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>() &lt;span style="color:#f92672">/&lt;/span> Stream.&lt;span style="color:#a6e22e">of&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 空のStreamを作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Collections.&lt;span style="color:#a6e22e">emptyList&lt;/span>().&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Stream.&lt;span style="color:#a6e22e">empty&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 範囲指定で配列を作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IntStream.&lt;span style="color:#a6e22e">range&lt;/span>(expr1, expr2).&lt;span style="color:#a6e22e">mapToObj&lt;/span>(x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> array&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(array, expr1, expr2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 範囲指定でStreamを作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Collection.&lt;span style="color:#a6e22e">nCopies&lt;/span>(count, ...)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Stream.&lt;span style="color:#a6e22e">generate&lt;/span>().&lt;span style="color:#a6e22e">limit&lt;/span>(count)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>要素の判定&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 条件に一致する要素が存在するかの判定(1)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">filter&lt;/span>().&lt;span style="color:#a6e22e">findFirst&lt;/span>().&lt;span style="color:#a6e22e">isPresent&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">anyMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 条件に一致する要素が存在するかの判定(2)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">map&lt;/span>().&lt;span style="color:#a6e22e">anyMatch&lt;/span>(Boolean::booleanValue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">anyMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素が一つでも条件と一致しないかの判定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">!&lt;/span>stream.&lt;span style="color:#a6e22e">anyMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">noneMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 全要素が条件と一致するかの判定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">!&lt;/span>stream.&lt;span style="color:#a6e22e">anyMatch&lt;/span>(x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>(...))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">allMatch&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ソートして最も先にある値を探す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">sorted&lt;/span>(comparator).&lt;span style="color:#a6e22e">findFirst&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> Stream.&lt;span style="color:#a6e22e">min&lt;/span>(comparator)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>要素を集める&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素の数を数える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(counting())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">count&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 最も大きい要素を探す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(maxBy())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">max&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素を違うオブジェクトにマッピングする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(mapping())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">map&lt;/span>().&lt;span style="color:#a6e22e">collect&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素を一つにまとめる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(reducing())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">reduce&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素を数字の合計にする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">collect&lt;/span>(summingInt())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">mapToInt&lt;/span>().&lt;span style="color:#a6e22e">sum&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>要素の処理&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 要素の状態だけを変える&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stream.&lt;span style="color:#a6e22e">map&lt;/span>(x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {...; &lt;span style="color:#66d9ef">return&lt;/span> x;})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> stream.&lt;span style="color:#a6e22e">peek&lt;/span>(x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ...)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>関数型プログラミングに興味がないとしても、Streamそのものはかなり魅力的なAPIですので、皆さんにもぜひ使ってみて欲しいです。Java 1.8がリリースされた当時には性能も劣り読みにくいという批判も多かったのですが、もう時間は経ち、Javaのバージョンはすでに14となっているくらいです。もうそろそろStreamを使ってモダンな書き方を試してみても良いでしょう。&lt;/p>
&lt;p>そしてStreamを通じて、関数型プログラミングを味わえるのも一つのメリットではないかと思います。もちろん、Streamが完璧な関数型プログラミングの例だとは言い切れませんが、少なくとも、オブジェクト指向だけでなく新しいプログラミングのトレンドはどういうものかを経験できるということだけでも十分価値があるのではないでしょうか。もう関数型プログラミングの概念が登場してからも数年が経っています。プログラミングの世界は常に変化と発達が伴うものなので、少なくとも最近のトレンドが何であるかくらいは把握しておきたいものです。&lt;/p>
&lt;p>では、またあいましょう！&lt;/p></description></item><item><title>Oracle JavaSE 8 Goldについて</title><link>https://retheviper.github.io/posts/java-se-8-gold/</link><pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-se-8-gold/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Oracle JavaSE 8 Goldについて" />&lt;p>この度はJava SE 8 Goldを受験しました。Silverを取ったのが去年の9月末だったので、およそ半年ぶりの受験ですね。以前、Silverの方を受験した時は&lt;a class="link" href="../java-se-8-silver" >ポスト&lt;/a>でその感想を書いていたので、今回も同じくGold受験後の感想を書こうと思います。&lt;/p>
&lt;h2 id="generics">Generics
&lt;/h2>&lt;p>Genericsに関する問題は、型が明確ではない場合をとう問題が多かったです。例えばとあるクラスを継承しているクラスのみを引数として受けたい場合はどうするか、とかの問題ですね。&lt;code>&amp;lt;? super X&amp;gt;&lt;/code>と&lt;code>&amp;lt;? extends X&amp;gt;&lt;/code>の違いがよくわからないと難しくなる、そのような問題です。&lt;/p>
&lt;p>また、Genericsに関しての問題は&lt;code>Comparator&amp;lt;T&amp;gt;&lt;/code>と&lt;code>Comparable&amp;lt;T&amp;gt;&lt;/code>も登場していて、これからどう違うか、またどこで必要となるものかを理解していないと難しい問題になっていました。個人的にはあまり使ってないAPIだったので最初は苦戦した問題でした。理解できればなるほど、となりますが、これからもそんなに使うことあるかどうか…でも確かに知っておけば便利そうな気はしますので覚えておきたいAPIです。&lt;/p>
&lt;h2 id="lambda">Lambda
&lt;/h2>&lt;p>Java 1.8の重要機能であるLambdaはやはり問題数が多いです。Lambdaはただ単にメソッドの書き方が楽になったということだけではなく、それを活用できる関数型インタフェースやStreamなど、他の重要なAPIと関係がある重要なAPIですので、やはりこれがわからないと本当の意味でJava 1.8を理解していないと言えるでしょう。&lt;/p>
&lt;p>Lambdaに関する問題は、関数型インターフェースの条件(SAM)やjava.util.functionパッケージで提供しているインターフェースの種類を理解していないと解けないものが多い感じでした。また、Method Referenceに関する問題も出題されています。Lambdaをしっかり理解していれば書き方が違うだけというのがわかりますが、そうでないとコードすら読めないかもしれません。&lt;/p>
&lt;h2 id="stream">Stream
&lt;/h2>&lt;p>Streamは問題の割合が多いです。Java 1.8で追加された重要なAPIの一つでもあり、今までのJavaのAPIとは性格がちょっと違うものでもあるのでなんとなく感だけで使っていた自分には大変勉強となりました。今まではせいぜいstream()やcollect()くらいしか使ってなかったのですが、今回の試験でこれから色々Streamを活用できる箇所が増えていくような気がします。&lt;/p>
&lt;p>個人的には既存のコードが問題なく作動していていればわざわざStreamに変える必要があるくらいではないものの、関数型プログラミングの特徴を少しでも味わえる素敵なAPIと思います。例えば問題では中間操作と終端操作の違いやそれぞれのメソッドの活用方法などに関する質問が出ていて、それらしきメソッド名を並べては「次の中、〇〇APIのメソッドとして正しいものを選びなさい」のような意味のない問題に比べ、APIそのものの特徴と使い方を理解できないと解けない問題となっている感じがして好きでした。特に、peek()やsorted()、Collectors.groupingBy()のような良いメソッドが出てきて嬉しかったです。&lt;/p>
&lt;h2 id="io">I/O
&lt;/h2>&lt;p>基本的にはJava 1.7から追加されたNIOに関する問題が多かったです。これもまたStreamと結び付けるためか、lines()やlist()、walk()などのメソッドに関して問う問題が多かったですね。また、同じく1.7から登場したtry-with-resourceに関する問題も出たのでよかったと思います。&lt;/p>
&lt;p>自分の場合はファイルI/Oで主にNIOのFilesクラスを使うことが多いので馴染んでいるのもあって、close()をわざわざ呼び出さなくても安全なAPIを提示してくれるってことはこれからの習慣にもいい影響を与えるだろうと思います。&lt;/p>
&lt;p>個人的には仕事でもAutoCloseableを継承したクラスを作ったこともあったので嬉しかったです。&lt;/p>
&lt;h2 id="thread">Thread
&lt;/h2>&lt;p>並行性に関する問題も割合的には多い感じでした。AtomicIntegerやExecutorServiceのような重要なAPIを学ぶ良い機会となりましたが、せっかくRunnableやCallableまで扱っているので、CompletableFutureまで扱ってくれていたらよかったのでは、と思いました。CyclicBarrierが出ていましたが、最近はあまり使われてないらしいですしね。スレッドはそこまで難しくなく、ForkJoinPoolとCyclicBarrier、RunnableとCallableのシグニチャをちゃんと覚えておいたら解ける問題が多かった気がします。&lt;/p>
&lt;h2 id="temporal">Temporal
&lt;/h2>&lt;p>LocalDateTimeなどのAPIに関する問題が少し出ていましたが、割合は低め。Silverでも扱っていたAPIなので、こちらではフォーマッターや例外になるパターンに関する問題が多かったような気がします。ZoneIdなども出てきましたが、そこまで重要ではないような印象でした。&lt;/p>
&lt;h2 id="locale">Locale
&lt;/h2>&lt;p>こちらもまた割合は低め。ただ、プロパティーをどう読み込むかはLocaleだけでなく環境変数などを扱う時も必要な知識となるため、覚えておくかちはあると思います。APIのシグニチャを問う問題の場合はインターネットでも十分情報を得ることができるのでわざわざ覚える必要はあるのかな？といったところですが…&lt;/p>
&lt;h2 id="他に">他に
&lt;/h2>&lt;p>JDBCに関する問題も少々ありましたが、やはり今はあまり使われてないので問題の数は少なかったです。自分の場合はJavaでのDB処理にはMybatisやJPAを使っているのでわざわざJDBCを使うことはないのですが、基本的にJavaではこういう風にDBにアクセスして処理をしているんだな、ということだけ分かれば十分なのではと思っているので、問題の割合としては適切だったかなと。&lt;/p>
&lt;p>また、SilverまではJavaのAPIをちゃんと覚えているかを問う問題が多いような気がしますが、Goldからはクラス設計に関する問題もいくつか出ていて、カプセル化やシングルトンクラスをどう実装するべきかに関する問題や、Files.walk()による再帰処理などに関する問題もあったのですが、Goldを受験する人がそのような知識がないとは思えないのですね。&lt;/p>
&lt;p>一つ、せっかく同じような使い方(メソッドチェイン)をしていて、Streamで要素を取得する時も使えるOptionalについては言及されてないことは残念に思います。他と同じくJava 1.8で導入されたものなのになぜ…？って感じですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>去年はJava SE 11の資格も登場したので、最初からそちらにした方がよかったかなとも思いましたが、Oracleの公式ホームページの試験の紹介だとJava 9から導入されたモジュールシステム以外はあまり試験の内容が変わってないようです。&lt;/p>
&lt;p>8も11もLTSバージョンなので、次のLTSである17がリリースされたら、おそらく資格も更新される可能性があります。個人的には12から14まで導入された新機能の方が便利だと思うので、私のように勉強の目的で受験していて、元々8の資格を持っている方ならあまり11へのアップグレードはメリットがないかもしれません。もちろん、これから初めて資格を取得する人にとっては11の方が良いでしょう。自分はそんなことも知らずにとりあえず8を受験してしまったのですが…&lt;/p>
&lt;p>とりまとめ、資格取得は嬉しいことですが、何よりも勉強のため始めたJavaの資格が、思っていたより仕事で役立つ知識を提供していたので満足しました。問題自体はパターンをよく覚えだけで解けるものも多いのですが、JavaのAPIに対する理解を深めたい方なら、受験してみて損することはないと思います。受検料は高いですが…&lt;/p></description></item><item><title>Javaはこう進化して欲しい</title><link>https://retheviper.github.io/posts/java-wishes/</link><pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-wishes/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Javaはこう進化して欲しい" />&lt;p>Javaは長い間業界で生産性、性能、安定性で評判がよく、最近はバージョンアップも様々な機能が追加されています。仕事では主に11バージョンを使っていますが、次のLTSバージョンである17がリリーズされたらそちらを使うことになるのではないかと思います。なので今も新しいバージョンが発表されると一応更新履歴には目を通していますが、言語仕様そのものが変わる場合は新しいAPIの追加と比べ少ない気がしなくもないです。&lt;/p>
&lt;p>Javaが人気を得た理由の一つの生産性という部分では、今じゃPythonやJavaScriptなどに比べて劣る部分もあり、「コードが読みやすい」というメリットも、いつの間にか「冗長すぎる」という評価と変わってしまいましたね。自分はJavaが好きで、まだ言語そのものの仕様まで見切ってはいないですが、それでも使いながらこれは不便だな、これは他の言語と同じくなって欲しいなと思う時もあります。今回のポストでは仕事でJavaを扱いながら感じた不便なところ、また他の言語と比べて改善したいところについて述べたいと思います。こうして他の言語と比べ、Javaがどんなものであるかを把握していくのもまた一つの勉強になるのでは、と思いますので。&lt;/p>
&lt;h2 id="optional表記の改善">Optional表記の改善
&lt;/h2>&lt;p>以前のポスト](../java-optional)で紹介したOptionalですが、これはJavaだけでなく他の言語でも多く採用しているAPIの一つですね。むしろ、JavaのOptionalが他の言語から影響され導入されたものらしいです。今は私自身もよく使っていて、すごい便利だと思っていますが、それでも他の言語と比べたらやはり不便と思うところがあります。&lt;/p>
&lt;p>他の言語と比べてコードが冗長であることがJavaの特徴と先に述べましたが、実際のコードではどうかをまず比較してみましょう。複雑にネストしているオブジェクトのとあるフィールドを読み、Nullだった場合はデフォルト値を返却する例を持って説明します。&lt;/p>
&lt;h3 id="java">Java
&lt;/h3>&lt;p>Javaのコードでは、最初のオブジェクトをOptionalでラップし、ネストされているフィールドやメソッドに対してmap()をチェーニングしていくことで次から次へとラップの対象を変えていきます。そして最後に、ターゲットのオブジェクトがNullだった場合はorElse()などのメソッドでデフォルト値を設定しますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元のオブジェクト&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SomeClass object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複雑にネストされている&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(object).&lt;span style="color:#a6e22e">map&lt;/span>(obj::getProp1).&lt;span style="color:#a6e22e">map&lt;/span>(prop1::getProp2).&lt;span style="color:#a6e22e">map&lt;/span>(prop2::getProp3).&lt;span style="color:#a6e22e">orElse&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="c">C#
&lt;/h3>&lt;p>言語そのものがJavaと似ているC#ですが、より若いからか、Javaと比べ進んでいる部分がよく見当たるC#です。こちらでもKotlinとコードの書き方は同じです。違うのは、オブジェクトそのものがNullになる可能性を事前に宣言しないということだけですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object?&lt;/span>.prop1?.prop2?.prop3? ?? &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="javascript">JavaScript
&lt;/h3>&lt;p>JavaScriptのOptionalもまた、C#とあまり変わらないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">object&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">prop1&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">prop2&lt;/span>&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#a6e22e">prop3&lt;/span>&lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#f92672">??&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="swift">Swift
&lt;/h3>&lt;p>Swiftでもそう変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>object?.prop1?.prop2?.prop3 ?? &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kotlin">Kotlin
&lt;/h3>&lt;p>Kotlinもデフォルト値指定のためのElvis opertor特有の表現を覗くと、一緒ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span>&lt;span style="color:#f92672">?.&lt;/span>prop1&lt;span style="color:#f92672">?.&lt;/span>prop2&lt;span style="color:#f92672">?.&lt;/span>prop3 &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他の言語の例と比べて見ると、JavaのOptionalは確かに冗長な印象ですね。なので今後Optionalを言語の基本仕様として導入し、ラップをするのではなく?として表現できるようにしたらどうかという気もします。?を導入したところでコードの読みやすさを損ねるわけでもないですので。&lt;/p>
&lt;h2 id="multiple-return-statements">Multiple Return Statements
&lt;/h2>&lt;p>Javaの仕様ではメソッドの戻り値となれるオブジェクトは常に一つのみですが、Pythonのような言語では戻り値を複数指定することができます。もちろん、Javaの戻り値が一つという制約を乗り越えるためによくBeanやCollectionに複数のオブジェクトやデータを入れて返すことはできるのでこれはシンタックスシュガー的なものになるだけですが、それでも便利な方法があったら使いたくもなります。&lt;/p>
&lt;h3 id="java-1">Java
&lt;/h3>&lt;p>メソッドの処理結果として複数のデータを受け取りたい場合、Javaだと先に述べたようにBeanやCollectionを使うことになりますね。以下は戻り値が複数の数字である例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(1, 2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 戻り値の取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> data &lt;span style="color:#f92672">=&lt;/span> multipleReturn();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="c-1">C#
&lt;/h3>&lt;p>C#でもJavaと似たようなやり方で複数のデータを取得することができますね。実際はref/outパラメータを使ったり、structやclassを使う方法もあるらしいですが、Javaと比べより便利ではないかと思うのはTupleを使う場合です。C#のバージョンによって書き方が違っていて、昔の書き方ではJavaでCollectionを使うのとあまり変わらないものの、新しい書き方ではかなり便利なものとなっています。以下はその二つの例のコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つメソッド(7以前)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Tuple&amp;lt;&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&amp;gt; oldMultipleReturn()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Tuple.Create(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// オブジェクトとして取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> result = oldMultipleReturn();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つメソッド(7以後)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>) newMultipleReturn()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 変数として取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#66d9ef">int&lt;/span> one, &lt;span style="color:#66d9ef">int&lt;/span> two) = newMultipleReturn();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="python">Python
&lt;/h3>&lt;p>Pythonの例では、7以後のC#と似たような感覚でコードを書けます。オブジェクト(tuple)として戻り値を全部取得するか、個別の変数として取得するか両方一つのfunctionでできるのがより便利な気もしますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 複数の戻り値を持つfunction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">multiple_return&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 個別の戻り値を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a, b &lt;span style="color:#f92672">=&lt;/span> multiple_return()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(a) &lt;span style="color:#75715e"># 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 戻り値をtupleとして全取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>d &lt;span style="color:#f92672">=&lt;/span> multiple_return()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(d) &lt;span style="color:#75715e"># (1, 2)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="javascript-1">JavaScript
&lt;/h3>&lt;p>ES6から導入された書き方ではPythonと似たようなコードで複数の戻り値を取得できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つfunction
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">funtion&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">first&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">second&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 個別の戻り値を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> (&lt;span style="color:#a6e22e">first&lt;/span>, &lt;span style="color:#a6e22e">second&lt;/span>) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="swift-1">Swift
&lt;/h3>&lt;p>SwiftはやはりOptionalと同じく、JavaScriptとあまり変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つfunction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>() -&amp;gt; (Int, Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 個別の戻り値を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> (first, second) = multipleReturn()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kotlin-1">Kotlin
&lt;/h3>&lt;p>KotlinではPairかTripleなどがあり、使い方は簡単です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数の戻り値を持つfunction
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">multipleReturn&lt;/span>(): Pair&amp;lt;Int, Int&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> to &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 個別の戻り値を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>first, second) = multipleReturn()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaでのコードの書き方の方がメソッドの役割をわかりやすいというメリットはありますが、戻り値のオブジェクトやデータをそのまま変数として使えるという面ではPythonのやり方がより便利ですね。このように複数の戻り値を持つメソッドを定義できるのは現代プログラミング言語ならどれもが持っている機能のようです。Javaにもいつかは導入されるのでしょうか？&lt;/p>
&lt;h2 id="引数の種類をor指定">引数の種類をor指定
&lt;/h2>&lt;p>たまに、一つのメソッドで引数の型を複数指定できたら便利ではないだろうかと思うことがあります。Javaではこれをオーバーロードで実現していますね。&lt;/p>
&lt;h3 id="java-2">Java
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(String value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Stringの場合の処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// intの場合の処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もちろん、引数の型をObjectとして宣言し、内部ではinstansofを使って判定することもできます。しかし、前者ならやりたいことに比べコードの量が増えすぎる問題がありますし、後者なら意図した型以外のObjectが渡された場合の挙動がおかしくなる可能性もあります。&lt;/p>
&lt;h3 id="typescript">TypeScript
&lt;/h3>&lt;p>TypeScriptでは、これを簡単に引数のタイプを複数指定できるようにすることで解決しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ts" data-lang="ts">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">checkString&lt;/span>(&lt;span style="color:#a6e22e">v&lt;/span>: &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">number&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">typeof&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#e6db74">&amp;#34;string&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これまで引数の種類だけ違う場合はオーバーロードして、共通処理だけprivateメソッドで書いていましたが、これならよりコードを簡単に把握できそうですね。ぜひ導入して欲しい機能の一つです。&lt;/p>
&lt;h2 id="ternary-operator-with-throw">Ternary Operator with Throw
&lt;/h2>&lt;p>結果が二択しかない場合は、なるべくifより三項演算子を使った方がコードも短くなり便利と思います。しかし、Javaの三項演算子では例外を投げることができません。条件式に当てはまらない場合はどうしても以下のようなコードを書くしかないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// xが0だとnumberも0で、0ではなかった場合は例外とする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> number &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>無理やり三項演算子で例外を投げようとしたら、以下のような方法はありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Genericな戻り値を持っていて、例外を投げるだけのメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> T &lt;span style="color:#a6e22e">throwSomeException&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// elseでメソッドを呼ぶ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> number &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">==&lt;/span> 0 &lt;span style="color:#f92672">?&lt;/span> x : throwSomeException();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的にif文は二択しかない結果のために使うのはスペースの無駄遣いと思いますし、無理やりメソッドを作ってまで三項演算子を使う必要はないので、三項演算子でelseの場合には単純に例外を投げられるといいな、と思っていました。そして調べてみると、他の言語ではそれができるようです。&lt;/p>
&lt;h3 id="c-2">C#
&lt;/h3>&lt;p>C#では、二つのやり方があります。まず7以前だと、elseの場合に例外を投げるFuncを実行させることで実現できます。そして7以後では普通に三項演算子でthrowできるようです。まさに私が望んでいた形ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 7以前&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> number = x == &lt;span style="color:#ae81ff">0&lt;/span> ? x : &lt;span style="color:#66d9ef">new&lt;/span> Func&amp;lt;&lt;span style="color:#66d9ef">int&lt;/span>&amp;gt;(() =&amp;gt; { &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Exception(); })();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 7以後&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> number = x == &lt;span style="color:#ae81ff">0&lt;/span> ? x : &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Exception();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="kotlin-2">Kotlin
&lt;/h3>&lt;p>Kotlinでは三項演算子がなく、if-elseを使うことになるということだけで、簡単な形になっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> i = &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) x &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> Exception(&lt;span style="color:#e6db74">&amp;#34;error&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="javascript-2">JavaScript
&lt;/h3>&lt;p>JavaScriptでは、7以前のC#と似た形で例外を投げることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">number&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">:&lt;/span> (&lt;span style="color:#66d9ef">function&lt;/span>() { &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#e6db74">&amp;#34;error&amp;#34;&lt;/span> }());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>わざわざ関数を実行してまで三項演算子で例外を投げたくはないですが、こういうやり方があるということがわかっただけでもかなり興味深いですね。JavaにもC#の7以後のような書き方ができるといいな、と思います。&lt;/p>
&lt;h2 id="アクセス修飾子の拡張">アクセス修飾子の拡張
&lt;/h2>&lt;p>Javaでのアクセス修飾子は、public・private・protectedをよく使っています。しかし、自作ライブラリーを作る場合はpublicとprivateの中間的なものもあって欲しいな、と思う時もあります。例えばJarにまとめた時、Jar以外ではアクセスできないようなアクセス制限をかけられるようなものですね。&lt;/p>
&lt;p>Java 9からモジュールが導入されましたが、自分が経験した問題もあるのでなるべくモジュールを使いたくはないなと思っているので…同じプロジェクトの中ならパッケージが違ってもアクセスできるような修飾子があったらいいな、と思います。また、protectedならサブパッケージでも参照できるなど。同じモジュール内でのみのアクセス修飾子はC#とSwift、KotlinでInternalとして提供しているので、Javaにも導入されるといいですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最近のJavaの更新履歴をみると、続々と便利な機能が導入され続けています。特に14では、recordでLombokの&lt;code>@Data&lt;/code>と同じ機能を持つクラス宣言ができるようになるらしいです。次のLTS版は17なので、まだ十分色々と改善される余地はありますね。1.8でも便利な機能は多いですが、これからもどんどん他の言語の良い点を吸収して変転できるといいなと思います。&lt;/p>
&lt;p>また、こうやって他の言語ではどうしているかを調べてみるのも良い勉強となりました。特にTypeScriptは最近注目している言語なので、機会があれば経験してみて、Javaとの比較もしてみたいものですね。では、また！&lt;/p></description></item><item><title>IOからNIOへ</title><link>https://retheviper.github.io/posts/java-nio/</link><pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-nio/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post IOからNIOへ" />&lt;p>私がそうでしたが、今でも初めてJavaでのI/Oを学ぶとしたら、やはりFileオブジェクトを生成してInputStreamで読み込んだり、OutputStreamで書き込むのが一般的なのではないかと思います。ここで少し発展すると、WriterやReaderなどのクラスを使ったり、StreamをBufferで包んだり、SerializableでオブジェクトのI/Oを行ったりするレベルまで行くのでしょう。&lt;/p>
&lt;p>昔のAPIだとしても、動作や性能に大した問題がなければあえて新しいAPIにコードを全部変える必要はないと思います。むしろ無理やり新しいAPIに書き換えたコードが問題を起こす可能性もあるし、常に優秀とは言えませんので。例えばJava 1.8で追加されたforEach()は便利で、Lambdaが好きな私は多くの場面で使っていますが、実際は今までのJVMは伝統的なforループに最適化されているのでforEach()は性能で劣るらしいです。今後、forEach()の性能がより良くなる可能性もなくはないでしょうが、最近のJavaのバージョンアップ履歴をみると関数型APIの性能改善にどれだけ時間がかかるかは少し謎です。&lt;/p>
&lt;p>新しいAPIを使うということにはこのような問題もあり、慎重ではければならないのですが、それでもAPIが新しくなるのには何らかの理由があるためなので、新しくコードを書いたり簡単なコードに変えたりするなどの理由があれば、積極的に新しいAPIを導入してみるということもそう悪くないと思います。今回紹介したいAPIもまたそのようなものです。ファイルI/Oを扱う新しい方式、NIOです。(と言っても、Java 1.7から導入されたので今はあまり新しくもないですが…)&lt;/p>
&lt;h2 id="nioって何">NIOって何？
&lt;/h2>&lt;p>NIOは、Javaの新しいI/Oのことです。Newの略かと思いがちなのですが、実際はNon-blockingの略らしいですね。JavaはCやC++と比べ遅いですが、その理由の一つがI/Oだったらしいです。なのでそれを改善するために出たのがこのNIOですと。&lt;/p>
&lt;p>BlockingかNon-blockingかによる違い、Stream基盤かChannel基盤かという違いなど様々な違いがありますが、一般的には頻繁なI/Oが要求される場合ではNIOを選択した方がより良い性能を期待できると言います。他には以下のようなメリットがあります。&lt;/p>
&lt;ul>
&lt;li>スレッドのブロックが発生しない&lt;/li>
&lt;li>コードがより簡潔&lt;/li>
&lt;li>コピー、移動、読み込みのオプション指定が簡単&lt;/li>
&lt;li>基本的にBufferを使うので、Buffered~でのラッピングが要らなくなる&lt;/li>
&lt;/ul>
&lt;p>あまりJVMの構造に詳しくないので、私がここで浅い知識を持って説明するようなことはしません。ただ、自分の観点からしてコードがより簡潔になるということは確かなメリットです。なので皆さんにもぜひ使ってみていただきたいと思います。&lt;/p>
&lt;p>それでは、実際のコードでNIOをどう使うかについて説明して行きます。&lt;/p>
&lt;h2 id="file--path">File → Path
&lt;/h2>&lt;p>NIOではFileオブジェクトよりPathオブジェクトを使います。PathはFileオブジェクトに比べ、ファイルパスをディレクトリとファイル名で分離して指定できるのが最大のメリットです。&lt;/p>
&lt;p>例えばファイルパスが複数のフォルダでネストされているとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 複数のディレクトリとファイルがそれぞれ文字列として存在(path/to/file.txt)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String rootDirectory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;path&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String toDirectory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;to&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String fileName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;file.txt&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この複数の文字列からインスタンスを作成するとしたら、Fileのコンストラクターは引数が一つの文字列なので以下のようになります。ディレクトリの文字列にスラッシュが含まれてないので、文字列を結合しながらスラッシュも一緒にいれる必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Fileオブジェクトの生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>File file &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> File(rootDirectory &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> toDirectory &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> fileName);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Pathの場合は指定できる文字列が複数でも構いません。ディレクトリとファイル名の文字列を順番通り指定するだけで良いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Pathオブジェクトの生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Path path &lt;span style="color:#f92672">=&lt;/span> Paths.&lt;span style="color:#a6e22e">get&lt;/span>(rootDirectory, directory, fileName);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、インスタンスの作成がより便利なのがPathです。また、どうしてもFileオブジェクトが必要な場合があるとしても、FileのメソッドからPathに変換できる機能があるので便利ですね。もちろん、その逆もできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathからFile生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Path path &lt;span style="color:#f92672">=&lt;/span> file.&lt;span style="color:#a6e22e">toPath&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// FileからPath生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>File file &lt;span style="color:#f92672">=&lt;/span> path.&lt;span style="color:#a6e22e">toFile&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にもtoURI()メソッドでURIオブジェクトを生成できるなど、PathにはFileと同じ機能をするようなメソッドが多いので、どちらか便利な方を使いましょう。&lt;/p>
&lt;h2 id="files">Files
&lt;/h2>&lt;p>昔ながらのI/Oでファイルのコピーや削除などの操作を行うためにはInputStream、OutputStream、Writer、Readerなどのクラスを活用してきました。NIOでは主にこれらの作業をFilesクラスを持って行います。また、FilesクラスにはWriterとReader、InputStreamとOutputStreamを生成する機能もあるので使い勝手が良いクラスです。&lt;/p>
&lt;h3 id="ファイルのコピー">ファイルのコピー
&lt;/h3>&lt;p>Filesクラスでのファイルコピーは簡単です。以下のコードを見てください。基本的にコピー元とコピー先のファイルをPathオブジェクトとして指定するだけです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathをPathにコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">copy&lt;/span>(source, target);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>FilesクラスでのコピーにはENUMでコピー時のオプションを指定することもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// オプションを指定(ファイル属性もコピー)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StandardCopyOption option &lt;span style="color:#f92672">=&lt;/span> StandardCopyOption.&lt;span style="color:#a6e22e">COPY_ATTRIBUTES&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">copy&lt;/span>(source, target, option);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、実際存在するファイルではなく、InputStreamをコピー元として指定することもできます。この場合、データをファイルに書き込むということもできますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// InputStreamをPathにコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">copy&lt;/span>(sourceStream, target);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルの削除">ファイルの削除
&lt;/h3>&lt;p>Filesクラスでのファイル削除はコピーと同じく、Pathオブジェクトを引数として渡します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 削除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">delete&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>戻り値がbooleanのメソッドも用意されています。ファイルが存在する場合は削除して、その結果をbooleanとして返します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 存在する場合削除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">deleteIfExists&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルの移動">ファイルの移動
&lt;/h3>&lt;p>ファイルの移動は、コピーと削除の組み合わせみたいなものですね。また、ファイル名を変える場合にも使えます。基本がコピーだからか、コピーの時と同じオプションを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 移動もしくはリネーム&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">move&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// オプションを指定(上書きする)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StandardCopyOption option &lt;span style="color:#f92672">=&lt;/span> StandardCopyOption.&lt;span style="color:#a6e22e">REPLACE_EXISTING&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">move&lt;/span>(path, option);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルの書き込み">ファイルの書き込み
&lt;/h3>&lt;p>InputStreamをcopy()で使えるのですが、ファイル書き込みの場合のメソッドもあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Pathにデータを書き込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">write&lt;/span>(path, content);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>write()メソッドの引数として渡せるのは&lt;code>byte[]&lt;/code>、&lt;code>List&amp;lt;String&amp;gt;&lt;/code>などがあります。また、コピーの場合のようにオプションが指定できます。こちらのオプションではファイルが存在する場合上書きするか、追記するかを選べるので場合によってはcopy()と分けて使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// オプション指定(追記)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StandardOpenOption option &lt;span style="color:#f92672">=&lt;/span> StandardOpenOption.&lt;span style="color:#a6e22e">APPEND&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">write&lt;/span>(path, content, option);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルの読み込み">ファイルの読み込み
&lt;/h3>&lt;p>書き込みが文字列かbyte[]で分けられているように、読み込みも同じ形でファイルを取得できるメソッドがあります。文字列取得の場合、シンタックスシュガーとして結果物がStreamかListかくらいの違いがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 文字列として全行を読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> lines &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">lines&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> liness &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">readAllLines&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// byte[]として読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bytes &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">readAllBytes&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Fileがそうであるように、Pathもまたファイルではなくディレクトリになれるので、Filesのメソッドもそれに対応しています。list()メソッドではディレクトリないのエントリをPathとして取得してStreamを生成します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ディレクトリ内のエントリを要素として持つStream取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Stream&lt;span style="color:#f92672">&amp;lt;&lt;/span>Path&lt;span style="color:#f92672">&amp;gt;&lt;/span> files &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">list&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ioとの組み合わせで使う">I/Oとの組み合わせで使う
&lt;/h3>&lt;p>先に述べたように、Filesのメソッドの一部は昔ながらのI/Oと組み合わせて使えるものもあります。その一部を紹介します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 読み込みの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InputStream is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BufferedReader br &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newBufferedReader&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 書き込みの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OutputStream os &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newOutputStream&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BufferedWriter bw &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newBufferedWriter&lt;/span>(path);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もちろんOpenOptionの指定もできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ファイルがない場合は作成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>StandardOpenOption option &lt;span style="color:#f92672">=&lt;/span> StandardOpenOption.&lt;span style="color:#a6e22e">CREATE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>InputStream is &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">newInputStream&lt;/span>(path, option);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>どうでしたか。同じ機能をするだけならあまり使いたくなるメリットはないように見えるかもしれませんが、実際使ってみると、ENUMによるオプション指定でやりたいことが明確となって、コードの量も減らすことができる便利なクラスを提供するのがNIOだと思います。特にFileはそのまま使うとしても、Filesのメソッドは便利かつ強力なので、皆さんにぜひお勧めしたいものです。&lt;/p>
&lt;p>他にもFilesクラスには双方通信ができるというChannelクラスを提供するメソッドや、ファイルの属性、シンボリックリンクを取得したり指定したPathがディレクトリかを確認したり、二つのPathが同じファイルかをチェックするなど便利なメソッドが多いので、ぜひ使ってみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Nullチェックの地獄から脱出したい</title><link>https://retheviper.github.io/posts/java-optional/</link><pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-optional/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Nullチェックの地獄から脱出したい" />&lt;p>Javaでアプリケーションを組みながら最も遭遇率の高い例外が何かとしたら、それはNullPointerException(NPE)でしょう。初めてプログラミングを接する人に取っては「空白」と「Null」がどう違うのかを理解することもかなり難しいことではないのかと思いますが、Nullを理解できたとしても予想してなかったところで出てくるNPEで苦労する場合は決して少なくないと思います。ある意味、Javaでのアプリケーション開発はNPEとの戦いであるといっても過言ではないのではないでしょうか。&lt;/p>
&lt;p>なので今回は、NPEに対処するための方法を紹介します。Nullをチェックし、安全なコードを書く方法を探してみましょう。&lt;/p>
&lt;h2 id="nullチェックで十分か">Nullチェックで十分か？
&lt;/h2>&lt;p>とある学生の名前を取得するメソッドがあるとしましょう。データオブジェクトを引数として渡すと、そこから順番に学校、学年、組、学生の情報を取得して最後に学生の名前をStringとして返却するようなものです。これをコードで表現したら、例えば以下のように表現できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> School school &lt;span style="color:#f92672">=&lt;/span> data.&lt;span style="color:#a6e22e">getSchool&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Grade grade &lt;span style="color:#f92672">=&lt;/span> school.&lt;span style="color:#a6e22e">getGrade&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassName className &lt;span style="color:#f92672">=&lt;/span> grade.&lt;span style="color:#a6e22e">getClassName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> className.&lt;span style="color:#a6e22e">getStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> student.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをより簡潔なコードで表現するとしたら、以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> data.&lt;span style="color:#a6e22e">getSchool&lt;/span>().&lt;span style="color:#a6e22e">getGrade&lt;/span>().&lt;span style="color:#a6e22e">getClassName&lt;/span>().&lt;span style="color:#a6e22e">getStudent&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このメソッドが意図通りに作動するとしたら、シグネチャーとコードだけで意図と結果が明確なものとなるはずです。しかし、皆さんにもわかるように、このコードにはいつどこでも例外が発生する可能性があります。&lt;/p>
&lt;p>学生の名前フィールドがNullだとしたら？いや、そもそも学生が、もしくは組が、学年が、学校がNullだったら？引数がNullだとしたら？どれもNPEになりうる可能性があるので、極めて危険なコードとなっています。&lt;/p>
&lt;p>ここでまず考えられる対策は、事前にNullチェックの処理を入れNullでない場合にだけ次の処理に移行するようなコードを書くことでしょう。そしてNullだった場合にまた適切な処理(もしくはデフォルト値)を書くことで意図した通りに動かすことができます。&lt;/p>
&lt;p>では、上のコードにNullチェックの処理を入れ、をNull Safeなコードに変えてみましょう。例えば以下のように変えることができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (data &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> School school &lt;span style="color:#f92672">=&lt;/span> data.&lt;span style="color:#a6e22e">getSchool&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (school &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Grade grade &lt;span style="color:#f92672">=&lt;/span> school.&lt;span style="color:#a6e22e">getGrade&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (grade &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassRoom classRoom &lt;span style="color:#f92672">=&lt;/span> grade.&lt;span style="color:#a6e22e">getClassRoom&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (classRoom &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> classRoom.&lt;span style="color:#a6e22e">getStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (student &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String studentName &lt;span style="color:#f92672">=&lt;/span> student.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (studentName &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> studentName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のコードはネストしすぎて、極めて読みづらいコードとなっています。なのでもし一つの項目でもNullチェックが抜けているとしてもわからなくなります。また、コードを直すこともかなり困難になります。メソッドの目的はあくまで、「学生の名前が知りたい」というシンプルな要求に応えるためのものだったのですが、もはやNullチェックが入りすぎてなんのためのロジックなのかわかりづらいですね。&lt;/p>
&lt;p>ネストしている処理を避けるためif文をバラバラにしても結果はあまり変わりません。以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (data &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> School school &lt;span style="color:#f92672">=&lt;/span> data.&lt;span style="color:#a6e22e">getSchool&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (school &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Grade grade &lt;span style="color:#f92672">=&lt;/span> school.&lt;span style="color:#a6e22e">getGrade&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (grade &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassRoom classRoom &lt;span style="color:#f92672">=&lt;/span> grade.&lt;span style="color:#a6e22e">getClassRoom&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (classRoom &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> classRoom.&lt;span style="color:#a6e22e">getStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (student &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String studentName &lt;span style="color:#f92672">=&lt;/span> student.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (studentName &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// Default value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> studentName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>if文のネストを無くして読みやすくしてみようとしました。でも、このやり方だとむしろreturnが多すぎてこれはこれであまりよくない処理になっています。&lt;/p>
&lt;p>このようなコードはどう直したらいいのか？という時に、使えるAPIをJavaでは用意しています。今回の主題であるOptionalです。&lt;/p>
&lt;h2 id="optionalを導入する">Optionalを導入する
&lt;/h2>&lt;p>現代の言語はこのNullによって起こり得る問題を最初からブロックするため最初からNullを代入することを許さなかったり、Nullになりえるオブジェクトを扱えるAPIを提供したりするようです。例えばKotlinやSwiftではNullableやOptionalを制約の一つとして使っているようで(触ってみたことがないのでこうとしかいえませんが)、Pythonの場合もUnionやOptionaと言ったAPIが用意されているようです。そしてJavaもそう言ったトレンドに答えるべく、Java 1.8でOptionalをAPIとして導入しています。&lt;/p>
&lt;p>Optionalは、Nullになる可能性のあるオブジェクトに対しての新しい(といってもJava 1.8で導入されたのでもうそんなに新くもないですが)方法です。基本的には関数型言語から影響を受けて作られているらしいですね。&lt;/p>
&lt;p>私自身は関数型言語に詳しくないのですが、確かにこのOptionalの使い方をみるとLambda同様、元のJavaの思想とはかなり違うもののような気がします。なぜなら、オブジェクトのNullチェックを比較演算してその後の処理を決めるわけではなく、メソッドの連鎖で決めていくような形になっていて、書き方がかなり異質的だからです。&lt;/p>
&lt;p>なら、そんな異質的なAPIをなぜ使うのか？それはOptionalがどんなものであり、どんな特徴を持っているかをまず見て判断することにしましょう。&lt;/p>
&lt;h3 id="使い方が簡単">使い方が簡単
&lt;/h3>&lt;p>map()やfilter()などCollection&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>やStream&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>と似たような機能をするメソッドがあり、さらに引数としてLambdaを使えるので、CollectionやStreamに慣れていると簡単に適応できます。&lt;/p>
&lt;p>Optionalを効率的に使うためにはメソッドチェーニング&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>やLambdaにまずなれる必要があるので、まずはjava.util.functionsになれるとしましょう。&lt;a class="link" href="../java-functional-interface" >以前のポスト&lt;/a>を参考にしてください。&lt;/p>
&lt;h3 id="見ただけでわかる">見ただけでわかる
&lt;/h3>&lt;p>Optionalはオブジェクトを包み、そのオブジェクトがNullである場合の処理のため作られたAPIです。なのでOptionalで包まれているオブジェクトがあると、そのオブジェクトはNullになる可能性があることを明らかにしているということです。なので戻り値だけでNullになる可能性があるコードを見分けることができるようになります。&lt;/p>
&lt;h3 id="可読性が上がる">可読性が上がる
&lt;/h3>&lt;p>Nullチェックという本来の目的に充実しながらも、コードが簡潔になるので読みやすいコードになります。取得したいオブジェクトがネストしている場合もOptionalで対応できます。最初のオブジェクトのNullチェックをして、さらにネストしているオブジェクトをNullチェックしていくような形です。&lt;/p>
&lt;h2 id="optionalでnullチェックを変えてみましょう">OptionalでNullチェックを変えてみましょう
&lt;/h2>&lt;p>では、実際のコードを持ってOptionalでのNullチェックがどう可能になるのかをコードを持ってみてみましょう。さっきのメソッドは以下のように変えることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudentName&lt;/span>(Data data) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Data::getSchool)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(School::getGrade)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Grade::getClassRoom)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Class::getStudent)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Student::getName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">orElse&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Optionalが初めての方にはどんなことをしているか一見わからなくなるのではと思いますが、それでもコードの量が減り、可読性がよくなったのはわかるでしょう。もちろん、Nullチェックが省略されているわけでもありません。このように簡潔で分かり安く、安全なNullチェックを可能にするのがOptionalです。&lt;/p>
&lt;h2 id="optionalのメソッド">Optionalのメソッド
&lt;/h2>&lt;p>OptionalはSingletonの&lt;code>java.util.Optional&amp;lt;T&amp;gt;&lt;/code>をインポートしてオブジェクトを包み、包まれたオブジェクトがNullか否かによってどんな挙動をするかのメソッドを持っています。これからそれらのメソッドを一つづつ見ていきましょう。&lt;/p>
&lt;h3 id="empty">empty()
&lt;/h3>&lt;p>空のOptionalを作成します。空のOptionalはその名の通り空で、中にラップされたオブジェクトがNullの状態です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> emtpyName &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">empty&lt;/span>(); &lt;span style="color:#75715e">// StringはNull&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="get">get()
&lt;/h3>&lt;p>Optionalでラップされたオブジェクトを取得する時に使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optinal&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(name.&lt;span style="color:#a6e22e">get&lt;/span>()); &lt;span style="color:#75715e">// Sato&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="oft-value">of(T value)
&lt;/h3>&lt;p>引数として渡したオブジェクトを包むOptionalを生成します。ただ、引数のオブジェクトがNullの場合はget()の結果もNullになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optinal&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name.&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Null&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ofnullablet-value">ofNullable(T value)
&lt;/h3>&lt;p>引数として渡したオブジェクトを包むOptionalを生成するということではof()と同じですが、引数のオブジェクトがNullだった場合はempty()で生成されたOptionalを返却します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optinal&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name.&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Optional&amp;lt;String&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="mapfunction-super-t--extends-u-mapper">map(Function&amp;lt;? super T, ? extends U&amp;gt; mapper)
&lt;/h3>&lt;p>CollectionやStreamのmap()と似たようなメソッドです。複雑にネストされているフィールドを安全にチェックする時に使います。mapで取り出したオブジェクトは自動的にOptionalでラップされたクラスとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Student sato &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Student(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(sato);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String nameOfSato &lt;span style="color:#f92672">=&lt;/span> student.&lt;span style="color:#a6e22e">map&lt;/span>(Student::getName).&lt;span style="color:#a6e22e">get&lt;/span>(); &lt;span style="color:#75715e">// Optional&amp;lt;Student&amp;gt; -&amp;gt; Optional&amp;lt;String&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで使われている::での表現式はMethod Referenceといい、ターゲットレファレンスとメソッドを書くだけで一般的なLambdaと同じ効果を期待できる書き方です。Lambdaで既存のコードをより簡潔に書くことができるようになりましたが、さらに引数の変数名を省略できるようにしたものですね。変数名を書かなくても指している対象が明確でメソッドも一つだけを呼ぶ場合に使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数を標準出力するLambdaの一般的な書き方&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Consumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> print &lt;span style="color:#f92672">=&lt;/span> name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Method Referenceに変えた形&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Consumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> print &lt;span style="color:#f92672">=&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>::print;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスの生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> String::&lt;span style="color:#66d9ef">new&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="filterpredicate-super-t-predicate">filter(Predicate&amp;lt;? super T&amp;gt; predicate)
&lt;/h3>&lt;p>filter()もまたCollectionやStreamのメソッドに慣れているなら簡単に使えるメソッドの一つです。条件と一致する場合(PredicateによりTrueとなる)にだけ値を返却します。単にNullかどうかの判定だけでなく、何かの処理を付け加えたい時に使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 伝統的なパターン&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getSato&lt;/span>(Student student) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#f92672">=&lt;/span> student.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (name &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> name.&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// filter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getSato&lt;/span>(Student student) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">getName&lt;/span>().&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(Student::getName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Optionalの要素は一つしかないのでfilterで指定した条件の結果がfalseの時は以後のメソッドが無視されます。&lt;/p>
&lt;h3 id="ispresent">isPresent()
&lt;/h3>&lt;p>OptionalでラップしたクラスがNullであるかを判定するためのメソッド。Nullでない場合はTrue、Nullの場合はFalseとなるシンプルなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> studentName &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>studentName.&lt;span style="color:#a6e22e">isPresent&lt;/span>(); &lt;span style="color:#75715e">// true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ifpresentconsumer-super-t-consumer">ifPresent(Consumer&amp;lt;? super T&amp;gt; consumer)
&lt;/h3>&lt;p>ラップされたオブジェクトがNullでない場合にだけ実行するメソッドを記述します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name.&lt;span style="color:#a6e22e">ifPresent&lt;/span>(n &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(n));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="orelset-other">orElse(T other)
&lt;/h3>&lt;p>引数として渡したオブジェクトがNullの場合にデフォルト値を使います。このメソッドを使った場合はget()は記述しなくてもよくなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String defaultName &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Sato&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> name.&lt;span style="color:#a6e22e">orElse&lt;/span>(defaultName); &lt;span style="color:#75715e">// student.getName()がNullの場合defaultNameになる&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="orelsegetsupplier-extends-t-other">orElseGet(Supplier&amp;lt;? extends T&amp;gt; other)
&lt;/h3>&lt;p>引数として渡したオブジェクトがNullの場合にデフォルト値として指定したLambdaを実行し、その結果を返却します。このメソッドを使った場合はget()は記述しなくてもよくなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> name.&lt;span style="color:#a6e22e">orElseGet&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> student.&lt;span style="color:#a6e22e">getNumber&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;の名前がありません&amp;#34;&lt;/span>); &lt;span style="color:#75715e">// student.getName()がNullの場合Lambdaを実行する&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="orelsethrowsupplier-extends-x-exceptionsupplier">orElseThrow(Supplier&amp;lt;? extends X&amp;gt; exceptionSupplier)
&lt;/h3>&lt;p>引数として渡したオブジェクトがNullの場合に例外を投げます。このメソッドを使った場合はget()は記述しなくてもよくなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> name.&lt;span style="color:#a6e22e">orElseThrow&lt;/span>((BusinessException::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="optionalで注意すべきこと">Optionalで注意すべきこと
&lt;/h2>&lt;p>Nullチェックで便利で安全なOptionalですが、全ての状況でNullに関する処理を全部Optionalに変える必要はありません。Optionalの導入を検討する時、注意すべきことについて説明します。&lt;/p>
&lt;h3 id="性能を意識する">性能を意識する
&lt;/h3>&lt;p>すでに気づいている方もいらっしゃると思いますが、Optionalはオブジェクトをラップするものなので必然的に性能の低下と繋がります。なのでNullチェックがいる場面では一旦Optionalを使う、ということはあまり良い考えではありません。簡単なNullチェックはOptionalでなくてもできますし、早いです。&lt;/p>
&lt;p>Optionalを使ってオブジェクトがNullの場合の処理を書く際もorElse()よりはorElseGet()を使った方が良いです。orElse()はNullではない場合も必ず実行されるからです。それに対してorElseGet()の場合はLazy&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>なメソッドなのでより良い性能を期待できます。&lt;/p>
&lt;p>ただ、場合によっては(staticなデフォルト値をフィールドとして持っているなど)、orElse()の方を使った方が良いケースもあるのでその場の判断が重要です。返却したいデフォルト値のインスタンスがどこで作成されるかの時点をよく把握しましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例(Nullではない場合捨てられるインスタンス)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Student &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student).&lt;span style="color:#a6e22e">orElse&lt;/span>(Student::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Student &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student).&lt;span style="color:#a6e22e">orElseGet&lt;/span>(Student::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、戻り値としてNullもしくは決まったデフォルト値を期待する場合はOptionalよりもNullチェックの方が良い場合もあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例(常に同じデフォルト値が決まっている場合)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Student defaultStudent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Student &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(student).&lt;span style="color:#a6e22e">orElse&lt;/span>(defaultStudent);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Student &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> student &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> student : defaultStudent;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ispresentとgetの組み合わせはng">isPresent()とget()の組み合わせはNG
&lt;/h3>&lt;p>isPresent()でオブジェクトがNullかを確認したあと、get()でオブジェクトを取得するようなコードは結局普通のNullチェックと変わりません。デフォルト値を使いたい場合はorElseGet()を、例外としたい場合はorElseThrow()を活用しましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (student.&lt;span style="color:#a6e22e">isPresent&lt;/span>()) { &lt;span style="color:#75715e">// (value != null)の方が良い&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> student.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> NullPointerException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getStudent&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> student.&lt;span style="color:#a6e22e">orElseThrow&lt;/span>(NullPointerException::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、オブジェクトがNullでない場合にだけ処理を行いたい場合なら、ifPresent()を使いましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">adjustScore&lt;/span>(String name, &lt;span style="color:#66d9ef">int&lt;/span> score) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (student.&lt;span style="color:#a6e22e">isPresent&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">setScore&lt;/span>(score);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">adjustScore&lt;/span>(String name, &lt;span style="color:#66d9ef">int&lt;/span> score) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> student &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">getStudent&lt;/span>(name));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student.&lt;span style="color:#a6e22e">ifPresent&lt;/span>(s &lt;span style="color:#f92672">-&amp;gt;&lt;/span> s.&lt;span style="color:#a6e22e">setScore&lt;/span>(score));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="フィールドでは使わない">フィールドでは使わない
&lt;/h3>&lt;p>そもそもOptionalはフィールドとして使われる場合を想定していないようです。なぜなら、OptionalはSerializableを継承してないからです。なのでDTOなどでフィールドとしてOptionalを使うとNullチェック以前に問題が起こる可能性があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Serializable{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name; &lt;span style="color:#75715e">// 直列化できない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Serializable{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name; &lt;span style="color:#75715e">// 直列化できる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="引数では使わない">引数では使わない
&lt;/h3>&lt;p>メソッドやコンストラクターの引数としてOptionalを使うと、それを呼び出すたびに引数としてOptionalを生成する必要があります。また、内部的にOptionalでNullチェックのロジックが入るのでコードも複雑になりますね。こういう場合、内部でどんな処理が行われ、期待通りの処理になっているかわからなくなるので不便です。&lt;/p>
&lt;p>なのでメソッドやコンストラクターの引数は普通のオブジェクトにして、Nullチェックをした方が使いやすく意図した処理を期待できるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> name) { &lt;span style="color:#75715e">// インスタンスを作成するたびOptionalも必要となる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name.&lt;span style="color:#a6e22e">orElseThrow&lt;/span>(NullPointerException::&lt;span style="color:#66d9ef">new&lt;/span>); &lt;span style="color:#75715e">// OptionalでNullチェックおよび代入が必要&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name; &lt;span style="color:#75715e">// 期待通りの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="collectionの中では使わない">Collectionの中では使わない
&lt;/h3>&lt;p>Collectionの中の要素は無理やり入れない限りNullが入らない場合もあれば、Nullチェックに対応するメソッドを含めている場合もあります。そして中の要素は複数になるので、Optionalを要素として使う場合は性能の低下が必然的に起こります。なので要素ではなるべくOptionalを使わないようにしましょう。また、フィールドや引数と同じく要素を追加したり取得する場合に毎回Optionalを経由しなければならないという不便さがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> names &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>names.&lt;span style="color:#a6e22e">add&lt;/span>(Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(name1)); &lt;span style="color:#75715e">// 要素を追加するたびラップが必要&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> names &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>names.&lt;span style="color:#a6e22e">add&lt;/span>(name1);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="collectionはcollectionで">CollectionはCollectionで
&lt;/h3>&lt;p>Collectionが戻り値のメソッドの場合、NullだとCollections.emptyList()やCollections.emptyMap()などで空のCollectionを返却した方が良い場合が多いです。Collectionは&lt;/p>
&lt;p>また、Spring Data JPAを使っている場合はそもそも戻り値がNullだと、自動的に空のListを生成してくれるので尚更Optionalを使う必要がありません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">listStudent&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> students &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">listStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">ofNullable&lt;/span>(students);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">listStudent&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Student&lt;span style="color:#f92672">&amp;gt;&lt;/span> students &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">repository&lt;/span>.&lt;span style="color:#a6e22e">listStudent&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> students &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> students : Collections.&lt;span style="color:#a6e22e">emptyList&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="intlongdoubleはoptionalでラップしない">int/long/doubleはOptionalでラップしない
&lt;/h3>&lt;p>Optionalのバリエーションでは、一部プリミティブ型のためのクラスも用意されています。int/long/doubleの場合がそうです。これらはOptionalInt、OptionalLong、OptionalDoubleで包む方が良いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// よくない例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(100);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> countNum &lt;span style="color:#f92672">=&lt;/span> count.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 良い例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OptionalInt count &lt;span style="color:#f92672">=&lt;/span> OptionalInt.&lt;span style="color:#a6e22e">of&lt;/span>(100);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> countNum &lt;span style="color:#f92672">=&lt;/span> count.&lt;span style="color:#a6e22e">getAsInt&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今は使われているJavaのバージョンが古くても、公式サポートなどの理由でJava 1.8以上にバージョンアップするところも多いと聞きます。ならばJavaプログラマーとして、未来に備えJava 1.8の重要なAPIに慣れて置いた方が良いでしょう。そういう意味でFunctionやOptionalは皆さんにもぜひ使ってみて欲しいAPIでもあります。そもそもJavaがこんなにメジャーな言語になり得たのは、開発しやすいというメリットがあったからなので、さらに開発が楽になるAPIは覚えておいて損はないでしょう。&lt;/p>
&lt;p>Javaもかなり古い言語ですが、最近は急激なバージョンアップと共に関数型言語など最近のトレンドを反映して変化しているところもあります。今は性能も書きやすさも優秀な言語が溢れ出している時代ですが、こんなJavaの変化がどこまで続き、いつまで生き残ることができるか気になります。JVMは依然として強力ですが、LLVMなどより性能が優れた技術も続々と登場していますしね。でも、Javaの変化に適応し、大体のAPIを使うことができたら、他の言語にも適応しやすくなるのではと思います。そういう理由ででも、みなさん、Java 1.8以後のAPIは注目してください。では！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>List, Set, Mapなど複数の要素を持つオブジェクトのことを指します。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>ファイルの入出力で使われるInputStreamやOutputStreamではなく、Collectionの要素を一つずつ巡回しながら特定のメソッド(主にLambda)を実行できるようにしてくれるJava 1.8のAPIです。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>戻り値が自分自身のため、何度もメソッドをつなげて書くことのできる仕組み。Builderパターンが代表的なメソッドチェーニングの例です。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>プログラミングでLazyということは、とある処理が常にではなく、呼ばれた際に初めて実行される仕組みのことを意味します。必要な時だけ処理が始まるので不要な処理が減ります。&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>外部設定ファイルを扱うクラスを作る</title><link>https://retheviper.github.io/posts/java-yaml-for-configuration/</link><pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-yaml-for-configuration/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post 外部設定ファイルを扱うクラスを作る" />&lt;p>アプリケーションを作る場合、考慮しなければならないことの一つは「設定ファイルを作る」ことです。設定値のデータがアプリケーションの内部にあると、ディコンパイルしない限りそれを変えられる方法がなくからですね。なので一般的にはアプリケーションの柔軟性のためにも動的に変える必要のある設定値はアプリケーションの外に別途のファイルとして置く場合が多いです。ゲームでいえばセーブファイルみたいなものですね。&lt;/p>
&lt;p>外部のファイルを読み込むことに関してはすでに様々な方法があるとは思いますが、今回は自分で使っている方法を共有します。簡単に、外部設定ファイルは&lt;a class="link" href="https://ja.wikipedia.org/wiki/YAML" target="_blank" rel="noopener"
>YAML&lt;/a>で記載してプログラムの起動時に読み込んでシングルトンクラスのフィールドとして持す方法です。I/Oを一回だけにできて、どこからも参照できるというメリットがあります。設定ファイルのフォーマットとしてYAMLを選定したのは、書きやすく読みやすいというメリットもあって、自分が主に扱っているSpringで使っているためでもあります。JSONでも問題はないですが、項目が増えるほどJSONは読みづらくなるので…&lt;/p>
&lt;p>とにかく、準備するものはYAMLを読み込むためのライブラリーです。ここでは&lt;a class="link" href="https://bitbucket.org/asomov/snakeyaml/src/default" target="_blank" rel="noopener"
>SnakeYaml&lt;/a>を使います。ファイルを読み込んでオブジェクト化するだけなので他のライブラリーを使っても構いません。&lt;/p>
&lt;p>では、まず以下のようなYAMLファイルがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Development&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;develop&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">use_local_storage&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Debugging&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;debug&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">version&lt;/span>: &lt;span style="color:#ae81ff">11&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">use_local_storage&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DevelopmentとDebuggingという二つのケースでそれぞれ違う値を使いたい、というシナリオで簡単に書いてみました。これを利用するコードは以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 共用の設定情報クラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Settings&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// シングルトンクラスなので自分のインスタンスを持っている&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Settings UNIQUE_INSTANCE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Settings();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 設定ファイルから読み込んだ値を一次的に入れておくためのフィールド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> SETTINGS_FROM_FILE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 設定ファイル名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String SETTINGS_FILENAME &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;application-settings.yml&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Developmentの設定情報が入るMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Getter&lt;/span>(lazy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> developmentSettings &lt;span style="color:#f92672">=&lt;/span> setDevelopmentSettings();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Debuggingの設定が入るMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Getter&lt;/span>(lazy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> debuggingSettings &lt;span style="color:#f92672">=&lt;/span> setDebuggingSettings();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// イニシャライザーブロックで最初からファイルを読み込む処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルを指定して読み込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassLoader classloader &lt;span style="color:#f92672">=&lt;/span> UNIQUE_INSTANCE.&lt;span style="color:#a6e22e">getClassLoader&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> URL resource &lt;span style="color:#f92672">=&lt;/span> classloader.&lt;span style="color:#a6e22e">getResource&lt;/span>(SETTINGS_FILENAME);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> (InputStreamReader reader &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> InputStramReader(resource.&lt;span style="color:#a6e22e">openStream&lt;/span>())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 読み込んだYAMLファイルをパースしてMapに値を取り込む&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Yaml yaml &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Yaml();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> importedMap &lt;span style="color:#f92672">=&lt;/span> autoCast(yaml.&lt;span style="color:#a6e22e">load&lt;/span>(reader));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 読み込んだ値をフィールドのMapに移す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Map.&lt;span style="color:#a6e22e">Entry&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> entry : importedMap.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SETTINGS_FROM_FILE.&lt;span style="color:#a6e22e">put&lt;/span>(entry.&lt;span style="color:#a6e22e">getKey&lt;/span>(), entry.&lt;span style="color:#a6e22e">getValue&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IOException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 例外処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// コンストラクターは外部からアクセスできない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">Settings&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Lazy Getterで要請が入った時点でインスタンスを作るためのメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">setDevelopmentSettings&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableMap&lt;/span>(SETTINGS_FROM_FILE.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Development&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Lazy Getterで要請が入った時点でインスタンスを作るためのメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">setDebuggingSettings&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">unmodifiableMap&lt;/span>(SETTINGS_FROM_FILE.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Debugging&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 外部からインスタンスを取得するためのGetter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Settings &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> UNIQUE_INSTANCE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オブジェクトのキャストをより簡単にするためのメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@SuppressWarnings&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unchecked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> T &lt;span style="color:#a6e22e">autoCast&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> Object object) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (T)object;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここではLazy Getterを使ってDevelopmentとDebuggingの設定のフィールドが、get要請が入った時点でインスタンスが作られるようにしています。こうしている理由は、イニシャライザーブロックでファイルを読み込んだ後から個別フィールドに値を入れたい + フィールドはprivate finalにしたい + Settingsクラスはシングルトンとしてプログラムの起動時にインスタンスが生成されるようにしたいからです。Lazy Getterを設定しておくとprivate finalを維持しつつ、フィールドの初期化は後に担保できて、一度インスタンスが生成されるとキャッシュとして残りますので便利です。もしこうでなく、コンストラクターやフィールドで初期化しようとするとその時点がファイルを読み込む前となってしまうので注意しましょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回紹介したコードを使うと、設定クラスはシングルトンクラスとしてアプリケーションの起動時にインスタンスが生成され、その時ファイルを読み込んでMapとしてメモリー上に載せ、どこからでも固定された値をGetterで取得できます。もしYAMLの設定がより深くネストしたり、項目が増えたり、ファイル名が変わったりする場合はMapとフィールドを調整するだけで簡単に変更ができますね。&lt;/p>
&lt;p>単純に動くだけでなく、維持補修が簡単で無駄のないコードを書くことこそが重要なので、何か頻繁に変わるデータを扱うためにはこう言った仕組みを(自分が紹介したものと同じではなくても)考える必要があるのでは、と思います。これからもどんなものが良いコードなのかを常に意識しないと、ですね。&lt;/p></description></item><item><title>Javaの色々なコーディングスキル</title><link>https://retheviper.github.io/posts/java-skills/</link><pubDate>Sun, 17 Nov 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-skills/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Javaの色々なコーディングスキル" />&lt;p>今回のポストでは、スキルといっても大したものはないですが、自分がコードを書きながらこれは便利だな(もしくは単に格好いいな)と思ったコーディングスキル的なものをいくつか集めました。&lt;/p>
&lt;h2 id="streamでlistの変換">StreamでListの変換
&lt;/h2>&lt;p>以下のような二つのクラスがあるとしましょう。コードの量を減らすためLombokを使っていると仮定します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Item&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Setter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Product&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>業務的にこの二つのクラスのフィールドである&lt;code>value&lt;/code>が同一なものと仮定します。そうすると、Itemクラスから&lt;code>value&lt;/code>を取得してProductクラスに取り込むことが必要な状況もあるでしょう。このような場合、オブジェクトがそれぞれ一つだけだとあまり問題にならないですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Product &lt;span style="color:#a6e22e">setProductValueFromItemValue&lt;/span>(Item item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Product product &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Product();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> product.&lt;span style="color:#a6e22e">setValue&lt;/span>(item.&lt;span style="color:#a6e22e">getValue&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> product;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>複数の項目をマッピングする必要があるなら、&lt;a class="link" href="http://modelmapper.org/" target="_blank" rel="noopener"
>ModelMapper&lt;/a>のようなライブラリを使う方法もあります。同じような名前のGetter/Setterがあると自動でマッピングしてくれるので便利ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Product &lt;span style="color:#a6e22e">setProductValueFromItemValue&lt;/span>(Item item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ModelMapper mapper &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ModelMapper();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Product product &lt;span style="color:#f92672">=&lt;/span> mapper.&lt;span style="color:#a6e22e">map&lt;/span>(item, Product.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> product;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これらがListやMapに入っているとどうするのでしょうか。普通にFor文のなかで同じくマッピングをさせる方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">itemListToProductList&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> itemList) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> productList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Item item : itemList) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> productList.&lt;span style="color:#a6e22e">add&lt;/span>(mapper.&lt;span style="color:#a6e22e">map&lt;/span>(item, Product.&lt;span style="color:#a6e22e">class&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> productList;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをStreamとLambdaを利用して、より簡単なコードにすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">itemListToProductList&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> itemList) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Product&lt;span style="color:#f92672">&amp;gt;&lt;/span> productList &lt;span style="color:#f92672">=&lt;/span> itemList.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">map&lt;/span>(item &lt;span style="color:#f92672">-&amp;gt;&lt;/span> mapper.&lt;span style="color:#a6e22e">map&lt;/span>(item, Product.&lt;span style="color:#a6e22e">class&lt;/span>)).&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> productList;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>やっていることはFor文とあまり変わりません。元のリストから要素を一つづつ取り出し、マッピングして新しいオブジェクトを作る。そしてそれを取り集めて新しいListを生成していますね。ただ、&lt;code>map()&lt;/code>の引数はLambdaなのでただのマッピングだけでなく、より複雑な処理を入れることもできます。同じことをするとしてもより簡単で短いコードが完成されます。&lt;/p>
&lt;h2 id="collectionでimmutable">CollectionでImmutable
&lt;/h2>&lt;p>Immutable、すなわち不変クラスについては&lt;a class="link" href="../java-thoughts-of-immutable" >前回のポスト&lt;/a>でも扱いました。今回はCollectionを使って、そのクラスのListやMapもImmutableにする方法について述べます。下のコードは、Listの例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">returnAsUnmodifiableList&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collentions.&lt;span style="color:#a6e22e">unmodifiableList&lt;/span>(list);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じ方法で、&lt;code>Collentions.unmodifiableMap()&lt;/code>でラッピングするとMapもImmutableにできます。こう変換されたListやMapは変更が不可能になるため設定系などのデータを持っている場合に有効活用できます。ただ、Nullが入るとNullPointerExceptionが発生するため注意しましょう。包みたいListがNullになる可能性がある場合は&lt;code>Collection.emptyList()&lt;/code>を代わりに入れることができます。&lt;/p>
&lt;p>逆に、ImmutableになったListやMapを変更したい場合は新しいオブジェクトに複製します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">returnAsModifiableList&lt;/span>(List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Item&lt;span style="color:#f92672">&amp;gt;&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(list);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうしてオブジェクトを複製してデータを変更する場合、元のImmutableなListにも反映されるので注意する必要があります。&lt;/p>
&lt;h2 id="カスタムクラスをiterableにする">カスタムクラスをIterableにする
&lt;/h2>&lt;p>とあるクラスの中に、子要素のクラスがListとして入っているとします。例えば、以下のようなイメージです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Container&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> baggages &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>場合によっては、このクラスの中の子要素を全部取り出してFor文を書きたい場合もあるはずです。そういう場合は普通、こんな形で使うのではないかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printBaggageNames&lt;/span>(Container container) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> baggages &lt;span style="color:#f92672">=&lt;/span> container.&lt;span style="color:#a6e22e">getBaggages&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Baggage baggage : baggages) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(baggage.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>でも、このクラス自体を拡張For文のなかで使えるとしたら、より便利になりますね。つまり、以下のように使えるとしたいということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printBaggageNames&lt;/span>(Container container) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Baggage baggage : container) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(baggage.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしこれができたら、Getterは要らなくなって、よりシンプルなコードがかけますね。また、Listそのものを取得させるわけではないので、Immutableにする必要もなくなります。&lt;/p>
&lt;p>これはIterableを使うことで具現化できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Container&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> baggages &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Iterator&lt;span style="color:#f92672">&amp;lt;&lt;/span>Baggage&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">iterator&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> baggages.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうすることで簡単に、親クラスから子要素を拡張For文の中で使えるようになります。簡単ですね！&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>そこまで高級スキル的なものはなかったのですが、覚えておくとどこかで必ず役に立ちそうなスキルをいくつか集めてみました。これらは実際の仕事でも使っているものであって、とりあえず「動けばいい」レベルを超えて行きたい時に有効活用できるようなものではないかと思いました。こういう細かいところでのスキルの差が、プログラマーとしての実力に繋がるものではないでしょうか。そう思って、今後からも何かわかったらまたポストとして作成したいと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Enumを使いましょう</title><link>https://retheviper.github.io/posts/java-enum/</link><pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-enum/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Enumを使いましょう" />&lt;p>JavaのEnumは興味深いものです。読みやすく、同時に複数の値を持たせるということが魅力的です。なので複数のクラスで共通のコード値を扱う必要があったり、DBに連携する場合に使うと便利ですね。私も現在の仕事では積極的に活用しています。また、完全なクラスとして機能しているので単に定数のため使うだけでなく、処理を記述することも可能なので活用できる範囲はかなり広いのでは、と思います。&lt;/p>
&lt;p>なので今回はJavaのEnumの活用法やメリットについて、自分の経験と調べたことをまとめ紹介したいと思います。&lt;/p>
&lt;h2 id="読みやすい">読みやすい
&lt;/h2>&lt;p>コードが読みやすいということは、つまり維持補修に有利ということですね。個人的にはプログラミングの段階は「とにかく動く物を作る」→「共通(重複)処理をメソッドやクラスで分離する」→「他人がみてもわかりやすいコードにする」順に進むべきだと思います。そして全ての段階が最初の設計からできていればなおさらですね。&lt;/p>
&lt;p>テーブルにとあるコード値が項目として存在するとしましょう。DBの種類によってはその項目を&lt;code>boolean&lt;/code>にすることもできますが、&lt;code>char(1)&lt;/code>になる場合もあります。そしてこういった場合はそのコード値は二つの状態だけでなく、3つ以上の状態を持つ場合もありますね。サンプルとしてJava内での状態をStringとして持ち、DBには&lt;code>char(1)&lt;/code>として記録するとしましょう。そういう場合は以下のようなコードが必要となるはずです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Stringで記述されている状態をDBのコード値に変換するメソッドの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">toCodeValue&lt;/span>(String status) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (status.&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;TRUE&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このメソッドを使うコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// itemオブジェクトにステータスを指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setStatusTrue&lt;/span>(Item item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;TRUE&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ハードコーディングされた&lt;code>status&lt;/code>を定数かすることは可能です。定数は普通のクラス内でも持たせますね。しかし、そういう場合は定数がどのクラスで定義されているかをまず知る必要があります。とこで定数が定義されているかわからない場合は修正も難しくなるし、重複して同じ定数をそれぞれ違うクラスに作成することになる可能性もありますね。&lt;/p>
&lt;p>そして、このコードでは処理の結果を見る前まで状態がどうなっているか確認できなくなる可能性があるという欠点があります。もしどこかで指定された&lt;code>status&lt;/code>が&lt;code>TRUE&lt;/code>でも&lt;code>FALSE&lt;/code>でもない第三の文字列だったら？そういう場合は&lt;code>if&lt;/code>の分岐を増やすしかないでしょう。&lt;/p>
&lt;p>これをEnumを使うコードに変えてみましょう。コードは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> StatusEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TRUE(&lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FALSE(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Integer codeValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringEnum(Integer codeValue) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">codeValue&lt;/span> &lt;span style="color:#f92672">=&lt;/span> codeValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Integer &lt;span style="color:#a6e22e">getCodeValue&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> codeValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>定数名にそれぞれのコード値を設定し、フィールド・コンストラクタ・Getterを用意するだけです。構造からわかるように、このようなEnumクラスはLombokのアノテーションでも簡単に作ることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> StatusEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TRUE(&lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FALSE(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Integer codeValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作成したEnumを実際活用する場合のコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// itemオブジェクトにステータスを指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Item item &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Item();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(StatusEnum.&lt;span style="color:#a6e22e">TRUE&lt;/span>.&lt;span style="color:#a6e22e">getCodeValue&lt;/span>()); &lt;span style="color:#75715e">// &amp;#34;0&amp;#34;となる&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Enumを作成することで、入れたい値が明確になります。また、Enumは独立したクラスなのでパッケージを分けて保存することで管理がより簡単になります。あとでコード値が増える場合にもそちらのEnumを修正するだけで住みますね。また、Enum自体をフィールドとして宣言することも可能です。その場合は以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// フィールドにEnumがある例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Item {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> StatusEnum status;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>フィールドがEnumの場合は、値の指定がより簡単になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Item item &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Item();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(StatusEnum.&lt;span style="color:#a6e22e">TRUE&lt;/span>); &lt;span style="color:#75715e">// TRUEとして保存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コード値を抽出したいときのコード&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String itemCodeValue &lt;span style="color:#f92672">=&lt;/span> item.&lt;span style="color:#a6e22e">getStatus&lt;/span>().&lt;span style="color:#a6e22e">getCodeValue&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="複数の値を持つことが可能">複数の値を持つことが可能
&lt;/h2>&lt;p>そこまで読み易くはならないのでは？と思われる可能性もありますね。確かに、一つの定数につき値が一つだけの場合はそうかもしれません。しかし、Enumの良いところは、定数に複数の値を持たせることも可能ということです。&lt;/p>
&lt;p>例えば二つ以上のDBを使っていて、同じ項目を片方のテーブルは&lt;code>char(1)&lt;/code>、またの方は&lt;code>boolean&lt;/code>で管理しているとしましょう。Enumでは両方を一つの定数として管理することができます。それがどういうことか、以下のコードで確認してみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> MultiValueEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Y(&lt;span style="color:#e6db74">&amp;#34;0&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> N(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Integer charValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> booleanValue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コードを見ると簡単に理解できると思いますが、どちらのGetterを使うかによって同じ定数でも違うデータ型のコード値を返却します。これを実際のコードで使うとしたら、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBの項目がchar(1)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Item item &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Item();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(MultiValueEnum.&lt;span style="color:#a6e22e">Y&lt;/span>.&lt;span style="color:#a6e22e">getCharValue&lt;/span>()); &lt;span style="color:#75715e">// &amp;#34;0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBの項目がboolean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>item.&lt;span style="color:#a6e22e">setStatus&lt;/span>(MultiValueEnum.&lt;span style="color:#a6e22e">Y&lt;/span>.&lt;span style="color:#a6e22e">getBooleanValue&lt;/span>()); &lt;span style="color:#75715e">// true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>複数の値を指定可能ということは、配列やListでも可能ということではないか？と思う方もいるかもしれません。結論からいうとYesです。自分も最初からわかっていたわけではありませんが、調べてみると&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener"
>Stream&lt;/a>を使うと値としてListを持たせ、さらにそのListの中の値との比較もできるようです。この場合のコードは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> ListValueEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Y(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Good&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;Excellent&amp;#34;&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> N(Arrays.&lt;span style="color:#a6e22e">asList&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Bad&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Unavailable&amp;#34;&lt;/span>)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL(&lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> codeValueList;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Listの中に値があるかチェック&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">hasCodeValue&lt;/span>(String codeValue){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> codeValueList.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">anyMatch&lt;/span>(code &lt;span style="color:#f92672">-&amp;gt;&lt;/span> code.&lt;span style="color:#a6e22e">equals&lt;/span>(codeValue));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Listの中の値と一致する場合、その定数を返す(&amp;#34;Good&amp;#34;ならListValueEnum.Yを返却)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ListValueEnum &lt;span style="color:#a6e22e">findByValue&lt;/span>(String codeValue) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Arrays.&lt;span style="color:#a6e22e">stream&lt;/span>(ListValueEnum.&lt;span style="color:#a6e22e">getCodeValueList&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(listValueEnum &lt;span style="color:#f92672">-&amp;gt;&lt;/span> listValueEnum.&lt;span style="color:#a6e22e">hasCodeValue&lt;/span>(codeValue))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">findAny&lt;/span>().&lt;span style="color:#a6e22e">orElse&lt;/span>(NULL); &lt;span style="color:#75715e">// 当てはまる値がない場合はNullを返す・&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まだStreamは一部でしか使ってみたことがないのでこういう活用方法は考えてみたことがないですが、どこかで使えそうなコードです。&lt;/p>
&lt;p>また、フィールドとして使うEnumに特に値がない場合は以下のようなアノテーションを使うことも可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Item&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// StringEnum.YESのまま使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Enumerated&lt;/span>(EnumType.&lt;span style="color:#a6e22e">STRING&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> StringEnum codeValue1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="classらしき活用">Classらしき活用
&lt;/h2>&lt;p>Enumはクラスなので、もちろん処理を持たせる方法もあります。処理を持たせるというのは難しく感じるかもしれませんが、処理をメソッドと思えば良いだけの話です。メソッドのフィールド化する方法についてはLambdaに関する&lt;a class="link" href="../java-functional-interface" >以前のポスト&lt;/a>を参照してください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> CalculateEnum {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Lambdaでフィールドを指定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TYPE_1(num &lt;span style="color:#f92672">-&amp;gt;&lt;/span> num),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TYPE_2(num &lt;span style="color:#f92672">-&amp;gt;&lt;/span> num &lt;span style="color:#f92672">+&lt;/span> 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Function&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> calculate;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 値を入れると処理結果が帰ってくる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pulbic Integer &lt;span style="color:#a6e22e">calculate&lt;/span>(Integer number) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> calculate.&lt;span style="color:#a6e22e">apply&lt;/span>(number);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような形のEnumを使う場合のコードは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 処理結果を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Integer type_1 &lt;span style="color:#f92672">=&lt;/span> CalculateEnum.&lt;span style="color:#a6e22e">TYPE_1&lt;/span>.&lt;span style="color:#a6e22e">calculate&lt;/span>(10); &lt;span style="color:#75715e">// 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Integer type_2 &lt;span style="color:#f92672">=&lt;/span> CalculateEnum.&lt;span style="color:#a6e22e">TYPE_2&lt;/span>.&lt;span style="color:#a6e22e">calculate&lt;/span>(10); &lt;span style="color:#75715e">// 20&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>共通の部品として使われるものが重複されていると管理もその値の理解も難しくなり、余計なコードが増えるますね。これをEnumで克服できるということを伝えたかったのですが、いかがでしょうか。ただ、定数を必ずEnumにする必要があるかは、よく考えてみる問題だと思います。場合によってはテーブルとして管理した方が良いのかもしれません。そしてある特定のクラス内でしか使われていないなら、あえてEnumを作る必要もないでしょう。&lt;/p>
&lt;p>それでもこのようにAPIの活用方法を理解し、覚えておくと、どこかで使っていい場合が現れるのではないかと思います。最初はLambdaをただの「読みづらいコード」としか認識していなかった私も、Functionの存在を知ってからは積極的に使っています。知識のみでなく、その知識を適材適所で活かしていけるようになることが真のプログラマーと思います。まずその判断は難しいかもしれませんが、知識を先に持つことで見えてくるものもあるのではないでしょうか。なので、これからも新しく得られた知識があれば、このブログで紹介していきたいと思います。&lt;/p></description></item><item><title>Oracle JavaSE 8 Silverについて</title><link>https://retheviper.github.io/posts/java-se-8-silver/</link><pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-se-8-silver/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Oracle JavaSE 8 Silverについて" />&lt;p>今回、Oracle認定JavaSE 8 Silverを受験しました。仕事でしばらくJavaを使うことになって、自分の実力がどのレベルなのかを確かめたかったので受けてみましたが、運よくも合格。Java Silverで検索すると合格した人たちはどう勉強したか、難易度はどうなのかについてのブログが多いのでここでは書きません。&lt;/p>
&lt;p>それでもあえてポストとして資格試験のことを書く理由は、どうしても資格とは実際の業務で必要となる知識とは乖離があるものだからです。資格をまず取得して業務に入る人もいれば、私のように業務でのお作法を経験してから受験する人もいるだろうと思います。なので、私と全く同じ状況ではないとしてもテストで困る問題は多分ある程度その領域が重なるのでは、と思います。その結果として他の多くの方が書いているものとあまり変わらないことを述べているのではないか、とも思いますが…&lt;/p>
&lt;p>もしこれからJavaSE Silverを受験しようとしている方がこのポストを見つけた場合に、少しでも役に立てるような情報になれるといいなと思い、自分の経験として意外とハマったところについて述べます。&lt;/p>
&lt;h2 id="全体的な印象">全体的な印象
&lt;/h2>&lt;p>業務では使わない知識が要求される場合が少なくないです。ただそれが全部無駄な知識とは言えない印象でした。一旦覚えておくと業務でも活かせるのでは、と思う問題もありました。大きく分けてAPIに対する単なる知識を聞く問題と、コードを読んで理解する能力を要求するような問題があります。&lt;/p>
&lt;p>意外と難しいなと思ったのは、IDEに依存できない問題でした。代表的にimportの書き方、コンパイルエラーの見つけだしなどがあります。実際の業務でIDEを使わず、単なるテキストエディタでJavaを書くことはないと思いますが、試験としてはそのような問題の頻度が決して低くないので、問題で提示されるコードはちゃんと読む必要があります。&lt;/p>
&lt;p>それでは、以下ではテストの個別項目について感じたことを述べていきます。&lt;/p>
&lt;h3 id="データ型">データ型
&lt;/h3>&lt;p>データ型で最も多く使われるのは、int/double/Stringの三つだと思います。テストでもbyte型やfloat型の範囲などを聞く問題はなかったですが、一部の問題でこれらが出てくる場合があります。例えばswitch文の条件文で使えないデータ型は何かを選ぶ問題など。Bronzeならもっとデータ型について詳しく聞く問題が出てくるのでBronzeの次にSilverを受けるならともかく、私みたいにSilverから挑戦する人なら少し困るかもしれません。&lt;/p>
&lt;p>他にもデータ型と関連する問題の種類は、型変換(暗黙的な型変換とそうではない場合を選ぶ)があります。こちらもbyte, short, long, floatの特徴を確かに覚えないと、意外と正解がわからなくなる問題でした。&lt;/p>
&lt;h3 id="string--stringbuilder">String / Stringbuilder
&lt;/h3>&lt;p>StringやStringBuilderのメソッドに関する問題が多かったです。ただ普段はあまり意識してなかった部分ですが、StringはImmutableなオブジェクトになるためreplaceやsubstringなどのメソッドを使うと新しいインスタンスが返却されるということをちゃんと覚えておく必要があります。例えば以下のような問題があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 出力される文字列を当てる問題&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is string&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s.&lt;span style="color:#a6e22e">substring&lt;/span>(0, 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(s);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元のString自体は変わってないので最初に宣言した通り出力されるのが当たり前ですが、注意深くコードを読まないとsubstringで切り取った文字が出力されるように勘違いしやすいです。(自分だけかもしれませんが…)&lt;/p>
&lt;h3 id="配列">配列
&lt;/h3>&lt;p>配列をあえて使う場合があまりなく、ほとんどListを使っていたのでこちらの問題でも苦戦しました。配列の宣言の仕方から、配列の中の要素を処理する方法などの問題がよく出てきましたが、配列の宣言には様々な方法があるので少し選択肢が怪しく思われます。&lt;/p>
&lt;p>もちろんListは基本が可変・スレッドセーフではないので場合によっては業務でも配列を導入する必要はあるかもしれません。覚えておいて損ではないと思いますので、配列については確実に覚えておきたいと思いました。&lt;/p>
&lt;h3 id="アクセス修飾子--継承">アクセス修飾子 / 継承
&lt;/h3>&lt;p>defaultとprotectedの違いを問う問題があります。普段からパッケージ構成や継承を考慮した実装をしていたならともかく、大抵の場合はpublicとprivateのみを使っていて他を忘れやすい場合もあると思うので、ちゃんと覚えておきたいものでした。&lt;/p>
&lt;p>また、継承の問題でアクセス修飾子が重要なキーワードとなる問題もありました。例えばスーパークラスからオーバーライドーしているメソッドをより狭い範囲にするようなコードを提示して、そのコードを実行したらどうなるかを聞く問題など。正常実行されると思ってその結果を答えとして選んでも、「コンパイルエラー」が正解だったりします。&lt;/p>
&lt;p>継承に関してはかなり問題の量が多いような印象を受けました。Interfaceとabstractの違い、継承の仕方、インスタンスと参照の違い、キャストなどバリエーションも多く、どれも実務では使われているので慣れてはいるものの、問題自体もそのためか知識だけよりは少し複雑な方法でミスを招こうとしている印象でした。コードを注意深く読む必要があります。&lt;/p>
&lt;h3 id="ラベル">ラベル
&lt;/h3>&lt;p>ラベルについてはこの度初めて接したので全然知らなかったですね。しかし二重ループで使うとかなりパフォーマンスの改善を図れると思いますので、これはテストだけではなく覚えておくと良いこつと思います。ただ、ループ以外で使うことはそんなにないかも…とも思います。&lt;/p>
&lt;p>問題としてはラベルがついたループ文ないでif文を書き、結果がどうなるかを聞く問題が少しありました。例えば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 出力がどうなるかを問う問題&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> num &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> 5 &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> num&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ラベル自体よりは条件文とcontinue / breakの違いをちゃんと理解しているかを聞くような問題とも言えると思いますが、とにかくラベルとはなんぞや？となると、一旦答えることができなくなります。もちろん知識としてラベルをつけることができるのはどこか、という問題もありました。&lt;/p>
&lt;h3 id="例外">例外
&lt;/h3>&lt;p>Javaの例外の特徴や、try-catch文での挙動に関する問題が出てきます。業務ではカスタム例外を作ることもあるのでExceptionとRuntimeExceptionの違いについて理解しているならそこまで問題となることはないと思いますが、提示されるコードで見逃す可能性があるのは「throws宣言があるかどうか」、「catchでスーパークラスの例外を宣言しておいてその次にサブクラスをまた書いてコンパイルエラーになる場合であるか」のような部分です。上位の例外をcatchすると、下位の例外は書く必要がないので注意しましょう。&lt;/p>
&lt;p>IDEを使える環境だったらあまり気にする必要ない部分なので、意外と見逃せやすい部分ではないかと思います。&lt;/p>
&lt;h3 id="lambda">Lambda
&lt;/h3>&lt;p>JavaSE SilverではJava8ならではのAPIについて聞く場合が少なくないです。Lambdaもそうですね。ただ、大抵のLambda関連の問題は正しい書き方やFunctionの種類に関する知識を問う問題です。慣れてなくても、覚えておくと大丈夫でした。&lt;/p>
&lt;p>書き方については括弧とreturnの省略が正しく書いてあるのかについての問題で、例外同様IDEだとすぐコンパイルエラーになるため見逃しやすい部分でした。&lt;/p>
&lt;h3 id="localdate--localtime--localdatetime">LocalDate / LocalTime / LocalDateTime
&lt;/h3>&lt;p>今まで自分が使っていた日付関連のAPIは&lt;code>java.util.Date&lt;/code>と&lt;code>java.sql.Date&lt;/code>しかなかったので、苦戦した問題でした。こちらもStringと同じくImmutableなので、似たような問題が出てきます。例えば以下のような問題です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 出力がどうなるかを問う問題&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LocalDate date &lt;span style="color:#f92672">=&lt;/span> LocalDate.&lt;span style="color:#a6e22e">now&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date.&lt;span style="color:#a6e22e">plusDays&lt;/span>(5);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(date);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Stringと同じく、Local〜類のAPIは値を操作するメソッドが新しいインスタンスを返却することを覚えておくと良いだけです。ただ、時間や日付の出力フォーマットに関する問題が出るのでこちらは覚えておく必要がありました。APIを見ると&lt;code>java.sql.Data&lt;/code>にも変換ができるのですが、変換に関する問題は出てませんでした。&lt;/p>
&lt;h3 id="その他">その他
&lt;/h3>&lt;p>問題集だけだと複数の選択肢を選ぶ問題なのに一つしか選んでなかったりしていて、本場でこうなると困るな…と思っていましたが、実際のテストでは単一選択肢だとラジオボタン、複数だとチェックボックスで選ぶようになっているので心配ありませんでした。チェックスボックスなのに一つだけ選んでいたりすると次の問題に移る前に警告も出ました。&lt;/p>
&lt;p>一部ループでの処理などを直接計算する必要がある場合もありますが、多くは時間がかからなく即答できるものです。時間が足りないということはほぼないと思いますので、問われているAPIに関してその特徴をよく覚えると簡単に合格できる資格なのでは、と思います。&lt;/p>
&lt;p>ただ逆に、私みたいに業務に慣れていて基本を忘れていたり知らなかったりするとハマるところも少なくないと思います。先に述べたように時間が足りなくなることはあまりないので、コードが提示される問題は注意深く読みましょう。そしてコードが提示される問題の答えは実質的に「処理の結果が出力される」、「コンパイルエラーになる」、「実行時に例外がスローされる」の三つだけなので、まずどれに当て嵌まるかを考えてみると良いと思います。&lt;/p>
&lt;p>それでは、これから受験する皆さんも合格できますように！&lt;/p></description></item><item><title>Moduleの問題に会った話</title><link>https://retheviper.github.io/posts/java-conflict-of-module/</link><pubDate>Sun, 08 Sep 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-conflict-of-module/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Moduleの問題に会った話" />&lt;p>最近のJavaはバージョンアップが早いですね。自分が初めて学んだものは1.8でしたが、すぐ9がでて今は13もリリースを目前としています。バージョンアップはバグ修正や性能の向上など良い面が多いためなるべく自分が使っているプログラムは常に最新のバージョンを維持したいですが、言語のバージョンが上がる度、何が変わったかを確認しすでに存在するコードを見直すのは簡単な問題ではいですね。&lt;/p>
&lt;p>Javaはかなり歴史が長いので、現在のトレンドと比べてみると不便(パラダイムが変わったからという理由が多いと思いますが)な面が多いです。そして1.8が維持された期間が長かったのですが、そのため流行には遅れていますね。10になって型推論が導入されるなどトレンドを追いかけているような面もありますが、Kotlinのように同じくJVMを使う言語と比べてみるとまだ先が遠い印象はあります。&lt;/p>
&lt;p>もちろん変化は肯定的なものであって、元の特徴を維持しながらもトレンドに合う書き方ができるようになったというのは、その言語を使えるユーザーのプールが広くなったとも評価できるでしょう。でも、全ての要素において「古いものと新しいもの共存」ができるわけではなさそうです。そういう場合はどちらを使うかを選択する必要がありますね。&lt;/p>
&lt;p>今回のポストで話たいModuleがその代表的なものです。昔からの問題を改善するために導入されたものですが、結局は既存のコードに影響を与えてしまい、対応が必要となる部分です。最初は自分が書くコードでは考慮する必要がないものだろうと思っていたのですが、どうもそうはいかなかったです。なのでここでは、JavaのModuleが何であり、どんな問題を経験したかを述べたいと思います。&lt;/p>
&lt;h2 id="project-jigsaw">Project Jigsaw
&lt;/h2>&lt;p>ModuleはProject Jigsawという名で、1.7から導入を検討していたものらしいです。Moduleという名からわかるように、アプリケーションを起動する時読み込むライブラリー(Java内臓の)を選択することができるシステムです。1.8まではコマンドラインで起動するアプリケーションを作るとしても、基本的なシステムライブラリーであるSwingなどが含まれていたのですが、それを調整できるようになりました。要らないシステムライブラリーを除去するとアプリケーションのサイズも小さくなりますし、メモリーを節約できるというメリットもありますね。また、Javaの特徴でもあった「完璧にロードされるまでには時間がかかる」という問題も、このModuleの設定である程度解消できるようになりました。&lt;/p>
&lt;p>そのほかにも、パッケージの「Publicすぎる問題」も、Moduleで解消できるようです。JavaのクラスはProtected宣言で同じパッケージでアクセスできるようにできますが、パッケージが細かく分けられた場合は同じライブラリーの中でもアクセスできませんでした。そういう場合はPublicで宣言するしかなかったですね。Publicで宣言されたクラスはライブラリーの中だけではなく、どこでもアクセスできるようになるため問題が生じる可能性もあります。ライブラリーを作りながらクライアントに使って欲しいクラスと使って欲しくないクラスを分けることが難しいことだったということです。これをModule設定により外部へ公開するクラスと、ライブラリー内部に向けて公開されるクラスで分けられるようになりました。&lt;/p>
&lt;h2 id="moduleの実例">Moduleの実例
&lt;/h2>&lt;p>では、Public問題をModuleでどう解消できたかを、コードを持って説明します。まだ自分もModuleを積極的に使っているわけではないので基本となる部分だけですが、重要なポイントは以下の三要素だそうです。&lt;/p>
&lt;ul>
&lt;li>Name&lt;/li>
&lt;li>Exports&lt;/li>
&lt;li>Requires&lt;/li>
&lt;/ul>
&lt;p>まずNameは、Moduleそのものの名称を意味します。パッケージ名と同じ命名規則で書きます。次にExportsは、このModuleから外へ公開するパッケージのことを意味します。ModuleではPublicであっても、Exportsと明示されていないパッケージは外部からアクセスすることができません。そして最後にRequiresは他のModuleに対する依存関係を表します。&lt;/p>
&lt;p>これらを実際のコードで書くと、以下のようになります。デフォルト・パッケージに&lt;code>module-info.java&lt;/code>として記述されます。(Java9以後のシステムライブラリーから確認できます)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// module-info.javaの書き方&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>module com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">mylibrary&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exports com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">mylibrary&lt;/span>.&lt;span style="color:#a6e22e">api&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> requires com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">exlibrary&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Exportsの場合、公開対象を指定することができます。つまり、アクセスできるMobuleを指定することができるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// exlibrary限定のPublic設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>module com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">mylibrary&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exports com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">mylibrary&lt;/span>.&lt;span style="color:#a6e22e">api&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> to com.&lt;span style="color:#a6e22e">module&lt;/span>.&lt;span style="color:#a6e22e">exlibrary&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Moduleはもちろん外部ライブラリーに対しても使うことができます。&lt;code>module-info.java&lt;/code>を作成する方法もありますが、Java9以前に作られたライブラリーの場合にはそれがない可能性が高いですね。このようにModuleかされていないライブラリーを含ませる必要がある場合は&lt;code>Automatic Module&lt;/code>か&lt;code>Unnamed Module&lt;/code>の二つの方法からライブラリーを分けて使うことになります。両方自動的にModuleとして扱われるという面では同じで、全てのパッケージにアクセスできるという面では同じですが、前者は&lt;code>modulepath&lt;/code>に属するものとして名前がある(Jarファイル名となります)ことに対して、後者は&lt;code>classpath&lt;/code>に属するもので名称がないためRequiresで指定することができません。&lt;/p>
&lt;h2 id="moduleでハマったところ">Moduleでハマったところ
&lt;/h2>&lt;p>自分がModuleであった問題は、同じパッケージをもつ二つのライブラリーの競合によるものでした。問題が生じたのは、既存のプロジェクトにGradleのタスクを追加しようとしていたので原因でした。Gradleのタスクを作成する方法は&lt;code>build.gradle&lt;/code>に直接taskを作成することでもできますが、最初自分が参考にしていた方法(Gradleの公式文書に従いました)では&lt;code>java-gradle-plugin&lt;/code>というプラグインを含ませる方法でした。こうすると自動的にJavaのライブラリーが追加されて、Javaでプラグインを書けられるようになりますが、ここに含まれているライブラリーがJavaのシステムライブラリーと競合を起こしました。&lt;/p>
&lt;p>元のプロジェクト(Java11を使っています)では&lt;code>javax.xml&lt;/code>をインポートしていて、これがJava9からは&lt;code>Deprecated&lt;/code>になり、最終的にJava11から除去されたらしいです。それがEclipse上では&lt;code>Unnnamed Module&lt;/code>として読み込まれていたらしく、ちょうど&lt;code>java-gradle-plugin&lt;/code>のパッケージにも同一名のパッケージが含まれていたので競合が起こったのです。そもそも除去されている扱いなので競合が生じるのがおかしいですが…エラ〜メッセージでは&lt;code>The package javax.xml.transform is accessible from more than one module: &amp;lt;unnamed&amp;gt;, javax.xml&lt;/code>と出力されていました。&lt;/p>
&lt;p>&lt;a class="link" href="https://stackoverflow.com/questions/51094274/eclipse-cant-find-xml-related-classes-after-switching-build-path-to-jdk-10" target="_blank" rel="noopener"
>似たような事例&lt;/a>を参考にすると、二つの解決法が提示されていましたがどちらも自分のプロジェクトでは使えませんでした。&lt;code>module-info.java&lt;/code>を作成するとマルチプロジェクトとなっていてサブプロジェクト間のパッケージ依存関係まで考慮するには複雑な手続きが必要でしたし、Eclipseのモジュール依存関係設定からシステムライブラリーの&lt;code>javax.xml&lt;/code>を除去すると、他にインポートしている&lt;code>java.sql&lt;/code>が&lt;code>javax.xml&lt;/code>に依存しているのでこちらも使えなくなるという問題がありました。&lt;/p>
&lt;p>そしてリンクの文を読んでみると、最新のJava13までこの問題(自分のケースと完璧に一致しているとは言えませんが)は解決されてないというので、どうしようもない状態でした。&lt;code>java-gradle-plugin&lt;/code>はGradleで管理されているライブラリーなのでこちらからうかつに手を出すこともできませんでした。&lt;/p>
&lt;h2 id="結局どうしたらいいか">結局どうしたらいいか
&lt;/h2>&lt;p>現時点では、外部ライブラリーを維持したまま競合だけを避ける方法はなさそうです。自分のModuleに対する理解がまだ足りてないことも原因かとは思いますが、結局はこのような事態が発生するとなるべく競合の原因となるライブラリーを除外するしか他の道はなさそうですね。便利さのために導入された新しい機能が、思わぬところで問題を起こしてしまうのはそう珍しいことでもないですが…3日ほど悩んだ私の選択は結局、そのライブラリーを使わないということしかなかったです。&lt;/p>
&lt;p>もちろん、Moduleの問題なのでバージョンに対するこだわりがなければJavaを1.８に下げるという方法もあります。ただ1.8はいずれサポートが終わるはずで、これからもJavaのバージョンはどんどん上がっていくはずなのでいつかは直面することになるかもしれない問題ですね。どうかJava14ではこのような問題が起こらないことを祈ります。&lt;/p></description></item><item><title>インスタンスをImmutableにするための工夫</title><link>https://retheviper.github.io/posts/java-thoughts-of-immutable/</link><pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-thoughts-of-immutable/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post インスタンスをImmutableにするための工夫" />&lt;p>Pythonのような本格的なオブジェクト指向言語ではあまり見かけられないことですが、Javaではいわゆる参照型の以外にもプリミティブ型というものがありますね。どうもJavaが初めて世に出た時代はまだオブジェクト指向という概念が生まれたばかりだったのでそうなったのではないかと思います。このプリミティブ型が存在するという点から、Javaは完全なオブジェクト指向言語ではないという話もあるようです。&lt;/p>
&lt;p>プリミティブ型に対する定義は言語ごとに少し違うようですが、私が知っているのはJavaだけなのでJavaの基準からいうと、プリミティブ型はオブジェクトではないデータ型を指す言葉です。そしてそれは、メモリー上に載せたデータをどう持つかの観点がオブジェクトとは違うということです。オブジェクトはメモリー上のデータが位置する「アドレス」を指すことに対して、プリミティブ型はそれぞれ独立したメモリー領域にデータを載せます。&lt;/p>
&lt;p>これを証明するのが、条件文での演算子の違いです。プリミティブ型で、二つの変数が同一なデータを持っているかを比較する演算子は&lt;code>==&lt;/code>ですね。しかし、同じ方法でオブジェクト、よく挙げられている例としてStringだと、同じ方法を使えません。&lt;code>equals()&lt;/code>を使わないとStringでの正確な値の比較はできなくなりますね。なぜならオブジェクトが持っている値そのものはメモリーのアドレスなので、「同じ値を入れた」つもりでもそれぞれのオブジェクトが指しているメモリーのアドレスは違う可能性があるからです。&lt;/p>
&lt;p>このように、メモリー問題はプログラミングに対してはかなり重要なものです。いくらメモリーの絶対値が増えても、メモリーに載せられたデータをどう参照するか、どう扱うかを間違えたら思い通りにプログラムは動かない可能性があるからです。そしてまた重要なのは、メモリー上に載せたデータを参照する方法だけではなく、どう管理するかということです。正確なデータを入れたつもりが、途中で変わったりすると、参照の仕方が正しくてもプログラムが正常動作しない可能性がありますからね。&lt;/p>
&lt;p>そういう意味で、今回はImmutableなクラスについて述べたいと思います。&lt;/p>
&lt;h2 id="immutable-objectとは">Immutable Objectとは
&lt;/h2>&lt;p>Immutavle Objectとは、簡単にいうと「一度インスタンスが生成されたら、そのインスタンスが持つデータが変わらない」オブジェクトのことです。逆に、インスタンスの生成以後もデータが変わる可能性のあるオブジェクトはMutableと言います。代表的なMutableクラスとしてはBeanを挙げられますね。Setterを通じて自由にデータを変えることができます。そしてImmutableなクラスとして代表的なのは、Stringと言います。Stringは値を代入しても、元のデータはGarbage Collectorの対象になるまでメモリーに残り、そのStringオブジェクトが指すメモリーのアドレスだけ変わるからです。&lt;/p>
&lt;p>先に述べたように、プログラムの中でオブジェクトが持っているデータが途中で変わると、安定的な動作を保証できなくなります。そしてマルチスレッド環境では、二つのオブジェクトが同じメモリーアドレスを参照していると、スレッドそのものが止まってしまう可能性もあります。もしそのような場合が生じるとどこで問題が起きたか調べることも難しいですね。このような問題を回避するため、Immutableなクラスを作成するときは「インスタンスの生成以後はデータが変わらない」ことと、「クラスの持つデータが同じメモリーアドレスを参照しないように」します。&lt;/p>
&lt;p>それでは、Immutableなクラスを作成する方法にはどんなものがあるか、見ていきましょう。&lt;/p>
&lt;h2 id="setterは使わない">setterは使わない
&lt;/h2>&lt;p>最近はかなりLombokを使う場合が多く、ある程度定型的なコードを生成してくれるので、Lombokのアノテーションを使って生成されるコードを持って説明したいと思います。Lombok自体の紹介は、&lt;a class="link" href="../java-design-pattern-builder" >以前のポスト&lt;/a>を参照してください。&lt;/p>
&lt;p>Lombokでは、アノテーションをつけることで簡単にBeanを生成できます。クラスの上に&lt;code>@Data&lt;/code>をつけることで、簡単にSetterとGetterができますね。これを使った場合、直接メソッドを手で書くより安定的でコードの量も減るため積極的に使えます。&lt;/p>
&lt;p>しかし、Setterが生成されるということはImmutableなオブジェクトにならないことを意味します。次は実際、&lt;code>@Data&lt;/code>をつけることで生成されるコードの例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @Dataの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドだけを定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以下のメソッドたちが自動生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setName&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setColor&lt;/span>(String color) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span> &lt;span style="color:#f92672">=&lt;/span> color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getColor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうなった場合、フィールドが&lt;code>final&lt;/code>で守られていないといつでもSetterにより値が変わる可能性があります。そして一部Setterメソッドが使われていない場合は全フィールドに値が設定されてないままnullになってしまう可能性もありますね。これはImmutableの定義にふさわしくないコードとなっています。&lt;/p>
&lt;p>幸い、Lombokで提供するアノテーションの中にはImmutableなクラスを生成するためのアノテーションもあります。&lt;code>@Value&lt;/code>というものです。これを使うと、&lt;code>@Data&lt;/code>と同じ機能をしながら(インスタンスの生成とフィールドの値を指定する方法は変わりますが)もImmutableなクラスを生成することができます。こちらのアノテーションを使ったコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @Valueの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドだけを定義&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以下のメソッドたちが自動生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span>(String name, String color) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span> &lt;span style="color:#f92672">=&lt;/span> color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getColor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最初、インスタンスを生成するときはコンストラクターで全フィールドを引数として指定します。フィールドが多いとどれがどれかわからなくなりますが、フィールドの値指定が漏れる可能性は無くなります。そしてSetterがないため一度生成されたインスタンスに対してはフィールドを変更できなくなります。&lt;/p>
&lt;p>そしてこの&lt;code>@Value&lt;/code>アノテーションの良いところは、Builderパターンと両立できるというところです。&lt;code>@Builder&lt;/code>をつけることで、インスタンスの生成時にそれぞれのフィールドがどんなものであるかを明確に確認できますね。ただ、Builderパターンでは全フィールドに値を指定する義務はないので注意が必要です。この問題は、手で&lt;code>build()&lt;/code>メソッドを書くことで回避できます。ある意味、オーバーライドに近いことだと言えますね。コードで表現すると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以下のコードだけを作成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> CarBuilder {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// nullのフィールドがあったらNPEを発生させる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Car &lt;span style="color:#a6e22e">build&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> NullPointException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> NullPointException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Car(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はやはりコードが複雑になり、フィールドが増えるとまたそれに対応しなければならなくなりますね。フィールドがまた&lt;code>List&lt;/code>だったりすると、ループでnull検査をする必要もあるはずです。このように&lt;code>@Value&lt;/code>だけを使う場合に比べ、コードが複雑になっているので、便宜生と安全性でどちらを選ぶかを考える必要がありますね。&lt;/p>
&lt;h2 id="final宣言">final宣言
&lt;/h2>&lt;p>Beanを使うしかない場合もありますね。例えばフィールドがnullになっても良い場合もあるはずです。それともそのBeanを持って処理をするメソッドでnullを検査するなど、何かの措置をしといたら良い場合もあるはずでしょう。&lt;/p>
&lt;p>そしてBeanを使う場合、フィールドを&lt;code>private&lt;/code>に宣言して外部からの直接的なアクセスを防ぐということは常識となっています。&lt;code>public&lt;/code>で宣言されたフィールドだと、どこでもアクセスできるようになり知らないうちに値が変更される可能性がありますからね。それを防ぐために、Beanのフィールドに直接的なアクセスを許容しなく、Setterメソッドで値を指定してGetterメソッドで値を参照することは暗黙のルールとなっています。&lt;/p>
&lt;p>Setterメソッドによってフィールドに直接アクセスせずに値を指定することで最低限の安全は確保したと言いたいところですが、実はそうでもありません。なぜなら、依然としてフィールドの値は何度でも変わる可能性があるからです。一度Setterで値を入れて、その後にまたどこかでSetterを読んでいたら、Beanの持つフィールドの値は上書きされます。&lt;/p>
&lt;p>これを防ぐためには、フィールドに&lt;code>final&lt;/code>を使うべきです。final宣言されたフィールドは、初期化以後にその値が代入されないため、安定性が上がります。final宣言されたフィールドに値を代入しようとするとコンパイルエラーとなるため、エラーを見つけやすいというところも良いですね。&lt;/p>
&lt;p>また、全フィールドがfinalで宣言されている場合、&lt;code>@Data&lt;/code>アノテーションは実質的に&lt;code>@Value&lt;/code>アノテーションと同じコードを生成します。もちろん、場合によってはfinalではないフィールドを持たせることもできます。そういう場合のコードは以下のようになります。場合によってはこれも必要かもですね！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @Dataの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// colorだけがfinal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 以下のメソッドたちが自動生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span>(String color) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span> &lt;span style="color:#f92672">=&lt;/span> color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setName&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getColor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">color&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、finalとなっているのはあくまでもこのクラスのフィールドのみということに気をつけなければならないです。Carオブジェクトを生成時に使われたデータが、以後も固定されて更新ができなくなります。&lt;/p>
&lt;h2 id="浅いコピーと深いコピー">浅いコピーと深いコピー
&lt;/h2>&lt;p>Setterメソッドのもう一つの問題は、オブジェクトをコピーした場合に、コピー先のオブジェクトの値を変えるためにSetterを使うとそれがコピー元に影響するということです。簡単に以下のようなコードを作成したとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @DataのCarクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Car car1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Car();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car1.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;My car&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car1.&lt;span style="color:#a6e22e">setColor&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;red&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 友達が私と同じ車を買った&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Car car2 &lt;span style="color:#f92672">=&lt;/span> car1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Your car&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 出力してみる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(car1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(car2);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコマンドをコンパイルして実行してみると、どちらのCarも&lt;code>name&lt;/code>が&lt;code>Your car&lt;/code>になっていることを確認できます。なぜこうなったのでしょう？先はStringがImmutableと言っていましたけどね。&lt;/p>
&lt;p>これは、&lt;code>car1&lt;/code>の値だけを&lt;code>car2&lt;/code>にコピーするという意図から書かれたコードが、実は&lt;code>car1&lt;/code>と&lt;code>car2&lt;/code>は「同じメモリーアドレスを参照する」というコードになってしまったからです。同じアドレスから値を参照するため、そのアドレスの値が変わると両方に影響するわけです。&lt;/p>
&lt;p>このようにオブジェクトは参照が変わるだけなので、代入だけではそれぞれが独立していると言えなくなります。プリミティブ型が値そのものを保存するので代入でも安全なのとはまた違うところですね。このようにオブジェクトの「参照」だけが変わる状況を「浅いコピー」と言います。&lt;/p>
&lt;p>今までの展開から推測できるように、オブジェクトの参照を分離する必要があるでしょう。参照が独立していると、片方の値が変わっても他には影響ないはずですからね。参照がオブジェクトごとに違うというのは、同じ値を持ってメモリーに新しいオブジェクトを生成するということと同じ意味です。そしてこれを「深いコピー」と呼びます。&lt;/p>
&lt;p>深いコピーには様々な方法があります。まずはフィールドのオブジェクトを新しく生成することです。例えば、以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスを生成して値を入れてみる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Car car2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Car();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> String(car1.&lt;span style="color:#a6e22e">getName&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> String(car1.&lt;span style="color:#a6e22e">getColor&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 値を変えてみる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> String(&lt;span style="color:#e6db74">&amp;#34;Your car&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じく出力してみると、今回はちゃんと&lt;code>car2&lt;/code>の値だけが変わったことを確認できます。しかし、全てのフィールドに対してこうするのはあまり便利ではないですね。とこかでメソッド化することはできないのでしょうか？&lt;/p>
&lt;p>簡単なのは、インタフェースを利用することです。&lt;code>Cloneable&lt;/code>を継承することで簡単にオブジェクトをクローンできるようになります。ただ少し、メソッドを作成する必要はありますがね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Cloneable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// cloneメソッドを作る &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Car &lt;span style="color:#a6e22e">clone&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> CloneNotSupportedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (Car) &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうすると、以下のような方法で深いコピーができるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> car2 &lt;span style="color:#f92672">=&lt;/span> car1.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> car2.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Your car&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">catch&lt;/span> (CloneNotSupportedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法を使うときに注意すべきことがあります。クラスに&lt;code>clone()&lt;/code>を定義したからって、全てのフィールドに対して深いコピーを保証するわけではないということです。例えば&lt;code>Car&lt;/code>クラス内にさらに&lt;code>Engine&lt;/code>のような、Beanクラスがフィールドとして定義されていると、そのフィールドは浅いコピーになる可能性があるということです。これを回避するためには、&lt;code>Engine&lt;/code>クラスにも&lt;code>Cloneable&lt;/code>を継承させる必要があります。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Cloneable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 追加したフィールド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Engine engine;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドも深いコピーをさせる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Car &lt;span style="color:#a6e22e">clone&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> CloneNotSupportedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Car car &lt;span style="color:#f92672">=&lt;/span> (Car) &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> car.&lt;span style="color:#a6e22e">engine&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">engine&lt;/span>.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> car;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Engine&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Cloneable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String cylinders;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// cloneメソッドを作る &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Engine &lt;span style="color:#a6e22e">clone&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> CloneNotSupportedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (Engine) &lt;span style="color:#66d9ef">super&lt;/span>.&lt;span style="color:#a6e22e">clone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ListやMapの場合はどうクローンしたら良いでしょうか？同じくオブジェクトをクローンする観点からすると、両方とも方式は似ています。ループによるクローンですね。例えば以下のような方法でクローンができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listのコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> carList1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> carList2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Car car : catList1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carList2.&lt;span style="color:#a6e22e">add&lt;/span>(car.&lt;span style="color:#a6e22e">clone&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Mapのコピー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> carMap1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> carMap2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Entry&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Car&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry : carMap1.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carMap2.&lt;span style="color:#a6e22e">put&lt;/span>(entry.&lt;span style="color:#a6e22e">getKey&lt;/span>(), entry.&lt;span style="color:#a6e22e">getValue&lt;/span>().&lt;span style="color:#a6e22e">clone&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでImmutableなクラスを作り、コピーもできるようになりますね。&lt;/p>
&lt;h2 id="immutableなクラスで注意すること">Immutableなクラスで注意すること
&lt;/h2>&lt;p>&lt;a class="link" href="../java-reflection" >Reflectionに関するポスト&lt;/a>でも紹介したように、Reflectionを使うとフィールドに直接アクセスができ、privateで宣言されていてもアクセスを可能にすることもできます。つまりいくらImmutableなクラスを作ったとしても、Reflectionを使うとフィールドの値を変えることはできるということですね。&lt;/p>
&lt;p>そしてImmutableなクラスを作るということは、結局メモリーの使用量が上がるということでもあります。常に新しくオブジェクトを生成し、それぞれがメモリーを占有することになりますからね。もちろん現代のマシンのメモリーは多少のオブジェクトが作られても耐えられるメモリーを持っていますし、GCも活発に動いてくれるので一般的には心配するようなことではないですがね。&lt;/p>
&lt;h2 id="singletonクラスの変数には注意">Singletonクラスの変数には注意
&lt;/h2>&lt;p>Immutableとも関係があることですが、以前紹介した&lt;a class="link" href="../java-design-pattern-singleton" >Singletonクラス&lt;/a>を作成する場合にも、そのクラスが持つフィールドには注意しなければならないです。このクラスはインスタンスが生成されるとアプリケーションが終了するまで一つのインスタンスが使われるため、フィールドの値が変更される可能性があったら致命的です。処理ごとに結果が変わる可能性があるからです。なのでSingletonクラスにはなるべくフィールドを持たせないようにするか、final宣言をしておくなど、フィールドの値が変わる可能性を最初から封鎖しておく必要があります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>個人的に、プログラミングの始まりが「どう実現するか」だとすると、プログラミングの完成は「どう安定させるか」であると思います。もちろん、性能を改善させたり、維持補修を簡単にさせたりするテクニックも大事ですが、安定的に動作するプログラムを作るということがもっとも難しいものですからね。要件が増えれば増えるほど、コードは複雑になり、例外が発生する可能性も高くなります。Immutableなクラスを作るということは、そのような例外を回避するための一歩であるゆえ、信頼できるプログラムを作り出せるという面で大事な知識なのではないかと思います。&lt;/p>
&lt;p>これからもこのような知識に触れ、身につけていきたいですね！&lt;/p></description></item><item><title>デザインパターン、Singleton</title><link>https://retheviper.github.io/posts/java-design-pattern-singleton/</link><pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-design-pattern-singleton/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post デザインパターン、Singleton" />&lt;p>昔からPCを使うといつも問題となるのはメモリーだった覚えがあります。私が初めてPCに触れたのは父が仕事て使っていたもので、当時はOSとしてDOSを採用していてゲームでもしたいときはいつもメモリーの設定を変える必要がありました。そのときはそれが不便だとも思わず、ただゲームができればいいと思っていました。&lt;/p>
&lt;p>しかし時間が経ち、大学でのプレゼンテーションを準備しながら感じたのは、やはりメモリーが十分でないとマルチタスクがきついということでした。今はPCのパーツの中でもっともアップグレードした時に性能向上を感じられるのはSSDと言いますが、それはあくまでCPUとメモリーを安定的に確保できる時代になったおかげと思います。まずメモリーが足りないととにかく遅いとしか思えない時代もありましたからね。&lt;/p>
&lt;p>そしてプログラムを作る立場となってからは、メモリー問題はより現実的な問題となりました。例えばとあるシステムを構築し、複数の使用者がそのシステムを利用するとしたら、限定された資源であるメモリーが足りなくなる可能性はハードウェアが飛躍的な発展を成している現在でも存在しています。オブジェクトを作るたび、残りのメモリーは減り続けるので。&lt;/p>
&lt;p>ならば最適化という面で、メモリーを節約するには、無駄なオブジェクトの生成は抑えるべきでしょう。そのためにできる方法がないかと思っていたら、すでに存在していました。今回のポストの主題となる、Singletonパターンです。&lt;/p>
&lt;h2 id="singletonパターンとは">Singletonパターンとは
&lt;/h2>&lt;p>Singletonパターンは、アプリケーション内でインスタンスが一度だけ生成され、そのアプリケーションが終了するまで使われるクラスを作るためのデザインパターンです。Beanの場合はそれぞれ違うデータを持つインスタンスをたくさん生成して使いますが、こちらはインスタンスが一つしかないため動的なフィールドを持たせないですね。なのでどこからでもアクセスできるような不変のデータを持ったり、特定の処理を繰り返す必要がある時このSingletonパターンでのクラスを作る場合があります。&lt;/p>
&lt;p>このようなクラスがあって何が良いかというと、先に述べたメモリー問題です。例えばグローバル変数の場合、どんなクラスからもアクセスできるのであまりSingletonと変わらないようにも見えます。しかしグローバル変数の場合は、それが使われるが使われないが常にメモリーのなかにあって、無駄になってしまう可能性もあります。しかしSingletonの場合は、必要であれば生成し、必要でなければ生成しないこともできます。なのでメモリーを節約できますね。&lt;/p>
&lt;p>仕事では主に、ユーティリティークラスとしてSingletonクラスを作ることが多かったです。データの処理を繰り返して行う必要がある時、毎回インスタンスを生成することはメモリー問題もあって、コードが無駄に冗長になる傾向がありました。これをデータはそれぞれ違うインスタンスのBeanに持たせ、Singletonクラスに処理を任せることでコードの量も減らし、メモリーも節約することができました。&lt;/p>
&lt;h2 id="古典的singletonパターン">古典的Singletonパターン
&lt;/h2>&lt;p>それではSingletonクラスをどうやって作るのかを紹介します。デザインパターンでは様々なパターンがあって、その中の一つであるSingletonもまた様々な方法で具現できます。まずは古典的な方式を紹介します。&lt;/p>
&lt;p>ここで目的はインスタンスを一つだけにすることなので、外部からすでに生成されているインスタンスにアクセスはできても、そのインスタンスを勝手に作れないようにします。そうするにはコンストラクターにアクセスの制限が必要ですね。まずコードで紹介しましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// クラスはpublicにして外部からアクセスできるようにする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// コンストラクターはprivateにして、外部からはアクセスできないようにする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかしこれだけでは十分ではありません。どこかでインスタンスを生成する必要がありますね。また、先に述べたようにインスタンスの生成の時点は外部で制御できるようにしなければなりません。なのでprivateのコンストラクターにアクセスできるメソッドを用意する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスを保存するための静的フィールド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスの返却(インスタンスが生成されたない場合は生成してから返却する)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uniqueInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniqueInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SingletoneClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 普通のメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まずstaticで、自分のインスタンスを保存できるフィールドを宣言します。外部からSingletonクラスのインスタンスを取得するためにはこれを使うようになります。宣言だけで、この段階でインスタンスを生成しないのはグローバル変数と区別するためです。&lt;/p>
&lt;p>次に、インスタンスが生成されてない場合でもアクセスできるstaticメソッドを作成します。ここからこのSingletonクラスのインスタンスを取得するようになります。メソッドの中はでは戻り値としてインスタンスのフィールドをセットし、もしインスタンスが生成されてない場合にだけnewをするようにします。&lt;/p>
&lt;p>これで外部からは以下のように使えるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスの取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SingletonClass singletonInstance &lt;span style="color:#f92672">=&lt;/span> SingletonClass.&lt;span style="color:#a6e22e">getInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスのメソッドを使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>singletonInstance.&lt;span style="color:#a6e22e">doSomething&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでどこからでも同一なインスタンスでつかけるSingletonクラスができました。&lt;/p>
&lt;h2 id="古典的singletonパターンの問題">古典的Singletonパターンの問題
&lt;/h2>&lt;p>マルチスレッドを考える必要がない場合なら気にすることはないですが、現代のプログラミングはそうでもないですね。特に何かのシステムを作り、サービスとして提供する場合は複数の使用者によって同じクラスが要請される場合があります。&lt;/p>
&lt;p>そしてクラスの中が複雑でインスタンスの生成に時間がかかったり、ほぼ同時のタイミングでインスタンスが要請されると古典的なSingletonパターンでは複数のインスタンスが生成されることを塞げられない場合があります。この場合は元の設計通り動かなくなり予想できない例外が発生する可能性がありますね。&lt;/p>
&lt;p>もちろんこれらを解決するためにいくつかの方法が提示されてはいますが、それらの解決策にもデメリットはあります。まずどんな方法があり、それぞれのデメリットには何があるか見ていきましょう。&lt;/p>
&lt;h2 id="マルチスレッド問題を開所するために">マルチスレッド問題を開所するために
&lt;/h2>&lt;p>他にも方法はありそうですが、スレッドセーフなSingletonクラスを生成する方法は以下のようなものがあります。&lt;/p>
&lt;ol>
&lt;li>インスタンスの生成をシンクロさせる&lt;/li>
&lt;li>Double-Checked Lockingを使う&lt;/li>
&lt;li>JVMのクラスローダーにお任せ&lt;/li>
&lt;/ol>
&lt;p>まずインスタンスの生成をシンクロさせる方法は簡単です。インスタンスを取得するための&lt;code>getInstance()&lt;/code>メソッドに&lt;code>synchronized&lt;/code>を追加することです。コードで見るとあまり変わらないので、古典的Singletonパターンのクラスがあればもっとも簡単に適用できる方法ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスを提供するメソッドをシンクロさせる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">synchronized&lt;/span> SingletonClass &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uniqueInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniqueInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SingletoneClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、&lt;code>synchronized&lt;/code>の問題は性能です。100倍以上も処理の速度が遅くなる場合もあるらしいので、マルチスレッドを性能のために使う場合があれば、あまり望ましくないですね。&lt;/p>
&lt;p>次の方法は、二重チェックです。インスタンスがnullであればシンクロさせます。この方法だと毎回シンクロさせる必要がないので(2回目からはインスタンスがnullでないため)最初の一回以外は性能が低下しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// volatile宣言で安定性を確保&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスの二回確認&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uniqueInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (SingletonClass.&lt;span style="color:#a6e22e">class&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (uniqueInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uniqueInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SingletoneClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>volatile宣言を使う理由は、変数がCPUのキャッシュメモリーに入ることを防止するためだそうです。プログラムのデータは最初ハードディスクから読み込まれシステムメモリーに載せられますが、そのあとCPUでの処理が行われる時にはさらにCPUのキャッシュメモリーに載せられることがあります。&lt;/p>
&lt;p>最近は複数のCPUを搭載しているシステムも少なくないので、それぞれ違うCPUのキャッシュメモリーにインスタンスが入ってしまうとインスタンスが生成されているかどうかわからなくなりますね。volatile宣言でシステムメモリーにフィールドを乗せることで、インスタンスの生成がより安定的に行われます。でも依然として、同期化による性能低下を一回は経験しなければならないという問題があります。&lt;/p>
&lt;p>最後は、JVMが起動する時にインスタンスを生成させる方法です。この方法では外部からは確実にインスタンスの制御ができなく、常にインスタンスが生成されるためマルチスレッド問題を回避できますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドにインスタンスの生成を宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass uniqueInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SingletonClass();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">SingletonClass&lt;/span>() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスのチェックも要らなくなる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> SingletonClass &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> uniqueInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>クラスが読み込まれる時点でJVMからインスタンスを生成してしまうので、どんなスレッドからも静的フィールドにはアクセスできなくなります。ただ、これならグローバル変数で宣言することとあまり変わらないので、使われなくてもメモリー上にはインスタンスが生成されたままであるという問題は残ります。もちろん、グローバル変数宣言とは違ってインスタンスは唯一であることが違うところです。グローバル変数だとstaticでフィールドを宣言しても、違うクラスでまたを宣言できますので。そもそもグローバル変数には何が入っているかわからなくなる場合が少なくないので、乱発しないほうがいいですね。&lt;/p>
&lt;h2 id="メソッドとフィールドを全部staticに宣言して良いのでは">メソッドとフィールドを全部staticに宣言して良いのでは？
&lt;/h2>&lt;p>もちろんその方法もありです。しかし、初期化の過程が極めて簡単な場合にだけ有効(フィールドが何もないなど)な方法と言えます。クラス自体が単純な構造をしていて、メソッドは単純に外部から入れられたデータを処理して返すだけならできる方法ですね。実際使えない方法ではないですが、後の機能拡張などを考えると良い方法ではなくなりますね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>Singletonパターンは幅広く使われていて、確かに魅力的なクラスの設計の方法ではあります。しかしマルチスレッド問題を回避するため工夫しなければならない問題があり、唯一なインスタンスなためフィールドの処理にも気をつけなければならない面があります。とあるスレッドでインスタンスが使われていて、フィールドにデータを入れたのをまた違うスレッドでアクセスしようとすると問題が起こり得る可能性がありますので。&lt;/p>
&lt;p>他にもOOPの原則である、「一つのクラスは一つだけの責任を持つ」ということからしても、Singletonクラスは問題を持っています。何かの処理を担当していながらも、自分自身でインスタンスを管理するという二つの責任を持っていますからね。そしてコンストラクターがprivateであるため、サブクラスを作られなくなるという問題があります。サブクラスを生成するためにコンストラクターをpublicやprotectedに変えるとSingletonではなくなるジレンマもできますね。&lt;/p>
&lt;p>それでもSingletonパターンで作られたクラスは、確かな魅力を持っています。ちゃんとインスタンスの管理さえできていれば、どこでも呼びたして使うことができますからね。常にメモリーに載せる必要があるクラスができたら、検討したくなるパターンです。&lt;/p></description></item><item><title>Lombokのバグにあった話</title><link>https://retheviper.github.io/posts/java-lombok-annotation-bug/</link><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-lombok-annotation-bug/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post Lombokのバグにあった話" />&lt;p>&lt;a class="link" href="../java-design-pattern-builder" >前回のポスト&lt;/a>で、Builderパターンとともに&lt;code>Lombok&lt;/code>を紹介しました。Beanだけでなく、Immutableなクラス&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>やBuilderを作れるなど便利な機能が集まっていて、さらにアノテーションで様々なオプションが指定できたり(フィールドのアクセスレベルを指定できるなど)、必要なメソッドは追記しても良いなど使い道が多いですね。ただ、今回はそのLombokを使いながらバグらしき現象を発見したのでポストします。&lt;/p>
&lt;h2 id="バグの発生したところ">バグの発生したところ
&lt;/h2>&lt;p>どこでバグが発生したかを述べる前に、まずどんなLombokのアノテーションを使っていて、それらがそれぞれどんな機能をしているかを紹介したいと思います。なぜなら今回の場合は二つ以上のLombokアノテーションを組み合わせて使っていて、ほかにも自分と同じような組み合わせでLombokを使って同じバグを経験される方がいるかも知れないからです。&lt;/p>
&lt;p>Lombokの&lt;code>@Builder&lt;/code>には、&lt;code>(toBuilder=true)&lt;/code>のオプションをつけられます。これを使うと、基本的に新しいインスタンスの生成はstaticメソッドを呼ぶ事でできるようになって、すでに存在しているインスタンスから一部の値を変えて違うインスタンスに再生成する事ができます。コードで表現すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// @Builderだけを使って新しいインスタンスを生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>House house2 &lt;span style="color:#f92672">=&lt;/span> House.&lt;span style="color:#a6e22e">builder&lt;/span>().&lt;span style="color:#a6e22e">type&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;wooden&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// toBuilderオプションで既存のインスタンスから値を変えて再生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>House house3 &lt;span style="color:#f92672">=&lt;/span> house2.&lt;span style="color:#a6e22e">tobuilder&lt;/span>().&lt;span style="color:#a6e22e">type&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;block&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてBuilderを使いながらも、元のクラスのフィールドの中でBuilderにデフォルト値として渡したいものもあります。つまり、Nullにしたくない場合ですね。自分の場合は、Listでした。インスタンスが生成される場合にはとにかくListを初期化して、Builderを使ってListそのものを代入したり、&lt;code>addList()&lt;/code>のようなメソッドを作って個別の要素を追加できるようにしたかったです。&lt;/p>
&lt;p>これを実現するためには、元のクラスでListを初期化して、その状態でBuilderに渡す必要はありました。Lombokのアノテーションではフィールドに&lt;code>@Builder.Default&lt;/code>をつけることでできるようになります。そしてBuilderのアノテーションでは生成されない、&lt;code>addList()&lt;/code>的なメソッドだけを実装することですね。コードで表現すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>(toBuilder&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Wallet&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Builderでインスタンスが生成されるときはNullにしたくない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Builder.Default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> cards &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// カスタムメソッドをBuilderに追加するための宣言&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">WalletBuilder&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 元のBuilderではListそのものを代入する方法しかないので、個別要素を追加できるメソッドを書く&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> WalletBuilder &lt;span style="color:#a6e22e">addCard&lt;/span>(String card) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">cards&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(card);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうした実装で期待していた動きは以下のようなものでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インスタンスを生成しながらListにAddする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wallet myWallet &lt;span style="color:#f92672">=&lt;/span> Wallet.&lt;span style="color:#a6e22e">builder&lt;/span>().&lt;span style="color:#a6e22e">addCard&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Apple Card&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 既存のインスタンスにAddする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Wallet newWallet &lt;span style="color:#f92672">=&lt;/span> myWallet.&lt;span style="color:#a6e22e">toBuilder&lt;/span>().&lt;span style="color:#a6e22e">addCard&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;American Express Card&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、実際テストをしてみるとこの二つのアノテーションによりバグが発生したのです。&lt;/p>
&lt;h2 id="それでどんなバグが">それでどんなバグが？
&lt;/h2>&lt;p>既存のインスタンス(Listの操作を一切していない)では&lt;code>add&lt;/code>が思い通りになったのですが、インスタンスを生成すると同時に&lt;code>add&lt;/code>した場合はNPE&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>が発生していました。場所を調べてみると&lt;code>this.cards.add(card);&lt;/code>のところで例外が発生していたので、生成されてないオブジェクトに要素を追加しようとしていたとのことですね。つまり、Listがちゃんと初期化されてないという事です。&lt;/p>
&lt;p>少し調べてみると、&lt;a class="link" href="https://github.com/rzwitserloot/lombok/issues/1347" target="_blank" rel="noopener"
>Githubでのイシュー&lt;/a>がありました。2017年に書かれたもので今となってはずいぶん古い感じもしましたが、読んでみると今の自分が経験している現象と似ていましたね。しかも、Lombokの&lt;code>1.18.2&lt;/code>バージョンで解消されたという話もありましたが、今の自分が使っているバージョンは&lt;code>1.18.8&lt;/code>でした。解消されているはずがちゃんと想定通りならなかったのか、バージョンアップにより再発したのかわかりませんが、ともかく同じ現象が起きていましたね。&lt;/p>
&lt;h2 id="解決策">解決策
&lt;/h2>&lt;p>それではどう解決したらいいか？他にも方法があるのかもしれませんが、自分の場合は&lt;code>toBuilder=true&lt;/code>と&lt;code>@Builder.Default&lt;/code>の両方を使わない事で解決できました。Builderにちゃんとフィールドが渡らない時点で後者は意味がなくなりました。そして&lt;code>toBuilder&lt;/code>の場合も、二つのメソッドが追加されるだけなのでそれを手書きで確実に値を渡せるようにしました。上で提示した&lt;code>Wallet&lt;/code>クラスをこのやり方で直すと、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// toBuilderオプションを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Wallet&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// @Builder.Defaultを使わない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> cards &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// toBuilderメソッドも手書きする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> WalletBuilder &lt;span style="color:#a6e22e">toBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> WalletBuilder().&lt;span style="color:#a6e22e">cards&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">cards&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで元の想定通り、インスタンスを生成する時もちゃんと初期化されたListが渡るようになりました。めでたしめでたし。&lt;/p>
&lt;h2 id="教訓">教訓？
&lt;/h2>&lt;p>ライブラリーを使ってコードの量を減らし、自動化することは生産性の向上という面では大事な事ではありますが、人間の書いたコードはどこでバグが発生するかわからないので(想定していない使い方をする場合もありますし)、たまには手間がかかっても確実なコードを書くのが安全な場合もありますね。特にこの場合、アノテーションを諦めずコードを直そうとしていたらいつまでたってもバグは回避できなかったのかもしれません。そういう意味で、よい勉強になったと思える事件ではなかったのだろうかと思います。&lt;/p>
&lt;p>もしこのポストを読まれる方の中、私と同じような実装を考えている方がいたら、こんなこともあるんだなと参考できるようなことになっていると嬉しいです。それではまた会いましょう！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>一度インスタンスを生成すると、途中で値を変える事が出来ないクラス。Stringの場合がそうです。値を代入すると、メモリーに載せてある値を捨てて新しく生成します。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Null Pointer Exception、ヌルポとも呼ぶ例外です。参照しようとしているオブジェクトがメモリー上にありませんよーとのことで、Javaで最も遭遇しやすい例外ですね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>関数型インタフェースを使う</title><link>https://retheviper.github.io/posts/java-functional-interface/</link><pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-functional-interface/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post 関数型インタフェースを使う" />&lt;p>今回も、いつもと同じく仕事で得られた知識です。とあるIterableなクラスを作り、Forループをさせる必要がありました。これはそんなに難しいことではなかったです。まずフィールドにリストを持たせる。またIterableをインプリメントし、戻り値がIteratorであるメソッドを作るだけでしたね。しかし問題は、そのクラスのループの途中で、「使用者が指定したルールによりループを終了させる機能のあるクラスを作ること」でした。つまり、ループを終了させるには引数でループ中の要素を受け入れる引数を持つメソッドが内臓されていて、そのメソッドはインスタンスごとの基準となるデータを持っているということですね。&lt;/p>
&lt;h2 id="メソッドをフィールドとして使う">メソッドをフィールドとして使う？
&lt;/h2>&lt;p>メソッドとして機能しながらフィールドみたいにデータを持つ？それをさらに使用者が指定できるようにする？難しい注文だったので一瞬迷いましたが、「functionを使うといい」というアドバイスを受け、調べてみました。なるほど、これを使ったらフィールドとして宣言しながらもメソッドの機能を期待でき流みたいです。早速適用してみて、それがどう機能するかをまず紹介したいと思います。&lt;/p>
&lt;p>まずはIterableなクラスを用意します。ループの対象となるのはこちらです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Lineというクラスをリストとして持ち、Iterate可能なクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Factory&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Iterable&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> lines &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Iterator&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">iterator&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">lines&lt;/span>.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次はこのFactoryクラスを持ってループをさせる例です。ループの途中で&lt;code>Rule&lt;/code>クラスの&lt;code>isEnd(Line)&lt;/code>での判定が入ります。Lineインスタンスの中で何か条件に当たるものがあったら、戻り値がTrueとなってループから抜ける構造です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Iterableクラス&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Factory factory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Factory();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// forループでFactoryの中のLineオブジェクトを処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Line line : factory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Ruleクラスのループ終了判定メソッドを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (Rule.&lt;span style="color:#a6e22e">isEnd&lt;/span>(line)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何らかの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで判定を行うRuleクラスの場合は、以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Rule&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 判定のルールをフィールドとして持っている&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> endRule &lt;span style="color:#f92672">=&lt;/span> line &lt;span style="color:#f92672">-&amp;gt;&lt;/span> line.&lt;span style="color:#a6e22e">isBroken&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 引数のLineがPredicateの条件に当たるかを判定するメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isEnd&lt;/span>(Line line) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> endRule.&lt;span style="color:#a6e22e">test&lt;/span>(line);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RuleBuilder&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 中身は普通のBuilder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> endRule;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> RuleBuilder &lt;span style="color:#a6e22e">endRule&lt;/span>(Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>Line&lt;span style="color:#f92672">&amp;gt;&lt;/span> endRule) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">endRule&lt;/span> &lt;span style="color:#f92672">=&lt;/span> endRule;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まずPredicateが何であり、Lambdaだけであれができる？と思われそうなコードです。しかしちゃんと動いてくれています。それはなぜか？今までよくしらなかったですが、Java8から追加された&lt;code>java.util.function&lt;/code>によるマジックでした。フィールドはデータを持つためのものである、とは思っていましたが、そのデータというのがメソッドそのものにも慣れるとは知らなかったですね。&lt;/p>
&lt;p>それでは、その&lt;code>java.util.function&lt;/code>が一体どんなものかを、それに含まれている様々なインタフェースたちを持って紹介したいと思います。&lt;/p>
&lt;h2 id="functional-interface">Functional Interface
&lt;/h2>&lt;p>&lt;code>java.util.function&lt;/code>に含まれている様々なインタフェースたちを、関数型インタフェースと呼ぶらしいです。Java8で追加されたLambdaを「実装すべき抽象メソッドが一つしかないインタフェースを具現化したもの」と言いますが、ここでいう「実装すべき抽象メソッドが一つしかないインタフェース」のことが関数型インタフェースです。&lt;/p>
&lt;p>言葉として表現すると難しいですが、要は一つです。中身をLambdaで満たせて完成するインタフェース。様々なタイプのものがあって、ぞれぞれの特徴は少しづつ違いますが、どんなことがして欲しいかによって選択するものが違うだけで、実際はそんな難しくもないです。むしろ難しいと言えばLambdaの方かな…&lt;/p>
&lt;p>とにかくこれらの関数型インタフェースを、一つづつ紹介しましょう。&lt;/p>
&lt;h3 id="function">Function
&lt;/h3>&lt;p>Functionは、そのなの通り典型的な関数です。引数と戻り値を指定して宣言します。実行は&lt;code>apply(適用)&lt;/code>となります。コードで見ると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Integerが引数で、Stringが戻り値となる例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Function&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> function &lt;span style="color:#f92672">=&lt;/span> number &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String.&lt;span style="color:#a6e22e">valueof&lt;/span>(number);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Functionの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> function.&lt;span style="color:#a6e22e">apply&lt;/span>(12);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="bifunction">BiFunction
&lt;/h4>&lt;p>Function以外にも「Bi」が付くいくつかの関数型インタフェースがあります。何が違うかというと、そのなのとおり引数が二つ。他は元のものとほぼ一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 二つのStringが引数で、Integerが戻り値となる例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BiFunction&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> biFunction &lt;span style="color:#f92672">=&lt;/span> (string1, string2) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(string1) &lt;span style="color:#f92672">+&lt;/span> Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(string2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BiFunctionの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> biFunction.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="predicate">Predicate
&lt;/h3>&lt;p>先に紹介したものですね。&lt;code>Predicate&lt;/code>は「述語」の意味を持っています。その名の通り、「引数がTrueかFalseかを述べる」ようなものです。引数は一つです、戻り値がBooleanです。実行は&lt;code>test&lt;/code>です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数がStringの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Predicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> predicate &lt;span style="color:#f92672">=&lt;/span> string &lt;span style="color:#f92672">-&amp;gt;&lt;/span> string.&lt;span style="color:#a6e22e">isEmpty&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Predicateの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> predicate.&lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;空じゃない！&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="bipredicate">BiPredicate
&lt;/h4>&lt;p>引数が二つのPredicateです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数がStringの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BiPredicate&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> biPredicate &lt;span style="color:#f92672">=&lt;/span> (string, number) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> string.&lt;span style="color:#a6e22e">equals&lt;/span>(Integer.&lt;span style="color:#a6e22e">toString&lt;/span>(number));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BiPredicateの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> biPredicate.&lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>, 1);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="consumer">Consumer
&lt;/h3>&lt;p>&lt;code>Consume&lt;/code>は消費するという意味がありますね。引数を受けて戻り値はない(&lt;code>void&lt;/code>となる)ものです。実行するときは&lt;code>accept(受納)&lt;/code>となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数がStringの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Consumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> consumer &lt;span style="color:#f92672">=&lt;/span> string &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(string);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Consumerの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>consumer.&lt;span style="color:#a6e22e">accept&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;吸収！&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="biconsumer">BiConsumer
&lt;/h4>&lt;p>引数が二つのConsumerです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 引数がStringとIntegerの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BiConsumer&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> biConsumer &lt;span style="color:#f92672">=&lt;/span> (string, number) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(string &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> number);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BiConsumerの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>biConsumer.&lt;span style="color:#a6e22e">accept&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;今年儲かる確率は&amp;#34;&lt;/span>, 0);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="unaryoperator">UnaryOperator
&lt;/h3>&lt;p>&lt;code>Unary&lt;/code>は「単項」の意味。&lt;code>Operate&lt;/code>は作用するという意味を持っていますね。引数と戻り値が同じもので、引数に何かの操作をしてから返すという印象です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>UnaryOperator&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> uOperator &lt;span style="color:#f92672">=&lt;/span> string &lt;span style="color:#f92672">-&amp;gt;&lt;/span> string &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;完成されます&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UnaryOperatorの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> uOperator.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;この文字を入れると&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="binaryoperator">BinaryOperator
&lt;/h4>&lt;p>引数が二つのOperatorです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>BinaryOperator&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> biOperator &lt;span style="color:#f92672">=&lt;/span> (string1, string2) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> string1 &lt;span style="color:#f92672">+&lt;/span> string2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ではないです&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// BinaryOperatorの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> biOperator.&lt;span style="color:#a6e22e">apply&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;私は&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;大丈夫&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="supplier">Supplier
&lt;/h3>&lt;p>&lt;code>Supply&lt;/code>は「補給」の意味。Consumerとは真逆のもので、引数がなく戻り値だけがあるものです。実行は&lt;code>get&lt;/code>となります。引数がないためこちらはBiSupplierのようなインタフェースがないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Supplier&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> supplier &lt;span style="color:#f92672">=&lt;/span> () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;例えば引数なしで文字列が帰ってくる！&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Supplierの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> supplier.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>Java8が出てから数年、もうJavaも12までバージョンアップしています。でもまだJava8が使われている場面は多く、なるべくJava8の機能を最大限に活かしたコードを書きたいものですね。LambdaもStreamも難しいですが、Functionみたいにどこかで使うことになってまた今まではできなかったことをできるようになりたいです。&lt;/p>
&lt;p>今回も色々と勉強になりました。Javaの世界はまだまだ広くて奥深いものですね！&lt;/p></description></item><item><title>ReflectionとGenericを活用する</title><link>https://retheviper.github.io/posts/java-reflection/</link><pubDate>Tue, 30 Jul 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-reflection/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post ReflectionとGenericを活用する" />&lt;p>今回の仕事で学んだことは、自分のコードを他人がライブラリーとして使うときはどのように実装していくかの方法です。とある機能をするスクリプトを書くこと、エンドユーザーが使うUIやそコンテンツを処理するロジックなどだけに関わったことのない自分にとってはとても新しい経験になりました。今までだと自分が担当した機能を具現し、それを最適化していいだけでした。でも、ライブラリーは基本的にコードを扱える人が使うものなので設計が全く違いますね。&lt;/p>
&lt;p>そして、難しかった部分の一つは、柔軟性を持たせることでした。例えばデータを受け取り、処理していく中で、今までは自分が実装したBeanにデータがマッピングされていることを第一の前提条件としていました。それが今の仕事では、「どんなBeanが入ってくるかわからないから、それに対応する」ようにする必要がありました。&lt;/p>
&lt;p>まずクラスやインスタンスを引数として受け取る方法を知る必要がありますね。最初はObjectそのものを使おうと思いましたが、調べてみると&lt;code>Generic&lt;/code>というものがあったので、そちらを使うことにしました。&lt;/p>
&lt;p>次にそのGenericを使って、引数として受け取ったBeanです。自分が設計したBeanだけを使うなら、Beanが持つフィールドのデータ型も知っていいて、Getter/Setterからデータのやりとりができますね。しかし自分が作ったものではないと、フィールドのデータ型もGetter/Setterメソッドもどう呼ぶかもわからなくなります。ここでどう対応したらいいだろうか…と悩み、探し出した答えが&lt;code>Reflection&lt;/code>でした。&lt;/p>
&lt;p>今回のポストはその二つを使い、どう「自分が作っていないBeanを処理」したかについて述べ地と思います。&lt;/p>
&lt;h2 id="generic">Generic
&lt;/h2>&lt;p>Genericとは、「データのタイプを一般化」するということです。総称型とも呼ぶらしいです。クラスの中で使うタイプを、クラスの外部から設定するとき用いられると言いますね。今までは主に複数のデータ型やオブジェクトを処理したい場合は&lt;code>Object&lt;/code>を使ってきました。Javaでは一部のPrimitive(参照型)を覗くと、ほとんどのデータががオブジェクトとして扱われているので、もっとも上位のタイプであるObjectに変えられらからです。&lt;/p>
&lt;p>しかし、Objectを引数として使うと、メソッドの中のフィールドが何があるかわからなくなります。また、Getter/Setterによる値の指定・取得などの操作もできませんね。なのでオブジェクトそのものを受け取るだけでなく、インスタンスの中を直接覗く必要があります。&lt;/p>
&lt;p>ここでGenericを使うと、Objectと同じ機能(どんなインスタンスやクラスでも受け取れる)をしながらも、最初に具体的なタイプが決まるのでキャストがいらなくなります。これなら性能的にもよく、より安全な挙動を期待できますね。あとは実際どんな構造をしているかわからないObjectに対し、Reflectionを活用して、クラスやインスタンスの中を覗いたらメソッドもフィールドも取得できるというメリットもあります。&lt;/p>
&lt;p>まずインスタンスを引数として受け取る方法から見てみましょう。引数として&lt;code>T&lt;/code>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>を指定します。これでGenericタイプの引数を受け入れられます。つまり、インスタンス自体が引数となるということです。ただ、引数が&lt;code>T&lt;/code>の場合はメソッドの戻り値の前でも&lt;code>&amp;lt;T&amp;gt;&lt;/code>を宣言する必要があります。コードで表現すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Beanのインスタンスを受け取るメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (T parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BeanObject beanObject &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanObject();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (isBean(beanObject)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Listの中にもGenericを使うことができます。たとえば以下のように書くと、どんなタイプも受け入れられるようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インスタンスではなく、クラスそのものをGenericで受け入れるには以下のように書きます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Beanのクラスを受け取るメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 継承もできる(限定)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isStringBean&lt;/span> (Class&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> String&lt;span style="color:#f92672">&amp;gt;&lt;/span> parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (isBean(BeanObject.&lt;span style="color:#a6e22e">class&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 何かの処理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやってGenericの引数を渡してもらう準備は完了です。次は、そうやって受け取った引数を扱うReflectionについて調べてみましょう。&lt;/p>
&lt;h2 id="reflection">Reflection
&lt;/h2>&lt;p>クラスの具体的なタイプをわからなくても、メソッド・コンストラクター・フィールドなどににアクセスできるようにしてくれるAPIをReflectionと言います。取得したメソッド・コンストラクター・フィールドはいずれもそのまま使ったり、値(戻り値)を取得したり、つけられているアノテーションを取得するなど、普通のクラスでできることは全部できます。&lt;/p>
&lt;p>では、このReflectionを実際どう使うかを以下のコードで紹介します。まずはインスタンスからクラスを取得する方法と、さらに取得したクラスからコンストラクターを取得するコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (T object) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// インスタンスからクラスを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> objectClass &lt;span style="color:#f92672">=&lt;/span> object.&lt;span style="color:#a6e22e">getClass&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クラスからさらにインスタンスを生成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object instance &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">newInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クラスのパッケージ名を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">= &lt;/span>objectClass.getPackage();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// パッケージを含むクラス名を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Stirng classNamePackageInvolved &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クラス名だけを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String className &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getSimpleName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列でpublicコンストラクターたちをを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Constructor&lt;span style="color:#f92672">[]&lt;/span> constructors &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getConstructors&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のpublicコンストラクターを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Constructor constructor &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getConstructor&lt;/span>(parameter1, parameter2, ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 取得したコンストラクターからインスタンスを生成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object instance2 &lt;span style="color:#f92672">=&lt;/span> constructor.&lt;span style="color:#a6e22e">newInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>クラス自体を扱うことができるので、その中身がわかれば新しいインスタンスを生成して使うこともできますね。それでは次に、フィールドを取得する方法を紹介します。&lt;/p>
&lt;h2 id="fieldの取得">Fieldの取得
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (T object) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> objectClass &lt;span style="color:#f92672">=&lt;/span> object.&lt;span style="color:#a6e22e">getClass&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列でpublicフィールドたちを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field&lt;span style="color:#f92672">[]&lt;/span> fields &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getFields&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のpublicフィールドを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field field &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getField&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;フィールド名&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列で全フィールドたちを取得(public以外も)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field&lt;span style="color:#f92672">[]&lt;/span> declaredFields &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getDeclardFields&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のフィールドを取得(public以外も)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field declaredFiled &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getDeclaredField&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;フィールド名&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Fieldでできること&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドに値を設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field.&lt;span style="color:#a6e22e">set&lt;/span>(object, parameter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドの値を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String fieldValue &lt;span style="color:#f92672">=&lt;/span> field.&lt;span style="color:#a6e22e">get&lt;/span>(object);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドのアノテーションを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Annotation&lt;span style="color:#f92672">[]&lt;/span> annotations &lt;span style="color:#f92672">=&lt;/span> field.&lt;span style="color:#a6e22e">getAnnotations&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで注意すべき部分は、フィールドを取得するときはクラスからであって、実際値を代入したり取得するときはその対象としてインスタンスを使うということです。クラスが設計図であり、インスタンスがその設計図で生成されたものだということが明確になる瞬間ですね。Reflectionを使うことのメリットはここにもあるのかもしれません。&lt;/p>
&lt;p>次には、メソッドをみていきます。&lt;/p>
&lt;h2 id="methodの取得">Methodの取得
&lt;/h2>&lt;p>メソッドもフィールドの場合とそう変わりません。クラスからメソッドを取得し、そのメソッドからさらに色々できるようになります。またコードを以下に用意しました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isBean&lt;/span> (T objectClass) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> objectClass &lt;span style="color:#f92672">=&lt;/span> object.&lt;span style="color:#a6e22e">getClass&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列でpublicメソッドたちを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Method&lt;span style="color:#f92672">[]&lt;/span> methods &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getMethods&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のpublicメソッドを取得 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Method method &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getMethod&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;メソッド名&amp;#34;&lt;/span>, parameter1, parameter2, ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 配列でメソッドたちを取得(public以外も)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Method&lt;span style="color:#f92672">[]&lt;/span> declaredMethods &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getDeclaredMethods&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 特定のメソッドを取得(public以外も)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Method declaredMethod &lt;span style="color:#f92672">=&lt;/span> objectClass.&lt;span style="color:#a6e22e">getDeclaredMethod&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;メソッド名&amp;#34;&lt;/span>, parameter1, parameter2, ...);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Methodでできること&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// メソッド名の取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String methodName &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">getName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// メソッドの実行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object methodInvoked &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">invoke&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 引数のアノテーションを取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Annotation&lt;span style="color:#f92672">[]&lt;/span> parameterAnnotations &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">getParameterAnnotations&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 引数を取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Parameter&lt;span style="color:#f92672">[]&lt;/span> parameters &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">getParameters&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>アノテーションの場合はクラスでもフィールドでも取得できますが、メソッドの場合はそれに加えて引数のアノテーションも取得できるということが特徴です。また、引数そのものを取得することもできますね。もちろん&lt;code>Parameter&lt;/code>クラスでも引数名を取得するなど色々な操作ができます。&lt;/p>
&lt;h2 id="結論">結論
&lt;/h2>&lt;p>結局、道が見えてくると、解決の方法も見えてくるものです。メソッドをやコンストラクターに触れる必要もなく、引数で受け取ったインスタンスからフィールドを取得して、その値をObjectに代入する。そしてinstanceofを活用して分岐させ、キャストすることでデータを扱う、というシンプルな構造で自分のタスクは完成されました。簡単なコードで表現すると以下のような形ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// クラスをわからないBeanを引数とするメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">processSomething&lt;/span>(T bean) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 複数のタイプのオブジェクトがある&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String stringObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Integer intObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// クラスとフィールドの取得&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> beanClass &lt;span style="color:#f92672">=&lt;/span> bean.&lt;span style="color:#a6e22e">getClass&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field&lt;span style="color:#f92672">[]&lt;/span> beanFields &lt;span style="color:#f92672">=&lt;/span> beanClass.&lt;span style="color:#a6e22e">getDeclardFields&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ループで個別フィールドを取得し、一致するタイプのオブジェクトにフィールドの値を入れる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Field field : beanFields) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// privateフィールドの場合はアクセスできない場合があるためアクセス可能にする&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (field.&lt;span style="color:#a6e22e">canAccess&lt;/span>(bean)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field.&lt;span style="color:#a6e22e">setAccessible&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// フィールドの値を取得し、型を判断&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object value &lt;span style="color:#f92672">=&lt;/span> field.&lt;span style="color:#a6e22e">get&lt;/span>(bean);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (value &lt;span style="color:#66d9ef">instanceof&lt;/span> String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stringObject &lt;span style="color:#f92672">=&lt;/span> (String)value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (value &lt;span style="color:#66d9ef">instanceof&lt;/span> Integer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> intObject &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)value();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>どうですか。方法がわかれば簡単にできるものなのでは。さらに応用して、インスタンスの一部の値だけを修正して返すなどの挙動もできそうです。色々活用できそうな面が多いですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>このようにだいたいフィールドとメソッドがわかれば、これでどんなインスタンスやクラスが入ってきても、対応できそうな気がします。実際どうかはコンパイルして実行してみない限りわからないものですが…でも一つ、賢くなったような気はします。皆さんもぜひ、Reflectionを通じてクラスとインスタンスに対する理解を深めてみてください。&lt;/p>
&lt;p>それでは、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Typeのこと。ただ、E(Element)やK(Key)、N(Number)、V(Value)も使えるらしいです。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>デザインパターン、Builder</title><link>https://retheviper.github.io/posts/java-design-pattern-builder/</link><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/java-design-pattern-builder/</guid><description>&lt;img src="https://retheviper.github.io/images/java.jpg" alt="Featured image of post デザインパターン、Builder" />&lt;p>以前、自分より開発者として日本就職が早かった大学の後輩がいて、どんな言語やフレームワークを勉強した方がいいかを聞いたことがあります。周りではC#をやるといい、ReactやNode.jsのような流行りのライブラリーを学んだ方がいいという人もいましたが、現場で使われている人の意見が聞きたかったからです。そして彼は、言語やフレームワークはメインとしている言語をマスターしたらいつでも変えられるもので、実質的に必要となるスキルはデザインパターンと言っていました。&lt;/p>
&lt;p>それから本を買い、いくつかのデザインパターンを見たことはありますが、そのパターンたちをどう使ったらいいか一人で考えるのは難しいことでした。一人でコードを書く時は、自分が理解できるコードを書けばいいだけなのでそこまで考える余裕が無くなりますね。また、エンドユーザーだけを意識したコードになりがちだったのであまりパターンを含むコードの書き方をする必要もなかったです。&lt;/p>
&lt;p>それが今はJavaでのフレームワーク開発に関わることとなり、自分の買いたコードを違う人が使えるように書けとの指示を受けましたが、いつも通りDTOを元とするWrapperクラスを生成して行けばいいのかなと思っていたら、実装してみてからはこれはダメだなと感じました。なぜなら数十から数百に至る変数の設定値があって、引数として渡すのも単純な数字や文字などではなかったからです。自分の作ったコードが使う側として接した場合は、これはダメと思うはず。&lt;/p>
&lt;p>どう改善したらいいかと悩んでいたら、指示を出した方からBuilderパターンを使うといいだろうというアドバイうをもらいました。これなら引数は最低限にして、直観的に使えるらしいです。なので実際使ってみました。そして伝統的なDTOと比べてみると、確かになと思いましたね。何が違ってなぜ違うのかを、DTOとBuilderパターンの比べでこれから述べたいと思います。&lt;/p>
&lt;h2 id="telescoping-constructor-pattern">Telescoping Constructor Pattern
&lt;/h2>&lt;p>テレスコープとは望遠鏡のこと。どこが望遠鏡的かというと、だんだん伸びていくコンストラクターの形が望遠鏡の伸縮みたいでこんな名前になったようです。最近はJava Beanの中でもよく使われるパターンなのですね。オブジェクトを生成する時に引数の数によって値を入れる変数の数を調節できます。Method Overloading&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>で複数のコンストラクターを用意するだけです。&lt;/p>
&lt;p>例えばカフェでコーヒーを注文する過程を、Javaのクラスで具現化するとしましょう。カップのサイズ、ホットかアイスか、シロップは入れるか、クリームは入れるか…様々なオプションがありますね。これをTelescoping Constructor Patternで書くと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(size, hot, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot, &lt;span style="color:#66d9ef">boolean&lt;/span> addCream){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(size, hot, addCream, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot, &lt;span style="color:#66d9ef">boolean&lt;/span> addCream, &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(size, hot, addCream, addSugar, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot, &lt;span style="color:#66d9ef">boolean&lt;/span> addCream, &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar, &lt;span style="color:#66d9ef">boolean&lt;/span> takeout){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span> &lt;span style="color:#f92672">=&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span> &lt;span style="color:#f92672">=&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでオーダを定義するクラスが一つ、できました。実際使ってみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cafe&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オーダーごとのオブジェクトを生成する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(&lt;span style="color:#e6db74">&amp;#34;tall&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(&lt;span style="color:#e6db74">&amp;#34;grande&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_3 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(&lt;span style="color:#e6db74">&amp;#34;venti&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(&lt;span style="color:#e6db74">&amp;#34;tall&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このパターンのよくない点は、オブジェクトを生成する時、引数の意味を分かりにくいという点です。実際クラスの中身をみないと、連続している&lt;code>false&lt;/code>や&lt;code>true&lt;/code>の意味が分かりませんね。そして例えば、サイズとシロップだけを引数として入れたい場合は、それに合わせてまたコンストラクターを作成しなければならないです。変数が増えれば増えるほど、それに合わせコンストラクターを用意する必要があるという問題もあります。あとでオーダーのオプションが増えたり減ったりするとそれに対応するのが難しいですね。&lt;/p>
&lt;h2 id="java-bean-dtovo">Java Bean, DTO(VO)
&lt;/h2>&lt;p>JavaでOOP&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>の概念を学ぶ時、初めて接したのがこの&lt;code>Java Bean&lt;/code>です。これも一つのパターンと言えますね。みなさんがよく知っているよう、&lt;code>Getter&lt;/code>と&lt;code>Setter&lt;/code>で値を渡すパターンです。同じくオーダーのクラスを作ってみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(){}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setSize&lt;/span>(String size){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getSize&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setHot&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> hot){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span> &lt;span style="color:#f92672">=&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getHot&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setAddCream&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> addCream){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getAddCream&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setAddSugar&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> addSugar){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getAddSugar&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">setTakeout&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> takeout){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span> &lt;span style="color:#f92672">=&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">getTakeout&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンストラクターとして引数を受け取るパターンも含める場合はありますが、Java Beanとしての特徴はこのGetterとSetterにあるので、ここでは省略。では同じく、これでオーダーを生成してみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cafe&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オーダーの内容はSetterで設定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_1.&lt;span style="color:#a6e22e">setSize&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tall&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_1.&lt;span style="color:#a6e22e">setHot&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_2.&lt;span style="color:#a6e22e">setSize&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;grande&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_2.&lt;span style="color:#a6e22e">setHot&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_2.&lt;span style="color:#a6e22e">setAddCream&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さっきよりは個別項目ごとに値を設定することができ、それぞれのSetterをみてどんなオーダーを出しているのかがより明確になりますね。また変数が増えてもそれに合わせてGetterとSetterを用意するだけで良いです。&lt;/p>
&lt;p>ただ、一つの注文を完成する時、オプションの数が増えると無題に長いコードになってしまうという問題がありますね。今は5つのフィールドを使っているだけですが、もし20、30のオプションがあったら？それをいちいち書くのはかなり時間もかかることですね。私が失敗したのはこの部分でした。なのでBuilderを使い、この問題を解決してみます。&lt;/p>
&lt;h2 id="builder-pattern">Builder Pattern
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>(Stirng size, &lt;span style="color:#66d9ef">boolean&lt;/span> hot, &lt;span style="color:#66d9ef">boolean&lt;/span> addCream, &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar, &lt;span style="color:#66d9ef">boolean&lt;/span> takeout){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span> &lt;span style="color:#f92672">=&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span> &lt;span style="color:#f92672">=&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Builder &lt;span style="color:#a6e22e">builder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Builder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Builder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Builder&lt;/span>(){}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">size&lt;/span>(String size){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span> &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">hot&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> hot){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span> &lt;span style="color:#f92672">=&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">addCream&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> addCream){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">addSugar&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> addSugar){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span> &lt;span style="color:#f92672">=&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">takeout&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> takeout){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span> &lt;span style="color:#f92672">=&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrder &lt;span style="color:#a6e22e">build&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder(size, hot, addCream, addSugar, takeOut);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Inner Classも入り、何か複雑になったように見えますが、実際使ってみるとそうでもないです。このようなBuilderクラスを使うとどうなるのか、また確認してみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cafe&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// オーダーを生成してBuilderを使う&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order_1.&lt;span style="color:#a6e22e">Builder&lt;/span>().&lt;span style="color:#a6e22e">size&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;tall&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">hot&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CoffeeOrder order_2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrder().&lt;span style="color:#a6e22e">Builder&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">size&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;grande&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">hot&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addCream&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">takeout&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Setterと似たような使い方で、一回だけで複雑なオプションを全部処理できます。また、生成と同時にもオーダーを完成できます。Builderが戻り値として自分自身を使っていて、連続してメソッドを呼び出すことができるからです。これならいくら変数が増えても対応できますね！&lt;/p>
&lt;h2 id="lombokを使う">Lombokを使う
&lt;/h2>&lt;p>以上のパターンは&lt;a class="link" href="https://projectlombok.org" target="_blank" rel="noopener"
>Lombok&lt;/a>を使うとアノテーションだけで設定できるらしいです。例えばコンストラクターは&lt;code>@NoArgsConstructor&lt;/code>や&lt;code>@RequiredArgsConstructor&lt;/code>、&lt;code>@AllArgsConstructor&lt;/code>でできます。Java Beanなら&lt;code>@Data&lt;/code>をつけることでGetterとSetterができるらしいですね。また、Builderの場合は&lt;code>@Builder&lt;/code>でできると言います。以下はLombokを使った場合の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> lombok.Builder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに&lt;code>@Builder(toBuilder = true)&lt;/code>にすると、インスタンスの新規生成では&lt;code>CoffeOrder.builder()&lt;/code>から直接Builderにアクセスできるようになります。また、既存のインスタンスの値を受け継ぐ場合は&lt;code>order_1.toBuilder()&lt;/code>を使えるようになります。実際は以下のコードになるようなものとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> lombok.Builder;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>(toBuilder &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CoffeeOrder&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> hot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addCream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> addSugar;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> takeout;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... 基本的なBuilder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CoffeeOrderBuilder &lt;span style="color:#a6e22e">toBuilder&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CoffeeOrderBuilder().&lt;span style="color:#a6e22e">size&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>).&lt;span style="color:#a6e22e">hot&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">hot&lt;/span>).&lt;span style="color:#a6e22e">addCream&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addCream&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addSugar&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">addSugar&lt;/span>).&lt;span style="color:#a6e22e">takeout&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">takeout&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてBuilderを使うとき、親クラスのフィールドをそのまま継承したい場合はフィールドに&lt;code>@Builder.Default&lt;/code>をつけることでそのまま受け継がれます。他にもフィールドにつけてアクセスレベルを指定できるなど便利な機能が多いので、ぜひ使いたいものですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>デザインパターンの種類に何があって、どんな構造をしているかを把握することも大事ですが、何より大事なことは適材適所に使えることではないかと思いました。最初から自分がBuilderパターンを知っていたとしても、それを使ったらいいと言われなかったら果たして使おうとしていただろうかと思うと、そうでもないような気がしますね。なのでこれからはデザインパターン自体の研究とともに、それをどの場合に使えるかという面から考察していきたいと思います。&lt;/p>
&lt;p>それでは、また会いましょう！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>引数の数や種類を変えることで、同名のメソッドを複数作成する記法。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Object Oriented Programing.オブジェクト指向プログラミングとも言いますね。コードをひたすら上から下まで流れる処理として扱うのではなく(手続き型プログラミング)、隔離されたオブジェクト間のデータ交換として成立するプログラミングのパラダイムです。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>