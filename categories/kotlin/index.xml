<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kotlin on Korean-man in Tokyo</title><link>https://retheviper.github.io/categories/kotlin/</link><description>Recent content in kotlin on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 25 May 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/categories/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>KotlinConf'24を要約してみた</title><link>https://retheviper.github.io/posts/kotlin-conf-2024/</link><pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-conf-2024/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinConf'24を要約してみた" />&lt;p>今年のKotlinConfが開催されました。数日かけてのイベントなので、全てのセッションを見ることはできませんが、まずはキーノートの方で重要な情報をまとめてみました。全体のスケージュールは&lt;a class="link" href="https://kotlinconf.com/schedule/" target="_blank" rel="noopener"
>こちら&lt;/a>から確認できて、&lt;a class="link" href="https://www.youtube.com/@Kotlin/streams" target="_blank" rel="noopener"
>YouTubeでのライブ配信&lt;/a>も行われているので、興味がある方はぜひチェックしてみてください。&lt;/p>
&lt;p>まずはKotlinConf'24の公式アプリの紹介がありました。公式アプリでは今回行われるカンファレンスとセッションを確認できるもので、&lt;a class="link" href="https://github.com/JetBrains/kotlinconf-app" target="_blank" rel="noopener"
>GitHubにてソースコードを公開&lt;/a>しています。Kotlin Multiplatformで作成されていて、iOS、Android、Webで動作するものなので、いいサンプルとして使えるかもしれません。&lt;/p>
&lt;h2 id="kotlinの今">Kotlinの今
&lt;/h2>&lt;p>まずはKotlinの現状から。常にKotlinを使っているエンジニアの数が、200万以上になっているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage_hub3ba13be49a6828c9de3715db7f23862_72520_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage_hub3ba13be49a6828c9de3715db7f23862_72520_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Kotlinエンジニア数"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>また、Kotlinを導入している企業もどんどん増えているとのことです。代表的な企業は以下の画像通りだそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies_huc6aef245febedaeb6032b72a98ba9331_80568_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-usage-companies_huc6aef245febedaeb6032b72a98ba9331_80568_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Kotlin導入企業"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="kotlin-20-and-k2-compiler">Kotlin 2.0 and K2 Compiler
&lt;/h2>&lt;p>Kotlin 2.0からはK2コンパイラーの導入により、全般的にコンパイルの速度が向上したという話が主なテーマです。ただ一部プロジェクトでは、遅くなるケースもあるとのことでした。また、IntellijでもK2コンパイラーモードがあり、コードハイライトが1.8倍速くなるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance.webp"
width="2056"
height="1216"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance_hua6710ccce01267c60da264e401c19c35_103860_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/k2-mode-performance_hua6710ccce01267c60da264e401c19c35_103860_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="K2コンパイラーの速度比較"
class="gallery-image"
data-flex-grow="169"
data-flex-basis="405px"
>&lt;/p>
&lt;p>K2モードは、Intellij 2024.1以上から以下の設定画面で設定できます。2024.2からは性能の改善を含め、Beta版として提供される予定です。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode.webp"
width="2188"
height="1668"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode_hucd6e39bb5bcd2b2433dcb028dd68479a_110960_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/intellij-k2-mode_hucd6e39bb5bcd2b2433dcb028dd68479a_110960_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="IntellijのK2モード設定画面"
class="gallery-image"
data-flex-grow="131"
data-flex-basis="314px"
>&lt;/p>
&lt;p>2.0へのマイグレーションは1000万行のコード、18000人のエンジニア、80000のプロジェクトでテストされていて、1.9からのマイグレーションはスムーズに行えるとのことです。&lt;/p>
&lt;h3 id="metaの場合">Metaの場合
&lt;/h3>&lt;p>Metaの場合、Kotlin firstでの開発を積極的に進めているとのことでした。IDEからコードの最適化までの全てにおいてKotlinを採用して、既存のJavaで作成されたFacebook, Instagram, Facebook Messenger, WhatsAppなどのアプリにおいて、Kotlinに自動変換できるツールを作成して移行を自動化しているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin_huab5088ae8b08c67c58940e3fa4ffa242_82010_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/meta-kotlin_huab5088ae8b08c67c58940e3fa4ffa242_82010_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="MetaのKotlin採用"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>そしてMetaはKotlin 1.8の時点から一部のプロジェクトにおいてすでにK2コンパイラーを採用していて、今は95%のプロジェクトがK2コンパイラーを使っているとのことです。その効果としてはAndroidプロジェクトにおいては最大20%のビルド時間の短縮ができたらしいです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler_hud72c3bd8dc71c7ee89a72db16853cc87_87106_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/meta-k2-compiler_hud72c3bd8dc71c7ee89a72db16853cc87_87106_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="MetaのK2コンパイラー採用"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="googleの場合">Googleの場合
&lt;/h3>&lt;p>K2コンパイラーにはGoogle側も協力していて、Androidのツーリングに関してLintや&lt;a class="link" href="https://developer.android.com/kotlin/parcelize?hl=ja" target="_blank" rel="noopener"
>Parcelize&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/docs/ksp-overview.html" target="_blank" rel="noopener"
>KSP&lt;/a>などにもコントリビュートしているそうです。また、Jetpack Composeのコンパイラーの改善もあり、従来はKotlinとバージョンと相違があったのですが、2.0からは同じバージョンで指定できるようになったとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update_hu7fd259c25ed8e5eca2338d777d8a309f_80422_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/compose-compiler-update_hu7fd259c25ed8e5eca2338d777d8a309f_80422_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Composeコンパイラーのバージョン指定"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>またAndroid StudioでもKotlin 2.0のサポートを予定しているとのことでした。代表的な機能は以下の画像の通りです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0_huf6b6d7263a6bedddd389a0740fc0f2f5_97080_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/android-kotlin-2.0_huf6b6d7263a6bedddd389a0740fc0f2f5_97080_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="AndroidのKotlin 2.0サポート"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Jetpack Composeにおいても新しい機能を追加される予定だそうです。主に以下の画像で挙げている機能が、7月から提供される予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming_hu21ad215560a306b28dc706633ddd07ef_87466_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-upcoming_hu21ad215560a306b28dc706633ddd07ef_87466_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Jetpack Composeの追加予定機能"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>コンパイラーそのものの改善もあり、安定性やパフォーマンスが向上しているとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance_hu8104ee915afa4dbf564f1e1f8e9ada01_82306_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-performance_hu8104ee915afa4dbf564f1e1f8e9ada01_82306_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Jetpack Composeの性能改善"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>他にも、Google内部ではサーバサイドKotlinの採用も進んでいたり、KMPによる開発も進んでいるとのことでした。あとはJetpack ComposeのライブラリもMultiplatformに対応していて、ViewModelやRoomなどのライブラリもKotlin Multiplatformで使えるようになったとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform_hu184b7352b4d801225a477076fb3871bb_93470_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/jetpack-compose-multiplatform_hu184b7352b4d801225a477076fb3871bb_93470_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Jetpack ComposeのMultiplatform対応"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="kotlin-multiplatform">Kotlin Multiplatform
&lt;/h2>&lt;p>K2コンパイラーの導入により、Kotlinのコードを直接Swiftのコードに変換することができるようになったとのことです。これにより、iOSアプリの開発においてもKotlin Multiplatformを使って開発することができるようになりました。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift_hu36f0b70d6e09af0f70082a80b24d77fa_80636_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-to-swift_hu36f0b70d6e09af0f70082a80b24d77fa_80636_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="KotlinのSwift変換"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>そして&lt;a class="link" href="https://www.jetbrains.com/ja-jp/fleet/" target="_blank" rel="noopener"
>Fleet&lt;/a>で、iOSアプリも開発できるという紹介もありました。FleetだとCompose MultiplatformによるiOSとAndroidのアプリ開発が同時に可能で、リファクタからデバッグまで一貫して開発できるとのことです。AppCodeのサポートが2023年に終了となっていたので、これは嬉しいニュースですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development_hu0d5bfc4b1237efd7f31684765c0b1bff_96184_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/fleet-multiplatform-development_hu0d5bfc4b1237efd7f31684765c0b1bff_96184_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="FleetでのMultiplatform開発"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>また、新しいビルドツールである&lt;a class="link" href="https://github.com/JetBrains/amper" target="_blank" rel="noopener"
>Amper&lt;/a>も紹介されました。まだ発表されてから間もないのですが、すでにJetBrainsのIDEでサポートされていて、YAMLファイルだけでビルド設定を行うことができるので、新しいプロジェクトで使ってみるのもいいかもしれません。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/amper.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/amper_hu6e4361bc5fcbb127fffd2cd06f8d9ee0_93446_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/amper_hu6e4361bc5fcbb127fffd2cd06f8d9ee0_93446_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Amperの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Compose Multiplatformにおいても、以下の新しい機能が追加されたらしいです。どれも期待していた機能だったので、嬉しいですね。個人的にはデスクトップアプリでファイルの選択ダイアログを実装した時に、対応する機能がなくJavaのAWTを使わざるを得なかったので、このようなAPIもあるといいなと思っています。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform_hu1ec0861aeaca3268d9d904f6b2bc1845_76646_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/compose-multiplatform_hu1ec0861aeaca3268d9d904f6b2bc1845_76646_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Compose Multiplatformの新機能"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="upcoming">Upcoming
&lt;/h2>&lt;p>次に、Kotlin 2.1のベータ版から導入予定の機能について紹介や、新しいライブラリ、AIモデルの発表がありました。以下の画像の通りです。&lt;/p>
&lt;h3 id="guard">Guard
&lt;/h3>&lt;p>whenの分岐で、変数の重複を防ぐための機能です。既存のコードなら、以下のようなコードで&lt;code>status&lt;/code>が重複する場合があっても、どうしようもなかったですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">render&lt;/span>(status: Status): String =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Loading &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Loading&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.isEmpty() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;No data&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">-&amp;gt;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.joinToString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Error &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.isCritical &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Critical problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unknown problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なぜなら、以下のようにコードを変えた場合に&lt;code>and&lt;/code>でコンパイルエラーが発生してしまうからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">render&lt;/span>(status: Status): String =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (status) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Status&lt;/span>.Loading &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Loading&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.isEmpty() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;No data&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Error: expecting &amp;#39;-&amp;gt;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.OK &lt;span style="color:#f92672">-&amp;gt;&lt;/span> status.&lt;span style="color:#66d9ef">data&lt;/span>.joinToString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">Status&lt;/span>.Error &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> status.isCritical &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Critical problem&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Error: expecting &amp;#39;-&amp;gt;&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unknown problem&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを改善するため、以下のように&lt;code>Guarded Condition&lt;/code>を導入する予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard_hu9521d200448d3c4a99eb6ca76abb58d4_87392_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-guard_hu9521d200448d3c4a99eb6ca76abb58d4_87392_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Guardの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="-escaping-problem">$-escaping problem
&lt;/h3>&lt;p>Kotlinで&lt;code>$&lt;/code>は、文字列の中で変数を埋め込むために使われています。ということは、&lt;code>$&lt;/code>を文字列として使いたい場合にエスケープの問題が発生するとのことでもあります。特にMulti-line Stringがそうですね。例えば、以下の例があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jsonSchema: String = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$schema&amp;#34;: &amp;#34;https://json-schema.org/draft/2020-12/schema&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$id&amp;#34;: &amp;#34;https://example.com/product.schema.json&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;$dynamicAnchor&amp;#34;: &amp;#34;meta&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;title&amp;#34;: &amp;#34;Product&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>schema&lt;/code>や&lt;code>id&lt;/code>などは変数ではなく、文字列として使いたい場合がありますが、Multi-line Stringの場合にはエスケープができません。なので、以下のようなコードになるケースもありました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jsonSchema: String = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}schema&amp;#34;: &amp;#34;https://json-schema.org/draft/2020-12/schema&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}id&amp;#34;: &amp;#34;https://example.com/product.schema.json&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;${&amp;#39;$&amp;#39;}dynamicAnchor&amp;#34;: &amp;#34;meta&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;title&amp;#34;: &amp;#34;Product&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">}&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを解決するために、文字列リテラルで&lt;code>$&lt;/code>を2回入れることでinterpolationできるようにする、という機能が導入される予定だそうです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape_hu3203318b61bb42e5c5916a550c5b226c_89156_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/dollar-escape_hu3203318b61bb42e5c5916a550c5b226c_89156_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="$-escaping problemの解決"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="non-local-breakcontinue">Non-local break/continue
&lt;/h3>&lt;p>今までは、コンパイラーがLambdaが実行される場所を特定できないため、&lt;code>break&lt;/code>や&lt;code>continue&lt;/code>が使えなかったです。なので、以下のようなコードはエラーになってしまいます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0.&lt;/span>.n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> date = state[i]&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span> &lt;span style="color:#75715e">// Error: &amp;#39;break&amp;#39; is not allowed here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">continue&lt;/span> &lt;span style="color:#75715e">// Error: &amp;#39;continue&amp;#39; is not allowed here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> process(&lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これもまた、Kotlin 2.1からは&lt;code>let&lt;/code>のようなinline関数を正しく解析できるようになるため、&lt;code>break&lt;/code>や&lt;code>continue&lt;/code>が使えるようになるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/non-local-break-and-continue.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/non-local-break-and-continue_hu766f193d8d364f9bdab4981ddfd09b63_70996_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/non-local-break-and-continue_hu766f193d8d364f9bdab4981ddfd09b63_70996_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Non-local break/continueの解決"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="contexts">Contexts
&lt;/h3>&lt;p>去年発表された&lt;code>Context&lt;/code>についても発表がありました。これはすでにプレビューとして導入されていて、Kotlin 2.2からはベータ版として提供される予定だそうです。これでDIと似たようなことをしたり、セッションやトランザクションなど色々な関数で使い回す必要があるものは、関数の引数に渡すことなく、&lt;code>Context&lt;/code>を使って共有することができるようになります。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/contexts.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/contexts_hu56f3d437804e5230ee0dd5ddb1a1b5e9_81618_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/contexts_hu56f3d437804e5230ee0dd5ddb1a1b5e9_81618_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Contextの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="core-libraries">Core Libraries
&lt;/h3>&lt;p>Kotlinのコアライブラリも改善される予定だそうです。すでに発表されている&lt;a class="link" href="https://github.com/Kotlin/kotlinx-io" target="_blank" rel="noopener"
>kotlinx.io&lt;/a>のようなものだけでなく、&lt;a class="link" href="https://github.com/Kotlin/kotlinx-rpc" target="_blank" rel="noopener"
>kotlinx.rpc&lt;/a>のような新しいライブラリの発表もありました。これらのコアライブラリは、Multiplatformでの開発をサポートするために提供されるもので、どのプラットフォームでも使えるものです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries_hu4860cf71836d2df4ff0406de789a76fb_79312_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/core-libraries_hu4860cf71836d2df4ff0406de789a76fb_79312_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Core Librariesの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="aws-sdk-for-kotlin">AWS SDK for Kotlin
&lt;/h3>&lt;p>Kotlin用のAWS SDKも提供される予定という発表もありました。今まではJavaのSDKを使うことが多かったのですが、CoroutineやNull SafetyのようなKotlinの特徴を活かせつつ、Multiplatformで使えるSDKが提供されるとのことです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk_hude1a88b155c3317ae0d889e904fff447_88676_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/aws-kotlin-sdk_hude1a88b155c3317ae0d889e904fff447_88676_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="AWS SDK for Kotlinの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h3 id="kotlin-language-model">Kotlin Language Model
&lt;/h3>&lt;p>Fleetではすでに利用可能で、Intellijでは2024.2から利用可能となるKotlinの言語モデルが開発中のことです。既存のいくつかのモデルと比べ、Kotlinに特化されたからか、比較的パラメータの数が少ないことに比べ、ベンチマークでは高い精度を示しているとのことです。ただ、比較で使っているLlamaの場合はすでにバージョン3がリリースされているので、最新のモデルと比べる場合どの程度の精度があるのかは気になるところです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model_hu6e0fd101ad4ac706498eb15da5bb2442_84954_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2024/kotlin-language-model_hu6e0fd101ad4ac706498eb15da5bb2442_84954_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Kotlin Language Modelの紹介"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>KotlinConf'24のキーノートでの発表内容を以上でまとめてみました。他にも多くのセッションがあ理、Kotlin 2.0も&lt;a class="link" href="https://github.com/JetBrains/kotlin/releases/tag/v2.0.0" target="_blank" rel="noopener"
>Changelog&lt;/a>を見ると、多くの変更があるので、また色々とチェックしていきたいところですね。&lt;/p>
&lt;p>Composeの発展も良かったのですが、Flutterのような他のフレームワークもあるのでこれからどれだけのシェアを取れるかが楽しみです。言語としても他の言語の発展も早いので、Kotlinも引けを取らないように頑張ってほしいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その四〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-4/</link><pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-4/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その四〜" />&lt;p>しばらくKotlinで書いてみたシリーズを書いていなかったので、今回はその四です。&lt;/p>
&lt;h2 id="listをlistでソート">ListをListでソート
&lt;/h2>&lt;p>データ構造として、ListをListでソートしたい場合がありますね。例えばとあるテーブルに対して、別のテーブルのIDを持たせている場合などです。このテーブルのIDを配列にして、並び順を表現しているとしたら、この配列を元にソートしたいことになります。&lt;/p>
&lt;p>もちろんクエリでソートすることもできますが、クエリでソートすると、ソートした結果をキャッシュできないというデメリットがあります。そこで、ListをListでソートする方法を考えてみました。&lt;/p>
&lt;p>まずは以下のようなデータがあるとします。イメージとしては、複数の画像を持つImageBoxというデータがあり、そのImageBoxのimageOrderにはImageのIDが配列として入っているとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ImageBox&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> title: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> imageOrder: List&amp;lt;Int&amp;gt; &lt;span style="color:#75715e">// imageのIDの配列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Image&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> url: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでDBとしてはImageBoxテーブルとImageテーブルがあり、ImageBoxテーブルのimageOrderにはImageテーブルのIDが配列として入っているとします。そしてアプリではImageBoxのimageOrderの順番にImageを表示したいとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> imageBox = ImageBox(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title = &lt;span style="color:#e6db74">&amp;#34;title&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> imageOrder = listOf(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> images = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">1&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url1&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">2&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url2&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">3&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url3&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">4&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url4&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Image(id = &lt;span style="color:#ae81ff">5&lt;/span>, url = &lt;span style="color:#e6db74">&amp;#34;url5&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、以下のようにソートすることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// imageBoxのimageOrderのをIndexをkeyとするMapに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> indexMap = imageBox.imageOrder.mapIndexed { index, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span> to index }.toMap()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// imagesをimageOrderを元にソート
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> sortedImages = images.sortedBy { indexMap[&lt;span style="color:#66d9ef">it&lt;/span>.id] }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原理は簡単で、imageOrderの配列をIndexとvalueのMapに変換して、その値を元にソートしているだけです。この方法であれば、クエリでソートすることなく、imageOrderの順番にソートすることができます。&lt;/p>
&lt;p>また、こういったソートは以下のように拡張関数として定義すると、他の場所でも使い回すことができます。anotherには並び順を表現する配列を渡して、keySelectorにはソートしたい配列の要素から並び順の基準となる値を取り出す関数を渡します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">U&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.sortedBy(another: List&amp;lt;U&amp;gt;, keySelector: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> U): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> indexMap = another.mapIndexed { index, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span> to index }.toMap()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.sortedBy { indexMap[keySelector(&lt;span style="color:#66d9ef">it&lt;/span>)] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> sortedImages = images.sortedBy(imageBox.imageOrder) { &lt;span style="color:#66d9ef">it&lt;/span>.id }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>keySelectorでitすら省略したい場合は、以下のような方法もあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">U&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.sortedBy(another: List&amp;lt;U&amp;gt;, keySelector: &lt;span style="color:#a6e22e">T&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> U): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> indexMap = another.mapIndexed { index, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span> to index }.toMap()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.sortedBy { indexMap[keySelector(&lt;span style="color:#66d9ef">it&lt;/span>)] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> sortedImages = images.sortedBy(imageBox.imageOrder) { id }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="listのページング">Listのページング
&lt;/h2>&lt;p>ページングはよくDBのクエリで行いますが、クエリでなくコードのみで処理したい場合もありますね。例えば、外部APIに対してリクエストを送る場合などです。この場合、ページングをどう実装するかが課題になります。&lt;/p>
&lt;p>この場合は以下のように拡張関数を定義することで、Listのページングを実装することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.paginated(offset: Int, limit: Int): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ページングが必要ない場合はそのまま返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (offest &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> limit &amp;lt; size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ページングが必要な場合はoffsetとlimitを元にsubListを取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> fromIndex = (offset - &lt;span style="color:#ae81ff">1&lt;/span>) * limit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">&amp;lt;=&lt;/span> fromIndex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ページングの範囲外の場合は空のリストを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ページングの範囲内の場合はsubListを返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> toIndex = size.coerceAtMost(fromIndex + limit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> subList(fromIndex, toIndex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>細かいものとしては&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-at-most.html" target="_blank" rel="noopener"
>coerceAtMost()&lt;/a>を使って、sizeより大きい値を渡された場合はsizeを返すようにしています。これはもちろんIndexOutOfBoundsExceptionを防ぐためです。&lt;/p>
&lt;h2 id="exposed">Exposed
&lt;/h2>&lt;p>厳密にいって&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>はORMなのですが、Kotlinの書き方によってさらに便利になる部分もあるので今回はこちらも紹介したいと思います。&lt;/p>
&lt;h3 id="insertとupdateの共通化">InsertとUpdateの共通化
&lt;/h3>&lt;p>ExposedでInsertやUpdateを書くのはかなり直感的なのですが、多くの場合にInsertとUpdateで同じ処理を書くことになります。そこで、InsertとUpdateの共通化を考えてみました。例えば以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">insert&lt;/span>(image: Image): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.insert {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[id] = image.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[url] = image.url
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[title] = image.title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[description] = image.description
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(image: Image): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.update({ &lt;span style="color:#a6e22e">ImageTable&lt;/span>.id eq image.id }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[url] = image.url
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[title] = image.title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[description] = image.description
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、InsertとUpdateではID以外だとurlやtitleのような値をセットするという面では同じ処理を書いているだけですね。テーブルが増えれば増えるほど、このようなコードも増えていきます。幸いExposedではUpdate時の&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/main/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/statements/UpdateBuilder.kt" target="_blank" rel="noopener"
>UpdateBuilder&lt;/a>をInsert時の&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/main/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/statements/InsertStatement.kt" target="_blank" rel="noopener"
>InsertStatement&lt;/a>が継承している形の実装となっているので、以下のように共通化することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">UpdateBuilder&lt;/span>&amp;lt;Int&amp;gt;.setParametersFrom(image: Image) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[url] = image.url
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[title] = image.title
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[description] = image.description
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような関数を定義すると、InsertとUpdateの処理は以下のように書くことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">insert&lt;/span>(image: Image): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.insert {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[id] = image.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.setParametersFrom(image)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(image: Image): Image {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.update({ &lt;span style="color:#a6e22e">ImageTable&lt;/span>.id eq image.id }) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.setParametersFrom(image)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> image
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはbatchInsertの場合でも同じです。&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/main/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/statements/BatchInsertStatement.kt" target="_blank" rel="noopener"
>BatchInsertStatement&lt;/a>もまたInsertStatementを継承しているので、以下のように共通化することができます。これでだいぶすっきりしたコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">batchInsert&lt;/span>(images: List&amp;lt;Image&amp;gt;): List&amp;lt;Image&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ImageTable&lt;/span>.batchInsert(images) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[id] = &lt;span style="color:#66d9ef">it&lt;/span>.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.setParametersFrom(&lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> images
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="batchupsertの実装">BatchUpsertの実装
&lt;/h3>&lt;p>ExposedにbatchInsertはありますが、batchUpsertはありません。ただ、クエリの書き方とアプリ側の実装によってbatchUpsertを実現することはできます。もちろん&lt;a class="link" href="https://github.com/PerfectDreams/ExposedPowerUtils" target="_blank" rel="noopener"
>ExposedPowerUtils&lt;/a>のようなライブラリもあるので、それを導入するのも良いでしょう。&lt;/p>
&lt;p>ただ、あのライブラリを使う場合は少し問題がありました。まずこのライブラリの実装では特定のカラムを指定して、それを基準にデータがすでに存在する場合はUpdate、存在しない場合はInsertという処理を行っています。最終的に作られるコードは、Insertをまず実行して、指定したカラムが重複している場合は&lt;code>ON CONFLICT&lt;/code>でUpdateを実行するというものです。&lt;/p>
&lt;p>ここでテーブルのIDはアプリ側で生成するUUIDであり、ON CONFLICTの基準となるカラムがFKの場合にはIDまでUPDATEされるという問題がありました。なので、先ほどのライブラリの実装を元に、PKを除いてUpdateするように実装を変更しました。それが以下です。（あと一部使ってない引数は省略してます）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span> : &lt;span style="color:#a6e22e">Table&lt;/span>, &lt;span style="color:#a6e22e">E&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">T&lt;/span>.batchUpsert(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">data&lt;/span>: Collection&amp;lt;E&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">vararg&lt;/span> keys: Column&amp;lt;*&amp;gt; = (primaryKey &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;primary key is missing&amp;#34;&lt;/span>)).columns,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body: &lt;span style="color:#a6e22e">T&lt;/span>.(BatchInsertStatement, E) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): BatchInsertOrUpdate {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> BatchInsertOrUpdate(table = &lt;span style="color:#66d9ef">this&lt;/span>, keys = keys).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">data&lt;/span>.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> addBatch()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> body(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> execute(&lt;span style="color:#a6e22e">TransactionManager&lt;/span>.current())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BatchInsertOrUpdate&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> table: Table,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">vararg&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> keys: Column&amp;lt;*&amp;gt;,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : BatchInsertStatement(table, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">prepareSQL&lt;/span>(transaction: Transaction): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> transactionManager = &lt;span style="color:#a6e22e">TransactionManager&lt;/span>.current()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> primaryKey = table.primaryKey&lt;span style="color:#f92672">?.&lt;/span>columns&lt;span style="color:#f92672">?.&lt;/span>toSet() &lt;span style="color:#75715e">// ここでprimaryKeyを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> updateSetter = ((table.columns - keys.toSet())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .let { columns &lt;span style="color:#f92672">-&amp;gt;&lt;/span> primaryKey&lt;span style="color:#f92672">?.&lt;/span>let { columns - primaryKey } &lt;span style="color:#f92672">?:&lt;/span> columns }) &lt;span style="color:#75715e">// ここでprimaryKeyを除外
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .joinToString { &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${transactionManager.identity(it)}&lt;/span>&lt;span style="color:#e6db74"> = EXCLUDED.&lt;/span>&lt;span style="color:#e6db74">${transactionManager.identity(it)}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> onConflict =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;ON CONFLICT (&lt;/span>&lt;span style="color:#e6db74">${keys.joinToString { transactionManager.identity(it) }&lt;/span>&lt;span style="color:#e6db74">}) DO UPDATE SET &lt;/span>&lt;span style="color:#e6db74">$updateSetter&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${super.prepareSQL(transaction)}&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#e6db74">$onConflict&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="トランザクションを分ける">トランザクションを分ける
&lt;/h3>&lt;p>この度はリードレプリカを導入することになり、GET系のAPIにはとりあえずリードレプリカを使うことになりました。ただ、リードレプリカは更新系のクエリを受け付けないので、更新系のクエリはプライマリに送る必要があります。&lt;/p>
&lt;p>そして、APIの実装としては例外を投げる前に明示的にロールバックを行うため別途の関数を定義していて、これと同じような使い方としてリードレプリカに接続するものを作りたいと思いました。まず、既存で使っていた関数は以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">transactionWrapper&lt;/span>(statement: &lt;span style="color:#a6e22e">Transaction&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> transaction {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> statement()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (ex: Exception) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">TransactionManager&lt;/span>.current().rollback()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Exposedでは&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/7c8d8a20e2efef5d0282ca6b703a433ecbf4a607/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/transactions/ThreadLocalTransactionManager.kt#L156" target="_blank" rel="noopener"
>transaction&lt;/a>の引数に&lt;a class="link" href="https://github.com/JetBrains/Exposed/blob/7c8d8a20e2efef5d0282ca6b703a433ecbf4a607/exposed-core/src/main/kotlin/org/jetbrains/exposed/sql/Database.kt" target="_blank" rel="noopener"
>Database&lt;/a>を渡すことで、簡単にどのDBに接続するかを指定することができます。なので、これを使ってリードレプリカに接続する関数を以下のように定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">readReplicaTransactionWrapper&lt;/span>(statement: &lt;span style="color:#a6e22e">Transaction&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> readReplicaDatabase: Database = getKoinModule(named(&lt;span style="color:#e6db74">&amp;#34;readReplicaDatabase&amp;#34;&lt;/span>)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> transaction(readReplicaDatabase) { statement() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでの&lt;code>Database&lt;/code>を&lt;a class="link" href="https://github.com/InsertKoinIO/koin" target="_blank" rel="noopener"
>Koin&lt;/a>を使用してinjectしているので、追加で以下のような設定を加えてます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// デフォルトのDBはプライマリに固定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> defaultDatabase: Database = getKoinModule(named(&lt;span style="color:#e6db74">&amp;#34;primaryDatabase&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">TransactionManager&lt;/span>.defaultDatabase = defaultDatabase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Top level functionでKoinのinjectを使うための設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">getKoinModule&lt;/span>(qualifier: Qualifier? = &lt;span style="color:#66d9ef">null&lt;/span>): T {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">KoinComponent&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> value: T &lt;span style="color:#66d9ef">by&lt;/span> inject(qualifier)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.&lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでtransactionを使うたびに関数名だけを変えるだけで、プライマリとリードレプリカに接続することができます。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたでしょうか。今回もKotlinの小技的なものを紹介してみました。最近はあまり複雑なロジックを書いてない上、プライベートでの開発もあまりしてないので、なかなかブログのネタが思いつかないですね。たまにこちらのブログの記事を参考にしていただいている方がいるようなので、もう少し頻繁に更新できるように頑張ります。&lt;/p>
&lt;p>しばらくブログを更新してませんでしたが、今回はCompose Multiplatformも1.5.0になり、Java 21のリリースもまもなくなので、近いうちにまたそれらについての記事も更新していきたいと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinConf'23を要約してみた</title><link>https://retheviper.github.io/posts/kotlin-conf-2023/</link><pubDate>Fri, 14 Apr 2023 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-conf-2023/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinConf'23を要約してみた" />&lt;p>今年も&lt;a class="link" href="https://kotlinconf.com/" target="_blank" rel="noopener"
>KotlinConf&lt;/a>が開催されました。毎年興味を持って参加やキーノートを視聴しているわけでもありませんが、最近はK2 CompilerにやKMMなどJetbrainsのプロダクトがかなり盛んな感じなので視聴することにしました。そこで思ったより興味深い発表が多かったので、今回はその内容について簡単にまとめてみようかなと思います。&lt;/p>
&lt;p>では、セッション別にどんな話があったのかを紹介していきます。&lt;/p>
&lt;h2 id="k2-compiler">K2 Compiler
&lt;/h2>&lt;p>まずはKotlin 2.0で採用予定の&lt;a class="link" href="https://blog.jetbrains.com/kotlin/2021/10/the-road-to-the-k2-compiler/" target="_blank" rel="noopener"
>K2 Compiler&lt;/a>の話です。2021年から発表されていて、コンパイラの性能向上のみでなくプラグイン対応などの機能も提供する予定となっていますね。今現在開発が進んでいて、Kotlin 1.8がリリースされた今もかなり多い部分が完成されている状態です。&lt;/p>
&lt;p>ここではKotlin 1.8と、2.0になった場合のコンパイラのパフォーマンスの違いをまずグラフとして提示していました。当たり前ながら、2.0でかなり速度が上がったように見えます。同じ環境で20秒かかるものが、10秒に短縮されたということですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison_hu289f29ab394cd6066b8df4bdc9e6c13b_69280_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/compilation-time-comparison_hu289f29ab394cd6066b8df4bdc9e6c13b_69280_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="コンパイル時間の比較"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>Andoridの公式言語としてKotlinが採用され、JavaからKotlinに移行した開発者の間でやはりビルドが遅くなったという話を聞いた覚えがあるのでこれはかなり嬉しい結果となっていますね。またコンパイラのパフォーマンスが上がるとintellijでのコンパイルも早くなるわけなのでより快適な開発環境になると思います。&lt;/p>
&lt;p>また、今年の後半にはKotlin 1.9のリリースが予定されていて、その次に1.10のようなバージョンは予定にないとのことでした。つまり、1.9の後はすぐに2.0となるとのことですね。そして2.0は1.9の後方互換性を保つので、1.9でコンパイルができるのであれば2.0でもコンパイルができるとのことです。&lt;/p>
&lt;p>もちろん言語のバージョンアップを急ぐ企業さんはそこまではないと思いますし、コンパイラ自体が変わることでどんな問題が起こるかわからないので、実際の採用まではかなり時間がかるでしょう。ただ個人的にはサイドプロジェクトで色々試してみたいので、来年からはK2 Compilerに触れられるということが楽しみです。&lt;/p>
&lt;h2 id="要望の多い機能">要望の多い機能
&lt;/h2>&lt;p>&lt;a class="link" href="https://www.jetbrains.com/youtrack/" target="_blank" rel="noopener"
>Youtrack&lt;/a>というサイトからJetbrainsのプロダクトに関して議論できるのですが、ここで要望の多い機能に対して今後どのような形で対応していくかを説明するセッションです。ここは一つ一つ、どのような要望があるかを見ていきます。&lt;/p>
&lt;h3 id="static-extensions">Static Extensions
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-11968/Research-and-prototype-namespace-based-solution-for-statics-and-static-extensions" target="_blank" rel="noopener"
>KT-11968&lt;/a>に上がっているもので、JavaクラスにもCompanion objectのように、staticなメソッドやプロパティを追加できるようにしてほしいということです。&lt;/p>
&lt;p>例えば、今までは以下のようにJavaのクラスにCompanion objectを定義してインスタンスの生成なしで使うことはできませんでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">File&lt;/span>.&lt;span style="color:#66d9ef">open&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;data.txt&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>.&lt;span style="color:#a6e22e">Companion&lt;/span>.&lt;span style="color:#66d9ef">open&lt;/span>(name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、&lt;code>static&lt;/code>というキーワードを使って以下のように書けるようになるとのことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">File&lt;/span>.static.&lt;span style="color:#66d9ef">open&lt;/span>(name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的にはMySQLとJVMの日付のMAX_VALUEの閾値が違ってバグが起きたことがあって、LocalDateに別途プロパティを追加したかったのにJavaのクラスにはstaticなプロパティの追加ができなくて諦めた経験があるのでこれはとても嬉しい変化です。&lt;/p>
&lt;h3 id="collection-literals">Collection Literals
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-43871/Collection-literals" target="_blank" rel="noopener"
>KT-43871&lt;/a>に上がっているもので、その名の通りコレクションのリテラルを作成できるようにしてほしいということです。&lt;/p>
&lt;p>例えば、今までは言語レベルでコレクションのリテラルに対応していなかったので、以下のような書き方が多かったかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>cmdArgs = listOf(&lt;span style="color:#e6db74">&amp;#34;-language-version&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;2.0&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>それが、以下のようにコレクションのリテラルを書けるようになるとのことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> skip: PersistentSet&amp;lt;Int&amp;gt; = [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> skip2 = PersistentSet [&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>個人的には&lt;code>const&lt;/code>キーワードの適用範囲をもっと広げてほしいと思っているところですが、これもまた悪くない変化ですね。特にアノテーションなどで使われる配列は実際リテラルになるケースが多いと思いますので、そこでまた色々と活用できる余地ができるかもしれません。&lt;/p>
&lt;h3 id="name-based-destructing">Name-Based Destructing
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-19627" target="_blank" rel="noopener"
>KT-19627&lt;/a>に上がっているもので、分解宣言時に変数名とフィールド名が一致するようにしてほしいということです。&lt;/p>
&lt;p>例えば以下のように分解宣言をしたとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> firstName: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> lastName: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>firstName, lastName) = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Doe&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードの場合、&lt;code>firstName&lt;/code>は&lt;code>John&lt;/code>, &lt;code>lastName&lt;/code>は&lt;code>Doe&lt;/code>となります。data classの実際のフィールド名とも一致しているので、なんの問題もありません。ただ、もし間違って以下のようにしたらどうでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>lastName, firstName) = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Doe&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、意図とは違って&lt;code>firstName&lt;/code>は&lt;code>Doe&lt;/code>, &lt;code>lastName&lt;/code>は&lt;code>John&lt;/code>となってしまいます。このようなミスを回避するために&lt;a class="link" href="https://kotlinlang.org/docs/inline-classes.html" target="_blank" rel="noopener"
>inline class&lt;/a>などを導入してフィールドごとに型を定義したり、分解宣言そのものを使わないようにするなどの対応をしていることも少なくはないかと思いますが、今後はこのようなミスを回避するために、分解宣言時に変数名とフィールド名が一致するかどうかコンパイラが判断して値の代入を行うことになるとのことです。&lt;/p>
&lt;p>個人的にはかなりすごいと思いますが、心配も多いですね。単純に変数名とフィールドが一致する時のみ動作してくれるのかどうかわからないので、実際の動作を見ておきたいものです。&lt;/p>
&lt;h3 id="context-recivers">Context Recivers
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-10468/Context-receivers-multiple-receivers-on-extension-functions-properties" target="_blank" rel="noopener"
>KT-10468&lt;/a>に上がっているもので、関数にコンテキストが必要な場合はパラメータとしてではなく、別途のキーワードを使ってコンテキストを渡すことができるようにしてほしいということです。&lt;/p>
&lt;p>例えば、以下のような関数があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">processRequest&lt;/span>(context: ServiceContext, request: ServiceRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = request.loadData(context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数ではコンテキストを引数としてもらい、さらにそのコンテキストを違う関数の方に渡しています。当然、呼ばれる関数の方も引数にコンテキストが必要になります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ServiceRequest&lt;/span>.loadData(context: ServiceContext): Data { &lt;span style="color:#75715e">/** ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合、関数の中で呼ばれる他の関数が多くなればなるほど、その関数にもコンテキストを渡す必要が出てきます。そこで、以下のように別途のキーワードを使って、引数の追加なしでコンテキストを渡すことができるようになるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>context(ServiceContext)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">processRequest&lt;/span>(request: ServiceRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = request.loadData()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>context(ServiceContext)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">ServiceRequest&lt;/span>.loadData(): Data { &lt;span style="color:#75715e">/** ... */&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>context&lt;/code>のキーワードに渡せるコンテキストの基準が何か、そしてどのように関数の中でコンテキストを呼び出せるかどうかはまだわかりませんが、より綺麗な感覚になっているかなと思います。&lt;/p>
&lt;h3 id="explicit-fields">Explicit Fields
&lt;/h3>&lt;p>&lt;a class="link" href="https://youtrack.jetbrains.com/issue/KT-14663/Support-having-a-public-and-a-private-type-for-the-same-property" target="_blank" rel="noopener"
>KT-14663&lt;/a>に上がっているもので、privateなプロパティに対してpublicなプロパティを定義しなくても良いようにしてほしいということです。&lt;/p>
&lt;p>例えば、privateのプロパティに対して、外部から参照する場合は以下のように書くケースがあるかなと思います。privateなプロパティを維持しつつ、外部で参照のみできる別のプロパティがその値を提供するということですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _applicationState = MutableStateFlow(State())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> applicationState: StateFlow&amp;lt;State&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = _applicationState
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを、以下のように書けるようになるらしいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> applicationState: StateFlow&amp;lt;State&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span> = MutableStateFlow(State())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>行数をかなり減らせられ、似たようなプロパティを定義する必要もなくなるのでかなり便利そうな感覚です。特にComposeのようにプロパティで状態を管理する場合はこのようなパターンが多いかなと思いますので、有効活用できるかなと思いました。&lt;/p>
&lt;h2 id="kotlin-notebooks">Kotlin Notebooks
&lt;/h2>&lt;p>このセッションで新しくKotlin Notebooksというものの発表がありました。今は&lt;a class="link" href="https://jupyter.org/" target="_blank" rel="noopener"
>Jupyter Notebook&lt;/a>でもKotlinは使えるのですが、似たような機能をKotlin専用として開発したような感覚ですね。Jupyterそのものも有名で、動画の中ですでに多くの機能を紹介しているので説明よりはそのキャプチャを載せておきます。以下のような活用例が紹介されています。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1_hu06403b1b89feef3e492decaed0d81c46_68910_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-1_hu06403b1b89feef3e492decaed0d81c46_68910_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="プロトタイピング"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2_hu139c01037ed2db259a137cf88a47579f_91280_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-2_hu139c01037ed2db259a137cf88a47579f_91280_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="言語使用の学習(AIサポート)"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3_hu450f7497e01387b52bed7e5737209c2e_74536_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-3_hu450f7497e01387b52bed7e5737209c2e_74536_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="アルゴリズムの検証(ソートのビジュアライズ)"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4_hu0677be80cf782869dae8d9ee20bfd5cc_98812_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-4_hu0677be80cf782869dae8d9ee20bfd5cc_98812_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="データ調査"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5_hue2b369f0f8b7dd6ad3a2d83552345cc6_72452_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-5_hue2b369f0f8b7dd6ad3a2d83552345cc6_72452_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="データ分析"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6.webp"
width="2144"
height="1304"
srcset="https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6_hu165594b5fb29de743fc2d838d18cdaa6_66612_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-conf-2023/kotlin-notebook-example-6_hu165594b5fb29de743fc2d838d18cdaa6_66612_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Plot生成"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="394px"
>&lt;/p>
&lt;p>その他、自動完成やオンラインでのコードシェア対応、テーブルのソートとカラムの順番変更などができるという点が紹介で明らかになっています。&lt;/p>
&lt;h2 id="googlekotlinconf">Google@KotlinConf
&lt;/h2>&lt;p>こちらのセッションはGoogleの人が出て発表をしていましたが、主に指標の話で、Androidのアプリの中でKotlinやComposeを採用しているものがどれほど多いかの話などが多かったですね。また、GoogleでもKotlinを積極活用していて、Google WorkspaceでもKotlin Multiplatformを利用してビジネスロジックを書いているという話がありました。&lt;/p>
&lt;p>他に注目したいところは、Androidの開発においてGradleのデフォルト設定がKotlin DSLになったというところです。Kotlinで開発をしているならもちろんGroovyよりはKotlinの方が便利だと思っていたので、このような変化はありがたいですね。&lt;/p>
&lt;p>ただ、GoogleでもKotlinを利用しているとはいえ、FlutterやGoという競合もあるので、今後どのような方向性を取っていくのかが気になりました。もちろんKotlinのカンファレンスなのでそのような話には触れなかったのですが、今後のGoogleの方針やCompose Multiplatformのシェアについてはもっと注目したいと思いました。&lt;/p>
&lt;h2 id="crossplatform">Crossplatform
&lt;/h2>&lt;p>このセッションではComposeのiOS対応の発表と、Mutiplatformの現在の紹介などがありました。ComposeのiOSはAlpha、MultiplatformはBetaの段階で多くのライブラリが対応しているなどの話が続きましたね。Kotlinが初めからJVM以外の領域でも活用できることを目標として開発されたのは確かですが、登場から10年以上も経ってやっとそのロードマップが現実になっているなという感覚でした。&lt;/p>
&lt;p>個人的にはXcodeやSwiftUIよりはintellijとComposeの方が合っていると感じていたので、iOSの開発ができるようになったのは大変嬉しく思っています。特に、AppCodeの開発が今年て終了するとのことだったのでMacやiOSの開発のためには致し方なくSwiftUIを勉強する必要があるかなと思っていたところなのでタイミング的にも最適ですね。直近でちょうどKotlinのみでウェブとモバイル、デスクトップのアプリを開発するというサイドプロジェクトをやっているので、早速試してみようかなと思っています。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>純粋にK2 Compilerの現在が知りたくて試聴した動画で、思わぬ発表が続いて嬉しい気持ちになりました。個人的には一つの言語で必要なことができるようにしたいと思っていたので、Kotlinという言語を選択したのは正解だったという気持ちになりました。&lt;/p>
&lt;p>やはりまだサーバサイドでもシェアはそこまで高くないかなと思いますが、これからもいろいろな分野でKotlinを使える環境が整っていくと言語として伸びるポテンシャルは十分など思いますので、また今後に期待ですね。&lt;/p>
&lt;p>取り急ぎ、KotlinConfのキーノートの動画を紹介しましたが、他にもいろいろな動画が公式のチャンネルにて配信中なので、興味がある方はぜひ見てみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinはどう書いたらいいか</title><link>https://retheviper.github.io/posts/kotlin-how-to-kotlin-like/</link><pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-how-to-kotlin-like/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinはどう書いたらいいか" />&lt;p>自分がJavaからKotlinに転向してからもう2年ほどが経ちます。しかし、いまだにKotlinでできることは無限にあって、新しい発見は終わることがないと感じています。Kotlinという言語自体のバージョンアップが早く、色々と機能が追加されて続けているのでまだしばらくこの発見も続きそうですね。&lt;/p>
&lt;p>そんな中で思うことなのですが、Intellijを使っていると自動的にJavaのコードを変換してくれたり、Javaの書き方をそのまま流用しても問題になることは少ないものの、やはりKotlinならではのコードを書きたいという欲求も湧いてきます。つまり、「Kotlinらしき書き方」をしたいと思ってしまうのです。&lt;/p>
&lt;h2 id="korlinらしき書き方って">Korlinらしき書き方って？
&lt;/h2>&lt;p>「Kotlinらしき書き方」とは一体どういうものなのでしょうか。まずはその定義が必要ですね。いろいろな捉え方があるかと思いますが、私は基本的に「Kotlinの仕様や機能を最大限に活かすこと」なのではと思っています。つまり、スタンダードライブラリのAPI、Scope Function, Extensionなどを積極的にコードに取り入れることです。そうすることでコードを書く時間は短くなり、より効率が上がるだろうと私は思っています。&lt;/p>
&lt;p>ただ、そういう概念を言葉で述べるだけでは曖昧なところがあるので、コードを持って例を挙げた方がいいでしょう。例えば、以下のような関数を実装する必要があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">numbers&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// TODO
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この関数を通じて行いたい処理は、「0〜10の数字をStringに変換してListとして返す」ことだとしましょう。その場合、実装の一例として以下のようなコードを提示できるかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">numbers&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> list = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> i = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (i &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list.add(i.toString())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> list.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map.html" target="_blank" rel="noopener"
>kotlin.collections.map()&lt;/a>を使ったら、同じコードを以下のように変換することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">numbers&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ae81ff">0.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>).map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>map()&lt;/code>のような関数が初めて登場した際は、あまり直感的にその処理の意味を把握できないということから「可読性に欠ける」という評価もあったようです。上記の二つのコードを比べると、場合によっては&lt;code>while&lt;/code>ループでの処理がわかりやすいと感じる方もいらっしゃるかなと思います。今は&lt;code>map()&lt;/code>が多くのプログラミング言語で採用している関数であり、期待できる関数の実行結果も常識化していますが、古典的なコードに慣れている人からしたら「ループで何かを行う」というコードの方がわかりやすいかもです。&lt;/p>
&lt;h2 id="可読性として">「可読性」として
&lt;/h2>&lt;p>しかし、果たしてより高度な処理を行う場合も「長いコードの方が可読性は良い場合もある」と断定できるのでしょうか。ここでまた、違う例を挙げてみましょう。例えば、&lt;code>Listの数字を全て掛け算した結果を返す&lt;/code>関数を実装する必要があるとします。例えば以下のようなコードを書くことができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">multiply&lt;/span>(numbers: List&amp;lt;Int&amp;gt;): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (numbers.isEmpty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalAccessException(&lt;span style="color:#e6db74">&amp;#34;List is empty&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> acc = numbers[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (numbers.size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> acc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ((index, &lt;span style="color:#66d9ef">value&lt;/span>) &lt;span style="color:#66d9ef">in&lt;/span> numbers.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (index &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> acc &lt;span style="color:#f92672">*=&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> acc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードでは当初の目的は果たしていますが、「可読性」という観点からするとどうでしょうか。関数のシグニチャーだけでなく、関数で行なっている処理全体に目を通さないと、何が起こっているかわからないのではないでしょうか？&lt;/p>
&lt;p>この関数で行なっている処理を一つ一つ読んでみると、「リストが空の場合はエラーを返す」、「リストの要素が一つの場合はそれを返す」、「リストが空でなく、要素が一つでもない場合は後続の処理を行う」、「最初の要素をとり、リストの要素をループしながら最初の要素以外を全て掛け算する」という情報が込められています。&lt;/p>
&lt;p>ここでExtensionと&lt;code>kotlin.collections&lt;/code>の関数を使って同じ処理を行う関数を実装してみると、コードは大きく変わります。以下がそのサンプルコードです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;Int&amp;gt;.multiply(): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reduce { acc, e &lt;span style="color:#f92672">-&amp;gt;&lt;/span> acc * e }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>map()&lt;/code>の場合と同じく、&lt;code>reduce()&lt;/code>という関数が何をするかがわからない場合もあるかと思います。しかし、その関数が「要素を一つに減らす」ことであり、その中で行なっている「減らし方は掛け算」ということを理解すれば良いだけなので、こちらの方がその意図を把握しやすいのではないでしょうか。先ほどの関数は、処理全体をいくつかの単位で分けて理解する必要があったということから考えると、可読性の面ではこちらの方がより優秀だと言えるのではないかと私は思っています。&lt;/p>
&lt;p>また、&lt;code>List&lt;/code>に拡張関数として定義することで、まるで元からついていたメソッドのように使えるのも良い点でしょう（IDEから自動補完に出てくるはずなので）。&lt;/p>
&lt;h2 id="工数として">「工数」として
&lt;/h2>&lt;p>コードを書くのは工数がかかる行為です。なので、同じ機能をする関数を書くとしても、毎回全ての処理を書くより共通化できる部分は分離し、再利用するのが常識のようなものです。そのため多くのライブラリやフレームワークが存在していますね。&lt;/p>
&lt;p>プログラミング言語の使用や機能をよく理解し、それらを活用するということも本質的にはライブラリやフレームワークを使うことと変わらないものです。先のように、「Listの要素を一つにまとめる」処理を毎回自前で書くとしたら、かなりの時間が必要となるでしょう。&lt;/p>
&lt;p>ここで他の例をまた挙げます。例えば以下のようなデータがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> version: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Data(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>DBの中に履歴を残したい場合はversionや枝番など名称の列を持たせ、同じIDのデータをいくつか挿入する場合があるかと思います。そしてその場合、最新のデータのみを処理したいケースもありますね。上記の例だと、&lt;code>Data(1, 2)&lt;/code>と&lt;code>Data(2, 3)&lt;/code>のみを取得したいということです。&lt;/p>
&lt;p>最初からクエリで最新のデータのみを取得できるといいのですが、外部APIのレスポンスの場合はそのようにフィルタされたデータでない場合もあります。なのでこちらでversionがmaxのデータをフィルタする処理を書くとします。例えば以下のようなコードを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">maxVersions&lt;/span>(list: List&amp;lt;Data&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = mutableListOf&amp;lt;Data&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ((index, &lt;span style="color:#66d9ef">value&lt;/span>) &lt;span style="color:#66d9ef">in&lt;/span> list.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (index &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> last = result[result.size - &lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">value&lt;/span>.id &lt;span style="color:#f92672">==&lt;/span> last.id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">value&lt;/span>.version &amp;gt; last.version) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.remove(last)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.add(&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可読性の問題は一旦置いといて、このようなコードを書くときの工数はどうでしょうか。慣れてしまえば簡単なのかもしれませんが、初めてこの処理を書く人の立場からしたらかなりの工数がかかり、関数が期待通りに動作するかの検証を含めるとさらに工数が必要となりそうだと思います。慣れている場合でも、常にこのようなコードを的確に書けるかどうかが疑問です。&lt;/p>
&lt;p>それに対して、スタンダードライブラリを使った例を考えてみます。以下のように、メソッドチェーンによって簡単に同じことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> maxVersions = list.groupBy { &lt;span style="color:#66d9ef">it&lt;/span>.id }.map { &lt;span style="color:#66d9ef">it&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>.maxBy { &lt;span style="color:#66d9ef">it&lt;/span>.version } }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで使われている&lt;code>groupBy()&lt;/code>、&lt;code>map()&lt;/code>、&lt;code>maxBy()&lt;/code>はそれぞれ「ValueがListのMapを作る」、「要素を違う形にマッピングする」、「Listの要素のうちmaxの値を探す」という関数なので、ここだけでなく色々な場面で活用できる関数となっています。このように便利な関数を使いこなし、さらに組み合わせることでより複雑な処理でも簡単に書くことができるという点をみると、スタンダードライブラリの機能を理解するのは工数の面でもかなり効率を上げられることになるのではないかと思います。&lt;/p>
&lt;h2 id="注意点">注意点
&lt;/h2>&lt;p>ここまではKotlinの仕様や機能を活かすと可読性と工数という二つの観点から、メリットがあるという話をしてきました。しかし、どんなことでもメリットがあればデメリットもあるものですね。&lt;/p>
&lt;p>当たり前ながら、どんな機能でも単純に「それができる」という理由で乱用するとむしろ逆効果が出るケースがあります。例えば以下のような例を考えられます。二つのデータクラスがあって、&lt;code>Data&lt;/code>から&lt;code>Request&lt;/code>にマッピングする必要があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> version: Int?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Request&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> version: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Data&lt;/code>のフィールドはnullableとなっていますが、&lt;code>Request&lt;/code>の場合はそうではないです。このようにビジネスロジック上はnullになることはなくても、実装上の都合によってnullableにするケースもありますね。その場合、どうやってマッピングしたらいいでしょうか。例えば以下のような例があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Request&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> version: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">from&lt;/span>(&lt;span style="color:#66d9ef">data&lt;/span>: Data): Request {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Request(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = requireNotNull(&lt;span style="color:#66d9ef">data&lt;/span>.id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${Data::id.name}&lt;/span>&lt;span style="color:#e6db74"> should not be null.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version = requireNotNull(&lt;span style="color:#66d9ef">data&lt;/span>.version) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${Data::version.name}&lt;/span>&lt;span style="color:#e6db74"> should not be null.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここではcompanion objectを利用して&lt;code>Request&lt;/code>のインスタンスを生成しながら、データのマッピングを行うようにしています。そこで、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require-not-null.html" target="_blank" rel="noopener"
>requireNotNull()&lt;/a>を利用したバリデーションを行い、nullだった場合はエラーメッセージを出力するようにしていますね。&lt;/p>
&lt;p>ここまでは良い実装だとして、問題はエラーメッセージの方です。どのパラメータがnullだったかわかるようにしていますが、そこで&lt;code>Data&lt;/code>のフィールドをRefelctionで取得し、そのフィールド名をStringに埋め込むようにしています。エラーが発生した時には意図的に動作するとしても、果たして性能の劣るRefelctionを使うまでのことだったでしょうか。&lt;/p>
&lt;p>このように、言語が提供する機能を活用する場合は適切な場面を判断する必要があります。ここで紹介した&lt;code>map()&lt;/code>や&lt;code>reduce()&lt;/code>、&lt;code>groupBy()&lt;/code>なども便利で簡単な実装ができるようにしてくれる優秀な関数ですが、これらの関数の実装をみるとそれぞれが一つのループを必ず行い新しいCollectionを生成するという処理を行なっているということを理解すれば、メソッドチェーンで複数の関数を利用する場合は性能に影響を及ぼす可能性もあるということがわかるでしょう。他にも可読性の面でもわかりにくくなったり、別の関数として分離した方が良いコードが一つの関数内でいくつも繰り広げられることになる可能性もあるかと思います。&lt;/p>
&lt;p>なので、「曖昧な理解」や「慣性」としてこれらの機能を利用するという行為にはリスクがあるということを理解し、どのような実装をするかは常に悩むべきではないかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>すでに何回か、「Kotlinで書いてみた」というタイトルで、Kotlinならこういう書き方ができるというポストを載せていて、今回の記事もまたそれらと大きく離れた題ではないです。また、ある意味ここで挙げたことはプログラマなら基本的に熟知しておくべき常識のようなもので、今更な感があるのかもしれません。&lt;/p>
&lt;p>それでもあえて記事として書いている理由は、基本こそ大事だという自分の考えゆえでもあります。経験を積んでいくと発展する部分もありますが、逆に変な習慣がついてしまいなかなか直せないところも出てくるものですので。自分はそうでないかという警戒を兼ねて、一度は基本に戻り今の自分と照らし合わせてみるのもまた一つの勉強になるのではないかと思います。ちょうど年末ということもありますが。&lt;/p>
&lt;p>少し遅れてしまいましたが、2022年のポストはこれにて終わりとなります。来年は自分も、ここに訪れるみなさんにも成長のある一年になることをお祈りします。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>ifでの分岐を考える</title><link>https://retheviper.github.io/posts/kotlin-if-to-non-if/</link><pubDate>Sun, 20 Nov 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-if-to-non-if/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post ifでの分岐を考える" />&lt;p>ほとんどの言語で、特定の条件に合致した場合にのみ実行する処理を書くには、&lt;code>if&lt;/code>のように分岐処理のための構文を使うのが当たり前のように考えられています。言語によっては構文ではなく式として扱われたり、&lt;code>switch&lt;/code>や三項演算子のような他の選択肢も存在しますが、基本的に「条件とそれに従う処理」を書く機能として本質は変わらないものですね。&lt;/p>
&lt;p>分岐処理に限った話ではありませんが、便利な道具というのは時に危険性を伴うこともあります。&lt;code>if&lt;/code>を使う場合、最初の実装ではわかりやすく簡単に目的を達成できますが、維持保守の観点からするとあまり良くない選択になるケースもありますね。たとえば条件が増えたり変わるなどコードに変更が必要となった場合は修正がすべてのケースを網羅しているかどうかがわからなくなったり、ユニットテストが困難になったりするなどが考えられます。&lt;/p>
&lt;p>なので少なくとも&lt;code>if&lt;/code>の処理をよりシンプルにしたり、もしくはデザインパターンなどで分岐の構文を使わず同じ処理ができるように改善する必要が出てくることもあるかなと思います。そうすることで、コードリーディングはより難しくなるとしても、維持保守の観点からはより良いコードになる可能性もあるでしょう。&lt;/p>
&lt;p>もちろん、完全に&lt;code>if&lt;/code>をなくするというのは不可能に近い話で、そこまでする必要もありません。道具自体に罪はなく、あくまで使い方が問題になるだけですので。ここではあくまで、&lt;code>if&lt;/code>を使ったコードをどういう風にリファクタできるか、それだけに集中したいと思います。（初心者向けな感じで）&lt;/p>
&lt;h2 id="if文の例">if文の例
&lt;/h2>&lt;p>まずは、以下の関数をご覧ください。コードと価格を渡したら、内部ではコードに合わせて元の価格から割引の値を返すというものです。極めて単純化してはいますが、ECサイトのプロモーションなどでこのような処理が存在することもあるかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#ae81ff">0.1&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#ae81ff">0.15&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (amount &amp;lt; &lt;span style="color:#ae81ff">1000&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>すでにどのように処理をリファクタすれば良いか、一目でわかる方もいらっしゃるかなと思いますが、ここでは色々な観点でどうコードを変えられるかを述べたいので、一つ一つ項目を挙げて説明したいと思います。&lt;/p>
&lt;h2 id="関数のリファクタ">関数のリファクタ
&lt;/h2>&lt;p>まずは関数内の処理をどう変えられるかを考えてみます。コードをより単純化して可読性を向上したり、処理の漏れをなくしたり、共通化できたり処理の単位が曖昧な場合は分離するなどいろいろな方法が考えられるはずです。&lt;/p>
&lt;h3 id="標準ライブラリ">標準ライブラリ
&lt;/h3>&lt;p>上記の関数では&lt;code>if&lt;/code>の中にさらに&lt;code>if&lt;/code>が入っている構造となっているのがわかります。このようなネストは深くなれば深くなるほど良いコードとは言えませんね。なのでまずはここから直していきましょう。&lt;/p>
&lt;p>&lt;code>if&lt;/code>のネストを一つ減らす方法として、標準ライブラリを用いた方法を考えられます。標準ライブラリでなくでも関数として分離するという選択もありますが、標準ライブラリに処理を委任することでこの関数の負担がまず減るかなと思います。&lt;/p>
&lt;p>Kotlinには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-at-least.html" target="_blank" rel="noopener"
>coerceAtLeast()&lt;/a>という関数があり、パラメータとして渡された値をミニマムとして返すという働きをします。なので、&lt;code>amount&lt;/code>が1000以下の場合は&lt;code>amount&lt;/code>自身を、それ以外は1000を返すという処理はこの関数を使うことで単純化できます。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#ae81ff">0.1&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (amount * &lt;span style="color:#ae81ff">0.15&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (code &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>) &lt;span style="color:#75715e">// 閾値を超えない値となる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>単純に標準ライブラリを使用しただけですが、ネストが一つなくなりより単純なコードになりました。また、ここでの修正により閾値の修正が必要になった場合でも、1箇所だけを修正すると良いというメリットもありますね。&lt;/p>
&lt;p>他にも標準ライブラリで処理ができそうな場所は積極的に利用したり、似たような処理が繰り返されるところがあったら切り出して自前のライブラリとして分離しておくことも良い選択になるでしょう。&lt;/p>
&lt;h3 id="when">when
&lt;/h3>&lt;p>もう一つのリファクタとしては、&lt;code>if&lt;/code>を&lt;code>when&lt;/code>(他の言語の&lt;code>switch&lt;/code>)に入れ替えるという方法を考えられます。&lt;code>when&lt;/code>は結果的に同じ機能をするので、常に&lt;code>if&lt;/code>の代替として良いというわけではありません。しかし、ifの条件が一律であれば、&lt;code>when&lt;/code>を選ぶのは良い選択になる場合があります。&lt;/p>
&lt;p>先ほどの&lt;code>if&lt;/code>で分岐する条件は、あくまで&lt;code>code&lt;/code>という文字列がどのような値となっているか比較することだけですね。他には特に条件がないので、&lt;code>when&lt;/code>を用いた方がブランチを文字列だけで収めるのでより単純化つ明瞭なコードになります。たとえば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (code) { &lt;span style="color:#75715e">// codeの値を比較するだけの分岐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (amount * &lt;span style="color:#ae81ff">0.1&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (amount * &lt;span style="color:#ae81ff">0.15&lt;/span>).roundToInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>if&lt;/code>を&lt;code>when&lt;/code>に変えただけで、全体的に短くなってより読みやすいコードになっているかと思います。このように、&lt;code>if&lt;/code>の条件文がどのようなものかをみて、&lt;code>when&lt;/code>に変えるのも場合によっては良い選択の一つになり得るかなと思います。&lt;/p>
&lt;h3 id="拡張関数">拡張関数
&lt;/h3>&lt;p>Kotlinのような言語には、拡張関数で既存のクラスにメソッドを追加する機能がありますね。同じような処理が2箇所以上繰り返されているなら関数として分離を考慮すべきで、その関数を拡張関数として定義することも場合によっては考えられます。&lt;/p>
&lt;p>ここでは&lt;code>code&lt;/code>が&lt;code>Facebook&lt;/code>か&lt;code>Twitter&lt;/code>かによる分岐がありますが、やりたいことは&lt;code>amount&lt;/code>に特定のパーセンテージをかけて返すことですね。なので、パーセンテージを求める関数を定義しておいた方が良いでしょう。&lt;/p>
&lt;p>パーセンテージを求めるのはここでしか使わないとしたら&lt;code>private&lt;/code>な関数として定義しても良いのですが、より汎用的な使い方ができるようにしたいなら、以下のような拡張関数を定義するのもありでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// パーセントを求める拡張関数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">infix&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.percentOf(amount: Int): Int = (amount * &lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> percentOf amount &lt;span style="color:#75715e">// 10パーセントの値を返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span> percentOf amount &lt;span style="color:#75715e">// 15パーセントの値を返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先のほどのコードと比べ、拡張関数を定義することで処理の共通化ができたことと共に、「パーセントを計算する」という意図がコードでより明確に表れているようになっているのではないかと思います。&lt;/p>
&lt;h3 id="map">Map
&lt;/h3>&lt;p>&lt;code>if&lt;/code>や&lt;code>when&lt;/code>を使わない場合でも分岐ができる場合はあります。たとえば&lt;code>Map&lt;/code>を活用する方法ですね。&lt;code>code&lt;/code>によって違う値を掛け算したいので、&lt;code>code&lt;/code>をKeyに、掛けたい値をValueとするMapを定義しておくことです。たとえば以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コードと割引率
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> discountPercentages = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> to &lt;span style="color:#ae81ff">10&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> to &lt;span style="color:#ae81ff">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 割引率が定義してあったら掛け算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> discountPercentages[code]&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Mapにないcodeの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法では全ての分岐を網羅することはできなくなりますね。&lt;code>code&lt;/code>の値ががMapのKeyに含まれてない場合の処理が必要となるからです。ここでクロージャを用いると&lt;code>code&lt;/code>の値が&lt;code>Instagram&lt;/code>の場合の処理もMapに含めることができます。たとえば以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Valueを(Int) -&amp;gt; Intに変える
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> discountRules = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> to { amount: Int &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> percentOf amount },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> to { amount: Int &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">15&lt;/span> percentOf amount },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> to { amount: Int &lt;span style="color:#f92672">-&amp;gt;&lt;/span> amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> discountRules[code]&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">it&lt;/span>(amount) } &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Mapを利用する方法が条件分岐より良い方法だとは言い切れないのですが、コード別の割引率を他の関数でも参照する必要があるなど、複数の関数やクラスを跨いで共通の値を保持しておきたい場合は考えられる方法の一つになるかなと思います。この場合は、Map一つを修正するだけで全体の処理で整合性が保証されるコードになるという効果がありますね。&lt;/p>
&lt;h2 id="oop的な考え方">OOP的な考え方
&lt;/h2>&lt;p>今までは単純に関数内部の処理をどう変えていくかについて述べましたが、より高度な方法ももちろんあります。OOPの考え方として捉えると、先ほどの関数は「割引額を求める」責任がありますが、その中で「割引」の定義そのものと、その計算式まで持っていることになります。なので、責任を分離していく必要がありますね。&lt;/p>
&lt;p>この修正に処理は一見より複雑なものになっていくと感じる場合もあるかと思いますが、これはOOPに原則である&lt;a class="link" href="https://ja.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener"
>SOLID&lt;/a>を考慮したものでもあります。長期的な観点からすると、このような方法をとった方がより維持保守には向いていることになるでしょう。&lt;/p>
&lt;h3 id="interface抽出">interface抽出
&lt;/h3>&lt;p>まずは「割引ポリシー」を&lt;code>insterface&lt;/code>として分離します。この割引ポリシーを実装するクラスで実際のポリシーに従う割引額を計算するイメージです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicy&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> NONE: DiscountPolicy = &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">DiscountPolicy&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとはこの&lt;code>interface&lt;/code>を実装するクラスを、コード別に定義しておきます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FacebookDiscountPolicy&lt;/span> : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">10&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TwitterDiscountPolicy&lt;/span> : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">15&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">InstagramDiscountPolicy&lt;/span> : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうやって割引ポリシーを定義しておくと、&lt;code>getDiscountAmount()&lt;/code>は以下のように変えられるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> discountPolicy = &lt;span style="color:#66d9ef">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> FacebookDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> TwitterDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> InstagramDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicy&lt;/span>.NONE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> discountPolicy.calculate(amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="factory">Factory
&lt;/h3>&lt;p>先ほどの&lt;code>interface&lt;/code>抽出で割引ポリシー自体は分離できたものの、&lt;code>getDiscountAmount()&lt;/code>ではまだ「割引ポリシーを生成する」という責任を持っています。これもまた別の役割として分離ができるでしょう。ここは以下のように割引ポリシーを生成する&lt;code>Factory&lt;/code>を定義しておくと良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicyFactory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountPolicy&lt;/span>(code: String): DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> (code) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> FacebookDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> TwitterDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> InstagramDiscountPolicy()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicy&lt;/span>.NONE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最終的に、&lt;code>getDiscountAmount()&lt;/code>は以下のように修正できます。&lt;code>interface&lt;/code>の抽出や&lt;code>Factory&lt;/code>の作成でコードの量は増えましたが、この関数の責任はより軽くなり、割引ポリシーの追加や修正が必要な場合でも柔軟な対応ができるようになりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> discountPolicy = &lt;span style="color:#a6e22e">DiscountFactory&lt;/span>.getDiscountPolicy(code)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> discountPolicy.calculate(amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="enum">Enum
&lt;/h3>&lt;p>割引ポリシーを生成するために&lt;code>Factory&lt;/code>を使う代わりに、&lt;code>Enum&lt;/code>を使うこともできます。先ほどの&lt;code>DiscountPolicy&lt;/code>を継承して、クラスではなく列挙定数として扱う方法です。たとえば以下のようなものが定義できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicies&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> code: String) : DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FACEBOOK(&lt;span style="color:#e6db74">&amp;#34;Facebook&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">10&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TWITTER(&lt;span style="color:#e6db74">&amp;#34;Twitter&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = &lt;span style="color:#ae81ff">15&lt;/span> percentOf amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> INSTAGRAM(&lt;span style="color:#e6db74">&amp;#34;Instagram&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(amount: Int): Int = amount.coerceAtLeast(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fromCode&lt;/span>(code: String): DiscountPolicy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> values().find { &lt;span style="color:#66d9ef">it&lt;/span>.code &lt;span style="color:#f92672">==&lt;/span> code } &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#a6e22e">DiscountPolicy&lt;/span>.NONE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の&lt;code>Enum&lt;/code>を利用する場合、&lt;code>getDiscountAmount()&lt;/code>は以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getDiscountAmount&lt;/span>(code: String, amount: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> discountPolicy = &lt;span style="color:#a6e22e">DiscountPolicies&lt;/span>.fromCode(code)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> discountPolicy.calculate(amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Enum&lt;/code>の場合、&lt;code>fromCode()&lt;/code>で&lt;code>code&lt;/code>による分岐そのものが必要なくなり、割引ポリシを追加したい場合でも列挙定数を追加することで拡張も容易にできるので&lt;code>Factory&lt;/code>よりも良い方法ではないかと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最初に断っておいたように、全ての&lt;code>if&lt;/code>をなくすのは不可能に近い話で、そうする必要もありません。しかしその&lt;code>if&lt;/code>が行っている処理の本質、責任、可読性のような要素は注意深く観察する必要があり、最初は&lt;code>if&lt;/code>でとりあえず動くコードを作ったあとは他の方法で改善できるかどうか振り返ってみる必要はあるかなと思います。&lt;/p>
&lt;p>こういう自分も常に綺麗なコードを書いているわけではないのですが、たまにはこうやって初心者の気持ちで自分の書いたコードを振り返ってみるという姿勢は常に必要なのではという気持ちにもなります。良いコードを書くのは常に難しいものですね。でも、難しいことを最初にやっておいた方が後に後悔しないことにもつながるだろうと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinだけでファイルサーバを作ってみた</title><link>https://retheviper.github.io/posts/kotlin-compose-web/</link><pubDate>Mon, 10 Oct 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-compose-web/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinだけでファイルサーバを作ってみた" />&lt;p>世の中にはさまざまなプログラミング言語があり、それぞれの特徴も明確で、言語ごとにできる・できないことも違うケースが多いですね。企業ならエンジニアの採用や費用など現実的な観点から技術選定をするので、プロジェクトにおいてどの言語を使うかは明確かつ一般的な基準があるかと思います。しかし、個人のレベルだとチームでの作業を考慮すべきでもなく、その人の好みや慣れというものから言語を選ぶ傾向があるのではないかと思います。なので、割とマイナーな言語やフレームワークを使うケースもあるでしょう。&lt;/p>
&lt;p>自分がまさにそうであって、個人的に使うために実装するアプリや自動化のスクリプトなどは、なるべくKotlinやPythonで作成しています。特にKotlinの場合、仕事でも使っているので最も慣れているからでもありますが、さまざまなフレームワークや言語自体の特徴によりサーバサイドというジャンルやJVMという環境に限らずいろいろなことにチャレンジできるのが魅力的で好きです。&lt;/p>
&lt;p>というわけで、今回もプライベートでちょっと変わった形でウェブアプリを一つ作ってみた、という話です。どこが変わっているかというと、表題にも書いてある通りですが、「Kotlin」だけでファイルサーバのアプリを実装した話となります。&lt;/p>
&lt;h2 id="背景">背景
&lt;/h2>&lt;p>まず、どんなアプリをなぜ作ったかから述べないとですね。私の実家には、以前から使っていたWindowsのパソコンがあります。組み立てたのはおよそ8年ほど前のことで、最近は自分が実家に帰ることも少ないのであまり使われてないです。ただ、今のPC(Mac)からファイルを送ったりもらったりして使うことがあります。&lt;/p>
&lt;p>ここでファイルのやりとりには、今までMicrosoft社の&lt;a class="link" href="https://www.microsoft.com/ja-jp/microsoft-365/onedrive/online-cloud-storage" target="_blank" rel="noopener"
>OneDrive&lt;/a>を使っていました。片方で必要なファイルをOneDriveのフォルダにコピーしておくと、そのファイルがクラウドにアップロードされ、自動的に同期される方式ですね。これでも問題は全然なく安定的に使ってはいましたが、ふと思うとクラウドを経由するというステップが無駄だという気がしました。また、同期の前後でファイルをコピーしたり移動したりすることもめんどい作業になっています。&lt;/p>
&lt;p>ここで、自分でインターネット越しでファイルのやり取りができるアプリを作ってみたらどうかと思ったわけです。すでに自分が思っているような機能を提供している何らかのサービスはあるかもしれませんが、そこまで複雑なものでもないので、数日で作れるような気がしましたのでとりあえずチャレンジしてみることにしました。（SFTPというオプションもありましたが、GUIで楽にしたかったので却下です）&lt;/p>
&lt;h2 id="要件">要件
&lt;/h2>&lt;p>さて、作りたいものがあったらやることは決まっています。いつものことですが、アプリを作る前に簡単に要件を決めておきます。まず、機能的には以下のようなことができれば良いかなと思いました。&lt;/p>
&lt;ul>
&lt;li>サーバアプリを起動すると、クライアントからサーバのストレージにアクセスできる&lt;/li>
&lt;li>サーバのパスを指定したらその中身（ファイルとフォルダ）が見える&lt;/li>
&lt;li>フォルダをクリックすると表示中のパスが変わる&lt;/li>
&lt;li>ファイルをクリックするとダウンロードできる&lt;/li>
&lt;li>パスにファイルをアップロードできる&lt;/li>
&lt;/ul>
&lt;p>機能が決まったらそれを実現するための技術の番ですね。ここでは、何よりもKotlinで全て解決したい！という考えで、技術選定は全てKotlinを中心にしています。&lt;/p>
&lt;p>まずFrontendでは、ちょうどこないだ&lt;a class="link" href="https://www.jetbrains.com/lp/compose-desktop/" target="_blank" rel="noopener"
>Compose for Desktop&lt;/a>で簡単なアプリを作ったとこのブログに書いたことがありましたが、&lt;a class="link" href="https://compose-web.ui.pages.jetbrains.team/" target="_blank" rel="noopener"
>Compose for Web&lt;/a>というものもあったので、今回はこれを使ってみるとどうかなと思いました。これに関しては言語を統一したいという理由が最も大きいのですが、他にはFrontendの経験や知識があんまりないので少しでも触れてみた技術を使いたかったという理由もあります。&lt;/p>
&lt;p>Backendのフレームワークは&lt;a class="link" href="https://ktor.io/" target="_blank" rel="noopener"
>Ktor&lt;/a>にすることとしました。普段はSpringをやっているのでこちらの場合もあまり本格的な経験があるわけではありませんが、以前触れてみた感覚だとアプリの起動がはやく、実装も簡単だったので採用。また同じく、最も大きい理由はKotlin用ということです。&lt;/p>
&lt;p>大きくはこの二つで、他にも当然色々とライブラリなどが必要となるわけですが、ここは実装を進めながら必要なものがKotlin製かJetBrainsのものかを基準に選んで実装することにしました。もしくは実装において参考となるだろう公式のドキュメントに出てくるものを採用するという方針です。&lt;/p>
&lt;h2 id="frontend">Frontend
&lt;/h2>&lt;p>Frontendでは、先に述べた通りCompose for Webを使いました。やはり初めてということもあったのですが、まだ新しい技術だったり、そもそも自分がFrontendに対してあまりわかってないということもあったので最も工数がかかった部分です。ここについては、肌で感じたことを良かった点・思ったことと違った点・問題だった点という三つの軸で分けて述べていきたいと思います。&lt;/p>
&lt;h3 id="良かった点">良かった点
&lt;/h3>&lt;p>良かった点としては、やはりComposeでデスクトップアプリを作ってみた経験を活かした実装ができたというところです。Composeでは&lt;a class="link" href="https://developer.android.com/jetpack/compose/state#state-in-composables" target="_blank" rel="noopener"
>&lt;code>remember&lt;/code>と&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>&lt;/a>を組み合わせて状態を管理したり、&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Composable" target="_blank" rel="noopener"
>@Composable&lt;/a>をつけた関数の単位で画面の構成要素を分けて実装することができますが、ここでもそれは同じでした。&lt;/p>
&lt;p>なので、「指定したパスをブラウズ」する機能を実装した時、「一つ前のパスに戻る機能を追加したいな」と思ったときはそのパスを保持するために状態にパスを持たせたり、サーバから取得したパスの中身のオブジェクト（ファイルやフォルダなど）を画面に描画するためのコンポーネントを一つの&lt;code>@Composable&lt;/code>関数として定義して使ったりなどが思ったよりも簡単にできたわけです。&lt;/p>
&lt;p>他にもKotlinなのでCoroutineが簡単に使えたり、サーバサイドと同じリポジトリにソースコードを作成できるというところも良いところでした。特に後者の場合、GradleでKotlinのプラグインを&lt;code>multiplatform&lt;/code>にすることでFrontendではJavaScriptにコンパイルされ、サーバサイドではいつも通りJVMのバイトコードにコンパイルされるようにできるという点がお気に入りです。&lt;/p>
&lt;h3 id="思ったことと違った点">思ったことと違った点
&lt;/h3>&lt;p>自分の考えが甘かったのですが、Desktopとはかなり違うところがありました。何かというと、言語としてはKotlinを使うとしても、HTMLやCSSを排除することはできないという点です。ここでもやはり&lt;code>div&lt;/code>や&lt;code>form&lt;/code>のようなタグを使ったり、タグにマウスオーバ時のカーソルを変えるためにタグの&lt;code>attr&lt;/code>を変更する必要がありました。例えば、以下はファイルアップロードのコンポーネントですが、Kotlinで書いているだけで実際はHTMLをそのまま書いているような感覚です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Composable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">FileUploadForm&lt;/span>(currentPath: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Div {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Form(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$API&lt;/span>&lt;span style="color:#e6db74">_URL&lt;/span>&lt;span style="color:#e6db74">$ENPOINT&lt;/span>&lt;span style="color:#e6db74">_UPLOAD&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attrs = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method(&lt;span style="color:#a6e22e">FormMethod&lt;/span>.Post)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> encType(&lt;span style="color:#a6e22e">FormEncType&lt;/span>.MultipartFormData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target(&lt;span style="color:#a6e22e">FormTarget&lt;/span>.Blank)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HiddenInput {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name(&lt;span style="color:#e6db74">&amp;#34;target&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span>(currentPath)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Input(&lt;span style="color:#a6e22e">InputType&lt;/span>.File) { name(&lt;span style="color:#e6db74">&amp;#34;file&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Input(&lt;span style="color:#a6e22e">InputType&lt;/span>.Submit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここは完全に他のプラットフォームでのComposeを使うというよりは、Kotlinようにラップされたクラスを提供するだけという印象が強く、やはりある程度Frontendの知識が必要となる部分ではないかと思っています。なので、&lt;a class="link" href="https://reactjs.org/" target="_blank" rel="noopener"
>React&lt;/a>や&lt;a class="link" href="https://vuejs.org/" target="_blank" rel="noopener"
>Vue.js&lt;/a>などメジャーなFrontendのフレームワークの知識がある場合にはあまりComposeを選ぶ理由はなさそうな気がしています。&lt;/p>
&lt;p>他には、いつもとは違ってKotlin/JSとKotlin/JVMが共存するプロジェクトとなっているためか、intellij上の自動補完やビルド時の挙動が少し違う感覚があります。例えば、Gradleで依存関係を変更してもすぐに反映されなかったり…&lt;/p>
&lt;h3 id="問題だった点">問題だった点
&lt;/h3>&lt;p>意外と問題になったのは、プロジェクトのビルドでした。Compose for Webでは&lt;code>index.html&lt;/code>ファイルとWebpackなどを使ってビルドされた&lt;code>js&lt;/code>ファイルを使うことになり、ビルド自体はGradleのコマンドひとつで簡単にできるものですが、どうやら内部的に&lt;a class="link" href="https://yarnpkg.com/" target="_blank" rel="noopener"
>yarn&lt;/a>などを使っているようですが、intellijで生成したプロジェクトのデフォルト設定ではビルド時にエラーが出ることが多かったです。&lt;/p>
&lt;p>調べてみると自分のようなエラーが出る場合、&lt;a class="link" href="https://github.com/Kotlin/kotlinx-datetime/issues/193" target="_blank" rel="noopener"
>ビルドできない場合はKotlinのバージョンが&lt;code>v1.6.20&lt;/code>以降だと解消される&lt;/a>らしいのですが、問題はComposeのバージョンでした。このアプリを実装した時点の最新は&lt;a class="link" href="https://github.com/JetBrains/compose-jb/releases/tag/v1.1.1" target="_blank" rel="noopener"
>v1.1.1&lt;/a>なのですが、これだと対応しているKotlinのバージョンが&lt;code>v1.6.10&lt;/code>までです。なので、自分の場合は&lt;code>v1.2.0&lt;/code>のベータ版を使ってKotlinのバージョンを&lt;code>v1.7.10&lt;/code>にしてから解消できました。これはマイナーなプロジェクトのハマりどころと言えるものかもしれないですね。&lt;/p>
&lt;p>また、HTTPクライアントとしては&lt;a class="link" href="https://ktor.io/docs/getting-started-ktor-client.html" target="_blank" rel="noopener"
>Ktor Client&lt;/a>を使っていますが、大容量のファイルをアップロードする場合を想定して&lt;code>form&lt;/code>タグでMultipartのデータを直接送るよりHTTPクライアントを使う方法を取ろうとするとうまくいかなかったです。Ktor ClientはMultiplatform対応のものなので、クライアントの宣言時に&lt;a class="link" href="https://ktor.io/docs/http-client-engines.html" target="_blank" rel="noopener"
>どのEngineを使うかを選択できる&lt;/a>のですが、Kotlin/JSで使えるEngineだと&lt;a class="link" href="https://ktor.io/docs/request.html#binary" target="_blank" rel="noopener"
>公式で紹介している内容&lt;/a>通りに実装しても&lt;code>File&lt;/code>オブジェクトを直接扱えないので送信ができませんでした。ここは今後の改善に期待するか、Websocketなどを使うなど他の方法を取る必要がありそうです。&lt;/p>
&lt;h2 id="backend">Backend
&lt;/h2>&lt;p>次にBackendですが、こちらは自分の慣れている分野で、Ktor自体については他のポストでも述べたことがあり、技術的な面の話よりはロジック面で試行錯誤をしたことを中心に述べていきたいと思います。&lt;/p>
&lt;h3 id="ファイルツリーのブラウズ">ファイルツリーのブラウズ
&lt;/h3>&lt;p>このアプリにはまずファイルをブラウズする機能があるので、クライアントで指定したパスを探索して、その中にあるコンテンツ（ファイルとフォルダ）を返す必要があります。問題は、JSONの構造をどうするかですね。ここではまず一つの方法を試してみてから判断することにしました。&lt;/p>
&lt;h4 id="全取得する">全取得する
&lt;/h4>&lt;p>最初は、以下のような形で実装をしようと思いました。パスを指定したら、その配下にある全てのフォルダをたどり、親子関係をネストで表現する形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Documents&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;children&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;SomeDocument.pdf&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;file&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;size&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1391482&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;mimeType&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;application/pdf&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }&lt;span style="color:#960050;background-color:#1e0010">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Images&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;children&amp;#34;&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このようなファイルツリー返すために、サーバ側のコードは以下のようなものを使いました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ルートとなるパスを指定すると、子要素（ファイルとフォルダ）を全て取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> files = &lt;span style="color:#a6e22e">Files&lt;/span>.list(root)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#66d9ef">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathをJSONオブジェクトとして加工する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Path&lt;/span>.toFileTree(): FileTree {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> FileTree(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">this&lt;/span>.fileName.toString(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.fileSize(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#a6e22e">FileType&lt;/span>.DIRECTORY &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">FileType&lt;/span>.FILE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> children = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.list(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#66d9ef">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#walk-java.nio.file.Path-java.nio.file.FileVisitOption...-" target="_blank" rel="noopener"
>Files.walk()&lt;/a>を使うと、指定したパスを基準にネストされているファイルツリーを全て&lt;code>Stream&amp;lt;Path&amp;gt;&lt;/code>として取得してくれますが、それだと上記のJSONの形として加工するのが簡単ではないです。一度取得した結果をもとに、親子関係を追跡しながらJSONオブジェクトとしてまとめるにはかなり複雑な処理になるっでしょう。&lt;/p>
&lt;p>なので、ここでは&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#list-java.nio.file.Path-" target="_blank" rel="noopener"
>Files.list()&lt;/a>を使って指定したパスに含まれた要素を取得し、その要素がディレクトリの場合はさらに子要素として取得するように再帰を使って子要素を再度取得するという形としてまとめています。単純な処理ですが、効率的になりましたね。&lt;/p>
&lt;p>ただ、この方法で思った通りのファイルツリーをJSONとして返すことはできましたが、問題がありました。まず、指定したパスがルートに近くなればなるほど探索にかかる時間が長くなり、レスポンスも遅く慣ればJSONのサイズも大きくなるという問題がありました。また、JSONを受け取ったところで、Frontendで描画をするにも難点がありそうな気がしました。というわけで、この案はまず廃棄して、二つ目の方法を取ることにしました。&lt;/p>
&lt;h4 id="ネストさせない">ネストさせない
&lt;/h4>&lt;p>次に試した方法は、指定したパスのみに処理を制限することでした。何かというと、JSONオブジェクトのネストを無くして、指定したパスにどんなファイルとフォルダが含まれているかだけをリストとして返すということです。つまり、以下のような形になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Documents&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Images&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こうなると、中のフォルダを辿る必要がなくなるのでレルポンスも早く、軽くなるわけです。最初からちゃんと考えるべきだったのですが、こちらの方がFrontendとしても実装が楽であって、さらにサブパスのフォルダにアクセスしたい場合はそのパスを再度Backendに送ればいいだけですね。コードとしては再帰を使わなくなったくらいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> files = &lt;span style="color:#a6e22e">Files&lt;/span>.list(root)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { !&lt;span style="color:#66d9ef">it&lt;/span>.isHidden() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toFileTree() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// PathをJSONオブジェクトとして加工する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Path&lt;/span>.toFileTree(): FileTree {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> FileTree(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#66d9ef">this&lt;/span>.fileName.toString(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.fileSize(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> type = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.isDirectory()) &lt;span style="color:#a6e22e">FileType&lt;/span>.DIRECTORY &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">FileType&lt;/span>.FILE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルアップロード">ファイルアップロード
&lt;/h3>&lt;p>ファイルアップロードについては、Mutlipartとして送られているデータをどう扱うかですが、これはKtorらしく簡単な処理で対応できました。以下のコードが実際の実装となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// router
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>post(ENPOINT_UPLOAD) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Multipartデータを受信
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> multipart = call.receiveMultipart()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイル保存先のパス
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> path = &lt;span style="color:#a6e22e">Path&lt;/span>.of(ROOT_DIRECTORY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> multipart.forEachPart { part &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (part) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ルートでないパスを指定した場合は保存先を更新
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">PartData&lt;/span>.FormItem &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (part.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;target&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = path.resolve(part.&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルデータを保存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#a6e22e">PartData&lt;/span>.FileItem &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> file = &lt;span style="color:#a6e22e">Files&lt;/span>.createFile(path.resolve(part.originalFileName&lt;span style="color:#f92672">!!&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> part.streamProvider().use { input &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.newOutputStream(&lt;span style="color:#66d9ef">file&lt;/span>).use { output &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> input.copyTo(output)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// どちらでもない場合は一旦出力
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Unknown part: &lt;/span>&lt;span style="color:#e6db74">$part&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 処理の終わったデータはdispose
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> part.dispose()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、個人的にはストレージアクセスのある処理に対してはNIOを使いたいので、はじめは&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/nio/file/Files.html#copy-java.io.InputStream-java.nio.file.Path-java.nio.file.CopyOption...-" target="_blank" rel="noopener"
>Files.copy()&lt;/a>を使おうと思ったのですが、なぜかファイルの保存処理を以下のような作成するとうまくいかなったです。Coroutineとの相性に何か問題があるのかもしれないですので、ここは注意ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> file = &lt;span style="color:#a6e22e">Files&lt;/span>.createFile(path.resolve(part.originalFileName&lt;span style="color:#f92672">!!&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">Files&lt;/span>.copy(part.streamProvider(), &lt;span style="color:#66d9ef">file&lt;/span>) &lt;span style="color:#75715e">// ファイルが保存されない
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="ファイルダウンロード">ファイルダウンロード
&lt;/h3>&lt;p>ファイルダウンロードの場合も、ロジックは特にないので、ほとんどKtorのみのコードとなっています。自分の好みでPathを使っているくらいですのでコードだけを紹介します。ひとつ注意すべきところは、アップロードする時もそうですが、ファイル名を返すときにURLパスとしてエンコードすることですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">get&lt;/span>(ENDPOINT_DOWNLOAD) {&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> filepath = call.request.queryParameters[&lt;span style="color:#e6db74">&amp;#34;filepath&amp;#34;&lt;/span>] &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> path = &lt;span style="color:#a6e22e">FileService&lt;/span>.getFullPath(filepath) &lt;span style="color:#75715e">// ルートディレクトリからのフルパスを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">Files&lt;/span>.notExists(path)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respond(&lt;span style="color:#a6e22e">HttpStatusCode&lt;/span>.BadRequest, &lt;span style="color:#e6db74">&amp;#34;File not found&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.response.header(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#a6e22e">HttpHeaders&lt;/span>.ContentDisposition,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#a6e22e">ContentDisposition&lt;/span>.&lt;span style="color:#a6e22e">Attachment&lt;/span>.withParameter(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = &lt;span style="color:#a6e22e">ContentDisposition&lt;/span>.&lt;span style="color:#a6e22e">Parameters&lt;/span>.FileName,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> = path.fileName.toString().encodeURLPath()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ).toString()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> call.respondFile(path.toFile())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="注意すべきところ">注意すべきところ
&lt;/h3>&lt;p>まず、一つのプロジェクトにKotlin/JSとKotlin/JVMを両立する場合、&lt;code>dependencies&lt;/code>として記述するものに対しては&lt;code>build.gradle.kts&lt;/code>ファイルで以下のように指定することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>kotlin {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sourceSets {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Kotlin/JSの依存関係
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> jsMain &lt;span style="color:#66d9ef">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(compose.web.core)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(compose.runtime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Kotlin/JVMの依存関係
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> jvmMain &lt;span style="color:#66d9ef">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-core-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-auth-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、Composeを使うためには&lt;code>plugin&lt;/code>として指定する必要があり、これがプロジェクト全体の依存関係に追加されることになっていました。なので、アプリの作りとしてはまずFrontendのComposeをビルドし、サーバを起動したらビルドしたファイルをstaticとして提供する構造になっていますが、Backendの起動にもComposeのランタイムが必要になります。このランタイムを追加してくれないと、エラーが吐き出され、Ktorが起動できなくなっています。何かKotlin/JSのみの依存関係にpluginを追加する他の方法があるかもしれませんが、とりあえずはJVMの依存関係に以下のようにランタイムを追加することで問題は解消できました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> jvmMain &lt;span style="color:#66d9ef">by&lt;/span> getting {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dependencies {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-core-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation(&lt;span style="color:#e6db74">&amp;#34;io.ktor:ktor-server-auth-jvm:&lt;/span>&lt;span style="color:#e6db74">$ktor&lt;/span>&lt;span style="color:#e6db74">_version&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> implementation(compose.runtime) &lt;span style="color:#75715e">// Composeランタイム
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="その他">その他
&lt;/h2>&lt;p>Kotlin/JSとKotlin/JVMを一つのプロジェクトとして扱う場合に、&lt;code>common&lt;/code>というパッケージを設けることで、コードの共有ができるのが何より嬉しかったところです。例えば、JSONオブジェクトをdata classとして定義してcommonパッケージに置くことで、FrontendとBackendの両方で同じオブジェクトを使うことができます。他にももちろんEnumやconstを共有できたりするので、実装がかなり楽でした。&lt;/p>
&lt;p>また、今回は採用しなかったのですが、Ktor Serverの場合&lt;a class="link" href="https://ktor.io/docs/type-safe-routing.html#resource_classes" target="_blank" rel="noopener"
>Type-safe Routing&lt;/a>というものに対応しているので、うまく活用できたらかなり良さそうな気がしました。これはKtor Clientでも&lt;a class="link" href="https://ktor.io/docs/type-safe-request.html#define_route" target="_blank" rel="noopener"
>Type-safe Request&lt;/a>として対応しているので、FrontendとBackend両方で使える機能です。またKtorを使う機会があったら、ぜひ使ってみたいと思っています。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ファイルアップロードが思った通り改善できなかったので、アプリの完成はまだ少し先のことになりそうですが、かなり面白い経験となりました。Kotlinでできることは色々とあるので、また何か作ってみたいものがあればチャレンジしてみたくなります。ただ、やはりまだ成熟してない技術なので、思ってもなかったところで問題が発生したりリファレンスがあまりないという点ではまだプロダクションレベルでは使えないものかなという気がします。&lt;/p>
&lt;p>アプリ全体のコードはGitHubにて公開していますので、&lt;a class="link" href="https://github.com/retheviper/FileTransporter" target="_blank" rel="noopener"
>こちら&lt;/a>から参照できます。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinでデスクトップアプリを作ってみた</title><link>https://retheviper.github.io/posts/kotlin-compose-desktop/</link><pubDate>Fri, 09 Sep 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-compose-desktop/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinでデスクトップアプリを作ってみた" />&lt;p>バックエンドの開発をしていると、テストの自動化では対応できない場合もありますね。理想的なシナリオとしては、ユニットテストから全てのシナリオを想定したインテグレーションテストまでを全部作成でき、開発・企画に属するものがそれらを理解しきっていることだろうとは思いますが、現実ではなかなか難しいものです。特に、サービスが成長していきながら技術的負債を解消しようとしたり、新しい機能を足したり、昔は対応できなかった改修が必要となったり、運用上のイレギュラー対応が必要となったりなどで最初の仕様は変わり続けていき、改修を行うエンジニアや運用する側でも今の状態がどうで、どう変わるべきかを判断するのは難しくなりがちなのだから、と自分は理解しています。&lt;/p>
&lt;p>なので、少なくとも今のアプリがちゃんと想定通りに動くかどうかを人の手で検証する必要が出てくるケースも十分にあり得るものです。そしてそうなった場合はどうやってテストを行うかを考える必要もありますね。テストの方法も色々あり、小さい機能単位でユニットテストを行い、最終的にはインテグレーションテストやシナリオテストまで上がっていくと良いはずですが、その全部を自動化するのが難しいケースもあるかと思います。例えばテストするためのデータのパターンを色々と用意する必要があったり、エンジニアが完全に仕様を把握してなかったりなどの場合もありますね。なので、人の手によるテスト（モンキーテスト的な）が必要となる場面も存在すると思います。&lt;/p>
&lt;p>今回はその「人の手によるテスト」を手伝うために、テストツールを作った話です。自分の扱っているシステムはマイクロサービスの一つであり、業務仕様が複雑でさまざまなパターンで機能をテストする必要がありました。なのでエンジニアとしては実装を進めながら、同時に業務仕様に詳しい人にさまざまなパターンのデータを使ってテストができるツールを作ることになったわけです。&lt;/p>
&lt;h2 id="目標と設計技術選定">目標と設計、技術選定
&lt;/h2>&lt;p>実は以前から、リポジトリにはすでにテストツールが存在していました。しかし調べたところ、作られて2年以上放置されていて、Ruby on railsという自分が全く触れたことも（興味を持ったことも）ないフレームワークで作られているという問題がありました。これだと、自分がRubyを勉強して既存のツールを改修するという手もあったかもしれませんが、以下の理由から一から作り直そうと思いました。&lt;/p>
&lt;ol>
&lt;li>KotlinエンジニアがRubyアプリをメンテするのは良くない&lt;/li>
&lt;li>ドキュメント化が進んでなく、使い方が不便&lt;/li>
&lt;/ol>
&lt;p>そう決めてからは、テストを行いたい側（企画）からの要請を受け、ツールに要求される仕様としての機能をまとめることに。テストが行えるツールという確実な目標があったので、仕様は極めて単純です。要求事項としてツールに揃うべき機能は以下のようなものでした。&lt;/p>
&lt;ul>
&lt;li>テストデータのファイルを読み込ませる&lt;/li>
&lt;li>バックエンドのアプリのAPIを呼び出す&lt;/li>
&lt;li>APIの実行結果をファイルに書き込む&lt;/li>
&lt;/ul>
&lt;p>テストツールとしては上記に挙げている要求事項を満たしているならテストツールとしては合格というわけです。しかし、実際のテストを行いたい側がまずエンジニアではなく、今後もエンジニアではない人がツールを触る可能性があります。そこまでを考慮して、以下の追加的な目標を立てました。&lt;/p>
&lt;ul>
&lt;li>環境構築をしなくても使えるようにする&lt;/li>
&lt;li>手順書がなくても使えるくらい簡単なものに仕上げる&lt;/li>
&lt;/ul>
&lt;p>ここまで決めたら、次に要求されている機能の細部を掘り下げていきます。設計書を書くほどでもないですが、土台となる設計のようなものです。&lt;/p>
&lt;ul>
&lt;li>データの読み込みと書き込み
&lt;ul>
&lt;li>ツールを使える人はSQLが使える=テーブル（表）が読める&lt;/li>
&lt;li>テーブルの形でデータの入出力ができた方がわかりやすい&lt;/li>
&lt;li>テストデータはCSVで読み込む&lt;/li>
&lt;li>API実行結果もCSVに書き込む&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>APIコールができる
&lt;ul>
&lt;li>HTTPクライアントでGET・POSTする&lt;/li>
&lt;li>APIコールにはトークンが必要
&lt;ul>
&lt;li>トークンはセキュリティ問題でソースコードに埋め込むのはNG&lt;/li>
&lt;li>しかし毎回入力するのはめんどくさい&lt;/li>
&lt;li>アプリを実行して最初はトークンを入力し、次回からはそのトークンを使い回すようにする&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>本番以外の環境が対象
&lt;ul>
&lt;li>複数の環境があるのでどれかを選択できるようにする&lt;/li>
&lt;li>これも毎回入力はめんどくさい&lt;/li>
&lt;li>最初に一回だけ選択できるようにしたい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>そして自分の立てた目標を、上記の要求事項を達成できるかどうかを考えながら振り返ってみます。環境構築をしなくても使えるなら、実行可能な一つのバイナリとして提供した方が良いでしょう。また、使い方が簡単な方だと、やはりGUIを含めた方が良いですね。特にGUIを採用したら要求事項に対してもかなり良い感じで機能を完成できると思いました。&lt;/p>
&lt;p>例えばファイルの読み込みや書き込みにはパスの指定が必要で、トークンと環境の選択も入力が必要な項目で、CLIだとやはり不便です。エンジニアではない人が触るとしたら尚更ですね。Windowsユーザなら、コマンドラインも考慮しなければならないかもしれません。その反面、GUIだとファイルパスならダイアログ、トークンの入力もテキストポックス、環境の選択ならプールダウンメニューで対応できます。なので、「バイナリの実行で起動できるGUIのアプリを作る」という結論を出しています。&lt;/p>
&lt;h2 id="compose-for-desktop">Compose for Desktop
&lt;/h2>&lt;p>テストツールの仕様と技術的な要件が決まったら次は技術選定になりますがね。まずどの言語を使うかについてですが、自分以外でも同じチーム、つまりKotlinエンジニアがこれからもメンテを行うことになる可能性が高いのでKotlinにしました。Kotlinを使うことで、機能の実現で必要なライブラリの選定も楽になりますね。すでにテスト対象のバックエンドアプリで使っているHTTPクライアントがあるので、一部のコードはそのまま移植しても良いはずです。また、同じライブラリを使うことでメンテもより簡単になるでしょう。&lt;/p>
&lt;p>あとはGUIですが、今回は&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-desktop/" target="_blank" rel="noopener"
>Compose for Desktop&lt;/a>を使うことにしました。KotlinはJavaと互換性があるので、当然&lt;a class="link" href="https://ja.wikipedia.org/wiki/Swing" target="_blank" rel="noopener"
>Swing&lt;/a>や&lt;a class="link" href="https://openjfx.io/" target="_blank" rel="noopener"
>JavaFX&lt;/a>などJavaのGUIツールキットをそのまま使うという選択肢もあります。他にも&lt;a class="link" href="https://github.com/edvin/tornadofx" target="_blank" rel="noopener"
>TornadoFX&lt;/a>という選択肢があったりもしますが、今回あえてComposeを選んだのはいくつかの理由があります。&lt;/p>
&lt;p>まずは個人的にモバイルに興味があって以前から興味を持っていたので、今回本格的にこれでアプリを作ってみたいという願望もありましたが、今後もKotlinエンジニアの手でメンテが行われるとすると、やはりモバイルの経験があるか、少なくとも興味を持つ方が多いだろうという点です。Composeはまだ正式リリースされて1年ほどしか経ってない新しいものですが、最近流行っているいわゆる「宣言型」のフレームワークなので、少なくともAndroidアプリの開発ではメインストリームになる可能性が高いだろうという判断からでした。&lt;/p>
&lt;p>また、Composeはモバイルのみでなく、そもそもマルチプラットフォーム向けに開発されたものなので、Windows/Mac/Linuxの環境を問わず実行可能なバイナリをビルドできるという点でも魅力的だったです。これならテスターがどんなOSを使っていても同じ感覚でツールを使えて、&lt;/p>
&lt;p>ただ、やはり今まであまり接したことのない技術なので勉強はもちろん試行錯誤などもあったので、テストツールを作りながらこれは覚えておいた方が良いなと思ったところをいくつか挙げてみようと思います。&lt;/p>
&lt;h3 id="状態管理">状態管理
&lt;/h3>&lt;p>&lt;a class="link" href="../swift-ui-first-impression-2/" >SwiftUIのポスト&lt;/a>の時も触れた状態管理ですが、Composeでも同じくGUIを扱うことになるので、状態管理が大事となります。今回はアプリとしての画面がひとつしかないので、複数の画面にまたがって状態を管理する必要はないかなと思いましたが、それでもやはり処理を行うためにはアプリ全体で共有する状態として管理が必要なものがいくつかありました。&lt;/p>
&lt;p>ただ、上記ポストでも述べた通り、SwiftUIとComposeとは状態管理の方式が少し違います。SwiftUIでは状態がどこで使われるかによって明確に使われるアノテーションやクラスなどが変わっていたなら、Composeでは大体&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary?hl=ja#remember%28kotlin.Function0%29" target="_blank" rel="noopener"
>remember()&lt;/a>と&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState?hl=ja" target="_blank" rel="noopener"
>&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>&lt;/a>の組み合わせで事足りることになります。画面の構成要素の最小単位をComposeではWidgetでも使い方が同じだということは、SwiftUIと比べると定義するのは簡単ですが、使い方には少し注意が必要だなという感覚でした。&lt;/p>
&lt;p>まず、Composeでの状態は、以下のような三つの方法で定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Delegateで定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> isOn: Boolean &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#66d9ef">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 直接値を書き換えできる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>isOn = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 分解宣言で定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>isOff: Boolean, setIsOff: (Boolean) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#66d9ef">true&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 参照と更新が分離される
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (isOff) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setIsOff(&lt;span style="color:#f92672">!is&lt;/span>Off) &lt;span style="color:#75715e">// toggle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// MubtableState&amp;lt;T&amp;gt;として扱う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> isNotOff: MutableState&amp;lt;Boolean&amp;gt; = remember { mutableStateOf(&lt;span style="color:#66d9ef">false&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ラッパーになっているので、値を更新するためにはvalueにアクセスする必要がある
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>isNotOff.&lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#f92672">!is&lt;/span>&lt;span style="color:#a6e22e">NotOff&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでDelegateで&lt;code>var&lt;/code>として定義した場合は最も使いやすくなりますが、Intellij上ではコンパイルエラーになりがちです。なぜかというと、Delegateを使うためには&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#%28androidx.compose.runtime.MutableState%29.setValue%28kotlin.Any,kotlin.reflect.KProperty,kotlin.Any%29" target="_blank" rel="noopener"
>androidx.compose.runtime.setValue&lt;/a>と&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#%28androidx.compose.runtime.State%29.getValue%28kotlin.Any,kotlin.reflect.KProperty%29" target="_blank" rel="noopener"
>androidx.compose.runtime.getValue&lt;/a>をimportする必要がありますが、これが自動で行われないからです。最初このエラーの理由がわからなかったり、忙しい場合にいちいちimport文を書いていくが面倒だったりでかなり使わなくなるケースも多いかなという気がします。ただこれは、まだIntellijでのCompose対応が完璧ではないのが原因なので、これはいずれ解消されると期待できるでしょう。&lt;/p>
&lt;p>分解宣言で値の参照と更新を別々で使うのは、どこで使うか悩ましいケースもあるかなと思いますが、Composeの一部Widgetに状態を渡す場合に使われる場面があります。代表的なものが&lt;a class="link" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField%28kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors%29" target="_blank" rel="noopener"
>TextField&lt;/a>で、これはコードを見るとすぐにその目的がわかります。実際のコードで、以下のように使われます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>text: String, updateText: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) = remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TextField(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> onValueChange = setValue, &lt;span style="color:#75715e">// TextFieldに文字を入力するとその値でtextを更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">value&lt;/span> = text &lt;span style="color:#75715e">// textの値をTextFieldに表示する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後に&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>として定義するケースですが、直接的な値の更新ができないので最も使い方としては不便なのですが、実際は最も多く使われるのではないかと思います。なぜかというと、アプリ全体で状態を共有するなど複数のWidgetをまたがって使う場合は、以下のようにclassの中にフィールドとして&lt;code>MutableState&amp;lt;T&amp;gt;&lt;/code>を定義することになるからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// アプリ全体で共有するためにクラスに状態を定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> isOn: MutableState&amp;lt;Boolean&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはもちろん別途&lt;a class="link" href="https://kotlinlang.org/docs/properties.html#getters-and-setters" target="_blank" rel="noopener"
>getter/setter&lt;/a>をclassに定義しておくと、中のvalueにアクセスしなくても直接プロパティにアクセスする感覚で使えます。イメージ的には以下のようなものですね。これだと状態として管理したい項目が増えれば増えるほどコードの量が増えてしまう面倒さがあるというのが短所かなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AppState&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> _isOn: MutableState&amp;lt;Boolean&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> isOn: Boolean
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = _isOn.&lt;span style="color:#66d9ef">value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>) { _isOn.&lt;span style="color:#66d9ef">value&lt;/span> = &lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このように、Composeでの状態には定義する方法が色々あり、それぞれの特徴があるわけなのでどの場面で使うかによって適切な定義の方法を考えるのが何よりも大事だという印象です。&lt;/p>
&lt;h3 id="swingawt">Swing/AWT
&lt;/h3>&lt;p>Compose for Desktopの特徴の一つは、Swingや&lt;a class="link" href="https://en.wikipedia.org/wiki/Abstract_Window_Toolkit" target="_blank" rel="noopener"
>AWT&lt;/a>に対する互換性があるという点です。最初は&lt;a class="link" href="https://github.com/JetBrains/compose-jb/blob/master/tutorials/Tray_Notifications_MenuBar_new/README.md" target="_blank" rel="noopener"
>Macのトレイ、メニューバー、通知&lt;/a>にも対応していたので基本的な機能は全て揃っているのではないかと思いましたが、実はそうでもなく、一部の機能はSwingやAWTの機能を借りて実装することになるケースもありました。実際、私の作ったテストツールでも一部SwingとAWTの機能を使っているところがあります。&lt;/p>
&lt;p>例えばファイル選択機能がそうです。CSVを読み込むためにファイル選択のダイアログを表示したかったのですが、ComposeのWigdetではまだ対応できてないので、やむを得なくAWTの&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/awt/FileDialog.html" target="_blank" rel="noopener"
>FileDialog&lt;/a>を使う必要がありました。以下がその実装の例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 選択したファイル名を状態として保持する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> fileName &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// AWTのファイル選択ダイアログを使う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>FileDialog(ComposeWindow()).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 選択できるのはCSVのみにしたい
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> setFilenameFilter { _, name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> name.endsWith(&lt;span style="color:#e6db74">&amp;#34;.csv&amp;#34;&lt;/span>, ignoreCase = &lt;span style="color:#66d9ef">true&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isVisible = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ファイルが選択された場合は状態を更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (!&lt;span style="color:#66d9ef">file&lt;/span>.isNullOrBlank()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileName = &lt;span style="color:#66d9ef">file&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これでも十分ではない場合もありました。フォルダのみを選択できるようにしたい場合に&lt;code>FileDialog&lt;/code>はあまり良い選択ではなかったのです。名前からそうですが、あくまでファイルの選択を想定したものであるため、フォルダのみを選択できるようにはできなかったのです。なので、フォルダのみを選択できるようにするためには、Swingの力も借りる必要があります。その場合は、以下のように実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 選択したフォルダのパスを状態として保持する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> selectedPath &lt;span style="color:#66d9ef">by&lt;/span> remember { mutableStateOf(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Swingのファイル選択ダイアログをディレクトリのみ選択できるように設定して定義する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> fileChooser = JFileChooser().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dialogTitle = &lt;span style="color:#e6db74">&amp;#34;Choose Directory&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fileSelectionMode = &lt;span style="color:#a6e22e">JFileChooser&lt;/span>.DIRECTORIES_ONLY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ダイアログを表示する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> (fileChooser.showOpenDialog(ComposeWindow()) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">JFileChooser&lt;/span>.APPROVE_OPTION) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ダイアログで選択したパスが状態として保持しているパスと違う場合、選択したディレクトリの絶対パスを状態として更新する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> path = fileChooser.selectedFile.absolutePath
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (selectedPath &lt;span style="color:#f92672">!=&lt;/span> path) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> selectedPath = path
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回はこの二つユースケースのみSwingやAWTが登場していませんでしたが、どんなアプリを実装するかによって他のAPIも色々と使う必要性が出てくるかも知れないという良い一例になっている気がします。まだComposeはリリースされて1年ほどしか経っていないので、今後のバージョンアップでより多彩なWidgetが追加されることに期待ですね。&lt;/p>
&lt;h3 id="ビルド">ビルド
&lt;/h3>&lt;p>Composeを選んだ理由の一つのバイナリのビルドができるという点ですが、これはかなり満足度が高かったです。&lt;code>gradle&lt;/code>を使って、コマンドひとつで実行可能なバイナリが生成されます。Macでビルドして見ると、他のアプリと同じくパッケージが生成されます。中を見ると、実行に必要なJREと依存関係のJarが含まれていて、ネイティブではなくJVM上で起動される構造になっていました。&lt;/p>
&lt;p>バイナリをビルドするときのオプションには色々なものがあり、OSの種類(Windows, Mac, Linux)によって違うアイコンを使ったり、基本的には含まれないモジュールを含むように指定したりすることができました。以下が実際のビルド時のオプションのサンプルです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>compose.desktop {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> application {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mainClass = &lt;span style="color:#e6db74">&amp;#34;com.testtool.MainKt&amp;#34;&lt;/span> &lt;span style="color:#75715e">// 実行時のメインクラスを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> nativeDistributions {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> packageName = &lt;span style="color:#e6db74">&amp;#34;Test Tool&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> packageVersion = &lt;span style="color:#e6db74">&amp;#34;1.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modules(&lt;span style="color:#e6db74">&amp;#34;java.sql&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;java.naming&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// デフォルトでは含まれないパッケージを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> macOS {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iconFile.&lt;span style="color:#66d9ef">set&lt;/span>(project.&lt;span style="color:#66d9ef">file&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;misc/appicon/icon-mac.icns&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> windows {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> iconFile.&lt;span style="color:#66d9ef">set&lt;/span>(project.&lt;span style="color:#66d9ef">file&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;misc/appicon/icon-win.ico&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ビルド時は注意が必要です。ビルドするとき、Composeでは内部的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/14/docs/specs/man/jpackage.html" target="_blank" rel="noopener"
>jpackage&lt;/a>を使うので、まずJava 15以上が必要となります。また、CPUのアーキテクチャによって違うJDKをインストールするようになっているため、ビルドするマシンと違うのアーキテクチャのCPUを使っているマシンをターゲットにすることはできません。&lt;/p>
&lt;p>つまり、自分の使用のMacだとApple Silicon用のバイナリが生成され、IntelチップのMacだとx64用のバイナリが生成されるということです。実際ComposeでApp Storeにアプリを提出した人もいるらしいのですが、Rosettaで起動できるということでIntelチップのMacを使ってビルドしているとのことでした。Universal Binaryを作りたい場合は、JDKそのものがまずUniversal Binaryとして提供されることを待つしかなさそうです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回はデスクトップアプリの中でもかなり制限された機能と単純なロジックしかないシンプルなものを作ったので、もしこれからまたComposeを使ってさまざまな機能を持つように実装するとしたら(マルチウィンドウやダークモード対応、ナビゲーションなど)また色々と発見があるかも知れない気がしています。個人的にはかなりためになる経験で、思ったより実装もそこまで難しくなかったので、ツールの機能を拡張するか新しいツールを作ってみるチャンスがあるとしたら再度Composeを使ってみたいなと思いました。&lt;/p>
&lt;p>まだリリースされてからそう長くもなく、足りない機能や情報も多かったり競合のフレームワークが色々とあるので未来はどうなるかわからないものですが、自分のようにKotlinをメインとしているエンジニアで、GUIに興味がある方なら一度はComposeを使って見ることをお勧めしたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>data classのListをCSVにする</title><link>https://retheviper.github.io/posts/kotlin-write-csv/</link><pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-write-csv/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post data classのListをCSVにする" />&lt;p>アプリを書いていると、DBに保存した形とは違う形でデータを読み込んだり出力するケースが多いです。代表的に、多くのバックエンドアプリで採用しているREST APIがそうですね。APIの入力値と戻り値は、DBに保存されている形とは一致しないケースが多く、必要(リクエストを送信してきた側の都合)に合わせて適切にパラメータを受け取り、レスポンスを返すようになっています。そして時と場合によっては、人間が楽に読める形としてデータをまとめる必要もあります。そういった場合はExcelファイルやCSV、PDFといったいろいろなものを想定できますね。&lt;/p>
&lt;p>今回のポストも場合も人が読める形のファイルとして、特にCSVを扱う場合にKotlin側の実装をどうやっていくかに関するものです。&lt;/p>
&lt;h2 id="kotlinでcsvを扱う">KotlinでCSVを扱う
&lt;/h2>&lt;p>KotlinのCSV読み込み/書き込みのライブラリとして&lt;a class="link" href="https://github.com/doyaaaaaken/kotlin-csv/" target="_blank" rel="noopener"
>kotlin-csv&lt;/a>があり、JVMだけでなくKoltin/JSの場合でもこのライブラリを使って簡単にCSVを扱えます。更に&lt;a class="link" href="https://github.com/blackmo18/kotlin-grass" target="_blank" rel="noopener"
>kotlin-grass&lt;/a>というライブラリもあり、&lt;code>kotlin-csv&lt;/code>との組み合わせででCSVのデータを簡単にdata classのListとしてまとめることもできますね。読み込みの際に指定できるデータのフォーマットやカスタムマッピングオプションなどの機能も豊富にあり、かなり使いやすく良いライブラリとなっています。&lt;/p>
&lt;p>しかし、実は&lt;code>kotlin-csv&lt;/code>を使うときに問題が一つあります。先に述べた通りCSVにデータの出力そのものは可能なものとなっているのですが、読み込みの時にdata classへのマッピングには別のライブラリが必要であったように、data classのリストを書き込むには追加の処理が必要となります。これは、kotlin-csvの書き込み用のメソッドが以下のようになっているからです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">writeAll&lt;/span>(rows: List&amp;lt;List&amp;lt;Any?&amp;gt;&amp;gt;, targetFile: File, append: Boolean = &lt;span style="color:#66d9ef">false&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">open&lt;/span>(targetFile, append) { writeRows(rows) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>rows&lt;/code>が書き込みで使うデータとなりますが、型が&lt;code>List&amp;lt;List&amp;lt;Any?&amp;gt;&amp;gt;&lt;/code>になっているので、列のデータを一つの行としてListに定義し、それをさらにListに格納することでCSVのデータ全体を定義する必要があります。これはつまり、data classのリストを書き込むためには、フィールド一つ一つを列として定義し、それらをListとしてまとめる必要があるということです。また、CSVには一般的にヘッダが含まれますが、&lt;code>List&amp;lt;List&amp;lt;Any?&amp;gt;&amp;gt;&lt;/code>の形だと最初の行にヘッダのみを定義した行は必要となることでもありますね。&lt;/p>
&lt;p>一見複雑に見えますが、&lt;a class="link" href="https://kotlinlang.org/docs/reflection.html" target="_blank" rel="noopener"
>reflection&lt;/a>を利用すると、data classのフィールド名とその値を得ることができますので、それを利用してdata classのListをこのメソッドに適した形に変えられます。これをヘッダを作る方法と、data classの値を行に変更する二つの段階で分けて説明していきます。&lt;/p>
&lt;h3 id="data-classからヘッダを作る">data classからヘッダを作る
&lt;/h3>&lt;p>まずはヘッダを作ります。ヘッダを作るには、data classからフィールドを取得し、そのフィールドの名前のみを取得するといいでしょう。&lt;code>id&lt;/code>というフィールドがあるとしたら、ヘッダもそのまま&lt;code>id&lt;/code>になるということです。フィールド名とは別の名前をつけたい場合はアノテーションを活用する方法を考えられますが、まずはフィールド名をそのまま使う方法から述べたいと思います。&lt;/p>
&lt;p>Kotlinのdata classから、フィールドを取得する方法が3つがあります。まずは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/members.html" target="_blank" rel="noopener"
>KClass.members&lt;/a>があります。ただ、これだとメソッドを含め、全てのメンバーを持ってくることになります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> members = Data&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.members
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(members)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String, fun Line_2.Data.component1(): kotlin.Int, fun Line_2.Data.component2(): kotlin.String, fun Line_2.Data.copy(kotlin.Int, kotlin.String): Line_2.Data, fun Line_2.Data.equals(kotlin.Any?): kotlin.Boolean, fun Line_2.Data.hashCode(): kotlin.Int, fun Line_2.Data.toString(): kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>フィールド名が現れているのでこれも使える方法の一つではありますが、やはりdata classだと基本的に&lt;code>equals()&lt;/code>, &lt;code>hashCode()&lt;/code>, &lt;code>copy()&lt;/code>, &lt;code>toString()&lt;/code>, &lt;code>componentN()&lt;/code>のようなメソッドが
できてしまうので、これらをフィルタする必要があります。例えば、以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> memberProperties = Data&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.members.filterNot { &lt;span style="color:#66d9ef">it&lt;/span>.name.contains(&lt;span style="color:#e6db74">&amp;#34;component&amp;#34;&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;copy&amp;#34;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;equals&amp;#34;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hashCode&amp;#34;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;toString&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(memberProperties)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、フィルタをしなくてももっと簡単にフィールドのみを抽出できる方法もあります。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect.full/member-properties.html" target="_blank" rel="noopener"
>memberProperties&lt;/a>を使うことです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> memberProperties = Data&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(memberProperties)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [val Line_2.Data.id: kotlin.Int, val Line_2.Data.name: kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この方法にも問題はあります。取得したフィールドの順番が、data classに定義した通りにならなく、アルファベット順になるということです。以下の例を見ると、nameとageの順で定義したフィールドが、ageとnameの順になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> name: String, &lt;span style="color:#66d9ef">val&lt;/span> age: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> memberProperties = Person&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(memberProperties) &lt;span style="color:#75715e">// name, age順にならない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [val Line_11.Person.age: kotlin.Int, val Line_11.Person.name: kotlin.String]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでどうしてもフィールドを定義した順に取得したい場合、data classのコンストラクタを使う方法があります。まずはコンストラクタを使った方法ですが、これはdata classに、自動的にコンストラクタがフィールドを定義した順番通りのパラメータを持つように生成されるということを利用した方法です。以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> parameters = Person&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.primaryConstructor&lt;span style="color:#f92672">!!&lt;/span>.parameters.mapNotNull { &lt;span style="color:#66d9ef">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(parameters) &lt;span style="color:#75715e">// [name, age]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>多少強引な方法ではありますが、これでフィールドとして使うフィールド名は取得できました。では、次にアノテーションを使う場合を見ていきましょう。&lt;/p>
&lt;h4 id="アノテーションを使う場合">アノテーションを使う場合
&lt;/h4>&lt;p>フィールド名をそのままヘッダとして利用したくない場合は、アノテーションを活用できます。フィールドとしてStringを持つアノテーションを定義して、ヘッダを読み取るときにそのフィールドにつけたアノテーションを取得するという方法です。例えば、以下のようなアノテーションを定義したとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Target&lt;/span>(&lt;span style="color:#a6e22e">AnnotationTarget&lt;/span>.PROPERTY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">annotation&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CsvHeaderName&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> value: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>アノテーションは、以下のようにdata classで使います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@CsvHeaderName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;名前&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@CsvHeaderName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;年齢&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> age: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そしてこのdata classのアノテーションを取得していきます。&lt;code>memberProperties&lt;/code>でフィールドを取得した場合、そのフィールドからアノテーションの一覧(アノテーションは複数存在できるので)を取得し、そこから先に定義した&lt;code>CsvHeaderName&lt;/code>のみをフィルタします。あとはアノテーションがあるかどうかをみて、どちらの値を使うかを決めればいいですね。以下のコードが、そのサンプルです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> datas = listOf(Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> headers = datas.first()&lt;span style="color:#f92672">!!::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.map { &lt;span style="color:#66d9ef">property&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name = &lt;span style="color:#66d9ef">property&lt;/span>.annotations.filterIsInstance&amp;lt;CsvHeaderName&amp;gt;().firstOrNull() &lt;span style="color:#75715e">// アノテーションはないケースもある
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> name&lt;span style="color:#f92672">?.&lt;/span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">property&lt;/span>.name &lt;span style="color:#75715e">// アノテーションがnullの場合は、フィールド名を使う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(headers) &lt;span style="color:#75715e">// [年齢, 名前]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>primaryConstructor&lt;/code>のパラメータで取得した場合でも、やり方は大きく変わりません。この場合は、コンストラクタのパラメータを基準にループしながら一致するフィールドを探すという処理が追加されるだけです。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> fieldNames = seeds.first()&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.primaryConstructor&lt;span style="color:#f92672">!!&lt;/span>.parameters.mapNotNull { &lt;span style="color:#66d9ef">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> headers = fieldNames.mapNotNull { name &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// パラメータと一致するフィールドを対象に処理を行う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> datas.first()&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.find { &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> name }&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">property&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> headerName = &lt;span style="color:#66d9ef">property&lt;/span>.annotations.filterIsInstance&amp;lt;CsvHeaderName&amp;gt;().firstOrNull()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> headerName&lt;span style="color:#f92672">?.&lt;/span>&lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">property&lt;/span>.name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで、ヘッダのデータはできました。次は、このヘッダに合わせて下に出力する行としてdata classをListに変換するのみですね。&lt;/p>
&lt;h3 id="data-classをlistに変える">data classをListに変える
&lt;/h3>&lt;p>ヘッダの処理で既にやっていたように、data classをListに変換する場合でも処理は大きく変わりません。違う点は、フィールドから実際のデータを取得するだけですね。ここでは、コンストラクタからパラメータを取得した場合を想定してコードを書きましょう。&lt;/p>
&lt;p>Kotlinのreflectionでフィールドの値を取得する場合はJavaと変わらなくて、取得したフィールドにdata classのインスタンスを渡すだけとなります。ただ、フィールドがnullの場合は考慮する必要があります。nullになってしまうと、その列自体がスキップされ、最終的に出力されたCSVのデータで列がずれる場合があるからです。なので、空白のStringを指定するなどで、行ごとの長さ(Listのサイズ)を合わせる必要があります。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>datas.map { d &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fieldNames.mapNotNull { name &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.find { &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> name }&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">field&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span>.call(d) &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// フィールドの値を取得し、nullのばいは空白にする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここで時間や日付を扱う場合、フォーマッタを利用したいケースがあるかと思います。例えば、アプリの中では&lt;code>LocalTime&lt;/code>として扱っているが、CSVとしては&lt;code>HH:mm&lt;/code>のような形で出力したい場合や、&lt;code>LocalDate&lt;/code>を&lt;code>yy/MM/dd&lt;/code>にしたい場合などですね。ここでフォーマット自体は、&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>を使うだけですが、問題は取得したフィールドがどの型であるかの判定です。&lt;/p>
&lt;p>Kotlinのreflectionで取得したフィールドは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property1/" target="_blank" rel="noopener"
>KProperty1&lt;/a>という型になっています。ここでどうやって元の型を取得するかが問題ですね。このクラスは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-callable/" target="_blank" rel="noopener"
>KCallable&lt;/a>というインタフェースを実装していて、ここには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-callable/return-type.html" target="_blank" rel="noopener"
>returnType&lt;/a>というプロパティがあります。これで&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-type/" target="_blank" rel="noopener"
>KType&lt;/a>というインタフェースが取得できるようになるので、これを持って判定をおこ泣くことになります。&lt;/p>
&lt;p>しかし、名前から分かるように、&lt;code>KType&lt;/code>はKotlinの型に関するインタフェースとなっています。比較したい&lt;code>LocalDate&lt;/code>や&lt;code>LocalTime&lt;/code>などのクラスはJavaのものなので、直接的な比較ができないですね。幸い、JavaのクラスでもKotlinで参照できる&lt;code>Ktype&lt;/code>として変換することはできます。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> localDateKType: KType = LocalDate&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、あとは分岐によって適切なフォーマッタを使うだけですね。以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>datas.map { d &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fieldNames.mapNotNull { name &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.find { &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> name }&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">field&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span>.call(d)&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">field&lt;/span>.returnType) { &lt;span style="color:#75715e">// タイプによる分岐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> LocalDate&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> dateFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> timeFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalDateTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> dateTimeFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalDateTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、ここでもう一つ注意しなければならないのは、nullableなフィールドのKTypeは別のものになるということです。つまり、上記のコードでは、以下のようなdata classのフィールドは分岐処理でフォーマッタが働かなくなるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// どのフィールドもフォーマットされない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DateTimes&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> date: LocalDate?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> time: LocalTime?,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> dateTime: LocalDateTime?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合は、&lt;code>KType&lt;/code>を作るときにnullableであることを指定することで簡単に解決できます。あとは分岐で、両方チェックするようにするだけです。以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>datas.map { d &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fieldNames.mapNotNull { name &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> d&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.memberProperties.find { &lt;span style="color:#66d9ef">it&lt;/span>.name &lt;span style="color:#f92672">==&lt;/span> name }&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">field&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">field&lt;/span>.call(d)&lt;span style="color:#f92672">?.&lt;/span>let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (&lt;span style="color:#66d9ef">field&lt;/span>.returnType) { &lt;span style="color:#75715e">// nullableでもnullableではない場合でも分岐でフォーマットする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> LocalDate&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(), LocalDate&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(nullable = &lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> dateFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(), LocalTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(nullable = &lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> timeFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LocalDateTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(), LocalDateTime&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>.createType(nullable = &lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> dateTimeFormatter.format(&lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> LocalDateTime)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは、ヘッダと、data classから取得した値のリストを結合して&lt;code>kotlin-csv&lt;/code>の&lt;code>writeAll()&lt;/code>に渡すだけですね。一つ、値は上記のコードで既に&lt;code>List&amp;lt;List&amp;lt;Any&amp;gt;&amp;gt;&lt;/code>の形となっていますが、ヘッダは&lt;code>List&amp;lt;String&amp;gt;&lt;/code>なので、ヘッダは更にListに入れる必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ヘッダ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> header = &lt;span style="color:#75715e">// 省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 実際のデータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> rows = datas.map { &lt;span style="color:#75715e">/** 省略 */&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>csvWriter().writeAll(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows = listOf(headers) + rows,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetFile = targetFile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでヘッダが先に行に書き込まれ、次の行からはdata classのフィールドに格納した実際の値が出力されることになりました。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>この度軽く「KotlinなんだからKotlin制のライブラリを使おう」と、軽い気持ちで採用したライブラリが想定していたものと違ったので困っていましたが、幸いJavaを使っていた時に&lt;a class="link" href="https://poi.apache.org/" target="_blank" rel="noopener"
>Apache POI&lt;/a>を使って似たような機能をするライブラリを作ってみた経験があったのでその知識を活かせたと言えます。当時はまだ駆け出しのエンジニア(今もそうと思っていますが)だったので大変苦労した思い出でもありますが、今はその経験があってこそ対処できたようなものなので大変ありがたい経験だったなと思いました。&lt;/p>
&lt;p>上記のコードに対してはちょっとしたライブラリを作ってみたので、またどこかで活用してみたいものですね。色々と改善して、のちにMaven Repositoryのようなところでも公開できるようになったらなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinのこれからを語る</title><link>https://retheviper.github.io/posts/kotlin-prospect/</link><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-prospect/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinのこれからを語る" />&lt;p>1年ほどサーバサイドKotlinを扱いながら、ふと「今のKotlinはどこまできていて、これからはどうなるんだろう」と思うようになりました。色々な観点があると思いますが、とりあえず市場においてどれほどの需要があり、展望（これからも積極的に採用され続けそう、苦戦しそうなどの）はどうかなど、いわゆるkotlinという言語の「ステータス」について自分が感じていることについて考えてみたくなったというわけです。&lt;/p>
&lt;p>最近のトレンドを見ると、一つの言語において専門家になるというよりはさまざまな言語を使いこなせる、いわゆる&lt;code>Polyglot&lt;/code>なプログラマが求められていて、常識みたいになっているとも言われているようです。確かに私自信もその経験があるかどうかは関係なく、案件によりさまざまな言語に触れるケースを多くみています。そして今は充実したドキュメントや記事をインターネットに溢れていて、UdemyやCourseraなど良質の講義を提供するサイトも色々とあるので経験がない言語だとしても入門が難しくてできないとは言えない時代になっている感覚でもあります。なので、自分が現在使っている言語がメインストリームに属してあるかどうかの問題は以前よりは重要でなくなった、といえるかもしれません。&lt;/p>
&lt;p>ただ、立場や観点によっては一つの言語に集中したい場合もあるかと思います。例えば学生や、未経験からエンジニアに転職しようとする人にいきなり二つ以上の言語を扱えるように注文するのは難しいことでしょう。エンジニアの追求する技術においてもそうです。フロントエンドエンジニアがいきなり今すぐ使う予定でもないGoやJavaのようなバックエンドで使われる言語を勉強する必要はないはずです。そして会社としては、複数の言語を扱えるエンジニアを求めるということは採用において非常に厳しい条件となるはずです。なので、依然として市場において一つの言語のステータスというのは無視できないものなのではないかと私は思っています。&lt;/p>
&lt;p>というわけで、今回は多少主観的な観点からの話になりますが、他の言語や分野で、Kotlinという言語の展望について考えてみたことを述べたいと思います。それでは、どうぞ。&lt;/p>
&lt;h2 id="vs-java">vs Java
&lt;/h2>&lt;h3 id="better-javaという捉え方">Better javaという捉え方
&lt;/h3>&lt;p>Kotlin(JVM)をJavaと比べると、コンパイル結果がバイトコードを生成するため、「Javaと互換性が完璧であり、性能もまた変わらない」というのが世間一般でいうKotlinの評価ではないかと思います。その上拡張関数やCoroutine、スコープ関数、Null安全性などさまざまな機能が揃っているので、表面上は&lt;code>better java&lt;/code>と読んでも良いのではないかと思わせる面もあります。それに、JavaのバージョンアップでJVMの改良が行われると、結局それもKotlinの改善につながることとなりますね。Javaも1.8以降は半年に1回のリリース政策によりバージョンアップが早くなっていまずが、まだアプリケーションエンジニアの立場からするとKotlinと比べ惜しいところもなくはないかなと思います。&lt;/p>
&lt;p>ここまでの話だと、Kotlinは完璧にJavaを代替できる言語であるかのように聞こえます。つまり、これからは全くJavaを使う理由はなくて、何もかもKotlinに移行するという選択肢しかないかのようにですね。しかし、業界の事情はどうなのでしょうか。&lt;/p>
&lt;p>まずJavaの歴史から考えてみましょう。Javaは長い間、「世界で最もよく使われる言語」であって、他の言語が人気を得た今でもTop 5に入るほどの人気な言語となっています&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。そしてこれが示唆するのは、単純に今の人気、つまり、「これからも使われる可能性」だけの話ではなく、「今まで使われた回数」が圧倒的に高いということも意味するという点です。今まで作られた多くのシステムやアプリケーションがJava基盤になっているので、余程のことがない限りは維持保守や機能の拡張においてJavaのエンジニアを求めることになるでしょう。&lt;/p>
&lt;p>また、こういう側面もあります。JVM言語としてJavaのメリットを活かしつつ、より発展したコードを書けるというコンセプトで登場した言語はKotlinだけではないということです。今までClojure・Scala・Groovyなどさまざまな言語が登場し、それぞれの言語がそれなりの需要や分野を確保・拡張できてはいるものの、そのうちどれも「Javaを超えた」という評価をもらってはいないのが現状かと思います。同じくKotlinの場合も、その立場が他のJVM言語と大きく変わっているとは言えないものではないでしょうか。なので、「JVM言語だ」「Javaよりモダンだ」という特徴は、少なくともKotlinが今後Javaを超えられるという根拠にはならないかと思っています。&lt;/p>
&lt;p>モバイルではAndroidの言語としてJavaよりKotlinを採用する例が多くなっているかと思いますが、これはOracleとGoogleの訴訟絡みでJavaを1.8しか使えなかったことも理由の一つかと思います。現在Javaがよく使われているWebの場合、OpenJDKのバージョンに特に法理的な問題もなく、Java 17からはOracleJDKも無償で利用できるようになったので、モバイルとはまた状況は違うのではないかと個人的には思っています。&lt;/p>
&lt;p>もちろん、上記の問題はJetbrainsでもその点は最初から認識していたため、最初からKotlinがJavaと相互運用できる言語として設計した部分はあります。なので、あくまで既存のJavaアプリケーションをKotlinでリプレイスする、というよりは、部分的な移行から新規開発で占有率を徐々に上げていくことを目標としているのではないかと思います。その戦略は十分に納得できるもので、あとは企業の方でJavaとKotlinという二つの言語を同時に運用することに抵抗がなければ、Javaを使っていた場合でも問題なくKotlinを受け入れられると思います。実際、自分の場合でもJavaからKotlinの移行は全く問題ありませんでした。&lt;/p>
&lt;h3 id="kotlinも強くなる">Kotlinも強くなる
&lt;/h3>&lt;p>最近のフレームワークやライブラリの方をみると、まだKotlinがモバイル以外の分野での認知度は劣るものの、少しづつJavaがメインストリームであった分野で採用されているケースが増えてきているような気もします。例えば、自分が仕事で使っている&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.kotlin" target="_blank" rel="noopener"
>Spring boot&lt;/a>、&lt;a class="link" href="https://github.com/FasterXML/jackson-module-kotlin" target="_blank" rel="noopener"
>Jackson&lt;/a>、&lt;a class="link" href="https://github.com/awslabs/aws-sdk-kotlin" target="_blank" rel="noopener"
>AWS SDK&lt;/a>などウェブアプリケーションで有名なものがKotlinに対応していて、他にも&lt;a class="link" href="https://www.jooq.org/doc/latest/manual/getting-started/jooq-and-kotlin/" target="_blank" rel="noopener"
>jOOQ&lt;/a>、&lt;a class="link" href="https://jooby.io/v1/doc/lang-kotlin/" target="_blank" rel="noopener"
>jooby&lt;/a>、&lt;a class="link" href="https://javalin.io/" target="_blank" rel="noopener"
>Javalin&lt;/a>のようにJavaとKotlinの両方に対応しているものも増えています。&lt;/p>
&lt;p>もしくは、Javaで存在していたライブラリをKotlin向けに調整したものもあります。例えば&lt;a class="link" href="https://tornadofx.io/" target="_blank" rel="noopener"
>TornadoFX&lt;/a>、&lt;a class="link" href="https://github.com/grpc/grpc-kotlin" target="_blank" rel="noopener"
>gRPC&lt;/a>、&lt;a class="link" href="https://github.com/ReactiveX/RxKotlin" target="_blank" rel="noopener"
>RxKotlin&lt;/a>のようなものがそうです。そして、最初からKotlin専用として設計されたものも少なくないです。&lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>Kotlin Serialization&lt;/a>、&lt;a class="link" href="https://github.com/cbeust/klaxon" target="_blank" rel="noopener"
>Klaxon&lt;/a>、&lt;a class="link" href="https://github.com/Netflix/dgs-framework" target="_blank" rel="noopener"
>DGS&lt;/a>、&lt;a class="link" href="https://www.ktorm.org/" target="_blank" rel="noopener"
>Ktorm&lt;/a>、&lt;a class="link" href="https://github.com/kotest/kotest" target="_blank" rel="noopener"
>Kotest&lt;/a>、&lt;a class="link" href="https://github.com/mockk/mockk" target="_blank" rel="noopener"
>MockK&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>、&lt;a class="link" href="https://litote.org/kmongo/" target="_blank" rel="noopener"
>KMongo&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/xodus" target="_blank" rel="noopener"
>Xodus&lt;/a>、&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>、&lt;a class="link" href="https://github.com/Kodein-Framework/Kodein-DI" target="_blank" rel="noopener"
>Kodein-DI&lt;/a>などがそうですね。なので、Javaの世界に寄生していた数年前とは違って、Kotlinだけでもウェブアプリケーションを十分構築できるレベルまできているのではないか、というのが自分の考えです。&lt;/p>
&lt;p>結論として、まだ二つの言語を比べると、Javaの方が圧倒的に規模はでかく、知名度でも上にあるのですが、Kotlinも競争できる力を身につけてきたので、これからは十分状況が変わる可能性がある、と思っています。&lt;/p>
&lt;h2 id="vs-go">vs Go
&lt;/h2>&lt;h3 id="早いの美徳">「早い」の美徳
&lt;/h3>&lt;p>仕事でGoを使っている立場からすると、Kotlinに比べGoの優越な側面はやはり「とにかく早い」ということではないかと思います。基本的にネイティブにコンパイルされる言語なのでランタイム性能も優秀なはずですが、コンパイルもビルドもとにかく早いのは確かに良いなと思いました。特に、コードの修正後にユニットテストで検証してみることが多いのですが、Kotlinのプロジェクトと比べるととにかく早いのでストレスがないですね。(Kotlinの場合は使っているウェブフレームワークがSpringで、テストケースがより多い、ビルド時にはシングルスレッドでやっているということもありますが)&lt;/p>
&lt;p>そのほかにもGitHubのパッケージをそのまま使えたり、別途ライブラリを使わなくてもstructをすぐにJSONとして扱える(&lt;code>omitempty&lt;/code>とかも便利な場面がある)なところは印象的で、かなりウェブ開発に特化されているなという印象までありました。ネイティブなのでビルドして生成されるバイナリのサイズが小さいのも良いですね。これらの特徴からして、最近トレンドとなっているサーバレスやマイクロサービスなどおいてはKotlinよりGoを採用した方が有利な面が多いかなと思います。&lt;/p>
&lt;p>まだサーバがクラウド上のVMに移行したばかりの頃は、JVMを使う言語の問題はだいたいマシンスペックの向上により無視できました。しかし、サーバレスとマイクロサービスアーキテクチャが流行りながらJVMの特徴が再び問題となってきていますね。まずサーバレスだと、JVMが完璧にロードされるまで時間がかかるる上に、さらにコールドスタートにも時間がかかります&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。また、マイクロサービスにおいては、JVMが占めるヒープメモリとストレージが増えることでインスタンスごとのコストが増えるという問題が挙げられています。&lt;/p>
&lt;h3 id="kotlin--遅い">Kotlin != 遅い
&lt;/h3>&lt;p>このような問題に対して、サーバレスだと&lt;a class="link" href="https://site.kotless.io/" target="_blank" rel="noopener"
>Kotless&lt;/a>のようなフレームワークが開発されていたり、&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>を利用してネイティブビルドができる&lt;a class="link" href="https://ja.quarkus.io/" target="_blank" rel="noopener"
>Quarkus&lt;/a>や&lt;a class="link" href="https://github.com/spring-projects-experimental/spring-native" target="_blank" rel="noopener"
>Spring Native&lt;/a>が開発されるなど、JVM言語でも最近のトレンドに合わせて改善が行われていはいます。&lt;/p>
&lt;p>ランタイム性能という面では、JITによる最適化でJVM言語でもGoには劣らないという面もありますね。ベンチマークを見ると&lt;a class="link" href="https://programming-language-benchmarks.vercel.app/go-vs-kotlin" target="_blank" rel="noopener"
>Kotlin/JVMとの比較&lt;/a>や&lt;a class="link" href="https://www.lambrospetrou.com/articles/kotlin-http4k-graalvm-native-and-golang/" target="_blank" rel="noopener"
>Kotlin/Native&lt;/a>でわかるように、Goに対してKotlinが性能で劣る部分もあれば、優位にある部分もあるのがわかります。&lt;/p>
&lt;p>また、&lt;a class="link" href="https://go.dev/blog/intro-generics" target="_blank" rel="noopener"
>Go 1.18でジェエリックが導入&lt;/a>されていますが、&lt;a class="link" href="https://planetscale.com/blog/generics-can-make-your-go-code-slower" target="_blank" rel="noopener"
>ジェネリックにより遅くなる可能性がある&lt;/a>という話もあり、これからもしGoに新しい機能が追加されるとしたら、それがコンパイル速度やランタイム性能に影響を及ぼす可能性もあるかなと思います。&lt;/p>
&lt;p>なので、KotlinとGoという二つの言語で考えると、少なくともパフォーマンスという観点だけではGoにこだわる必要はないかなと思います。しかし、アプリケーションの開発において言語を選ぶ基準はパフォーマンスだけでなく、生産性やクラウドで対応している言語、エンジニアが確保できるかなど色々な側面があるので、Goの代わりにKotlinを選んだほうが効率的だとは言えないのも事実です。自分が転職を決めた時も、サーバサイドではGoのエンジニアを募集している企業の方がKotlinより多かったのですが、単純にパフォーマンスが基準だとしたらこのようなことにはならなかったでしょう。Googleが推している言語であるとか、パフォーマンスだけでなく生産性の面でも優れているなどさまざまな理由が複合的に作用した結果だと言えるものかと思います。&lt;/p>
&lt;h3 id="それでも有利なのは">それでも有利なのは
&lt;/h3>&lt;p>あとは、そもそもの知名度の問題ですね。Kotlinにおいて、ネイティブイメージのビルドができ、性能が劣らないとしても、多くの場合はKotlinをモバイル(Android限定)用の言語だと認識しているのが一般的かなと思います。なので、このような認識がエンジニアと企業で変わらない限り、これからもGoの方がサーバサイドでは市場において優位に立つという状況がしばらくは続くのではないかと思っています。&lt;/p>
&lt;p>他にも、Goはその書きやすさからや入門のしやすさの人気もあると思いますが、それを踏まえると比較的書き方が複雑なKotlinの方が劣るのではないかという推測もできそうですね。自分にとってはKotlinの書き方が簡潔で良い感覚ですが、Goの書き方を簡潔だと思っている方もいるようです。確かに、キーワードが少なく、それらを覚えるのに労力が比較的少ないなら、よりロジックに集中した書き方ができるはずですね。Goで作られたアプリやCLIツールなどが増えているのも、そのような特徴からのものなのではないでしょうか。自分の場合は簡単なツールを作るときはPythonで書くのを好みますが、同じく気軽にコードが書ける稼働かの観点でいうと、KotlinよりGoが優れているとも言える気がします。なので、個人の趣味やサイドプロジェクトなどでよく使われ、それがまた人気につながるだろうと思うと、Goを好むエンジニアが増えるのもおかしくはないですね。&lt;/p>
&lt;h2 id="vs-rust">vs Rust
&lt;/h2>&lt;h3 id="最強の性能">最強の性能？
&lt;/h3>&lt;p>GCがないので同じネイティブでありながらもGoより性能が優秀だというRustですが、これもまたKotlinと同じく、知名度の問題で苦戦しているところがあるかなと思います。そもそもC/C++を代替するのが開発の目的でもあったため仕方ないのかもしれませんが、どちらかというとエンベデッドで使われるイメージがどうしてもあるような気がしますね。意外と&lt;a class="link" href="https://www.figma.com/" target="_blank" rel="noopener"
>Figma&lt;/a>、&lt;a class="link" href="https://1password.com/jp/" target="_blank" rel="noopener"
>1Password&lt;/a>、&lt;a class="link" href="https://discord.com/" target="_blank" rel="noopener"
>Discord&lt;/a>、&lt;a class="link" href="https://www.dropbox.com/" target="_blank" rel="noopener"
>Dropbox&lt;/a>、&lt;a class="link" href="https://www.mozilla.org/ja/" target="_blank" rel="noopener"
>Mozilla&lt;/a>、&lt;a class="link" href="https://line.me/ja/" target="_blank" rel="noopener"
>Line&lt;/a>、&lt;a class="link" href="https://www.npmjs.com/" target="_blank" rel="noopener"
>npm&lt;/a>、&lt;a class="link" href="https://www.cloudflare.com/ja-jp/" target="_blank" rel="noopener"
>Cloudflare&lt;/a>などさまざまな組織で採用されていて、&lt;a class="link" href="https://github.com/ogham/exa" target="_blank" rel="noopener"
>exa&lt;/a>、&lt;a class="link" href="https://github.com/sharkdp/bat" target="_blank" rel="noopener"
>bat&lt;/a>、&lt;a class="link" href="https://github.com/Wilfred/difftastic" target="_blank" rel="noopener"
>difftastic&lt;/a>、&lt;a class="link" href="https://github.com/ClementTsang/bottom" target="_blank" rel="noopener"
>bottom&lt;/a>などのCLIツールから&lt;a class="link" href="https://yew.rs/" target="_blank" rel="noopener"
>yew&lt;/a>、&lt;a class="link" href="https://seed-rs.org/" target="_blank" rel="noopener"
>seed&lt;/a>、&lt;a class="link" href="https://dioxuslabs.com/" target="_blank" rel="noopener"
>Dioxus&lt;/a>、&lt;a class="link" href="https://rocket.rs/" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://github.com/http-rs/tide" target="_blank" rel="noopener"
>tide&lt;/a>、&lt;a class="link" href="https://github.com/poem-web/poem" target="_blank" rel="noopener"
>poem&lt;/a>のようなGUIやウェブフレームワークなどがたくさん開発されていますが、これもまた特に調査してみないとわからないくらいです。&lt;/p>
&lt;p>さまざまなベンチマークでその性能が検証されていて、使ってみたエンジニアからも評判の高いものとなっているRustですが、やはり知名度が低いので、企業からも採用するのはかなり難しい判断になるでしょう。実際Jetbrainsの去年の設問では&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/rust/#Rust_how-do-you-use-rust" target="_blank" rel="noopener"
>Rustは趣味もしくは個人用途、サイドプロジェクトで使う&lt;/a>と答えた割合のエンジニアが多かったのを見ると、やはり企業の需要はあまりようです。ただ、逆にいうと、このようにRustに好意的なエンジニアが増え、さまざまなプロジェクトで使われ始めるといつか市場の状況も変わっていく可能性もあるということです。先ほど述べたGoのケースのように、比較的に歴史の短い若い言語でも十分その価値を立証できるのであれば市場でもメインストリームに合流できます。なので、Rustの未来はむしろ明るく、これからが期待される言語だと個人的には思っています。ただ、人気を得た後も、ウェブアプリケーションを開発するよりは今まで通りエンベデッド・システムプログラミングに特化していきそうな気がしますね。&lt;/p>
&lt;h3 id="kotlinをネイティブにしたら">Kotlinをネイティブにしたら
&lt;/h3>&lt;p>RustをKotlinとの比較をするとしたら、Kotlin/Nativeがあるので、言語自体でできることはそう変わらないものの、Rustがエンベデッドやシステムプログラミングという分野でC/C++を代替していく傾向があるのに対して、これといった成果があまり見当たらないというのが問題かなと思います。特にKotlin/NativeはLLVM基盤なので、GraalVMによるネイティブコンバイるができるウェブフレームワークが登場している今はますますそのポジションが曖昧なものになっている気もします。Object-CやC/C++とのinteropができると言われていますが、そのようなユースケースだとそもそもObject-CやC/C++といった言語を使った方が色々と有利なのではないでしょうか。もちろん、Rustには所有権のような概念があり、他の言語と比べプログラミングが難しいとされているので、Kotlin/Nativeを採用した方がコーディングは楽になるかもしれません。でも、Nativeを追求するならやはりパフォーマンスが重視される場面が多いので、そこではGCのあるKotlinが不利な気がしますね。このような面からすると、やはりKotlin/Nativeのポジショニングが難しそうな気がします。&lt;/p>
&lt;p>結論としては、Kotlin(JVM)とRustはそれぞれ特化した分野が違っていて、大きな変化がない限り互いの領域を蝕むことなく発展していきそうです。どちらかというとKotlin/Nativeが直接的なライバルになる可能性はありますが、そもそものポジショニングが曖昧なところがあるので、Nativeがどうしても必要な場面ではRustが使われる可能性が高いのではないか、という気がしています。&lt;/p>
&lt;h2 id="vs-python">vs Python
&lt;/h2>&lt;h3 id="万能ツール">万能ツール
&lt;/h3>&lt;p>ここ数年で最も人気を得ている言語の一つ、Pythonの場合は、Kotlinと比べて見るとどうでしょうか。まず自分の場合だと、日常での自動化や簡単なツールを作る場面ではPythonの方をよく使っていて、本格的なウェブアプリケーションを開発するとしたらKotlinを選ぶことが多いです。もちろん、なんでもできる言語なので大規模のアプリケーションを作るのにPythonがNGというわけではないです。実際Uber、Google、PayPal、Netflixなど有種の企業がPythonを使っていて、あの有名なInstagramのサーバサイドもPythonで書かれていると言われていますね。&lt;/p>
&lt;p>ただやはり、PythonはデータサイエンスやAIといった分野でよく使われているイメージがあり、使いやすく、そこまで性能が求められていない場面でなら良いものの、個人的にはその限界が明確であることが問題かなという気もします。本格的な業務用のアプリを開発した経験がないのであくまで印象と推測の話となりますが、Pythonをサーバサイドに取り入れている企業は大概がスタートアップであって、サービスが古くなるとインタープリター言語特有のメンテが難しくなるという問題が出てくる可能性が高いではないかと思いますね。JavaScriptの例もありますが、Pythonのタイプヒントはあくまでヒントであって、TypeScriptのようにコンパイルタイムで検出できるエラーを確実にわかるわけでもないです。あとは性能ですが、&lt;a class="link" href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener"
>GIL&lt;/a>のような問題もあります。このような問題を認識しているため、検証用のアプリ(プロトタイプ)をPythonで書いてから他の言語に移行するという例もあるのかなと思ったりしています。&lt;/p>
&lt;h3 id="pythonだけの領域でもないが">Pythonだけの領域でもないが
&lt;/h3>&lt;p>逆にKotlinでいうと、Jupyterを使えるなど&lt;a class="link" href="https://kotlinlang.org/docs/data-science-overview.html#kotlin-libraries" target="_blank" rel="noopener"
>Kotlinでもデータサイエンスに使える&lt;/a>のですが、すでにPythonが市場支配的な言語になっているところでどこまで伸びるかが問題な気がしますね。JetBrainsが主張するように、Pythonと比べ「静的型付け、Null安全性、パフォーマンス」というのは確かにKotlinが持つメリットではあるのですが、そもそものユーザ数が増える何かがないと占有率を上げるのはかなり難しくないのではないかと思います。Pythonは入門が簡単なので講座も多く、実際エンジニアではない人も使うケースが多いのですが、Kotlinはまだそのような面では弱い印象ですね。&lt;/p>
&lt;p>以上のことからして、Pythonは依然としてデータサイエンスなど元々強かった分野に対してはこれからも需要が大きく変わることはなさそうです。ウェブという分野では競合になる可能性はありますが、どちらかというとKotlinを採用した方がより安定した開発ができるので大規模なアプリの開発ではKotlin、小規模ではPythonという形になるのではないかと思います。もちろん、大規模のアプリを開発するにあたってはまたの選択肢があるのでKotlinではない他の言語が採用される可能性の方が高そうですが、あくまで二つの言語を比べた場合の話となります。&lt;/p>
&lt;h2 id="vs-javascript">vs JavaScript
&lt;/h2>&lt;h3 id="多芸多才">多芸多才
&lt;/h3>&lt;p>一つの言語でなんでもできちゃう言語が何かというと、過去はJava、少し前はPython、そして今はなんといってもJavaScriptではないかと思います。フロントエンド、バックエンド、モバイル、データサイエンスなどさまざまな分野で活躍している言語ですね。ランタイムの性能が問題となっている部分に対しても&lt;a class="link" href="https://deno.land/" target="_blank" rel="noopener"
>Deno&lt;/a>のような新しいランタイムが登場したり、V8エンジンの持続的な改善によりだんだん補完されていって、静的型付けに関してもTypeScriptの台頭によって解決されています。まさに無敵の言語のようにも見えます。&lt;/p>
&lt;p>フロントエンドにおいてはJavaScript以外は考えられない&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>というのもあり、&lt;a class="link" href="https://webassembly.org/" target="_blank" rel="noopener"
>WebAssembly&lt;/a>のような技術も発達していますが、これはまたウェブの画面描画だけでなく違う方向に向かっているような感じなので、これから何かあって(あるとは思いませんが)色々な分野で使われなくなるとしてもJavaScriptそのものが使われなくなることはないでしょう。そして同じ意味で、Kotlinがそのような分野に進出するのもかなりハードルが高いと思います。&lt;/p>
&lt;h3 id="kotlinでフロントエンド">Kotlinでフロントエンド？
&lt;/h3>&lt;p>Kotlinで言えば、Kotlin/JVMとKotlin/Native以外に3つの軸として存在しているのが&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>であり、JetBrainsの発信を見るとそこそこ力を入れている感覚ではあります。他にも、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-mpp/" target="_blank" rel="noopener"
>Compose Multiplatform&lt;/a>を通じて、モバイルだけでなくウェブやデスクトップアプリにおいてもKotlinでGUIを作成できるようになったので、なるべく自分のサイドプロジェクトなどではKotlinで完結したいと思っている私の場合はこちらも応援したいと思っています。ただ、まだモバイル以外ではそこまでメジャーではなく、新しい技術の問題(ライブラリの不足、バージョンアップによる変化が激しいなど)が考えられるのでしばらくは様子見な感じですね。あと自分のような特殊な目的がない場合は、個人でも企業側としても無理して採用すべきメリットが薄いという問題もあるかなと思います。&lt;/p>
&lt;p>バックエンドだとKotlinが競合になる可能性はまだ十分ではないかと思います。特に、今までJavaが採用されていた分野だと主にJVMの安定性や数値計算の精度など検証された安全性というものがあるので、これから言語を変えるとしたらKotlinを採用する確率が高いのではないかと思っているところですが、そのような分野だと、最初からJavaScriptによるバックエンドの採用は考えない可能性が高そうです。スタートアップのようにエンジニアの求人が難しく、使われる技術の数を減らしてなるべく工数の削減しようとするか、Pythonのようにプロトタイプのアプリを作るかなどの特殊な状況ではない限り積極的にバックエンドの言語としてJavaScriptを採用する例はあまりなさそうな気がしていて、これからもおそらくそれは大きく変化していく気はしません。ただ、自分のようにKotlinで何もかも解決したい、という方がJavaScript側にもいらっしゃるとしたら、そこはまた話が変わってくるかもしれませんね。フロントエンド、バックエンド、モバイル、デスクトップまで対応したい場合にはJavaScript以上のものがないので、その会社や個人の目的次第でJavaScriptが採用される可能性は高く、そのような状況こそKotlinは採用されない可能性が高いかなと思います。&lt;/p>
&lt;h2 id="vs-dart">vs Dart
&lt;/h2>&lt;h3 id="guiの最強者">GUIの最強者？
&lt;/h3>&lt;p>Dartの場合は、言語そのものというよりは&lt;a class="link" href="https://flutter.dev/" target="_blank" rel="noopener"
>Flutter&lt;/a>が最近熱いですね。最初はモバイルでクロスプラットフォーム開発ができるということで注目されたものですが、Dartに対してはFlutterの最大の競合は&lt;a class="link" href="https://reactnative.dev/" target="_blank" rel="noopener"
>React Native&lt;/a>だと言えるかなと思いますが、それも最近のトレンドを見ると少しづつ逆転してきているような気がします。もちろんこれはあくまでも「クロスプラットフォーム用のフレームワーク」という基準での比較であり、実際は色々と複雑な事情があるでしょう。例えば、フロントエンドエンジニアがモバイルの開発も担当していて、フロントエンドのライブラリとしてはReactを使っているなどの状況を考えると、ここでいきなりFlutterを採用する可能性は低くなるはずですので。&lt;/p>
&lt;p>自分が思うにDartの最大の問題は、その最初の意図(JavaScriptを代替するという)はともかく、言語そのものの印象が薄いということです。少しだけ触ってみた感覚では、いわゆるC-Family言語としての馴染みはあっても、特段ここが魅力的だというところはあまり感じ取れなかったです。それが今はFlutterのおかがで使用率は上がってきていますが、それ以外の分野ではどうかなという疑問がまだあります。&lt;/p>
&lt;h3 id="可能性は他にもあるかもだけど">可能性は他にもあるかもだけど
&lt;/h3>&lt;p>ただ、以前からGoogleの次世代OSである&lt;a class="link" href="https://fuchsia.dev/" target="_blank" rel="noopener"
>Fuchsia&lt;/a>ではメインの開発環境となるという噂もあり、FuchsiaそのものがどんなOSになるかはまだ不明な状態ですが、もし噂通りAndroidの次世代のOSになるとしたら、ネイティブの開発そのものがDartによるものにもなり得る可能性はありますね。もしそうなると、ChromeOSを含めレガシーの環境を捨てることになるので、公式の開発の言語にKotlinを指定した時とは比べ物にならないインパクトがあることを想定すると、なかなか想像できない事態です。&lt;/p>
&lt;p>もちろんDartもプログラミング言語なので、これからのフレームワークやライブラリの開発次第でいくらでも状況は変わる可能性があります。&lt;a class="link" href="https://github.com/yissachar/awesome-dart" target="_blank" rel="noopener"
>こちらのリポジトリ&lt;/a>を参照すると、サーバサイドのフレームワークもすでにいくつか存在しているので、自分の考えているKotlinで全てを解決する、という目標においてはむしろDartの方がやりやすい可能性がありますね。Kotlinの方だと&lt;a class="link" href="https://kotlinlang.org/lp/mobile/" target="_blank" rel="noopener"
>Kotlin/Multiiplatform Mobile&lt;/a>がありますが、これはどちらかというとビジネスロジックの共通化を目標としているものなので、結局iOSのコードを書く必要があります。もちろん、一部の企業でやっているように「UIはFlutterで、ビジネスロジックはネイティブで」ということもできるかとは思いますが、あまりメジャーなやり方にならないかなと思います。実際、Swiftの場合も&lt;a class="link" href="https://vapor.codes/" target="_blank" rel="noopener"
>Vapor&lt;/a>のようなフレームワークがあり、サーバサイドでも十分使えるということをアピールしていますが、採用しているエンジニアや企業が限りなく少ないというのを見ると、単純に「できる」だけでは十分ではなさそうですので。&lt;/p>
&lt;h3 id="モバイルでも強くなっていく">モバイルでも強くなっていく
&lt;/h3>&lt;p>特に今年開催された&lt;a class="link" href="https://io.google/2022/intl/ja/" target="_blank" rel="noopener"
>Google I/O&lt;/a>で確認できるように、Flutter 3ではさらにパフォーマンスの向上やFlutter Desktopの正式リリースなど様々な面での発展を見せていて、これからもFlutterの未来は明るく見えます。Flutterを採用している企業も増えてきているので、このような発展の恩恵を受け入れるのは結局時間の問題に過ぎない気がします。もちろん、ネイティブアプリの開発においても需要はこれからもあり得ると思いますが、クロスプラットフォームアプリでも事足りる分野が増えてくるとしたら、どちらがメインストリームになるかは目に見えるようなものですね。&lt;/p>
&lt;p>このような状況では、今の占有率においてKotlinのホームグラウンドとなっていると言っても過言ではないモバイルの分野で、Flutterの成長ぶりはある意味、Kotlinにおいては脅威のようなものではないかという気がします。なので、これからKotlinならではのメリットをより強化していく必要がありそうですね。先の述べたKotlin/Multiplatform Mobileのようなものが、その役割をしてくれるのではないかと期待しています。そのほかでも、Kotlinでできることは多いので、分野を問わない連携を強化していくと十分Kotlinを利用するメリットはこれからも出てくるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回は、いつもと違って自分の考えが中心になる記事なので、色々と偏った判断があるかもしれませんが、とりあえずKotlinエンジニアとしての感想をまとめてみました。もちろん、自分の知見が足りてなく、モバイルやフロントエンド、データサイエンティスト、DevOpsエンジニアなど色々な分野で活躍されている方からしたら色々と間違っているか、的確ではない情報や判断も目立つかなとも思います。&lt;/p>
&lt;p>ただ、一人のエンジニアとして、ただの時流を淡々と見つめているよりは、目指す目標に対して使っている技術や興味のいくものに注目し、自分なりの判断をしてみるのもまた必要なものではないかという気がして、このような記事を作成することになりました。また、このような記事を作成することで、この後に色々な変化があって自分の展望がどれだけあっているか、実際と比べてみるのもまた有意義な振り返りとなりそうな気もします。&lt;/p>
&lt;p>今回はあまり情報がなく、Twitterにでもつぶやいたら良いかも知れない雑談に近いものですが、少しでもここでKotlinのことを改めて認識できたという方がいらっしゃるなら幸いです。&lt;/p>
&lt;p>では、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a class="link" href="https://spectrum.ieee.org/top-programming-languages" target="_blank" rel="noopener"
>IEEE Spectrum&lt;/a>、&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE&lt;/a>、&lt;a class="link" href="https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-programming-scripting-and-markup-languages" target="_blank" rel="noopener"
>Stack Overflow&lt;/a>、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/#Main_programming-languages" target="_blank" rel="noopener"
>Jetbrains&lt;/a>の調査結果を参照しました。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Warm(アイドルインスタンスを常に立ち上げておく)で対応できる部分ではありますが、スケールアウトするとコールドスタートが必要となる場合があり、インスタンスを立ち上げておくことでコストがかかる問題は避けられないですね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>Dartのような言語でJavaScriptを代替しようとした歴史がありますが、今は失敗していて、JavaScriptがより高度化した今はTypeScriptのようなスーパーセットやJavaScriptにトランスパイルできる言語でないとフロントエンドの言語を代替するのは難しいかと思われます。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Effective Kotlinを読む</title><link>https://retheviper.github.io/posts/effective-kotlin/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/effective-kotlin/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Effective Kotlinを読む" />&lt;p>今回は久々に本を読んだのでそれに関する感想を少し書こうと思います。転職前は主にJavaを扱っていたため、&lt;a class="link" href="https://www.amazon.co.jp/Effective-Java-%E7%AC%AC3%E7%89%88-%E3%82%B8%E3%83%A7%E3%82%B7%E3%83%A5%E3%82%A2%E3%83%BB%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF-ebook/dp/B099922DML/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=1OT3QRYCGG9BB&amp;amp;keywords=Effective&amp;#43;Java&amp;amp;qid=1645265607&amp;amp;sprefix=effective&amp;#43;kotlin%2Caps%2C753&amp;amp;sr=8-1" target="_blank" rel="noopener"
>Effective Java&lt;/a>を読み自分の書いたコードを振り返って見たことがありました。転職後はKotlinという違う言語を触るようになったものの、やはりJVMで動く言語であり、現在使っているフレームワークもSpringから変わってないので基本的には同じ観点でコードを作成すると良いのかなと思っていました。しかし、Kotlinに触れてから1年が経った今、やはり言語が違うとコードを作成するときの週間も一度は見直す必要があるのではないかと思っています。&lt;/p>
&lt;p>そこで、ちょうど&lt;a class="link" href="https://www.amazon.co.jp/Effective-Kotlin-Best-practices-English-ebook/dp/B08WXCRVD2/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=2HVT6TZYJL65A&amp;amp;keywords=effective&amp;#43;kotlin&amp;amp;qid=1645264802&amp;amp;sprefix=effective&amp;#43;kotli%2Caps%2C230&amp;amp;sr=8-1" target="_blank" rel="noopener"
>Effective Kotlin&lt;/a>という本を発見したので早速読んでみました。そして今回のポストではその内容について色々と書こうと思います。&lt;/p>
&lt;p>ちなみに、この本自体は出版されて少し経つので、ネット上でもたまにその内容やPDFの資料などを発見することあができました。例えば、この本で「可読性」のチャプタに関しての話は[こちらのブログ]の方によく整理されてあるので、参考にしてください。&lt;/p>
&lt;h2 id="全体的な印象">全体的な印象
&lt;/h2>&lt;p>個人的に&lt;code>Effective Java&lt;/code>は上級者向けの本で、ある程度Javaでアプリを書いたこと経験のある人でないと理解が難しいところが多かったかなと思います。例えば、「&lt;code>try-finally&lt;/code>を
&lt;code>try-with-resource&lt;/code>に代替した方がいい」とか、「&lt;code>Stream&lt;/code>で副作用のない関数を書く方法」などが紹介されていますが、これらはやはりある程度Javaという言語の設計と仕様に対する基盤知識を必要とするものですね。&lt;/p>
&lt;p>それに比べ、&lt;code>Effective Kotlin&lt;/code>には初心者向けの内容も結構あります。例えば、そもそものオブジェクト志向が何かのような内容がありました。ただそれだけではどう思っても&lt;code>Effective Java&lt;/code>を意識したような題名が意味をなくすと判断したからか（前書きでも&lt;code>Effective Java&lt;/code>を言及しています）他には「ベストプラクティス」として書かれているものも多いです。&lt;/p>
&lt;p>そして当たり前ながら、Kotlinにおいても有効なことは&lt;code>Effective Java&lt;/code>と重なっているような部分もあります。例えば、オブジェクトのインスタンスを作るときはfactory methodを書いた方が良いとかがそうですね。&lt;/p>
&lt;p>ただ、Kotlinのバージョンアップの速さに追いついてないと感じるところがあったり（これは出版物の限界でもありますが）、上級者向けの内容は多少十分ではない感覚でしたので、どちらかというとジュニア向けの感覚ではあります。&lt;/p>
&lt;h2 id="興味深い">興味深い
&lt;/h2>&lt;p>ジュニア向けといいつつ、自分もまだジュニア（の気持ち）であるため、興味深いと思ったところもありました。ここでその一部を紹介したいと思います。&lt;/p>
&lt;h3 id="single-responsibility-principle">Single responsibility principle
&lt;/h3>&lt;p>いわゆる&lt;a class="link" href="https://ja.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener"
>SOLID&lt;/a>に触れるパートです。Kotlinでは拡張関数を用いることで、単一責任の原則を守れるという主張をしていました。まず以下のようなケースがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">isPassing&lt;/span>(): Boolean =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calculatePointsFromPassedCourses() &amp;gt; &lt;span style="color:#ae81ff">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">qualifiesForScholarship&lt;/span>(): Boolean =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calculatePointsFromPassedCourses() &amp;gt; &lt;span style="color:#ae81ff">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculatePointsFromPassedCourses&lt;/span>(): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>isPassing()&lt;/code>は&lt;code>accreditations&lt;/code>というモジュールで、&lt;code>qualifiesForScholarship()&lt;/code>は&lt;code>scholarship&lt;/code>というモジュールで使われるとします。そしたら、&lt;code>Student&lt;/code>というクラスがこれらの関数を持つのは単一責任としてどうか、ということですね。&lt;/p>
&lt;p>なので、モジュール別にこれらの関数を拡張関数として定義することが良いとのことでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// scholarship module
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>.qualifiesForScholarship(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// accreditations module
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>.calculatePointsFromPassedCourses(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしくは&lt;code>calculatePointsFromPassedCourses()&lt;/code>を外に出す方法を考えられるでしょう。しかし、この場合はこれらの二つのメソッド専用のprivateメソッドとしてつかえません。なので、&lt;/p>
&lt;ol>
&lt;li>どのモジュールでも使える共通関数を作っておく&lt;/li>
&lt;li>department別にhelper関数を作っておく&lt;/li>
&lt;/ol>
&lt;p>とかの方法も考えられます。&lt;/p>
&lt;p>確かに、よく考えると拡張関数の良いところは「interfaceの実装ややスーパークラスの継承なし」でも簡単に処理を追加できるということなので、このような使い方をするのがユースケース別に処理を分けられて良さげな気がします。特に拡張関数を使うと、関数を配置するパッケージと可視性の制御が効くというところが個人的には新しい発見でした。&lt;/p>
&lt;h3 id="consider-defining-a-dsl-for-complex-object-creation">Consider defining a DSL for complex object creation
&lt;/h3>&lt;p>オブジェクトの作成時の複雑な処理はDSLを使いましょう、というパートです。Kotlinですでに提供している例としたら、HTMLがありますね。以下のような形で定義することになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>body {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> div {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a(&lt;span style="color:#e6db74">&amp;#34;https://kotlinlang.org&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target = &lt;span style="color:#a6e22e">ATarget&lt;/span>.blank
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +&lt;span style="color:#e6db74">&amp;#34;google&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +&lt;span style="color:#e6db74">&amp;#34;Some content&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>確かにKtorのようなフレームワークでもよく使われている物なので、ある程度需要はあるのかなという気がしました。Kotlinだと高階関数を作るのが難しくはないので、十分挑戦できるところでもありますね。&lt;/p>
&lt;p>ただ、DSL特有の書き方を確立し、その書き方をエンジニアに共有することや最初の設計と維持管理が難しそうな気がするので、アプリの縮小が求められる今のご時世に果たして合うかとうかは少し疑問ののころところでした。&lt;/p>
&lt;p>個人的に何かのライブラリやフレームワークを作るとしたら、挑戦してみたいなと思いました。&lt;/p>
&lt;h2 id="まあそうだよねって思ったところ">まあそうだよねって思ったところ
&lt;/h2>&lt;p>なんとなくそうではないかと思っていたところを（もしくはどこかで聞いて理論的な部分は忘れたけど、無意識的のうちに習慣化されていた部分を）文として親切に整理してくれているようなパートもありました。なのでもう一度自分の考えを再確認できたといえるところでしょうか。&lt;/p>
&lt;h3 id="do-not-repeat-common-algorithms">Do not repeat common algorithms
&lt;/h3>&lt;p>「スタンダードライブラリで解決できる一般的なアルゴリズムを自前のコードで書くな」というパートです。理由は以下の通りです。&lt;/p>
&lt;ol>
&lt;li>呼び出しの方がコードを書くより時間が短くかかる&lt;/li>
&lt;li>わかりやすい名前になっている&lt;/li>
&lt;li>コードがわかりやすくなる&lt;/li>
&lt;li>最適化が効く&lt;/li>
&lt;/ol>
&lt;p>私自身もなるべくスタンダートライブラリを活用した方が良いと思っていたので、ここはすぐに納得できました。自分で書いた処理が果たして最適化されたものかどうかもわからないし、業務使用以外のロジックを触るのは避けたいという理由でした。&lt;/p>
&lt;p>この本では、以下のようなコードを上げています。自前のロジックを書いた場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> percent = &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &amp;gt; &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &amp;lt; &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-in.html" target="_blank" rel="noopener"
>coerceIn()&lt;/a>を使うことでシンプルにできます。以下がその例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> percent = number.coerceIn(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinには特にスタンダードラリブラリに良い関数が多いので、自前のロジックを書くよりは一度どんなAPIがあるのかを確認した方が良いケースが個人的には多かった気がします。そしてそれが納得できる理由が書いてあってよかったと思います。&lt;/p>
&lt;h3 id="implementing-your-own-utils">Implementing your own utils
&lt;/h3>&lt;p>スタンダードライブラリで解消できる問題以外で、プロジェクトに必要な共通の処理はユーティリティ関数として作っておきましょうってパートです。ユーティリティはクラスでなく、拡張関数として作ったら以下のようなメリットがあるらしいです。&lt;/p>
&lt;ul>
&lt;li>関数は状態を持たないので副作用がない&lt;/li>
&lt;li>トップレベル関数と比べると型が決まっているので使い勝手がいい&lt;/li>
&lt;li>引数よりはクラスについた形が直観的&lt;/li>
&lt;li>オブジェクトに関数をまとめるより必要な機能を探しやすい&lt;/li>
&lt;li>特定のクラスに従属されるので親クラスのものか、子クラスのものか悩まない&lt;/li>
&lt;/ul>
&lt;p>確かにJavaを使っていた時は、私もいわゆるSingleton Patternでユーティリティクラスを作ったり、DIして使えるクラスを定義しておいて、staticメソッドを書いていました。Kotlinだと、ユーティリティクラスなしでも特定のクラスに関数を追加することができるのでより使い勝手がよくなります。&lt;/p>
&lt;p>例えば、同じことをするとしても、拡張関数で書く場合とユーティリティクラスを作る場合のコードは以下のような違いがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 拡張関数を使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> isEmptyByExtension = &lt;span style="color:#e6db74">&amp;#34;Text&amp;#34;&lt;/span>.isEmpty()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ユーティリティクラスを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> isEmptyByUtilClass = &lt;span style="color:#a6e22e">TextUtils&lt;/span>.isEmpty(&lt;span style="color:#e6db74">&amp;#34;Text&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ユーティリティクラスを使う場合はまず、「どのユーティリティクラスの関数を使うか」を考えなければならないです。それに比べ、拡張関数はIDEでも自動補完ですぐ欲しい関数を見つけることができるので、より直観的なものになっていますね。&lt;/p>
&lt;p>他にも具体的なクラスにのみ追加ができたりするので、より安全な使い方ができるというのも良いところですね。色々と拡張関数は使い道が多いなという、再発見ができたと言えるところでしょうか。&lt;/p>
&lt;h3 id="builder-pattern">Builder pattern
&lt;/h3>&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>named arguments&lt;/a>が使えて、Builderパターンがいらないというパートです。KotlinでもBuilderパターンを使うことが技術的に不可能ではないが、named parameterを使った方が良い理由としては以下が挙げられています。&lt;/p>
&lt;ul>
&lt;li>より短い&lt;/li>
&lt;li>より綺麗&lt;/li>
&lt;li>使い方がシンプル&lt;/li>
&lt;li>スレッドセーフ&lt;/li>
&lt;/ul>
&lt;p>私自身も、Javaで使っていたのでKotlinでもBuilderパターンが必要かなと思ったことがありますが、いらないという結論を出しています。上記で挙げた理由ももちろん妥当ですが、Builderパターンだとインスタンスを生成するときに必須パラメータが揃っているかどうかを判断するのが難しくなるという理由からでした。&lt;/p>
&lt;p>例えば本に出てくるBuilderパターンの例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Pizza&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> size: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> cheese: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> olives: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> bacon: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Builder&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> size: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> cheese: Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> olives: Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> bacon: Int = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">setCheese&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>: Int): Builder = apply { cheese = &lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">setOlives&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>: Int): Builder = apply { olives = &lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">setBacon&lt;/span>(&lt;span style="color:#66d9ef">value&lt;/span>: Int): Builder = apply { bacon = &lt;span style="color:#66d9ef">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">build&lt;/span>() = Pizza(size, cheese, olives, bacon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このBuilderは以下のような使い方ができると思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> villagePizza = &lt;span style="color:#a6e22e">Pizza&lt;/span>.Builder(&lt;span style="color:#e6db74">&amp;#34;L&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setCheese(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setOlives(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setBacon(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし以下の場合でもビルドはできますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> villagePizza = &lt;span style="color:#a6e22e">Pizza&lt;/span>.Builder(&lt;span style="color:#e6db74">&amp;#34;L&amp;#34;&lt;/span>).build()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もし&lt;code>cheese&lt;/code>、&lt;code>olives&lt;/code>、&lt;code>bacon&lt;/code>が&lt;code>0&lt;/code>を許容しない作りになっていると、これを修正するのは大変なことになるでしょう。もしくは、パラメータが複雑な作りのオブジェクトだったらデフォルト値を設定するか、強制null check(&lt;code>!!&lt;/code>)などを入れるか…より複雑になるだけですね。&lt;/p>
&lt;p>しかし、named parameterを使うと簡単に解決できる問題です。デフォルト値を指定しない&lt;code>val&lt;/code>だったら、それが必須項目であるということもわかりやすいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> myFavorite = Pizza(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#e6db74">&amp;#34;L&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cheese = &lt;span style="color:#ae81ff">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> olives = &lt;span style="color:#ae81ff">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bacon = &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="consider-factory-functions-instead-of-constructors">Consider factory functions instead of constructors
&lt;/h3>&lt;p>Javaでも最近は色々とfactory functionを導入していて、簡単にimmutableなオブジェクトを作りやすくなりました。Kotlinでもコンストラクタの作成や、named parameterによるインスタンスの生成が色々と便利ではあるものの、それでもfactory functionが良いケースがあるというパートです。理由は以下の通りです。&lt;/p>
&lt;ul>
&lt;li>関数には名前があるので、どうやってオブジェクトが生成されるかわかる
&lt;ul>
&lt;li>&lt;code>ArrayList(3)&lt;/code>よりは&lt;code>ArrayList.withSize(3)&lt;/code>がわかりやすい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>戻り値としてサブタイプのオブジェクトを指定できる
&lt;ul>
&lt;li>具体的な実装を時と場合によって違う形にすることができる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>呼び出されるたび新しいオブジェクトを作るわけではない
&lt;ul>
&lt;li>&lt;code>Connections.createOrNull()&lt;/code>のようにnullを返すこともできる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>まだ存在しないオブジェクトを提供できる
&lt;ul>
&lt;li>プロキシなしで動くようなオブジェクトを作るなどで応用できる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>オブジェクトの外に作ることで可視性を制御できる&lt;/li>
&lt;li>&lt;code>inline&lt;/code>にできるので、&lt;a class="link" href="https://kotlinlang.org/docs/inline-functions.html#reified-type-parameters" target="_blank" rel="noopener"
>reified&lt;/a>にもできる&lt;/li>
&lt;li>インスタンスを作るのが複雑なオブジェクトの手間を省く&lt;/li>
&lt;li>スーパークラスやプライマリコンストラクタを呼び出さずにインスタンスを生成できる&lt;/li>
&lt;/ul>
&lt;p>こちらも読みながらなるほどと納得しました。特に私の場合でも、Service層のDTOとController層のResponseなどのオブジェクト間のマッピングではfactory functionを導入してコードを再使用性を高められたと思っていたので、良い判断だったなと今は思っています。&lt;/p>
&lt;p>他に、factory functionを作る方法としても以下のようなものが提示されてありました。一般的にはcompanion object内に定義しておくことが多いかと思いますが、他の方法も必要であれば考慮したいものですね。&lt;/p>
&lt;h4 id="companion-object">companion object
&lt;/h4>&lt;p>Javaのstaticメソッドのようなパターン。最もわかりやすいですね。以下のような形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyLinkedList&lt;/span>&amp;lt;T&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> head: T,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> tail: MyLinkedList&amp;lt;T&amp;gt;?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#66d9ef">vararg&lt;/span> elements: T): MyLinkedList&amp;lt;T&amp;gt;? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Usage
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> list = &lt;span style="color:#a6e22e">MyLinkedList&lt;/span>.of(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>factory functionは大体以下の規則を持って命名されるという説明もありました。&lt;/p>
&lt;h5 id="from">from
&lt;/h5>&lt;p>一つのパラメータを渡し、タイプを変える時（自分自身のインスタンスを返す）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> date: Date = &lt;span style="color:#a6e22e">Date&lt;/span>.from(instant)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="of">of
&lt;/h5>&lt;p>複数のパタメータを渡し、それを束ねたタイプに変換するとき&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> faceCards: Set&amp;lt;Rank&amp;gt; = &lt;span style="color:#a6e22e">EnumSet&lt;/span>.of(JACK, QUEEN, KING)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="valueof">valueOf
&lt;/h5>&lt;p>&lt;code>of&lt;/code>の冗長な形&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> prime: BigInteger = &lt;span style="color:#a6e22e">BigInteger&lt;/span>.valueOf(&lt;span style="color:#a6e22e">Integer&lt;/span>.MAX_VALUE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="instance--getinstance">instance / getInstance
&lt;/h5>&lt;p>Singletonのインスタンス取得（パラメータが同じだと常に同じインスタンスが帰ってくる）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> luke: StackWalker = &lt;span style="color:#a6e22e">StackWalker&lt;/span>.getInstance(options)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="createinstance--newinstance">createInstance / newInstance
&lt;/h5>&lt;p>instance / getInstanceは似ているが、常に新しいインスタンスを返す&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> newArray = &lt;span style="color:#a6e22e">Array&lt;/span>.newInstance(classObject, arrayLen)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="gettype">getType
&lt;/h5>&lt;p>instance / getInstanceと似ているが、違うタイプのインスタンスを返すとき&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> fs: FileStore = &lt;span style="color:#a6e22e">Files&lt;/span>.getFileStore(path)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="newtype">newType
&lt;/h5>&lt;p>createInstance / newInstanceに似ているが、違うタイプのインスタンスを返す時&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> br: BufferedReader = &lt;span style="color:#a6e22e">Files&lt;/span>.newBufferedReader(path)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="extension">extension
&lt;/h4>&lt;p>クラスにからのcompanion objectを定義しておいて、外部から拡張関数でfactory functionを付ける形です。元のクラスをいじらなくても良くなるし、パッケージと可視性の制御など拡張関数の持つ特徴を活用できますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Tool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> { &lt;span style="color:#75715e">/*...*/&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Tool&lt;/span>.&lt;span style="color:#a6e22e">Companion&lt;/span>.createBigTool( &lt;span style="color:#75715e">/*...*/&lt;/span> ): BigTool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="top-level">top-level
&lt;/h4>&lt;p>スタンダードライブラリに含まれている、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html" target="_blank" rel="noopener"
>listOf()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/set-of.html" target="_blank" rel="noopener"
>setOf()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-of.html" target="_blank" rel="noopener"
>mapOf()&lt;/a>のようなものです。&lt;/p>
&lt;p>よく使うタイプに関しては使い勝手がいいので便利なものの、IDEの自動補完などに現れたら混乱するケースもあるので命名は慎重にする必要がある、とのことでした。&lt;/p>
&lt;h4 id="fake-constructor">fake constructor
&lt;/h4>&lt;p>Pascal Caseを使って、関数をコンストラクタに見せかけるものです。Kotlinのスタンダードライブラリとしては、以下のようなものがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#ae81ff">4&lt;/span>) { &lt;span style="color:#e6db74">&amp;#34;User&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> } &lt;span style="color:#75715e">// [User0, User1, User2, User3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは実際は以下のような関数ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">init&lt;/span>: (index: Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): List&amp;lt;T&amp;gt; = MutableList(size, &lt;span style="color:#66d9ef">init&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">MutableList&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">init&lt;/span>: (index: Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> list = ArrayList&amp;lt;T&amp;gt;(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(size) { index &lt;span style="color:#f92672">-&amp;gt;&lt;/span> list.add(&lt;span style="color:#66d9ef">init&lt;/span>(index)) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはinterfaceに対してコンストラクタを作る必要があったり、&lt;code>reified&lt;/code>タイプの引数が必要な時に考慮できるものらしいです。&lt;/p>
&lt;p>他にもfake constructorを作る方法があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Tree&lt;/span>&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">invoke&lt;/span>(size: Int, generator: (Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): Tree&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Usage
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>Tree(&lt;span style="color:#ae81ff">10&lt;/span>) { &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この場合constructor referenceではコードが複雑になる問題があるらしいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> f: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#f92672">::&lt;/span>Tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Fake Constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> d: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#f92672">::&lt;/span>Tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Invoke in companion object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> g: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#a6e22e">Tree&lt;/span>.Companion&lt;span style="color:#f92672">::&lt;/span>invoke
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なのでfake constructorを使うとしたら、関数として定義したほうがよさそうです。&lt;/p>
&lt;h4 id="factory-class">factory class
&lt;/h4>&lt;p>別途Factoryというクラスを置いてインスタンスを返すようにする方法ですね。Javaではinterfaceでそのようなことをするケースがありますが（&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/List.html#of%28E%29" target="_blank" rel="noopener"
>List.of()&lt;/a>みたいな）、Kotlinでも良いのか？という疑問が湧きました。結論から言いますと、「factoryクラスは状態を持つことが可能」なため、場合によっては考慮しても良いとのことです。これは思ったより活用できそうな可能性がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> surname: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StudentsFactory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> nextId = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>(name: String, surname: String) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student(nextId&lt;span style="color:#f92672">++&lt;/span>, name, surname)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> factory = StudentsFactory()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> s1 = factory.next(&lt;span style="color:#e6db74">&amp;#34;Marcin&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Moskala&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(s1) &lt;span style="color:#75715e">// Student(id=0, name=Marcin, Surname=Moskala)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> s2 = factory.next(&lt;span style="color:#e6db74">&amp;#34;Igor&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Wojda&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(s2) &lt;span style="color:#75715e">// Student(id=1, name=Igor, Surname=Wojda)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>ざっくりなまとめとなりますが、以上が私のこの本で得られた知識への感想となります。新しい発見もあり、自分の習慣が間違ってなかったということを人の説明で補ってもらったような気にもなり、かなり興味深かったです。&lt;/p>
&lt;p>ただやはり、Kotlinがまだ新しい言語であり、いろいろなパラダイムを吸収しているためか、&lt;code>Effective Java&lt;/code>のようなレベルの高い作法に対する議論は少し足りてないような気がしていて、そこは多少残念に思います。まあ、こう思うようになったということ自体が、少しは自分が成長した証拠でもあるかなという生意気な想像もしてみるのですが。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinでデータの逆転グルーピング</title><link>https://retheviper.github.io/posts/kotlin-reverse-groupping/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-reverse-groupping/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinでデータの逆転グルーピング" />&lt;p>DBを設計する時と、最終的にアプリで活用するデータの形は大きく変わるケースがあります。特に後から機能を付け加えるとそうなりますね。もちろん正規化などを通じてより効率的にデータを保存する方法を考える必要のあるDBと、データをいかに加工して使うかを工夫するアプリの違いによるものもありますが、アプリの改修が続くと同じデータでも活用する箇所や表現の仕方が変わってくるからでもあるかなと思います。&lt;/p>
&lt;p>そういうわけで、今回はそのようなケースで一つ活用できる方法をご紹介したいと思います。アルゴリズムというわけでもありませんし、より効率的な方法はあるかなと思いますが、応用すれば結構色々な場所で使えそうな方法ではないかと思います。&lt;/p>
&lt;h2 id="シナリオ">シナリオ
&lt;/h2>&lt;p>例えば以下のようなシナリオがあるとします。&lt;/p>
&lt;ol>
&lt;li>社員はA、Bという二つの部署に配属される&lt;/li>
&lt;li>社員が部署に配属される日付はそれぞれ&lt;/li>
&lt;/ol>
&lt;p>この場合、データの作りには色々な観点があるかと思いますが、まず部署の配属日を基準にデータを作るとしたら、部署の種類、配属日とその日付に配属となった社員のリストを持つような形になるかと思います。Kotlinのコードとして表現するとしたら以下のような形ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DepartmentType&lt;/span> { A, B }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Department&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> departmentType: DepartmentType,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> date: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> employers: List&amp;lt;Employer&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Employer&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> id: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで社員の3人がいて、それぞれ部署Aと部署Bに配属された日付が違うケースがあるとしましょう。データとしては、以下のようなものです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>社員番号&lt;/th>
&lt;th>部署A配属&lt;/th>
&lt;th>部署B配属&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上記のデータを持って、先ほどの部署のデータを実際のリストとして作るとしたら以下のようになるかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> departments = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#a6e22e">DepartmentType&lt;/span>.A,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#a6e22e">DepartmentType&lt;/span>.A,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#a6e22e">DepartmentType&lt;/span>.B,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = &lt;span style="color:#a6e22e">DepartmentType&lt;/span>.B,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2022&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Department&lt;/span>.Employer(id = &lt;span style="color:#ae81ff">3&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、これを社員を基準に、それぞれの部署に配属された日付をデータとして加工するにはどうしたら良いでしょうか。社員番号と部署に配属となった日付の二つを持つような形です。例えば、コードで表現すると以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">JoinedDates&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> employerId: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> departmentA: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> departmentB: LocalDate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、やりたいことは先ほどの&lt;code>departments&lt;/code>を、最終的に以下のようなデータにしたいということですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">[
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> JoinedDates(employerId=EmployerId(value=1), departmentA=2022-01-01, departmentB=2022-01-01),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> JoinedDates(employerId=EmployerId(value=2), departmentA=2022-01-01, departmentB=2022-02-01),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e"> JoinedDates(employerId=EmployerId(value=3), departmentA=2022-02-01, departmentB=2022-02-01)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>データの整列の基準がひっくり返されるので、どうしたら良いかと悩ましくなる場面です。今回は、これを解決した自分の方法を紹介したいと思います。&lt;/p>
&lt;h2 id="ロジック">ロジック
&lt;/h2>&lt;p>Departmentを基準に考えるとEmployerのデータが複数になりますが、これを逆転させて、Employerを基準に複数のDepartmentを持つという形に加工したいというのが今回の要件です。だとすると、考えられるロジックは以下がポイントかなと思います。&lt;/p>
&lt;ol>
&lt;li>EmployerのID単位でまとめる&lt;/li>
&lt;li>EmployerごとにDepartmentをType別に分けた配列を持たせる&lt;/li>
&lt;/ol>
&lt;p>まずはネスとしているEmployerのリストに入り、そのIDを抽出する必要がありますね。このIDは重複させたくないので、MapのKeyにしておくと良さげです。&lt;/p>
&lt;p>あとは、そのMapにEmployerのIDがKeyとして存在するかどうかで以下の処理をすると良いでしょう。&lt;/p>
&lt;ol>
&lt;li>Keyが存在しない場合は、新しくDepartmentのタイプとその日付をinsert&lt;/li>
&lt;li>Keyが存在する場合は、そのvalueを取り出してDepartmentのタイプと日付を追加&lt;/li>
&lt;/ol>
&lt;p>なので、一回DepartmentのListをMapに変換して、さらにJoinedDatesのListに変換することとなります。ちょうど上記の分岐については、&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#compute-K-java.util.function.BiFunction-" target="_blank" rel="noopener"
>compute()&lt;/a>を活用するとできるので、中間データとしてのMapがどんな形になるかを考えると良いかなと思います。&lt;/p>
&lt;p>私の場合はMapの方がデータを取りやすいので、最終的には以下のような処理となりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;Department&amp;gt;.toJoinedDates(): List&amp;lt;JoinedDates&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 中間データ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> tempMap = mutableMapOf&amp;lt;Int, Map&amp;lt;DepartmentType, LocalDate&amp;gt;&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.forEach { department &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Departmentのタイプとその日付のPair
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> departmentJoined = department.departmentType to department.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> department.employers.forEach { employer &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// EmployerのIDがKeyとして存在したら足して、なかったらMapを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> tempMap.compute(employer.id) { _, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span>&lt;span style="color:#f92672">?.&lt;/span>let { &lt;span style="color:#66d9ef">value&lt;/span> + departmentJoined } &lt;span style="color:#f92672">?:&lt;/span> mapOf(departmentJoined)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 中間データをJoinedDatesのListに変えて返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> tempMap.map { (id, department) &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JoinedDates(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employerId = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentA = department.getValue(&lt;span style="color:#a6e22e">DepartmentType&lt;/span>.A),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentB = department.getValue(&lt;span style="color:#a6e22e">DepartmentType&lt;/span>.B)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="共通ロジック化">共通ロジック化
&lt;/h2>&lt;p>ジェネリックを使ったclassとして上記のロジックを一部分離すれば、似たようなケースで色々使い回せるのではないかと思いましたので、以下のようなコードも書いてみました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Aggregator&lt;/span>&amp;lt;T, K, V, R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> tempMap = mutableMapOf&amp;lt;T, Map&amp;lt;K, V&amp;gt;&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// データの追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(key: T, &lt;span style="color:#66d9ef">value&lt;/span>: Pair&amp;lt;K, V&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tempMap.compute(key) { _, existingValue &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> existingValue&lt;span style="color:#f92672">?.&lt;/span>let { existingValue + &lt;span style="color:#66d9ef">value&lt;/span> } &lt;span style="color:#f92672">?:&lt;/span> mapOf(&lt;span style="color:#66d9ef">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定したListとして取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getList&lt;/span>(transfer: (T, Map&amp;lt;K, V&amp;gt;) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): List&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> tempMap.map { transfer(&lt;span style="color:#66d9ef">it&lt;/span>.key, &lt;span style="color:#66d9ef">it&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これの場合は以下のような使い方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> aggregator = Aggregator&amp;lt;Int, DepartmentType, LocalDate, JoinedDates&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// データの追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>departments.forEach { a &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.employers.forEach { b &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aggregator.add(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = b.id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">value&lt;/span> = a.departmentType to a.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Listの結果を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> joinedDates = aggregator.getList { id, joinedDate &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JoinedDates(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employerId = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentA = joinedDate.getValue(&lt;span style="color:#a6e22e">DepartmentType&lt;/span>.A),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentB = joinedDate.getValue(&lt;span style="color:#a6e22e">DepartmentType&lt;/span>.B)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>汎用性はあるものの、呼び出し元のコードが増えたり、指定している型の意味や意図がよくわからないので適切なKDocやコメントがないと少しわかりにくいところがデメリットかもしれませんね。ただ大事なのは中間データの型と&lt;code>compute()&lt;/code>による分岐処理なので、そこだけをうまく取り出して他でも応用できるかなと思います。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>サーバサイドKoltinだと、多くの場合にデータを&lt;code>List&lt;/code>として扱うのが普通かなと思いますが、場合によっては&lt;code>Map&lt;/code>を使うのもロジックを書いていく中では良い選択になるかと思います。特に、今回紹介した&lt;code>compute()&lt;/code>以外でも、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-or-put.html" target="_blank" rel="noopener"
>getOrPut()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/get-or-default.html" target="_blank" rel="noopener"
>getOrDefault()&lt;/a>などの機能が便利なので色々と活用できる場面が多いかなと思います。この処理は&lt;a class="link" href="../exposed-mapping-record-to-object" >前回のポスト&lt;/a>でも似たようなものを紹介したことがありますので、興味のある方はそちらも参考にしてください。&lt;/p>
&lt;p>プログラミング言語が提供するスタンダードライブラリは色々と見逃しやすいところがあるかなと思いますが、よくドキュメントや自動補完で一覧に登場する関数に注目すると、こういう風に必要なものがいきなり現れることもあるかと思います。まだ私もKotlinを触って1年ほどしか経ってないひよこなものなので、これからもどんどん新しい発見があると嬉しいなと思いますね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで和暦を使う</title><link>https://retheviper.github.io/posts/kotlin-japanese-era/</link><pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-japanese-era/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで和暦を使う" />&lt;p>帳票などで、たまに和暦を処理する必要な時がありますね。例えば元号を表記するとか、和暦の年度を表記するなどの場合があるかと思います。Kotlin(JVM)の場合、西暦だとJavaのAPIの&lt;code>Date&lt;/code>や&lt;code>LocalDate&lt;/code>などのAPIを使うと簡単ですが、和暦が必要となるのはごく一部のケースなので方法がなかなか分かりづらいかと思います。なので、今回はKotlinで和暦を扱う方法について少しまとめてみました。&lt;/p>
&lt;h2 id="japanseera--japanesedate">JapanseEra / JapaneseDate
&lt;/h2>&lt;p>Javaでは、1.8から和暦で日付を扱える&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseDate.html" target="_blank" rel="noopener"
>JapaneseDate&lt;/a>及び元号を扱える&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseEra.html" target="_blank" rel="noopener"
>JapaneseEra&lt;/a>というAPIを提供しています。なので&lt;code>JapaneseDate&lt;/code>のインスタンスを作り、そこから&lt;code>JapaneseEra&lt;/code>を取得することで簡単に元号の情報を取得できるようになります。実際の使い方は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 現在日付のJapaneseDateを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> japaneseDate = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// JapaneseEraの取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> japaneseEra = japaneseDate.era
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>JapaneseDate&lt;/code>の場合、&lt;code>LocalDate&lt;/code>と同じく&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/chrono/ChronoLocalDate.html" target="_blank" rel="noopener"
>ChronoLocalDate&lt;/a>を継承しているのでインスタンスを作成する方法はそう変わりません。なので、以下のようなこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// LocalDateをJapaneseDateに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> japaneseDateFromLocalDate = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.from(&lt;span style="color:#a6e22e">LocalDate&lt;/span>.now())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 特定の日付を指定してJapaneseDate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> japaneseDateFromSpecificDate = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.of(&lt;span style="color:#ae81ff">2000&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">31&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="元号を日本語で表記する">元号を日本語で表記する
&lt;/h2>&lt;p>和暦を扱う場合にやりたいことは大きく二つかと思います。一つは、元号を文字列として扱うこと、そしてもう一つは、和暦での年度を数字として扱うことです。まずは、元号を文字列として取得できる方法について説明します。&lt;/p>
&lt;p>まず上記で紹介した通り、&lt;code>JapaneseDate&lt;/code>のインスタンスを取得した上で、さらにそのオブジェクトが保持している&lt;code>JapaneseEra&lt;/code>を取得する必要があります。その後、&lt;code>JapaneseEra.getDisplayName()&lt;/code>という関数に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/TextStyle.html" target="_blank" rel="noopener"
>TextStyle&lt;/a>と&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/Locale.html" target="_blank" rel="noopener"
>Locale&lt;/a>を指定して文字列を取得することができます。前者は文字の出力型を指定する列挙型定数で、後者は言語の指定と思ってください。&lt;/p>
&lt;p>&lt;code>TextStyle&lt;/code>の場合、以下のような値があります。他の言語だと指定したものによって出力がかなり変わってくるかもしれませんが、日本語の場合は&lt;code>FULL&lt;/code>と&lt;code>NARROW&lt;/code>だけで十分ではないかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>定数&lt;/th>
&lt;th>出力例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>FULL&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>FULL_STANDALONE&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>NARROW&lt;/code>&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>NARROW_STANDALONE&lt;/code>&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SHORT&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SHORT_STANDALONE&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>Locale&lt;/code>の場合、&lt;code>Locale.JAPAN&lt;/code>や&lt;code>Locale.JAPANESE&lt;/code>のどちらを指定しても結果は同じです。ただ、実装としては以下のようになるのでなるべく&lt;code>Locale.JAPAN&lt;/code>を使った方が良さそうです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Locale&lt;/th>
&lt;th>作られるBaseLocaleの設定&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>JAPAN&lt;/code>&lt;/td>
&lt;td>&lt;code>language = ja, region = JP&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>JAPANESE&lt;/code>&lt;/td>
&lt;td>&lt;code>language = ja&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以下はこれらの定数を渡して元号を文字列として取得する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> today = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> era = today.era
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元号を漢字で取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> eraName = era.getDisplayName(&lt;span style="color:#a6e22e">TextStyle&lt;/span>.FULL, &lt;span style="color:#a6e22e">Locale&lt;/span>.JAPAN) &lt;span style="color:#75715e">// 令和
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元号だけでなく、年度までも合わせて表記したい場合もあるかと思います。その場合に使えるものは&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>です。これも&lt;code>JapaneseDate&lt;/code>が実質&lt;code>LocalDate&lt;/code>と同じく&lt;code>ChronoLocalDate&lt;/code>を継承しているから可能なことですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 日付を日本語で表記する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> formatter = &lt;span style="color:#a6e22e">DateTimeFormatter&lt;/span>.ofPattern(&lt;span style="color:#e6db74">&amp;#34;Gy年&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Locale&lt;/span>.JAPAN)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> todayString = formatter.format(&lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now()) &lt;span style="color:#75715e">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしJava 1.8以前のバージョンを使うなどで&lt;code>LocalDate&lt;/code>や&lt;code>JapaneseDate&lt;/code>が使えなく、&lt;code>java.util.Date&lt;/code>の方を使うしかない場合は、以下のような方法で年号と年度の取得が可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> format = SimpleDateFormat(&lt;span style="color:#e6db74">&amp;#34;Gy年&amp;#34;&lt;/span>, Locale(&lt;span style="color:#e6db74">&amp;#34;Ja&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;JP&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;JP&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> year = format.format(Date()) &lt;span style="color:#75715e">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>java.util.Date&lt;/code>を使う場合は、&lt;code>Locale&lt;/code>に第3引数の&lt;code>variant&lt;/code>まで指定する必要があるので、既存の列挙型として定義されたものは使えません。&lt;/p>
&lt;p>また、&lt;code>Locale.ENGLISH&lt;/code>などに設定すると、&lt;code>JapaenseDate&lt;/code>を使っている場合でも取得した結果は&lt;code>AD2021年12月5日&lt;/code>になります。&lt;/p>
&lt;h3 id="合字で表記する">合字で表記する
&lt;/h3>&lt;p>年号については、Unicodeで合字を取得して使いたい場合もあるかと思います。その場合は、以下のようにUnicodeのMapなどを定義しておいて取得するのが良いかと思います。拡張関数などを定義するのも良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> eraUnicodeMap = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.MEIJI to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u337e&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// ㍾
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.TAISHO to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u337d&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// ㍽
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.SHOWA to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u337c&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// ㍼
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.HEISEI to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u337b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#75715e">// ㍻
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">JapaneseEra&lt;/span>.REIWA to &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\u32ff&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#75715e">// ㋿
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> era = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now().era
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 元号を合字で取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> eraUnicode = eraUnicodeMap[era] &lt;span style="color:#75715e">// ㋿
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のサンプルでは&lt;code>JapaneseEra&lt;/code>が列挙型なのでそのままキーとしていますが、&lt;code>JapaneseEra&lt;/code>は数値としての情報も持っているのでそちらを使う方法もあるでしょう。それぞれの値に対する数値は以下の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>JapaneseEra&lt;/th>
&lt;th>数値&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MEIJI&lt;/td>
&lt;td>-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TAISHO&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SHOWA&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HEISEI&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>REIWA&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>2021年から2022年の3月の場合は令和3年なので、&lt;code>JapaneseEra.REIWA.value&lt;/code>の値が年度だと勘違いされやすいかなと思います。実際の年度の情報は&lt;code>JapaneseDate&lt;/code>の方にあるので注意しましょう。&lt;/p>
&lt;h2 id="年度を数字で表示する">年度を数字で表示する
&lt;/h2>&lt;p>&lt;code>JapaneseEra&lt;/code>は元号を得るために使う列挙型定数のクラスなので、これ自体は&lt;code>JapaneseDate&lt;/code>の日付情報を持っていません。なので参照できる情報は、あくまでも元となる&lt;code>JapaneseDate&lt;/code>が属した元号の情報のみです。&lt;/p>
&lt;p>なので数値としての年度は、列挙型の&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/temporal/ChronoField.html" target="_blank" rel="noopener"
>ChronoField&lt;/a>を&lt;code>JapaneseDate.get()&lt;/code>に渡して取得する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> today = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.of(&lt;span style="color:#ae81ff">2010&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">31&lt;/span>) &lt;span style="color:#75715e">// 平成22年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 年度をIntとして取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> year = today.&lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#a6e22e">ChronoField&lt;/span>.YEAR) &lt;span style="color:#75715e">// 2010
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> yearOfHeisei = today.&lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#a6e22e">ChronoField&lt;/span>.YEAR_OF_ERA) &lt;span style="color:#75715e">// 22
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは&lt;code>JapaneseDate&lt;/code>が&lt;code>LocalDate&lt;/code>と違って、直接&lt;code>year&lt;/code>をgetterで取得できないからです。実際オブジェクトの中を覗いてみると、&lt;code>LocalDate&lt;/code>は年月日をintとshortのフィールドとして保持していることに対して、&lt;code>JapaneseDate&lt;/code>は&lt;code>LocalDate&lt;/code>とint型の&lt;code>yearOfEra&lt;/code>を持っていて、&lt;code>get(ChronoField.YEAR_OF_ERA)&lt;/code>を通じてはじめて&lt;code>yearOfEra&lt;/code>を取得できることになります。getterを用意していないのはおそらく&lt;code>LocalDate&lt;/code>と&lt;code>yearOfEra&lt;/code>という二つの概念があるからなのではないかと思います。もちろん、Kotlinなのでこれは簡単に拡張関数を書くことでgetterを作ることはできますね。&lt;/p>
&lt;p>また、日付のオブジェクトとして&lt;code>LocalDate&lt;/code>を使っている場合は場合は&lt;code>ChronoField.YEAR_OF_ERA&lt;/code>を渡しても西暦の年度が返ってくるので、和暦を使うために&lt;code>JapaneseDate&lt;/code>を使っているかどうかをまず確認しましょう。&lt;/p>
&lt;h3 id="年度を2桁の文字で表示する">年度を2桁の文字で表示する
&lt;/h3>&lt;p>厳密に言って和暦とは関係のないことですが、年度を取得して使う場合、一貫して先端に「0」のついた2桁の文字列として扱いたい場合もあるかと思います。&lt;code>JapaneseDate&lt;/code>を通じて年度を取得した場合は&lt;code>Int&lt;/code>型になるので、1〜9の間は1桁の数字となるわけですが、これを01〜09に表示したい場合は以下の方法が使えます。&lt;/p>
&lt;h4 id="decimalformatを利用する">DecimalFormatを利用する
&lt;/h4>&lt;p>一つは、JavaのAPIである&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/text/DecimalFormat.html" target="_blank" rel="noopener"
>DecimalFormat&lt;/a>を使うことです。小数点の範囲などをわかりやすく指定できるので個人的には好むやり方です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> today = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now() &lt;span style="color:#75715e">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 数字を表示するためのフォーマットを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> decimalFormat = DecimalFormat(&lt;span style="color:#e6db74">&amp;#34;00&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> year = decimalFormat.format(today) &lt;span style="color:#75715e">// 03
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="stringformatを利用する">String.formatを利用する
&lt;/h4>&lt;p>もう一つの方法は、Kotlinのスタンダードライブラリの機能である&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/format.html" target="_blank" rel="noopener"
>String.format()&lt;/a>を使うことです。性能注視なら、こちらの方法が良いかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> today = &lt;span style="color:#a6e22e">JapaneseDate&lt;/span>.now() &lt;span style="color:#75715e">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 数字を表示するためのフォーマットを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> year = &lt;span style="color:#e6db74">&amp;#34;%02d&amp;#34;&lt;/span>.format(today) &lt;span style="color:#75715e">// 03
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="番外kotlinx-datetime">番外：kotlinx-datetime
&lt;/h2>&lt;p>Kotlinには元々日付や時間を扱うAPIがなかったのですが、2020年から&lt;a class="link" href="https://github.com/Kotlin/kotlinx-datetime" target="_blank" rel="noopener"
>kotlinx-datetime&lt;/a>を提供しています。なのでKotlin/JSやKotlin/Nativeなど、JVM上で動かない場合でも日付を扱える公式のAPIができたわけですが、いくつかの懸念があるのでこれを導入するには検討が必要かと思います。&lt;/p>
&lt;h3 id="pre-releaseの段階">Pre-releaseの段階
&lt;/h3>&lt;p>&lt;code>kotlinx-datetime&lt;/code>はまだpre-releaseの段階で、2021年10月に&lt;code>v0.3.1&lt;/code>がリリースされています。なので色々とバグがあったり、思い通りにならない可能性があります。また、開発途中のものなので仕方ありませんが、現時点で提供している機能も&lt;code>java.time&lt;/code>のAPIに比べて少なく、簡単に年号の計算などができるわけではありません。今は必要最低限の機能だけを提供していると思って良いでしょう。&lt;/p>
&lt;h3 id="マルチプラットフォーム向け">マルチプラットフォーム向け
&lt;/h3>&lt;p>Kotlinのスタンダードライブラリ、及び&lt;code>kotlinx&lt;/code>として提供されるライブラリはマルチプラットホームを考慮した実装となっているため、プラットホームが違っても同じ使い方ができるというメリットがありますが、かえってデメリットになる場合もあります。実際、&lt;code>kotlinx-datetime&lt;/code>のJVMの実装は内部的に&lt;code>jata.time&lt;/code>のAPIに依存しているため、JVMだけを使う場合はあえて導入する必要がないともいえます。&lt;/p>
&lt;p>また、プラットフォームごとに実装が違うということはどこかで予期せぬ例外が発生したり、期待した結果にならないケースも発生しえる、ということにもなるかと思います。&lt;/p>
&lt;h2 id="javatimeの懸念">java.timeの懸念
&lt;/h2>&lt;p>&lt;code>JapaneseEra&lt;/code>では明治以前（慶応など）の元号は使えませんが、おそらくその理由は和暦でグレゴリウス暦が使われたのは明治からだったという歴史的な背景があるのではないかと思います。また、&lt;code>JapaneseDate&lt;/code>でも明治6年(西暦1873年1月1日)以前の日付を指定すると以下のように例外が発生します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Exception in thread &lt;span style="color:#e6db74">&amp;#34;main&amp;#34;&lt;/span> java.time.DateTimeException: JapaneseDate before Meiji &lt;span style="color:#ae81ff">6&lt;/span> is not supported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at java.base/java.time.chrono.JapaneseDate.&amp;lt;init&amp;gt;&lt;span style="color:#f92672">(&lt;/span>JapaneseDate.java:333&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at java.base/java.time.chrono.JapaneseDate.of&lt;span style="color:#f92672">(&lt;/span>JapaneseDate.java:257&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、単純に帳票を作るなどのケースでなく、歴史的な研究のための日付計算ではここで紹介した方法は使えないケースもあるかと思います。&lt;/p>
&lt;p>また、JDKのバージョンなどの問題があるためか、&lt;code>JapaneseEra.REIWA&lt;/code>の取得ができなく、エラーとなるケースがあるので注意する必要があります。この場合でも&lt;code>value&lt;/code>の値の取得は問題ないので、少し可読性は低下しながら分岐などの判定に定数をそのまま使うのは避けたほうが良さそうです。（正確な理由はわかりませんが…）&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたか。少し興味本位で調べ始めたもののまとめではありますが、本業の方で実際に必要な処理でもあり、これをどうやって拡張関数として落とせるかということも考えられる良い機会となったかなと思っています。&lt;/p>
&lt;p>また、JavaのAPIに関しては&lt;a class="link" href="https://qiita.com/yamadamn/items/56e7370bae2ceaec55d5" target="_blank" rel="noopener"
>Javaバージョン別の改元(新元号)対応まとめ&lt;/a>という良い記事があったので、興味のある方はご一読ください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその３</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-3/</link><pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-3/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinの隠されたコストーその３" />&lt;p>Kotlinの隠されたコスト、その最後の記事となります。今までの記事もかなり興味深かったですが、今回はさらにKotlinならではの機能に触れているので、Kotlinそのものに対する理解も含めてみる必要があり、さらに深い内容となっているかと思います。&lt;/p>
&lt;p>今回のアジェンダは、「委譲プロパティ」と「rangeを使ったループ」になります。この記事は&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-3-3bf6e0dbf0a4" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 3&lt;/a>の内容を要約したものです。&lt;/p>
&lt;h2 id="委譲プロパティ">委譲プロパティ
&lt;/h2>&lt;p>&lt;a class="link" href="https://kotlinlang.org/docs/delegated-properties.html" target="_blank" rel="noopener"
>委譲プロパティ&lt;/a>とは、&lt;code>getter&lt;/code>と&lt;code>setter&lt;/code>が&lt;code>委譲(delegate)&lt;/code>というオブジェクトによって実装された&lt;a class="link" href="https://kotlinlang.org/docs/properties.html" target="_blank" rel="noopener"
>プロパティ&lt;/a>を指します。これによって再利用可能なカスタムプロパティを作ることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> p: String &lt;span style="color:#66d9ef">by&lt;/span> Delegate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>委譲オブジェクトはプロパティの設定と読み込みのため&lt;code>getValue()&lt;/code>と&lt;code>setValue()&lt;/code>を実装する必要があります。そしてこれらの関数はプロパティのメタデータ（プロパティ名）とオブジェクトのインスタンスを引数として必要とします。&lt;/p>
&lt;p>クラスが委譲プロパティとして定義されると、コンパイラは下記のようなコードを生成します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@NotNull&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Delegate p$delegate &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Delegate();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: 生成されたフィールド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> KProperty&lt;span style="color:#f92672">[]&lt;/span> $$delegatedProperties &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> KProperty&lt;span style="color:#f92672">[]&lt;/span>{(KProperty)Reflection.&lt;span style="color:#a6e22e">mutableProperty1&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> MutablePropertyReference1Impl(Reflection.&lt;span style="color:#a6e22e">getOrCreateKotlinClass&lt;/span>(Example.&lt;span style="color:#a6e22e">class&lt;/span>), &lt;span style="color:#e6db74">&amp;#34;p&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;getP()Ljava/lang/String;&amp;#34;&lt;/span>))};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@NotNull&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String &lt;span style="color:#a6e22e">getP&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">p$delegate&lt;/span>.&lt;span style="color:#a6e22e">getValue&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, $$delegatedProperties&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setP&lt;/span>(&lt;span style="color:#a6e22e">@NotNull&lt;/span> String var1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics.&lt;span style="color:#a6e22e">checkParameterIsNotNull&lt;/span>(var1, &lt;span style="color:#e6db74">&amp;#34;&amp;lt;set-?&amp;gt;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">p$delegate&lt;/span>.&lt;span style="color:#a6e22e">setValue&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, $$delegatedProperties&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>, var1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一部staticプロパティのメタデータがクラスに追加されます。そして毎回値の設定と読み込みが発生するたびにコンストラクタによる初期化が起こります。&lt;/p>
&lt;h3 id="委譲インスタンス">委譲インスタンス
&lt;/h3>&lt;p>上記サンプルでは新しい委譲のインスタンスがプロパティの実装のため生成されています。委譲がstatefulの場合にこのようになります。たとえはローカルで計算されたプロパティを使うなどの場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StringDelegate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> cache: String? = &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getValue&lt;/span>(thisRef: Any?, &lt;span style="color:#66d9ef">property&lt;/span>: KProperty&amp;lt;*&amp;gt;): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> result = cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = someOperation()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>またコンストラクタに追加のパラメータが渡されると、新しい委譲のインスタンスが必要となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> nameView &lt;span style="color:#66d9ef">by&lt;/span> BindViewDelegate&amp;lt;TextView&amp;gt;(&lt;span style="color:#a6e22e">R&lt;/span>.id.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>statelessであり、すでに渡されたオブジェクトのインスタンスとプロパティ名を保ちたいだけなら委譲クラスに&lt;code>object&lt;/code>をつけてsingletonにする方法があります。たとえば下記のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">FragmentDelegate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getValue&lt;/span>(thisRef: Activity, &lt;span style="color:#66d9ef">property&lt;/span>: KProperty&amp;lt;*&amp;gt;): Fragment? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> thisRef.fragmentManager.findFragmentByTag(&lt;span style="color:#66d9ef">property&lt;/span>.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また既存のオブジェクトを拡張して委譲することもできます。つまり、&lt;code>getValue()&lt;/code>や&lt;code>setValue()&lt;/code>を拡張関数として定義することもできるということです。Kotlinではすでに&lt;code>Map&lt;/code>と&lt;code>MutableMap&lt;/code>に拡張関数として委譲するパターンを使っています。（プロパティ名をキーで使っています）&lt;/p>
&lt;p>もし一つのクラス内でローカルの委譲インスタンスに複数のプロパティを保持して再利用したいなら、そのクラスのコンストラクタでインスタンスを初期化しましょう。&lt;/p>
&lt;p>Kotlin 1.1以降、&lt;a class="link" href="https://kotlinlang.org/docs/delegated-properties.html#local-delegated-properties" target="_blank" rel="noopener"
>関数内のローカル変数を委譲プロパティにする&lt;/a>こともできます。この場合、委譲は後で初期化できます。&lt;/p>
&lt;p>クラスに定義された委譲プロパティごとにオーバーヘッドとメタデータの追加が発生するのでなるべくプロパティを再利用できるようにした方が良いでしょう。また、定義したい項目が多い場合に、果たして委譲プロパティが良い選択肢であるかを考慮すべきです。&lt;/p>
&lt;h3 id="ジェネリック委譲">ジェネリック委譲
&lt;/h3>&lt;p>委譲関数はジェネリックでも定義できます。なので委譲クラスをさまざまな型のプロパティとして定義することもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> maxDelay: Long &lt;span style="color:#66d9ef">by&lt;/span> SharedPreferencesDelegate&amp;lt;Long&amp;gt;()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記のようにprimitiveをジェネリック委譲を使う場合、&lt;code>boxing&lt;/code>と&lt;code>unboxing&lt;/code>が値の指定と読み込みで発生することに注意する必要があります。これはプロパティがnon-nullの場合でも起こることです。&lt;/p>
&lt;p>なのでnon-nullなprimitive型の委譲プロパティを定義する場合はジェネリックで定義を避けたほうが良いです。&lt;/p>
&lt;h3 id="スタンダード委譲lazy">スタンダード委譲（lazy()）
&lt;/h3>&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" target="_blank" rel="noopener"
>Delegates.notNull()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html" target="_blank" rel="noopener"
>Delegates.observable()&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html" target="_blank" rel="noopener"
>lazy()&lt;/a>のような委譲のための標準機能が存在しています。&lt;/p>
&lt;p>&lt;code>lazy()&lt;/code>は読み込み専用の委譲プロパティのための関数です。初めて読み込みが発生する際、プロパティを初期化するた目にlambdaを指定できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> dateFormat: DateFormat &lt;span style="color:#66d9ef">by&lt;/span> lazy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SimpleDateFormat(&lt;span style="color:#e6db74">&amp;#34;dd-MM-yyyy&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Locale&lt;/span>.getDefault())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはその値が実際に読み込まれるまで高いコストの初期化を遅延させるという、パフォーマンスと可読性の側面で優れた方法です。&lt;/p>
&lt;p>ただ、&lt;code>lazy()&lt;/code>はinline関数ではなく、引数として渡されたlambdaは別の&lt;code>Function&lt;/code>クラスとしてコンパイルされ、戻り値の委譲オブジェクトもまたinline化されないことには注意する必要があります。&lt;/p>
&lt;p>そして&lt;code>lazy()&lt;/code>関数で見逃しやすいのは&lt;code>mode&lt;/code>という引数で戻り値の委譲タイプを決められるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">lazy&lt;/span>(initializer: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): Lazy&amp;lt;T&amp;gt; = SynchronizedLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">lazy&lt;/span>(mode: LazyThreadSafetyMode, initializer: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): Lazy&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (mode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LazyThreadSafetyMode&lt;/span>.SYNCHRONIZED &lt;span style="color:#f92672">-&amp;gt;&lt;/span> SynchronizedLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LazyThreadSafetyMode&lt;/span>.PUBLICATION &lt;span style="color:#f92672">-&amp;gt;&lt;/span> SafePublicationLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LazyThreadSafetyMode&lt;/span>.NONE &lt;span style="color:#f92672">-&amp;gt;&lt;/span> UnsafeLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mode&lt;/code>を指定していない場合、デフォルトとしては&lt;code>LazyThreadSafetyMode.SYNCHRONIZED&lt;/code>が使われますが、これは複数のスレッドで初期化ブロックが安全に実行されることを保証するためにコストの高い&lt;code>double-checked lock&lt;/code>を行います。&lt;/p>
&lt;p>シングルスレッドしかプロパティに対するアクセスがないというのがわかっているなら、無駄なロックは下げた方がいいでしょう。こういう場合は&lt;code>LazyThreadSafetyMode.NONE&lt;/code>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> dateFormat: DateFormat &lt;span style="color:#66d9ef">by&lt;/span> lazy(&lt;span style="color:#a6e22e">LazyThreadSafetyMode&lt;/span>.NONE) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SimpleDateFormat(&lt;span style="color:#e6db74">&amp;#34;dd-MM-yyyy&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Locale&lt;/span>.getDefault())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ranges">Ranges
&lt;/h2>&lt;p>&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html" target="_blank" rel="noopener"
>Ranges&lt;/a>で限定された範囲の値のセットを定義できます。この値は&lt;code>Comparable&lt;/code>なものならなんでも指定できますね。そして、この表現式を使うと&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-closed-range/" target="_blank" rel="noopener"
>ClosedRange&lt;/a>というインタフェースの実装ができることになります。&lt;/p>
&lt;h3 id="包含テスト">包含テスト
&lt;/h3>&lt;p>rangeを使って範囲内に特定の値が含まれているかどうかを&lt;code>in&lt;/code>や&lt;code>!in&lt;/code>を使って検知することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rangeはnon-nullなprimitive型（&lt;code>Int&lt;/code>, &lt;code>Long&lt;/code>, &lt;code>Byte&lt;/code>, &lt;code>Short&lt;/code>, &lt;code>Float&lt;/code>, &lt;code>Double&lt;/code>, &lt;code>Char&lt;/code>）に対する最適化が行われるので、コンパイルされた結果は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(1 &lt;span style="color:#f92672">&amp;lt;=&lt;/span> i &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、オーバーヘッドや追加オブジェクトの割り当てなどは起こらないです。しかし、primitiveではない場合はどうでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (name &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Alfred&amp;#34;&lt;/span>&lt;span style="color:#f92672">..&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Alicia&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlin 1.1.50以前はコンパイル時に&lt;code>ClosedRange&lt;/code>オブジェクトが常に生成されました。しかし、1.1.50からは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(name.compareTo(&lt;span style="color:#e6db74">&amp;#34;Alfred&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(name.compareTo(&lt;span style="color:#e6db74">&amp;#34;Alicia&amp;#34;&lt;/span>) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">System&lt;/span>.&lt;span style="color:#66d9ef">out&lt;/span>.println(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rangeはまた、&lt;code>when&lt;/code>の条件式でも使えます。&lt;code>if-else&lt;/code>より可読性が良くなりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> message = &lt;span style="color:#66d9ef">when&lt;/span> (statusCode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">200.&lt;/span>.&lt;span style="color:#ae81ff">299&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;OK&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">300.&lt;/span>.&lt;span style="color:#ae81ff">399&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Find it somewhere else&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Oops&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、rangeを使う場合、特定の値が含まれているかどうかをチェックするとき、指定された範囲とそれを使うコードの間に間があるとコストがかかることになります。たとえば以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> myRange &lt;span style="color:#66d9ef">get&lt;/span>() = &lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">rangeTest&lt;/span>(i: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> myRange) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はコンパイルすると&lt;code>IntRange&lt;/code>オブジェクトが追加されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> IntRange &lt;span style="color:#a6e22e">getMyRange&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IntRange(1, 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">rangeTest&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getMyRange&lt;/span>().&lt;span style="color:#a6e22e">contains&lt;/span>(i)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはプロパティのgetterを&lt;code>inline&lt;/code>として定義しても同じです。なのでなるべくrangeが使われるテストの方に直接書くことでオブジェクトが追加されない要因した方が良いです。また、primitiveではないオブジェクトを使う場合は定数として定義し、&lt;code>ClosedRange&lt;/code>のインスタンスを再利用する方法があります。&lt;/p>
&lt;h3 id="forループ">forループ
&lt;/h3>&lt;p>&lt;code>Float&lt;/code>と&lt;code>Double&lt;/code>を除いたprimitive型の範囲をループで使うのも良い選択です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルされた結果にはオーバーヘッドが発生しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">byte&lt;/span> var2 &lt;span style="color:#f92672">=&lt;/span> 11; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> var2; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>逆順にループしたい場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/down-to.html" target="_blank" rel="noopener"
>downTo()&lt;/a>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> downTo &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これにもまた、オーバーヘッドは発生しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">byte&lt;/span> var1 &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">==&lt;/span> var1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">--&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/until.html" target="_blank" rel="noopener"
>until&lt;/a>を使って特定の値未満にループするのも良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> until size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前は少しコストがかかることになりましたが、Kotlin 1.1.4以降は以下のようなコードが生成されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> var2 &lt;span style="color:#f92672">=&lt;/span> size; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> var2; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、そのほかは最適化があまり効いてないケースもあります。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/reversed.html" target="_blank" rel="noopener"
>reversed()&lt;/a>を使う例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> (&lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>).reversed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルされたコードがあまり綺麗とは言えません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>IntProgression var10000 = &lt;span style="color:#a6e22e">RangesKt&lt;/span>.reversed((IntProgression)(new IntRange(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int i = var10000.getFirst();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int var3 = var10000.getLast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int var4 = var10000.getStep();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(var4 &amp;gt; &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &amp;gt; var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(i &amp;lt; var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">System&lt;/span>.&lt;span style="color:#66d9ef">out&lt;/span>.println(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">==&lt;/span> var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">+=&lt;/span> var4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>IntRange&lt;/code>オブジェクトが範囲を再定義するため生成され、さらに&lt;code>IntProgression&lt;/code>オブジェクトが逆順に要素を整列するために生成されます。&lt;/p>
&lt;p>&lt;code>progression&lt;/code>を作るのに二つ以上の関数が使われていると、二つ以上のオブジェクトを作るようなオーバーヘッドが発生することになります。&lt;/p>
&lt;p>上記のルールは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/step.html" target="_blank" rel="noopener"
>step()&lt;/a>を使う場合も同じで、&lt;code>step 1&lt;/code>を指定しても状況は変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span> step &lt;span style="color:#ae81ff">2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに、生成されたコードで最後の値を読み込む時、&lt;code>IntProgression&lt;/code>オブジェクトの最後の要素と&lt;code>step()&lt;/code>で指定した範囲を考慮して追加の処理が行われます。上記のサンプルだと最後の要素は&lt;code>9&lt;/code>です。&lt;/p>
&lt;p>なので、&lt;code>for&lt;/code>を利用したループをするときはなるべく&lt;code>..&lt;/code>、&lt;code>downTo()&lt;/code>、&lt;code>until()&lt;/code>を利用してオーバーヘッドを避けた方が良いでしょう。&lt;/p>
&lt;h3 id="foreachループ">forEachループ
&lt;/h3>&lt;p>&lt;code>for&lt;/code>ループの代わりに、rangeに対してinline拡張関数の&lt;code>forEach()&lt;/code>を使う場合も結果はあまり変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">1.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>).forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、&lt;code>forEach()&lt;/code>は&lt;code>Iterable&lt;/code>に対してのみ最適化されてないです。これはつまり、iteratorを生成する必要があるということを意味します。なので、コンパイルされると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Iterable $receiver$iv &lt;span style="color:#f92672">=&lt;/span> (Iterable)(&lt;span style="color:#66d9ef">new&lt;/span> IntRange(1, 10));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Iterator var1 &lt;span style="color:#f92672">=&lt;/span> $receiver$iv.&lt;span style="color:#a6e22e">iterator&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span>(var1.&lt;span style="color:#a6e22e">hasNext&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> element$iv &lt;span style="color:#f92672">=&lt;/span> ((IntIterator)var1).&lt;span style="color:#a6e22e">nextInt&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(element$iv);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは今までのサンプルよりもコストのかかるものです。&lt;code>IntRange&lt;/code>オブジェクトを生成するだけでなく、&lt;code>IntIterator&lt;/code>オブジェクトも生成しているからです。primitiveではない場合はさらにコストがかかるでしょう。&lt;/p>
&lt;p>なので、rangeを使ったループが必要な場合は&lt;code>forEach()&lt;/code>より&lt;code>for&lt;/code>ループを使ってオーバーヘッドを減らした方が良いです。&lt;/p>
&lt;h3 id="collectionインデックスループ">collectionインデックスループ
&lt;/h3>&lt;p>Kotlinのスタンダードライブラリは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/indices.html" target="_blank" rel="noopener"
>indices&lt;/a>という拡張プロパティで配列と&lt;code>Collection&lt;/code>のインテックスを提供します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> list.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(list[i])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>indices&lt;/code>のコンパイルされた結果は良い最適化を見せてくれます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List list &lt;span style="color:#f92672">=&lt;/span> CollectionsKt.&lt;span style="color:#a6e22e">listOf&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span>{&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> var2 &lt;span style="color:#f92672">=&lt;/span> ((Collection)list).&lt;span style="color:#a6e22e">size&lt;/span>(); i &lt;span style="color:#f92672">&amp;lt;&lt;/span> var2; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object var3 &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">get&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(var3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>IntRange&lt;/code>オブジェクトが作られてないです。では、自前で実装してみるとどうなるのでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> SparseArray&amp;lt;*&amp;gt;.indices: IntRange
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = &lt;span style="color:#ae81ff">0&lt;/span> until size()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">printValues&lt;/span>(map: SparseArray&amp;lt;String&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> map.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(map.valueAt(i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>拡張プロパティとして定義してコンパイルすると、あまり効率的ではないコードになっていることがわかります。&lt;code>IntRange&lt;/code>オブジェクトが作られてます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> static &lt;span style="color:#66d9ef">final&lt;/span> void printValues(&lt;span style="color:#a6e22e">@NotNull&lt;/span> SparseArray map) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Intrinsics&lt;/span>.checkParameterIsNotNull(map, &lt;span style="color:#e6db74">&amp;#34;map&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IntRange var10000 = &lt;span style="color:#a6e22e">RangesKt&lt;/span>.until(&lt;span style="color:#ae81ff">0&lt;/span>, map.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int i = var10000.getFirst();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int var2 = var10000.getLast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#66d9ef">receiver&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>iv = map.valueAt(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">System&lt;/span>.&lt;span style="color:#66d9ef">out&lt;/span>.println(&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#66d9ef">receiver&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>iv);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(i &lt;span style="color:#f92672">==&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">++&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合は代わりに&lt;code>until()&lt;/code>と&lt;code>for&lt;/code>ループを使った方が良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">printValues&lt;/span>(map: SparseArray&amp;lt;String&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> until map.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(map.valueAt(i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたか。個人的にはあまり委譲プロパティを使ったことがなく、そもそもの理解を兼ねてかなり勉強になりました。また、rangeに関しても、Javaでの習慣でテストクラスのフィールドとして定義していろいろな関数で使い回していましたが、まさかそれがよりコストのかかることだとは思ってなかったので少しショックでした。&lt;/p>
&lt;p>また、改めてKotlinで提供している機能とAPIに対して正しく理解する必要があると思いました。そして&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%83%E3%82%AB%E3%83%A0%E3%81%AE%E5%89%83%E5%88%80" target="_blank" rel="noopener"
>オッカムの剃刀&lt;/a>でも話しているように、なるべくシンプルなロジックとコードを追求する必要があるとも思いましたね。intellijのメニューのうち、&lt;code>Tools &amp;gt; Kotlin &amp;gt; Show Kotlin Bytecode&lt;/code> でいつでもJavaのコードにdecomplieされたコードを確認できるので、最新だとどのように変換されるのかを確認してみながらコードを最適化を行なった方が良いかもしれません。&lt;/p>
&lt;p>今月はいつもの、自分の経験や仮説を紹介するようなポストでなく、ほぼ翻訳のみになってしまいましたが、私自身としてはかなり貴重な知識を得られたと思っています。またの機会で何か良いものがあったら、是非とも紹介させていただきたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその２</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-2/</link><pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-2/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinの隠されたコストーその２" />&lt;p>今回はまたKotlinの隠されたコストに対するポストです。今となってはあまり気にすることはないかもしれませんし（検証は必要そうですが、バージョンアップごとにコンパイラが生成するコードを追うのは大変そうですね…）、極限のチューニングをするよりもマシンスペックを上げた方がよい時代になったとはいうものの、この記事で紹介していることをコーディングの習慣として身につけておくと良いかなと思います。&lt;/p>
&lt;p>前回は高階関数とLambda、そしてcompanion objectに関する記事を紹介しました。今回はローカル関数、Null安定性、Varargsに隠されたKotlinのコストについて述べます。この記事は&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-2-324a4a50b70" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 2&lt;/a>の内容を要約したものです。&lt;/p>
&lt;h2 id="ローカル関数">ローカル関数
&lt;/h2>&lt;p>関数内に定義した関数を「ローカル関数」と言います。これらローカル関数は、アウター関数（ローカル関数が定義された関数）の範囲にアクセスできます。例えば以下だと、&lt;code>sumSquare&lt;/code>で&lt;code>someMath&lt;/code>のパラメータにアクセスしているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">someMath&lt;/span>(a: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">sumSquare&lt;/span>(b: Int) = (a + b) * (a + b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sumSquare(&lt;span style="color:#ae81ff">1&lt;/span>) + sumSquare(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ローカル関数は基本的にLambdaと似ていますが、他に制限があります。ローカル関数そのものと、ローカル関数を含む関数もまた&lt;code>inline&lt;/code>として定義できません。なので関数の呼び出しにかかるコストを避ける方法がありません。&lt;/p>
&lt;p>コンパイルされたローカル関数は&lt;code>Function&lt;/code>オブジェクトに変わります。なので前回の記事で述べた「インライン化してないLambda」と同じ問題を持っています。上記のコードをJavaのコードで表すと以下のような形になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">someMath&lt;/span>(&lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Function1 sumSquare$ &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Function1(1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: 生成されたメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: ブリッジメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object var1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Integer.&lt;span style="color:#a6e22e">valueOf&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">invoke&lt;/span>(((Number)var1).&lt;span style="color:#a6e22e">intValue&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">invoke&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (a &lt;span style="color:#f92672">+&lt;/span> b) &lt;span style="color:#f92672">*&lt;/span> (a &lt;span style="color:#f92672">+&lt;/span> b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sumSquare$.&lt;span style="color:#a6e22e">invoke&lt;/span>(1) &lt;span style="color:#f92672">+&lt;/span> sumSquare$.&lt;span style="color:#a6e22e">invoke&lt;/span>(2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Lambdaと比べ一つ性能が劣化されない点があります。関数のインスタンスが呼び出し元からわかるので、ジェネリックなインタフェースを使わず、匿名クラスになりメソッドが直接呼び出されます。これは外の関数からローカル関数を呼び出す際に、&lt;code>casting&lt;/code>や&lt;code>boxing&lt;/code>が発生しないということを意味します。実際のBytecodeを見ると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ICONST_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKEVIRTUAL be/myapplication/MyClassKt$someMath$1.invoke (I)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ICONST_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKEVIRTUAL be/myapplication/MyClassKt$someMath$1.invoke (I)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IADD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IRETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでメソッドが2回呼び出されていますが、メソッドの引数も戻り値も&lt;code>int&lt;/code>型になっていて、&lt;code>boxing&lt;/code>と&lt;code>unboxing&lt;/code>がないのを確認できます。&lt;/p>
&lt;p>ただ、依然としてメソッドが呼び出されるたびに&lt;code>Function&lt;/code>オブジェクトのインスタンスを生成していますが、ローカル関数をvalue caputeなしのものに代替することでこの問題は回避できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">someMath&lt;/span>(a: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">sumSquare&lt;/span>(a: Int, b: Int) = (a + b) * (a + b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sumSquare(a, &lt;span style="color:#ae81ff">1&lt;/span>) + sumSquare(a, &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにすることで、&lt;code>Function&lt;/code>オブジェクトのインスタンスは再利用できるようなものになります。こうすることで既存のprivate関数に比べ、ローカル関数のデメリットは追加のクラス（メソッドを含む）を生成するということだけになります。&lt;/p>
&lt;p>ローカル関数はprivate関数の代替として、アウター関数の変数にアクセスできるというメリットがあります。ただこれによって&lt;code>Function&lt;/code>オブジェクトを生成するというコストがかかりますので、non-capturingにする工夫が必要です。&lt;/p>
&lt;h2 id="null安全性">Null安全性
&lt;/h2>&lt;p>Kotlinの最も良い機能の一つは明視的にnullになり得る型とそうでない型を区別できるということです。これによってコンパイラがランタイムで予期せぬ&lt;code>NullPointerException&lt;/code>を投げるのを防止できます。&lt;/p>
&lt;h3 id="non-nullパラメータのランタイムでのチェック">Non-nullパラメータのランタイムでのチェック
&lt;/h3>&lt;p>例えば以下のような関数があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>(who: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello &lt;/span>&lt;span style="color:#e6db74">$who&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはJavaのコードで以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>(&lt;span style="color:#a6e22e">@NotNull&lt;/span> String who) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics.&lt;span style="color:#a6e22e">checkParameterIsNotNull&lt;/span>(who, &lt;span style="color:#e6db74">&amp;#34;who&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String var1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> who;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(var1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>@NotNull&lt;/code>アノテーションが追加され、Java側にnullが渡されてはいけないということを知らせています。&lt;/p>
&lt;p>しかし、アノテーションは呼び出し側にnull safetyを強制するものではありません。なのでstaticメソッドを呼び出してパラメータをもう一度確認しています。この関数は&lt;code>IllegalArgumentException&lt;/code>を投げて呼び出し元の修正を簡単にします。&lt;/p>
&lt;p>publicな関数には常にnon-nullなパラメータに対して&lt;code>Intrinsics.checkParameterIsNotNull()&lt;/code>でのチェックがが追加されますが、privateな関数に対しては追加されません。なぜなら、Kotlinクラスはnull safeであることをコンパイラが保証するからです。&lt;/p>
&lt;p>このNullチェックによるパフォーマンスへの影響は無視しても良いほどでテストにも有用ですが、ビルド時にもっと時間がかかる原因になります。これに対してはコンパイラのオプションに&lt;code>-Xno-param-assertions&lt;/code>を追加するか、&lt;a class="link" href="https://www.guardsquare.com/proguard" target="_blank" rel="noopener"
>ProGuard&lt;/a>のルールに以下の設定を追加することでランタイムNullチェックをなくすことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span>assumenosideeffects &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">kotlin&lt;/span>.&lt;span style="color:#a6e22e">jvm&lt;/span>.&lt;span style="color:#a6e22e">internal&lt;/span>.&lt;span style="color:#a6e22e">Intrinsics&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">checkParameterIsNotNull&lt;/span>(java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">Object&lt;/span>, java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ上記のルールを追加する場合、AndroidのProGuardのOptimization設定が有効になっているかのチェックがまず必要です。この設定はデフォルトでは無効になっています。&lt;/p>
&lt;h3 id="nullable-primitive型">Nullable primitive型
&lt;/h3>&lt;p>まず先に覚えておくべきことは、nullableで宣言したprimitive型は常にJavaの&lt;code>int&lt;/code>や&lt;code>float&lt;/code>などの代わりに&lt;code>Integer&lt;/code>、&lt;code>Float&lt;/code>といった&lt;code>boxed reference&lt;/code>型が使われるので追加のコストが発生するということです。&lt;/p>
&lt;p>&lt;a class="link" href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/autoboxing.html" target="_blank" rel="noopener"
>autoboxing&lt;/a>とnull-safetyを無視するのでJavaでは&lt;code>Integer&lt;/code>でも&lt;code>int&lt;/code>でもコードはあまり変わらないJavaに対して、Kotlinだとnullableに対して安全なコードを書くように強制しているので、non-nullの方を使った方が良いというのが明確にわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a: Int, b: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a + b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a: Int?, b: Int?): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (a &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) + (b &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、なるべくコードの可読性と性能を考慮してnon-nullの方を選んだ方が良いです。&lt;/p>
&lt;h3 id="配列">配列
&lt;/h3>&lt;p>Kotlinには、以下の3通りの配列があります。&lt;/p>
&lt;ul>
&lt;li>&lt;code>IntArray&lt;/code>、&lt;code>FloatArray&lt;/code>のようなもの：primitive型の配列。&lt;code>int[]&lt;/code>、&lt;code>float[]&lt;/code>のような型にコンパイルされる。&lt;/li>
&lt;li>&lt;code>Array&amp;lt;T&amp;gt;&lt;/code>：non-nullオブジェクトの型が指定された配列。primitiveに対して&lt;code>boxing&lt;/code>が起こりえる。&lt;/li>
&lt;li>&lt;code>Array&amp;lt;T?&amp;gt;&lt;/code>：nullableオブジェクトの型が指定された配列。明確に&lt;code>boxing&lt;/code>が起こる。&lt;/li>
&lt;/ul>
&lt;p>もしnon-nullなprimitive型の配列が必要な場合は、なるべく&lt;code>Array&amp;lt;Int&amp;gt;&lt;/code>の代わりに&lt;code>IntArray&lt;/code>を使いましょう。&lt;/p>
&lt;h2 id="varargs">Varargs
&lt;/h2>&lt;p>KotlinではJavaとは書き方が少し違いますが、&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#variable-number-of-arguments-varargs" target="_blank" rel="noopener"
>可変長引数&lt;/a>を定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">printDouble&lt;/span>(&lt;span style="color:#66d9ef">vararg&lt;/span> values: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values.forEach { println(&lt;span style="color:#66d9ef">it&lt;/span> * &lt;span style="color:#ae81ff">2&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaと同じく、&lt;code>vararg&lt;/code>はコンパイルされると指定した型の配列になります。そして上記の関数は以下のように、３つの方法で呼び出すことができます。&lt;/p>
&lt;h3 id="複数のパラメータを渡す">複数のパラメータを渡す
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>printDouble(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinのコンパイラはこれを新しい配列の生成と初期化に変えます。これはJavaと一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>printDouble(new int[]{&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはつまり新しい配列を作るためのオーバヘッドがあるということです。ただJavaと変わらないやり方です。&lt;/p>
&lt;h3 id="配列を渡す">配列を渡す
&lt;/h3>&lt;p>Javaでは配列をそのまま渡すことができますが、Kotlinだとそれができず、&lt;code>spread operator&lt;/code>を使う必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> values = intArrayOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(*values)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaでは配列の参照が&lt;code>as-is&lt;/code>として関数に渡され、新しい配列の割り当ては起こりません。しかし、Kotlinの&lt;code>spread operator&lt;/code>は以下のようなことをします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> values &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span>{1, 2, 3};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(Arrays.&lt;span style="color:#a6e22e">copyOf&lt;/span>(values, values.&lt;span style="color:#a6e22e">length&lt;/span>));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列のコピーが関数に渡されるので、より安全なコードといえます。呼び出し側には影響なしで、配列を修正できますので。しかしメモリを追加的に消費してしまいます。&lt;/p>
&lt;h3 id="配列と他の引数を混ぜて渡す">配列と他の引数を混ぜて渡す
&lt;/h3>&lt;p>&lt;code>spread operator&lt;/code>の良い点は、配列と他の引数を混ぜて渡すこともできるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> values = intArrayOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(&lt;span style="color:#ae81ff">0&lt;/span>, *values, &lt;span style="color:#ae81ff">42&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はどうコンパイルされるか気になりませんか？結果はかなり面白いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> values &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span>{1, 2, 3};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IntSpreadBuilder var10000 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IntSpreadBuilder(3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000.&lt;span style="color:#a6e22e">add&lt;/span>(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000.&lt;span style="color:#a6e22e">addSpread&lt;/span>(values);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000.&lt;span style="color:#a6e22e">add&lt;/span>(42);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(var10000.&lt;span style="color:#a6e22e">toArray&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列を新しく生成するだけでなく、一時的なビルダオブジェクトを使って配列の最終的なサイズを計算しています。なので配列を渡す時よりもコストは追加されます。&lt;/p>
&lt;p>なので、呼び出される回数の多くパフォーマンスが重要なコードに対してはなるべく可変長引数より実際の配列をパラメータとして使った方が良いです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがでしたか。個人的にprivate関数をよく使うので、よりスコープを制限できるという面でローカル関数を積極的に使いたいと思っていましたが、ここでも隠されたコストがあるというというのは興味深かったです。primitive型についてはJavaがそうだったので、なんとなく&lt;code>boxing&lt;/code>が起こるんじゃないかなと思っていたものの、nullableに対してのみそうだというのも面白かったですね。逆に、primitiveのままになるnon-null型に対してはどうやってチェックが走るのだろうという新しい疑問もありました。（例えば&lt;code>int&lt;/code>だとデフォルト値の&lt;code>0&lt;/code>が常に割り当てられるので）&lt;/p>
&lt;p>あと、配列の場合はJavaでも&lt;code>IntStream&lt;/code>、&lt;code>DoubleStream&lt;/code>などがあったのでなんとなくすぐ理解ができましたが、まさか&lt;code>varargs&lt;/code>で渡したパラメータに対して色々とコストが追加されるとは思わなかったです。そもそもあまり配列を使わないので、可変長引数を使う場面もなかったのですが…よく使わないものほど重要なことを忘れやすそうなので、これは覚えておかないとですね。色々と勉強になりました。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその１</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-1/</link><pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-1/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinの隠されたコストーその１" />&lt;p>Kotlinは便利ですが、何が便利かというと代表的に挙げられるものがたくさんのシンタクスシュガーではないかと思います。同じJVM言語のJavaと比べ、多くの場合でコード量が劇的に減るのが嬉しいという評価も多いものですね。しかし、この便利さの裏には隠されたコスト（性能面での）があるという話があります。今回はそれについて説明している良い記事を見つけたので、共有したいと思います。ただ、翻訳よりは要約に近いものなので、そこはご了承ください。&lt;/p>
&lt;p>ちなみにここで紹介している記事（&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 1&lt;/a>）は、2017年に作成された（Kotlinがまだ1.1だったころ）ので、1.5にまでバージョンアップを成している今からすると、コンパイラの改善などで少し状況が違うケースもあるかと思いますが、述べている内容のレベルが高いので一度は目を通してみても良いかなと思います。また、記事で紹介しているKotlinのBytecodeに対しても、直接最近のKotlinが生成しているコードと比較してみるのも面白いかもですね。&lt;/p>
&lt;p>また、今回紹介している記事は&lt;code>Part 1&lt;/code>ですが、そのほかにも&lt;code>Part 2&lt;/code>や&lt;code>Part 3&lt;/code>の記事がありますので、今後も順次紹介させていただきたいと思います。では、まず&lt;code>Lambda表現式とcompanion object&lt;/code>編を、どうぞ。&lt;/p>
&lt;h2 id="高階関数とlambda表現式">高階関数とLambda表現式
&lt;/h2>&lt;p>例えば以下のような関数を定義しておいたとしましょう。渡されたパラメータをDBのトランザクションの中で実行し、実行結果の行数を返すものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">transaction&lt;/span>(db: Database, body: (Database) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.beginTransaction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = body(db)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.setTransactionSuccessful()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.endTransaction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数は、Lambdaを渡して以下のように使えますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> deletedRows = transaction(db) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.delete(&lt;span style="color:#960050;background-color:#1e0010">“&lt;/span>Customers&lt;span style="color:#960050;background-color:#1e0010">”&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinはJava 1.6のJVMから使えますが、Java 1.6のJVMではLambdaに対応していないのです。なので、Kotlinはその互換性を維持するためにLambda（匿名関数も）を&lt;code>Function&lt;/code>というオブジェクトを生成することで対応しています。&lt;/p>
&lt;h3 id="functionオブジェクト">Functionオブジェクト
&lt;/h3>&lt;p>では、実際コンパイルされたLambda（body）がJavaのコードとしてはどうなっているかをみていきましょう。（ここでは、Intellij/Android Studioの&lt;code>Show Kotlin Bytecode&lt;/code>の&lt;code>Decompile&lt;/code>機能を使っています）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass$myMethod$1&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Function1 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: 生成されたメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// $FF: ブリッジメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object var1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Integer.&lt;span style="color:#a6e22e">valueOf&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">invoke&lt;/span>((Database)var1));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">invoke&lt;/span>(&lt;span style="color:#a6e22e">@NotNull&lt;/span> Database it) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics.&lt;span style="color:#a6e22e">checkParameterIsNotNull&lt;/span>(it, &lt;span style="color:#e6db74">&amp;#34;it&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> it.&lt;span style="color:#a6e22e">delete&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Customers&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを見るとわかりますが、Lambda（匿名関数）を使う場合、コンパイルされた結果としては基本的に3、4個のメソッドが追加で生成されるということになります。ここで追加された&lt;code>Function&lt;/code>オブジェクトのインスタンスは、必要な時にだけ生成されます。正確には、以下のような動作をします。&lt;/p>
&lt;ul>
&lt;li>value captureがある場合、毎回パラメータが渡されるたび&lt;code>Function&lt;/code>のインスタンスが生成され、GCの対象になる&lt;/li>
&lt;li>value captureがない場合、&lt;code>Function&lt;/code>はSingletonとしてインスタンスが生成され再利用できる&lt;/li>
&lt;/ul>
&lt;p>先ほどのコードでは、value captureがないため、Lambdaの呼び出し元は以下のようなコードとしてコンパイルされます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">transaction&lt;/span>(db, (Function1)MyClass$myMethod$1.&lt;span style="color:#a6e22e">INSTANCE&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、value captureのある高階関数を繰り返し呼び出す場合はGCによる性能の低下を考えれます。&lt;/p>
&lt;h3 id="boxingオーバーヘッド">Boxingオーバーヘッド
&lt;/h3>&lt;p>Lambdaに対応しているJava 1.8以降のバージョンでは、&lt;code>Function&lt;/code>インタフェースを複数提供していることでなるべくboxing/unboxingを避けようとしています。しかし、Kotlinでコンパイルされた場合はgenericを利用しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/** 引数を一つ受け取る関数 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Function1&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">in&lt;/span> P1, &lt;span style="color:#66d9ef">out&lt;/span> R&amp;gt; : Function&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/** 引数を受け取り関数を実行する */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">invoke&lt;/span>(p1: P1): R
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらをみてわかるのは、高階関数でパラメータとして渡された関数を呼び出す時に、その関数にprimitiveタイプの値が存在する場合（パラメータ、もしくは戻り値）boxing/unboxingが起こるということです。先ほどのコンパイルされたLambdaにおいて、戻り値が&lt;code>Integer&lt;/code>としてboxingされたのを確認できましたね。&lt;/p>
&lt;p>primitiveタイプを使用するLambdaをパラメータとしてとる高階関数は、参照回数が少なければあまり意識しなくてもよいコストになりますが、そうでない場合は性能に影響があると推定できます。&lt;/p>
&lt;h3 id="inline関数">Inline関数
&lt;/h3>&lt;p>幸い、Kotlinでは&lt;code>inline&lt;/code>と言うキーワドを提供しています。これを使うと高階関数をインライン化できますね。インライン化されると呼び出し元のコードに&lt;code>Function&lt;/code>の中身を直接含ませてコンパイルします。なので、インライン化された場合は以下のような面で性能の向上を考えられます。&lt;/p>
&lt;ul>
&lt;li>Functionオブジェクトのインスタンスが生成されない&lt;/li>
&lt;li>primitiveタイプを使う関数に対してboxing/unboxingが起こらない&lt;/li>
&lt;li>メソッドカウントが増えない（Androidの場合、アプリが参照できるメソッドの数字に制限がある）&lt;/li>
&lt;li>関数の呼び出しが増えない（CPU依存が高く、呼び出される頻度の高いコードのパフォーマンスの改善を期待できる）&lt;/li>
&lt;/ul>
&lt;p>インライン化された場合のコードを確認してみましょう。&lt;code>transaction&lt;/code>関数が消え、&lt;code>db.delete&lt;/code>を直接呼び出しているのがわかります。また、戻り値の&lt;code>result&lt;/code>もWrapperクラスからprimitiveタイプになっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>db.&lt;span style="color:#a6e22e">beginTransaction&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> result$iv &lt;span style="color:#f92672">=&lt;/span> db.&lt;span style="color:#a6e22e">delete&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Customers&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#a6e22e">setTransactionSuccessful&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.&lt;span style="color:#a6e22e">endTransaction&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、&lt;code>inline&lt;/code>キーワードを使うときは以下のことを考慮しなければならないです。&lt;/p>
&lt;ul>
&lt;li>インライン関数は自分自身を直接呼び出したり、他のインライン関数から呼び出せない&lt;/li>
&lt;li>クラスに定義されたpublicなインライン関数はそのクラスのpublic関数とフィールドのみアクセスできる&lt;/li>
&lt;li>コンパイルされたコードが大きくなる（繰り返し参照される場合はより大きくなる）&lt;/li>
&lt;/ul>
&lt;p>なるべく高階関数をインライン化し、必要であれば長いコードブロックをインラインではない関数に写した方がいいです。また、性能が大事なところでは呼び出された関数をインライン化することも考えられます。&lt;/p>
&lt;h2 id="companion-object">Companion object
&lt;/h2>&lt;p>Kotlinではクラスがstaticなフィールドやメソッドを定義できません。その代わりに&lt;code>companion object&lt;/code>を使うことになっていますね。&lt;/p>
&lt;h3 id="クラスのprivateフィールドをcompanion-objectからアクセスする">クラスのprivateフィールドをcompanion objectからアクセスする
&lt;/h3>&lt;p>以下のような例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> hello = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">newInstance&lt;/span>() = MyClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードがコンパイスされると、&lt;code>companion object&lt;/code>はSingletonクラスになります。なので、クラスのprivateフィールドに外部クラスからアクセスできるようにする必要があり、コンパイラが&lt;code>getter&lt;/code>、&lt;code>setter&lt;/code>を追加で生成することになるということです。生成されたメソッドは&lt;code>companion object&lt;/code>から参照されることになります。以下を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass.access$getHello$p (Lbe/myapplication/MyClass;)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ISTORE 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaだとこれを避けるためにアクセス制限を&lt;code>package&lt;/code>単位にすることができましたが、Kotlinではそのようなキーワードがないですね。&lt;code>public&lt;/code>や&lt;code>internal&lt;/code>を使う場合も&lt;code>getter&lt;/code>と&lt;code>setter&lt;/code>は基本的に生成されます。また、これらのメソッドはinstanceメソッドであり、staticメソッドよりもコストが高いですね。なので、最適化のためフィールドのアクセス制限を変えるということは避けた方が良いです。&lt;/p>
&lt;p>もし&lt;code>companion object&lt;/code>からクラスのフィールドに頻繁なアクセスが発生するとしたら、この隠れているメソッドの呼び出しを避けるためにフィールドの値をキャッシュするという方法も考慮できます。&lt;/p>
&lt;h3 id="companion-objectの定数にアクセスする">Companion objectの定数にアクセスする
&lt;/h3>&lt;p>Kotlinでは、クラス内のstaticな定数は&lt;code>companion object&lt;/code>の中に定義するのが一般的です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> TAG = &lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(TAG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見シンプルで良さげなコードですが、Kotlin 1.2.40以前の場合だとかなり裏のコードは汚くなっています。&lt;/p>
&lt;h4 id="kotlin-1240以前の場合">Kotlin 1.2.40以前の場合
&lt;/h4>&lt;p>&lt;code>companion object&lt;/code>に定義されたprivateな定数にアクセスする場合、上記のようなこと（&lt;code>getter&lt;/code>を利用する）が起こります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GETSTATIC be/myapplication/MyClass.Companion : Lbe/myapplication/MyClass$Companion;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass$Companion.access$getTAG$p (Lbe/myapplication/MyClass$Companion;)Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ASTORE 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>問題はこれだけではありません。生成されたメソッドは実際の値を返すわけでなく、instanceメソッドとして生成された&lt;code>getter&lt;/code>を呼び出すことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESPECIAL be/myapplication/MyClass$Companion.getTAG ()Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>定数が&lt;code>public&lt;/code>になっている場合はダイレクトにアクセスできるようになりますが、依然として&lt;code>getter&lt;/code>メソッドを通して値にアクセスことになります。&lt;/p>
&lt;p>そして定数の値を格納するために、Kotlinコンパイラは&lt;code>companion object&lt;/code>ではなく、それを持つクラスの方に&lt;code>private static final&lt;/code>フィールドを生成します。さらに&lt;code>companion object&lt;/code>からこのフィールドにアクセスするため、またのメソッドを生成することとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass.access$getTAG$cp()Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こういう長い道のりで、やっと値を読み込むことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GETSTATIC be/myapplication/MyClass.TAG : Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まとめると、Kotlin 1.2.40以前のバージョンを使っている場合は以下のようになります。&lt;/p>
&lt;ul>
&lt;li>&lt;code>companion object&lt;/code>から静的メソッドを呼び出す
&lt;ul>
&lt;li>&lt;code>companion object&lt;/code>からinstanceメソッドを呼び出す
&lt;ul>
&lt;li>クラスのstaticメソッドを呼び出す
&lt;ul>
&lt;li>staticフィールドから値を読み込む&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>これをJavaのコードで表現すると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String TAG &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Companion companion &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Companion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 生成されるメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String &lt;span style="color:#a6e22e">access$getTAG$cp&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> TAG;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Companion&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String &lt;span style="color:#a6e22e">getTAG&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> MyClass.&lt;span style="color:#a6e22e">access$getTAG$cp&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 生成されるメソッド&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String &lt;span style="color:#a6e22e">access$getTAG$p&lt;/span>(Companion c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> c.&lt;span style="color:#a6e22e">getTAG&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Companion.&lt;span style="color:#a6e22e">access$getTAG$p&lt;/span>(companion));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>よりコストの低いBytecodeを生成することも可能ですが、それは簡単ではないです。&lt;/p>
&lt;p>まず&lt;code>const&lt;/code>キーワードを使ってコンパイルタイム定数を定義することでメソッドの呼び出しをなくすことができます。しかし、KotlinではprimitiveかStringに対してのみ可能な方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> TAG = &lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(TAG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または&lt;code>@JvmField&lt;/code>を使ってJavaのアプローチを取る方法を考えられます。こうすることで&lt;code>getter&lt;/code>や&lt;code>setter&lt;/code>が生成されず、フィールドに直接アクセスができるようになります。ただ、&lt;code>@Jvm&lt;/code>系のアノテーションはJavaとの互換性のためのものであるのでこれが果たして良い方法かどうかを考えた方が良いでしょう。そして&lt;code>public&lt;/code>なフィールドのみ可能な方法です。&lt;/p>
&lt;p>Androidの開発の場合だと、&lt;code>Parcelable&lt;/code>オブジェクトを自前で実装する場合のみ有効な方法に思われます。例えば以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span>() : Parcelable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">companion&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@JvmField&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> CREATOR = creator { MyClass(&lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">constructor&lt;/span>(parcel: Parcel) : &lt;span style="color:#66d9ef">this&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">writeToParcel&lt;/span>(dest: Parcel, flags: Int) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">describeContents&lt;/span>() = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後の方法として、&lt;a class="link" href="https://developer.android.com/studio/build/shrink-code" target="_blank" rel="noopener"
>ProGuard&lt;/a>やR8のようなツールを使ってBytecodeの最適化を狙うという方法があるでしょう。&lt;/p>
&lt;h4 id="kotlin-1240以降の場合">Kotlin 1.2.40以降の場合
&lt;/h4>&lt;p>Kotlinn 1.2.40からは、&lt;code>companion object&lt;/code>に定義された値はメインクラスの方に格納されるということには変わりがありませんが、メソッドの生成と呼び出しなしで直接アクセスができるようになりました。これをJavaのコードとして表現すると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String TAG &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TAG&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Companion companion &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Companion();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Companion&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(TAG);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、上記のように&lt;code>companion object&lt;/code>にメソッドが一つもない場合は、ProGuardやR8によるツールと使うとクラス自体が消えることで最適化されます。&lt;/p>
&lt;p>ただ、&lt;code>companion object&lt;/code>に定義さえたメソッドの場合はコストが少しかかります。フィールドがメインクラスの方に格納されてあるため、&lt;code>companion object&lt;/code>に定義されたprivateフィールドにアクセスするためには依然として生成されたメソッドを経由することになります。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>今回は人の書いた記事を読んだだけですが、かなり勉強になる内容でした。特に私個人としては、intellijを使っていると何を基準に&lt;code>inline&lt;/code>キーワードを使った方がいいという警告が出るのか悩ましい場面がありましたが、それが少し理解できました。&lt;code>companion object&lt;/code>に関する話も、今は問題が解決されたものの、何も考えず「定数だから&lt;code>companion object&lt;/code>だな」と思っていた自分を反省することになりましたね。そしてこの後の記事でも面白い内容が色々と出てくるので、またの機会でぜひ紹介したいと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その三〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-3/</link><pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-3/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その三〜" />&lt;p>JavaからKotlinに移行したものの立場から言うと、Kotlinはスタンダードライブラリだけでも色々な関数を提供しているので、Javaに比べてかなり生産性が上がるといえますが、逆にいまいち関数の有効な使い方がわからなかったり、どうやって処理を書いたら「Kotlinらしい」かわからない場合もあるかと思います。なのでもう3回目のポストになりますが、今回もKotlinで色々とコードを書いてみて、そのうち良さそうなものをいくつか共有します。&lt;/p>
&lt;h2 id="listの要素をスワップ">Listの要素をスワップ
&lt;/h2>&lt;p>Listの要素の順番を変える方法はソートなどを含め色々とありますが、二つの要素をスワップ（インデックスを交換）したい場合もあるかと思います。こういう時に活用できる拡張関数を考えてみました。&lt;/p>
&lt;h3 id="インデックスがわかる場合">インデックスがわかる場合
&lt;/h3>&lt;p>スワップしたい要素のインデックスがわかる場合は、そのインデックスを交換すればいいだけですね。ここでインデックスの交換は、二つの変数の値をスワップすることと変わらないです。変数の値を交換するのは伝統的には以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> a = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> b = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> c = a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b = c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もう少しKotlinらしい方法では、&lt;code>also&lt;/code>を用いたものがあります。その方法だと、必要な処理は以下のようにもっとシンプルになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> a = &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> b = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = b.also { b = a }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これと同じく、Listの要素をスワップする処理を拡張関数で書くとしたらと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.swapByIndex(indexFrom: Int, indexTo: Int): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toMutableList().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>[indexFrom] = &lt;span style="color:#66d9ef">this&lt;/span>[indexTo].also { &lt;span style="color:#66d9ef">this&lt;/span>[indexTo] = &lt;span style="color:#66d9ef">this&lt;/span>[indexFrom] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.toList()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="インデックスがわからない場合">インデックスがわからない場合
&lt;/h3>&lt;p>スワップしたい要素のインデックスがわからない場合もありますが、これも結局インデックスを持って値をスワップすることになるので、まずインデックスを抽出する処理だけを足せば良いかなと思います。&lt;/p>
&lt;p>インデックスを取得する方法は、要素を渡して取得する&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index-of.html" target="_blank" rel="noopener"
>indexOf&lt;/a>とPredicateを渡して取得する&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index-of-first.html" target="_blank" rel="noopener"
>indexOfFirst&lt;/a>があるので、これらを活用することにします。あとはこれらの方法で取得したインデックスを、先に実装しておいた拡張関数に渡すだけで良いです。例えば以下のような実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// indexOf(element)を使うケース
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.swapByElement(from: T, to: T): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swapByIndex(indexOf(from), indexOf(to))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// indexOfFirst(predicate)を使うケース
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.swapByCondition(from: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Boolean, to: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Boolean): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swapByIndex(indexOfFirst { from(&lt;span style="color:#66d9ef">it&lt;/span>) }, indexOfFirst { to(&lt;span style="color:#66d9ef">it&lt;/span>) })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="時間を数字に">時間を数字に
&lt;/h2>&lt;p>&lt;code>java.time&lt;/code>パッケージの&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>のようなオブジェクトは、コード上で時間を扱うには便利ですが、ファイルに書き込むなどでフォーマットを変更する必要がある時もあります。つまり、&lt;code>yyyy-MM-dd&lt;/code>ではなく&lt;code>yyyyMMddhhmmss&lt;/code>のような形にしたい場合があるということです。こういうときは、簡単にInt型に変更できる拡張関数を書いておくと便利でしょう。例えば以下のようなものを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">LocalDate&lt;/span>.toInt(): Int = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$year$monthValue$dayOfMonth&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">12&lt;/span>, &lt;span style="color:#ae81ff">31&lt;/span>) &lt;span style="color:#75715e">// 2021-12-31
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(date.toInt()) &lt;span style="color:#75715e">// 20211231
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうする場合、以下のように月や日付が一桁のものになってしまうケースもあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// 2021-09-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(date.toInt()) &lt;span style="color:#75715e">// 202191
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この問題を解決するには、まず月や日付を二桁の文字列に変える必要がありますね。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">LocalDate&lt;/span>.toInt(): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$year${monthValue.toString().padStart(2, &amp;#39;0&amp;#39;)}${dayOfMonth.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> date = &lt;span style="color:#a6e22e">LocalDate&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// 2021-09-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(date.toInt()) &lt;span style="color:#75715e">// 20210901
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これでも完璧とはいえません。&lt;code>LocalDate&lt;/code>のみでなく&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>, &lt;code>YearMonth&lt;/code>など、&lt;code>java.time&lt;/code>パッケージに属する他のオブジェクトも使いたい場合には、全てのオブジェクトに対して同じような拡張関数を書く必要があるからです。&lt;/p>
&lt;p>幸い、&lt;code>LocalDate&lt;/code>、&lt;code>LocalDateTime&lt;/code>、&lt;code>YearMonth&lt;/code>は共通的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/temporal/Temporal.html" target="_blank" rel="noopener"
>Temporal&lt;/a>というインタフェースを継承しているので、&lt;code>Temporal&lt;/code>に拡張関数を追加することで問題は解決できます。&lt;/p>
&lt;p>そしてこれらの実装クラスで扱っている時間の範囲はオブジェクトごとに違うので、実装も変える必要がありますね。これらのオブジェクトはどれも時間を数字として表現しているので、まず&lt;code>toString&lt;/code>で文字列に変換した後、数字だけを抽出することです。&lt;code>String&lt;/code>は&lt;code>CharSequence&lt;/code>を継承しているので、&lt;code>filter&lt;/code>で数字だけを抽出すると良いでしょう。そうすると、以下のような方法が使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Temporal&lt;/span>.toDigit(): Long = toString().filter { &lt;span style="color:#66d9ef">it&lt;/span>.isDigit() }.toLong()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> yearMonth = &lt;span style="color:#a6e22e">YearMonth&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>) &lt;span style="color:#75715e">// 2021-08
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(yearMonth.toDigit()) &lt;span style="color:#75715e">// 202108
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> dateTime = &lt;span style="color:#a6e22e">LocalDateTime&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>) &lt;span style="color:#75715e">// 2021-10-02T10:10:10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(dateTime.toDigit()) &lt;span style="color:#75715e">// 20211002101010
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Stringのフォーマットで数字に変換する場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int.html" target="_blank" rel="noopener"
>toInt&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-long.html" target="_blank" rel="noopener"
>toLong&lt;/a>でループが一回発生するだけですが、CharSequenceとして扱う場合はループが2回発生するという違いがあるので性能的には前者が良いはずですが、時間を扱うくらいではそこまでループは長くないので気にするほどではないかと思います。&lt;/p>
&lt;h2 id="要素の一部を合算">要素の一部を合算
&lt;/h2>&lt;p>Listの値を一つに集約したい（合算値を出したい）場合があります。&lt;code>sum&lt;/code>を使っても良いですが、これはそもそも要素が数字ではないと難しいですね。例えば要素が以下のようなクラスとなっているケースはどうしたら良いでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Data&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> amount: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> price: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="合算したい値が一つの場合">合算したい値が一つの場合
&lt;/h3>&lt;p>合算したい値が一つだけの場合は、&lt;code>sumOf&lt;/code>で合算したい値だけを指定すれば良いです。以下は、&lt;code>Data&lt;/code>クラスの&lt;code>amount&lt;/code>だけを合算したい場合に使える方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(Data(&lt;span style="color:#e6db74">&amp;#34;data1&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">100&lt;/span>), Data(&lt;span style="color:#e6db74">&amp;#34;data2&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#ae81ff">200&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> totalAmount = list.sumOf { &lt;span style="color:#66d9ef">it&lt;/span>.amount }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="合算したい値が複数の場合">合算したい値が複数の場合
&lt;/h3>&lt;p>ここで&lt;code>amount&lt;/code>のみでなく、&lt;code>price&lt;/code>も合算したい場合はどうすれば良いでしょう。同じく&lt;code>sumOf&lt;/code>を&lt;code>price&lt;/code>にも使うことで実装はできますが、同じListに対してループが2回も発生するのあまり効率的ではありません。こういうときは、素直にそれぞれの合算値を変数として宣言しておいて&lt;code>forEach&lt;/code>ループの中で値を足していく方が効率が良いでしょう。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> totalAmount = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> totalPrice = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> totalAmount &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> totalPrice &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.price
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もう一つの方法は、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold.html" target="_blank" rel="noopener"
>fold&lt;/a>を使う方法です。&lt;code>fold&lt;/code>は&lt;code>reduce&lt;/code>と似たようなもので、初期値(initial)を指定できるという違いがありますが、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reduce-to.html" target="_blank" rel="noopener"
>reduceTo&lt;/a>のようにこの初期値の型はListの要素とは違うものに指定できます。そして関数を実行した結果はinitialと同じ型になるので、これを応用すると&lt;code>Data&lt;/code>のリストを二つの値(&lt;code>Pair&lt;/code>)に&lt;code>reduce&lt;/code>することもできます。例えば上記の処理は&lt;code>fold&lt;/code>を使うと以下のようにワンライナで実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>totalAmount, totalPrice) = list.fold(&lt;span style="color:#ae81ff">0&lt;/span> to &lt;span style="color:#ae81ff">0&lt;/span>) { acc, &lt;span style="color:#66d9ef">value&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (acc.first + &lt;span style="color:#66d9ef">value&lt;/span>.amount) to (acc.second + &lt;span style="color:#66d9ef">value&lt;/span>.price)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>fold&lt;/code>を使う場合、合算したい値が三つある場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-triple/" target="_blank" rel="noopener"
>Triple&lt;/a>を使うこともできますし、さらに値が多い場合は専用のクラスを作ることで対応もできるかと思います。ただ、こうする場合、合算した値を&lt;code>val&lt;/code>として宣言できるというメリットはありますが、ループごとにインスタンスが作成されるので合算したい項目が増えれば増えるほど性能的にはあまり良くない可能性が高いので場合によって適切なものを選ぶ必要がありそうですね。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがだったでしょうか。私はずっとJavaでコードを書いていたので、完全にKotlinに転向した今でもついJavaらしいコードを書いてしまうのではないか、と思う時があります。元を辿ると、「Javaらしいコード」や「Kotlinらしいコード」がそもそも何であるかを考えなければならないとは思いますが、それでも、確かに言語が違うとその言語に合わせて自分のコーディングスタイルも変化する必要はあるのではないかと思います。そうすることで、より良いコードが書けるようになりそうな気がしていますので。&lt;/p>
&lt;p>というわけで、これからもKotlinならではの、Kotlinに特化したコードを書くための工夫はこれからも続きます。特に今月はJava 17もリリースされたので、新しいAPIの一覧を眺めてKotlinではどう活用できるか考えてみたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その二〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-2/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-2/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その二〜" />&lt;p>&lt;a class="link" href="../kotlin-code-in-my-style-1" >前回&lt;/a>に続いて、今回も簡単にKotlinで色々書いてみましたのでその紹介となります。Kotlinではスタンダードライブラリや言語仕様として提供している機能がかなり多いので、これらを使いこなすだけでも生産性やコードのクォリティが大幅に上がるのではないかと思います。なので、今回もJava的な書き方を、Kotlinではどんな方法で効率よく実現できるかを中心に紹介したいと思います。&lt;/p>
&lt;p>もちろんKotlinでは基本的にJavaの書き方でも全く問題なく動くコードを書けますが、Kotlinならではのコードに変えた方がより簡単で短いコードを書ける場合が多く、色々と手間を省けることができるので（そして大抵の場合、スタンダードライブラリの実装の方が自分の書いたコードよりクォリティ高いような…）こういう工夫はする価値が十分にあるのではないかと思います。&lt;/p>
&lt;p>なので、今回は自分が調べたKotlinの小技を少し紹介したいと思います。&lt;/p>
&lt;h2 id="sequentialなデータを作成する">Sequentialなデータを作成する
&lt;/h2>&lt;p>よくユニットテストなどでテスト用データを作成して使う場合がありますね。こういう時に必要となるデータの種類は色々とあるかと思いますが、複数のレコードを番号をつけて順番に揃えた感じのものを作りたい場合もあると思います。例えばData01、Data02、Data03…といったデータを作りたい場合ですね。&lt;/p>
&lt;p>この場合は、ループでデータを作り、Listにまとめるというのが一般的ではないかと思います。例えば以下のような例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// テスト用データを作成する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createTestDatas&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// テスト用データのリスト
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> testDatas = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 10件のデータを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> until &lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testDatas.add(&lt;span style="color:#e6db74">&amp;#34;テスト&lt;/span>&lt;span style="color:#e6db74">$i&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// read-onlyに変換して返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> testDatas.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、どちらかというとこれはJavaのやり方に近いので、まずはこれをベースに、Kotlinらしきコードではどうやって同じことができるかを考えてみたいと思います。&lt;/p>
&lt;h3 id="repeat">repeat
&lt;/h3>&lt;p>まず考えられる方法は、ループの単純化ですね。サイズが10のリストを作りたいということは、ループが10回であることなので、それに相応しい関数を使います。例えば&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html" target="_blank" rel="noopener"
>repeat&lt;/a>がありますね。&lt;code>repeat&lt;/code>を使うと、スコープ内のパラメータとしてインデックスが渡されるので、簡単に&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createTestDatas&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> testDatas = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 10回繰り返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> repeat(&lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testDatas.add(&lt;span style="color:#e6db74">&amp;#34;テスト&lt;/span>&lt;span style="color:#e6db74">$i&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> testDatas.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に考えたいのは、&lt;code>MutableList&lt;/code>を&lt;code>Immutable&lt;/code>に変えることです。テストで使うデータとしては問題ない場合はありますが、変更する必要のないデータをそのまま&lt;code>Mutable&lt;/code>にしておくのはあまり良い選択ではありませんね。なので、データの作成を最初から&lt;code>List&lt;/code>にできる方法を取りたいものです。&lt;/p>
&lt;p>ここでは二つの道があって、最初からサイズを指定した&lt;code>List&lt;/code>を宣言するか、ループの範囲、つまり&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html#range" target="_blank" rel="noopener"
>Range&lt;/a>を指定する方法があります。&lt;/p>
&lt;h3 id="list">List
&lt;/h3>&lt;p>まずはサイズを指定した&lt;code>List&lt;/code>を作る方法からみていきましょう。インスタンスの作成時に、サイズと要素に対してのイニシャライザを引数として渡すことで簡単に指定したサイズ分の要素を作ることができます。例えば、上で紹介したコードは&lt;code>List&lt;/code>を使うことで以下のように変えることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createTestDatasByList&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(&lt;span style="color:#ae81ff">10&lt;/span>) { &lt;span style="color:#e6db74">&amp;#34;テスト&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この方法は、実は先に紹介した方法と根本的に違うものではありません。実装としては、以下のようになっているので、Syntax sugarとして使えるということがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SinceKotlin&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1.1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@kotlin&lt;/span>.&lt;span style="color:#66d9ef">internal&lt;/span>.InlineOnly
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>(size: Int, &lt;span style="color:#66d9ef">init&lt;/span>: (index: Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): List&amp;lt;T&amp;gt; = MutableList(size, &lt;span style="color:#66d9ef">init&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SinceKotlin&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;1.1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@kotlin&lt;/span>.&lt;span style="color:#66d9ef">internal&lt;/span>.InlineOnly
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">MutableList&lt;/span>(size: Int, &lt;span style="color:#66d9ef">init&lt;/span>: (index: Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> list = ArrayList&amp;lt;T&amp;gt;(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(size) { index &lt;span style="color:#f92672">-&amp;gt;&lt;/span> list.add(&lt;span style="color:#66d9ef">init&lt;/span>(index)) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも&lt;code>List&lt;/code>を使う場合は、&lt;code>itnit&lt;/code>としてどんな関数を渡すかによって、&lt;code>step&lt;/code>の設定などができるのも便利ですね。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#ae81ff">5&lt;/span>) { &lt;span style="color:#e6db74">&amp;#34;Test&lt;/span>&lt;span style="color:#e6db74">${ it * 2 }&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [Test0, Test2, Test4, Test6, Test8]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#ae81ff">5&lt;/span>) { (&lt;span style="color:#66d9ef">it&lt;/span> * &lt;span style="color:#ae81ff">2&lt;/span>).let { index &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$index&lt;/span>&lt;span style="color:#e6db74"> は偶数&amp;#34;&lt;/span> } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// [0 は偶数, 2 は偶数, 4 は偶数, 6 は偶数, 8 は偶数]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、結果的に作られる&lt;code>List&lt;/code>のインスタンスは&lt;code>MutableList&lt;/code>なので、生成したデータをread-onlyにしたい場合はまたこれを&lt;code>toList()&lt;/code>などで変換する必要があるという問題があります。&lt;/p>
&lt;h3 id="range">Range
&lt;/h3>&lt;p>では、もう一つの方法をまた試してみましょう。Kotlinでは数字の範囲を指定することだけで簡単に&lt;code>Range&lt;/code>オブジェクトを作成することができます。&lt;code>Range&lt;/code>を使う場合、上記のコードは以下のように変えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Rangeを使ってテストデータを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">createTestDatasByRange&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ae81ff">0.&lt;/span>.&lt;span style="color:#ae81ff">10&lt;/span>).map { &lt;span style="color:#e6db74">&amp;#34;テスト%it&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>List&lt;/code>の時とは違って、&lt;code>Range&lt;/code>には&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-int-range" target="_blank" rel="noopener"
>IntRange&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-long-range" target="_blank" rel="noopener"
>LongRange&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-char-range" target="_blank" rel="noopener"
>CharRange&lt;/a>などがあり、引数の数字や文字を調整することで簡単にアレンジができるということも良いです。&lt;/p>
&lt;p>また、一般的に性能は&lt;code>List&lt;/code>より&lt;code>Range&lt;/code>の方が良いようです。以下のようなコードでベンチマークした際、大抵&lt;code>Range&lt;/code>の方が&lt;code>List&lt;/code>の倍ぐらい早いのを確認できました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> kotlin.system.measureTimeMillis
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> name: String, &lt;span style="color:#66d9ef">val&lt;/span> Num: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark { list() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark { range() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">benchmark&lt;/span>(function: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(measureTimeMillis { function() })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">list&lt;/span>() =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(&lt;span style="color:#ae81ff">200000&lt;/span>) { Person(&lt;span style="color:#e6db74">&amp;#34;person&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">range&lt;/span>(): List&amp;lt;Person&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ae81ff">0.&lt;/span>.&lt;span style="color:#ae81ff">200000&lt;/span>).map { Person(&lt;span style="color:#e6db74">&amp;#34;person&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一つ気にしなくてはならないのは、&lt;code>Range&lt;/code>の場合は基本的に値が1づつ増加することになっているので、&lt;code>for&lt;/code>や&lt;code>List&lt;/code>のような&lt;code>step&lt;/code>の条件が使えません。なので場合によってどちらを使うかは考える必要があります。&lt;/p>
&lt;h2 id="check">Check
&lt;/h2>&lt;p>Validationなどで、パラメータの値を確認しなければならない場合があります。Kotlinでは&lt;code>Nullable&lt;/code>オブジェクトとそうでないオブジェクトが分けられているので、Javaと違って引数に&lt;code>null&lt;/code>が渡される場合はコンパイルエラーとなりますが、ビジネスロジックによってはそれ以外のことをチェックする必要もあり、自前のチェックをコードで書くしかないです。&lt;/p>
&lt;p>まず、お馴染みのJavaのやり方を踏襲してみると、以下のようなコードを書くことができるでしょう。関数の引数と、その戻り値のチェックが含まれている例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: String): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (parameter.isBlank()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;文字列が空です&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = someRepository.find(parameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;結果がnullです&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで少し違う言語の例をみていきたいと思います。Kotlinとよく似ていると言われているSwiftの場合、ここで&lt;a class="link" href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#grammar_if-statement" target="_blank" rel="noopener"
>Guard Statement&lt;/a>を使うのが一般的のようです。チェックのための表現が存在することで、ビジネスロジックとチェックが分離されるのが良いですね。Swiftをあまり触ったことがないので良い例にはなっていないかもしれませんが、イメージ的には以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: String) &lt;span style="color:#66d9ef">throws&lt;/span> -&amp;gt; String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#f92672">!&lt;/span>parameter.isEmpty &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ValidationError.invalidArgument
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">guard&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> result = someRepository.find(parameter) &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ValidationError.notFound
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じく、Kotlinでもチェックのための表現とビジネスロジックが分離できれば、コードの意味がより明確になるはずです。Kotlinではどうやってそれを実現できるのでしょうか。例えば以下のようなことを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: String?): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> checkedParameter = requireNotNull(parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;文字列がnullです&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = someRepository.find(checkedParameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> checkNotNull(result) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;結果がnullです&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require-not-null.html" target="_blank" rel="noopener"
>requireNotNull&lt;/a>は、渡された引数が&lt;code>null&lt;/code>である場合は&lt;code>IllegalArgumentException&lt;/code>を投げ、そうでない場合は引数を&lt;code>non-null&lt;/code>タイプとして返します、明確に&lt;code>null&lt;/code>チェックをしていることが解るだけでなく、以降チェックがいらないので便利です。また、&lt;code>lazy message&lt;/code>として&lt;code>IllegalArgumentException&lt;/code>が発生した時のメッセージを指定できるのも良いですね。&lt;/p>
&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html" target="_blank" rel="noopener"
>checkNotNull&lt;/a>の場合も機能的には&lt;code>requireNotNull&lt;/code>と変わらないですが、&lt;code>null&lt;/code>の場合に投げる例外が&lt;code>IllegalStateException&lt;/code>となります。なので、用途に合わせてこの二つを分けて使えますね。&lt;/p>
&lt;p>他に使えるものとしては&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html" target="_blank" rel="noopener"
>require&lt;/a>があります。こちらは条件式を渡すことで、&lt;code>null&lt;/code>チェック以外のこともできます。なので、以下のコードのように、&lt;code>Int&lt;/code>型のデータに対して範囲をチェックするということもできるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> require(parameter &amp;gt; &lt;span style="color:#ae81ff">100&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$parameterは大きすぎます&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、&lt;a class="link" href="https://kotlinlang.org/docs/null-safety.html#elvis-operator" target="_blank" rel="noopener"
>Elvis operator&lt;/a>を使う方法もありますね。この場合は、&lt;code>null&lt;/code>の場合にただ例外を投げるだけでなく、代替となる処理を書くことができますので色々と活用できる余地があります。例えば以下のようなことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(parameter: String?): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> checkedParameter = parameter &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> result = someRepository.find(checkedParameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result &lt;span style="color:#f92672">?:&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> CustomException(&lt;span style="color:#e6db74">&amp;#34;結果がnullです&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="listの分割">Listの分割
&lt;/h2>&lt;p>とある条件と一致するデータをListから抽出したい場合は、&lt;code>filter&lt;/code>のようなoperationを使うことでできます。しかし、条件が二つだとどうすればいいでしょうか。正確には、一つのリストに対して、指定した条件に一致する要素とそうでない要素の二つのリストに分離したい場合です。&lt;/p>
&lt;p>こういう場合はとりあえず下記のように2回ループさせる方法があると思いますが、これはあまり効率がよくないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> origin = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 奇数を抽出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> odd = origin.filter { &lt;span style="color:#66d9ef">it&lt;/span> % &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 偶数を抽出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> even = origin.filter { &lt;span style="color:#66d9ef">it&lt;/span> % &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ループを減らすためには、あらかじめ宣言したリストに対してループの中で分岐処理を行うという方法があるでしょう。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> origin = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 奇数と偶数のリストを宣言しておく
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> odd = mutableListOf&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> even = mutableListOf&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ループ処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>origin.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">it&lt;/span> % &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd.add(&lt;span style="color:#66d9ef">it&lt;/span>) &lt;span style="color:#75715e">// 奇数のリストに追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even.add(&lt;span style="color:#66d9ef">it&lt;/span>) &lt;span style="color:#75715e">// 偶数のリストに追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>幸い、この状況にぴったりな方法をKotlinのスタンダードライブラリが提供しています。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html" target="_blank" rel="noopener"
>partition&lt;/a>というoperationです。このopreationを使うと、元のリストの要素を条件に一致するものとそうでないもので分割してくれます。&lt;/p>
&lt;p>また、&lt;code>partition&lt;/code>戻り値は&lt;code>Pair&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;/code>なので、&lt;a class="link" href="https://kotlinlang.org/docs/destructuring-declarations.html" target="_blank" rel="noopener"
>destructuring-declaration&lt;/a>と組み合わせることでかなり短いコードになります。実際のコードは以下のようになるりますが、かなりスマートですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> origin = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>odd, even) = origin.partition { &lt;span style="color:#66d9ef">it&lt;/span> % &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> } &lt;span style="color:#75715e">// 条件に一致するものと一致しないものでリストを分離
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>Kotlinは便利ではありますが、言語自体が提供する便利さ（機能）が多いゆえに、APIの使い方を正しく活用できるかどうかでコードのクォリティが左右される部分が他の言語と比べ多いような気がしています。さらにバージョンアップも早く、次々と機能が追加されるのでキャッチアップも大事ですね。&lt;/p>
&lt;p>でも確かに一つづつKotlinでできることを工夫するうちに、色々とできることが増えていく気もしていますね。研究すればするほど力になる言語を使うということは嬉しいことです。ということで、これからもKotlinで書いてみたシリーズは続きます。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Sequenceは常にいいか</title><link>https://retheviper.github.io/posts/kotlin-collection-and-sequence/</link><pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-collection-and-sequence/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Sequenceは常にいいか" />&lt;p>とある処理を書く方法が色々ある場合は、どれを選んだ方がもっとも良いかと悩ましくなります。こういう場合は、コードの読みやすさやコードの長さ、予想される問題のようなさまざまな観点からそれぞれの方式を比較してどれを選ぶか判断することになりますね。ただ、このような観点から判断するのは多くの場合「書き方が全く違う」場合に有効であって、そもそも似たようなコードを書くことになる場合は他の観点からも考える必要があります。ほんの少しだけ違うから、見た目だけでは違いがわからない場合。こういう時はそのAPIの内部、メカニズムからちゃんと考えて選ぶ必要がありますね。&lt;/p>
&lt;p>そういう意味で、今回はKotlinのCollectionの処理に使える方法の二つ、「Collectionのoperation直接使う」場合と「Sequenceに変換してから処理する」場合の違いに関して述べたいと思います。&lt;/p>
&lt;h2 id="処理方式の違い">処理方式の違い
&lt;/h2>&lt;p>Javaでは、Collectionの要素を持って処理をする方法は色々とありますが、大きく分けて1.8以前の方法(&lt;code>for&lt;/code>や&lt;code>while&lt;/code>などを利用したループ)と1.8以降の方法(&lt;code>Stream&lt;/code>を使った方法)があると言ってもいいのではないかと思います。この二つの方法はそもそもベースとなっているパラダイムそのものが違うので、コードを書くスタイルから大きく違います。例えば同じ処理をしたい場合でも、以下のコードで確認できるように、見た目が完全に違います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// forループの場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterEven&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Integer i : list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">add&lt;/span>(i.&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> 3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Streamを使う場合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">filterEvenStream&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">filter&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">map&lt;/span>(i &lt;span style="color:#f92672">-&amp;gt;&lt;/span> i.&lt;span style="color:#a6e22e">toString&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">limit&lt;/span>(3)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Streamを使った処理の場合はoperationを積み重ねて行く形をしていますが、これは現代の関数型プログラミングに対応している言語ならどれも持っているAPIといえます。例えばKotlin, 公式的には呼び方が色々あるようですが、一部では&lt;code>Functional function&lt;/code>という名で呼ばれているようで、今回はこの操作方式、Functional functionについて述べたいと思います。&lt;/p>
&lt;p>KotlinではCollectionでもこのようなopreationがあり、Kotlin版のStreamとも言える&lt;a class="link" href="https://kotlinlang.org/docs/sequences.html" target="_blank" rel="noopener"
>Sequence&lt;/a>でも同様の操作できるようになっています。また、JavaのStreamをそのまま使うこともできるので、Functional functionを使った処理は三つがあるといえますね。それぞれの使い方もあまり変わりません。なので以下のようなコードで同じ処理ができますが、それが帰って悩ましくなるところでもあります。「どれを使ったらいい？」とですね。例えば同じ処理をしたい場合でも、Kotlinでは以下のように色々な方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Collectionの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">filterEven&lt;/span>(): List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>).filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }.map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }.take(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Sequenceを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">filterEvenSequence&lt;/span>: List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>).asSequence().filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }.map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }.take(&lt;span style="color:#ae81ff">3&lt;/span>).toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// JavaのStream APIを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">filterEvenStream&lt;/span>(): List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>).stream().filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }.map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }.limit(&lt;span style="color:#ae81ff">3&lt;/span>).collect(&lt;span style="color:#a6e22e">Collectors&lt;/span>.toList())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは見た目ではあまり違いがわからないですね。処理やロジックが大きく変わる訳でもありません。使い方があまり変わらなく、結果としても同じようなものを期待できるとしたら、やはり次に気にすべきは「性能」ではないかと思います。特にCollectionよりもSequenceの方がより性能がいいという話もありますので、それならなるべくSequenceを使った方が絶対良いはずですね。&lt;/p>
&lt;p>しかし、それを事実と受け止めるとしたら、いくつかの疑問が残ります。常にSequenceの方が性能で有利だとしたら、なぜCollectionからFunctional functionを呼び出す時は内部でSequenceに変換するようにするのでなく、わざわざ&lt;code>asSequence()&lt;/code>を呼び出して明示的な変換をさせるのでしょうか？もしくはなぜCollectionでもFunctional functionを呼び出せるようにしているのでしょうか？これはつまり、SequenceがCollectionよりも性能がよくなるのは「とある条件下に限る」ということではないでしょうか。なので、今回は主に性能の観点から、CollectionとSequenceの違いについて述べましょう。&lt;/p>
&lt;h3 id="lazy-evaluation">Lazy evaluation
&lt;/h3>&lt;p>KotlinのSequenceは、元々JavaのStreamと同じ名前になる予定だったそうです。これはただの偶然ではなく、実際の処理もStreamに似ているからです。何が似ているかというと、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1" target="_blank" rel="noopener"
>Lazy evaluation&lt;/a>という概念です。これは簡単に言いますと、「なるべく処理を遅延させる = 必要とされるまでは処理をしない」ということですね。そして多くの場合、Sequenceを使うとこのLazy evaluationのおかげで性能がよくなるという話があります。これはつまり、Sequenceは処理を遅延することでCollectionより良い性能を期待できる、ということになるでしょう。&lt;/p>
&lt;p>しかし、単純に処理を遅延させることががなぜ性能を向上させる事になるのか、すぐに納得は行きません。まず、ループ処理の中で「必要によって処理をするかどうかを決定する」という概念がピンと来ないですね。我々が認識しているループ処理とは、対象となるデータモデルの全要素を巡回しながら処理をするという意味ですので。&lt;/p>
&lt;p>だからSequenceを使った方が性能がよくなると言っても、パフォーマンスはさまざまな要素によって劣化も向上もするものなので、その話だけを信じて全ての処理をSequenceに変えるということは危ないです。そもそもSequenceがそんなに良いものであれば、全てのIterableなオブジェクトをなぜSequenceとして処理しないか、という疑問も湧いてきますね。なので、まずはCollectionとSequenceでFunctional functionがどう違うか、コードどそれを実行した結果で説明したいと思います。&lt;/p>
&lt;h4 id="eager-evaluationのcollection">Eager evaluationのCollection
&lt;/h4>&lt;p>CollectionでのFunctional functionは、Eager evalutionと言われています。これはLazy evaluationの逆で、必要とされてなくてもとりあえず処理を行っておくということです。こうする場合期待できることは、メモリ上にすでに処理の結果が残っていて、複数回呼ばれた場合はそのキャッシュを使うことができるということですね。&lt;/p>
&lt;p>Eager evaluationだと、Functional functionが呼ばれるたび、その全要素に対しての処理をまず行うことになります。例えば、以下のような処理を書いたとしましょう。&lt;code>onEach()&lt;/code>は処理の流れを視覚化するためのものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;Found even: &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;Now &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74"> is String&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .take(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74"> has taken&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを実行した結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">2&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">4&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">6&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">8&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">10&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> has taken
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、CollectionでのFunctional functionでは以下のような順で処理します。&lt;/p>
&lt;ol>
&lt;li>Listからfilterのpredicateに当てはまる要素を探し、その結果でListを作る&lt;/li>
&lt;li>filterされたListの要素をmapし、その結果でListを作る&lt;/li>
&lt;li>mapされたListの要素からtakeする&lt;/li>
&lt;/ol>
&lt;p>これを絵で表現すると以下の通りです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing.webp"
width="990"
height="377"
srcset="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing_hua501a853c8fda1d2f914f1da85006fa4_22782_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing_hua501a853c8fda1d2f914f1da85006fa4_22782_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Kotlin List Processing"
class="gallery-image"
data-flex-grow="262"
data-flex-basis="630px"
>
&lt;em>出典：Kotlin公式ドキュメント - &lt;a class="link" href="https://kotlinlang.org/docs/sequences.html#iterable" target="_blank" rel="noopener"
>Sequences&lt;/a>&lt;/em>&lt;/p>
&lt;h5 id="collectionのopreation">Collectionのopreation
&lt;/h5>&lt;p>Collectionでの処理は上記の通りですが、実装としてはどうでしょうか。ここではCollectionでの&lt;code>map()&lt;/code>のコードを見ていきたいと思います。コードとしては以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">R&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Iterable&lt;/span>&amp;lt;T&amp;gt;.map(transform: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): List&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> mapTo(ArrayList&amp;lt;R&amp;gt;(collectionSizeOrDefault(&lt;span style="color:#ae81ff">10&lt;/span>)), transform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mapTo()&lt;/code>という関数に、元のCollectionのサイズで新しくインスタンスを作成した&lt;code>ArrayList&lt;/code>とLambdaを渡しています。ちなみに&lt;code>collectionSizeOrDefault()&lt;/code>という関数は、以下のような実装となっています。Collectionである場合はそのサイズを、そうでない場合（Sequenceなど）はデフォルトとして10のサイズを持つListになるということがわかりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Iterable&lt;/span>&amp;lt;T&amp;gt;.collectionSizeOrDefault(default: Int): Int = &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#66d9ef">is&lt;/span> Collection&amp;lt;*&amp;gt;) &lt;span style="color:#66d9ef">this&lt;/span>.size &lt;span style="color:#66d9ef">else&lt;/span> default
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>mapTo()&lt;/code>という関数の中では、元のCollectionをループしながら新しいListにLambdaの実行結果を追加するという実装となっています。実際のコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">R&lt;/span>, &lt;span style="color:#a6e22e">C&lt;/span> : &lt;span style="color:#a6e22e">MutableCollection&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#a6e22e">Iterable&lt;/span>&amp;lt;T&amp;gt;.mapTo(destination: C, transform: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): C {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (item &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destination.add(transform(item))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、一つのFunctional functionが呼ばれるたびにListに対するループが発生し、さらに新しいListを作ることになるということです。なので上記のサンプルコードの場合だとループは6回、Listの作成は4回であるといえます。&lt;code>onEach()&lt;/code>を除外するとしてもループは3回なので、かなり多い印象ですね。&lt;/p>
&lt;p>ここで考えられるものは、「Sequenceの方が性能がいい」という話は、Sequenceを使った場合にこのようなループ回数やListの作成を減らせられるということになるのではないか、ということですね。Sequenceではどんな処理をしていて、実際にこのようなループやListを作る回数などを減らしているということでしょうか。同じ処理を書いた場合にSequenceではどのようなことが起きるかを見ていきましょう。&lt;/p>
&lt;h4 id="lazy-evaluationのsequence">Lazy evaluationのSequence
&lt;/h4>&lt;p>Collectionは、&lt;code>asSequence()&lt;/code>を呼び出すことで簡単にSequenceによる処理に変換することができます。ただ、このコードを実際に走らせるためにはJavaのStreamと同じく終端処理が必要となるのがポイントです。これも「必要とされるまでは実際の処理を行わない」Lazy evaluationの特徴といえます。例えば以下のようなコードを書いたとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#ae81ff">7&lt;/span>, &lt;span style="color:#ae81ff">8&lt;/span>, &lt;span style="color:#ae81ff">9&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .asSequence() &lt;span style="color:#75715e">// Sequenceに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .filter { &lt;span style="color:#66d9ef">it&lt;/span> %&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;Found even: &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#66d9ef">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;Now &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74"> is String&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .take(&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74"> has taken&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList() &lt;span style="color:#75715e">// Collectionに再変換（終端処理で処理を走らせる）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを実行した結果は以下の通りです。Collectionの場合と結果は同じであるものの、処理の順番が変わっていることを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">2&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">4&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#ae81ff">6&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> has taken
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、そもそも8と10に対しての処理は行われてないということです。これはCollectionで全要素に対して一つのFunctional functionの処理が終わったあと、次のFunctional functionが実行される構造に対して、Sequenceは一つの要素に対しての全ての処理が終わったあと次の要素に対して同じ処理を繰り返しているということです。言葉で表現すると複雑ですが、以下のような順になっているということです。&lt;/p>
&lt;ol>
&lt;li>Listの要素にfilterを当てる&lt;/li>
&lt;li>要素がfilterのpredicateに当てはまるものなら次の処理に移行する&lt;/li>
&lt;li>filterされた要素をmapする&lt;/li>
&lt;li>mapされた要素をtakeする&lt;/li>
&lt;li>次の要素に対して同じ処理を繰り返す&lt;/li>
&lt;/ol>
&lt;p>これを絵で表現すると以下の通りです。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing.webp"
width="990"
height="427"
srcset="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing_hufb4d6f801fd07781c1a4cd82f37f6652_22704_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing_hufb4d6f801fd07781c1a4cd82f37f6652_22704_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Kotlin Sequence Processing"
class="gallery-image"
data-flex-grow="231"
data-flex-basis="556px"
>
&lt;em>出典：Kotlin公式ドキュメント - &lt;a class="link" href="https://kotlinlang.org/docs/sequences.html#sequence" target="_blank" rel="noopener"
>Sequences&lt;/a>&lt;/em>&lt;/p>
&lt;p>処理の順番や仕組みが違うので、Collectionの時とは実装もかなり違うだろうと予想ができますね。では、こちらの実装を見ていきましょう。&lt;/p>
&lt;h5 id="sequenceでのoperation">Sequenceでのoperation
&lt;/h5>&lt;p>Collectionと同じく、Sequenceの&lt;code>map()&lt;/code>の実装を覗いてみましょう。先程のコードでSequenceの&lt;code>map()&lt;/code>は中間処理であり、新しいCollectionを作り出すわけではないということはわかりました。実装を見ると、以下のようになっていて、処理結果が反映されたSequenceを返しているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">R&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.map(transform: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R): Sequence&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> TransformingSequence(&lt;span style="color:#66d9ef">this&lt;/span>, transform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、内部で&lt;code>TransformingSequence&lt;/code>という新しいSequenceのインスタンスを作成しているのがわかりますね。このクラスの実装は以下の通りです。ここでループごとにLambdaの実行が行われていますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TransformingSequence&lt;/span>&amp;lt;T, R&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constructor&lt;/span>(&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> sequence: Sequence&amp;lt;T&amp;gt;, &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> transformer: (T) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> R) : Sequence&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">iterator&lt;/span>(): Iterator&amp;lt;R&amp;gt; = &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">Iterator&lt;/span>&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> iterator = sequence.iterator()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">next&lt;/span>(): R {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> transformer(iterator.next())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">hasNext&lt;/span>(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> iterator.hasNext()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">E&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">flatten&lt;/span>(iterator: (R) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Iterator&amp;lt;E&amp;gt;): Sequence&amp;lt;E&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> FlatteningSequence&amp;lt;T, R, E&amp;gt;(sequence, transformer, iterator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のコードの実行結果と実装でわかるように、Sequenceを使う場合は一つの要素を単位として処理を行っていくので、CollectionでFunctional functionを使う場合に発生し得る不要な処理(毎回Listを生成する、前要素に対してmapを行うなど)を減らせると期待できます。なので元のCollectionが大きい場合やoperationが多い場合はSequenceの方がより良いように見えます。&lt;/p>
&lt;p>ただ、性能の観点で考えると、CollectionとSequenceの違いはもう一つ考慮すべきところがあります。それはデータ構造の違いです。&lt;/p>
&lt;h2 id="stateless">Stateless
&lt;/h2>&lt;p>JavaのStreamでもそうでしたが、Sequenceは状態(State)を持たないのが特徴です。ここで状態を持たないということは、持っている要素の数や順番などに対しての情報がないということを意味します。なぜかというと、SequenceがIteratorに基づいているものだからです。そしてそれが原因で、処理の種類によってCollectionよりも性能は劣る可能性もまたあります。&lt;/p>
&lt;p>先に使っていたサンプルコードを持って考えてみましょう。サンプルコードでは、Sequenceの終端処理としてListを返すために&lt;code>toList()&lt;/code>を呼び出していました。これは、「状態を持たない」ものから「状態を持つ」ものに変換することですね。簡単なやり方としては、MutableなListを作って、全要素を一つづつ&lt;code>add()&lt;/code>していく方法があるでしょう。実際はどうでしょうか？まずは&lt;code>toList()&lt;/code>のコードをみてみましょう。以下がその実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.toList(): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.toMutableList().optimizeReadOnlyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まずMutableなListに変換して、さらに読み込み専用（Immutable）のListに変換しているように見えます。さらにMutable Listに変えているところの実装をみてみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.toMutableList(): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> toCollection(ArrayList&amp;lt;T&amp;gt;())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ArrayListのインスタンスを作って、それを&lt;code>toCollection()&lt;/code>に渡していますね。ここで&lt;code>toCollection()&lt;/code>はSequenceをCollectionに帰る時の共通処理で、型を指定にするため引数にListを渡しているようです。さらに&lt;code>toCollection()&lt;/code>の実装をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">C&lt;/span> : &lt;span style="color:#a6e22e">MutableCollection&lt;/span>&amp;lt;&lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.toCollection(destination: C): C {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (item &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destination.add(item)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここまでたどり着いてわかったのは、やはりSequenceの要素を一つ一つListの中に入れているということですね。ただ、単純な処理ではありますが、ここでは「Listに要素を足していく」ということ自体に注目する必要があります。&lt;/p>
&lt;p>先に述べた通り、Sequenceは自分が持つ要素の数をわからないので、Listのインスタンスを作る時はサイズを「仮定」して処理するしかないです。そして基本的にMutableなListでは、現在のサイズよりも多くの要素を追加する必要がある時、内部のArrayより大きいサイズのArrayを新しく作り、そこに要素をコピーしていくことを繰り返します。そしてこれを全要素が揃うまで繰り返していきますね。ということは、Sequenceの要素が多ければ多いほどArrayのインタンス作成とコピーが多くなるということになります。&lt;/p>
&lt;p>そしてコピーが全部終わった場合、実際の要素数よりArrayのサイズが大きい場合もありますね。その場合、メモリを無駄に使うだけでなく、実際のサイズもわからなくなるので、サイズを要素数に合わせて再調整する必要があります。&lt;code>toList()&lt;/code>の実装で最後に&lt;code>optimizeReadOnlyList()&lt;/code>を呼び出しているのは、おそらくその理由でしょう。&lt;code>optimizeReadOnlyList()&lt;/code>の実装は以下の通りです。やはりサイズを再調整していますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">internal&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">List&lt;/span>&amp;lt;T&amp;gt;.optimizeReadOnlyList() = &lt;span style="color:#66d9ef">when&lt;/span> (size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> listOf(&lt;span style="color:#66d9ef">this&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでわかるように、Sequenceを使って処理したあと、Collectionにまとめるなら要素数が多ければ多いほどCollectionよりも性能が劣化する可能性は確かに存在します。CollectionでFunctional functionを呼び出す際にListを作るとしても、すでに要素数はわかっているので、Listのサイズが合わないためのArrayの生成とコピーの処理は不要ですね。なのでCollectionとSequenceのどちらを選ぶかの問題はFunctional functionを呼び出す回数や処理の種類だけでなく、要素の数まで考える必要がありそうです。&lt;/p>
&lt;p>ただ、要素数が多い場合でも、終端処理の種類によってはSequenceの方が有利になる可能性もなくはないです。例えば&lt;code>forEach()&lt;/code>や&lt;code>onEach()&lt;/code>など、個別の要素に対して処理を行うだけの場合は依然としてSequenceの方で良い性能を期待できるでしょう。&lt;/p>
&lt;p>要素数が多い場合に性能に影響する処理としてもう一つ考えられるのは、Sequenceを使う場合でも呼び出せるFunctional functionの中で明らかに「状態を必要とする」ものがあるということです。例えば以下の一覧のようなものです。&lt;/p>
&lt;ul>
&lt;li>どんな要素が含まれているかわかる必要がある
&lt;ul>
&lt;li>&lt;code>distinct()&lt;/code>&lt;/li>
&lt;li>&lt;code>average()&lt;/code>&lt;/li>
&lt;li>&lt;code>min()&lt;/code>&lt;/li>
&lt;li>&lt;code>max()&lt;/code>&lt;/li>
&lt;li>&lt;code>take()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要素の順番をわかる必要がある
&lt;ul>
&lt;li>&lt;code>indexOf()&lt;/code>&lt;/li>
&lt;li>&lt;code>mapIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>flatMapIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>elementAt()&lt;/code>&lt;/li>
&lt;li>&lt;code>filterIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>foldIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>forEachIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>reduceIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>scanIndexed()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>これらの処理をSequenceではどうしているのでしょうか。まずはその実装を覗いてみる必要がありそうですね。ここでは&lt;code>sort()&lt;/code>の方をみていきたいと思います。実装は以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span> : &lt;span style="color:#a6e22e">Comparable&lt;/span>&amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt;.sorted(): Sequence&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">: &lt;/span>&lt;span style="color:#a6e22e">Sequence&lt;/span>&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">iterator&lt;/span>(): Iterator&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> sortedList = &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#a6e22e">@sorted&lt;/span>.toMutableList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sortedList.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sortedList.iterator()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>単純ですが、Sequenceを一度Listに変換してsortした後、またSequenceに変えて返していますね。ここでListに変えるために呼び出している関数は&lt;code>toMutableList()&lt;/code>なので、結局&lt;code>toList()&lt;/code>を呼び出す場合と同じようなことが起きるということです。なので、状態を必要とする操作の場合は要素数が多ければ多いほど性能はCollectionより劣化しやすい、ということがわかります。&lt;/p>
&lt;p>ただ、逆に状態が必要にならない場合は、Collectionと違って中間結果のListを作成しなくなるので、依然としてSequenceが良い性能を見せるだろうと思えます。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>だいぶ話が長くなりましたが、性能の観点でどれを選ぶべきか、という話の結論としては、「どんな処理をするか」によるということになりますね。簡単に整理すると、以下のようになるかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>条件&lt;/th>
&lt;th>おすすめ&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>処理が複雑&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>処理した結果としてCollectionが必要&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ループするだけ&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>処理に状態が必要&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>要素数が多い&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>要素数が少ない&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>もちろんこれらの条件が複数ある場合も十分考えられるので、必要な処理が何かをよく考えてどちらを使うかを慎重に考える必要がありそうです。多くの場合とりあえずCollectionを使うという方針だとしても特に問題はなさそうな気はしますが…&lt;/p>
&lt;p>この度はKotlinにおいてのSequenceを紹介しましたが、実はイラストを含めてわかりやすく説明している&lt;a class="link" href="https://typealias.com/guides/when-to-use-sequences" target="_blank" rel="noopener"
>いつSequenceを使うべきか&lt;/a>という良い記事があるので、Sequenceについてより深く理解したい方にはこちらを参考した方が良さそうな気がします。&lt;/p>
&lt;p>また、ここではKotlinのAPIでの処理のみを紹介しましたが、JavaのStreamを使う場合、Sequenceと違って&lt;code>parallelStream()&lt;/code>を呼び出すことができます。なので並列で処理しても良い場合には、CollectionとSequenceのみでなく、Streamを使うことを検討するのもありですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinのString実装を覗く〜whitespace編〜</title><link>https://retheviper.github.io/posts/kotlin-whitespace/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-whitespace/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinのString実装を覗く〜whitespace編〜" />&lt;p>Kotlin(JVM)は、コンパイルした結果がJVMのバイトコードになります。Javaで書かれたライブラリをそのままKotlinで利用できるのはそのためですね。これはKotliのライブラリに対しても同じなので、スタンダードライブラリを覗くとJavaの機能に依存しているところも少なくないです。&lt;/p>
&lt;p>ただ、KotlinがコンパイルしたらJVMのバイトコードになるということは、単純にKotlinが「書き方が違うJava」であるという意味ではないです。これはKotlinがJavaと言語スペックが違うという点もありますが、JVMだけでなく、JavaScriptやネイティブコードにコンパイルされることも想定してデザインされているので、スタンダードライブラリスタンダードライブラリはプラットフォームに合わせて違う実装になっています。そしてJVMだとしてもJavaのAPIをそのまま利用しているわけではありません。&lt;/p>
&lt;p>Kotlinのこういう構造は、内部のソースコードを見るとはっきりします。スタンダードライブラリの一部メソッドやクラスには&lt;code>expect&lt;/code>と&lt;code>actual&lt;/code>というキーワードが使われていますが、これらはJavaのinheritanceと似ているようなものです。Javaでは&lt;code>interface&lt;/code>で定義したメソッドを、それを継承したクラスで&lt;code>override&lt;/code>で実装して使うことになりますね。同じく、Kotlinでは&lt;code>expect&lt;/code>として定義された機能をプラットフォームに合わせて&lt;code>actual&lt;/code>で実装しているわけです。&lt;/p>
&lt;p>また、KotlinのスタンダードライブラリはJavaと一見同じようなものに見えるとしても、実際は違うケースもあります。&lt;code>actual&lt;/code>によって実装されたコードがKotlinに合わせて、書かれているからですね。なので、Kotlinのスタンダードライブラリに対しては「Javaと同じだろう」という認識をするのは危険な可能性もあります。&lt;/p>
&lt;p>今回はそういうことで、文字列のwhitespaceに関しての機能を、スタンダードライブラリのソースコードを中心に見ていきたいと思います。&lt;/p>
&lt;h2 id="whitespaceの判定">whitespaceの判定
&lt;/h2>&lt;p>とある文字列が意味のある(有効な)データであるかどうかを判定する方法の一つは、その文字列がただの空白であるかどうかを判定することです。つまり、そもそもなんのデータもなかったり、whitespaceだけでないかというチェックをするということですね。&lt;/p>
&lt;p>こういう場合の判定はKotlinのスタンダードライブラリで簡単に行うことができます。KotlinではStringのメソッドとして基本的に以下の二つを提供しています。&lt;/p>
&lt;ul>
&lt;li>&lt;code>isEmpty()&lt;/code>&lt;/li>
&lt;li>&lt;code>isBlank()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Java 11以降でもこれらと同名のメソッドが存在しているので、一見そのままの感覚で良さそうにも見えます。しかし、Kotlinではこれらのメソッドがまず&lt;code>kotlin.text.Strings&lt;/code>から呼ばれるものとされています。JavaのAPIをそのまま使っているわけではないので、処理も違う可能性があるという推測ができますね。&lt;/p>
&lt;p>ここで前者の場合、文字列が単純になんのデータも持ってないかどうかに対する判定をおこないます。実際のソースコードを見ると、文字列の長さだけをチェックしているのを確認できます。&lt;/p>
&lt;p>ちなみにJavaでは&lt;code>String&lt;/code>は&lt;code>CharSequence&lt;/code>を継承していますが、Kotlinとしてもライブラリは違えどそういう継承関係は一緒です。なので、Kotlinでは&lt;code>String&lt;/code>のメンバーでありながらも&lt;code>CharSequence&lt;/code>の関数として書かれています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CharSequence&lt;/span>.isEmpty(): Boolean = length &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>後者の場合は、文字列にwhitespaceまで含めているのかを判定します。以下のコードを見ると、何をやっているかが明確でしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">actual&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CharSequence&lt;/span>.isBlank(): Boolean = length &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> indices.all { &lt;span style="color:#66d9ef">this&lt;/span>[&lt;span style="color:#66d9ef">it&lt;/span>].isWhitespace() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>isBlank()&lt;/code>で呼び出している&lt;code>isWhitespace()&lt;/code>は、以下のような実装となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">actual&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Char&lt;/span>.isWhitespace(): Boolean = &lt;span style="color:#a6e22e">Character&lt;/span>.isWhitespace(&lt;span style="color:#66d9ef">this&lt;/span>) &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#a6e22e">Character&lt;/span>.isSpaceChar(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの&lt;code>Char.isWhitespace()&lt;/code>は最終的に&lt;code>Character.isWhitespace()&lt;/code>と&lt;code>Character.isSpaceChar()&lt;/code>を使って判定することになります。前者の場合はUnicodeのwhitespaceに当てはまるか、後者の場合はUnicodeのspace(改行コードなど)に当てはまるかを判定するJavaのAPIです。ここでわかるように、特集なケースでなければなるべく&lt;code>isEmpty()&lt;/code>を使った方が文字列をチェックする時に良いでしょう。&lt;/p>
&lt;h2 id="whitespaceの削除">whitespaceの削除
&lt;/h2>&lt;p>文字列が単純に意味のあるデータを持っているかどうかを判定するには、前述通り&lt;code>isEmpty()&lt;/code>を使うと良いですが、文字列にwhitespaceだけでなく、意味のあるデータも混在する場合もありますね。こういう時は前後のwhitespaceを取り除きたくなります。&lt;/p>
&lt;p>Javaでは、文字列の前後のwhitespaceを消去する方法として&lt;code>trim()&lt;/code>と&lt;code>strip()&lt;/code>がありました。前者は昔ながらのもので、全角のwhitespaceを検知できなく、性能の問題もあるのでJava 11以降は後者を使うことが推奨されています。&lt;/p>
&lt;p>ただ、Kotlinの場合は少し都合が違います。Kotlinでは基本的に&lt;code>trim()&lt;/code>だけを使うことになります。まずは&lt;code>trim()&lt;/code>の実装をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>.trim(): String = (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> CharSequence).trim().toString()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まず&lt;code>String&lt;/code>としては、&lt;code>CharSequence&lt;/code>にアップキャストしてその&lt;code>trim()&lt;/code>を呼び出すことにしています。そのあとは単純に&lt;code>toString()&lt;/code>で返すだけですね。&lt;/p>
&lt;p>続いて、&lt;code>String&lt;/code>で呼ばれている&lt;code>CharSequence&lt;/code>側の&lt;code>trim()&lt;/code>をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CharSequence&lt;/span>.trim(): CharSequence = trim(Char&lt;span style="color:#f92672">::&lt;/span>isWhitespace)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでは、オーバロードした他の&lt;code>trim()&lt;/code>に&lt;code>isWhitespace()&lt;/code>をメソッドレファレンスとして渡しているのがわかります。&lt;code>Boolean&lt;/code>が戻り値なので、引数は&lt;code>Predicate&lt;/code>であると推測できますね。続けて、こちらで呼び出している&lt;code>trim(predicate)&lt;/code>の方を確認します。こちらのコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CharSequence&lt;/span>.trim(predicate: (Char) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Boolean): CharSequence {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> startIndex = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> endIndex = length - &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> startFound = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (startIndex &lt;span style="color:#f92672">&amp;lt;=&lt;/span> endIndex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> index = &lt;span style="color:#66d9ef">if&lt;/span> (!startFound) startIndex &lt;span style="color:#66d9ef">else&lt;/span> endIndex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> match = predicate(&lt;span style="color:#66d9ef">this&lt;/span>[index])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!startFound) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!match)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startFound = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startIndex &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (!match)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endIndex &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> subSequence(startIndex, endIndex + &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここまできてやっと実際の処理がでました。&lt;code>CharSequence&lt;/code>をループしながら左(start)から右の方にwhitespaceを探し、初めてwhitespaceでない文字を見つけたら右(end)から左の方にループしながら繰り返すという処理ですね。意外と単純ですが、効率的な処理です。&lt;/p>
&lt;p>そしてその処理での判断基準が&lt;code>isWhitespace()&lt;/code>になっているわけですが、先に確認している通りこちらは最終的にJavaのAPIを呼ぶことになっているので、&lt;code>trim()&lt;/code>でも十分Unicodeに定義されてあるwhitespaceやspaceまでを削除してくれると推論できます。なので、Javaとは違ってあえて&lt;code>strip()&lt;/code>を使う必要はなさそうです。&lt;/p>
&lt;p>また、&lt;code>trim()&lt;/code>は文字列の前後のwhitespaceを削除しますが、場合によっては前方のみ、後方のみで分けて使いたい場合もあるかもしれません。その時は、以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> string = &lt;span style="color:#e6db74">&amp;#34; string &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 左のみtrim
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.trimStart()) &lt;span style="color:#75715e">// &amp;#34;string &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 右のみtrim
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.trimEnd()) &lt;span style="color:#75715e">// &amp;#34; string&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのメソッドは引数として&lt;code>Predicate&lt;/code>を渡すこともできるので、他の条件を自前で書く必要がある場合にはそちらを使えますね。&lt;/p>
&lt;p>他にも、whitespaceではない、前後の特定の文字(prefix、suffix)を削除してたい場合は以下のメソッドが提供されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> string = &lt;span style="color:#e6db74">&amp;#34;--hello--&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// prefixのみ削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.removePrefix(&lt;span style="color:#e6db74">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#75715e">// &amp;#34;hello--&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// suffixのみ削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.removeSuffix(&lt;span style="color:#e6db74">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#75715e">// &amp;#34;--hello&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 前後を削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(string.removeSurrounding(&lt;span style="color:#e6db74">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#75715e">// &amp;#34;hello&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="改行を削除">改行を削除
&lt;/h3>&lt;p>改行が文字列の前後に入っていれば&lt;code>trim()&lt;/code>で十分ですが、文字列の中に改行が含まれていて、それを変えたい場合もありますね。例えばJSONをログに一行で出力したいだったり、以下のようなMulitiline Stringを一行にまとめたい場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> string = &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> World
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Intellijだと自動的に&lt;code>trimIndent()&lt;/code>をつけてくれますが、これはあくまでインデントに関与するものであって、中の改行まではtrimしてくれないです。こういう場合は、KotlinでもJavaでも対応するメソッドは特にないので、自分で処理を書くしかないですね。例えば、以下のようなコードが使えるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">String&lt;/span>.stripLine() = replace(&lt;span style="color:#a6e22e">System&lt;/span>.lineSeparator(), &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Javaでも13から&lt;a class="link" href="https://openjdk.java.net/jeps/355" target="_blank" rel="noopener"
>Text Block&lt;/a>が導入されているので、今後はJavaのAPIの方で上記のようなメソッドが追加されることを期待できるかもしれません。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>最初に&lt;code>expect&lt;/code>と&lt;code>actual&lt;/code>の話をしましたが、これらのキーワードは&lt;a class="link" href="https://kotlinlang.org/docs/multiplatform.html" target="_blank" rel="noopener"
>Kotlin Multiplatform&lt;/a>でもっとも重要な概念です。Kotlinで書いたコードをさまざまなプラットフォームで共有できるようにすることを目的としているので、こういう構造になっているのは自然ですね。なので、Kotlin/JVMだけでなく、他のことを試したい方にはとりあえず理解しておく必要があるキーワードだと思います。ちょっと独特なだけで、実体は単純なので、理解は簡単でしょう。&lt;/p>
&lt;p>また、KotlinのStringに関しては、&lt;a class="link" href="https://youtu.be/n4WBip822A8" target="_blank" rel="noopener"
>JetBrains公式YouTubeチャンネルの動画&lt;/a>で簡単に説明しているので、Kotlinで開発をしている方なら一度は参考にした方が良いかもしれません。&lt;/p>
&lt;p>他に、&lt;code>strip()&lt;/code>をあえて使う必要はないと言いましたが、実際Kotlinの最新バージョンである1.5.0でも&lt;code>strip()&lt;/code>は&lt;code>deprecated&lt;/code>になっていて、以下のようなコメントがついているので、次のバージョンで正式対応するまでは使わない方が良いですね。&lt;/p>
&lt;blockquote>
&lt;p>&amp;lsquo;strip(): String!&amp;rsquo; is deprecated. This member is not fully supported by Kotlin compiler, so it may be absent or have different signature in next major version&lt;/p>
&lt;/blockquote>
&lt;p>こういうケースでもわかるように、KotlinがJavaと100%互換性があると言い切れない側面もあるのではと思います。なので、JavaからKotlinに移行した場合(実際のコードであれ、開発者自身のスキルであれ)には、一度注意深くスタンダードライブラリの説明を読む必要があるかもしれません。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>年月を扱ってみる</title><link>https://retheviper.github.io/posts/kotlin-year-month/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-year-month/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post 年月を扱ってみる" />&lt;p>Kotlin(Java)では、&lt;code>java.time&lt;/code>パッケージのクラスで日付や時間を処理することができます。例えば&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/LocalDateTime.html" target="_blank" rel="noopener"
>LocalDateTime&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/LocalDate.html" target="_blank" rel="noopener"
>LocalDate&lt;/a>などがありますね。サーバサイドではこれらのクラスを使ってDBに日付や時間を入力したり、認証用のトークンの有効期間を設定したりの処理ができるようになります。他にも&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/time/Period.html" target="_blank" rel="noopener"
>Period&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" target="_blank" rel="noopener"
>Duration&lt;/a>があって、「期間」を扱うこともできますね。&lt;/p>
&lt;p>ただ、「年月」という単位を扱いたい場合はどうしたらいいでしょうか。例えば、口座の入出金明細などを照会する時に、「2月から4月まで」という風に期間を設定するケースなどがあるとしたら、いらない「日」や「時間」まで含めるのはあまり効率的でなく、場合によってはバグの原因になるかもしれません。こういった場合は確かな「年月」としてデータを扱うか、数字として表現するかなどどちらかの方法を考える必要があるでしょう。&lt;/p>
&lt;p>ということで、今回はこの年月を扱う方法について少し述べたいと思います。&lt;/p>
&lt;h2 id="年月を年と月に">年月を年と月に
&lt;/h2>&lt;p>年月を扱うということは、つまり、いつでも「年」と「月」という二つのデータとして分離できるようにしたいということにもなりますね。ここでは二つの方法で、「年月」を「年」と「月」の二つに分けて扱う方法について説明します。&lt;/p>
&lt;h3 id="yearmonthとして">YearMonthとして
&lt;/h3>&lt;p>&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>では、基本的に&lt;a class="link" href="https://www.iso.org/iso-8601-date-and-time-format.html" target="_blank" rel="noopener"
>ISO-8601&lt;/a>形式で日付を扱うことができます。もちろん、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>を使って他の形式を指定することもできますが、扱うデータの形が違うだけで、本質的には「年月日」が基本となりますね。&lt;/p>
&lt;p>&lt;code>ISO-8601&lt;/code>の「年月日」形式で日付を扱っているということは、つまり、SpringでREST APIを作っている場合、リクエストの値が&lt;code>ISO-8601&lt;/code>の形式を守っていれば&lt;code>LocalDateTime&lt;/code>や&lt;code>LocalDate&lt;/code>形式に自動変換されるということでもあります。例えば以下のようなリクエストのJSONがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;date&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-04-01&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Spring側では以下のようなコードで、リクエストのdateを&lt;code>LocalDate&lt;/code>に変換することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// リクエストボディ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DateRequest&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> date: LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コントローラ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@PostMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">date&lt;/span>(&lt;span style="color:#a6e22e">@RequestBody&lt;/span> request: DateRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして全く同じやり方で、&lt;code>LocalDate&lt;/code>を&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/YearMonth.html" target="_blank" rel="noopener"
>YearMonth&lt;/a>に変えることで年月に対応することができます。例えば以下のようなリクエストがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;yearMonth&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2021-04&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>yearMonth&lt;/code>を&lt;code>YearMonth&lt;/code>に変えるだけです。以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// リクエストボディ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">YearMonthRequest&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> yearMonth: YearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// コントローラ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@PostMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/year-month&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">yearMonth&lt;/span>(&lt;span style="color:#a6e22e">@RequestBody&lt;/span> request: YearMonthRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>YearMonth&lt;/code>を使うことのメリットは、&lt;code>LocalDateTime&lt;/code>や&lt;code>LocalDate&lt;/code>と同じく&lt;code>java.time&lt;/code>パッケージに属するオブジェクトなので、それらと互換性があり、相互変換が自由ということでもあります。例えば以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> yearMonth = &lt;span style="color:#a6e22e">YearMonth&lt;/span>.now() &lt;span style="color:#75715e">// 現在の年月を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2021&lt;/span>-&lt;span style="color:#ae81ff">04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> localDate = yearMonth.atDay(&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// 年月に日を指定してLocalDateにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&amp;gt;&amp;gt;&amp;gt; println(localDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2021&lt;/span>-&lt;span style="color:#ae81ff">04&lt;/span>-&lt;span style="color:#ae81ff">01&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>YearMonth&lt;/code>は時間に関する便利なメソッドを多く提供しているので、単純に数値としての年月を扱うだけでなく、色々な要件に合わせて日付関連の処理が必要な場合に便利かもしれません。例えば以下のような機能が提供されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> yearMonth = &lt;span style="color:#a6e22e">YearMonth&lt;/span>.of(&lt;span style="color:#ae81ff">2021&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2021&lt;/span>-&lt;span style="color:#ae81ff">05&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getYear()) &lt;span style="color:#75715e">// 年を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getMonth()) &lt;span style="color:#75715e">// 月(Enum)を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>MAY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getMonthValue()) &lt;span style="color:#75715e">// 月(数字)を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.isLeapYear()) &lt;span style="color:#75715e">// うるう年であるかどうか
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.atEndOfMonth()) &lt;span style="color:#75715e">// 月の最後の日(LocalDate)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">2021&lt;/span>-&lt;span style="color:#ae81ff">05&lt;/span>-&lt;span style="color:#ae81ff">31&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数字として">数字として
&lt;/h3>&lt;p>&lt;code>YearMonth&lt;/code>で受け取って処理した方がもっとも綺麗な方法に見えますが、状況によっては素直に&lt;code>Int&lt;/code>型で受け取った方が良い(もしくはそうするしかない)ケースもあるはずです。例えば以下のようなリクエストが送らられて来るようなケースですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;yearMonth&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">202104&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そもそも&lt;code>year&lt;/code>と&lt;code>month&lt;/code>のように別の項目になっていたとしたらもっとやりやすいのですが、このように年月が一つの&lt;code>Int&lt;/code>型のデータとして送られてくる場合は自分で年と月を抽出する処理を作るしかないですね。例えば以下のようなextension functionを書くことができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 年を抽出する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.extractYear(): Int = &lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 月を抽出する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.extractMonth(): Int = &lt;span style="color:#66d9ef">this&lt;/span> % &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実際のコードを動かしてみると、ちゃんと意図通り動くのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.extractYear(): Int = &lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ae81ff">202104.&lt;/span>extractYear()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res4: kotlin.Int = &lt;span style="color:#ae81ff">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.extractMonth(): Int = &lt;span style="color:#66d9ef">this&lt;/span> % &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ae81ff">202104.&lt;/span>extractMonth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res6: kotlin.Int = &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、パラメータとして渡されたものはただの&lt;code>Int&lt;/code>型なので、期待した通りの値ではない可能性もあるという問題があります。常に&lt;code>YYYYMM&lt;/code>という形でデータが送られてくるかどうかをチェックする必要がありますね。&lt;/p>
&lt;p>そういう場合に、上記のコードだとリクエストの&lt;code>yearMonth&lt;/code>が正しい年月の形式になっているかどうかがわかりません。なので、正規式を用いたバリデーションチェックを挟むことにしたらより安全になるでしょう。例えば、以下のようなコードを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.toYearMonth(): Pair&amp;lt;Int, Int&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (Regex(&lt;span style="color:#e6db74">&amp;#34;^(19|20)&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">d{2}(0[1-9]|1[012])&amp;#34;&lt;/span>).matches(&lt;span style="color:#66d9ef">this&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span> to &lt;span style="color:#66d9ef">this&lt;/span> % &lt;span style="color:#ae81ff">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;cannot convert&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数は、以下のような使い方ができます。簡単に使えるのでいい感じですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>year, month) = &lt;span style="color:#ae81ff">202104.&lt;/span>toYearMonth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(year)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(month)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元の値を二つの&lt;code>Int&lt;/code>に分けるために戻り値として&lt;code>Pair&lt;/code>を使いましたが、場合によっては&lt;code>YearMonth&lt;/code>の方が良いかもしれません。そういう場合は、以下のようなコードが使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.toYearMonth(): YearMonth =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (Regex(&lt;span style="color:#e6db74">&amp;#34;^(19|20)&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">d{2}(0[1-9]|1[012])&amp;#34;&lt;/span>).matches(&lt;span style="color:#66d9ef">this&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YearMonth(&lt;span style="color:#66d9ef">this&lt;/span> / &lt;span style="color:#ae81ff">100&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span> % &lt;span style="color:#ae81ff">100&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;cannot convert&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="年と月を年月に">年と月を年月に
&lt;/h2>&lt;p>さて、今回は逆に「年」と「月」を繋げて「年月」にする場合の処理を考えてみましょう。二つの&lt;code>Int&lt;/code>を合わせて、一つの&lt;code>Int&lt;/code>(YYYYMM)にする形です。ここでまず考えられる方法は二つです。&lt;code>YearMonth&lt;/code>を使った方法と、文字列に変換してから処理するという方法です。&lt;/p>
&lt;h3 id="yearmonthで">YearMonthで
&lt;/h3>&lt;p>まず&lt;code>YearMonth&lt;/code>を利用する場合は、年と月をそのまま引数として渡した後、&lt;code>Int&lt;/code>に変換すれば良いですね。ただ、&lt;code>YearMonth&lt;/code>は基本的に&lt;code>ISO-8601&lt;/code>形式なので、2021年4月だと&lt;code>2021-04&lt;/code>となるので&lt;code>Int&lt;/code>へ変換ができません。なので、まず&lt;code>String&lt;/code>に変えてから、&lt;code>-&lt;/code>を消して&lt;code>Int&lt;/code>に変換することにします。以上の処理は、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">toYearMonth&lt;/span>(year: Int, month: Int): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">YearMonth&lt;/span>.of(year, month).toString().replace(&lt;span style="color:#e6db74">&amp;#34;-&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>).toInt()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="文字列で">文字列で
&lt;/h3>&lt;p>文字列で処理する場合は、単純に&lt;a class="link" href="https://kotlinlang.org/docs/basic-types.html#string-templates" target="_blank" rel="noopener"
>String templates&lt;/a>を使うことでも可能ですが、注意したいのは、月は1~12という範囲を持つので、単純にtemplateで年と月を繋げると&lt;code>20214&lt;/code>のような形になり得る可能性もあるということですね。なので、&lt;code>padStart()&lt;/code>を利用して、月が1~9の場合は先頭に&lt;code>0&lt;/code>をつけるようにします。そのあとは&lt;code>Int&lt;/code>に変換するだけですね。これは以下のようなコードになリます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">toYearMonth&lt;/span>(year: Int, month: Int): Int = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${year}${month.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらの方法は、引数が二つなので、&lt;code>infix&lt;/code>として定義することもできます(好みの問題かと思いますが)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#66d9ef">infix&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">Int&lt;/span>.toYearMonthWith(month: Int): Int = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${this}${month.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ae81ff">2021&lt;/span> toYearMonthWith &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res10: kotlin.Int = &lt;span style="color:#ae81ff">202105&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>いかがだったでしょうか。あまり難しいコードではなかったので、あえて記事にまでする必要があったのか、という気もしましたが、個人的には&lt;code>YearMonth&lt;/code>というクラスの存在を初めて知ったのもあり、Kotlinならではのコード(extension function)を書いてみたく試したことを共有したいと思った次第です。もしKotlinやJavaで年月を扱う必要がある方には、少しでも役に立てるといいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinでZIP圧縮してみる</title><link>https://retheviper.github.io/posts/kotlin-zip-files/</link><pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-zip-files/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinでZIP圧縮してみる" />&lt;p>サーバサイドの機能を作っていると、ファイルダウンロード機能が必要な時があります。ただ、ストレージに保存されてあるファイルをそのまま返すということだけでなく、場合によってはファイルを生成してそのまま返したり、複数のファイルをまとめて転送する必要もありますね。&lt;/p>
&lt;p>リクエストごとに一つのファイルをダウンロードさせるとしたら、実装はそう難しくないものですが、複数のファイルをダウンロードさせるという場合は少し複雑になりますね。ファイルを一つにまとめて送るとしたら、ZIPに圧縮した方が良いでしょう。幸い、Javaでは基本的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/zip/ZipOutputStream.html" target="_blank" rel="noopener"
>ZipOutputStream&lt;/a>というAPIを提供しているので、エントリに圧縮対象のファイルを追加したあとZIPファイルを出力だけで良いです。&lt;/p>
&lt;p>ただ、単純にファイルが複数だるだけでなく、ディレクトリが多重にネストされてあったりする場合は、ディレクトリ構造を維持しつつそのまま圧縮するとかの追加的な処理が必要となります。そして場合によっては含めたくないファイルがあるケースもあったりしますね。そしてなるべくファイルの数に関係なく(ファイルが一つであれ、ディレクトリであれ)一つの機能で済ませたいものです。なので、今回はそのようなユースケースに合わせた簡単なメソッドを作る方法を、JavaのコードからKotlinへ移行していく過程を簡単に紹介したいと思います。&lt;/p>
&lt;p>今回紹介しますコードは、はBaeldungの&lt;a class="link" href="https://www.baeldung.com/java-compress-and-uncompress" target="_blank" rel="noopener"
>JavaでZipを圧縮する方法&lt;/a>に関する記事に紹介されてあるものをベースにしています。&lt;/p>
&lt;h2 id="java">Java
&lt;/h2>&lt;p>まずJavaのコードを見ていきましょう。上記の記事には、以下のようなコードが紹介されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ZipDirectory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String sourceFile &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;zipTest&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileOutputStream fos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileOutputStream(&lt;span style="color:#e6db74">&amp;#34;dirCompressed.zip&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipOutputStream zipOut &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ZipOutputStream(fos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File fileToZip &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> File(sourceFile);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile(fileToZip, fileToZip.&lt;span style="color:#a6e22e">getName&lt;/span>(), zipOut);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fos.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">zipFile&lt;/span>(File fileToZip, String fileName, ZipOutputStream zipOut) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileToZip.&lt;span style="color:#a6e22e">isHidden&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileToZip.&lt;span style="color:#a6e22e">isDirectory&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileName.&lt;span style="color:#a6e22e">endsWith&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">putNextEntry&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ZipEntry(fileName));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">closeEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">putNextEntry&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> ZipEntry(fileName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">closeEntry&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File&lt;span style="color:#f92672">[]&lt;/span> children &lt;span style="color:#f92672">=&lt;/span> fileToZip.&lt;span style="color:#a6e22e">listFiles&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (File childFile : children) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile(childFile, fileName &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> childFile.&lt;span style="color:#a6e22e">getName&lt;/span>(), zipOut);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileInputStream fis &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FileInputStream(fileToZip);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipEntry zipEntry &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ZipEntry(fileName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">putNextEntry&lt;/span>(zipEntry);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bytes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>1024&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((length &lt;span style="color:#f92672">=&lt;/span> fis.&lt;span style="color:#a6e22e">read&lt;/span>(bytes)) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.&lt;span style="color:#a6e22e">write&lt;/span>(bytes, 0, length);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fis.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>zipFile&lt;/code>メソッドをみると、引数の&lt;code>fileToZip&lt;/code>にZIPで圧縮したいファイルやディレクトリのパスを指定して、&lt;code>fileName&lt;/code>にはファイルもしくはディレクトリ名、&lt;code>zipOut&lt;/code>には圧縮後のZIPのファイル名を指定するようになっています。&lt;/p>
&lt;p>そして実装としては、指定したファイルやディレクトリに&lt;code>hidden&lt;/code>属性がある場合は圧縮しなく、圧縮元のファイルがディレクトリである場合は中のファイルを全部ZIPに含ませるという処理が含まれてありますね。対象のファイルとディレクトリを全部エントリに追加した後は、圧縮元を読み込んでZipOutputStreamに書き込むという処理となっています。これをKotlinのコードに変えてみましょう。&lt;/p>
&lt;h2 id="kotlinのコードに変えてみる">Kotlinのコードに変えてみる
&lt;/h2>&lt;p>JavaのコードをKotlinのコードに変えるのはそう難しくありません。Intellijの場合、すでにJavaのコードを貼り付けると自動でKotlinのコードの変換してくれる機能を搭載していますので。ただ、それだけでは十分ではないですね。簡単に変換ができるとしても、それが本当に&lt;code>Kotlinらしいコード&lt;/code>になっているとはいえない場合があります。&lt;/p>
&lt;p>そして、処理自体もより単純に、もしくは読みやすいコードにする方法もあるはずですね。上記のJavaコードをまずKotlinに変えて、色々改善したいところを含めて変えていきます。&lt;/p>
&lt;h3 id="kotlinらしいコードに変える">Kotlinらしいコードに変える
&lt;/h3>&lt;p>Intellij 2021.1を基準に、Javaのコードをそのまま貼り付けると以下のようなコードに自動変換されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Throws&lt;/span>(IOException&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">zipFile&lt;/span>(fileToZip: File, fileName: String, zipOut: ZipOutputStream) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileToZip.isHidden) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileToZip.isDirectory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (fileName.endsWith(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(ZipEntry(fileName))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(ZipEntry(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$fileName&lt;/span>&lt;span style="color:#e6db74">/&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> children = fileToZip.listFiles()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (childFile &lt;span style="color:#66d9ef">in&lt;/span> children) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile(childFile, fileName + &lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span> + childFile.name, zipOut)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> fis = FileInputStream(fileToZip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> zipEntry = ZipEntry(fileName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(zipEntry)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> bytes = ByteArray(&lt;span style="color:#ae81ff">1024&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> length: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (fis.read(bytes).also { length = &lt;span style="color:#66d9ef">it&lt;/span> } &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.write(bytes, &lt;span style="color:#ae81ff">0&lt;/span>, length)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fis.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでもっとKotlinらしいコードに変えたい部分は、&lt;code>InputStream&lt;/code>や&lt;code>OutputStream&lt;/code>の使い方です。Javaでも&lt;code>try-with-resource&lt;/code>があって、Kotlinには&lt;code>use()&lt;/code>があるのでそちらを使った方が&lt;code>close&lt;/code>よりも良い気がします。&lt;/p>
&lt;p>また、&lt;code>if&lt;/code>は&lt;code>when&lt;/code>に変えたり、&lt;code>for&lt;/code>を&lt;code>forEach()&lt;/code>に変えたりなどでよりやりたいことを明確にすることができるようにも見えます。個人的にはスコープをあえて分けたほうが責任が明確になり、処理を追うときに混乱しないのでなるべくスコープ関数やCollection専用のオペレーションを積極的に使用して処理の単位を分けられるところはきちんと分けたいと思います。Javaのやり方をとっても処理としては全く問題がありませんが、せっかくなのでKotlinならではのコードを描きたいものです。&lt;/p>
&lt;p>あえてIOExceptionを投げるという表示をしておくというのも、ランタイム時の例外の処理を強制してないKotlinには相応しくないのではないかという気もするので、アノテーションは削除することとします。&lt;/p>
&lt;h3 id="ioからnioに変える">IOからNIOに変える
&lt;/h3>&lt;p>NIOに関しては以前のポストで何回か言及したことがありますが、サーバのように頻繁かつ同時実行数が多いケースは積極的に採用した方が良いと思います。また、Java 1.8以降から追加されたメソッドでかなり便利に使える機能が多いので、IOをNIOに変えるだけでコードの量をかなり減らせる可能性もあります。&lt;/p>
&lt;p>特にディレクトリを指定した場合、そのディレクトリの子要素を循環するにはNIOの&lt;code>Files&lt;/code>が提供する機能が強力なので、今回はそれを積極活用することにします。&lt;/p>
&lt;h3 id="シグニチャーを変える">シグニチャーを変える
&lt;/h3>&lt;p>上記のメソッドでは、三つの引数を取っていますが、実際に必要なのは圧縮元のパスと、圧縮先のパスのみですね。ZipOutputStreamを呼び出し元で渡す理由は特になく、むしろこのメソッドを利用する度に定義する必要があるので不便ですね。そして、メソッドの中で単純にエントリを追加していて、呼び出し元とオブジェクトに対する処理の職務を分担するという構造もあまりよくないかと思います。なので、ZipOutputStreamの生成と使用はメソッドの中で完結するように変えることにします。&lt;/p>
&lt;p>こうすることで、メソッドの外側(呼び出し元)での使い方はもっと簡単になりますし、圧縮元のデータを読み込む際に使う&lt;code>InputStream&lt;/code>は中で閉じているのに引数の&lt;code>OutputStream&lt;/code>は外で閉じるという複雑な状況は避けられます。&lt;/p>
&lt;h3 id="再帰を無くす">再帰を無くす
&lt;/h3>&lt;p>圧縮元のパスがディレクトリである場合は、さらにネストされたディレクトリやファイルもまとめて圧縮するために再帰を使うようになっています。再帰はアルゴリズムとしては重要ではあるものの、処理が全部終わるまでメモリに全データと処理を詰めておくので処理の効率という面ではあまりよくない場合もありますね。やりたいのは単純に&lt;code>hidden&lt;/code>属性を持つファイルやディレクトリを除外すること、そしてそれ以外のファイルやディレクトリは全部ZipOutputStreamのエントリに入れたいという単純な事です。&lt;/p>
&lt;p>幸い、NIOを使うことでディレクトリの子要素を全部取得することができますし、取得した子要素は&lt;code>Stream&amp;lt;Path&amp;gt;&lt;/code>として取得できるので、&lt;code>filter()&lt;/code>や&lt;code>forEach()&lt;/code>のようなメソッドが使えます。これで十分、再帰を使わずに目的を達成できそうですね。&lt;/p>
&lt;h2 id="完成したコード">完成したコード
&lt;/h2>&lt;p>以上のことを反映し、修正したコードは以下の通りになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">object&lt;/span> &lt;span style="color:#a6e22e">ZipService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">archive&lt;/span>(source: Path, target: Path): Unit =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipOutputStream(&lt;span style="color:#a6e22e">Files&lt;/span>.newOutputStream(target)).use { zos &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.walk(source)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { &lt;span style="color:#a6e22e">Files&lt;/span>.isHidden(&lt;span style="color:#66d9ef">it&lt;/span>).not() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">Files&lt;/span>.isDirectory(&lt;span style="color:#66d9ef">it&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.putNextEntry(ZipEntry(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">/&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.putNextEntry(ZipEntry(&lt;span style="color:#66d9ef">it&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span>.copy(&lt;span style="color:#66d9ef">it&lt;/span>, zos)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>簡単に説明しますと、&lt;code>object&lt;/code>として宣言したSingletonクラスにおくことでどこでも活用できるユーティリティクラスにして、メソッドのシグニチャはより単純なものにしました。引数の&lt;code>source&lt;/code>には圧縮元のファイルやディレクトリを、&lt;code>target&lt;/code>には圧縮先のZIPファイルを指定する事になっています。ZipOutputStreamはメソッドの中で生成して、&lt;code>use()&lt;/code>を使って自動にクローズされるようにしています。&lt;/p>
&lt;p>まず優先的に&lt;code>Files.walk()&lt;/code>を使って子要素を全部取得するようにしています。取得した子要素は&lt;code>filter()&lt;/code>で&lt;code>hidden&lt;/code>でない場合を選別しているので、分岐は無くなりますね。また、子要素がディレクトリである場合ディレクトリ名であることを表すために&lt;code>/&lt;/code>をつけて&lt;code>ZipEntry&lt;/code>を追加とクローズします。子要素がファイルの場合は&lt;code>ZipEntry&lt;/code>の追加とコンテンツのコピーを行います。これでより短く、単純なコードの出来上がりです。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>&lt;code>Kotlinらしいコード&lt;/code>と述べましたが、上記のコードはあくまで&lt;code>Kotlin/JVM&lt;/code>でのみ有効ですね。なのでもし&lt;code>Kotlin/Native&lt;/code>や&lt;code>Kotlin/JS&lt;/code>などで使うには、別の方法を探す必要があるはずです。また、&lt;code>Files.walk()&lt;/code>はJava 1.8から追加されたメソッドなので、1.7の場合は&lt;code>Files.walkFileTree()&lt;/code>を、その以前なら仕方なくNIOではない別の方法を使う必要があると思います。&lt;/p>
&lt;p>なので、&lt;code>Kotlin/JVM&lt;/code>(Java 1.8以上)ではこれが最善なのかもしれませんが、また色々と研究の余地はありそうですね。こうやってJavaのAPIをKotlinの作法で切り替えていくのも、それなりに価値のあることではないかと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その一〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-1/</link><pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-1/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その一〜" />&lt;p>こないだはGoに関するポストを作成しましたが、やはり本業はKotlinなので、Kotlinに関しても何かわかったことや閃いたことなどあれば、順次に書いていこうと思っています。今回はKotlinでAPIを作りながら、業務での要件をどんなコードで満たしたかを簡単に説明させていただきたいと思います。&lt;/p>
&lt;p>サーバサイドエンジニアをやっていると、要求される機能を以下に実現している方法がどんなものあれ(GraphQL、REST API、マイクロサービスみたいな技術やアーキテクチャの観点の以前の話として)、業務としてはある程度パターン化しているように感じることがあります。こういう場合には、コードよりもロジックが大事であるかのように見える場合もありますね。でも逆に、むしろ似たようなロジックが多いので、より良いコードを書くために工夫できる余地もまた多いのではないか、とも思います。&lt;/p>
&lt;p>正直自分はアルゴリズムに強いわけでもないので、効率的なコードを書くとしたら限界はあるだろうなという気はしています。とりあえず動くコードを書いて、それをリファクタリングしながら少しづつ整える感じのことしかできないのかもしれません。&lt;/p>
&lt;p>しかし、そんな自分にも良いコードを書くためにできることが全くないわけでもないと思います。例えば、Javaでコードを書くときは、参照の問題などからなるべく&lt;code>final&lt;/code>をつけてオブジェクトを&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%9F%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB" target="_blank" rel="noopener"
>immutable&lt;/a>にするようにと教わりましたが、実際は&lt;a class="link" href="https://www.baeldung.com/java-final-performance?__s=m4suw1p9x2sbizbhxrew" target="_blank" rel="noopener"
>ベンチマークで比較した結果&lt;/a>でもわかるように、性能の改善にも繋がっています。また、JavaでもKotlinでも色々と便利なAPIを提供していて、バージョンアップの度にまた新しいAPIが追加されるので、それらの用途と使い方をよく理解した上で、積極的に使用するだけでも読みやすく、性能も良いコードを書くことができます。&lt;/p>
&lt;p>ということで、今回はKotlinのAPIを使って書いていたコードを一部紹介したいと思います。&lt;/p>
&lt;h2 id="リストのグループ化">リストのグループ化
&lt;/h2>&lt;p>DBに商品情報テーブルがあって、さらに商品属性テーブル、生産地や販売店テーブルなどがある場合に、業務によっては「販売店ごとにどんな商品が販売されているかを確認したい」とか、「特定の商品属性に当てはまる商品だけみたい」とかのケースがあるはずですね。&lt;/p>
&lt;p>そういった場合、APIとしてはテーブルから取得したデータを、特定のカラムを基準にまとめたもの返す必要があります。これをコードに書くとしたら&lt;code>List&lt;/code>で取得したデータを、中の一つの属性をキーに&lt;code>Map&lt;/code>にまとめて返すということになりますね。Javaだと、以下のような形になるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBのデータの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>User&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, 20, &lt;span style="color:#e6db74">&amp;#34;USA&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Programmer&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;James&amp;#34;&lt;/span>, 30, &lt;span style="color:#e6db74">&amp;#34;Canada&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Sales&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;Jack&amp;#34;&lt;/span>, 35, &lt;span style="color:#e6db74">&amp;#34;UK&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Programmer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// UserのJobを基準にまとめる&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pair&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> list.&lt;span style="color:#a6e22e">stream&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">groupingBy&lt;/span>(User::getJob,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors.&lt;span style="color:#a6e22e">mapping&lt;/span>(user &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Pair(user.&lt;span style="color:#a6e22e">getAge&lt;/span>(), user.&lt;span style="color:#a6e22e">getName&lt;/span>()), Collectors.&lt;span style="color:#a6e22e">toList&lt;/span>())));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// {James=[Pair(first=30, second=Sales)], John=[Pair(first=20, second=Programmer), Pair(first=35, second=Writer)]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> age;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String address;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String job;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Pair&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Object first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Object second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinでもJavaのAPIをそのまま使うことができるので、上記の&lt;code>Stream&lt;/code>と&lt;code>Collector&lt;/code>を使って同じことはできます。ただ、せっかく違う言語と使っているわけなので、できればKotlinが提供するAPIを活用して同じことをしたいものです。&lt;/p>
&lt;p>KotlinはCollectionで提供する機能だけでも&lt;code>Stream&lt;/code>と&lt;code>Collector&lt;/code>を組み合わせたものと似たような処理ができる場合が多いので、JavaのAPIに対応した機能があるかどうかを探すだけで事足りるケースが多いです。ということは、上記の処理でキモになっている&lt;code>Collectors.groupingBy()&lt;/code>と&lt;code>Collectors.mapping()&lt;/code>と似たようなものがあればいいというわけですが、&lt;code>groupBy()&lt;/code>でそれらの処理をまとめることができます。なので、上記のコードをKotlinで変えると、以下のようになります。色々とスッキリしますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;USA&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Programmer&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;James&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Canada&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Sales&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;Jack&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">35&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;UK&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Programmer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Jobを基準にMap&amp;lt;String, List&amp;lt;Pair&amp;lt;Int, String&amp;gt;&amp;gt;&amp;gt;にまとめる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> map = list.groupBy({ &lt;span style="color:#66d9ef">it&lt;/span>.job }, { &lt;span style="color:#66d9ef">it&lt;/span>.age to &lt;span style="color:#66d9ef">it&lt;/span>.name })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// {Programmer=[(20, John), (35, Jack)], Sales=[(30, James)]}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> age: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> address: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> job: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mapのvalueだけを変える">Mapのvalueだけを変える
&lt;/h2>&lt;p>上記の処理に加えて、もっと条件がつく場合もあるかと思います。例えば、金額計算とかの例があるとします。従業員が案件ごとに賃金をもらうということになっていて、案件はコードで管理されている場合、賃金を払う側としては同じ案件に対しては合算した金額のみが知りたいとかのケースもあるでしょう。こういう場合には、従業員ごとにデータをまとめた上で、さらにその人が担当した案件のリスト野中で重複するものがあれば、金額だけを合算するようにする必要がありますね。&lt;/p>
&lt;p>こういう場合は、グルーピングの段階からそういう処理を入れるのがもっとも効率的ではあるとは思いますが、スレッドの問題もあるので(生成中のMapの中を巡回するという)、実際のコードに書くとするとかなり複雑になる可能性もあります。なのでここではまず、&lt;code>List&lt;/code>を&lt;code>Map&lt;/code>にまとめた結果を持ってさらに処理を加えるという形を取ります。&lt;/p>
&lt;p>Kotlinの&lt;code>Map&lt;/code>には、&lt;code>map()&lt;/code>以外にも&lt;code>mapKeys()&lt;/code>や&lt;code>mapValues()&lt;/code>のような関数があって、必要な部分だけをマッピングできます。今回は&lt;code>value&lt;/code>だけを変えたいので、&lt;code>mapValues()&lt;/code>を使った方が無駄がなく、コードを読む側としても意図が明確になって良いと思います。&lt;code>mapValues()&lt;/code>を使ってさらにマッピングを行うコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> name: String, &lt;span style="color:#66d9ef">val&lt;/span> id: Int, &lt;span style="color:#66d9ef">val&lt;/span> amount: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">5000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// nameでまとめた後、重複するidを一つにまとめる(amountを合算)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> map = list.groupBy({ &lt;span style="color:#66d9ef">it&lt;/span>.name }, { &lt;span style="color:#66d9ef">it&lt;/span>.id to &lt;span style="color:#66d9ef">it&lt;/span>.amount })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .mapValues {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// idでグルーピング
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">it&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>.groupBy { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.first }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// keyはそのまま、valueだけを合算する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> .map { map &lt;span style="color:#f92672">-&amp;gt;&lt;/span> map.key to map.&lt;span style="color:#66d9ef">value&lt;/span>.sumBy { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.second } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// {A=[(1, 3000), (2, 4000)], B=[(3, 5000)]}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>List&lt;/code>を&lt;code>Map&lt;/code>にまとめるもう一つの方法は、&lt;code>groupingBy()&lt;/code>があります。この関数を使うと、Collectionが&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-grouping" target="_blank" rel="noopener"
>Grouping&lt;/a>というオブジェクトに変わって、&lt;code>aggregate()&lt;/code>・&lt;code>reduce()&lt;/code>・&lt;code>fold()&lt;/code>・&lt;code>eachCount()&lt;/code>のような関数を使うことで後続の処理ができます。上記のコードを&lt;code>Grouping&lt;/code>を使ったものに変えるとしたら、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Groupingのaggregateを利用してMapに変えた後から、valueの処理を行う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> map = list.groupingBy { &lt;span style="color:#66d9ef">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .aggregate { _, accumulator: MutableList&amp;lt;Pair&amp;lt;Int, Int&amp;gt;&amp;gt;?, element, first &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 新しいキーなら、MutableListを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (first)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutableListOf(element.id to element.amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// そうではない場合は、存在するListに要素を追加する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accumulator&lt;span style="color:#f92672">?.&lt;/span>apply { add(element.id to element.amount) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.mapValues {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.&lt;span style="color:#66d9ef">value&lt;/span>&lt;span style="color:#f92672">?.&lt;/span>groupBy { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.first }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?.&lt;/span>map { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.key to pair.&lt;span style="color:#66d9ef">value&lt;/span>.sumBy { pair &lt;span style="color:#f92672">-&amp;gt;&lt;/span> pair.second } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見、&lt;code>groupingBy()&lt;/code>の方が複雑にも見えますが、&lt;code>accumulator&lt;/code>を使ってマッピングした値を積み重ねることができるので、場合によっては考慮する価値があるかもですね。&lt;/p>
&lt;h2 id="mapを使ったキャッシュ">Mapを使ったキャッシュ
&lt;/h2>&lt;p>DBの参照が頻繁であり、なお参照されるデータそのものは更新される頻度が高くない場合は、アプリケーション内にキャッシュして置くのが良いケースもたまにありますね。こういう場合には、パラメータをキーとして持つ&lt;code>Map&lt;/code>を宣言しておいて、そのキーがない場合だけDBにアクセスする(そして&lt;code>Map&lt;/code>に追加する)という形にすれば良いでしょう。Javaでは1.8から&lt;code>computeIfAbsent()&lt;/code>というメソッドを提供しているので、簡単に実装ができます。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBデータの例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// キャッシュのMap&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Boolean&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentHashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// パラメータ&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String element &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// キャッシュにパラメータがない場合はDBデータを参照して、追加した後に返す&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Boolean exists &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">computeIfAbsent&lt;/span>(element, key &lt;span style="color:#f92672">-&amp;gt;&lt;/span> list.&lt;span style="color:#a6e22e">contains&lt;/span>(element));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Method Referenceを使った例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exists &lt;span style="color:#f92672">=&lt;/span> map.&lt;span style="color:#a6e22e">computeIfAbsent&lt;/span>(element, list::contains);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaで提供する機能なので、もちろんKotlinでも全く同じ形で実装できます。ただ、Kotlinの仕様上&lt;code>compute&lt;/code>のコードが&lt;a class="link" href="https://kotlinlang.org/docs/lambdas.html#instantiating-a-function-type" target="_blank" rel="noopener"
>LambdaかMethod Referenceかによって書き方が違う&lt;/a>ので、そこだけ注意する必要があります。これはKotlin自体の仕様によるものですが、Javaの書き方に慣れていると最初はなかなかわかりにくいところかもしれません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// キャッシュのMap
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> map = ConcurrentHashMap&amp;lt;String, Boolean&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// パラメータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> element = &lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Lambdaの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> exists = map.computeIfAbsent(element) { list.contains(element) } &lt;span style="color:#75715e">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Method Referenceの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>exists = map.computeIfAbsent(element, list&lt;span style="color:#f92672">::&lt;/span>contains)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、似たような機能をするメソッドとして&lt;code>putIfAbsent()&lt;/code>がありますが、&lt;code>computIfAbsent()&lt;/code>の場合&lt;code>Map&lt;/code>にキーがなかった場合にだけ後続の処理が行われるに対して、&lt;code>putIfAbsent()&lt;/code>はキーがあるかないかに関係なく処理が走ってしまうという違いがあるらしいです。なのでキャッシュとして使う場合は、&lt;code>computeIfAbsent()&lt;/code>を使った方が良いでしょう。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>自分が書いたコードをいくつか紹介しましたが、いかがだったでしょうか。まだKotlinに移行したばかりなので色々とわからないことが多く、本当はもっとスマートな方法があるのかもしれませんが、自分的には、こうやって実際の業務の要件に合わせて違う言語とコードを比べながら、APIのソースをみたりで自分なりにどうやって書くかを考えてみるのは意味のあることで、楽しいとも思います。&lt;/p>
&lt;p>というわけで、これからもKotlinでの書き方に対する研究はこれからも続きます。そろそろGoでも簡単なAPIでも作ってみたりで勉強をしないとやばそうな気もしていますが…まぁ、なんとかなるでしょう。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>JavaプログラマーがみたKotlin〜その二〜</title><link>https://retheviper.github.io/posts/kotlin-basics/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-basics/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post JavaプログラマーがみたKotlin〜その二〜" />&lt;p>この度は、転職することとなり、仕事で使われる言語もJavaからKotlinに変わることになりました。個人的にKotlinで簡単なSpring WebFluxプロジェクトを作ってみたことはあり、もともとJavaプログラマがKotlinへ移行するのは難しいことではないと言われてはいるものの、やはり仕事で使われる言語が変わるというのはかなりのチャレンジではあると思います。なので、今まではJavaに関してのポストを主に載せていたのですが、これからはKotlinに関してのポストを増やしていきたいと思います。&lt;/p>
&lt;p>まず、よく知られているように、KotlinはJavaと完璧な互換性を持つものです。それはJVM言語であり、コンパイルしたらJavaと同じくバイトコードになるからですね。ただ、だからと言って「Javaの感覚で」コードを書くということは、Kotlinという「違う言語」に移行する意味を無くす行為な気がします。なぜなら、Kotlinは触れば触るほどJavaとは根本的に違う考え方で設計されている言語だということが伝わってくるからです。最初はJavaの冗長さ(Verbose)を減らすことが第一の目標ではないかという印象を受けましたが、本格的に勉強を始めるとそれだけではないような気がしているのです。&lt;/p>
&lt;p>今回のポストは、&lt;a class="link" href="https://www.coursera.org" target="_blank" rel="noopener"
>Coursera&lt;/a>の&lt;a class="link" href="https://www.coursera.org/learn/kotlin-for-java-developers" target="_blank" rel="noopener"
>Kotlin for Java Developers&lt;/a>の講義の内容に基づいて作成されました。&lt;/p>
&lt;h2 id="冗長さを減らすということ">冗長さを減らすということ
&lt;/h2>&lt;p>Javaは今でも良い言語であり、多くの言語が発表されエンタープライズレベルで使われるようになった今でも、幅広い分野で使われていますね。Javaが依然としてよく使われる言語であることは、&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE index&lt;/a>やJetBrainsの&lt;a class="link" href="https://www.jetbrains.com/lp/devecosystem-2020" target="_blank" rel="noopener"
>The State of Developer Ecosystem&lt;/a>、Stackoverflowの&lt;a class="link" href="https://insights.stackoverflow.com/survey/2020" target="_blank" rel="noopener"
>Developer Survey&lt;/a>からも読み取れることです。&lt;/p>
&lt;p>ただ、Javaが依然として人気の言語だとしても、それは圧倒的にJavaが他の言語に比べ優秀だとか、使いやすい言語であるという意味ではないでしょう。どの言語でもそうであると思いますが、Javaでよく指摘されている問題の一つは、「冗長すぎる」というところです。数多くのライブラリがあり、MavenやGradleのような優秀なビルドツールを使えながらも、やはり言語の仕様は変わってないですからね。Java 9からはこの問題を解消するため、他の言語から影響を受けたような機能を多く導入していますが(例えば、&lt;a class="link" href="https://blogs.oracle.com/javamagazine/pattern-matching-for-instanceof-in-java-14" target="_blank" rel="noopener"
>instanceofのパターンマッチング&lt;/a>や&lt;a class="link" href="https://blogs.oracle.com/javamagazine/records-come-to-java" target="_blank" rel="noopener"
>record&lt;/a>など)、言語そのものの設計思想が変わるというよりは「違う言語の特徴をJavaに合わせた仕様で導入する」ことに近いので、根本的な変化とは言えないものです。なので今まで書かれている冗長なコードは残るもので、またこれからも使われることになるはずです。&lt;/p>
&lt;h3 id="コードが短くなる">コードが短くなる
&lt;/h3>&lt;p>冗長さを減らすということは、簡単にいうと「より短いコードで、同じ結果を得る」と定義できるでしょう。そういう観点からすると、KotlinはJavaの冗長さを減らすために工夫した痕跡が言語の仕様から感じ取れるようなものです。例えば以下のようなコードがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">updateWeather&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> degrees) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String description;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Color color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (degrees &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;cold&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#f92672">=&lt;/span> BLUE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (degrees &lt;span style="color:#f92672">&amp;lt;&lt;/span> 25) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mild&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#f92672">=&lt;/span> ORANGE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#f92672">=&lt;/span> RED;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをKotlinで書き換えると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>description, color) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (degrees &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#e6db74">&amp;#34;cold&amp;#34;&lt;/span>, BLUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (degrees &amp;lt; &lt;span style="color:#ae81ff">25&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#e6db74">&amp;#34;mild&amp;#34;&lt;/span>, ORANGE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span>, RED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まず二つの変数を、戻り値が&lt;code>Pair&lt;/code>のオブジェクトの表現式でより短くできることがわかります。そしてこのコードは、&lt;code>when&lt;/code>句を使ってより短い形で変えることもできます。その結果が以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>description, color) = &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#e6db74">&amp;#34;cold&amp;#34;&lt;/span>, BLUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#ae81ff">25&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#e6db74">&amp;#34;mild&amp;#34;&lt;/span>, ORANGE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span>, RED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに&lt;code>Pair&lt;/code>は、&lt;code>to&lt;/code>を使うことでもっと簡単に表現することもできます。そうすると、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">(&lt;/span>description, color) = &lt;span style="color:#66d9ef">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;cold&amp;#34;&lt;/span> to BLUE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#ae81ff">25&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mild&amp;#34;&lt;/span> to ORANGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hot&amp;#34;&lt;/span> to RED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最初のJavaのコードと比べ、かなり簡単かつ明瞭なコードになっているのがわかります。他の言語を使っていた人だとしても、一瞬ですぐに何をしているのかがわかって、より短く効率なコードになっているのがわかりますね。こういうところこそ、KotlinがJavaの冗長さ−無駄を減らすことに力を入れている部分ではないかと思います。&lt;/p>
&lt;h3 id="コードを簡単に書ける">コードを簡単に書ける
&lt;/h3>&lt;p>自分は最初、Kotlinの文法を簡単にみながら&lt;code>switch&lt;/code>がここでは&lt;code>when&lt;/code>に変わって、&lt;code>case&lt;/code>を書く必要がないんだな、くらいの印象しか受けてなかったです。しかし、よくよく見ると、他にもJavaと違うところが良く見えます。ここで読み取れるものは、例えばさっきのコードだと以下がありますね。&lt;/p>
&lt;ul>
&lt;li>&lt;code>when&lt;/code>句が表現式として使える&lt;/li>
&lt;li>&lt;code>when&lt;/code>句の条件の対象は条件式の中のみで良い&lt;/li>
&lt;li>表現式の中で複数の値を戻り値として定義し、それを&lt;/li>
&lt;li>&lt;code>to&lt;/code>で二つのオブジェクトを&lt;code>Pair&lt;/code>にまとめることができる&lt;/li>
&lt;/ul>
&lt;p>他にも、Javaの&lt;code>switch&lt;/code>に比べKotlinの&lt;code>when&lt;/code>句は以下のよう活用ができるというところもあります。オブジェクトの比較がより簡単ですね。例えば以下のようなコードで、簡単に二つのオブジェクトに対しても比較が可能になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">mix&lt;/span>(c1: Color, c2: Color) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (setOf(c1, c2)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(RED, YELLOW) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ORANGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(YELLOW, BLUE) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> GREEN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(BLUE, VIOLET) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> INDIGO
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> Exception(&lt;span style="color:#e6db74">&amp;#34;Dirty Color&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをあえてJavaのコードで書くとしたら、おそらく以下のようになるでしょう。個人的に、たくさんの&lt;code>else if&lt;/code>はあまり読みやすいコードではなく、書く立場としても綺麗ではないと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> Color &lt;span style="color:#a6e22e">mix&lt;/span>(Color c1, Color c2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (c1 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">RED&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">YELLOW&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Color.&lt;span style="color:#a6e22e">ORANGE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (c1 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">YELLOW&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">BLUE&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Color.&lt;span style="color:#a6e22e">GREEN&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (c1 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">BLUE&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#f92672">==&lt;/span> Color.&lt;span style="color:#a6e22e">VIOLET&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Color.&lt;span style="color:#a6e22e">INDIGO&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Dirty Color&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、KotlinではJavaと同じことをするとしても、短いだけでなく、より簡単にコードをかけるということですね。もちろん、別のメソッドを作ったり、&lt;code>Comparable&lt;/code>なオブジェクトを作ったり、&lt;code>Comparator&lt;/code>クラスを実装することでJavaでも似たようなことはできるかもしれません。しかし、そこまでしたいかというと微妙ですね。&lt;/p>
&lt;p>もちろん、Java 12からはKotlinの&lt;code>when&lt;/code>に近い感覚でコードを書くこともできるようになっています。表現式としても使えて、複数の条件を指定することができ、&lt;code>Lambda&lt;/code>の感覚で書けるということも良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (month) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> JANUARY, JUNE, JULY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 3;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> FEBRUARY, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> MARCH, MAY, APRIL, AUGUST &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> monthLength &lt;span style="color:#f92672">=&lt;/span> month.&lt;span style="color:#a6e22e">toString&lt;/span>().&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> monthLength &lt;span style="color:#f92672">*&lt;/span> 4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような変化を見ると、この「冗長さを減らす」という面では、Javaもまたバージョンアップとともに新機能を次々と導入してきているので、Kotlinの魅力が半減しているように見えるかもしれません。しかし、Kotlinではもっと重要なポイントがまた一つあります。言語自体の拡張性です。&lt;/p>
&lt;h2 id="拡張ができるということ">拡張ができるということ
&lt;/h2>&lt;p>言語自体の拡張性と言いましたが、簡単にいうと、以前にも紹介したことのある拡張関数、つまり&lt;code>extension&lt;/code>のことです。Kotlinの仕様としてもこれは大きい部分として紹介されているものですね。これをよく使うと、ただ「継承しなくてもそのクラスにメソッドを追加できる」だけでなく、&lt;code>infix&lt;/code>と組み合わせることでまるで予約後であるように使うことができます。&lt;/p>
&lt;p>実際、&lt;a class="link" href="https://www.coursera.org/learn/kotlin-for-java-developers" target="_blank" rel="noopener"
>Kotlin for Java Developers&lt;/a>のコーディング問題では、&lt;code>infix&lt;/code>で書かれた以下の拡張関数を持って結果の確認を行っていると言われています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">infix&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">T&lt;/span>.eq(other: T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span> &lt;span style="color:#f92672">==&lt;/span> other) println(&lt;span style="color:#e6db74">&amp;#34;OK&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;Error: &lt;/span>&lt;span style="color:#e6db74">$this&lt;/span>&lt;span style="color:#e6db74"> != &lt;/span>&lt;span style="color:#e6db74">$other&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>infix&lt;/code>を使うと、以下のようなコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;ABC&amp;#34;&lt;/span> eq &lt;span style="color:#e6db74">&amp;#34;ABC&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような特徴があるということは、使う側からしても便利ですが、これから言語そのもののバージョンアップにしたがってより便利な機能が追加され安いことにもなっていると思います。例えば先ほどの&lt;code>Pair&lt;/code>オブジェクトを作る&lt;code>to&lt;/code>が、このように&lt;code>infix&lt;/code>関数として作られているものです。これからもこういった便利な機能が追加され、追加しやすくなるのは確かに開発のコストの削減をという面でも良いことですね。&lt;/p>
&lt;h2 id="もう十分便利であること">もう十分便利であること
&lt;/h2>&lt;p>冗長さを減らし、拡張性がある言語だという特徴は、おそらくKotlinを作っているJetBrainsにとっても十分有効な特徴であるかと思います。Kotlinのスタンダードライブラリを見ると、すでに便利な関数が多く存在しています。例えば、簡単なループでは以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 一般的なfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (element &lt;span style="color:#66d9ef">in&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(element)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデックスを含むfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> ((index, element) &lt;span style="color:#66d9ef">in&lt;/span> list.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$index&lt;/span>&lt;span style="color:#e6db74">: &lt;/span>&lt;span style="color:#e6db74">$element&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデックスのみのfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (index &lt;span style="color:#66d9ef">in&lt;/span> list.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(index)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前もJavaのfor文の性能についてのポストで簡単に述べたことがありますが、そこではJavaならインデックスが必要な場合は伝統的なfor文を使い、そうではない場合は一般的に拡張for文を使った方がいいという結論をJMHでのベンチマークで出していました。しかし、こうやってすでに言語から便利な方法を提供していると、性能を気にすることなく便利な方法を取れるという面でも魅力的です。&lt;/p>
&lt;p>そして、forEachでもインデックスが必要であるなら、&lt;code>forEachIndexed&lt;/code>を使えるという良い点もあります。例えば、以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 一般的なforEach文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>list.forEach(&lt;span style="color:#f92672">::&lt;/span>println)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// インデックスを含むforEach文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>list.forEachIndexed { index, element &lt;span style="color:#f92672">-&amp;gt;&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$index&lt;/span>&lt;span style="color:#e6db74">: &lt;/span>&lt;span style="color:#e6db74">$element&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インデックスを簡単に取得できるということは、ループ対象のオブジェクトが持つ全インデックスを取得したい場合に、あえて&lt;code>0&lt;/code>のような、マジックナンバーにありえる数値を指定する必要がないというところでも良いですね。Javaだと毎回、static finalなフィールドとして宣言したり、別の定数として管理したりするケースが多いので…&lt;/p>
&lt;p>他にも、正規表現なしでも文字に関して簡単にチェックできる関数が事前に提供されているとか(&lt;code>Char.isLetter()&lt;/code>や&lt;code>Char.isDigit()&lt;/code>など)、&lt;code>Map&lt;/code>には&lt;code>Pair&lt;/code>で要素を入れることができるとか、iterableなオブジェクトからStream APIのような操作がすぐできるなど、確かにJavaに比べ「悩む必要がない」のが魅力的と思います。まぁ、人によってはこれはデメリットと認識する可能性もあるのでは、といは思いますが…&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>色々とKotlinの特徴・メリットについて述べましたが、こういう自分もまだ実際に業務でKotlinを使っているわけではないので、まだまだ表面的な知識のみに止まっていると思います。しかし、ここで紹介したことだけでも、Kotlinの魅力は感じ取れるのではないかと思います。&lt;/p>
&lt;p>言語自体も魅力的なのですが、他にもKotlinを扱うことで得られるメリットは多いです。例えば、JetBrainsが開発しているので、Intellijとの相性が良いこと。JVM言語でありJavaとの互換性があるので、Javaの発展をそのまま吸収できるということ。NativeやJavaScriptへのコンパイルもできるということ。他の言語も十分魅力的なポイントはありますが、Javaプログラマーであるなら、一度Kotlinに触れてみる価値はあると信じています。皆さんもまだKotlinに触れたことがないのであれば、この度ぜひ軽い気持ちで挑戦してみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Scope Functionはどう使うか</title><link>https://retheviper.github.io/posts/kotlin-scope-function/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-scope-function/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Scope Functionはどう使うか" />&lt;p>KotlinがJavaと区別される特徴といえば色々あるとは思いますが、そのうちの一つとしてあげられるものが&lt;code>Scope Function&lt;/code>ではないかと思います。以前のポストでも簡単に触れたことがありますが、これらのビルトイン関数たちは確かに上手く使うと、Javaより簡潔なコードを書くばかりでなく、より作成者の意図が伝わりやすい、強力な武器になり得るのではないかと思います。しかしながら、やはり他の言語と比べて新しい概念のものであるので、どの場面で使った方が良いか、どう使ったらいいかという、いわゆるBest Practiceがどんなものであるか悩ましくもなりますね。&lt;/p>
&lt;p>おそらくこう思っているのは自分だけでなく、ネットから検索してみるとScope Functionに関しての多くの記事を見つけることができますが、大抵が個別の関数の使い方の紹介に過ぎないような気がしています。なので、具体的にこれらの関数はなんのためのものであり、それぞれどう使い分けるか、またどの場面で使うべきかというのが気になっていたところです。調べてみたところ、公式のドキュメントやいくつかのブログの記事などに情報があったので、これらをまとめて整理してみました。&lt;/p>
&lt;h2 id="そもそもscope-functionって">そもそもScope Functionって？
&lt;/h2>&lt;p>最初にScope Functionを言及しましたが、これは一体なんでしょう。まずはなぜこれらの関数にこんな名前がつけられたのかを知る必要がありそうです。&lt;a class="link" href="https://kotlinlang.org/docs/reference/scope-functions.html" target="_blank" rel="noopener"
>公式の説明&lt;/a>だと、以下のように述べています。&lt;/p>
&lt;blockquote>
&lt;p>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions.&lt;/p>
&lt;/blockquote>
&lt;p>要するに、特定のオブジェクトに範囲(Scope)を限定し、Lambdaで書かれた関数を実行させたい場合に使えるもののようです。もちろん、これは全く新しい形の関数ではありません。形(コードの書き方)としては、オブジェクトの関数を呼び出しているだけのように見えるだけですね。しかし、コードをみてみると、コードブロックで警戒を作ることでより&lt;code>特定のオブジェクト&lt;/code>に限った処理であることが視覚的に、明確になります。例えば、以下のようなコードはどれもやっていることは同じですが、コードも読む側からすると処理を適用させる&lt;code>範囲&lt;/code>は後者の方が明確になりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Scope Functionなしのコード
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> john = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#a6e22e">Gender&lt;/span>.Male)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>john.doWarmingUp()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>john.startToRun()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Scope Functionのletを使った場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> john = Person(&lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#a6e22e">Gender&lt;/span>.Male).let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.doWarmingUp()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.startToRun()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="どう違う">どう違う？
&lt;/h2>&lt;p>上述した通り、コードの範囲を限定することで、処理の範囲が明確になるのが分かりました。しかし、これでScope Functionを使う準備は整ったかというと、そうでもないです。実はそれ以外でも考えなければならないところがあるのです。なぜなら、Scope Functionには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" target="_blank" rel="noopener"
>with&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="_blank" rel="noopener"
>let&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="_blank" rel="noopener"
>run&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html" target="_blank" rel="noopener"
>also&lt;/a>の5つの関数が存在するからです。複数の関数が存在していることは、時と場合によって違う関数を選ぶ必要があるということでしょう。&lt;/p>
&lt;p>では、これらの関数は他と何が違うのでしょう。まず、考えられるのは仕様です。Scope Functionは、内部的には渡したLambdaを実行してその結果を返すこととなっています。だとすると、仕様としてはLambdaで扱うオブジェクトと戻り値の差だけとなります。Scope Functionには処理の対象となるオブジェクト(レシーバーと言います)と、Lambdaをまずパラメータとして渡すようになります。ここで渡したレシーバーへのアクセスをどう書くかと、処理後の戻り値がどうなるかがこの5つのScope Functionでそれぞれ違います。これをテーブルとして表すと、以下のようになります。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>関数名&lt;/th>
&lt;th>レシーバーのアクセス&lt;/th>
&lt;th>戻り値&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>with&lt;/td>
&lt;td>this&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>let&lt;/td>
&lt;td>it&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>apply&lt;/td>
&lt;td>this&lt;/td>
&lt;td>T&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>run&lt;/td>
&lt;td>this&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>also&lt;/td>
&lt;td>it&lt;/td>
&lt;td>T&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>また、withを除いた他の4つの関数たちは、&lt;a class="link" href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener"
>Extension Function&lt;/a>でもあるという特徴があります。 Extension Functionは何か？というと、簡単に、既定のクラスに関数を追加することです。Javaだとクラスの継承やラッパークラスの作成、オーバーライドなどで実現できる機能ですが、Kotlinでは簡単に定義できます。&lt;/p>
&lt;p>「Scope FunctionなのにExtension Functionでもあると？」と思うかもしれませんが、理由は簡単です。クラスの作成時に関数として定義してなくても、もともとそのクラスにあったかのように呼べる関数だから、ということです。どのオブジェクトでも、宣言しなくてもwithを除いたScope Functionをあらかじめ宣言しておいたかのように使うことができます。&lt;/p>
&lt;h3 id="参考itとthis">参考：itとthis
&lt;/h3>&lt;p>&lt;code>it&lt;/code>は、パラメータが一つのみのLambdaで使われるものです。例えばJavaだと、パラメータが一つだとしても、&lt;a class="link" href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener"
>Method Reference&lt;/a>を使わない限り以下のように書く必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> names &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;john&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;jack&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Predicateの引数は一つだけだが、&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> filtered &lt;span style="color:#f92672">=&lt;/span> names.&lt;span style="color:#a6e22e">stream&lt;/span>().&lt;span style="color:#a6e22e">filter&lt;/span>(name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;john&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">equals&lt;/span>(name)).&lt;span style="color:#a6e22e">findFirst&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは、同じ状況だとパタメータを省略して単純に&lt;code>it&lt;/code>として表現することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> names: List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#e6db74">&amp;#34;john&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;jack&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// itでの省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> filtered = names.first { &lt;span style="color:#66d9ef">it&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;o&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>結局、&lt;code>this&lt;/code>と同じではないか？と思いがちですが、&lt;code>it&lt;/code>はLambdaのぱらめーたにスコープが限定されて、&lt;code>this&lt;/code>のスコープはローカルでもグローバルでもなれるという点が違います。なぜなら、&lt;code>this&lt;/code>はレシーバーそのものを指していて、パラメータがない場合はLambdaのスコープの外を指すことになるからです。つまり、パラメータのないLambdaではitを使えないですが、thisは使えるということになります。&lt;/p>
&lt;h2 id="いつ使う">いつ使う?
&lt;/h2>&lt;p>では、Scope Functionに5つの関数があり、それぞれどう違うかがわかったので、次はそれぞれをどう使い分けるか知りたいですね。さまざまな意見があったので、(自分の)納得の行くもので整理してみました。&lt;/p>
&lt;h3 id="with">with
&lt;/h3>&lt;p>&lt;code>with&lt;/code>はExtension Functionではないので、オブジェクトをパラメータとして受け取る一般的な関数として使えます。このような特徴があるので、複数のオブジェクトで同じような処理を行う必要があるときに使えます。例えばforループの中で、わざとメソッドを分離したくない(命名がめんどくさいとか…)の場合に使えるでしょう。また、やはりScope Functionなので、処理の範囲を明確に区分するためにも使えそうですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (name &lt;span style="color:#66d9ef">in&lt;/span> names) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with(name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> rev = &lt;span style="color:#66d9ef">this&lt;/span>.reversed()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reversedName.add(rev)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="let">let
&lt;/h3>&lt;p>オブジェクトをトリガーにして、そのオブジェクトを持って何かの処理を行いたい場合に使うものです。&lt;code>let&lt;/code>の意味通り、そのオブジェクトを持って何かをするというイメージですね。また、戻り値も最後の結果となるので、それを持ってまた何かができそうです。また、&lt;a class="link" href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls" target="_blank" rel="noopener"
>Safe Call&lt;/a>な使い方ができるため、Nullではない場合のみの動作として指定することも可能です。なのでNullになり得るオブジェクトでは、&lt;code>let&lt;/code>を使った方が良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> name: String? = &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#f92672">?.&lt;/span>let { println(&lt;span style="color:#e6db74">&amp;#34;name is not null&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="apply">apply
&lt;/h3>&lt;p>Lambdaでレシーバーの関数を使わず、レシーバーそのものを返却する場合に使います。つまり、レシーバーのプロパティに新しい値を入れる場合のことです。代表的にはオブジェクトの初期化がありますね。もちろん初期化だけなら、コンストラクタを呼ぶだけで十分ではないかと思われますが、同じオブジェクトの値を入れ替える(例えばConfigurationクラスなど)場合に役立つらしいです。例えば以下のような場合を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (devMode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeConfig().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#e6db74">&amp;#34;devMode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="run">run
&lt;/h3>&lt;p>他の4つの関数で事足りるので、なるべくこれは使わないように、という話が多いです。確かに、runはノーマルな関数としても使えるので(&lt;code>run {}&lt;/code>)、&lt;code>with&lt;/code>との違いがいまいちわからない感覚ではありますね。あえて使う場合は、オブジェクトの値をオーバーライドする時だそうです。でも、これも&lt;code>let&lt;/code>でできるので、あえて使う必要はなさそうです。多くのケースで、これは推奨されてませんでした。&lt;/p>
&lt;p>ただ、一部ではオブジェクトの初期化として使うと便利と言ってました。確かに&lt;code>this&lt;/code>を使うので、少しながら&lt;code>it&lt;/code>を使う&lt;code>let&lt;/code>よりコードが短くなり得るというメリットはありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// runを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> result1 = server.run {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port = &lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/members:&lt;/span>&lt;span style="color:#e6db74">$port&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// letを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> result2 = server.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">it&lt;/span>.port = &lt;span style="color:#ae81ff">8081&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/members:&lt;/span>&lt;span style="color:#e6db74">${it.port}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="also">also
&lt;/h3>&lt;p>オブジェクトがトリガーとなり、そのオブジェクトとは関係のない別の処理を行います。なので、元のオブジェクトがNullであっても、そのオブジェクトが呼ばれた時点でなんらかの処理を行うことができます。これを応用すると、条件分岐(三項演算子)のように使うことも可能です。例えば、こんな感じですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> name: String? = &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#f92672">?.&lt;/span>let { println(&lt;span style="color:#e6db74">&amp;#34;name is not null&amp;#34;&lt;/span>) } &lt;span style="color:#f92672">?:&lt;/span> also { println(&lt;span style="color:#e6db74">&amp;#34;name is null&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="まとめ">まとめ
&lt;/h3>&lt;p>&lt;a class="link" href="https://medium.com/@brijesh1794/kotlin-standard-library-let-run-also-apply-with-bb08473d29fd" target="_blank" rel="noopener"
>Kotlin Standard Library (let, run also, apply, with)&lt;/a>では、5つのScope Functionのどれを使うか判断する基準を、フローチャートとして提示しています。以下は、そのフローチャートを簡単に翻訳したものです。どれを使うか悩ましい時は、こういう基準でコードを書いても良さそうですね。&lt;/p>
&lt;p>&lt;img src="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function.webp"
width="3483"
height="1203"
srcset="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function_hub9435f29393cab452e8e19d463370875_69328_480x0_resize_q75_h2_box_2.webp 480w, https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function_hub9435f29393cab452e8e19d463370875_69328_1024x0_resize_q75_h2_box_2.webp 1024w"
loading="lazy"
alt="Kotlin Select Scope Function"
class="gallery-image"
data-flex-grow="289"
data-flex-basis="694px"
>&lt;/p>
&lt;h2 id="応用">応用
&lt;/h2>&lt;p>Scope Functionが戻り値としてレシーバーそのものを返すというのは、すなわちBuilderパターンとして使えるという意味でもあります。なので、適切な組み合わせで、Scope Functionによるメソッドチェーンもできます。これをよく活用すると、かなり関数型的な感覚でコードを書くことができるでしょう。以下は、その例の一つです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// letの連鎖
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> three: Int = &lt;span style="color:#e6db74">&amp;#34; abc &amp;#34;&lt;/span>.let { &lt;span style="color:#66d9ef">it&lt;/span>.trim() }.let { &lt;span style="color:#66d9ef">it&lt;/span>.length }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// alsoの連鎖
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">var&lt;/span> jack: Person = Person(&lt;span style="color:#e6db74">&amp;#34;Jack&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#a6e22e">Gender&lt;/span>.MALE).also { println(&lt;span style="color:#66d9ef">it&lt;/span>.name) }.also { &lt;span style="color:#66d9ef">it&lt;/span>.doWarmingUp() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>実は、このようなKotlinの機能は、そう新しいものでもありません。なぜなら、同じJVM言語であり、同じく機能する&lt;code>with()&lt;/code>のような関数を提供している&lt;a class="link" href="http://groovy-lang.org" target="_blank" rel="noopener"
>Groovy&lt;/a>があるからです。自分の中では&lt;a class="link" href="http://spockframework.org" target="_blank" rel="noopener"
>Spock&lt;/a>かGradleのイメージしかないのですが…&lt;/p>
&lt;p>ただ、このようにKotlinが提供する機能は「新しくはないけど、快適」という感覚を確かに伝えてくれているような気がします。なのでJavaプログラマーがKotlinに転向していく数も増えているのでしょう。最近は特にPythonやJavaScriptのような言語が人気を得ているところですが(Kotlinは&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE&lt;/a>の順位からだと見えもしないし…)、もっと性能と安定性、そして快適な開発のバランスを持ちたいと思う人にはぜひおすすめしたい言語です。なのでもっと、Kotlinの魅力をより多くの人(自分を含め)にわかった欲しいところです。今回のポストで少しはそれが伝わると幸いですね。&lt;/p>
&lt;p>では、また!&lt;/p></description></item><item><title>JavaプログラマーがみたKotlin</title><link>https://retheviper.github.io/posts/kotlin-first-impression/</link><pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post JavaプログラマーがみたKotlin" />&lt;p>KotlinがAndroidの公式言語になってからもだいぶ長い時間が経ちましたが、まだまだWebアプリケーションの業界ではサーバサイド言語としてはJavaを使う企業も多く(自分の場合がそうです)、モバイル業界でもJavaを使うところが多いようです。Javaも9以降はアジャイル開発でバージョンアップにスピードを出していて、いわゆるモダンな言語の特徴を吸収していってますが、そもそもの言語のデザインが古いし、互換性のために昔ながらの名残を捨てられてないところもあるので根本から違う哲学でデザインされた言語とはかなり違うはずです。また、JVMを利用しない&lt;a class="link" href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener"
>Kotlin Native&lt;/a>も発表されているので、今後Javaよりも活躍できる場面が多いかも知れないなーという気がしたりもします。(&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>は使われることあるのかな…)&lt;/p>
&lt;p>取りまとめ、まだ正式の研修とかを受けたわけでなく、あくまでSpring WebFluxを使って簡単なアプリを作ってみるついでに使ってみただけなので、よくわかってない部分も多いかと思いますが、今まで触れてみた感想をJavaプログラマーの観点から簡単に紹介したいと思います。&lt;/p>
&lt;h2 id="これがよかった">これがよかった
&lt;/h2>&lt;p>まずは使ってみてよかったところから。結論からとなりますが、良いと思ったところはおおよそイメージ通り(期待してた通り)という感覚です。&lt;/p>
&lt;h3 id="やはりモダンな感じ">やはりモダンな感じ
&lt;/h3>&lt;p>Kotlinで書いたコードを見ると、モダンな言語だとやはりこんなものかなという感覚ではあります。モダンな言語が何か、という定義から必要になるのではという気もしますが、例えばSwift、Kotlin、Goみたいなものですね。あまり他の言語に詳しいわけではないのですが、これらの言語はなんとなくPythonに似ているような気がします。例えば&lt;code>var&lt;/code>、&lt;code>fun&lt;/code>のように基本文法で略語をよく使っていたり、型の指定はコロンの後につけたり、セミコロンがなかったり、&lt;code>in&lt;/code>や&lt;code>Range&lt;/code>、&lt;code>is&lt;/code>があるなどの共通点があったりしますので。他には、言語の使用ではないけど、一般的にはGetter/Setterを使わずフィールドに直接アクセスするところですかね。(おかげでLombokを使う必要がないのも便利ではあります)&lt;/p>
&lt;p>ただ、そんなモダンな感覚でありながらも、やはりKotlinはJavaよりな感覚ではあります。厳格なJavaをよりゆるくしただけの感覚といえばいいでしょうか。例えばPythonだと&lt;code>elif&lt;/code>なのですが、Kotlinでは&lt;code>else if&lt;/code>だったりしますので。JVM言語という理由だけでなく、基本文法からしてもJavaプログラマーならすぐに適応できる言語でもあります。例えばforループにラベルをつけることができたりします。&lt;/p>
&lt;p>あえてJavaとの比較をするとしたら、やはり冗長さを省けただけでなく、Javaという言語のデザインを根本的に変えようとしている気もしていました。例えばNullや、Mutableを扱う方式がそうです。Kotlinでは基本的に変数はNullになれなくて、Nullになれるオブジェクトは最初からそうであると宣言する必要があり、Nullになれるオブジェクトを扱う時もSafe Callを強制することでNullに対してはコンパイラレベルではできるだけサポートしている感覚です(おそらくこれはモダンな言語だと全部がそうですが)。そしてCollectionなどを宣言する時も、あえてMutableという宣言をしない限りは基本的にImmutableなオブジェクトが生成されます。これだけでもJavaでもっともよく見つかるNPEをよく避けられる気がしてしまいます。いちいち宣言して、コールもクエスチョンマークをつける必要があるのは面倒臭いことな気もしますが、コンパイルエラーの方がランタイムエラーよりはずっとマシだというのは我々みんなが知っていることではないでしょうか。&lt;/p>
&lt;p>あとは、個人的にPythonで使ってみてよかったなと思った機能がKotlinにもあってよかったです。例えばMultiple Return(複数の戻り値)だったり、Named argument(名前付き引数)があります。前者は特に、Pair/Tripleという型で明確な戻り値を提示できるのが素晴らしいと思います。こういうところはモダンながらも、Javaの持つ安定性もしくは丈夫さを捨ててなかったなという印象を与えてくれました。&lt;/p>
&lt;p>ただ、これらのメリットは最近のJavaもかなり近づいている状態ではあります。(まだ少し遅い感はありますが)&lt;/p>
&lt;h3 id="クラスファイルではない">クラス=ファイルではない
&lt;/h3>&lt;p>Javaの場合は、一つのファイルには一つのクラスというのが常識のようになっています。もちろんInner Classを書く場合もありますが、それだと名前とおりクラスの中に含まれたものになるので、インスタンスを生成するときに複雑だったりしますね。でもKotlinだと、純粋なクラスを一つのファイルに複数書くことができます。&lt;/p>
&lt;p>なので、似たようなクラスを一つのファイルの中に集めておくことができますね。例えばDTO、DAO、Entityなど似たようなクラスが複数損際するパターンでは、一つのファイルの中にそれらを集めておいた方がパッケージの中が複雑にならないような気がします。実際、Kotlinを試しながら好みの領域の話かもしれませんが。&lt;/p>
&lt;p>どちらかを選択できる自由があるというのが、必ずしも良いこととは言い切れませんが、ファイル内にクラスを複数書くかどうかはキメの問題であって実装時のコーディングスタイルに影響を与えるものではないので(今時importを直接書く人もいないだろうし…)、良い点として挙げられるのではないか、と思います。&lt;/p>
&lt;h3 id="拡張関数で自由に関数を追加できる">拡張関数で自由に関数を追加できる
&lt;/h3>&lt;p>Javaのデメリットとしてよく挙げられているのが、冗長すぎる(verbose)ということです。いわゆるBoilerplateなコードを毎回書かなくてはならないというのは、生産性の面からもよくないです。Javaにこういう面があるので、さまざまなデザインパターンが発達したり、IDEでコードを自動生成してくれたり、Lombokのようにコードの量を減らしてくれるライブラリが人気だったりしますね。自分が開発に参加したフレームワークの開発の案件も、結局は冗長化するコードを減らしたいという目的によるものでした。&lt;/p>
&lt;p>とにかく、Kotlinはこういう問題に対する反発ないしは反省から言語がデザインされているようにも見えます。最近のモダンな言語の特徴をコピーしただけでなく、Javaを改善させたいという強い意志が言語のデザインから感じ取れているような感覚でした。&lt;/p>
&lt;h3 id="スタンダードライブラリがとにかく便利">スタンダードライブラリがとにかく便利
&lt;/h3>&lt;p>拡張関数が便利な理由ともつながるようなことですが、Kotlinのスタンダードライブラリに存在する関数たちもまた同じ観点から便利といえます。例えば、すでに有名なのがいわゆる&lt;code>Scope Functions&lt;/code>の&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="_blank" rel="noopener"
>let&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" target="_blank" rel="noopener"
>with&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="_blank" rel="noopener"
>run&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html" target="_blank" rel="noopener"
>also&lt;/a>のような関数です。&lt;/p>
&lt;p>これらはJavaだと別途ユーティリティクラスを作るか、プライペートなメソッドを定義するか、特定のクラスを継承してからオーバライドで関数を新しく定義するなどの方法で対応はできるものの、やはり手間がかかるのでやりたくはないものです。これをKotlinでは、より関数型的な方法で解決してくれます。例えばletの例を見ていきましょう。以下のようなdata classがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Member&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> region: String, &lt;span style="color:#66d9ef">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このdata classのインスタンスを一つ作成します。そうすると以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> john = Member(&lt;span style="color:#e6db74">&amp;#34;Tokyo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとで、同じくMemberのインスタンスとしてjakeという変数を追加するとします。jakeは常にjohnと同じregionである必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> jake = Member(&lt;span style="color:#e6db74">&amp;#34;Tokyo&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをJavaの考え方で、コードを整理するとしたら以下のようになります。regionを同じインスタンスを使うようにすることですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> tokyo = &lt;span style="color:#e6db74">&amp;#34;Tokyo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> john = Member(tokyo, &lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> jake = Member(tokyo, &lt;span style="color:#e6db74">&amp;#34;Jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをletを使う場合のコードとして書くと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> jake = john.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Member(&lt;span style="color:#66d9ef">it&lt;/span>.region, &lt;span style="color:#e6db74">&amp;#34;jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>共通のregionを別途変数として宣言したくても、jakeのregionはjohnに指定したregionと同じ値となります。そしてある意味、こちらの方が「johnとjakeは同じregionを共有する」という意図がコードの中によく表れているのではないか、という気もします。今は簡単なフィールドを共有しているだけですが、変数の数が増えたり処理すべき項目が多くなった場合はいちいち定数を宣言するよりも、このような書き方の方がより優雅になるのではないか、と思います。そういう意味では、かなり洗練された方法を提供していますね。同じことをJavaでまねるとしたら…あまりやりたくなくなりそうです。&lt;/p>
&lt;h2 id="これはいまいち">これはいまいち
&lt;/h2>&lt;p>KotlinがJavaのさまざまな問題や不便さに注目し、それらの多くを解消してくれたのは事実ですが、果たして&lt;code>全て&lt;/code>Javaより発展しているか、というとそうでもないような気もします。ただし、ここであげているKotlinの問題点ないしデメリットは、メリットと同様、個人的な見解なので参考までに。&lt;/p>
&lt;h3 id="varと型">varと型
&lt;/h3>&lt;p>モダンな言語から接した人なら、変数の宣言が&lt;code>var&lt;/code>だけで集結するのはメリットと言いたくなるかもしれません。実際Kotlinだけでなく、JavaScriptやC#など現代に使われる大体の言語は&lt;code>var&lt;/code>に対応していて、あのJavaすらも10から&lt;code>var&lt;/code>による変数の表記を導入しています。また、Pythonのようにそもそも&lt;code>var&lt;/code>の宣言すらいらない言語があったりもしますね。&lt;code>var&lt;/code>をつけることで変数であることが明確だという考え方から来てるのか、Javaとは違って関数も&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88" target="_blank" rel="noopener"
>First Class Object&lt;/a>として扱う言語としては関数と同様に表記したいからそうしてるのか、よくわかってないのですが、どっちかというと流行りのもののようです。&lt;/p>
&lt;p>こういう傾向だけを見ると、「変数は変数であることが分かればいい」というだけの話になっているようにも思えます。しかし、私はこの&lt;code>var&lt;/code>が果たして良いものであるかという疑問を持っています。Javaに慣れすぎていて、新しいのを受け入れられてない、もしくは&lt;code>var&lt;/code>の良さをわかってないだけかもしれませんが、とにかく「型指定で変数であることも、型もわかるからこっちの方が良くないか」と思ってしまいます。&lt;/p>
&lt;p>こう思うまたの理由は、モダンなプログラミング言語の中でもTypeScriptのように、あえて型指定ができるように既存の言語を変えようとする動きもあるからです。Pythonの場合も3.6から型を宣言できるようになっています。これ自体が、「変数は変数であることが分かればいい」から「変数の型もわかった方がいい」に変わっているように見えます。ただ、問題は最初から型指定で変数を指定する方法がなく、&lt;code>var&lt;/code>しかない言語に型指定(型注釈)が付く場合です。&lt;code>var&lt;/code>のメリットである短くかけるというところが、型指定をすることで台無しになります。&lt;/p>
&lt;p>例えば、Kotlinでの&lt;code>var&lt;/code>だけの宣言だと以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> a = &lt;span style="color:#e6db74">&amp;#34;this is string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして&lt;code>var&lt;/code>に型を指定すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> b: String = &lt;span style="color:#e6db74">&amp;#34;this is string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの伝統的な書き方だと以下です。こちらの方が、むしろコードは短くなるし、変数であることも明確ではないでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;this is string&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、厳密にいうと変数ではないところでは&lt;code>var&lt;/code>をつけないのは当たり前なのかもしれませんが、Javaだと変数でも戻り値でも引数でも型をつけてしまうのに対して、Kotlinではこれらに&lt;code>var&lt;/code>をつけるか型をつけるか方が省略できるかという場面がそれぞれ区別されてしまうので、これだけはJavaよりも厳格じゃないか？という気になったりもします。例えば以下のような例です。&lt;/p>
&lt;p>関数の引数の場合は、型の指定が必要です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#66d9ef">it&lt;/span>.username, &lt;span style="color:#66d9ef">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして関数の戻り値は、型推論により省略可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>(request: ServerRequest) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#66d9ef">it&lt;/span>.username, &lt;span style="color:#66d9ef">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これはあくまで関数をSingle Expressionで書いた時の話です。明示的にreturnを書く場合は戻り値を省略するとコンパイルエラーになります。例えば以下のような場合がそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// これはコンパイルエラー(戻り値はUnitとなってしまう)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getMember&lt;/span>(request: ServerRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(&lt;span style="color:#a6e22e">MediaType&lt;/span>.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#66d9ef">it&lt;/span>.username, &lt;span style="color:#66d9ef">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、data classの場合はフィールドに&lt;code>val&lt;/code>か&lt;code>var&lt;/code>をつける必要があります。しかし、一般的なクラスを宣言する場合は要りません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// data classではvalかvarが必要
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MemberDto&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> username: String, &lt;span style="color:#66d9ef">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// classなら必要ない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MemberEntity&lt;/span>(username: String, name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通常はコンパイルエラーになるので、慣れるまではKotlinのルールに従ってコードを見直すしかないのですが、Javaからの入門だとかなり混乱する部分です。(自分だけかもしれませんが…)&lt;/p>
&lt;h3 id="依存関係">依存関係
&lt;/h3>&lt;p>プロジェクトにKotlinを使う場合はスタンダードライブラリを追加して使う必要があります。ただ、ここで&lt;code>kotlin-stdlib&lt;/code>だけを追加すると、Java 1.7以降に追加された一部の機能(AutoCloseableなど)を使えなくなります。なので、Java 1.7以降の機能を使いたい場合は&lt;code>kotlin-stdlib-jdk7&lt;/code>か&lt;code>kotlin-stdlib-jdk8&lt;/code>を依存関係に追加する必要があります。&lt;/p>
&lt;p>個人的にはOracleとGoogleの訴訟沙汰のようなことがあって、わざと著作権を避けるための独自のパッケージを作ったりしらからではないかなと思いましたが、実際はJava 9から導入されたModuleシステムに対応するための理由だそうです。なので&lt;code>kotlin-stdlib-jre7&lt;/code>が&lt;code>kotlin-stdlib-jdk7&lt;/code>に、&lt;code>kotlin-stdlib-jre8&lt;/code>が&lt;code>kotlin-stdlib-jdk8&lt;/code>に代替されたらしいですね。&lt;/p>
&lt;p>とにかく、これらのスタンダードライブラリを使うには、MavenやGradleのような依存関係を管理するパッケージマネージャを使って一回だけ登録しておけばよく、そこまでめんどくさくはないことなのかもしれませんが、例えば&lt;code>kotlin-stdlib-jre8&lt;/code>があったりするので、初めはどれを選べば良いか、どれが必要であるかを把握するのにも時間を使ってしまうことになるのでデメリットになるのではないかと思います。例えば&lt;code>kotlin-stdlib-jdk7&lt;/code>がなくても、AutoCloseable以外のJDK 1.7の機能は使えたりするのですが、今から作るプロジェクトや既存のプロジェクトにAutoCloseableが使われるかどうかで依存関係をまた追加するかどうかを調べるのもかなり面倒くさそうです。&lt;/p>
&lt;p>そしてJDK7やJDK8対応のスタンダードライブラリが別途存在するということは、今後JavaがバージョンアップしたらまたJDK 17などの新しいスタンダードライブラリが追加される可能性があるということでもあるでしょう。7(1.7)と17はよく勘違いしそうだし…あと、JDK以外の依存関係のパッケージが色々あるので(&lt;code>kotlin-reflect&lt;/code>など)、プロジェクトの構成によってはKotlinの導入にはかなり慎重になる必要がありそうです。ある意味、KotlinがPost Javaとしてのポテンシャルは十分でありながらも、Androidアプリの作成以外にではあまり導入されてないのはこのような理由もあるのではないかという気もしています。&lt;/p>
&lt;h2 id="最後に">最後に
&lt;/h2>&lt;p>簡単にPros・Consに分けて自分が感じたKotlinに対して書いてみました。実はまだ本格的な案件で触れてみたわけでもないので、&lt;a class="link" href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="noopener"
>Type aliases&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/docs/reference/inline-classes.html" target="_blank" rel="noopener"
>inline class&lt;/a>のような良さそうな機能に触れてもないです。でもやはり、使えば使うほど魅力的な言語であるなと感じているところです。なので個人的な意見としては、すでにJavaを使っているところなら本格的にKotlinへの移行を考慮しても良いのでは、と思っています。Javaプログラマーなら慣れやすく、より生産性も高いながら、Javaとの100%の互換性も担保されているので…言語の完成度やJVM対応でありながらNative、JavaScriptとの連動も可能なのを見るとまさにPost Javaとして相応しい言語なのではないかと思うくらいです。(他のJVM言語には悪いですが…)&lt;/p>
&lt;p>そういう意味で皆さん、今からでもKotlinやりませんか！&lt;/p></description></item></channel></rss>