<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kotlin on Korean-man in Tokyo</title><link>https://retheviper.github.io/categories/kotlin/</link><description>Recent content in kotlin on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 22 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/categories/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlinのこれからを語る</title><link>https://retheviper.github.io/posts/kotlin-prospect/</link><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-prospect/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinのこれからを語る" />&lt;p>1年ほどサーバサイドKotlinを扱いながら、ふと「今のKotlinはどこまできていて、これからはどうなるんだろう」と思うようになりました。色々な観点があると思いますが、とりあえず市場においてどれほどの需要があり、展望（これからも積極的に採用され続けそう、苦戦しそうなどの）はどうかなど、いわゆるkotlinという言語の「ステータス」について自分が感じていることについて考えてみたくなったというわけです。&lt;/p>
&lt;p>最近のトレンドを見ると、一つの言語において専門家になるというよりはさまざまな言語を使いこなせる、いわゆる&lt;code>Polyglot&lt;/code>なプログラマが求められていて、常識みたいになっているとも言われているようです。確かに私自信もその経験があるかどうかは関係なく、案件によりさまざまな言語に触れるケースを多くみています。そして今は充実したドキュメントや記事をインターネットに溢れていて、UdemyやCourseraなど良質の講義を提供するサイトも色々とあるので経験がない言語だとしても入門が難しくてできないとは言えない時代になっている感覚でもあります。なので、自分が現在使っている言語がメインストリームに属してあるかどうかの問題は以前よりは重要でなくなった、といえるかも知れません。&lt;/p>
&lt;p>ただ、立場や観点によっては一つの言語に集中したい場合もあるかと思います。例えば学生や、未経験からエンジニアに転職しようとする人にいきなり二つ以上の言語を扱えるように注文するのは難しいことでしょう。エンジニアの追求する技術においてもそうです。フロントエンドエンジニアがいきなり今すぐ使う予定でもないGoやJavaのようなバックエンドで使われる言語を勉強する必要はないはずです。そして会社としては、複数の言語を扱えるエンジニアを求めるということは採用において非常に厳しい条件となるはずです。なので、依然として市場において一つの言語のステータスというのは無視できないものなのではないかと私は思っています。&lt;/p>
&lt;p>というわけで、今回は多少主観的な観点からの話になりますが、他の言語や分野で、Kotlinという言語の展望について考えてみたことを述べたいと思います。それでは、どうぞ。&lt;/p>
&lt;h2 id="vs-java">vs Java&lt;/h2>
&lt;h3 id="better-javaという捉え方">Better javaという捉え方&lt;/h3>
&lt;p>Kotlin(JVM)をJavaと比べると、コンパイル結果がバイトコードを生成するため、「Javaと互換性が完璧であり、性能もまた変わらない」というのが世間一般でいうKotlinの評価ではないかと思います。その上拡張関数やCoroutine、スコープ関数、Null安全性などさまざまな機能が揃っているので、表面上は&lt;code>better java&lt;/code>と読んでも良いのではないかと思わせる面もあります。それに、JavaのバージョンアップでJVMの改良が行われると、結局それもKotlinの改善につながることとなりますね。Javaも1.8以降は半年に1回のリリース政策によりバージョンアップが早くなっていまずが、まだアプリケーションエンジニアの立場からするとKotlinと比べ惜しいところもなくはないかなと思います。&lt;/p>
&lt;p>ここまでの話だと、Kotlinは完璧にJavaを代替できる言語であるかのように聞こえます。つまり、これからは全くJavaを使う理由はなくて、何もかもKotlinに移行するという選択肢しかないかのようにですね。しかし、業界の事情はどうなのでしょうか。&lt;/p>
&lt;p>まずJavaの歴史から考えてみましょう。Javaは長い間、「世界で最もよく使われる言語」であって、他の言語が人気を得た今でもTop 5に入るほどの人気な言語となっています&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。そしてこれが示唆するのは、単純に今の人気、つまり、「これからも使われる可能性」だけの話ではなく、「今まで使われた回数」が圧倒的に高いということも意味するという点です。今まで作られた多くのシステムやアプリケーションがJava基盤になっているので、余程のことがない限りは維持保守や機能の拡張においてJavaのエンジニアを求めることになるでしょう。&lt;/p>
&lt;p>また、こういう側面もあります。JVM言語としてJavaのメリットを活かしつつ、より発展したコードを書けるというコンセプトで登場した言語はKotlinだけではないということです。今までClojure・Scala・Groovyなどさまざまな言語が登場し、それぞれの言語がそれなりの需要や分野を確保・拡張できてはいるものの、そのうちどれも「Javaを超えた」という評価をもらってはいないのが現状かと思います。同じくKotlinの場合も、その立場が他のJVM言語と大きく変わっているとは言えないものではないでしょうか。なので、「JVM言語だ」「Javaよりモダンだ」という特徴は、少なくともKotlinが今後Javaを超えられるという根拠にはならないかと思っています。&lt;/p>
&lt;p>モバイルではAndroidの言語としてJavaよりKotlinを採用する例が多くなっているかと思いますが、これはOracleとGoogleの訴訟絡みでJavaを1.8しか使えなかったことも理由の一つかと思います。現在Javaがよく使われているWebの場合、OpenJDKのバージョンに特に法理的な問題もなく、Java 17からはOracleJDKも無償で利用できるようになったので、モバイルとはまた状況は違うのではないかと個人的には思っています。&lt;/p>
&lt;p>もちろん、上記の問題はJetbrainsでもその点は最初から認識していたため、最初からKotlinがJavaと相互運用できる言語として設計した部分はあります。なので、あくまで既存のJavaアプリケーションをKotlinでリプレイスする、というよりは、部分的な移行から新規開発で占有率を徐々に上げていくことを目標としているのではないかと思います。その戦略は十分に納得できるもので、あとは企業の方でJavaとKotlinという二つの言語を同時に運用することに抵抗がなければ、Javaを使っていた場合でも問題なくKotlinを受け入れられると思います。実際、自分の場合でもJavaからKotlinの移行は全く問題ありませんでした。&lt;/p>
&lt;h3 id="kotlinも強くなる">Kotlinも強くなる&lt;/h3>
&lt;p>最近のフレームワークやライブラリの方をみると、まだKotlinがモバイル以外の分野での認知度は劣るものの、少しづつJavaがメインストリームであった分野で採用されているケースが増えてきているような気もします。例えば、自分が仕事で使っている&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.kotlin" target="_blank" rel="noopener"
>Spring boot&lt;/a>、&lt;a class="link" href="https://github.com/FasterXML/jackson-module-kotlin" target="_blank" rel="noopener"
>Jackson&lt;/a>、&lt;a class="link" href="https://github.com/awslabs/aws-sdk-kotlin" target="_blank" rel="noopener"
>AWS SDK&lt;/a>などウェブアプリケーションで有名なものがKotlinに対応していて、他にも&lt;a class="link" href="https://www.jooq.org/doc/latest/manual/getting-started/jooq-and-kotlin/" target="_blank" rel="noopener"
>jOOQ&lt;/a>、&lt;a class="link" href="https://jooby.io/v1/doc/lang-kotlin/" target="_blank" rel="noopener"
>jooby&lt;/a>、&lt;a class="link" href="https://javalin.io/" target="_blank" rel="noopener"
>Javalin&lt;/a>のようにJavaとKotlinの両方に対応しているものも増えています。&lt;/p>
&lt;p>もしくは、Javaで存在していたライブラリをKotlin向けに調整したものもあります。例えば&lt;a class="link" href="https://tornadofx.io/" target="_blank" rel="noopener"
>TornadoFX&lt;/a>、&lt;a class="link" href="https://github.com/grpc/grpc-kotlin" target="_blank" rel="noopener"
>gRPC&lt;/a>、&lt;a class="link" href="https://github.com/ReactiveX/RxKotlin" target="_blank" rel="noopener"
>RxKotlin&lt;/a>のようなものがそうです。そして、最初からKotlin専用として設計されたものも少なくないです。&lt;a class="link" href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener"
>Kotlin Serialization&lt;/a>、&lt;a class="link" href="https://github.com/cbeust/klaxon" target="_blank" rel="noopener"
>Klaxon&lt;/a>、&lt;a class="link" href="https://github.com/Netflix/dgs-framework" target="_blank" rel="noopener"
>DGS&lt;/a>、&lt;a class="link" href="https://www.ktorm.org/" target="_blank" rel="noopener"
>Ktorm&lt;/a>、&lt;a class="link" href="https://github.com/kotest/kotest" target="_blank" rel="noopener"
>Kotest&lt;/a>、&lt;a class="link" href="https://github.com/mockk/mockk" target="_blank" rel="noopener"
>MockK&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener"
>Exposed&lt;/a>、&lt;a class="link" href="https://litote.org/kmongo/" target="_blank" rel="noopener"
>KMongo&lt;/a>、&lt;a class="link" href="https://github.com/JetBrains/xodus" target="_blank" rel="noopener"
>Xodus&lt;/a>、&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>、&lt;a class="link" href="https://github.com/Kodein-Framework/Kodein-DI" target="_blank" rel="noopener"
>Kodein-DI&lt;/a>などがそうですね。なので、Javaの世界に寄生していた数年前とは違って、Kotlinだけでもウェブアプリケーションを十分構築できるレベルまできているのではないか、というのが自分の考えです。&lt;/p>
&lt;p>結論として、まだ二つの言語を比べると、Javaの方が圧倒的に規模はでかく、知名度でも上にあるのですが、Kotlinも競争できる力を身につけてきたので、これからは十分状況が変わる可能性がある、と思っています。&lt;/p>
&lt;h2 id="vs-go">vs Go&lt;/h2>
&lt;h3 id="早いの美徳">「早い」の美徳&lt;/h3>
&lt;p>仕事でGoを使っている立場からすると、Kotlinに比べGoの優越な側面はやはり「とにかく早い」ということではないかと思います。基本的にネイティブにコンパイルされる言語なのでランタイム性能も優秀なはずですが、コンパイルもビルドもとにかく早いのは確かに良いなと思いました。特に、コードの修正後にユニットテストで検証してみることが多いのですが、Kotlinのプロジェクトと比べるととにかく早いのでストレスがないですね。(Kotlinの場合は使っているウェブフレームワークがSpringで、テストケースがより多い、ビルド時にはシングルスレッドでやっているということもありますが)&lt;/p>
&lt;p>そのほかにもGitHubのパッケージをそのまま使えたり、別途ライブラリを使わなくてもstructをすぐにJSONとして扱える(&lt;code>omitempty&lt;/code>とかも便利な場面がある)なところは印象的で、かなりウェブ開発に特化されているなという印象までありました。ネイティブなのでビルドして生成されるバイナリのサイズが小さいのも良いですね。これらの特徴からして、最近トレンドとなっているサーバレスやマイクロサービスなどおいてはKotlinよりGoを採用した方が有利な面が多いかなと思います。&lt;/p>
&lt;p>まだサーバがクラウド上のVMに移行したばかりの頃は、JVMを使う言語の問題はだいたいマシンスペックの向上により無視できました。しかし、サーバレスとマイクロサービスアーキテクチャが流行りながらJVMの特徴が再び問題となってきていますね。まずサーバレスだと、JVMが完璧にロードされるまで時間がかか理、コールドスタートに時間がかかります&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。また、マイクロサービスにおいては、JVMが占めるヒープメモリとストレージが増えることでインスタンスごとのコストが増えるという問題が挙げられています。&lt;/p>
&lt;h3 id="kotlin--遅い">Kotlin != 遅い&lt;/h3>
&lt;p>このような問題に対して、サーバレスだと&lt;a class="link" href="https://site.kotless.io/" target="_blank" rel="noopener"
>Kotless&lt;/a>のようなフレームワークが開発されていたり、&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>を利用してネイティブビルドができる&lt;a class="link" href="https://ja.quarkus.io/" target="_blank" rel="noopener"
>Quarkus&lt;/a>や&lt;a class="link" href="https://github.com/spring-projects-experimental/spring-native" target="_blank" rel="noopener"
>Spring Native&lt;/a>が開発されるなど、JVM言語でも最近のトレンドに合わせて改善が行われていはいます。&lt;/p>
&lt;p>ランタイム性能という面では、JITによる最適化でJVM言語でもGoには劣らないという面もありますね。ベンチマークを見ると&lt;a class="link" href="https://programming-language-benchmarks.vercel.app/go-vs-kotlin" target="_blank" rel="noopener"
>Kotlin/JVMとの比較&lt;/a>や&lt;a class="link" href="https://www.lambrospetrou.com/articles/kotlin-http4k-graalvm-native-and-golang/" target="_blank" rel="noopener"
>Kotlin/Native&lt;/a>でわかるように、Goに対してKotlinが性能で劣る部分もあれば、優位にある部分もあるのがわかります。&lt;/p>
&lt;p>また、&lt;a class="link" href="https://go.dev/blog/intro-generics" target="_blank" rel="noopener"
>Go 1.18でジェエリックが導入&lt;/a>されていますが、&lt;a class="link" href="https://planetscale.com/blog/generics-can-make-your-go-code-slower" target="_blank" rel="noopener"
>ジェネリックにより遅くなる可能性がある&lt;/a>という話もあり、これからもしGoに新しい機能が追加されるとしたら、それがコンパイル速度やランタイム性能に影響を及ぼす可能性もあるかなと思います。&lt;/p>
&lt;p>なので、KotlinとGoという二つの言語で考えると、少なくともパフォーマンスという観点だけではGoにこだわる必要はないかなと思います。しかし、アプリケーションの開発において言語を選ぶ基準はパフォーマンスだけでなく、生産性やクラウドで対応している言語、エンジニアが確保できるかなど色々な側面があるので、Goの代わりにKotlinを選んだほうが効率的だとは言えないのも事実です。自分が転職を決めた時も、サーバサイドではGoのエンジニアを募集している企業の方がKotlinより多かったのですが、単純にパフォーマンスが基準だとしたらこのようなことにはならなかったでしょう。Googleが推している言語であるとか、パフォーマンスだけでなく生産性の面でも優れているなどさまざまな理由が複合的に作用した結果だと言えるものかと思います。&lt;/p>
&lt;h3 id="それでも有利なのは">それでも有利なのは&lt;/h3>
&lt;p>あとは、そもそもの知名度の問題ですね。Kotlinにおいて、ネイティブイメージのビルドができ、性能が劣らないとしても、多くの場合はKotlinをモバイル(Android限定)用の言語だと認識しているのが一般的かなと思います。なので、このような認識がエンジニアと企業で変わらない限り、これからもGoの方がサーバサイドでは市場において優位に立つという状況がしばらくは続くのではないかと思っています。&lt;/p>
&lt;p>他にも、Goはその書きやすさからや入門のしやすさの人気もあると思いますが、それを踏まえると比較的書き方が複雑なKotlinの方が劣るのではないかという推測もできそうですね。自分にとってはKotlinの書き方が簡潔で良い感覚ですが、Goの書き方を簡潔だと思っている方もいるようです。確かに、キーワードが少なく、それらを覚えるのに労力が比較的少ないなら、よりロジックに集中した書き方ができるはずですね。Goで作られたアプリやCLIツールなどが増えているのも、そのような特徴からのものなのではないでしょうか。自分の場合は簡単なツールを作るときはPythonで書くのを好みますが、同じく気軽にコードが書ける稼働かの観点でいうと、KotlinよりGoが優れているとも言える気がします。なので、個人の趣味やサイドプロジェクトなどでよく使われ、それがまた人気につながるだろうと思うと、Goを好むエンジニアが増えるのもおかしくはないですね。&lt;/p>
&lt;h2 id="vs-rust">vs Rust&lt;/h2>
&lt;h3 id="最強の性能">最強の性能？&lt;/h3>
&lt;p>GCがないので同じネイティブでありながらもGoより性能が優秀だというRustですが、これもまたKotlinと同じく、知名度の問題で苦戦しているところがあるかなと思います。そもそもC/C++を代替するのが開発の目的でもあったため仕方ないのかもしれませんが、どちらかというとエンベデッドで使われるイメージがどうしてもあるような気がしますね。意外と&lt;a class="link" href="https://www.figma.com/" target="_blank" rel="noopener"
>Figma&lt;/a>、&lt;a class="link" href="https://1password.com/jp/" target="_blank" rel="noopener"
>1Password&lt;/a>、&lt;a class="link" href="https://discord.com/" target="_blank" rel="noopener"
>Discord&lt;/a>、&lt;a class="link" href="https://www.dropbox.com/" target="_blank" rel="noopener"
>Dropbox&lt;/a>、&lt;a class="link" href="https://www.mozilla.org/ja/" target="_blank" rel="noopener"
>Mozilla&lt;/a>、&lt;a class="link" href="https://line.me/ja/" target="_blank" rel="noopener"
>Line&lt;/a>、&lt;a class="link" href="https://www.npmjs.com/" target="_blank" rel="noopener"
>npm&lt;/a>、&lt;a class="link" href="https://www.cloudflare.com/ja-jp/" target="_blank" rel="noopener"
>Cloudflare&lt;/a>などさまざまな組織で採用されていて、&lt;a class="link" href="https://github.com/ogham/exa" target="_blank" rel="noopener"
>exa&lt;/a>、&lt;a class="link" href="https://github.com/sharkdp/bat" target="_blank" rel="noopener"
>bat&lt;/a>、&lt;a class="link" href="https://github.com/Wilfred/difftastic" target="_blank" rel="noopener"
>difftastic&lt;/a>、&lt;a class="link" href="https://github.com/ClementTsang/bottom" target="_blank" rel="noopener"
>bottom&lt;/a>などのCLIツールから&lt;a class="link" href="https://yew.rs/" target="_blank" rel="noopener"
>yew&lt;/a>、&lt;a class="link" href="https://seed-rs.org/" target="_blank" rel="noopener"
>seed&lt;/a>、&lt;a class="link" href="https://dioxuslabs.com/" target="_blank" rel="noopener"
>Dioxus&lt;/a>、&lt;a class="link" href="https://rocket.rs/" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://github.com/http-rs/tide" target="_blank" rel="noopener"
>tide&lt;/a>、&lt;a class="link" href="https://github.com/poem-web/poem" target="_blank" rel="noopener"
>poem&lt;/a>のようなGUIやウェブフレームワークなどがたくさん開発されていますが、これもまた特に調査してみないとわからないくらいです。&lt;/p>
&lt;p>さまざまなベンチマークでその性能が検証されていて、使ってみたエンジニアからも評判の高いものとなっているRustですが、やはり知名度が低いので、企業からも採用するのはかなり難しい判断になるでしょう。実際Jetbrainsの去年の設問では&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/rust/#Rust_how-do-you-use-rust" target="_blank" rel="noopener"
>Rustは趣味もしくは個人用途、サイドプロジェクトで使う&lt;/a>と答えた割合のエンジニアが多かったのを見ると、やはり企業の需要はあまりようです。ただ、逆にいうと、このようにRustに好意的なエンジニアが増え、さまざまなプロジェクトで使われ始めるといつか市場の状況も変わっていく可能性もあるということです。先ほど述べたGoのケースのように、比較的に歴史の短い若い言語でも十分その価値を立証できるのであれば市場でもメインストリームに合流できます。なので、Rustの未来はむしろ明るく、これからが期待される言語だと個人的には思っています。ただ、人気を得た後も、ウェブアプリケーションを開発するよりは今まで通りエンベデッド・システムプログラミングに特化していきそうな気がしますね。&lt;/p>
&lt;h3 id="kotlinをネイティブにしたら">Kotlinをネイティブにしたら&lt;/h3>
&lt;p>RustをKotlinとの比較をするとしたら、Kotlin/Nativeがあるので、言語自体でできることはそう変わらないものの、Rustがエンベデッドやシステムプログラミングという分野でC/C++を代替していく傾向があるのに対して、これといった成果があまり見当たらないというのが問題かなと思います。特にKotlin/NativeはLLVM基盤なので、GraalVMによるネイティブコンバイるができるウェブフレームワークが登場している今はますますそのポジションが曖昧なものになっている気もします。Object-CやC/C++とのinteropができると言われていますが、そのようなユースケースだとそもそもObject-CやC/C++といった言語を使った方が色々と有利なのではないでしょうか。もちろん、Rustには所有権のような概念があり、他の言語と比べプログラミングが難しいとされているので、Kotlin/Nativeを採用した方がコーディングは楽になるかもしれません。でも、Nativeを追求するならやはりパフォーマンスが重視される場面が多いので、そこではGCのあるKotlinが不利な気がしますね。このような面からすると、やはりKotlin/Nativeのポジショニングが難しそうな気がします。&lt;/p>
&lt;p>結論としては、Kotlin(JVM)とRustはそれぞれ特化した分野が違っていて、大きな変化がない限り互いの領域を蝕むことなく発展していきそうです。どちらかというとKotlin/Nativeが直接的なライバルになる可能性はありますが、そもそものポジショニングが曖昧なところがあるので、Nativeがどうしても必要な場面ではRustが使われる可能性が高いのではないか、という気がしています。&lt;/p>
&lt;h2 id="vs-python">vs Python&lt;/h2>
&lt;h3 id="万能ツール">万能ツール&lt;/h3>
&lt;p>ここ数年で最も人気を得ている言語の一つ、Pythonの場合は、Kotlinと比べて見るとどうでしょうか。まず自分の場合だと、日常での自動化や簡単なツールを作る場面ではPythonの方をよく使っていて、本格的なウェブアプリケーションを開発するとしたらKotlinを選ぶことが多いです。もちろん、なんでもできる言語なので大規模のアプリケーションを作るのにPythonがNGというわけではないです。実際Uber、Google、PayPal、Netflixなど有種の企業がPythonを使っていて、あの有名なInstagramのサーバサイドもPythonで書かれていると言われていますね。&lt;/p>
&lt;p>ただやはり、PythonはデータサイエンスやAIといった分野でよく使われているイメージがあり、使いやすく、そこまで性能が求められていない場面でなら良いものの、個人的にはその限界が明確であることが問題かなという気もします。本格的な業務用のアプリを開発した経験がないのであくまで印象と推測の話となりますが、Pythonをサーバサイドに取り入れている企業は大概がスタートアップであって、サービスが古くなるとインタープリター言語特有のメンテが難しくなるという問題が出てくる可能性が高いではないかと思いますね。JavaScriptの例もありますが、Pythonのタイプヒントはあくまでヒントであって、TypeScriptのようにコンパイルタイムで検出できるエラーを確実にわかるわけでもないです。あとは性能ですが、&lt;a class="link" href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener"
>GIL&lt;/a>のような問題もあります。このような問題を認識しているため、検証用のアプリ(プロトタイプ)をPythonで書いてから他の言語に移行するという例もあるのかなと思ったりしています。&lt;/p>
&lt;h3 id="pythonだけの領域でもないが">Pythonだけの領域でもないが&lt;/h3>
&lt;p>逆にKotlinでいうと、Jupyterを使えるなど&lt;a class="link" href="https://kotlinlang.org/docs/data-science-overview.html#kotlin-libraries" target="_blank" rel="noopener"
>Kotlinでもデータサイエンスに使える&lt;/a>のですが、すでにPythonが市場支配的な言語になっているところでどこまで伸びるかが問題な気がしますね。JetBrainsが主張するように、Pythonと比べ「静的型付け、Null安全性、パフォーマンス」というのは確かにKotlinが持つメリットではあるのですが、そもそものユーザ数が増える何かがないと占有率を上げるのはかなり難しくないのではないかと思います。Pythonは入門が簡単なので講座も多く、実際エンジニアではない人も使うケースが多いのですが、Kotlinはまだそのような面では弱い印象ですね。&lt;/p>
&lt;p>以上のことからして、Pythonは依然としてデータサイエンスなど元々強かった分野に対してはこれからも需要が大きく変わることはなさそうです。ウェブという分野では競合になる可能性はありますが、どちらかというとKotlinを採用した方がより安定した開発ができるので大規模なアプリの開発ではKotlin、小規模ではPythonという形になるのではないかと思います。もちろん、大規模のアプリを開発するにあたってはまたの選択肢があるのでKotlinではない他の言語が採用される可能性の方が高そうですが、あくまで二つの言語を比べた場合の話となります。&lt;/p>
&lt;h2 id="vs-javascript">vs JavaScript&lt;/h2>
&lt;h3 id="多芸多才">多芸多才&lt;/h3>
&lt;p>一つの言語でなんでもできちゃう言語が何かというと、過去はJava、少し前はPython、そして今はなんといってもJavaScriptではないかと思います。フロントエンド、バックエンド、モバイル、データサイエンスなどさまざまな分野で活躍している言語ですね。ランタイムの性能が問題となっている部分に対しても&lt;a class="link" href="https://deno.land/" target="_blank" rel="noopener"
>Deno&lt;/a>のような新しいランタイムが登場したり、V8エンジンの持続的な改善によりだんだん補完されていって、静的型付けに関してもTypeScriptの台頭によって解決されています。まさに無敵の言語のようにも見えます。&lt;/p>
&lt;p>フロントエンドにおいてはJavaScript以外は考えられない&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>というのもあり、&lt;a class="link" href="https://webassembly.org/" target="_blank" rel="noopener"
>WebAssembly&lt;/a>のような技術も発達していますが、これはまたウェブの画面描画だけでなく違う方向に向かっているような感じなので、これから何かあって(あるとは思いませんが)色々な分野で使われなくなるとしてもJavaScriptそのものが使われなくなることはないでしょう。そして同じ意味で、Kotlinがそのような分野に進出するのもかなりハードルが高いと思います。&lt;/p>
&lt;h3 id="kotlinでフロントエンド">Kotlinでフロントエンド？&lt;/h3>
&lt;p>Kotlinで言えば、Kotlin/JVMとKotlin/Native以外に3つの軸として存在しているのが&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>であり、JetBrainsの発信を見るとそこそこ力を入れている感覚ではあります。他にも、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-mpp/" target="_blank" rel="noopener"
>Compose Multiplatform&lt;/a>を通じて、モバイルだけでなくウェブやデスクトップアプリにおいてもKotlinでGUIを作成できるようになったので、なるべく自分のサイドプロジェクトなどではKotlinで完結したいと思っている私の場合はこちらも応援したいと思っています。ただ、まだモバイル以外ではそこまでメジャーではなく、新しい技術の問題(ライブラリの不足、バージョンアップによる変化が激しいなど)が考えられるのでしばらくは様子見な感じですね。あと自分のような特殊な目的がない場合は、個人でも企業側としても無理して採用すべきメリットが薄いという問題もあるかなと思います。&lt;/p>
&lt;p>バックエンドだとKotlinが競合になる可能性はまだ十分ではないかと思います。特に、今までJavaが採用されていた分野だと主にJVMの安定性や数値計算の精度など検証された安全性というものがあるので、これから言語を変えるとしたらKotlinを採用する確率が高いのではないかと思っているところですが、そのような分野だと、最初からJavaScriptによるバックエンドの採用は考えない可能性が高そうです。スタートアップのようにエンジニアの求人が難しく、使われる技術の数を減らしてなるべく工数の削減しようとするか、Pythonのようにプロトタイプのアプリを作るかなどの特殊な状況ではない限り積極的にバックエンドの言語としてJavaScriptを採用する例はあまりなさそうな気がしていて、これからもおそらくそれは大きく変化していく気はしません。ただ、自分のようにKotlinで何もかも解決したい、という方がJavaScript側にもいらっしゃるとしたら、そこはまた話が変わってくるかも知れませんね。フロントエンド、バックエンド、モバイル、デスクトップまで対応したい場合にはJavaScript以上のものがないので、その会社や個人の目的次第でJavaScriptが採用される可能性は高く、そのような状況こそKotlinは採用されない可能性が高いかなと思います。&lt;/p>
&lt;h2 id="vs-dart">vs Dart&lt;/h2>
&lt;h3 id="guiの最強者">GUIの最強者？&lt;/h3>
&lt;p>Dartの場合は、言語そのものというよりは&lt;a class="link" href="https://flutter.dev/" target="_blank" rel="noopener"
>Flutter&lt;/a>が最近熱いですね。最初はモバイルでクロスプラットフォーム開発ができるということで注目されたものですが、Dartに対してはFlutterの最大の競合は&lt;a class="link" href="https://reactnative.dev/" target="_blank" rel="noopener"
>React Native&lt;/a>だと言えるかなと思いますが、それも最近のトレンドを見ると少しづつ逆転してきているような気がします。もちろんこれはあくまでも「クロスプラットフォーム用のフレームワーク」という基準での比較であり、実際は色々と複雑な事情があるでしょう。例えば、フロントエンドエンジニアがモバイルの開発も担当していて、フロントエンドのライブラリとしてはReactを使っているなどの状況を考えると、ここでいきなりFlutterを採用する可能性は低くなるはずですので。&lt;/p>
&lt;p>自分が思うにDartの最大の問題は、その最初の意図(JavaScriptを代替するという)はともかく、言語そのものの印象が薄いということです。少しだけ触ってみた感覚では、いわゆるC-Family言語としての馴染みはあっても、特段ここが魅力的だというところはあまり感じ取れなかったです。それが今はFlutterのおかがで使用率は上がってきていますが、それ以外の分野ではどうかなという疑問がまだあります。&lt;/p>
&lt;h3 id="可能性は他にもあるかもだけど">可能性は他にもあるかもだけど&lt;/h3>
&lt;p>ただ、以前からGoogleの次世代OSである&lt;a class="link" href="https://fuchsia.dev/" target="_blank" rel="noopener"
>Fuchsia&lt;/a>ではメインの開発環境となるという噂もあり、FuchsiaそのものがどんなOSになるかはまだ不明な状態ですが、もし噂通りAndroidの次世代のOSになるとしたら、ネイティブの開発そのものがDartによるものにもなり得る可能性はありますね。もしそうなると、ChromeOSを含めレガシーの環境を捨てることになるので、公式の開発の言語にKotlinを指定した時とは比べ物にならないインパクトがあることを想定すると、なかなか想像できない事態です。&lt;/p>
&lt;p>もちろんDartもプログラミング言語なので、これからのフレームワークやライブラリの開発次第でいくらでも状況は変わる可能性があります。&lt;a class="link" href="https://github.com/yissachar/awesome-dart" target="_blank" rel="noopener"
>こちらのリポジトリ&lt;/a>を参照すると、サーバサイドのフレームワークもすでにいくつか存在しているので、自分の考えているKotlinで全てを解決する、という目標においてはむしろDartの方がやりやすい可能性がありますね。Kotlinの方だと&lt;a class="link" href="https://kotlinlang.org/lp/mobile/" target="_blank" rel="noopener"
>Kotlin/Multiiplatform Mobile&lt;/a>がありますが、これはどちらかというとビジネスロジックの共通化を目標としているものなので、結局iOSのコードを書く必要があります。もちろん、一部の企業でやっているように「UIはFlutterで、ビジネスロジックはネイティブで」ということもできるかとは思いますが、あまりメジャーなやり方にならないかなと思います。実際、Swiftの場合も&lt;a class="link" href="https://vapor.codes/" target="_blank" rel="noopener"
>Vapor&lt;/a>のようなフレームワークがあり、サーバサイドでも十分使えるということをアピールしていますが、採用しているエンジニアや企業が限りなく少ないというのを見ると、単純に「できる」だけでは十分ではなさそうですので。&lt;/p>
&lt;h3 id="モバイルでも強くなっていく">モバイルでも強くなっていく&lt;/h3>
&lt;p>特に今年開催された&lt;a class="link" href="https://io.google/2022/intl/ja/" target="_blank" rel="noopener"
>Google I/O&lt;/a>で確認できるように、Flutter 3ではさらにパフォーマンスの向上やFlutter Desktopの正式リリースなど様々な面での発展を見せていて、これからもFlutterの未来は明るく見えます。Flutterを採用している企業も増えてきているので、このような発展の恩恵を受け入れるのは結局時間の問題に過ぎない気がします。もちろん、ネイティブアプリの開発においても需要はこれからもあり得ると思いますが、クロスプラットフォームアプリでも事足りる分野が増えてくるとしたら、どちらがメインストリームになるかは目に見えるようなものですね。&lt;/p>
&lt;p>このような状況では、今の占有率においてKotlinのホームグラウンドとなっていると言っても過言ではないモバイルの分野で、Flutterの成長ぶりはある意味、Kotlinにおいては脅威のようなものではないかという気がします。なので、これからKotlinならではのメリットをより強化していく必要がありそうですね。先の述べたKotlin/Multiplatform Mobileのようなものが、その役割をしてくれるのではないかと期待しています。そのほかでも、Kotlinでできることは多いので、分野を問わない連携を強化していくと十分Kotlinを利用するメリットはこれからも出てくるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は、いつもと違って自分の考えが中心になる記事なので、色々と偏った判断があるかも知れませんが、とりあえずKotlinエンジニアとしての感想をまとめてみました。もちろん、自分の知見が足りてなく、モバイルやフロントエンド、データサイエンティスト、DevOpsエンジニアなど色々な分野で活躍されている方からしたら色々と間違っているか、的確ではない情報や判断も目立つかなとも思います。&lt;/p>
&lt;p>ただ、一人のエンジニアとして、ただの時流を淡々と見つめているよりは、目指す目標に対して使っている技術や興味のいくものに注目し、自分なりの判断をしてみるのもまた必要なものではないかという気がして、このような記事を作成することになりました。また、このような記事を作成することで、この後に色々な変化があって自分の展望がどれだけあっているか、実際と比べてみるのもまた有意義な振り返りとなりそうな気もします。&lt;/p>
&lt;p>今回はあまり情報がなく、Twitterにでもつぶやいたら良いかも知れない雑談に近いものですが、少しでもここでKotlinのことを改めて認識できたという方がいらっしゃるなら幸いです。&lt;/p>
&lt;p>では、また！&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a class="link" href="https://spectrum.ieee.org/top-programming-languages" target="_blank" rel="noopener"
>IEEE Spectrum&lt;/a>、&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE&lt;/a>、&lt;a class="link" href="https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-programming-scripting-and-markup-languages" target="_blank" rel="noopener"
>Stack Overflow&lt;/a>、&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/devecosystem-2021/#Main_programming-languages" target="_blank" rel="noopener"
>Jetbrains&lt;/a>の調査結果を参照しました。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Warm(アイドルインスタンスを常に立ち上げておく)で対応できる部分ではありますが、スケールアウトするとコールドスタートが必要となる場合があり、インスタンスを立ち上げておくことでコストがかかる問題は避けられないですね。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>Dartのような言語でJavaScriptを代替しようとした歴史がありますが、今は失敗していて、JavaScriptがより高度化した今はTypeScriptのようなスーパーセットやJavaScriptにトランスパイルできる言語でないとフロントエンドの言語を代替するのは難しいかと思われます。&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Effective Kotlinを読む</title><link>https://retheviper.github.io/posts/effective-kotlin/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/effective-kotlin/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Effective Kotlinを読む" />&lt;p>今回は久々に本を読んだのでそれに関する感想を少し書こうと思います。転職前は主にJavaを扱っていたため、&lt;a class="link" href="https://www.amazon.co.jp/Effective-Java-%E7%AC%AC3%E7%89%88-%E3%82%B8%E3%83%A7%E3%82%B7%E3%83%A5%E3%82%A2%E3%83%BB%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF-ebook/dp/B099922DML/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=1OT3QRYCGG9BB&amp;amp;keywords=Effective&amp;#43;Java&amp;amp;qid=1645265607&amp;amp;sprefix=effective&amp;#43;kotlin%2Caps%2C753&amp;amp;sr=8-1" target="_blank" rel="noopener"
>Effective Java&lt;/a>を読み自分の書いたコードを振り返って見たことがありました。転職後はKotlinという違う言語を触るようになったものの、やはりJVMで動く言語であり、現在使っているフレームワークもSpringから変わってないので基本的には同じ観点でコードを作成すると良いのかなと思っていました。しかし、Kotlinに触れてから1年が経った今、やはり言語が違うとコードを作成するときの週間も一度は見直す必要があるのではないかと思っています。&lt;/p>
&lt;p>そこで、ちょうど&lt;a class="link" href="https://www.amazon.co.jp/Effective-Kotlin-Best-practices-English-ebook/dp/B08WXCRVD2/ref=sr_1_1?__mk_ja_JP=%E3%82%AB%E3%82%BF%E3%82%AB%E3%83%8A&amp;amp;crid=2HVT6TZYJL65A&amp;amp;keywords=effective&amp;#43;kotlin&amp;amp;qid=1645264802&amp;amp;sprefix=effective&amp;#43;kotli%2Caps%2C230&amp;amp;sr=8-1" target="_blank" rel="noopener"
>Effective Kotlin&lt;/a>という本を発見したので早速読んでみました。そして今回のポストではその内容について色々と書こうと思います。&lt;/p>
&lt;p>ちなみに、この本自体は出版されて少し経つので、ネット上でもたまにその内容やPDFの資料などを発見することあができました。例えば、この本で「可読性」のチャプタに関しての話は[こちらのブログ]の方によく整理されてあるので、参考にしてください。&lt;/p>
&lt;h2 id="全体的な印象">全体的な印象&lt;/h2>
&lt;p>個人的に&lt;code>Effective Java&lt;/code>は上級者向けの本で、ある程度Javaでアプリを書いたこと経験のある人でないと理解が難しいところが多かったかなと思います。例えば、「&lt;code>try-finally&lt;/code>を
&lt;code>try-with-resource&lt;/code>に代替した方がいい」とか、「&lt;code>Stream&lt;/code>で副作用のない関数を書く方法」などが紹介されていますが、これらはやはりある程度Javaという言語の設計と仕様に対する基盤知識を必要とするものですね。&lt;/p>
&lt;p>それに比べ、&lt;code>Effective Kotlin&lt;/code>には初心者向けの内容も結構あります。例えば、そもそものオブジェクト志向が何かのような内容がありました。ただそれだけではどう思っても&lt;code>Effective Java&lt;/code>を意識したような題名が意味をなくすと判断したからか（前書きでも&lt;code>Effective Java&lt;/code>を言及しています）他には「ベストプラクティス」として書かれているものも多いです。&lt;/p>
&lt;p>そして当たり前ながら、Kotlinにおいても有効なことは&lt;code>Effective Java&lt;/code>と重なっているような部分もあります。例えば、オブジェクトのインスタンスを作るときはfactory methodを書いた方が良いとかがそうですね。&lt;/p>
&lt;p>ただ、Kotlinのバージョンアップの速さに追いついてないと感じるところがあったり（これは出版物の限界でもありますが）、上級者向けの内容は多少十分ではない感覚でしたので、どちらかというとジュニア向けの感覚ではあります。&lt;/p>
&lt;h2 id="興味深い">興味深い&lt;/h2>
&lt;p>ジュニア向けといいつつ、自分もまだジュニア（の気持ち）であるため、興味深いと思ったところもありました。ここでその一部を紹介したいと思います。&lt;/p>
&lt;h3 id="single-responsibility-principle">Single responsibility principle&lt;/h3>
&lt;p>いわゆる&lt;a class="link" href="https://ja.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener"
>SOLID&lt;/a>に触れるパートです。Kotlinでは拡張関数を用いることで、単一責任の原則を守れるという主張をしていました。まず以下のようなケースがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">isPassing&lt;/span>(): Boolean =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calculatePointsFromPassedCourses() &amp;gt; &lt;span style="color:#bd93f9">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">qualifiesForScholarship&lt;/span>(): Boolean =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> calculatePointsFromPassedCourses() &amp;gt; &lt;span style="color:#bd93f9">30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">calculatePointsFromPassedCourses&lt;/span>(): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>isPassing()&lt;/code>は&lt;code>accreditations&lt;/code>というモジュールで、&lt;code>qualifiesForScholarship()&lt;/code>は&lt;code>scholarship&lt;/code>というモジュールで使われるとします。そしたら、&lt;code>Student&lt;/code>というクラスがこれらの関数を持つのは単一責任としてどうか、ということですね。&lt;/p>
&lt;p>なので、モジュール別にこれらの関数を拡張関数として定義することが良いとのことでした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// scholarship module
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>.qualifiesForScholarship(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// accreditations module
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>.calculatePointsFromPassedCourses(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしくは&lt;code>calculatePointsFromPassedCourses()&lt;/code>を外に出す方法を考えられるでしょう。しかし、この場合はこれらの二つのメソッド専用のprivateメソッドとしてつかえません。なので、&lt;/p>
&lt;ol>
&lt;li>どのモジュールでも使える共通関数を作っておく&lt;/li>
&lt;li>department別にhelper関数を作っておく&lt;/li>
&lt;/ol>
&lt;p>とかの方法も考えられます。&lt;/p>
&lt;p>確かに、よく考えると拡張関数の良いところは「interfaceの実装ややスーパークラスの継承なし」でも簡単に処理を追加できるということなので、このような使い方をするのがユースケース別に処理を分けられて良さげな気がします。特に拡張関数を使うと、関数を配置するパッケージと可視性の制御が効くというところが個人的には新しい発見でした。&lt;/p>
&lt;h3 id="consider-defining-a-dsl-for-complex-object-creation">Consider defining a DSL for complex object creation&lt;/h3>
&lt;p>オブジェクトの作成時の複雑な処理はDSLを使いましょう、というパートです。Kotlinですでに提供している例としたら、HTMLがありますね。以下のような形で定義することになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>body {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> div {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a(&lt;span style="color:#f1fa8c">&amp;#34;https://kotlinlang.org&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target = ATarget.blank
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +&lt;span style="color:#f1fa8c">&amp;#34;google&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> +&lt;span style="color:#f1fa8c">&amp;#34;Some content&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>確かにKtorのようなフレームワークでもよく使われている物なので、ある程度需要はあるのかなという気がしました。Kotlinだと高階関数を作るのが難しくはないので、十分挑戦できるところでもありますね。&lt;/p>
&lt;p>ただ、DSL特有の書き方を確立し、その書き方をエンジニアに共有することや最初の設計と維持管理が難しそうな気がするので、アプリの縮小が求められる今のご時世に果たして合うかとうかは少し疑問ののころところでした。&lt;/p>
&lt;p>個人的に何かのライブラリやフレームワークを作るとしたら、挑戦してみたいなと思いました。&lt;/p>
&lt;h2 id="まあそうだよねって思ったところ">まあそうだよねって思ったところ&lt;/h2>
&lt;p>なんとなくそうではないかと思っていたところを（もしくはどこかで聞いて理論的な部分は忘れたけど、無意識的のうちに習慣化されていた部分を）文として親切に整理してくれているようなパートもありました。なのでもう一度自分の考えを再確認できたといえるところでしょうか。&lt;/p>
&lt;h3 id="do-not-repeat-common-algorithms">Do not repeat common algorithms&lt;/h3>
&lt;p>「スタンダードライブラリで解決できる一般的なアルゴリズムを自前のコードで書くな」というパートです。理由は以下の通りです。&lt;/p>
&lt;ol>
&lt;li>呼び出しの方がコードを書くより時間が短くかかる&lt;/li>
&lt;li>わかりやすい名前になっている&lt;/li>
&lt;li>コードがわかりやすくなる&lt;/li>
&lt;li>最適化が効く&lt;/li>
&lt;/ol>
&lt;p>私自身もなるべくスタンダートライブラリを活用した方が良いと思っていたので、ここはすぐに納得できました。自分で書いた処理が果たして最適化されたものかどうかもわからないし、業務使用以外のロジックを触るのは避けたいという理由でした。&lt;/p>
&lt;p>この本では、以下のようなコードを上げています。自前のロジックを書いた場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> percent = &lt;span style="color:#ff79c6">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &amp;gt; &lt;span style="color:#bd93f9">100&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number &amp;lt; &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/coerce-in.html" target="_blank" rel="noopener"
>coerceIn()&lt;/a>を使うことでシンプルにできます。以下がその例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> percent = number.coerceIn(&lt;span style="color:#bd93f9">0&lt;/span>, &lt;span style="color:#bd93f9">100&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinには特にスタンダードラリブラリに良い関数が多いので、自前のロジックを書くよりは一度どんなAPIがあるのかを確認した方が良いケースが個人的には多かった気がします。そしてそれが納得できる理由が書いてあってよかったと思います。&lt;/p>
&lt;h3 id="implementing-your-own-utils">Implementing your own utils&lt;/h3>
&lt;p>スタンダードライブラリで解消できる問題以外で、プロジェクトに必要な共通の処理はユーティリティ関数として作っておきましょうってパートです。ユーティリティはクラスでなく、拡張関数として作ったら以下のようなメリットがあるらしいです。&lt;/p>
&lt;ul>
&lt;li>関数は状態を持たないので副作用がない&lt;/li>
&lt;li>トップレベル関数と比べると型が決まっているので使い勝手がいい&lt;/li>
&lt;li>引数よりはクラスについた形が直観的&lt;/li>
&lt;li>オブジェクトに関数をまとめるより必要な機能を探しやすい&lt;/li>
&lt;li>特定のクラスに従属されるので親クラスのものか、子クラスのものか悩まない&lt;/li>
&lt;/ul>
&lt;p>確かにJavaを使っていた時は、私もいわゆるSingleton Patternでユーティリティクラスを作ったり、DIして使えるクラスを定義しておいて、staticメソッドを書いていました。Kotlinだと、ユーティリティクラスなしでも特定のクラスに関数を追加することができるのでより使い勝手がよくなります。&lt;/p>
&lt;p>例えば、同じことをするとしても、拡張関数で書く場合とユーティリティクラスを作る場合のコードは以下のような違いがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 拡張関数を使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> isEmptyByExtension = &lt;span style="color:#f1fa8c">&amp;#34;Text&amp;#34;&lt;/span>.isEmpty()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ユーティリティクラスを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> isEmptyByUtilClass = TextUtils.isEmpty(&lt;span style="color:#f1fa8c">&amp;#34;Text&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ユーティリティクラスを使う場合はまず、「どのユーティリティクラスの関数を使うか」を考えなければならないです。それに比べ、拡張関数はIDEでも自動補完ですぐ欲しい関数を見つけることができるので、より直観的なものになっていますね。&lt;/p>
&lt;p>他にも具体的なクラスにのみ追加ができたりするので、より安全な使い方ができるというのも良いところですね。色々と拡張関数は使い道が多いなという、再発見ができたと言えるところでしょうか。&lt;/p>
&lt;h3 id="builder-pattern">Builder pattern&lt;/h3>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#named-arguments" target="_blank" rel="noopener"
>named arguments&lt;/a>が使えて、Builderパターンがいらないというパートです。KotlinでもBuilderパターンを使うことが技術的に不可能ではないが、named parameterを使った方が良い理由としては以下が挙げられています。&lt;/p>
&lt;ul>
&lt;li>より短い&lt;/li>
&lt;li>より綺麗&lt;/li>
&lt;li>使い方がシンプル&lt;/li>
&lt;li>スレッドセーフ&lt;/li>
&lt;/ul>
&lt;p>私自身も、Javaで使っていたのでKotlinでもBuilderパターンが必要かなと思ったことがありますが、いらないという結論を出しています。上記で挙げた理由ももちろん妥当ですが、Builderパターンだとインスタンスを生成するときに必須パラメータが揃っているかどうかを判断するのが難しくなるという理由からでした。&lt;/p>
&lt;p>例えば本に出てくるBuilderパターンの例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Pizza&lt;/span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">constructor&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> size: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> cheese: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> olives: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> bacon: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Builder&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> size: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> cheese: Int = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> olives: Int = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> bacon: Int = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">setCheese&lt;/span>(&lt;span style="color:#ff79c6">value&lt;/span>: Int): Builder = apply { cheese = &lt;span style="color:#ff79c6">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">setOlives&lt;/span>(&lt;span style="color:#ff79c6">value&lt;/span>: Int): Builder = apply { olives = &lt;span style="color:#ff79c6">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">setBacon&lt;/span>(&lt;span style="color:#ff79c6">value&lt;/span>: Int): Builder = apply { bacon = &lt;span style="color:#ff79c6">value&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">build&lt;/span>() = Pizza(size, cheese, olives, bacon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このBuilderは以下のような使い方ができると思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> villagePizza = Pizza.Builder(&lt;span style="color:#f1fa8c">&amp;#34;L&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setCheese(&lt;span style="color:#bd93f9">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setOlives(&lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .setBacon(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .build()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし以下の場合でもビルドはできますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> villagePizza = Pizza.Builder(&lt;span style="color:#f1fa8c">&amp;#34;L&amp;#34;&lt;/span>).build()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もし&lt;code>cheese&lt;/code>、&lt;code>olives&lt;/code>、&lt;code>bacon&lt;/code>が&lt;code>0&lt;/code>を許容しない作りになっていると、これを修正するのは大変なことになるでしょう。もしくは、パラメータが複雑な作りのオブジェクトだったらデフォルト値を設定するか、強制null check(&lt;code>!!&lt;/code>)などを入れるか…より複雑になるだけですね。&lt;/p>
&lt;p>しかし、named parameterを使うと簡単に解決できる問題です。デフォルト値を指定しない&lt;code>val&lt;/code>だったら、それが必須項目であるということもわかりやすいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> myFavorite = Pizza(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size = &lt;span style="color:#f1fa8c">&amp;#34;L&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cheese = &lt;span style="color:#bd93f9">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> olives = &lt;span style="color:#bd93f9">5&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bacon = &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="consider-factory-functions-instead-of-constructors">Consider factory functions instead of constructors&lt;/h3>
&lt;p>Javaでも最近は色々とfactory functionを導入していて、簡単にimmutableなオブジェクトを作りやすくなりました。Kotlinでもコンストラクタの作成や、named parameterによるインスタンスの生成が色々と便利ではあるものの、それでもfactory functionが良いケースがあるというパートです。理由は以下の通りです。&lt;/p>
&lt;ul>
&lt;li>関数には名前があるので、どうやってオブジェクトが生成されるかわかる
&lt;ul>
&lt;li>&lt;code>ArrayList(3)&lt;/code>よりは&lt;code>ArrayList.withSize(3)&lt;/code>がわかりやすい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>戻り値としてサブタイプのオブジェクトを指定できる
&lt;ul>
&lt;li>具体的な実装を時と場合によって違う形にすることができる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>呼び出されるたび新しいオブジェクトを作るわけではない
&lt;ul>
&lt;li>&lt;code>Connections.createOrNull()&lt;/code>のようにnullを返すこともできる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>まだ存在しないオブジェクトを提供できる
&lt;ul>
&lt;li>プロキシなしで動くようなオブジェクトを作るなどで応用できる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>オブジェクトの外に作ることで可視性を制御できる&lt;/li>
&lt;li>&lt;code>inline&lt;/code>にできるので、&lt;a class="link" href="https://kotlinlang.org/docs/inline-functions.html#reified-type-parameters" target="_blank" rel="noopener"
>reified&lt;/a>にもできる&lt;/li>
&lt;li>インスタンスを作るのが複雑なオブジェクトの手間を省く&lt;/li>
&lt;li>スーパークラスやプライマリコンストラクタを呼び出さずにインスタンスを生成できる&lt;/li>
&lt;/ul>
&lt;p>こちらも読みながらなるほどと納得しました。特に私の場合でも、Service層のDTOとController層のResponseなどのオブジェクト間のマッピングではfactory functionを導入してコードを再使用性を高められたと思っていたので、良い判断だったなと今は思っています。&lt;/p>
&lt;p>他に、factory functionを作る方法としても以下のようなものが提示されてありました。一般的にはcompanion object内に定義しておくことが多いかと思いますが、他の方法も必要であれば考慮したいものですね。&lt;/p>
&lt;h4 id="companion-object">companion object&lt;/h4>
&lt;p>Javaのstaticメソッドのようなパターン。最もわかりやすいですね。以下のような形です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyLinkedList&lt;/span>&amp;lt;T&amp;gt;(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> head: T,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> tail: MyLinkedList&amp;lt;T&amp;gt;?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">of&lt;/span>(&lt;span style="color:#ff79c6">vararg&lt;/span> elements: T): MyLinkedList&amp;lt;T&amp;gt;? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/*...*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Usage
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> list = MyLinkedList.of(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>factory functionは大体以下の規則を持って命名されるという説明もありました。&lt;/p>
&lt;h5 id="from">from&lt;/h5>
&lt;p>一つのパラメータを渡し、タイプを変える時（自分自身のインスタンスを返す）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> date: Date = Date.from(instant)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="of">of&lt;/h5>
&lt;p>複数のパタメータを渡し、それを束ねたタイプに変換するとき&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> faceCards: Set&amp;lt;Rank&amp;gt; = EnumSet.of(JACK, QUEEN, KING)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="valueof">valueOf&lt;/h5>
&lt;p>&lt;code>of&lt;/code>の冗長な形&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> prime: BigInteger = BigInteger.valueOf(Integer.MAX_VALUE)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="instance--getinstance">instance / getInstance&lt;/h5>
&lt;p>Singletonのインスタンス取得（パラメータが同じだと常に同じインスタンスが帰ってくる）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> luke: StackWalker = StackWalker.getInstance(options)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="createinstance--newinstance">createInstance / newInstance&lt;/h5>
&lt;p>instance / getInstanceは似ているが、常に新しいインスタンスを返す&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> newArray = Array.newInstance(classObject, arrayLen)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="gettype">getType&lt;/h5>
&lt;p>instance / getInstanceと似ているが、違うタイプのインスタンスを返すとき&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> fs: FileStore = Files.getFileStore(path)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="newtype">newType&lt;/h5>
&lt;p>createInstance / newInstanceに似ているが、違うタイプのインスタンスを返す時&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> br: BufferedReader = Files.newBufferedReader(path)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="extension">extension&lt;/h4>
&lt;p>クラスにからのcompanion objectを定義しておいて、外部から拡張関数でfactory functionを付ける形です。元のクラスをいじらなくても良くなるし、パッケージと可視性の制御など拡張関数の持つ特徴を活用できますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">interface&lt;/span> &lt;span style="color:#50fa7b">Tool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> { &lt;span style="color:#6272a4">/*...*/&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Tool&lt;/span>.Companion.createBigTool( &lt;span style="color:#6272a4">/*...*/&lt;/span> ): BigTool {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">//...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="top-level">top-level&lt;/h4>
&lt;p>スタンダードライブラリに含まれている、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html" target="_blank" rel="noopener"
>listOf()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/set-of.html" target="_blank" rel="noopener"
>setOf()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-of.html" target="_blank" rel="noopener"
>mapOf()&lt;/a>のようなものです。&lt;/p>
&lt;p>よく使うタイプに関しては使い勝手がいいので便利なものの、IDEの自動補完などに現れたら混乱するケースもあるので命名は慎重にする必要がある、とのことでした。&lt;/p>
&lt;h4 id="fake-constructor">fake constructor&lt;/h4>
&lt;p>Pascal Caseを使って、関数をコンストラクタに見せかけるものです。Kotlinのスタンダードライブラリとしては、以下のようなものがあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#bd93f9">4&lt;/span>) { &lt;span style="color:#f1fa8c">&amp;#34;User&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> } &lt;span style="color:#6272a4">// [User0, User1, User2, User3]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは実際は以下のような関数ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">init&lt;/span>: (index: Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): List&amp;lt;T&amp;gt; = MutableList(size, &lt;span style="color:#ff79c6">init&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">MutableList&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">init&lt;/span>: (index: Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> list = ArrayList&amp;lt;T&amp;gt;(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(size) { index &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> list.add(&lt;span style="color:#ff79c6">init&lt;/span>(index)) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはinterfaceに対してコンストラクタを作る必要があったり、&lt;code>reified&lt;/code>タイプの引数が必要な時に考慮できるものらしいです。&lt;/p>
&lt;p>他にもfake constructorを作る方法があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Tree&lt;/span>&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">operator&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">invoke&lt;/span>(size: Int, generator: (Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): Tree&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Usage
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Tree(&lt;span style="color:#bd93f9">10&lt;/span>) { &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、この場合constructor referenceではコードが複雑になる問題があるらしいですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> f: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#ff79c6">::&lt;/span>Tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Fake Constructor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> d: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Tree = &lt;span style="color:#ff79c6">::&lt;/span>Tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Invoke in companion object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> g: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Tree = Tree.Companion&lt;span style="color:#ff79c6">::&lt;/span>invoke
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なのでfake constructorを使うとしたら、関数として定義したほうがよさそうです。&lt;/p>
&lt;h4 id="factory-class">factory class&lt;/h4>
&lt;p>別途Factoryというクラスを置いてインスタンスを返すようにする方法ですね。Javaではinterfaceでそのようなことをするケースがありますが（&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/List.html#of%28E%29" target="_blank" rel="noopener"
>List.of()&lt;/a>みたいな）、Kotlinでも良いのか？という疑問が湧きました。結論から言いますと、「factoryクラスは状態を持つことが可能」なため、場合によっては考慮しても良いとのことです。これは思ったより活用できそうな可能性がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Student&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> id: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> surname: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">StudentsFactory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> nextId = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">next&lt;/span>(name: String, surname: String) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student(nextId&lt;span style="color:#ff79c6">++&lt;/span>, name, surname)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> factory = StudentsFactory()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> s1 = factory.next(&lt;span style="color:#f1fa8c">&amp;#34;Marcin&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Moskala&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(s1) &lt;span style="color:#6272a4">// Student(id=0, name=Marcin, Surname=Moskala)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> s2 = factory.next(&lt;span style="color:#f1fa8c">&amp;#34;Igor&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Wojda&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(s2) &lt;span style="color:#6272a4">// Student(id=1, name=Igor, Surname=Wojda)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>ざっくりなまとめとなりますが、以上が私のこの本で得られた知識への感想となります。新しい発見もあり、自分の習慣が間違ってなかったということを人の説明で補ってもらったような気にもなり、かなり興味深かったです。&lt;/p>
&lt;p>ただやはり、Kotlinがまだ新しい言語であり、いろいろなパラダイムを吸収しているためか、&lt;code>Effective Java&lt;/code>のようなレベルの高い作法に対する議論は少し足りてないような気がしていて、そこは多少残念に思います。まあ、こう思うようになったということ自体が、少しは自分が成長した証拠でもあるかなという生意気な想像もしてみるのですが。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinでデータの逆転グルーピング</title><link>https://retheviper.github.io/posts/kotlin-reverse-groupping/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-reverse-groupping/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinでデータの逆転グルーピング" />&lt;p>DBを設計する時と、最終的にアプリで活用するデータの形は大きく変わるケースがあります。特に後から機能を付け加えるとそうなりますね。もちろん正規化などを通じてより効率的にデータを保存する方法を考える必要のあるDBと、データをいかに加工して使うかを工夫するアプリの違いによるものもありますが、アプリの改修が続くと同じデータでも活用する箇所や表現の仕方が変わってくるからでもあるかなと思います。&lt;/p>
&lt;p>そういうわけで、今回はそのようなケースで一つ活用できる方法をご紹介したいと思います。アルゴリズムというわけでもありませんし、より効率的な方法はあるかなと思いますが、応用すれば結構色々な場所で使えそうな方法ではないかと思います。&lt;/p>
&lt;h2 id="シナリオ">シナリオ&lt;/h2>
&lt;p>例えば以下のようなシナリオがあるとします。&lt;/p>
&lt;ol>
&lt;li>社員はA、Bという二つの部署に配属される&lt;/li>
&lt;li>社員が部署に配属される日付はそれぞれ&lt;/li>
&lt;/ol>
&lt;p>この場合、データの作りには色々な観点があるかと思いますが、まず部署の配属日を基準にデータを作るとしたら、部署の種類、配属日とその日付に配属となった社員のリストを持つような形になるかと思います。Kotlinのコードとして表現するとしたら以下のような形ですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">enum&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">DepartmentType&lt;/span> { A, B }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Department&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> departmentType: DepartmentType,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> date: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> employers: List&amp;lt;Employer&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Employer&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> id: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで社員の3人がいて、それぞれ部署Aと部署Bに配属された日付が違うケースがあるとしましょう。データとしては、以下のようなものです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>社員番号&lt;/th>
&lt;th>部署A配属&lt;/th>
&lt;th>部署B配属&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>1月1日&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;td>2月1日&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上記のデータを持って、先ほどの部署のデータを実際のリストとして作るとしたら以下のようになるかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> departments = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = DepartmentType.A,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = LocalDate.of(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department.Employer(id = &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department.Employer(id = &lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = DepartmentType.A,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = LocalDate.of(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department.Employer(id = &lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = DepartmentType.B,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = LocalDate.of(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department.Employer(id = &lt;span style="color:#bd93f9">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentType = DepartmentType.B,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date = LocalDate.of(&lt;span style="color:#bd93f9">2022&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employers = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department.Employer(id = &lt;span style="color:#bd93f9">2&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Department.Employer(id = &lt;span style="color:#bd93f9">3&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、これを社員を基準に、それぞれの部署に配属された日付をデータとして加工するにはどうしたら良いでしょうか。社員番号と部署に配属となった日付の二つを持つような形です。例えば、コードで表現すると以下のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">JoinedDates&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> employerId: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> departmentA: LocalDate,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> departmentB: LocalDate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、やりたいことは先ほどの&lt;code>departments&lt;/code>を、最終的に以下のようなデータにしたいということですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">[
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> JoinedDates(employerId=EmployerId(value=1), departmentA=2022-01-01, departmentB=2022-01-01),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> JoinedDates(employerId=EmployerId(value=2), departmentA=2022-01-01, departmentB=2022-02-01),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b"> JoinedDates(employerId=EmployerId(value=3), departmentA=2022-02-01, departmentB=2022-02-01)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#50fa7b">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>データの整列の基準がひっくり返されるので、どうしたら良いかと悩ましくなる場面です。今回は、これを解決した自分の方法を紹介したいと思います。&lt;/p>
&lt;h2 id="ロジック">ロジック&lt;/h2>
&lt;p>Departmentを基準に考えるとEmployerのデータが複数になりますが、これを逆転させて、Employerを基準に複数のDepartmentを持つという形に加工したいというのが今回の要件です。だとすると、考えられるロジックは以下がポイントかなと思います。&lt;/p>
&lt;ol>
&lt;li>EmployerのID単位でまとめる&lt;/li>
&lt;li>EmployerごとにDepartmentをType別に分けた配列を持たせる&lt;/li>
&lt;/ol>
&lt;p>まずはネスとしているEmployerのリストに入り、そのIDを抽出する必要がありますね。このIDは重複させたくないので、MapのKeyにしておくと良さげです。&lt;/p>
&lt;p>あとは、そのMapにEmployerのIDがKeyとして存在するかどうかで以下の処理をすると良いでしょう。&lt;/p>
&lt;ol>
&lt;li>Keyが存在しない場合は、新しくDepartmentのタイプとその日付をinsert&lt;/li>
&lt;li>Keyが存在する場合は、そのvalueを取り出してDepartmentのタイプと日付を追加&lt;/li>
&lt;/ol>
&lt;p>なので、一回DepartmentのListをMapに変換して、さらにJoinedDatesのListに変換することとなります。ちょうど上記の分岐については、&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#compute-K-java.util.function.BiFunction-" target="_blank" rel="noopener"
>compute()&lt;/a>を活用するとできるので、中間データとしてのMapがどんな形になるかを考えると良いかなと思います。&lt;/p>
&lt;p>私の場合はMapの方がデータを取りやすいので、最終的には以下のような処理となりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;Department&amp;gt;.toJoinedDates(): List&amp;lt;JoinedDates&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 中間データ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> tempMap = mutableMapOf&amp;lt;Int, Map&amp;lt;DepartmentType, LocalDate&amp;gt;&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>.forEach { department &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Departmentのタイプとその日付のPair
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> departmentJoined = department.departmentType to department.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> department.employers.forEach { employer &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// EmployerのIDがKeyとして存在したら足して、なかったらMapを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> tempMap.compute(employer.id) { _, &lt;span style="color:#ff79c6">value&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">value&lt;/span>&lt;span style="color:#ff79c6">?.&lt;/span>let { &lt;span style="color:#ff79c6">value&lt;/span> + departmentJoined } &lt;span style="color:#ff79c6">?:&lt;/span> mapOf(departmentJoined)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 中間データをJoinedDatesのListに変えて返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> tempMap.map { (id, department) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JoinedDates(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employerId = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentA = department.getValue(DepartmentType.A),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentB = department.getValue(DepartmentType.B)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="共通ロジック化">共通ロジック化&lt;/h2>
&lt;p>ジェネリックを使ったclassとして上記のロジックを一部分離すれば、似たようなケースで色々使い回せるのではないかと思いましたので、以下のようなコードも書いてみました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Aggregator&lt;/span>&amp;lt;T, K, V, R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> tempMap = mutableMapOf&amp;lt;T, Map&amp;lt;K, V&amp;gt;&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// データの追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">add&lt;/span>(key: T, &lt;span style="color:#ff79c6">value&lt;/span>: Pair&amp;lt;K, V&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tempMap.compute(key) { _, existingValue &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> existingValue&lt;span style="color:#ff79c6">?.&lt;/span>let { existingValue + &lt;span style="color:#ff79c6">value&lt;/span> } &lt;span style="color:#ff79c6">?:&lt;/span> mapOf(&lt;span style="color:#ff79c6">value&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 指定したListとして取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getList&lt;/span>(transfer: (T, Map&amp;lt;K, V&amp;gt;) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R): List&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> tempMap.map { transfer(&lt;span style="color:#ff79c6">it&lt;/span>.key, &lt;span style="color:#ff79c6">it&lt;/span>.&lt;span style="color:#ff79c6">value&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これの場合は以下のような使い方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> aggregator = Aggregator&amp;lt;Int, DepartmentType, LocalDate, JoinedDates&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// データの追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>departments.forEach { a &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.employers.forEach { b &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> aggregator.add(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = b.id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">value&lt;/span> = a.departmentType to a.date
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Listの結果を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> joinedDates = aggregator.getList { id, joinedDate &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JoinedDates(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> employerId = id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentA = joinedDate.getValue(DepartmentType.A),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> departmentB = joinedDate.getValue(DepartmentType.B)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>汎用性はあるものの、呼び出し元のコードが増えたり、指定している型の意味や意図がよくわからないので適切なKDocやコメントがないと少しわかりにくいところがデメリットかも知れませんね。ただ大事なのは中間データの型と&lt;code>compute()&lt;/code>による分岐処理なので、そこだけをうまく取り出して他でも応用できるかなと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>サーバサイドKoltinだと、多くの場合にデータを&lt;code>List&lt;/code>として扱うのが普通かなと思いますが、場合によっては&lt;code>Map&lt;/code>を使うのもロジックを書いていく中では良い選択になるかと思います。特に、今回紹介した&lt;code>compute()&lt;/code>以外でも、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-or-put.html" target="_blank" rel="noopener"
>getOrPut()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/get-or-default.html" target="_blank" rel="noopener"
>getOrDefault()&lt;/a>などの機能が便利なので色々と活用できる場面が多いかなと思います。この処理は&lt;a class="link" href="../exposed-mapping-record-to-object" >前回のポスト&lt;/a>でも似たようなものを紹介したことがありますので、興味のある方はそちらも参考にしてください。&lt;/p>
&lt;p>プログラミング言語が提供するスタンダードライブラリは色々と見逃しやすいところがあるかなと思いますが、よくドキュメントや自動補完で一覧に登場する関数に注目すると、こういう風に必要なものがいきなり現れることもあるかと思います。まだ私もKotlinを触って1年ほどしか経ってないひよこなものなので、これからもどんどん新しい発見があると嬉しいなと思いますね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで和暦を使う</title><link>https://retheviper.github.io/posts/kotlin-japanese-era/</link><pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-japanese-era/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで和暦を使う" />&lt;p>帳票などで、たまに和暦を処理する必要な時がありますね。例えば元号を表記するとか、和暦の年度を表記するなどの場合があるかと思います。Kotlin(JVM)の場合、西暦だとJavaのAPIの&lt;code>Date&lt;/code>や&lt;code>LocalDate&lt;/code>などのAPIを使うと簡単ですが、和暦が必要となるのはごく一部のケースなので方法がなかなか分かりづらいかと思います。なので、今回はKotlinで和暦を扱う方法について少しまとめてみました。&lt;/p>
&lt;h2 id="japanseera--japanesedate">JapanseEra / JapaneseDate&lt;/h2>
&lt;p>Javaでは、1.8から和暦で日付を扱える&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseDate.html" target="_blank" rel="noopener"
>JapaneseDate&lt;/a>及び元号を扱える&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/chrono/JapaneseEra.html" target="_blank" rel="noopener"
>JapaneseEra&lt;/a>というAPIを提供しています。なので&lt;code>JapaneseDate&lt;/code>のインスタンスを作り、そこから&lt;code>JapaneseEra&lt;/code>を取得することで簡単に元号の情報を取得できるようになります。実際の使い方は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 現在日付のJapaneseDateを取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> japaneseDate = JapaneseDate.now()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// JapaneseEraの取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> japaneseEra = japaneseDate.era
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>JapaneseDate&lt;/code>の場合、&lt;code>LocalDate&lt;/code>と同じく&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/chrono/ChronoLocalDate.html" target="_blank" rel="noopener"
>ChronoLocalDate&lt;/a>を継承しているのでインスタンスを作成する方法はそう変わりません。なので、以下のようなこともできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// LocalDateをJapaneseDateに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> japaneseDateFromLocalDate = JapaneseDate.from(LocalDate.now())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 特定の日付を指定してJapaneseDate
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> japaneseDateFromSpecificDate = JapaneseDate.of(&lt;span style="color:#bd93f9">2000&lt;/span>, &lt;span style="color:#bd93f9">12&lt;/span>, &lt;span style="color:#bd93f9">31&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="元号を日本語で表記する">元号を日本語で表記する&lt;/h2>
&lt;p>和暦を扱う場合にやりたいことは大きく二つかと思います。一つは、元号を文字列として扱うこと、そしてもう一つは、和暦での年度を数字として扱うことです。まずは、元号を文字列として取得できる方法について説明します。&lt;/p>
&lt;p>まず上記で紹介した通り、&lt;code>JapaneseDate&lt;/code>のインスタンスを取得した上で、さらにそのオブジェクトが保持している&lt;code>JapaneseEra&lt;/code>を取得する必要があります。その後、&lt;code>JapaneseEra.getDisplayName()&lt;/code>という関数に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/format/TextStyle.html" target="_blank" rel="noopener"
>TextStyle&lt;/a>と&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/Locale.html" target="_blank" rel="noopener"
>Locale&lt;/a>を指定して文字列を取得することができます。前者は文字の出力型を指定する列挙型定数で、後者は言語の指定と思ってください。&lt;/p>
&lt;p>&lt;code>TextStyle&lt;/code>の場合、以下のような値があります。他の言語だと指定したものによって出力がかなり変わってくるかも知れませんが、日本語の場合は&lt;code>FULL&lt;/code>と&lt;code>NARROW&lt;/code>だけで十分ではないかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>定数&lt;/th>
&lt;th>出力例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>FULL&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>FULL_STANDALONE&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>NARROW&lt;/code>&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>NARROW_STANDALONE&lt;/code>&lt;/td>
&lt;td>S&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SHORT&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SHORT_STANDALONE&lt;/code>&lt;/td>
&lt;td>昭和&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>Locale&lt;/code>の場合、&lt;code>Locale.JAPAN&lt;/code>や&lt;code>Locale.JAPANESE&lt;/code>のどちらを指定しても結果は同じです。ただ、実装としては以下のようになるのでなるべく&lt;code>Locale.JAPAN&lt;/code>を使った方が良さそうです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Locale&lt;/th>
&lt;th>作られるBaseLocaleの設定&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>JAPAN&lt;/code>&lt;/td>
&lt;td>&lt;code>language = ja, region = JP&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>JAPANESE&lt;/code>&lt;/td>
&lt;td>&lt;code>language = ja&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以下はこれらの定数を渡して元号を文字列として取得する例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> today = JapaneseDate.now()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> era = today.era
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 元号を漢字で取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> eraName = era.getDisplayName(TextStyle.FULL, Locale.JAPAN) &lt;span style="color:#6272a4">// 令和
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元号だけでなく、年度までも合わせて表記したい場合もあるかと思います。その場合に使えるものは&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>です。これも&lt;code>JapaneseDate&lt;/code>が実質&lt;code>LocalDate&lt;/code>と同じく&lt;code>ChronoLocalDate&lt;/code>を継承しているから可能なことですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 日付を日本語で表記する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> formatter = DateTimeFormatter.ofPattern(&lt;span style="color:#f1fa8c">&amp;#34;Gy年&amp;#34;&lt;/span>, Locale.JAPAN)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> todayString = formatter.format(JapaneseDate.now()) &lt;span style="color:#6272a4">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もしJava 1.8以前のバージョンを使うなどで&lt;code>LocalDate&lt;/code>や&lt;code>JapaneseDate&lt;/code>が使えなく、&lt;code>java.util.Date&lt;/code>の方を使うしかない場合は、以下のような方法で年号と年度の取得が可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> format = SimpleDateFormat(&lt;span style="color:#f1fa8c">&amp;#34;Gy年&amp;#34;&lt;/span>, Locale(&lt;span style="color:#f1fa8c">&amp;#34;Ja&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;JP&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;JP&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> year = format.format(Date()) &lt;span style="color:#6272a4">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>java.util.Date&lt;/code>を使う場合は、&lt;code>Locale&lt;/code>に第3引数の&lt;code>variant&lt;/code>まで指定する必要があるので、既存の列挙型として定義されたものは使えません。&lt;/p>
&lt;p>また、&lt;code>Locale.ENGLISH&lt;/code>などに設定すると、&lt;code>JapaenseDate&lt;/code>を使っている場合でも取得した結果は&lt;code>AD2021年12月5日&lt;/code>になります。&lt;/p>
&lt;h3 id="合字で表記する">合字で表記する&lt;/h3>
&lt;p>年号については、Unicodeで合字を取得して使いたい場合もあるかと思います。その場合は、以下のようにUnicodeのMapなどを定義しておいて取得するのが良いかと思います。拡張関数などを定義するのも良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> eraUnicodeMap = mapOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JapaneseEra.MEIJI to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u337e&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#6272a4">// ㍾
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> JapaneseEra.TAISHO to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u337d&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#6272a4">// ㍽
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> JapaneseEra.SHOWA to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u337c&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#6272a4">// ㍼
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> JapaneseEra.HEISEI to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u337b&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#6272a4">// ㍻
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> JapaneseEra.REIWA to &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">\u32ff&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> &lt;span style="color:#6272a4">// ㋿
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> era = JapaneseDate.now().era
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 元号を合字で取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> eraUnicode = eraUnicodeMap[era] &lt;span style="color:#6272a4">// ㋿
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のサンプルでは&lt;code>JapaneseEra&lt;/code>が列挙型なのでそのままキーとしていますが、&lt;code>JapaneseEra&lt;/code>は数値としての情報も持っているのでそちらを使う方法もあるでしょう。それぞれの値に対する数値は以下の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>JapaneseEra&lt;/th>
&lt;th>数値&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MEIJI&lt;/td>
&lt;td>-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TAISHO&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SHOWA&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HEISEI&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>REIWA&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>2021年から2022年の3月の場合は令和3年なので、&lt;code>JapaneseEra.REIWA.value&lt;/code>の値が年度だと勘違いされやすいかなと思います。実際の年度の情報は&lt;code>JapaneseDate&lt;/code>の方にあるので注意しましょう。&lt;/p>
&lt;h2 id="年度を数字で表示する">年度を数字で表示する&lt;/h2>
&lt;p>&lt;code>JapaneseEra&lt;/code>は元号を得るために使う列挙型定数のクラスなので、これ自体は&lt;code>JapaneseDate&lt;/code>の日付情報を持っていません。なので参照できる情報は、あくまでも元となる&lt;code>JapaneseDate&lt;/code>が属した元号の情報のみです。&lt;/p>
&lt;p>なので数値としての年度は、列挙型の&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/temporal/ChronoField.html" target="_blank" rel="noopener"
>ChronoField&lt;/a>を&lt;code>JapaneseDate.get()&lt;/code>に渡して取得する必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> today = JapaneseDate.of(&lt;span style="color:#bd93f9">2010&lt;/span>, &lt;span style="color:#bd93f9">12&lt;/span>, &lt;span style="color:#bd93f9">31&lt;/span>) &lt;span style="color:#6272a4">// 平成22年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 年度をIntとして取得する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> year = today.&lt;span style="color:#ff79c6">get&lt;/span>(ChronoField.YEAR) &lt;span style="color:#6272a4">// 2010
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> yearOfHeisei = today.&lt;span style="color:#ff79c6">get&lt;/span>(ChronoField.YEAR_OF_ERA) &lt;span style="color:#6272a4">// 22
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは&lt;code>JapaneseDate&lt;/code>が&lt;code>LocalDate&lt;/code>と違って、直接&lt;code>year&lt;/code>をgetterで取得できないからです。実際オブジェクトの中を覗いてみると、&lt;code>LocalDate&lt;/code>は年月日をintとshortのフィールドとして保持していることに対して、&lt;code>JapaneseDate&lt;/code>は&lt;code>LocalDate&lt;/code>とint型の&lt;code>yearOfEra&lt;/code>を持っていて、&lt;code>get(ChronoField.YEAR_OF_ERA)&lt;/code>を通じてはじめて&lt;code>yearOfEra&lt;/code>を取得できることになります。getterを用意していないのはおそらく&lt;code>LocalDate&lt;/code>と&lt;code>yearOfEra&lt;/code>という二つの概念があるからなのではないかと思います。もちろん、Kotlinなのでこれは簡単に拡張関数を書くことでgetterを作ることはできますね。&lt;/p>
&lt;p>また、日付のオブジェクトとして&lt;code>LocalDate&lt;/code>を使っている場合は場合は&lt;code>ChronoField.YEAR_OF_ERA&lt;/code>を渡しても西暦の年度が返ってくるので、和暦を使うために&lt;code>JapaneseDate&lt;/code>を使っているかどうかをまず確認しましょう。&lt;/p>
&lt;h3 id="年度を2桁の文字で表示する">年度を2桁の文字で表示する&lt;/h3>
&lt;p>厳密に言って和暦とは関係のないことですが、年度を取得して使う場合、一貫して先端に「0」のついた2桁の文字列として扱いたい場合もあるかと思います。&lt;code>JapaneseDate&lt;/code>を通じて年度を取得した場合は&lt;code>Int&lt;/code>型になるので、1〜9の間は1桁の数字となるわけですが、これを01〜09に表示したい場合は以下の方法が使えます。&lt;/p>
&lt;h4 id="decimalformatを利用する">DecimalFormatを利用する&lt;/h4>
&lt;p>一つは、JavaのAPIである&lt;a class="link" href="https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/text/DecimalFormat.html" target="_blank" rel="noopener"
>DecimalFormat&lt;/a>を使うことです。小数点の範囲などをわかりやすく指定できるので個人的には好むやり方です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> today = JapaneseDate.now() &lt;span style="color:#6272a4">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 数字を表示するためのフォーマットを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> decimalFormat = DecimalFormat(&lt;span style="color:#f1fa8c">&amp;#34;00&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> year = decimalFormat.format(today) &lt;span style="color:#6272a4">// 03
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="stringformatを利用する">String.formatを利用する&lt;/h4>
&lt;p>もう一つの方法は、Kotlinのスタンダードライブラリの機能である&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/format.html" target="_blank" rel="noopener"
>String.format()&lt;/a>を使うことです。性能注視なら、こちらの方法が良いかなと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> today = JapaneseDate.now() &lt;span style="color:#6272a4">// 令和3年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 数字を表示するためのフォーマットを指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> year = &lt;span style="color:#f1fa8c">&amp;#34;%02d&amp;#34;&lt;/span>.format(today) &lt;span style="color:#6272a4">// 03
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="番外kotlinx-datetime">番外：kotlinx-datetime&lt;/h2>
&lt;p>Kotlinには元々日付や時間を扱うAPIがなかったのですが、2020年から&lt;a class="link" href="https://github.com/Kotlin/kotlinx-datetime" target="_blank" rel="noopener"
>kotlinx-datetime&lt;/a>を提供しています。なのでKotlin/JSやKotlin/Nativeなど、JVM上で動かない場合でも日付を扱える公式のAPIができたわけですが、いくつかの懸念があるのでこれを導入するには検討が必要かと思います。&lt;/p>
&lt;h3 id="pre-releaseの段階">Pre-releaseの段階&lt;/h3>
&lt;p>&lt;code>kotlinx-datetime&lt;/code>はまだpre-releaseの段階で、2021年10月に&lt;code>v0.3.1&lt;/code>がリリースされています。なので色々とバグがあったり、思い通りにならない可能性があります。また、開発途中のものなので仕方ありませんが、現時点で提供している機能も&lt;code>java.time&lt;/code>のAPIに比べて少なく、簡単に年号の計算などができるわけではありません。今は必要最低限の機能だけを提供していると思って良いでしょう。&lt;/p>
&lt;h3 id="マルチプラットフォーム向け">マルチプラットフォーム向け&lt;/h3>
&lt;p>Kotlinのスタンダードライブラリ、及び&lt;code>kotlinx&lt;/code>として提供されるライブラリはマルチプラットホームを考慮した実装となっているため、プラットホームが違っても同じ使い方ができるというメリットがありますが、かえってデメリットになる場合もあります。実際、&lt;code>kotlinx-datetime&lt;/code>のJVMの実装は内部的に&lt;code>jata.time&lt;/code>のAPIに依存しているため、JVMだけを使う場合はあえて導入する必要がないともいえます。&lt;/p>
&lt;p>また、プラットフォームごとに実装が違うということはどこかで予期せぬ例外が発生したり、期待した結果にならないケースも発生しえる、ということにもなるかと思います。&lt;/p>
&lt;h2 id="javatimeの懸念">java.timeの懸念&lt;/h2>
&lt;p>&lt;code>JapaneseEra&lt;/code>では明治以前（慶応など）の元号は使えませんが、おそらくその理由は和暦でグレゴリウス暦が使われたのは明治からだったという歴史的な背景があるのではないかと思います。また、&lt;code>JapaneseDate&lt;/code>でも明治6年(西暦1873年1月1日)以前の日付を指定すると以下のように例外が発生します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>Exception in thread &lt;span style="color:#f1fa8c">&amp;#34;main&amp;#34;&lt;/span> java.time.DateTimeException: JapaneseDate before Meiji &lt;span style="color:#bd93f9">6&lt;/span> is not supported
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at java.base/java.time.chrono.JapaneseDate.&amp;lt;init&amp;gt;&lt;span style="color:#ff79c6">(&lt;/span>JapaneseDate.java:333&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at java.base/java.time.chrono.JapaneseDate.of&lt;span style="color:#ff79c6">(&lt;/span>JapaneseDate.java:257&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、単純に帳票を作るなどのケースでなく、歴史的な研究のための日付計算ではここで紹介した方法は使えないケースもあるかと思います。&lt;/p>
&lt;p>また、JDKのバージョンなどの問題があるためか、&lt;code>JapaneseEra.REIWA&lt;/code>の取得ができなく、エラーとなるケースがあるので注意する必要があります。この場合でも&lt;code>value&lt;/code>の値の取得は問題ないので、少し可読性は低下しながら分岐などの判定に定数をそのまま使うのは避けたほうが良さそうです。（正確な理由はわかりませんが…）&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。少し興味本位で調べ始めたもののまとめではありますが、本業の方で実際に必要な処理でもあり、これをどうやって拡張関数として落とせるかということも考えられる良い機会となったかなと思っています。&lt;/p>
&lt;p>また、JavaのAPIに関しては&lt;a class="link" href="https://qiita.com/yamadamn/items/56e7370bae2ceaec55d5" target="_blank" rel="noopener"
>Javaバージョン別の改元(新元号)対応まとめ&lt;/a>という良い記事があったので、興味のある方はご一読ください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその３</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-3/</link><pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-3/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinの隠されたコストーその３" />&lt;p>Kotlinの隠されたコスト、その最後の記事となります。今までの記事もかなり興味深かったですが、今回はさらにKotlinならではの機能に触れているので、Kotlinそのものに対する理解も含めてみる必要があり、さらに深い内容となっているかと思います。&lt;/p>
&lt;p>今回のアジェンダは、「委譲プロパティ」と「rangeを使ったループ」になります。この記事は&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-3-3bf6e0dbf0a4" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 3&lt;/a>の内容を要約したものです。&lt;/p>
&lt;h2 id="委譲プロパティ">委譲プロパティ&lt;/h2>
&lt;p>&lt;a class="link" href="https://kotlinlang.org/docs/delegated-properties.html" target="_blank" rel="noopener"
>委譲プロパティ&lt;/a>とは、&lt;code>getter&lt;/code>と&lt;code>setter&lt;/code>が&lt;code>委譲(delegate)&lt;/code>というオブジェクトによって実装された&lt;a class="link" href="https://kotlinlang.org/docs/properties.html" target="_blank" rel="noopener"
>プロパティ&lt;/a>を指します。これによって再利用可能なカスタムプロパティを作ることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> p: String &lt;span style="color:#ff79c6">by&lt;/span> Delegate()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>委譲オブジェクトはプロパティの設定と読み込みのため&lt;code>getValue()&lt;/code>と&lt;code>setValue()&lt;/code>を実装する必要があります。そしてこれらの関数はプロパティのメタデータ（プロパティ名）とオブジェクトのインスタンスを引数として必要とします。&lt;/p>
&lt;p>クラスが委譲プロパティとして定義されると、コンパイラは下記のようなコードを生成します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Example&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @NotNull
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Delegate p$delegate &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Delegate&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// $FF: 生成されたフィールド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> KProperty&lt;span style="color:#ff79c6">[]&lt;/span> $$delegatedProperties &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> KProperty&lt;span style="color:#ff79c6">[]{(&lt;/span>KProperty&lt;span style="color:#ff79c6">)&lt;/span>Reflection&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">mutableProperty1&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> MutablePropertyReference1Impl&lt;span style="color:#ff79c6">(&lt;/span>Reflection&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getOrCreateKotlinClass&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Example&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">class&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;p&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;getP()Ljava/lang/String;&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">))};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @NotNull
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String &lt;span style="color:#50fa7b">getP&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">p$delegate&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getValue&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> $$delegatedProperties&lt;span style="color:#ff79c6">[&lt;/span>0&lt;span style="color:#ff79c6">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">setP&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>@NotNull String var1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">checkParameterIsNotNull&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>var1&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&amp;lt;set-?&amp;gt;&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">p$delegate&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">setValue&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> $$delegatedProperties&lt;span style="color:#ff79c6">[&lt;/span>0&lt;span style="color:#ff79c6">],&lt;/span> var1&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一部staticプロパティのメタデータがクラスに追加されます。そして毎回値の設定と読み込みが発生するたびにコンストラクタによる初期化が起こります。&lt;/p>
&lt;h3 id="委譲インスタンス">委譲インスタンス&lt;/h3>
&lt;p>上記サンプルでは新しい委譲のインスタンスがプロパティの実装のため生成されています。委譲がstatefulの場合にこのようになります。たとえはローカルで計算されたプロパティを使うなどの場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">StringDelegate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> cache: String? = &lt;span style="color:#ff79c6">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">operator&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getValue&lt;/span>(thisRef: Any?, &lt;span style="color:#ff79c6">property&lt;/span>: KProperty&amp;lt;*&amp;gt;): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> result = cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (result &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = someOperation()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache = result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>またコンストラクタに追加のパラメータが渡されると、新しい委譲のインスタンスが必要となります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Example&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> nameView &lt;span style="color:#ff79c6">by&lt;/span> BindViewDelegate&amp;lt;TextView&amp;gt;(R.id.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>statelessであり、すでに渡されたオブジェクトのインスタンスとプロパティ名を保ちたいだけなら委譲クラスに&lt;code>object&lt;/code>をつけてsingletonにする方法があります。たとえば下記のようなものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">object&lt;/span> &lt;span style="color:#50fa7b">FragmentDelegate&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">operator&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getValue&lt;/span>(thisRef: Activity, &lt;span style="color:#ff79c6">property&lt;/span>: KProperty&amp;lt;*&amp;gt;): Fragment? {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> thisRef.fragmentManager.findFragmentByTag(&lt;span style="color:#ff79c6">property&lt;/span>.name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また既存のオブジェクトを拡張して委譲することもできます。つまり、&lt;code>getValue()&lt;/code>や&lt;code>setValue()&lt;/code>を拡張関数として定義することもできるということです。Kotlinではすでに&lt;code>Map&lt;/code>と&lt;code>MutableMap&lt;/code>に拡張関数として委譲するパターンを使っています。（プロパティ名をキーで使っています）&lt;/p>
&lt;p>もし一つのクラス内でローカルの委譲インスタンスに複数のプロパティを保持して再利用したいなら、そのクラスのコンストラクタでインスタンスを初期化しましょう。&lt;/p>
&lt;p>Kotlin 1.1以降、&lt;a class="link" href="https://kotlinlang.org/docs/delegated-properties.html#local-delegated-properties" target="_blank" rel="noopener"
>関数内のローカル変数を委譲プロパティにする&lt;/a>こともできます。この場合、委譲は後で初期化できます。&lt;/p>
&lt;p>クラスに定義された委譲プロパティごとにオーバーヘッドとメタデータの追加が発生するのでなるべくプロパティを再利用できるようにした方が良いでしょう。また、定義したい項目が多い場合に、果たして委譲プロパティが良い選択肢であるかを考慮すべきです。&lt;/p>
&lt;h3 id="ジェネリック委譲">ジェネリック委譲&lt;/h3>
&lt;p>委譲関数はジェネリックでも定義できます。なので委譲クラスをさまざまな型のプロパティとして定義することもできます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> maxDelay: Long &lt;span style="color:#ff79c6">by&lt;/span> SharedPreferencesDelegate&amp;lt;Long&amp;gt;()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、上記のようにprimitiveをジェネリック委譲を使う場合、&lt;code>boxing&lt;/code>と&lt;code>unboxing&lt;/code>が値の指定と読み込みで発生することに注意する必要があります。これはプロパティがnon-nullの場合でも起こることです。&lt;/p>
&lt;p>なのでnon-nullなprimitive型の委譲プロパティを定義する場合はジェネリックで定義を避けたほうが良いです。&lt;/p>
&lt;h3 id="スタンダード委譲lazy">スタンダード委譲（lazy()）&lt;/h3>
&lt;p>Kotlinでは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" target="_blank" rel="noopener"
>Delegates.notNull()&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html" target="_blank" rel="noopener"
>Delegates.observable()&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html" target="_blank" rel="noopener"
>lazy()&lt;/a>のような委譲のための標準機能が存在しています。&lt;/p>
&lt;p>&lt;code>lazy()&lt;/code>は読み込み専用の委譲プロパティのための関数です。初めて読み込みが発生する際、プロパティを初期化するた目にlambdaを指定できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> dateFormat: DateFormat &lt;span style="color:#ff79c6">by&lt;/span> lazy {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SimpleDateFormat(&lt;span style="color:#f1fa8c">&amp;#34;dd-MM-yyyy&amp;#34;&lt;/span>, Locale.getDefault())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはその値が実際に読み込まれるまで高いコストの初期化を遅延させるという、パフォーマンスと可読性の側面で優れた方法です。&lt;/p>
&lt;p>ただ、&lt;code>lazy()&lt;/code>はinline関数ではなく、引数として渡されたlambdaは別の&lt;code>Function&lt;/code>クラスとしてコンパイルされ、戻り値の委譲オブジェクトもまたinline化されないことには注意する必要があります。&lt;/p>
&lt;p>そして&lt;code>lazy()&lt;/code>関数で見逃しやすいのは&lt;code>mode&lt;/code>という引数で戻り値の委譲タイプを決められるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">lazy&lt;/span>(initializer: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): Lazy&amp;lt;T&amp;gt; = SynchronizedLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">lazy&lt;/span>(mode: LazyThreadSafetyMode, initializer: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): Lazy&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">when&lt;/span> (mode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LazyThreadSafetyMode.SYNCHRONIZED &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> SynchronizedLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LazyThreadSafetyMode.PUBLICATION &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> SafePublicationLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LazyThreadSafetyMode.NONE &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> UnsafeLazyImpl(initializer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mode&lt;/code>を指定していない場合、デフォルトとしては&lt;code>LazyThreadSafetyMode.SYNCHRONIZED&lt;/code>が使われますが、これは複数のスレッドで初期化ブロックが安全に実行されることを保証するためにコストの高い&lt;code>double-checked lock&lt;/code>を行います。&lt;/p>
&lt;p>シングルスレッドしかプロパティに対するアクセスがないというのがわかっているなら、無駄なロックは下げた方がいいでしょう。こういう場合は&lt;code>LazyThreadSafetyMode.NONE&lt;/code>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> dateFormat: DateFormat &lt;span style="color:#ff79c6">by&lt;/span> lazy(LazyThreadSafetyMode.NONE) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SimpleDateFormat(&lt;span style="color:#f1fa8c">&amp;#34;dd-MM-yyyy&amp;#34;&lt;/span>, Locale.getDefault())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ranges">Ranges&lt;/h2>
&lt;p>&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html" target="_blank" rel="noopener"
>Ranges&lt;/a>で限定された範囲の値のセットを定義できます。この値は&lt;code>Comparable&lt;/code>なものならなんでも指定できますね。そして、この表現式を使うと&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-closed-range/" target="_blank" rel="noopener"
>ClosedRange&lt;/a>というインタフェースの実装ができることになります。&lt;/p>
&lt;h3 id="包含テスト">包含テスト&lt;/h3>
&lt;p>rangeを使って範囲内に特定の値が含まれているかどうかを&lt;code>in&lt;/code>や&lt;code>!in&lt;/code>を使って検知することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rangeはnon-nullなprimitive型（&lt;code>Int&lt;/code>, &lt;code>Long&lt;/code>, &lt;code>Byte&lt;/code>, &lt;code>Short&lt;/code>, &lt;code>Float&lt;/code>, &lt;code>Double&lt;/code>, &lt;code>Char&lt;/code>）に対する最適化が行われるので、コンパイルされた結果は以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>1 &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> i &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> 10&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、オーバーヘッドや追加オブジェクトの割り当てなどは起こらないです。しかし、primitiveではない場合はどうでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (name &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Alfred&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">..&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Alicia&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlin 1.1.50以前はコンパイル時に&lt;code>ClosedRange&lt;/code>オブジェクトが常に生成されました。しかし、1.1.50からは以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span>(name.compareTo(&lt;span style="color:#f1fa8c">&amp;#34;Alfred&amp;#34;&lt;/span>) &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(name.compareTo(&lt;span style="color:#f1fa8c">&amp;#34;Alicia&amp;#34;&lt;/span>) &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#ff79c6">out&lt;/span>.println(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>rangeはまた、&lt;code>when&lt;/code>の条件式でも使えます。&lt;code>if-else&lt;/code>より可読性が良くなりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> message = &lt;span style="color:#ff79c6">when&lt;/span> (statusCode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">200.&lt;/span>.&lt;span style="color:#bd93f9">299&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;OK&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">300.&lt;/span>.&lt;span style="color:#bd93f9">399&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Find it somewhere else&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Oops&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、rangeを使う場合、特定の値が含まれているかどうかをチェックするとき、指定された範囲とそれを使うコードの間に間があるとコストがかかることになります。たとえば以下のようなコードがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> myRange &lt;span style="color:#ff79c6">get&lt;/span>() = &lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">rangeTest&lt;/span>(i: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> myRange) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はコンパイルすると&lt;code>IntRange&lt;/code>オブジェクトが追加されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> IntRange &lt;span style="color:#50fa7b">getMyRange&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> IntRange&lt;span style="color:#ff79c6">(&lt;/span>1&lt;span style="color:#ff79c6">,&lt;/span> 10&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">rangeTest&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getMyRange&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">contains&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">))&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはプロパティのgetterを&lt;code>inline&lt;/code>として定義しても同じです。なのでなるべくrangeが使われるテストの方に直接書くことでオブジェクトが追加されない要因した方が良いです。また、primitiveではないオブジェクトを使う場合は定数として定義し、&lt;code>ClosedRange&lt;/code>のインスタンスを再利用する方法があります。&lt;/p>
&lt;h3 id="forループ">forループ&lt;/h3>
&lt;p>&lt;code>Float&lt;/code>と&lt;code>Double&lt;/code>を除いたprimitive型の範囲をループで使うのも良い選択です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルされた結果にはオーバーヘッドが発生しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> 1&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">byte&lt;/span> var2 &lt;span style="color:#ff79c6">=&lt;/span> 11&lt;span style="color:#ff79c6">;&lt;/span> i &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> var2&lt;span style="color:#ff79c6">;&lt;/span> &lt;span style="color:#ff79c6">++&lt;/span>i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>逆順にループしたい場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/down-to.html" target="_blank" rel="noopener"
>downTo()&lt;/a>を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">10&lt;/span> downTo &lt;span style="color:#bd93f9">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これにもまた、オーバーヘッドは発生しません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> 10&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">byte&lt;/span> var1 &lt;span style="color:#ff79c6">=&lt;/span> 1&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">true&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i &lt;span style="color:#ff79c6">==&lt;/span> var1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">--&lt;/span>i&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/until.html" target="_blank" rel="noopener"
>until&lt;/a>を使って特定の値未満にループするのも良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> until size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前は少しコストがかかることになりましたが、Kotlin 1.1.4以降は以下のようなコードが生成されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> 0&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> var2 &lt;span style="color:#ff79c6">=&lt;/span> size&lt;span style="color:#ff79c6">;&lt;/span> i &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> var2&lt;span style="color:#ff79c6">;&lt;/span> &lt;span style="color:#ff79c6">++&lt;/span>i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、そのほかは最適化があまり効いてないケースもあります。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/reversed.html" target="_blank" rel="noopener"
>reversed()&lt;/a>を使う例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> (&lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>).reversed()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンパイルされたコードがあまり綺麗とは言えません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>IntProgression var10000 = RangesKt.reversed((IntProgression)(new IntRange(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int i = var10000.getFirst();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int var3 = var10000.getLast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int var4 = var10000.getStep();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span>(var4 &amp;gt; &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(i &amp;gt; var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span>(i &amp;lt; var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span>(&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#ff79c6">out&lt;/span>.println(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(i &lt;span style="color:#ff79c6">==&lt;/span> var3) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#ff79c6">+=&lt;/span> var4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>IntRange&lt;/code>オブジェクトが範囲を再定義するため生成され、さらに&lt;code>IntProgression&lt;/code>オブジェクトが逆順に要素を整列するために生成されます。&lt;/p>
&lt;p>&lt;code>progression&lt;/code>を作るのに二つ以上の関数が使われていると、二つ以上のオブジェクトを作るようなオーバーヘッドが発生することになります。&lt;/p>
&lt;p>上記のルールは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/step.html" target="_blank" rel="noopener"
>step()&lt;/a>を使う場合も同じで、&lt;code>step 1&lt;/code>を指定しても状況は変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span> step &lt;span style="color:#bd93f9">2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに、生成されたコードで最後の値を読み込む時、&lt;code>IntProgression&lt;/code>オブジェクトの最後の要素と&lt;code>step()&lt;/code>で指定した範囲を考慮して追加の処理が行われます。上記のサンプルだと最後の要素は&lt;code>9&lt;/code>です。&lt;/p>
&lt;p>なので、&lt;code>for&lt;/code>を利用したループをするときはなるべく&lt;code>..&lt;/code>、&lt;code>downTo()&lt;/code>、&lt;code>until()&lt;/code>を利用してオーバーヘッドを避けた方が良いでしょう。&lt;/p>
&lt;h3 id="foreachループ">forEachループ&lt;/h3>
&lt;p>&lt;code>for&lt;/code>ループの代わりに、rangeに対してinline拡張関数の&lt;code>forEach()&lt;/code>を使う場合も結果はあまり変わりません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#bd93f9">1.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>).forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#ff79c6">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、&lt;code>forEach()&lt;/code>は&lt;code>Iterable&lt;/code>に対してのみ最適化されてないです。これはつまり、iteratorを生成する必要があるということを意味します。なので、コンパイルされると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Iterable $receiver$iv &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>Iterable&lt;span style="color:#ff79c6">)(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> IntRange&lt;span style="color:#ff79c6">(&lt;/span>1&lt;span style="color:#ff79c6">,&lt;/span> 10&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Iterator var1 &lt;span style="color:#ff79c6">=&lt;/span> $receiver$iv&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">iterator&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">while&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>var1&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">hasNext&lt;/span>&lt;span style="color:#ff79c6">())&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> element$iv &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">((&lt;/span>IntIterator&lt;span style="color:#ff79c6">)&lt;/span>var1&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">nextInt&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>element$iv&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは今までのサンプルよりもコストのかかるものです。&lt;code>IntRange&lt;/code>オブジェクトを生成するだけでなく、&lt;code>IntIterator&lt;/code>オブジェクトも生成しているからです。primitiveではない場合はさらにコストがかかるでしょう。&lt;/p>
&lt;p>なので、rangeを使ったループが必要な場合は&lt;code>forEach()&lt;/code>より&lt;code>for&lt;/code>ループを使ってオーバーヘッドを減らした方が良いです。&lt;/p>
&lt;h3 id="collectionインデックスループ">collectionインデックスループ&lt;/h3>
&lt;p>Kotlinのスタンダードライブラリは&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/indices.html" target="_blank" rel="noopener"
>indices&lt;/a>という拡張プロパティで配列と&lt;code>Collection&lt;/code>のインテックスを提供します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> list.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(list[i])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>indices&lt;/code>のコンパイルされた結果は良い最適化を見せてくれます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List list &lt;span style="color:#ff79c6">=&lt;/span> CollectionsKt&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">listOf&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> String&lt;span style="color:#ff79c6">[]{&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">});&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span> i &lt;span style="color:#ff79c6">=&lt;/span> 0&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> var2 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">((&lt;/span>Collection&lt;span style="color:#ff79c6">)&lt;/span>list&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">size&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span> i &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> var2&lt;span style="color:#ff79c6">;&lt;/span> &lt;span style="color:#ff79c6">++&lt;/span>i&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object var3 &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">get&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>var3&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>IntRange&lt;/code>オブジェクトが作られてないです。では、自前で実装してみるとどうなるのでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> SparseArray&amp;lt;*&amp;gt;.indices: IntRange
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>() = &lt;span style="color:#bd93f9">0&lt;/span> until size()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">printValues&lt;/span>(map: SparseArray&amp;lt;String&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> map.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(map.valueAt(i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>拡張プロパティとして定義してコンパイルすると、あまり効率的ではないコードになっていることがわかります。&lt;code>IntRange&lt;/code>オブジェクトが作られてます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> static &lt;span style="color:#ff79c6">final&lt;/span> void printValues(@NotNull SparseArray map) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics.checkParameterIsNotNull(map, &lt;span style="color:#f1fa8c">&amp;#34;map&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> IntRange var10000 = RangesKt.until(&lt;span style="color:#bd93f9">0&lt;/span>, map.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int i = var10000.getFirst();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int var2 = var10000.getLast();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(i &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span>(&lt;span style="color:#ff79c6">true&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object $&lt;span style="color:#ff79c6">receiver&lt;/span>$iv = map.valueAt(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#ff79c6">out&lt;/span>.println($&lt;span style="color:#ff79c6">receiver&lt;/span>$iv);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span>(i &lt;span style="color:#ff79c6">==&lt;/span> var2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">++&lt;/span>i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合は代わりに&lt;code>until()&lt;/code>と&lt;code>for&lt;/code>ループを使った方が良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">printValues&lt;/span>(map: SparseArray&amp;lt;String&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> until map.size()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(map.valueAt(i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。個人的にはあまり委譲プロパティを使ったことがなく、そもそもの理解を兼ねてかなり勉強になりました。また、rangeに関しても、Javaでの習慣でテストクラスのフィールドとして定義していろいろな関数で使い回していましたが、まさかそれがよりコストのかかることだとは思ってなかったので少しショックでした。&lt;/p>
&lt;p>また、改めてKotlinで提供している機能とAPIに対して正しく理解する必要があると思いました。そして&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%83%E3%82%AB%E3%83%A0%E3%81%AE%E5%89%83%E5%88%80" target="_blank" rel="noopener"
>オッカムの剃刀&lt;/a>でも話しているように、なるべくシンプルなロジックとコードを追求する必要があるとも思いましたね。intellijのメニューのうち、&lt;code>Tools &amp;gt; Kotlin &amp;gt; Show Kotlin Bytecode&lt;/code> でいつでもJavaのコードにdecomplieされたコードを確認できるので、最新だとどのように変換されるのかを確認してみながらコードを最適化を行なった方が良いかも知れません。&lt;/p>
&lt;p>今月はいつもの、自分の経験や仮説を紹介するようなポストでなく、ほぼ翻訳のみになってしまいましたが、私自身としてはかなり貴重な知識を得られたと思っています。またの機会で何か良いものがあったら、是非とも紹介させていただきたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその２</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-2/</link><pubDate>Sun, 21 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-2/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinの隠されたコストーその２" />&lt;p>今回はまたKotlinの隠されたコストに対するポストです。今となってはあまり気にすることはないかも知れませんし（検証は必要そうですが、バージョンアップごとにコンパイラが生成するコードを追うのは大変そうですね…）、極限のチューニングをするよりもマシンスペックを上げた方がよい時代になったとはいうものの、この記事で紹介していることをコーディングの習慣として身につけておくと良いかなと思います。&lt;/p>
&lt;p>前回は高階関数とLambda、そしてcompanion objectに関する記事を紹介しました。今回はローカル関数、Null安定性、Varargsに隠されたKotlinのコストについて述べます。この記事は&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-2-324a4a50b70" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 2&lt;/a>の内容を要約したものです。&lt;/p>
&lt;h2 id="ローカル関数">ローカル関数&lt;/h2>
&lt;p>関数内に定義した関数を「ローカル関数」と言います。これらローカル関数は、アウター関数（ローカル関数が定義された関数）の範囲にアクセスできます。例えば以下だと、&lt;code>sumSquare&lt;/code>で&lt;code>someMath&lt;/code>のパラメータにアクセスしているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">someMath&lt;/span>(a: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">sumSquare&lt;/span>(b: Int) = (a + b) * (a + b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> sumSquare(&lt;span style="color:#bd93f9">1&lt;/span>) + sumSquare(&lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ローカル関数は基本的にLambdaと似ていますが、他に制限があります。ローカル関数そのものと、ローカル関数を含む関数もまた&lt;code>inline&lt;/code>として定義できません。なので関数の呼び出しにかかるコストを避ける方法がありません。&lt;/p>
&lt;p>コンパイルされたローカル関数は&lt;code>Function&lt;/code>オブジェクトに変わります。なので前回の記事で述べた「インライン化してないLambda」と同じ問題を持っています。上記のコードをJavaのコードで表すと以下のような形になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">someMath&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> a&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Function1 sumSquare$ &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Function1&lt;span style="color:#ff79c6">(&lt;/span>1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// $FF: 生成されたメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#6272a4">// $FF: ブリッジメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> Object &lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Object var1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Integer&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">valueOf&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(((&lt;/span>Number&lt;span style="color:#ff79c6">)&lt;/span>var1&lt;span style="color:#ff79c6">).&lt;/span>&lt;span style="color:#50fa7b">intValue&lt;/span>&lt;span style="color:#ff79c6">()));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> b&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>a &lt;span style="color:#ff79c6">+&lt;/span> b&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">*&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>a &lt;span style="color:#ff79c6">+&lt;/span> b&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> sumSquare$&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> sumSquare$&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>2&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Lambdaと比べ一つ性能が劣化されない点があります。関数のインスタンスが呼び出し元からわかるので、ジェネリックなインタフェースを使わず、匿名クラスになりメソッドが直接呼び出されます。これは外の関数からローカル関数を呼び出す際に、&lt;code>casting&lt;/code>や&lt;code>boxing&lt;/code>が発生しないということを意味します。実際のBytecodeを見ると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ICONST_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKEVIRTUAL be/myapplication/MyClassKt$someMath$1.invoke (I)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ICONST_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKEVIRTUAL be/myapplication/MyClassKt$someMath$1.invoke (I)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IADD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IRETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでメソッドが2回呼び出されていますが、メソッドの引数も戻り値も&lt;code>int&lt;/code>型になっていて、&lt;code>boxing&lt;/code>と&lt;code>unboxing&lt;/code>がないのを確認できます。&lt;/p>
&lt;p>ただ、依然としてメソッドが呼び出されるたびに&lt;code>Function&lt;/code>オブジェクトのインスタンスを生成していますが、ローカル関数をvalue caputeなしのものに代替することでこの問題は回避できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">someMath&lt;/span>(a: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">sumSquare&lt;/span>(a: Int, b: Int) = (a + b) * (a + b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> sumSquare(a, &lt;span style="color:#bd93f9">1&lt;/span>) + sumSquare(a, &lt;span style="color:#bd93f9">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のようにすることで、&lt;code>Function&lt;/code>オブジェクトのインスタンスは再利用できるようなものになります。こうすることで既存のprivate関数に比べ、ローカル関数のデメリットは追加のクラス（メソッドを含む）を生成するということだけになります。&lt;/p>
&lt;p>ローカル関数はprivate関数の代替として、アウター関数の変数にアクセスできるというメリットがあります。ただこれによって&lt;code>Function&lt;/code>オブジェクトを生成するというコストがかかりますので、non-capturingにする工夫が必要です。&lt;/p>
&lt;h2 id="null安全性">Null安全性&lt;/h2>
&lt;p>Kotlinの最も良い機能の一つは明視的にnullになり得る型とそうでない型を区別できるということです。これによってコンパイラがランタイムで予期せぬ&lt;code>NullPointerException&lt;/code>を投げるのを防止できます。&lt;/p>
&lt;h3 id="non-nullパラメータのランタイムでのチェック">Non-nullパラメータのランタイムでのチェック&lt;/h3>
&lt;p>例えば以下のような関数があるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">sayHello&lt;/span>(who: String) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;Hello &lt;/span>&lt;span style="color:#f1fa8c">$who&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはJavaのコードで以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">sayHello&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>@NotNull String who&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">checkParameterIsNotNull&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>who&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;who&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String var1 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Hello &amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> who&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>var1&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>@NotNull&lt;/code>アノテーションが追加され、Java側にnullが渡されてはいけないということを知らせています。&lt;/p>
&lt;p>しかし、アノテーションは呼び出し側にnull safetyを強制するものではありません。なのでstaticメソッドを呼び出してパラメータをもう一度確認しています。この関数は&lt;code>IllegalArgumentException&lt;/code>を投げて呼び出し元の修正を簡単にします。&lt;/p>
&lt;p>publicな関数には常にnon-nullなパラメータに対して&lt;code>Intrinsics.checkParameterIsNotNull()&lt;/code>でのチェックがが追加されますが、privateな関数に対しては追加されません。なぜなら、Kotlinクラスはnull safeであることをコンパイラが保証するからです。&lt;/p>
&lt;p>このNullチェックによるパフォーマンスへの影響は無視しても良いほどでテストにも有用ですが、ビルド時にもっと時間がかかる原因になります。これに対してはコンパイラのオプションに&lt;code>-Xno-param-assertions&lt;/code>を追加するか、&lt;a class="link" href="https://www.guardsquare.com/proguard" target="_blank" rel="noopener"
>ProGuard&lt;/a>のルールに以下の設定を追加することでランタイムNullチェックをなくすことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">-&lt;/span>assumenosideeffects &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">kotlin&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">jvm&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">internal&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">Intrinsics&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">checkParameterIsNotNull&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>java&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">lang&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">Object&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> java&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">lang&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">String&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ上記のルールを追加する場合、AndroidのProGuardのOptimization設定が有効になっているかのチェックがまず必要です。この設定はデフォルトでは無効になっています。&lt;/p>
&lt;h3 id="nullable-primitive型">Nullable primitive型&lt;/h3>
&lt;p>まず先に覚えておくべきことは、nullableで宣言したprimitive型は常にJavaの&lt;code>int&lt;/code>や&lt;code>float&lt;/code>などの代わりに&lt;code>Integer&lt;/code>、&lt;code>Float&lt;/code>といった&lt;code>boxed reference&lt;/code>型が使われるので追加のコストが発生するということです。&lt;/p>
&lt;p>&lt;a class="link" href="http://docs.oracle.com/javase/8/docs/technotes/guides/language/autoboxing.html" target="_blank" rel="noopener"
>autoboxing&lt;/a>とnull-safetyを無視するのでJavaでは&lt;code>Integer&lt;/code>でも&lt;code>int&lt;/code>でもコードはあまり変わらないJavaに対して、Kotlinだとnullableに対して安全なコードを書くように強制しているので、non-nullの方を使った方が良いというのが明確にわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">add&lt;/span>(a: Int, b: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> a + b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">add&lt;/span>(a: Int?, b: Int?): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> (a &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) + (b &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なので、なるべくコードの可読性と性能を考慮してnon-nullの方を選んだ方が良いです。&lt;/p>
&lt;h3 id="配列">配列&lt;/h3>
&lt;p>Kotlinには、以下の3通りの配列があります。&lt;/p>
&lt;ul>
&lt;li>&lt;code>IntArray&lt;/code>、&lt;code>FloatArray&lt;/code>のようなもの：primitive型の配列。&lt;code>int[]&lt;/code>、&lt;code>float[]&lt;/code>のような型にコンパイルされる。&lt;/li>
&lt;li>&lt;code>Array&amp;lt;T&amp;gt;&lt;/code>：non-nullオブジェクトの型が指定された配列。primitiveに対して&lt;code>boxing&lt;/code>が起こりえる。&lt;/li>
&lt;li>&lt;code>Array&amp;lt;T?&amp;gt;&lt;/code>：nullableオブジェクトの型が指定された配列。明確に&lt;code>boxing&lt;/code>が起こる。&lt;/li>
&lt;/ul>
&lt;p>もしnon-nullなprimitive型の配列が必要な場合は、なるべく&lt;code>Array&amp;lt;Int&amp;gt;&lt;/code>の代わりに&lt;code>IntArray&lt;/code>を使いましょう。&lt;/p>
&lt;h2 id="varargs">Varargs&lt;/h2>
&lt;p>KotlinではJavaとは書き方が少し違いますが、&lt;a class="link" href="https://kotlinlang.org/docs/functions.html#variable-number-of-arguments-varargs" target="_blank" rel="noopener"
>可変長引数&lt;/a>を定義することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">printDouble&lt;/span>(&lt;span style="color:#ff79c6">vararg&lt;/span> values: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> values.forEach { println(&lt;span style="color:#ff79c6">it&lt;/span> * &lt;span style="color:#bd93f9">2&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaと同じく、&lt;code>vararg&lt;/code>はコンパイルされると指定した型の配列になります。そして上記の関数は以下のように、３つの方法で呼び出すことができます。&lt;/p>
&lt;h3 id="複数のパラメータを渡す">複数のパラメータを渡す&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>printDouble(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinのコンパイラはこれを新しい配列の生成と初期化に変えます。これはJavaと一緒です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>printDouble(new int[]{&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これはつまり新しい配列を作るためのオーバヘッドがあるということです。ただJavaと変わらないやり方です。&lt;/p>
&lt;h3 id="配列を渡す">配列を渡す&lt;/h3>
&lt;p>Javaでは配列をそのまま渡すことができますが、Kotlinだとそれができず、&lt;code>spread operator&lt;/code>を使う必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> values = intArrayOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(*values)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaでは配列の参照が&lt;code>as-is&lt;/code>として関数に渡され、新しい配列の割り当ては起こりません。しかし、Kotlinの&lt;code>spread operator&lt;/code>は以下のようなことをします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">[]&lt;/span> values &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">[]{&lt;/span>1&lt;span style="color:#ff79c6">,&lt;/span> 2&lt;span style="color:#ff79c6">,&lt;/span> 3&lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble&lt;span style="color:#ff79c6">(&lt;/span>Arrays&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">copyOf&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>values&lt;span style="color:#ff79c6">,&lt;/span> values&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">length&lt;/span>&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列のコピーが関数に渡されるので、より安全なコードといえます。呼び出し側には影響なしで、配列を修正できますので。しかしメモリを追加的に消費してしまいます。&lt;/p>
&lt;h3 id="配列と他の引数を混ぜて渡す">配列と他の引数を混ぜて渡す&lt;/h3>
&lt;p>&lt;code>spread operator&lt;/code>の良い点は、配列と他の引数を混ぜて渡すこともできるということです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> values = intArrayOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble(&lt;span style="color:#bd93f9">0&lt;/span>, *values, &lt;span style="color:#bd93f9">42&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この場合はどうコンパイルされるか気になりませんか？結果はかなり面白いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">[]&lt;/span> values &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span>&lt;span style="color:#ff79c6">[]{&lt;/span>1&lt;span style="color:#ff79c6">,&lt;/span> 2&lt;span style="color:#ff79c6">,&lt;/span> 3&lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IntSpreadBuilder var10000 &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> IntSpreadBuilder&lt;span style="color:#ff79c6">(&lt;/span>3&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">add&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>0&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">addSpread&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>values&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>var10000&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">add&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>42&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>printDouble&lt;span style="color:#ff79c6">(&lt;/span>var10000&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toArray&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列を新しく生成するだけでなく、一時的なビルダオブジェクトを使って配列の最終的なサイズを計算しています。なので配列を渡す時よりもコストは追加されます。&lt;/p>
&lt;p>なので、呼び出される回数の多くパフォーマンスが重要なコードに対してはなるべく可変長引数より実際の配列をパラメータとして使った方が良いです。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがでしたか。個人的にprivate関数をよく使うので、よりスコープを制限できるという面でローカル関数を積極的に使いたいと思っていましたが、ここでも隠されたコストがあるというというのは興味深かったです。primitive型についてはJavaがそうだったので、なんとなく&lt;code>boxing&lt;/code>が起こるんじゃないかなと思っていたものの、nullableに対してのみそうだというのも面白かったですね。逆に、primitiveのままになるnon-null型に対してはどうやってチェックが走るのだろうという新しい疑問もありました。（例えば&lt;code>int&lt;/code>だとデフォルト値の&lt;code>0&lt;/code>が常に割り当てられるので）&lt;/p>
&lt;p>あと、配列の場合はJavaでも&lt;code>IntStream&lt;/code>、&lt;code>DoubleStream&lt;/code>などがあったのでなんとなくすぐ理解ができましたが、まさか&lt;code>varargs&lt;/code>で渡したパラメータに対して色々とコストが追加されるとは思わなかったです。そもそもあまり配列を使わないので、可変長引数を使う場面もなかったのですが…よく使わないものほど重要なことを忘れやすそうなので、これは覚えておかないとですね。色々と勉強になりました。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinの隠されたコストーその１</title><link>https://retheviper.github.io/posts/kotlin-hidden-cost-1/</link><pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-hidden-cost-1/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinの隠されたコストーその１" />&lt;p>Kotlinは便利ですが、何が便利かというと代表的に挙げられるものがたくさんのシンタクスシュガーではないかと思います。同じJVM言語のJavaと比べ、多くの場合でコード量が劇的に減るのが嬉しいという評価も多いものですね。しかし、この便利さの裏には隠されたコスト（性能面での）があるという話があります。今回はそれについて説明している良い記事を見つけたので、共有したいと思います。ただ、翻訳よりは要約に近いものなので、そこはご了承ください。&lt;/p>
&lt;p>ちなみにここで紹介している記事（&lt;a class="link" href="https://bladecoder.medium.com/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62" target="_blank" rel="noopener"
>Exploring Kotlin’s hidden costs - Part 1&lt;/a>）は、2017年に作成された（Kotlinがまだ1.1だったころ）ので、1.5にまでバージョンアップを成している今からすると、コンパイラの改善などで少し状況が違うケースもあるかと思いますが、述べている内容のレベルが高いので一度は目を通してみても良いかなと思います。また、記事で紹介しているKotlinのBytecodeに対しても、直接最近のKotlinが生成しているコードと比較してみるのも面白いかもですね。&lt;/p>
&lt;p>また、今回紹介している記事は&lt;code>Part 1&lt;/code>ですが、そのほかにも&lt;code>Part 2&lt;/code>や&lt;code>Part 3&lt;/code>の記事がありますので、今後も順次紹介させていただきたいと思います。では、まず&lt;code>Lambda表現式とcompanion object&lt;/code>編を、どうぞ。&lt;/p>
&lt;h2 id="高階関数とlambda表現式">高階関数とLambda表現式&lt;/h2>
&lt;p>例えば以下のような関数を定義しておいたとしましょう。渡されたパラメータをDBのトランザクションの中で実行し、実行結果の行数を返すものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">transaction&lt;/span>(db: Database, body: (Database) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.beginTransaction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> result = body(db)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.setTransactionSuccessful()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.endTransaction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数は、Lambdaを渡して以下のように使えますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> deletedRows = transaction(db) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.delete(“Customers”, &lt;span style="color:#ff79c6">null&lt;/span>, &lt;span style="color:#ff79c6">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinはJava 1.6のJVMから使えますが、Java 1.6のJVMではLambdaに対応していないのです。なので、Kotlinはその互換性を維持するためにLambda（匿名関数も）を&lt;code>Function&lt;/code>というオブジェクトを生成することで対応しています。&lt;/p>
&lt;h3 id="functionオブジェクト">Functionオブジェクト&lt;/h3>
&lt;p>では、実際コンパイルされたLambda（body）がJavaのコードとしてはどうなっているかをみていきましょう。（ここでは、Intellij/Android Studioの&lt;code>Show Kotlin Bytecode&lt;/code>の&lt;code>Decompile&lt;/code>機能を使っています）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">MyClass$myMethod$1&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">implements&lt;/span> Function1 &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// $FF: 生成されたメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#6272a4">// $FF: ブリッジメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> Object &lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Object var1&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Integer&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">valueOf&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">((&lt;/span>Database&lt;span style="color:#ff79c6">)&lt;/span>var1&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> &lt;span style="color:#50fa7b">invoke&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>@NotNull Database it&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Intrinsics&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">checkParameterIsNotNull&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>it&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;it&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> it&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">delete&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Customers&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを見るとわかりますが、Lambda（匿名関数）を使う場合、コンパイルされた結果としては基本的に3、4個のメソッドが追加で生成されるということになります。ここで追加された&lt;code>Function&lt;/code>オブジェクトのインスタンスは、必要な時にだけ生成されます。正確には、以下のような動作をします。&lt;/p>
&lt;ul>
&lt;li>value captureがある場合、毎回パラメータが渡されるたび&lt;code>Function&lt;/code>のインスタンスが生成され、GCの対象になる&lt;/li>
&lt;li>value captureがない場合、&lt;code>Function&lt;/code>はSingletonとしてインスタンスが生成され再利用できる&lt;/li>
&lt;/ul>
&lt;p>先ほどのコードでは、value captureがないため、Lambdaの呼び出し元は以下のようなコードとしてコンパイルされます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">this&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">transaction&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>db&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>Function1&lt;span style="color:#ff79c6">)&lt;/span>MyClass$myMethod$1&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">INSTANCE&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、value captureのある高階関数を繰り返し呼び出す場合はGCによる性能の低下を考えれます。&lt;/p>
&lt;h3 id="boxingオーバーヘッド">Boxingオーバーヘッド&lt;/h3>
&lt;p>Lambdaに対応しているJava 1.8以降のバージョンでは、&lt;code>Function&lt;/code>インタフェースを複数提供していることでなるべくboxing/unboxingを避けようとしています。しかし、Kotlinでコンパイルされた場合はgenericを利用しています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">/** 引数を一つ受け取る関数 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">interface&lt;/span> &lt;span style="color:#50fa7b">Function1&lt;/span>&amp;lt;&lt;span style="color:#ff79c6">in&lt;/span> P1, &lt;span style="color:#ff79c6">out&lt;/span> R&amp;gt; : Function&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">/** 引数を受け取り関数を実行する */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">operator&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">invoke&lt;/span>(p1: P1): R
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらをみてわかるのは、高階関数でパラメータとして渡された関数を呼び出す時に、その関数にprimitiveタイプの値が存在する場合（パラメータ、もしくは戻り値）boxing/unboxingが起こるということです。先ほどのコンパイルされたLambdaにおいて、戻り値が&lt;code>Integer&lt;/code>としてboxingされたのを確認できましたね。&lt;/p>
&lt;p>primitiveタイプを使用するLambdaをパラメータとしてとる高階関数は、参照回数が少なければあまり意識しなくてもよいコストになりますが、そうでない場合は性能に影響があると推定できます。&lt;/p>
&lt;h3 id="inline関数">Inline関数&lt;/h3>
&lt;p>幸い、Kotlinでは&lt;code>inline&lt;/code>と言うキーワドを提供しています。これを使うと高階関数をインライン化できますね。インライン化されると呼び出し元のコードに&lt;code>Function&lt;/code>の中身を直接含ませてコンパイルします。なので、インライン化された場合は以下のような面で性能の向上を考えられます。&lt;/p>
&lt;ul>
&lt;li>Functionオブジェクトのインスタンスが生成されない&lt;/li>
&lt;li>primitiveタイプを使う関数に対してboxing/unboxingが起こらない&lt;/li>
&lt;li>メソッドカウントが増えない（Androidの場合、アプリが参照できるメソッドの数字に制限がある）&lt;/li>
&lt;li>関数の呼び出しが増えない（CPU依存が高く、呼び出される頻度の高いコードのパフォーマンスの改善を期待できる）&lt;/li>
&lt;/ul>
&lt;p>インライン化された場合のコードを確認してみましょう。&lt;code>transaction&lt;/code>関数が消え、&lt;code>db.delete&lt;/code>を直接呼び出しているのがわかります。また、戻り値の&lt;code>result&lt;/code>もWrapperクラスからprimitiveタイプになっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>db&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">beginTransaction&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">try&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> result$iv &lt;span style="color:#ff79c6">=&lt;/span> db&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">delete&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Customers&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">setTransactionSuccessful&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">finally&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">endTransaction&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、&lt;code>inline&lt;/code>キーワードを使うときは以下のことを考慮しなければならないです。&lt;/p>
&lt;ul>
&lt;li>インライン関数は自分自身を直接呼び出したり、他のインライン関数から呼び出せない&lt;/li>
&lt;li>クラスに定義されたpublicなインライン関数はそのクラスのpublic関数とフィールドのみアクセスできる&lt;/li>
&lt;li>コンパイルされたコードが大きくなる（繰り返し参照される場合はより大きくなる）&lt;/li>
&lt;/ul>
&lt;p>なるべく高階関数をインライン化し、必要であれば長いコードブロックをインラインではない関数に写した方がいいです。また、性能が大事なところでは呼び出された関数をインライン化することも考えられます。&lt;/p>
&lt;h2 id="companion-object">Companion object&lt;/h2>
&lt;p>Kotlinではクラスがstaticなフィールドやメソッドを定義できません。その代わりに&lt;code>companion object&lt;/code>を使うことになっていますね。&lt;/p>
&lt;h3 id="クラスのprivateフィールドをcompanion-objectからアクセスする">クラスのprivateフィールドをcompanion objectからアクセスする&lt;/h3>
&lt;p>以下のような例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">constructor&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">var&lt;/span> hello = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">newInstance&lt;/span>() = MyClass()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードがコンパイスされると、&lt;code>companion object&lt;/code>はSingletonクラスになります。なので、クラスのprivateフィールドに外部クラスからアクセスできるようにする必要があり、コンパイラが&lt;code>getter&lt;/code>、&lt;code>setter&lt;/code>を追加で生成することになるということです。生成されたメソッドは&lt;code>companion object&lt;/code>から参照されることになります。以下を見てください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass.access$getHello$p (Lbe/myapplication/MyClass;)I
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ISTORE 2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaだとこれを避けるためにアクセス制限を&lt;code>package&lt;/code>単位にすることができましたが、Kotlinではそのようなキーワードがないですね。&lt;code>public&lt;/code>や&lt;code>internal&lt;/code>を使う場合も&lt;code>getter&lt;/code>と&lt;code>setter&lt;/code>は基本的に生成されます。また、これらのメソッドはinstanceメソッドであり、staticメソッドよりもコストが高いですね。なので、最適化のためフィールドのアクセス制限を変えるということは避けた方が良いです。&lt;/p>
&lt;p>もし&lt;code>companion object&lt;/code>からクラスのフィールドに頻繁なアクセスが発生するとしたら、この隠れているメソッドの呼び出しを避けるためにフィールドの値をキャッシュするという方法も考慮できます。&lt;/p>
&lt;h3 id="companion-objectの定数にアクセスする">Companion objectの定数にアクセスする&lt;/h3>
&lt;p>Kotlinでは、クラス内のstaticな定数は&lt;code>companion object&lt;/code>の中に定義するのが一般的です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> TAG = &lt;span style="color:#f1fa8c">&amp;#34;TAG&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(TAG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見シンプルで良さげなコードですが、Kotlin 1.2.40以前の場合だとかなり裏のコードは汚くなっています。&lt;/p>
&lt;h4 id="kotlin-1240以前の場合">Kotlin 1.2.40以前の場合&lt;/h4>
&lt;p>&lt;code>companion object&lt;/code>に定義されたprivateな定数にアクセスする場合、上記のようなこと（&lt;code>getter&lt;/code>を利用する）が起こります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GETSTATIC be/myapplication/MyClass.Companion : Lbe/myapplication/MyClass$Companion;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass$Companion.access$getTAG$p (Lbe/myapplication/MyClass$Companion;)Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ASTORE 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>問題はこれだけではありません。生成されたメソッドは実際の値を返すわけでなく、instanceメソッドとして生成された&lt;code>getter&lt;/code>を呼び出すことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>ALOAD 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INVOKESPECIAL be/myapplication/MyClass$Companion.getTAG ()Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>定数が&lt;code>public&lt;/code>になっている場合はダイレクトにアクセスできるようになりますが、依然として&lt;code>getter&lt;/code>メソッドを通して値にアクセスことになります。&lt;/p>
&lt;p>そして定数の値を格納するために、Kotlinコンパイラは&lt;code>companion object&lt;/code>ではなく、それを持つクラスの方に&lt;code>private static final&lt;/code>フィールドを生成します。さらに&lt;code>companion object&lt;/code>からこのフィールドにアクセスするため、またのメソッドを生成することとなります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>INVOKESTATIC be/myapplication/MyClass.access$getTAG$cp()Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>こういう長い道のりで、やっと値を読み込むことになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GETSTATIC be/myapplication/MyClass.TAG : Ljava/lang/String;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ARETURN
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まとめると、Kotlin 1.2.40以前のバージョンを使っている場合は以下のようになります。&lt;/p>
&lt;ul>
&lt;li>&lt;code>companion object&lt;/code>から静的メソッドを呼び出す
&lt;ul>
&lt;li>&lt;code>companion object&lt;/code>からinstanceメソッドを呼び出す
&lt;ul>
&lt;li>クラスのstaticメソッドを呼び出す
&lt;ul>
&lt;li>staticフィールドから値を読み込む&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>これをJavaのコードで表現すると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String TAG &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;TAG&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Companion companion &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Companion&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 生成されるメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String &lt;span style="color:#50fa7b">access$getTAG$cp&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> TAG&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Companion&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String &lt;span style="color:#50fa7b">getTAG&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> MyClass&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">access$getTAG$cp&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 生成されるメソッド
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String &lt;span style="color:#50fa7b">access$getTAG$p&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Companion c&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> c&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getTAG&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">helloWorld&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Companion&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">access$getTAG$p&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>companion&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>よりコストの低いBytecodeを生成することも可能ですが、それは簡単ではないです。&lt;/p>
&lt;p>まず&lt;code>const&lt;/code>キーワードを使ってコンパイルタイム定数を定義することでメソッドの呼び出しをなくすことができます。しかし、KotlinではprimitiveかStringに対してのみ可能な方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">const&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> TAG = &lt;span style="color:#f1fa8c">&amp;#34;TAG&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">helloWorld&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(TAG)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または&lt;code>@JvmField&lt;/code>を使ってJavaのアプローチを取る方法を考えられます。こうすることで&lt;code>getter&lt;/code>や&lt;code>setter&lt;/code>が生成されず、フィールドに直接アクセスができるようになります。ただ、&lt;code>@Jvm&lt;/code>系のアノテーションはJavaとの互換性のためのものであるのでこれが果たして良い方法かどうかを考えた方が良いでしょう。そして&lt;code>public&lt;/code>なフィールドのみ可能な方法です。&lt;/p>
&lt;p>Androidの開発の場合だと、&lt;code>Parcelable&lt;/code>オブジェクトを自前で実装する場合のみ有効な方法に思われます。例えば以下のようにですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span>() : Parcelable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">companion&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @JvmField
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> CREATOR = creator { MyClass(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">constructor&lt;/span>(parcel: Parcel) : &lt;span style="color:#ff79c6">this&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">writeToParcel&lt;/span>(dest: Parcel, flags: Int) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">describeContents&lt;/span>() = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最後の方法として、&lt;a class="link" href="https://developer.android.com/studio/build/shrink-code" target="_blank" rel="noopener"
>ProGuard&lt;/a>やR8のようなツールを使ってBytecodeの最適化を狙うという方法があるでしょう。&lt;/p>
&lt;h4 id="kotlin-1240以降の場合">Kotlin 1.2.40以降の場合&lt;/h4>
&lt;p>Kotlinn 1.2.40からは、&lt;code>companion object&lt;/code>に定義された値はメインクラスの方に格納されるということには変わりがありませんが、メソッドの生成と呼び出しなしで直接アクセスができるようになりました。これをJavaのコードとして表現すると以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">MyClass&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> String TAG &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;TAG&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> Companion companion &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Companion&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Companion&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">final&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">helloWorld&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">out&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">println&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>TAG&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、上記のように&lt;code>companion object&lt;/code>にメソッドが一つもない場合は、ProGuardやR8によるツールと使うとクラス自体が消えることで最適化されます。&lt;/p>
&lt;p>ただ、&lt;code>companion object&lt;/code>に定義さえたメソッドの場合はコストが少しかかります。フィールドがメインクラスの方に格納されてあるため、&lt;code>companion object&lt;/code>に定義されたprivateフィールドにアクセスするためには依然として生成されたメソッドを経由することになります。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は人の書いた記事を読んだだけですが、かなり勉強になる内容でした。特に私個人としては、intellijを使っていると何を基準に&lt;code>inline&lt;/code>キーワードを使った方がいいという警告が出るのか悩ましい場面がありましたが、それが少し理解できました。&lt;code>companion object&lt;/code>に関する話も、今は問題が解決されたものの、何も考えず「定数だから&lt;code>companion object&lt;/code>だな」と思っていた自分を反省することになりましたね。そしてこの後の記事でも面白い内容が色々と出てくるので、またの機会でぜひ紹介したいと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その三〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-3/</link><pubDate>Sat, 18 Sep 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-3/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その三〜" />&lt;p>JavaからKotlinに移行したものの立場から言うと、Kotlinはスタンダードライブラリだけでも色々な関数を提供しているので、Javaに比べてかなり生産性が上がるといえますが、逆にいまいち関数の有効な使い方がわからなかったり、どうやって処理を書いたら「Kotlinらしい」かわからない場合もあるかと思います。なのでもう3回目のポストになりますが、今回もKotlinで色々とコードを書いてみて、そのうち良さそうなものをいくつか共有します。&lt;/p>
&lt;h2 id="listの要素をスワップ">Listの要素をスワップ&lt;/h2>
&lt;p>Listの要素の順番を変える方法はソートなどを含め色々とありますが、二つの要素をスワップ（インデックスを交換）したい場合もあるかと思います。こういう時に活用できる拡張関数を考えてみました。&lt;/p>
&lt;h3 id="インデックスがわかる場合">インデックスがわかる場合&lt;/h3>
&lt;p>スワップしたい要素のインデックスがわかる場合は、そのインデックスを交換すればいいだけですね。ここでインデックスの交換は、二つの変数の値をスワップすることと変わらないです。変数の値を交換するのは伝統的には以下のような方法がありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> a = &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> b = &lt;span style="color:#bd93f9">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> c = a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b = c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もう少しKotlinらしい方法では、&lt;code>also&lt;/code>を用いたものがあります。その方法だと、必要な処理は以下のようにもっとシンプルになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> a = &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> b = &lt;span style="color:#bd93f9">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a = b.also { b = a }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これと同じく、Listの要素をスワップする処理を拡張関数で書くとしたらと以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;T&amp;gt;.swapByIndex(indexFrom: Int, indexTo: Int): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> toMutableList().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span>[indexFrom] = &lt;span style="color:#ff79c6">this&lt;/span>[indexTo].also { &lt;span style="color:#ff79c6">this&lt;/span>[indexTo] = &lt;span style="color:#ff79c6">this&lt;/span>[indexFrom] }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.toList()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="インデックスがわからない場合">インデックスがわからない場合&lt;/h3>
&lt;p>スワップしたい要素のインデックスがわからない場合もありますが、これも結局インデックスを持って値をスワップすることになるので、まずインデックスを抽出する処理だけを足せば良いかなと思います。&lt;/p>
&lt;p>インデックスを取得する方法は、要素を渡して取得する&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index-of.html" target="_blank" rel="noopener"
>indexOf&lt;/a>とPredicateを渡して取得する&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index-of-first.html" target="_blank" rel="noopener"
>indexOfFirst&lt;/a>があるので、これらを活用することにします。あとはこれらの方法で取得したインデックスを、先に実装しておいた拡張関数に渡すだけで良いです。例えば以下のような実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// indexOf(element)を使うケース
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;T&amp;gt;.swapByElement(from: T, to: T): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swapByIndex(indexOf(from), indexOf(to))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// indexOfFirst(predicate)を使うケース
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;T&amp;gt;.swapByCondition(from: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Boolean, to: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Boolean): List&amp;lt;T&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swapByIndex(indexOfFirst { from(&lt;span style="color:#ff79c6">it&lt;/span>) }, indexOfFirst { to(&lt;span style="color:#ff79c6">it&lt;/span>) })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="時間を数字に">時間を数字に&lt;/h2>
&lt;p>&lt;code>java.time&lt;/code>パッケージの&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>のようなオブジェクトは、コード上で時間を扱うには便利ですが、ファイルに書き込むなどでフォーマットを変更する必要がある時もあります。つまり、&lt;code>yyyy-MM-dd&lt;/code>ではなく&lt;code>yyyyMMddhhmmss&lt;/code>のような形にしたい場合があるということです。こういうときは、簡単にInt型に変更できる拡張関数を書いておくと便利でしょう。例えば以下のようなものを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">LocalDate&lt;/span>.toInt(): Int = &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$year$monthValue$dayOfMonth&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> date = LocalDate.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">12&lt;/span>, &lt;span style="color:#bd93f9">31&lt;/span>) &lt;span style="color:#6272a4">// 2021-12-31
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(date.toInt()) &lt;span style="color:#6272a4">// 20211231
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、こうする場合、以下のように月や日付が一桁のものになってしまうケースもあります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> date = LocalDate.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>) &lt;span style="color:#6272a4">// 2021-09-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(date.toInt()) &lt;span style="color:#6272a4">// 202191
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この問題を解決するには、まず月や日付を二桁の文字列に変える必要がありますね。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">LocalDate&lt;/span>.toInt(): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$year${monthValue.toString().padStart(2, &amp;#39;0&amp;#39;)}${dayOfMonth.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> date = LocalDate.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>) &lt;span style="color:#6272a4">// 2021-09-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(date.toInt()) &lt;span style="color:#6272a4">// 20210901
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これでも完璧とはいえません。&lt;code>LocalDate&lt;/code>のみでなく&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>, &lt;code>YearMonth&lt;/code>など、&lt;code>java.time&lt;/code>パッケージに属する他のオブジェクトも使いたい場合には、全てのオブジェクトに対して同じような拡張関数を書く必要があるからです。&lt;/p>
&lt;p>幸い、&lt;code>LocalDate&lt;/code>、&lt;code>LocalDateTime&lt;/code>、&lt;code>YearMonth&lt;/code>は共通的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/temporal/Temporal.html" target="_blank" rel="noopener"
>Temporal&lt;/a>というインタフェースを継承しているので、&lt;code>Temporal&lt;/code>に拡張関数を追加することで問題は解決できます。&lt;/p>
&lt;p>そしてこれらの実装クラスで扱っている時間の範囲はオブジェクトごとに違うので、実装も変える必要がありますね。これらのオブジェクトはどれも時間を数字として表現しているので、まず&lt;code>toString&lt;/code>で文字列に変換した後、数字だけを抽出することです。&lt;code>String&lt;/code>は&lt;code>CharSequence&lt;/code>を継承しているので、&lt;code>filter&lt;/code>で数字だけを抽出すると良いでしょう。そうすると、以下のような方法が使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Temporal&lt;/span>.toDigit(): Long = toString().filter { &lt;span style="color:#ff79c6">it&lt;/span>.isDigit() }.toLong()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> yearMonth = YearMonth.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>) &lt;span style="color:#6272a4">// 2021-08
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(yearMonth.toDigit()) &lt;span style="color:#6272a4">// 202108
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> dateTime = LocalDateTime.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>) &lt;span style="color:#6272a4">// 2021-10-02T10:10:10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(dateTime.toDigit()) &lt;span style="color:#6272a4">// 20211002101010
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Stringのフォーマットで数字に変換する場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int.html" target="_blank" rel="noopener"
>toInt&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-long.html" target="_blank" rel="noopener"
>toLong&lt;/a>でループが一回発生するだけですが、CharSequenceとして扱う場合はループが2回発生するという違いがあるので性能的には前者が良いはずですが、時間を扱うくらいではそこまでループは長くないので気にするほどではないかと思います。&lt;/p>
&lt;h2 id="要素の一部を合算">要素の一部を合算&lt;/h2>
&lt;p>Listの値を一つに集約したい（合算値を出したい）場合があります。&lt;code>sum&lt;/code>を使っても良いですが、これはそもそも要素が数字ではないと難しいですね。例えば要素が以下のようなクラスとなっているケースはどうしたら良いでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Data&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> amount: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> price: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="合算したい値が一つの場合">合算したい値が一つの場合&lt;/h3>
&lt;p>合算したい値が一つだけの場合は、&lt;code>sumOf&lt;/code>で合算したい値だけを指定すれば良いです。以下は、&lt;code>Data&lt;/code>クラスの&lt;code>amount&lt;/code>だけを合算したい場合に使える方法です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(Data(&lt;span style="color:#f1fa8c">&amp;#34;data1&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>, &lt;span style="color:#bd93f9">100&lt;/span>), Data(&lt;span style="color:#f1fa8c">&amp;#34;data2&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">20&lt;/span>, &lt;span style="color:#bd93f9">200&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> totalAmount = list.sumOf { &lt;span style="color:#ff79c6">it&lt;/span>.amount }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="合算したい値が複数の場合">合算したい値が複数の場合&lt;/h3>
&lt;p>ここで&lt;code>amount&lt;/code>のみでなく、&lt;code>price&lt;/code>も合算したい場合はどうすれば良いでしょう。同じく&lt;code>sumOf&lt;/code>を&lt;code>price&lt;/code>にも使うことで実装はできますが、同じListに対してループが2回も発生するのあまり効率的ではありません。こういうときは、素直にそれぞれの合算値を変数として宣言しておいて&lt;code>forEach&lt;/code>ループの中で値を足していく方が効率が良いでしょう。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> totalAmount = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> totalPrice = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> totalAmount &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.amount
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> totalPrice &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.price
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>もう一つの方法は、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold.html" target="_blank" rel="noopener"
>fold&lt;/a>を使う方法です。&lt;code>fold&lt;/code>は&lt;code>reduce&lt;/code>と似たようなもので、初期値(initial)を指定できるという違いがありますが、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/reduce-to.html" target="_blank" rel="noopener"
>reduceTo&lt;/a>のようにこの初期値の型はListの要素とは違うものに指定できます。そして関数を実行した結果はinitialと同じ型になるので、これを応用すると&lt;code>Data&lt;/code>のリストを二つの値(&lt;code>Pair&lt;/code>)に&lt;code>reduce&lt;/code>することもできます。例えば上記の処理は&lt;code>fold&lt;/code>を使うと以下のようにワンライナで実装ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> (totalAmount, totalPrice) = list.fold(&lt;span style="color:#bd93f9">0&lt;/span> to &lt;span style="color:#bd93f9">0&lt;/span>) { acc, &lt;span style="color:#ff79c6">value&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (acc.first + &lt;span style="color:#ff79c6">value&lt;/span>.amount) to (acc.second + &lt;span style="color:#ff79c6">value&lt;/span>.price)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>fold&lt;/code>を使う場合、合算したい値が三つある場合は&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-triple/" target="_blank" rel="noopener"
>Triple&lt;/a>を使うこともできますし、さらに値が多い場合は専用のクラスを作ることで対応もできるかと思います。ただ、こうする場合、合算した値を&lt;code>val&lt;/code>として宣言できるというメリットはありますが、ループごとにインスタンスが作成されるので合算したい項目が増えれば増えるほど性能的にはあまり良くない可能性が高いので場合によって適切なものを選ぶ必要がありそうですね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがだったでしょうか。私はずっとJavaでコードを書いていたので、完全にKotlinに転向した今でもついJavaらしいコードを書いてしまうのではないか、と思う時があります。元を辿ると、「Javaらしいコード」や「Kotlinらしいコード」がそもそも何であるかを考えなければならないとは思いますが、それでも、確かに言語が違うとその言語に合わせて自分のコーディングスタイルも変化する必要はあるのではないかと思います。そうすることで、より良いコードが書けるようになりそうな気がしていますので。&lt;/p>
&lt;p>というわけで、これからもKotlinならではの、Kotlinに特化したコードを書くための工夫はこれからも続きます。特に今月はJava 17もリリースされたので、新しいAPIの一覧を眺めてKotlinではどう活用できるか考えてみたいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その二〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-2/</link><pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-2/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その二〜" />&lt;p>&lt;a class="link" href="../kotlin-code-in-my-style-1" >前回&lt;/a>に続いて、今回も簡単にKotlinで色々書いてみましたのでその紹介となります。Kotlinではスタンダードライブラリや言語仕様として提供している機能がかなり多いので、これらを使いこなすだけでも生産性やコードのクォリティが大幅に上がるのではないかと思います。なので、今回もJava的な書き方を、Kotlinではどんな方法で効率よく実現できるかを中心に紹介したいと思います。&lt;/p>
&lt;p>もちろんKotlinでは基本的にJavaの書き方でも全く問題なく動くコードを書けますが、Kotlinならではのコードに変えた方がより簡単で短いコードを書ける場合が多く、色々と手間を省けることができるので（そして大抵の場合、スタンダードライブラリの実装の方が自分の書いたコードよりクォリティ高いような…）こういう工夫はする価値が十分にあるのではないかと思います。&lt;/p>
&lt;p>なので、今回は自分が調べたKotlinの小技を少し紹介したいと思います。&lt;/p>
&lt;h2 id="sequentialなデータを作成する">Sequentialなデータを作成する&lt;/h2>
&lt;p>よくユニットテストなどでテスト用データを作成して使う場合がありますね。こういう時に必要となるデータの種類は色々とあるかと思いますが、複数のレコードを番号をつけて順番に揃えた感じのものを作りたい場合もあると思います。例えばData01、Data02、Data03…といったデータを作りたい場合ですね。&lt;/p>
&lt;p>この場合は、ループでデータを作り、Listにまとめるというのが一般的ではないかと思います。例えば以下のような例があるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// テスト用データを作成する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createTestDatas&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// テスト用データのリスト
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> testDatas = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 10件のデータを追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">for&lt;/span> (i &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> until &lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testDatas.add(&lt;span style="color:#f1fa8c">&amp;#34;テスト&lt;/span>&lt;span style="color:#f1fa8c">$i&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// read-onlyに変換して返却
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">return&lt;/span> testDatas.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、どちらかというとこれはJavaのやり方に近いので、まずはこれをベースに、Kotlinらしきコードではどうやって同じことができるかを考えてみたいと思います。&lt;/p>
&lt;h3 id="repeat">repeat&lt;/h3>
&lt;p>まず考えられる方法は、ループの単純化ですね。サイズが10のリストを作りたいということは、ループが10回であることなので、それに相応しい関数を使います。例えば&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html" target="_blank" rel="noopener"
>repeat&lt;/a>がありますね。&lt;code>repeat&lt;/code>を使うと、スコープ内のパラメータとしてインデックスが渡されるので、簡単に&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createTestDatas&lt;/span>(): List&amp;lt;String&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> testDatas = mutableListOf&amp;lt;String&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 10回繰り返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> repeat(&lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testDatas.add(&lt;span style="color:#f1fa8c">&amp;#34;テスト&lt;/span>&lt;span style="color:#f1fa8c">$i&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> testDatas.toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に考えたいのは、&lt;code>MutableList&lt;/code>を&lt;code>Immutable&lt;/code>に変えることです。テストで使うデータとしては問題ない場合はありますが、変更する必要のないデータをそのまま&lt;code>Mutable&lt;/code>にしておくのはあまり良い選択ではありませんね。なので、データの作成を最初から&lt;code>List&lt;/code>にできる方法を取りたいものです。&lt;/p>
&lt;p>ここでは二つの道があって、最初からサイズを指定した&lt;code>List&lt;/code>を宣言するか、ループの範囲、つまり&lt;a class="link" href="https://kotlinlang.org/docs/ranges.html#range" target="_blank" rel="noopener"
>Range&lt;/a>を指定する方法があります。&lt;/p>
&lt;h3 id="list">List&lt;/h3>
&lt;p>まずはサイズを指定した&lt;code>List&lt;/code>を作る方法からみていきましょう。インスタンスの作成時に、サイズと要素に対してのイニシャライザを引数として渡すことで簡単に指定したサイズ分の要素を作ることができます。例えば、上で紹介したコードは&lt;code>List&lt;/code>を使うことで以下のように変えることができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createTestDatasByList&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(&lt;span style="color:#bd93f9">10&lt;/span>) { &lt;span style="color:#f1fa8c">&amp;#34;テスト&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この方法は、実は先に紹介した方法と根本的に違うものではありません。実装としては、以下のようになっているので、Syntax sugarとして使えるということがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@SinceKotlin(&lt;span style="color:#f1fa8c">&amp;#34;1.1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@kotlin.&lt;span style="color:#ff79c6">internal&lt;/span>.InlineOnly
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>(size: Int, &lt;span style="color:#ff79c6">init&lt;/span>: (index: Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): List&amp;lt;T&amp;gt; = MutableList(size, &lt;span style="color:#ff79c6">init&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@SinceKotlin(&lt;span style="color:#f1fa8c">&amp;#34;1.1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@kotlin.&lt;span style="color:#ff79c6">internal&lt;/span>.InlineOnly
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">MutableList&lt;/span>(size: Int, &lt;span style="color:#ff79c6">init&lt;/span>: (index: Int) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> T): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> list = ArrayList&amp;lt;T&amp;gt;(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(size) { index &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> list.add(&lt;span style="color:#ff79c6">init&lt;/span>(index)) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも&lt;code>List&lt;/code>を使う場合は、&lt;code>itnit&lt;/code>としてどんな関数を渡すかによって、&lt;code>step&lt;/code>の設定などができるのも便利ですね。例えば以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#bd93f9">5&lt;/span>) { &lt;span style="color:#f1fa8c">&amp;#34;Test&lt;/span>&lt;span style="color:#f1fa8c">${ it * 2 }&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// [Test0, Test2, Test4, Test6, Test8]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>List(&lt;span style="color:#bd93f9">5&lt;/span>) { (&lt;span style="color:#ff79c6">it&lt;/span> * &lt;span style="color:#bd93f9">2&lt;/span>).let { index &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$index&lt;/span>&lt;span style="color:#f1fa8c"> は偶数&amp;#34;&lt;/span> } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// [0 は偶数, 2 は偶数, 4 は偶数, 6 は偶数, 8 は偶数]
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、結果的に作られる&lt;code>List&lt;/code>のインスタンスは&lt;code>MutableList&lt;/code>なので、生成したデータをread-onlyにしたい場合はまたこれを&lt;code>toList()&lt;/code>などで変換する必要があるという問題があります。&lt;/p>
&lt;h3 id="range">Range&lt;/h3>
&lt;p>では、もう一つの方法をまた試してみましょう。Kotlinでは数字の範囲を指定することだけで簡単に&lt;code>Range&lt;/code>オブジェクトを作成することができます。&lt;code>Range&lt;/code>を使う場合、上記のコードは以下のように変えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Rangeを使ってテストデータを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">createTestDatasByRange&lt;/span>(): List&amp;lt;String&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#bd93f9">0.&lt;/span>.&lt;span style="color:#bd93f9">10&lt;/span>).map { &lt;span style="color:#f1fa8c">&amp;#34;テスト%it&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>List&lt;/code>の時とは違って、&lt;code>Range&lt;/code>には&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-int-range" target="_blank" rel="noopener"
>IntRange&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-long-range" target="_blank" rel="noopener"
>LongRange&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-char-range" target="_blank" rel="noopener"
>CharRange&lt;/a>などがあり、引数の数字や文字を調整することで簡単にアレンジができるということも良いです。&lt;/p>
&lt;p>また、一般的に性能は&lt;code>List&lt;/code>より&lt;code>Range&lt;/code>の方が良いようです。以下のようなコードでベンチマークした際、大抵&lt;code>Range&lt;/code>の方が&lt;code>List&lt;/code>の倍ぐらい早いのを確認できました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">import&lt;/span> kotlin.system.measureTimeMillis
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Person&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> name: String, &lt;span style="color:#ff79c6">val&lt;/span> Num: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark { list() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> benchmark { range() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">benchmark&lt;/span>(function: () &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Unit) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(measureTimeMillis { function() })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">list&lt;/span>() =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List(&lt;span style="color:#bd93f9">200000&lt;/span>) { Person(&lt;span style="color:#f1fa8c">&amp;#34;person&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">range&lt;/span>(): List&amp;lt;Person&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#bd93f9">0.&lt;/span>.&lt;span style="color:#bd93f9">200000&lt;/span>).map { Person(&lt;span style="color:#f1fa8c">&amp;#34;person&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>, &lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一つ気にしなくてはならないのは、&lt;code>Range&lt;/code>の場合は基本的に値が1づつ増加することになっているので、&lt;code>for&lt;/code>や&lt;code>List&lt;/code>のような&lt;code>step&lt;/code>の条件が使えません。なので場合によってどちらを使うかは考える必要があります。&lt;/p>
&lt;h2 id="check">Check&lt;/h2>
&lt;p>Validationなどで、パラメータの値を確認しなければならない場合があります。Kotlinでは&lt;code>Nullable&lt;/code>オブジェクトとそうでないオブジェクトが分けられているので、Javaと違って引数に&lt;code>null&lt;/code>が渡される場合はコンパイルエラーとなりますが、ビジネスロジックによってはそれ以外のことをチェックする必要もあり、自前のチェックをコードで書くしかないです。&lt;/p>
&lt;p>まず、お馴染みのJavaのやり方を踏襲してみると、以下のようなコードを書くことができるでしょう。関数の引数と、その戻り値のチェックが含まれている例です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: String): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (parameter.isBlank()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#f1fa8c">&amp;#34;文字列が空です&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> result = someRepository.find(parameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (result &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#ff79c6">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> IllegalStateException(&lt;span style="color:#f1fa8c">&amp;#34;結果がnullです&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで少し違う言語の例をみていきたいと思います。Kotlinとよく似ていると言われているSwiftの場合、ここで&lt;a class="link" href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#grammar_if-statement" target="_blank" rel="noopener"
>Guard Statement&lt;/a>を使うのが一般的のようです。チェックのための表現が存在することで、ビジネスロジックとチェックが分離されるのが良いですね。Swiftをあまり触ったことがないので良い例にはなっていないかも知れませんが、イメージ的には以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-swift" data-lang="swift">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">func&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span>) &lt;span style="color:#ff79c6">throws&lt;/span> -&amp;gt; &lt;span style="color:#8be9fd;font-style:italic">String&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">guard&lt;/span> &lt;span style="color:#ff79c6">!&lt;/span>parameter.isEmpty &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> ValidationError.invalidArgument
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">guard&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">let&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">result&lt;/span> = someRepository.find(parameter) &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> ValidationError.notFound
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>同じく、Kotlinでもチェックのための表現とビジネスロジックが分離できれば、コードの意味がより明確になるはずです。Kotlinではどうやってそれを実現できるのでしょうか。例えば以下のようなことを考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: String?): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> checkedParameter = requireNotNull(parameter) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;文字列がnullです&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> result = someRepository.find(checkedParameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> checkNotNull(result) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;結果がnullです&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require-not-null.html" target="_blank" rel="noopener"
>requireNotNull&lt;/a>は、渡された引数が&lt;code>null&lt;/code>である場合は&lt;code>IllegalArgumentException&lt;/code>を投げ、そうでない場合は引数を&lt;code>non-null&lt;/code>タイプとして返します、明確に&lt;code>null&lt;/code>チェックをしていることが解るだけでなく、以降チェックがいらないので便利です。また、&lt;code>lazy message&lt;/code>として&lt;code>IllegalArgumentException&lt;/code>が発生した時のメッセージを指定できるのも良いですね。&lt;/p>
&lt;p>&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html" target="_blank" rel="noopener"
>checkNotNull&lt;/a>の場合も機能的には&lt;code>requireNotNull&lt;/code>と変わらないですが、&lt;code>null&lt;/code>の場合に投げる例外が&lt;code>IllegalStateException&lt;/code>となります。なので、用途に合わせてこの二つを分けて使えますね。&lt;/p>
&lt;p>他に使えるものとしては&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html" target="_blank" rel="noopener"
>require&lt;/a>があります。こちらは条件式を渡すことで、&lt;code>null&lt;/code>チェック以外のこともできます。なので、以下のコードのように、&lt;code>Int&lt;/code>型のデータに対して範囲をチェックするということもできるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> require(parameter &amp;gt; &lt;span style="color:#bd93f9">100&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$parameterは大きすぎます&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にも、&lt;a class="link" href="https://kotlinlang.org/docs/null-safety.html#elvis-operator" target="_blank" rel="noopener"
>Elvis operator&lt;/a>を使う方法もありますね。この場合は、&lt;code>null&lt;/code>の場合にただ例外を投げるだけでなく、代替となる処理を書くことができますので色々と活用できる余地があります。例えば以下のようなことができますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">doSomething&lt;/span>(parameter: String?): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> checkedParameter = parameter &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> result = someRepository.find(checkedParameter)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result &lt;span style="color:#ff79c6">?:&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> CustomException(&lt;span style="color:#f1fa8c">&amp;#34;結果がnullです&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="listの分割">Listの分割&lt;/h2>
&lt;p>とある条件と一致するデータをListから抽出したい場合は、&lt;code>filter&lt;/code>のようなoperationを使うことでできます。しかし、条件が二つだとどうすればいいでしょうか。正確には、一つのリストに対して、指定した条件に一致する要素とそうでない要素の二つのリストに分離したい場合です。&lt;/p>
&lt;p>こういう場合はとりあえず下記のように2回ループさせる方法があると思いますが、これはあまり効率がよくないです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> origin = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 奇数を抽出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> odd = origin.filter { &lt;span style="color:#ff79c6">it&lt;/span> % &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 偶数を抽出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> even = origin.filter { &lt;span style="color:#ff79c6">it&lt;/span> % &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ループを減らすためには、あらかじめ宣言したリストに対してループの中で分岐処理を行うという方法があるでしょう。例えば以下のようにです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> origin = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 奇数と偶数のリストを宣言しておく
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> odd = mutableListOf&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> even = mutableListOf&amp;lt;Int&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ループ処理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>origin.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">it&lt;/span> % &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> odd.add(&lt;span style="color:#ff79c6">it&lt;/span>) &lt;span style="color:#6272a4">// 奇数のリストに追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> even.add(&lt;span style="color:#ff79c6">it&lt;/span>) &lt;span style="color:#6272a4">// 偶数のリストに追加
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>幸い、この状況にぴったりな方法をKotlinのスタンダードライブラリが提供しています。&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/partition.html" target="_blank" rel="noopener"
>partition&lt;/a>というoperationです。このopreationを使うと、元のリストの要素を条件に一致するものとそうでないもので分割してくれます。&lt;/p>
&lt;p>また、&lt;code>partition&lt;/code>戻り値は&lt;code>Pair&amp;lt;List&amp;lt;T&amp;gt;, List&amp;lt;T&amp;gt;&amp;gt;&lt;/code>なので、&lt;a class="link" href="https://kotlinlang.org/docs/destructuring-declarations.html" target="_blank" rel="noopener"
>destructuring-declaration&lt;/a>と組み合わせることでかなり短いコードになります。実際のコードは以下のようになるりますが、かなりスマートですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> origin = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> (odd, even) = origin.partition { &lt;span style="color:#ff79c6">it&lt;/span> % &lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">!=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> } &lt;span style="color:#6272a4">// 条件に一致するものと一致しないものでリストを分離
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>Kotlinは便利ではありますが、言語自体が提供する便利さ（機能）が多いゆえに、APIの使い方を正しく活用できるかどうかでコードのクォリティが左右される部分が他の言語と比べ多いような気がしています。さらにバージョンアップも早く、次々と機能が追加されるのでキャッチアップも大事ですね。&lt;/p>
&lt;p>でも確かに一つづつKotlinでできることを工夫するうちに、色々とできることが増えていく気もしていますね。研究すればするほど力になる言語を使うということは嬉しいことです。ということで、これからもKotlinで書いてみたシリーズは続きます。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Sequenceは常にいいか</title><link>https://retheviper.github.io/posts/kotlin-collection-and-sequence/</link><pubDate>Sun, 13 Jun 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-collection-and-sequence/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Sequenceは常にいいか" />&lt;p>とある処理を書く方法が色々ある場合は、どれを選んだ方がもっとも良いかと悩ましくなります。こういう場合は、コードの読みやすさやコードの長さ、予想される問題のようなさまざまな観点からそれぞれの方式を比較してどれを選ぶか判断することになりますね。ただ、このような観点から判断するのは多くの場合「書き方が全く違う」場合に有効であって、そもそも似たようなコードを書くことになる場合は他の観点からも考える必要があります。ほんの少しだけ違うから、見た目だけでは違いがわからない場合。こういう時はそのAPIの内部、メカニズムからちゃんと考えて選ぶ必要がありますね。&lt;/p>
&lt;p>そういう意味で、今回はKotlinのCollectionの処理に使える方法の二つ、「Collectionのoperation直接使う」場合と「Sequenceに変換してから処理する」場合の違いに関して述べたいと思います。&lt;/p>
&lt;h2 id="処理方式の違い">処理方式の違い&lt;/h2>
&lt;p>Javaでは、Collectionの要素を持って処理をする方法は色々とありますが、大きく分けて1.8以前の方法(&lt;code>for&lt;/code>や&lt;code>while&lt;/code>などを利用したループ)と1.8以降の方法(&lt;code>Stream&lt;/code>を使った方法)があると言ってもいいのではないかと思います。この二つの方法はそもそもベースとなっているパラダイムそのものが違うので、コードを書くスタイルから大きく違います。例えば同じ処理をしたい場合でも、以下のコードで確認できるように、見た目が完全に違います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// forループの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">filterEven&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Integer&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> list &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>1&lt;span style="color:#ff79c6">,&lt;/span> 2&lt;span style="color:#ff79c6">,&lt;/span> 3&lt;span style="color:#ff79c6">,&lt;/span> 4&lt;span style="color:#ff79c6">,&lt;/span> 5&lt;span style="color:#ff79c6">,&lt;/span> 6&lt;span style="color:#ff79c6">,&lt;/span> 7&lt;span style="color:#ff79c6">,&lt;/span> 8&lt;span style="color:#ff79c6">,&lt;/span> 9&lt;span style="color:#ff79c6">,&lt;/span> 10&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> result &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ArrayList&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>Integer i &lt;span style="color:#ff79c6">:&lt;/span> list&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>i &lt;span style="color:#ff79c6">%&lt;/span> 2 &lt;span style="color:#ff79c6">==&lt;/span> 0&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">add&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toString&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>result&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">size&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> 3&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> result&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Streamを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> &lt;span style="color:#50fa7b">filterEvenStream&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>1&lt;span style="color:#ff79c6">,&lt;/span> 2&lt;span style="color:#ff79c6">,&lt;/span> 3&lt;span style="color:#ff79c6">,&lt;/span> 4&lt;span style="color:#ff79c6">,&lt;/span> 5&lt;span style="color:#ff79c6">,&lt;/span> 6&lt;span style="color:#ff79c6">,&lt;/span> 7&lt;span style="color:#ff79c6">,&lt;/span> 8&lt;span style="color:#ff79c6">,&lt;/span> 9&lt;span style="color:#ff79c6">,&lt;/span> 10&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">filter&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> i &lt;span style="color:#ff79c6">%&lt;/span> 2 &lt;span style="color:#ff79c6">==&lt;/span> 0&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">map&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>i &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> i&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toString&lt;/span>&lt;span style="color:#ff79c6">())&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">limit&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>3&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">());&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Streamを使った処理の場合はoperationを積み重ねて行く形をしていますが、これは現代の関数型プログラミングに対応している言語ならどれも持っているAPIといえます。例えばKotlin, 公式的には呼び方が色々あるようですが、一部では&lt;code>Functional function&lt;/code>という名で呼ばれているようで、今回はこの操作方式、Functional functionについて述べたいと思います。&lt;/p>
&lt;p>KotlinではCollectionでもこのようなopreationがあり、Kotlin版のStreamとも言える&lt;a class="link" href="https://kotlinlang.org/docs/sequences.html" target="_blank" rel="noopener"
>Sequence&lt;/a>でも同様の操作できるようになっています。また、JavaのStreamをそのまま使うこともできるので、Functional functionを使った処理は三つがあるといえますね。それぞれの使い方もあまり変わりません。なので以下のようなコードで同じ処理ができますが、それが帰って悩ましくなるところでもあります。「どれを使ったらいい？」とですね。例えば同じ処理をしたい場合でも、Kotlinでは以下のように色々な方法を使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Collectionの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">filterEven&lt;/span>(): List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>).filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }.map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }.take(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Sequenceを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">filterEvenSequence&lt;/span>: List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>).asSequence().filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }.map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }.take(&lt;span style="color:#bd93f9">3&lt;/span>).toList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// JavaのStream APIを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">filterEvenStream&lt;/span>(): List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>).stream().filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }.map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }.limit(&lt;span style="color:#bd93f9">3&lt;/span>).collect(Collectors.toList())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記のコードは見た目ではあまり違いがわからないですね。処理やロジックが大きく変わる訳でもありません。使い方があまり変わらなく、結果としても同じようなものを期待できるとしたら、やはり次に気にすべきは「性能」ではないかと思います。特にCollectionよりもSequenceの方がより性能がいいという話もありますので、それならなるべくSequenceを使った方が絶対良いはずですね。&lt;/p>
&lt;p>しかし、それを事実と受け止めるとしたら、いくつかの疑問が残ります。常にSequenceの方が性能で有利だとしたら、なぜCollectionからFunctional functionを呼び出す時は内部でSequenceに変換するようにするのでなく、わざわざ&lt;code>asSequence()&lt;/code>を呼び出して明示的な変換をさせるのでしょうか？もしくはなぜCollectionでもFunctional functionを呼び出せるようにしているのでしょうか？これはつまり、SequenceがCollectionよりも性能がよくなるのは「とある条件下に限る」ということではないでしょうか。なので、今回は主に性能の観点から、CollectionとSequenceの違いについて述べましょう。&lt;/p>
&lt;h3 id="lazy-evaluation">Lazy evaluation&lt;/h3>
&lt;p>KotlinのSequenceは、元々JavaのStreamと同じ名前になる予定だったそうです。これはただの偶然ではなく、実際の処理もStreamに似ているからです。何が似ているかというと、&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1" target="_blank" rel="noopener"
>Lazy evaluation&lt;/a>という概念です。これは簡単に言いますと、「なるべく処理を遅延させる = 必要とされるまでは処理をしない」ということですね。そして多くの場合、Sequenceを使うとこのLazy evaluationのおかげで性能がよくなるという話があります。これはつまり、Sequenceは処理を遅延することでCollectionより良い性能を期待できる、ということになるでしょう。&lt;/p>
&lt;p>しかし、単純に処理を遅延させることががなぜ性能を向上させる事になるのか、すぐに納得は行きません。まず、ループ処理の中で「必要によって処理をするかどうかを決定する」という概念がピンと来ないですね。我々が認識しているループ処理とは、対象となるデータモデルの全要素を巡回しながら処理をするという意味ですので。&lt;/p>
&lt;p>だからSequenceを使った方が性能がよくなると言っても、パフォーマンスはさまざまな要素によって劣化も向上もするものなので、その話だけを信じて全ての処理をSequenceに変えるということは危ないです。そもそもSequenceがそんなに良いものであれば、全てのIterableなオブジェクトをなぜSequenceとして処理しないか、という疑問も湧いてきますね。なので、まずはCollectionとSequenceでFunctional functionがどう違うか、コードどそれを実行した結果で説明したいと思います。&lt;/p>
&lt;h4 id="eager-evaluationのcollection">Eager evaluationのCollection&lt;/h4>
&lt;p>CollectionでのFunctional functionは、Eager evalutionと言われています。これはLazy evaluationの逆で、必要とされてなくてもとりあえず処理を行っておくということです。こうする場合期待できることは、メモリ上にすでに処理の結果が残っていて、複数回呼ばれた場合はそのキャッシュを使うことができるということですね。&lt;/p>
&lt;p>Eager evaluationだと、Functional functionが呼ばれるたび、その全要素に対しての処理をまず行うことになります。例えば、以下のような処理を書いたとしましょう。&lt;code>onEach()&lt;/code>は処理の流れを視覚化するためのものです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;Found even: &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;Now &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c"> is String&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .take(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c"> has taken&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを実行した結果は以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">2&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">4&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">6&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">8&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">10&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">4&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">6&lt;/span> has taken
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり、CollectionでのFunctional functionでは以下のような順で処理します。&lt;/p>
&lt;ol>
&lt;li>Listからfilterのpredicateに当てはまる要素を探し、その結果でListを作る&lt;/li>
&lt;li>filterされたListの要素をmapし、その結果でListを作る&lt;/li>
&lt;li>mapされたListの要素からtakeする&lt;/li>
&lt;/ol>
&lt;p>これを絵で表現すると以下の通りです。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 262;
flex-basis: 630px"
>
&lt;a href="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing.png" data-size="990x377">
&lt;img src="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing.png"
width="990"
height="377"
srcset="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing_hu8247a2d18d26f289432d35b2d30aabb1_33214_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_list_processing_hu8247a2d18d26f289432d35b2d30aabb1_33214_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Kotlin List Processing">
&lt;/a>
&lt;figcaption>Kotlin List Processing&lt;/figcaption>
&lt;/figure>
&lt;em>出典：Kotlin公式ドキュメント - &lt;a class="link" href="https://kotlinlang.org/docs/sequences.html#iterable" target="_blank" rel="noopener"
>Sequences&lt;/a>&lt;/em>&lt;/p>
&lt;h5 id="collectionのopreation">Collectionのopreation&lt;/h5>
&lt;p>Collectionでの処理は上記の通りですが、実装としてはどうでしょうか。ここではCollectionでの&lt;code>map()&lt;/code>のコードを見ていきたいと思います。コードとしては以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">R&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Iterable&lt;/span>&amp;lt;T&amp;gt;.map(transform: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R): List&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> mapTo(ArrayList&amp;lt;R&amp;gt;(collectionSizeOrDefault(&lt;span style="color:#bd93f9">10&lt;/span>)), transform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mapTo()&lt;/code>という関数に、元のCollectionのサイズで新しくインスタンスを作成した&lt;code>ArrayList&lt;/code>とLambdaを渡しています。ちなみに&lt;code>collectionSizeOrDefault()&lt;/code>という関数は、以下のような実装となっています。Collectionである場合はそのサイズを、そうでない場合（Sequenceなど）はデフォルトとして10のサイズを持つListになるということがわかりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">internal&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Iterable&lt;/span>&amp;lt;T&amp;gt;.collectionSizeOrDefault(default: Int): Int = &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span> &lt;span style="color:#ff79c6">is&lt;/span> Collection&amp;lt;*&amp;gt;) &lt;span style="color:#ff79c6">this&lt;/span>.size &lt;span style="color:#ff79c6">else&lt;/span> default
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>mapTo()&lt;/code>という関数の中では、元のCollectionをループしながら新しいListにLambdaの実行結果を追加するという実装となっています。実際のコードは、以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">R&lt;/span>, &lt;span style="color:#50fa7b">C&lt;/span> : &lt;span style="color:#50fa7b">MutableCollection&lt;/span>&amp;lt;&lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#50fa7b">R&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#50fa7b">Iterable&lt;/span>&amp;lt;T&amp;gt;.mapTo(destination: C, transform: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R): C {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (item &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destination.add(transform(item))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、一つのFunctional functionが呼ばれるたびにListに対するループが発生し、さらに新しいListを作ることになるということです。なので上記のサンプルコードの場合だとループは6回、Listの作成は4回であるといえます。&lt;code>onEach()&lt;/code>を除外するとしてもループは3回なので、かなり多い印象ですね。&lt;/p>
&lt;p>ここで考えられるものは、「Sequenceの方が性能がいい」という話は、Sequenceを使った場合にこのようなループ回数やListの作成を減らせられるということになるのではないか、ということですね。Sequenceではどんな処理をしていて、実際にこのようなループやListを作る回数などを減らしているということでしょうか。同じ処理を書いた場合にSequenceではどのようなことが起きるかを見ていきましょう。&lt;/p>
&lt;h4 id="lazy-evaluationのsequence">Lazy evaluationのSequence&lt;/h4>
&lt;p>Collectionは、&lt;code>asSequence()&lt;/code>を呼び出すことで簡単にSequenceによる処理に変換することができます。ただ、このコードを実際に走らせるためにはJavaのStreamと同じく終端処理が必要となるのがポイントです。これも「必要とされるまでは実際の処理を行わない」Lazy evaluationの特徴といえます。例えば以下のようなコードを書いたとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>listOf(&lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">4&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>, &lt;span style="color:#bd93f9">6&lt;/span>, &lt;span style="color:#bd93f9">7&lt;/span>, &lt;span style="color:#bd93f9">8&lt;/span>, &lt;span style="color:#bd93f9">9&lt;/span>, &lt;span style="color:#bd93f9">10&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .asSequence() &lt;span style="color:#6272a4">// Sequenceに変換
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> .filter { &lt;span style="color:#ff79c6">it&lt;/span> %&lt;span style="color:#bd93f9">2&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;Found even: &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .map { &lt;span style="color:#ff79c6">it&lt;/span>.toString() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;Now &lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c"> is String&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .take(&lt;span style="color:#bd93f9">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .onEach { println(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c"> has taken&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .toList() &lt;span style="color:#6272a4">// Collectionに再変換（終端処理で処理を走らせる）
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを実行した結果は以下の通りです。Collectionの場合と結果は同じであるものの、処理の順番が変わっていることを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">2&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">4&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">4&lt;/span> has taken
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found even: &lt;span style="color:#bd93f9">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Now &lt;span style="color:#bd93f9">6&lt;/span> is String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">6&lt;/span> has taken
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、そもそも8と10に対しての処理は行われてないということです。これはCollectionで全要素に対して一つのFunctional functionの処理が終わったあと、次のFunctional functionが実行される構造に対して、Sequenceは一つの要素に対しての全ての処理が終わったあと次の要素に対して同じ処理を繰り返しているということです。言葉で表現すると複雑ですが、以下のような順になっているということです。&lt;/p>
&lt;ol>
&lt;li>Listの要素にfilterを当てる&lt;/li>
&lt;li>要素がfilterのpredicateに当てはまるものなら次の処理に移行する&lt;/li>
&lt;li>filterされた要素をmapする&lt;/li>
&lt;li>mapされた要素をtakeする&lt;/li>
&lt;li>次の要素に対して同じ処理を繰り返す&lt;/li>
&lt;/ol>
&lt;p>これを絵で表現すると以下の通りです。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 231;
flex-basis: 556px"
>
&lt;a href="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing.png" data-size="990x427">
&lt;img src="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing.png"
width="990"
height="427"
srcset="https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing_huad9a91ec7000e356fa550a56d0b6e8a9_37351_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/kotlin-collection-and-sequence/kotlin_sequence_processing_huad9a91ec7000e356fa550a56d0b6e8a9_37351_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Kotlin Sequence Processing">
&lt;/a>
&lt;figcaption>Kotlin Sequence Processing&lt;/figcaption>
&lt;/figure>
&lt;em>出典：Kotlin公式ドキュメント - &lt;a class="link" href="https://kotlinlang.org/docs/sequences.html#sequence" target="_blank" rel="noopener"
>Sequences&lt;/a>&lt;/em>&lt;/p>
&lt;p>処理の順番や仕組みが違うので、Collectionの時とは実装もかなり違うだろうと予想ができますね。では、こちらの実装を見ていきましょう。&lt;/p>
&lt;h5 id="sequenceでのoperation">Sequenceでのoperation&lt;/h5>
&lt;p>Collectionと同じく、Sequenceの&lt;code>map()&lt;/code>の実装を覗いてみましょう。先程のコードでSequenceの&lt;code>map()&lt;/code>は中間処理であり、新しいCollectionを作り出すわけではないということはわかりました。実装を見ると、以下のようになっていて、処理結果が反映されたSequenceを返しているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">R&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.map(transform: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R): Sequence&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> TransformingSequence(&lt;span style="color:#ff79c6">this&lt;/span>, transform)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、内部で&lt;code>TransformingSequence&lt;/code>という新しいSequenceのインスタンスを作成しているのがわかりますね。このクラスの実装は以下の通りです。ここでループごとにLambdaの実行が行われていますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">internal&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">TransformingSequence&lt;/span>&amp;lt;T, R&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">constructor&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> sequence: Sequence&amp;lt;T&amp;gt;, &lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> transformer: (T) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> R) : Sequence&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">iterator&lt;/span>(): Iterator&amp;lt;R&amp;gt; = &lt;span style="color:#ff79c6">object&lt;/span> : &lt;span style="color:#50fa7b">Iterator&lt;/span>&amp;lt;R&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> iterator = sequence.iterator()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">next&lt;/span>(): R {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> transformer(iterator.next())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">hasNext&lt;/span>(): Boolean {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> iterator.hasNext()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">internal&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">E&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">flatten&lt;/span>(iterator: (R) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Iterator&amp;lt;E&amp;gt;): Sequence&amp;lt;E&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> FlatteningSequence&amp;lt;T, R, E&amp;gt;(sequence, transformer, iterator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上のコードの実行結果と実装でわかるように、Sequenceを使う場合は一つの要素を単位として処理を行っていくので、CollectionでFunctional functionを使う場合に発生し得る不要な処理(毎回Listを生成する、前要素に対してmapを行うなど)を減らせると期待できます。なので元のCollectionが大きい場合やoperationが多い場合はSequenceの方がより良いように見えます。&lt;/p>
&lt;p>ただ、性能の観点で考えると、CollectionとSequenceの違いはもう一つ考慮すべきところがあります。それはデータ構造の違いです。&lt;/p>
&lt;h2 id="stateless">Stateless&lt;/h2>
&lt;p>JavaのStreamでもそうでしたが、Sequenceは状態(State)を持たないのが特徴です。ここで状態を持たないということは、持っている要素の数や順番などに対しての情報がないということを意味します。なぜかというと、SequenceがIteratorに基づいているものだからです。そしてそれが原因で、処理の種類によってCollectionよりも性能は劣る可能性もまたあります。&lt;/p>
&lt;p>先に使っていたサンプルコードを持って考えてみましょう。サンプルコードでは、Sequenceの終端処理としてListを返すために&lt;code>toList()&lt;/code>を呼び出していました。これは、「状態を持たない」ものから「状態を持つ」ものに変換することですね。簡単なやり方としては、MutableなListを作って、全要素を一つづつ&lt;code>add()&lt;/code>していく方法があるでしょう。実際はどうでしょうか？まずは&lt;code>toList()&lt;/code>のコードをみてみましょう。以下がその実装です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.toList(): List&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>.toMutableList().optimizeReadOnlyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まずMutableなListに変換して、さらに読み込み専用（Immutable）のListに変換しているように見えます。さらにMutable Listに変えているところの実装をみてみましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.toMutableList(): MutableList&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> toCollection(ArrayList&amp;lt;T&amp;gt;())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ArrayListのインスタンスを作って、それを&lt;code>toCollection()&lt;/code>に渡していますね。ここで&lt;code>toCollection()&lt;/code>はSequenceをCollectionに帰る時の共通処理で、型を指定にするため引数にListを渡しているようです。さらに&lt;code>toCollection()&lt;/code>の実装をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>, &lt;span style="color:#50fa7b">C&lt;/span> : &lt;span style="color:#50fa7b">MutableCollection&lt;/span>&amp;lt;&lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#50fa7b">T&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.toCollection(destination: C): C {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (item &lt;span style="color:#ff79c6">in&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> destination.add(item)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> destination
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここまでたどり着いてわかったのは、やはりSequenceの要素を一つ一つListの中に入れているということですね。ただ、単純な処理ではありますが、ここでは「Listに要素を足していく」ということ自体に注目する必要があります。&lt;/p>
&lt;p>先に述べた通り、Sequenceは自分が持つ要素の数をわからないので、Listのインスタンスを作る時はサイズを「仮定」して処理するしかないです。そして基本的にMutableなListでは、現在のサイズよりも多くの要素を追加する必要がある時、内部のArrayより大きいサイズのArrayを新しく作り、そこに要素をコピーしていくことを繰り返します。そしてこれを全要素が揃うまで繰り返していきますね。ということは、Sequenceの要素が多ければ多いほどArrayのインタンス作成とコピーが多くなるということになります。&lt;/p>
&lt;p>そしてコピーが全部終わった場合、実際の要素数よりArrayのサイズが大きい場合もありますね。その場合、メモリを無駄に使うだけでなく、実際のサイズもわからなくなるので、サイズを要素数に合わせて再調整する必要があります。&lt;code>toList()&lt;/code>の実装で最後に&lt;code>optimizeReadOnlyList()&lt;/code>を呼び出しているのは、おそらくその理由でしょう。&lt;code>optimizeReadOnlyList()&lt;/code>の実装は以下の通りです。やはりサイズを再調整していますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">internal&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">List&lt;/span>&amp;lt;T&amp;gt;.optimizeReadOnlyList() = &lt;span style="color:#ff79c6">when&lt;/span> (size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#bd93f9">1&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> listOf(&lt;span style="color:#ff79c6">this&lt;/span>[&lt;span style="color:#bd93f9">0&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">this&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これでわかるように、Sequenceを使って処理したあと、Collectionにまとめるなら要素数が多ければ多いほどCollectionよりも性能が劣化する可能性は確かに存在します。CollectionでFunctional functionを呼び出す際にListを作るとしても、すでに要素数はわかっているので、Listのサイズが合わないためのArrayの生成とコピーの処理は不要ですね。なのでCollectionとSequenceのどちらを選ぶかの問題はFunctional functionを呼び出す回数や処理の種類だけでなく、要素の数まで考える必要がありそうです。&lt;/p>
&lt;p>ただ、要素数が多い場合でも、終端処理の種類によってはSequenceの方が有利になる可能性もなくはないです。例えば&lt;code>forEach()&lt;/code>や&lt;code>onEach()&lt;/code>など、個別の要素に対して処理を行うだけの場合は依然としてSequenceの方で良い性能を期待できるでしょう。&lt;/p>
&lt;p>要素数が多い場合に性能に影響する処理としてもう一つ考えられるのは、Sequenceを使う場合でも呼び出せるFunctional functionの中で明らかに「状態を必要とする」ものがあるということです。例えば以下の一覧のようなものです。&lt;/p>
&lt;ul>
&lt;li>どんな要素が含まれているかわかる必要がある
&lt;ul>
&lt;li>&lt;code>distinct()&lt;/code>&lt;/li>
&lt;li>&lt;code>average()&lt;/code>&lt;/li>
&lt;li>&lt;code>min()&lt;/code>&lt;/li>
&lt;li>&lt;code>max()&lt;/code>&lt;/li>
&lt;li>&lt;code>take()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>要素の順番をわかる必要がある
&lt;ul>
&lt;li>&lt;code>indexOf()&lt;/code>&lt;/li>
&lt;li>&lt;code>mapIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>flatMapIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>elementAt()&lt;/code>&lt;/li>
&lt;li>&lt;code>filterIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>foldIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>forEachIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>reduceIndexed()&lt;/code>&lt;/li>
&lt;li>&lt;code>scanIndexed()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>これらの処理をSequenceではどうしているのでしょうか。まずはその実装を覗いてみる必要がありそうですね。ここでは&lt;code>sort()&lt;/code>の方をみていきたいと思います。実装は以下のようになっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span> : &lt;span style="color:#50fa7b">Comparable&lt;/span>&amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt;&amp;gt; &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt;.sorted(): Sequence&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#ff79c6">object&lt;/span> : &lt;span style="color:#50fa7b">Sequence&lt;/span>&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">override&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">iterator&lt;/span>(): Iterator&amp;lt;T&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> sortedList = &lt;span style="color:#ff79c6">this&lt;/span>@sorted.toMutableList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sortedList.sort()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> sortedList.iterator()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>単純ですが、Sequenceを一度Listに変換してsortした後、またSequenceに変えて返していますね。ここでListに変えるために呼び出している関数は&lt;code>toMutableList()&lt;/code>なので、結局&lt;code>toList()&lt;/code>を呼び出す場合と同じようなことが起きるということです。なので、状態を必要とする操作の場合は要素数が多ければ多いほど性能はCollectionより劣化しやすい、ということがわかります。&lt;/p>
&lt;p>ただ、逆に状態が必要にならない場合は、Collectionと違って中間結果のListを作成しなくなるので、依然としてSequenceが良い性能を見せるだろうと思えます。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>だいぶ話が長くなりましたが、性能の観点でどれを選ぶべきか、という話の結論としては、「どんな処理をするか」によるということになりますね。簡単に整理すると、以下のようになるかと思います。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>条件&lt;/th>
&lt;th>おすすめ&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>処理が複雑&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>処理した結果としてCollectionが必要&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ループするだけ&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>処理に状態が必要&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>要素数が多い&lt;/td>
&lt;td>Sequence&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>要素数が少ない&lt;/td>
&lt;td>Collection&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>もちろんこれらの条件が複数ある場合も十分考えられるので、必要な処理が何かをよく考えてどちらを使うかを慎重に考える必要がありそうです。多くの場合とりあえずCollectionを使うという方針だとしても特に問題はなさそうな気はしますが…&lt;/p>
&lt;p>この度はKotlinにおいてのSequenceを紹介しましたが、実はイラストを含めてわかりやすく説明している&lt;a class="link" href="https://typealias.com/guides/when-to-use-sequences" target="_blank" rel="noopener"
>いつSequenceを使うべきか&lt;/a>という良い記事があるので、Sequenceについてより深く理解したい方にはこちらを参考した方が良さそうな気がします。&lt;/p>
&lt;p>また、ここではKotlinのAPIでの処理のみを紹介しましたが、JavaのStreamを使う場合、Sequenceと違って&lt;code>parallelStream()&lt;/code>を呼び出すことができます。なので並列で処理しても良い場合には、CollectionとSequenceのみでなく、Streamを使うことを検討するのもありですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinのString実装を覗く〜whitespace編〜</title><link>https://retheviper.github.io/posts/kotlin-whitespace/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-whitespace/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinのString実装を覗く〜whitespace編〜" />&lt;p>Kotlin(JVM)は、コンパイルした結果がJVMのバイトコードになります。Javaで書かれたライブラリをそのままKotlinで利用できるのはそのためですね。これはKotliのライブラリに対しても同じなので、スタンダードライブラリを覗くとJavaの機能に依存しているところも少なくないです。&lt;/p>
&lt;p>ただ、KotlinがコンパイルしたらJVMのバイトコードになるということは、単純にKotlinが「書き方が違うJava」であるという意味ではないです。これはKotlinがJavaと言語スペックが違うという点もありますが、JVMだけでなく、JavaScriptやネイティブコードにコンパイルされることも想定してデザインされているので、スタンダードライブラリスタンダードライブラリはプラットフォームに合わせて違う実装になっています。そしてJVMだとしてもJavaのAPIをそのまま利用しているわけではありません。&lt;/p>
&lt;p>Kotlinのこういう構造は、内部のソースコードを見るとはっきりします。スタンダードライブラリの一部メソッドやクラスには&lt;code>expect&lt;/code>と&lt;code>actual&lt;/code>というキーワードが使われていますが、これらはJavaのinheritanceと似ているようなものです。Javaでは&lt;code>interface&lt;/code>で定義したメソッドを、それを継承したクラスで&lt;code>override&lt;/code>で実装して使うことになりますね。同じく、Kotlinでは&lt;code>expect&lt;/code>として定義された機能をプラットフォームに合わせて&lt;code>actual&lt;/code>で実装しているわけです。&lt;/p>
&lt;p>また、KotlinのスタンダードライブラリはJavaと一見同じようなものに見えるとしても、実際は違うケースもあります。&lt;code>actual&lt;/code>によって実装されたコードがKotlinに合わせて、書かれているからですね。なので、Kotlinのスタンダードライブラリに対しては「Javaと同じだろう」という認識をするのは危険な可能性もあります。&lt;/p>
&lt;p>今回はそういうことで、文字列のwhitespaceに関しての機能を、スタンダードライブラリのソースコードを中心に見ていきたいと思います。&lt;/p>
&lt;h2 id="whitespaceの判定">whitespaceの判定&lt;/h2>
&lt;p>とある文字列が意味のある(有効な)データであるかどうかを判定する方法の一つは、その文字列がただの空白であるかどうかを判定することです。つまり、そもそもなんのデータもなかったり、whitespaceだけでないかというチェックをするということですね。&lt;/p>
&lt;p>こういう場合の判定はKotlinのスタンダードライブラリで簡単に行うことができます。KotlinではStringのメソッドとして基本的に以下の二つを提供しています。&lt;/p>
&lt;ul>
&lt;li>&lt;code>isEmpty()&lt;/code>&lt;/li>
&lt;li>&lt;code>isBlank()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Java 11以降でもこれらと同名のメソッドが存在しているので、一見そのままの感覚で良さそうにも見えます。しかし、Kotlinではこれらのメソッドがまず&lt;code>kotlin.text.Strings&lt;/code>から呼ばれるものとされています。JavaのAPIをそのまま使っているわけではないので、処理も違う可能性があるという推測ができますね。&lt;/p>
&lt;p>ここで前者の場合、文字列が単純になんのデータも持ってないかどうかに対する判定をおこないます。実際のソースコードを見ると、文字列の長さだけをチェックしているのを確認できます。&lt;/p>
&lt;p>ちなみにJavaでは&lt;code>String&lt;/code>は&lt;code>CharSequence&lt;/code>を継承していますが、Kotlinとしてもライブラリは違えどそういう継承関係は一緒です。なので、Kotlinでは&lt;code>String&lt;/code>のメンバーでありながらも&lt;code>CharSequence&lt;/code>の関数として書かれています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">CharSequence&lt;/span>.isEmpty(): Boolean = length &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>後者の場合は、文字列にwhitespaceまで含めているのかを判定します。以下のコードを見ると、何をやっているかが明確でしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">actual&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">CharSequence&lt;/span>.isBlank(): Boolean = length &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#ff79c6">||&lt;/span> indices.all { &lt;span style="color:#ff79c6">this&lt;/span>[&lt;span style="color:#ff79c6">it&lt;/span>].isWhitespace() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>isBlank()&lt;/code>で呼び出している&lt;code>isWhitespace()&lt;/code>は、以下のような実装となっています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">actual&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Char&lt;/span>.isWhitespace(): Boolean = Character.isWhitespace(&lt;span style="color:#ff79c6">this&lt;/span>) &lt;span style="color:#ff79c6">||&lt;/span> Character.isSpaceChar(&lt;span style="color:#ff79c6">this&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinの&lt;code>Char.isWhitespace()&lt;/code>は最終的に&lt;code>Character.isWhitespace()&lt;/code>と&lt;code>Character.isSpaceChar()&lt;/code>を使って判定することになります。前者の場合はUnicodeのwhitespaceに当てはまるか、後者の場合はUnicodeのspace(改行コードなど)に当てはまるかを判定するJavaのAPIです。ここでわかるように、特集なケースでなければなるべく&lt;code>isEmpty()&lt;/code>を使った方が文字列をチェックする時に良いでしょう。&lt;/p>
&lt;h2 id="whitespaceの削除">whitespaceの削除&lt;/h2>
&lt;p>文字列が単純に意味のあるデータを持っているかどうかを判定するには、前述通り&lt;code>isEmpty()&lt;/code>を使うと良いですが、文字列にwhitespaceだけでなく、意味のあるデータも混在する場合もありますね。こういう時は前後のwhitespaceを取り除きたくなります。&lt;/p>
&lt;p>Javaでは、文字列の前後のwhitespaceを消去する方法として&lt;code>trim()&lt;/code>と&lt;code>strip()&lt;/code>がありました。前者は昔ながらのもので、全角のwhitespaceを検知できなく、性能の問題もあるのでJava 11以降は後者を使うことが推奨されています。&lt;/p>
&lt;p>ただ、Kotlinの場合は少し都合が違います。Kotlinでは基本的に&lt;code>trim()&lt;/code>だけを使うことになります。まずは&lt;code>trim()&lt;/code>の実装をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">String&lt;/span>.trim(): String = (&lt;span style="color:#ff79c6">this&lt;/span> &lt;span style="color:#ff79c6">as&lt;/span> CharSequence).trim().toString()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まず&lt;code>String&lt;/code>としては、&lt;code>CharSequence&lt;/code>にアップキャストしてその&lt;code>trim()&lt;/code>を呼び出すことにしています。そのあとは単純に&lt;code>toString()&lt;/code>で返すだけですね。&lt;/p>
&lt;p>続いて、&lt;code>String&lt;/code>で呼ばれている&lt;code>CharSequence&lt;/code>側の&lt;code>trim()&lt;/code>をみていきましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">CharSequence&lt;/span>.trim(): CharSequence = trim(Char&lt;span style="color:#ff79c6">::&lt;/span>isWhitespace)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでは、オーバロードした他の&lt;code>trim()&lt;/code>に&lt;code>isWhitespace()&lt;/code>をメソッドレファレンスとして渡しているのがわかります。&lt;code>Boolean&lt;/code>が戻り値なので、引数は&lt;code>Predicate&lt;/code>であると推測できますね。続けて、こちらで呼び出している&lt;code>trim(predicate)&lt;/code>の方を確認します。こちらのコードは以下の通りです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">inline&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">CharSequence&lt;/span>.trim(predicate: (Char) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Boolean): CharSequence {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> startIndex = &lt;span style="color:#bd93f9">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> endIndex = length - &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> startFound = &lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span> (startIndex &lt;span style="color:#ff79c6">&amp;lt;=&lt;/span> endIndex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> index = &lt;span style="color:#ff79c6">if&lt;/span> (!startFound) startIndex &lt;span style="color:#ff79c6">else&lt;/span> endIndex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> match = predicate(&lt;span style="color:#ff79c6">this&lt;/span>[index])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (!startFound) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (!match)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startFound = &lt;span style="color:#ff79c6">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startIndex &lt;span style="color:#ff79c6">+=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (!match)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> endIndex &lt;span style="color:#ff79c6">-=&lt;/span> &lt;span style="color:#bd93f9">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> subSequence(startIndex, endIndex + &lt;span style="color:#bd93f9">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここまできてやっと実際の処理がでました。&lt;code>CharSequence&lt;/code>をループしながら左(start)から右の方にwhitespaceを探し、初めてwhitespaceでない文字を見つけたら右(end)から左の方にループしながら繰り返すという処理ですね。意外と単純ですが、効率的な処理です。&lt;/p>
&lt;p>そしてその処理での判断基準が&lt;code>isWhitespace()&lt;/code>になっているわけですが、先に確認している通りこちらは最終的にJavaのAPIを呼ぶことになっているので、&lt;code>trim()&lt;/code>でも十分Unicodeに定義されてあるwhitespaceやspaceまでを削除してくれると推論できます。なので、Javaとは違ってあえて&lt;code>strip()&lt;/code>を使う必要はなさそうです。&lt;/p>
&lt;p>また、&lt;code>trim()&lt;/code>は文字列の前後のwhitespaceを削除しますが、場合によっては前方のみ、後方のみで分けて使いたい場合もあるかも知れません。その時は、以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> string = &lt;span style="color:#f1fa8c">&amp;#34; string &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 左のみtrim
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.trimStart()) &lt;span style="color:#6272a4">// &amp;#34;string &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 右のみtrim
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.trimEnd()) &lt;span style="color:#6272a4">// &amp;#34; string&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらのメソッドは引数として&lt;code>Predicate&lt;/code>を渡すこともできるので、他の条件を自前で書く必要がある場合にはそちらを使えますね。&lt;/p>
&lt;p>他にも、whitespaceではない、前後の特定の文字(prefix、suffix)を削除してたい場合は以下のメソッドが提供されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> string = &lt;span style="color:#f1fa8c">&amp;#34;--hello--&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// prefixのみ削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.removePrefix(&lt;span style="color:#f1fa8c">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#6272a4">// &amp;#34;hello--&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// suffixのみ削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.removeSuffix(&lt;span style="color:#f1fa8c">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#6272a4">// &amp;#34;--hello&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 前後を削除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>println(string.removeSurrounding(&lt;span style="color:#f1fa8c">&amp;#34;--&amp;#34;&lt;/span>)) &lt;span style="color:#6272a4">// &amp;#34;hello&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="改行を削除">改行を削除&lt;/h3>
&lt;p>改行が文字列の前後に入っていれば&lt;code>trim()&lt;/code>で十分ですが、文字列の中に改行が含まれていて、それを変えたい場合もありますね。例えばJSONをログに一行で出力したいだったり、以下のようなMulitiline Stringを一行にまとめたい場合です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> string = &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> Hello
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> World
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Intellijだと自動的に&lt;code>trimIndent()&lt;/code>をつけてくれますが、これはあくまでインデントに関与するものであって、中の改行まではtrimしてくれないです。こういう場合は、KotlinでもJavaでも対応するメソッドは特にないので、自分で処理を書くしかないですね。例えば、以下のようなコードが使えるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">String&lt;/span>.stripLine() = replace(System.lineSeparator(), &lt;span style="color:#f1fa8c">&amp;#34; &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、Javaでも13から&lt;a class="link" href="https://openjdk.java.net/jeps/355" target="_blank" rel="noopener"
>Text Block&lt;/a>が導入されているので、今後はJavaのAPIの方で上記のようなメソッドが追加されることを期待できるかも知れません。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>最初に&lt;code>expect&lt;/code>と&lt;code>actual&lt;/code>の話をしましたが、これらのキーワードは&lt;a class="link" href="https://kotlinlang.org/docs/multiplatform.html" target="_blank" rel="noopener"
>Kotlin Multiplatform&lt;/a>でもっとも重要な概念です。Kotlinで書いたコードをさまざまなプラットフォームで共有できるようにすることを目的としているので、こういう構造になっているのは自然ですね。なので、Kotlin/JVMだけでなく、他のことを試したい方にはとりあえず理解しておく必要があるキーワードだと思います。ちょっと独特なだけで、実体は単純なので、理解は簡単でしょう。&lt;/p>
&lt;p>また、KotlinのStringに関しては、&lt;a class="link" href="https://youtu.be/n4WBip822A8" target="_blank" rel="noopener"
>JetBrains公式YouTubeチャンネルの動画&lt;/a>で簡単に説明しているので、Kotlinで開発をしている方なら一度は参考にした方が良いかも知れません。&lt;/p>
&lt;p>他に、&lt;code>strip()&lt;/code>をあえて使う必要はないと言いましたが、実際Kotlinの最新バージョンである1.5.0でも&lt;code>strip()&lt;/code>は&lt;code>deprecated&lt;/code>になっていて、以下のようなコメントがついているので、次のバージョンで正式対応するまでは使わない方が良いですね。&lt;/p>
&lt;blockquote>
&lt;p>&amp;lsquo;strip(): String!&amp;rsquo; is deprecated. This member is not fully supported by Kotlin compiler, so it may be absent or have different signature in next major version&lt;/p>
&lt;/blockquote>
&lt;p>こういうケースでもわかるように、KotlinがJavaと100%互換性があると言い切れない側面もあるのではと思います。なので、JavaからKotlinに移行した場合(実際のコードであれ、開発者自身のスキルであれ)には、一度注意深くスタンダードライブラリの説明を読む必要があるかも知れません。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>年月を扱ってみる</title><link>https://retheviper.github.io/posts/kotlin-year-month/</link><pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-year-month/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post 年月を扱ってみる" />&lt;p>Kotlin(Java)では、&lt;code>java.time&lt;/code>パッケージのクラスで日付や時間を処理することができます。例えば&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/LocalDateTime.html" target="_blank" rel="noopener"
>LocalDateTime&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/LocalDate.html" target="_blank" rel="noopener"
>LocalDate&lt;/a>などがありますね。サーバサイドではこれらのクラスを使ってDBに日付や時間を入力したり、認証用のトークンの有効期間を設定したりの処理ができるようになります。他にも&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/time/Period.html" target="_blank" rel="noopener"
>Period&lt;/a>や&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" target="_blank" rel="noopener"
>Duration&lt;/a>があって、「期間」を扱うこともできますね。&lt;/p>
&lt;p>ただ、「年月」という単位を扱いたい場合はどうしたらいいでしょうか。例えば、口座の入出金明細などを照会する時に、「2月から4月まで」という風に期間を設定するケースなどがあるとしたら、いらない「日」や「時間」まで含めるのはあまり効率的でなく、場合によってはバグの原因になるかも知れません。こういった場合は確かな「年月」としてデータを扱うか、数字として表現するかなどどちらかの方法を考える必要があるでしょう。&lt;/p>
&lt;p>ということで、今回はこの年月を扱う方法について少し述べたいと思います。&lt;/p>
&lt;h2 id="年月を年と月に">年月を年と月に&lt;/h2>
&lt;p>年月を扱うということは、つまり、いつでも「年」と「月」という二つのデータとして分離できるようにしたいということにもなりますね。ここでは二つの方法で、「年月」を「年」と「月」の二つに分けて扱う方法について説明します。&lt;/p>
&lt;h3 id="yearmonthとして">YearMonthとして&lt;/h3>
&lt;p>&lt;code>LocalDate&lt;/code>や&lt;code>LocalDateTime&lt;/code>では、基本的に&lt;a class="link" href="https://www.iso.org/iso-8601-date-and-time-format.html" target="_blank" rel="noopener"
>ISO-8601&lt;/a>形式で日付を扱うことができます。もちろん、&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener"
>DateTimeFormatter&lt;/a>を使って他の形式を指定することもできますが、扱うデータの形が違うだけで、本質的には「年月日」が基本となりますね。&lt;/p>
&lt;p>&lt;code>ISO-8601&lt;/code>の「年月日」形式で日付を扱っているということは、つまり、SpringでREST APIを作っている場合、リクエストの値が&lt;code>ISO-8601&lt;/code>の形式を守っていれば&lt;code>LocalDateTime&lt;/code>や&lt;code>LocalDate&lt;/code>形式に自動変換されるということでもあります。例えば以下のようなリクエストのJSONがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;date&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;2021-04-01&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Spring側では以下のようなコードで、リクエストのdateを&lt;code>LocalDate&lt;/code>に変換することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// リクエストボディ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">DateRequest&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> id: Int, &lt;span style="color:#ff79c6">val&lt;/span> date: LocalDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// コントローラ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>@PostMapping(&lt;span style="color:#f1fa8c">&amp;#34;/date&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">date&lt;/span>(@RequestBody request: DateRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして全く同じやり方で、&lt;code>LocalDate&lt;/code>を&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/time/YearMonth.html" target="_blank" rel="noopener"
>YearMonth&lt;/a>に変えることで年月に対応することができます。例えば以下のようなリクエストがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;yearMonth&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;2021-04&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで&lt;code>yearMonth&lt;/code>を&lt;code>YearMonth&lt;/code>に変えるだけです。以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// リクエストボディ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">YearMonthRequest&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> id: Int, &lt;span style="color:#ff79c6">val&lt;/span> yearMonth: YearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// コントローラ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>@PostMapping(&lt;span style="color:#f1fa8c">&amp;#34;/year-month&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">yearMonth&lt;/span>(@RequestBody request: YearMonthRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>YearMonth&lt;/code>を使うことのメリットは、&lt;code>LocalDateTime&lt;/code>や&lt;code>LocalDate&lt;/code>と同じく&lt;code>java.time&lt;/code>パッケージに属するオブジェクトなので、それらと互換性があり、相互変換が自由ということでもあります。例えば以下のように使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> yearMonth = YearMonth.now() &lt;span style="color:#6272a4">// 現在の年月を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2021&lt;/span>-&lt;span style="color:#bd93f9">04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> localDate = yearMonth.atDay(&lt;span style="color:#bd93f9">1&lt;/span>) &lt;span style="color:#6272a4">// 年月に日を指定してLocalDateにする
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&amp;gt;&amp;gt;&amp;gt; println(localDate)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2021&lt;/span>-&lt;span style="color:#bd93f9">04&lt;/span>-&lt;span style="color:#bd93f9">01&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、&lt;code>YearMonth&lt;/code>は時間に関する便利なメソッドを多く提供しているので、単純に数値としての年月を扱うだけでなく、色々な要件に合わせて日付関連の処理が必要な場合に便利かも知れません。例えば以下のような機能が提供されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> yearMonth = YearMonth.of(&lt;span style="color:#bd93f9">2021&lt;/span>, &lt;span style="color:#bd93f9">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2021&lt;/span>-&lt;span style="color:#bd93f9">05&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getYear()) &lt;span style="color:#6272a4">// 年を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#bd93f9">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getMonth()) &lt;span style="color:#6272a4">// 月(Enum)を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>MAY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.getMonthValue()) &lt;span style="color:#6272a4">// 月(数字)を取得
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.isLeapYear()) &lt;span style="color:#6272a4">// うるう年であるかどうか
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(yearMonth.atEndOfMonth()) &lt;span style="color:#6272a4">// 月の最後の日(LocalDate)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#bd93f9">2021&lt;/span>-&lt;span style="color:#bd93f9">05&lt;/span>-&lt;span style="color:#bd93f9">31&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数字として">数字として&lt;/h3>
&lt;p>&lt;code>YearMonth&lt;/code>で受け取って処理した方がもっとも綺麗な方法に見えますが、状況によっては素直に&lt;code>Int&lt;/code>型で受け取った方が良い(もしくはそうするしかない)ケースもあるはずです。例えば以下のようなリクエストが送らられて来るようなケースですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">&amp;#34;yearMonth&amp;#34;&lt;/span>: &lt;span style="color:#bd93f9">202104&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そもそも&lt;code>year&lt;/code>と&lt;code>month&lt;/code>のように別の項目になっていたとしたらもっとやりやすいのですが、このように年月が一つの&lt;code>Int&lt;/code>型のデータとして送られてくる場合は自分で年と月を抽出する処理を作るしかないですね。例えば以下のようなextension functionを書くことができるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 年を抽出する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.extractYear(): Int = &lt;span style="color:#ff79c6">this&lt;/span> / &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 月を抽出する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.extractMonth(): Int = &lt;span style="color:#ff79c6">this&lt;/span> % &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実際のコードを動かしてみると、ちゃんと意図通り動くのを確認できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.extractYear(): Int = &lt;span style="color:#ff79c6">this&lt;/span> / &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#bd93f9">202104.&lt;/span>extractYear()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res4: kotlin.Int = &lt;span style="color:#bd93f9">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.extractMonth(): Int = &lt;span style="color:#ff79c6">this&lt;/span> % &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#bd93f9">202104.&lt;/span>extractMonth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res6: kotlin.Int = &lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、パラメータとして渡されたものはただの&lt;code>Int&lt;/code>型なので、期待した通りの値ではない可能性もあるという問題があります。常に&lt;code>YYYYMM&lt;/code>という形でデータが送られてくるかどうかをチェックする必要がありますね。&lt;/p>
&lt;p>そういう場合に、上記のコードだとリクエストの&lt;code>yearMonth&lt;/code>が正しい年月の形式になっているかどうかがわかりません。なので、正規式を用いたバリデーションチェックを挟むことにしたらより安全になるでしょう。例えば、以下のようなコードを使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.toYearMonth(): Pair&amp;lt;Int, Int&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (Regex(&lt;span style="color:#f1fa8c">&amp;#34;^(19|20)&lt;/span>&lt;span style="color:#f1fa8c">\\&lt;/span>&lt;span style="color:#f1fa8c">d{2}(0[1-9]|1[012])&amp;#34;&lt;/span>).matches(&lt;span style="color:#ff79c6">this&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">this&lt;/span> / &lt;span style="color:#bd93f9">100&lt;/span> to &lt;span style="color:#ff79c6">this&lt;/span> % &lt;span style="color:#bd93f9">100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#f1fa8c">&amp;#34;cannot convert&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上記の関数は、以下のような使い方ができます。簡単に使えるのでいい感じですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">val&lt;/span> (year, month) = &lt;span style="color:#bd93f9">202104.&lt;/span>toYearMonth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(year)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">2021&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; println(month)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bd93f9">4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>元の値を二つの&lt;code>Int&lt;/code>に分けるために戻り値として&lt;code>Pair&lt;/code>を使いましたが、場合によっては&lt;code>YearMonth&lt;/code>の方が良いかも知れません。そういう場合は、以下のようなコードが使えます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.toYearMonth(): YearMonth =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (Regex(&lt;span style="color:#f1fa8c">&amp;#34;^(19|20)&lt;/span>&lt;span style="color:#f1fa8c">\\&lt;/span>&lt;span style="color:#f1fa8c">d{2}(0[1-9]|1[012])&amp;#34;&lt;/span>).matches(&lt;span style="color:#ff79c6">this&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YearMonth(&lt;span style="color:#ff79c6">this&lt;/span> / &lt;span style="color:#bd93f9">100&lt;/span>, &lt;span style="color:#ff79c6">this&lt;/span> % &lt;span style="color:#bd93f9">100&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> IllegalArgumentException(&lt;span style="color:#f1fa8c">&amp;#34;cannot convert&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="年と月を年月に">年と月を年月に&lt;/h2>
&lt;p>さて、今回は逆に「年」と「月」を繋げて「年月」にする場合の処理を考えてみましょう。二つの&lt;code>Int&lt;/code>を合わせて、一つの&lt;code>Int&lt;/code>(YYYYMM)にする形です。ここでまず考えられる方法は二つです。&lt;code>YearMonth&lt;/code>を使った方法と、文字列に変換してから処理するという方法です。&lt;/p>
&lt;h3 id="yearmonthで">YearMonthで&lt;/h3>
&lt;p>まず&lt;code>YearMonth&lt;/code>を利用する場合は、年と月をそのまま引数として渡した後、&lt;code>Int&lt;/code>に変換すれば良いですね。ただ、&lt;code>YearMonth&lt;/code>は基本的に&lt;code>ISO-8601&lt;/code>形式なので、2021年4月だと&lt;code>2021-04&lt;/code>となるので&lt;code>Int&lt;/code>へ変換ができません。なので、まず&lt;code>String&lt;/code>に変えてから、&lt;code>-&lt;/code>を消して&lt;code>Int&lt;/code>に変換することにします。以上の処理は、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">toYearMonth&lt;/span>(year: Int, month: Int): Int =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YearMonth.of(year, month).toString().replace(&lt;span style="color:#f1fa8c">&amp;#34;-&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;&amp;#34;&lt;/span>).toInt()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="文字列で">文字列で&lt;/h3>
&lt;p>文字列で処理する場合は、単純に&lt;a class="link" href="https://kotlinlang.org/docs/basic-types.html#string-templates" target="_blank" rel="noopener"
>String templates&lt;/a>を使うことでも可能ですが、注意したいのは、月は1~12という範囲を持つので、単純にtemplateで年と月を繋げると&lt;code>20214&lt;/code>のような形になり得る可能性もあるということですね。なので、&lt;code>padStart()&lt;/code>を利用して、月が1~9の場合は先頭に&lt;code>0&lt;/code>をつけるようにします。そのあとは&lt;code>Int&lt;/code>に変換するだけですね。これは以下のようなコードになリます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">toYearMonth&lt;/span>(year: Int, month: Int): Int = &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${year}${month.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これらの方法は、引数が二つなので、&lt;code>infix&lt;/code>として定義することもできます(好みの問題かと思いますが)。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#ff79c6">infix&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Int&lt;/span>.toYearMonthWith(month: Int): Int = &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">${this}${month.toString().padStart(2, &amp;#39;0&amp;#39;)}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>.toInt()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#bd93f9">2021&lt;/span> toYearMonthWith &lt;span style="color:#bd93f9">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>res10: kotlin.Int = &lt;span style="color:#bd93f9">202105&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いかがだったでしょうか。あまり難しいコードではなかったので、あえて記事にまでする必要があったのか、という気もしましたが、個人的には&lt;code>YearMonth&lt;/code>というクラスの存在を初めて知ったのもあり、Kotlinならではのコード(extension function)を書いてみたく試したことを共有したいと思った次第です。もしKotlinやJavaで年月を扱う必要がある方には、少しでも役に立てるといいですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>KotlinでZIP圧縮してみる</title><link>https://retheviper.github.io/posts/kotlin-zip-files/</link><pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-zip-files/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post KotlinでZIP圧縮してみる" />&lt;p>サーバサイドの機能を作っていると、ファイルダウンロード機能が必要な時があります。ただ、ストレージに保存されてあるファイルをそのまま返すということだけでなく、場合によってはファイルを生成してそのまま返したり、複数のファイルをまとめて転送する必要もありますね。&lt;/p>
&lt;p>リクエストごとに一つのファイルをダウンロードさせるとしたら、実装はそう難しくないものですが、複数のファイルをダウンロードさせるという場合は少し複雑になりますね。ファイルを一つにまとめて送るとしたら、ZIPに圧縮した方が良いでしょう。幸い、Javaでは基本的に&lt;a class="link" href="https://docs.oracle.com/javase/jp/8/docs/api/java/util/zip/ZipOutputStream.html" target="_blank" rel="noopener"
>ZipOutputStream&lt;/a>というAPIを提供しているので、エントリに圧縮対象のファイルを追加したあとZIPファイルを出力だけで良いです。&lt;/p>
&lt;p>ただ、単純にファイルが複数だるだけでなく、ディレクトリが多重にネストされてあったりする場合は、ディレクトリ構造を維持しつつそのまま圧縮するとかの追加的な処理が必要となります。そして場合によっては含めたくないファイルがあるケースもあったりしますね。そしてなるべくファイルの数に関係なく(ファイルが一つであれ、ディレクトリであれ)一つの機能で済ませたいものです。なので、今回はそのようなユースケースに合わせた簡単なメソッドを作る方法を、JavaのコードからKotlinへ移行していく過程を簡単に紹介したいと思います。&lt;/p>
&lt;p>今回紹介しますコードは、はBaeldungの&lt;a class="link" href="https://www.baeldung.com/java-compress-and-uncompress" target="_blank" rel="noopener"
>JavaでZipを圧縮する方法&lt;/a>に関する記事に紹介されてあるものをベースにしています。&lt;/p>
&lt;h2 id="java">Java&lt;/h2>
&lt;p>まずJavaのコードを見ていきましょう。上記の記事には、以下のようなコードが紹介されています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">ZipDirectory&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>String&lt;span style="color:#ff79c6">[]&lt;/span> args&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> IOException &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String sourceFile &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;zipTest&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileOutputStream fos &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> FileOutputStream&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;dirCompressed.zip&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipOutputStream zipOut &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ZipOutputStream&lt;span style="color:#ff79c6">(&lt;/span>fos&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File fileToZip &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> File&lt;span style="color:#ff79c6">(&lt;/span>sourceFile&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile&lt;span style="color:#ff79c6">(&lt;/span>fileToZip&lt;span style="color:#ff79c6">,&lt;/span> fileToZip&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getName&lt;/span>&lt;span style="color:#ff79c6">(),&lt;/span> zipOut&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">close&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fos&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">close&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">zipFile&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>File fileToZip&lt;span style="color:#ff79c6">,&lt;/span> String fileName&lt;span style="color:#ff79c6">,&lt;/span> ZipOutputStream zipOut&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">throws&lt;/span> IOException &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>fileToZip&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">isHidden&lt;/span>&lt;span style="color:#ff79c6">())&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>fileToZip&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">isDirectory&lt;/span>&lt;span style="color:#ff79c6">())&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>fileName&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">endsWith&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">))&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">putNextEntry&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> ZipEntry&lt;span style="color:#ff79c6">(&lt;/span>fileName&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">closeEntry&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">putNextEntry&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#ff79c6">new&lt;/span> ZipEntry&lt;span style="color:#ff79c6">(&lt;/span>fileName &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">closeEntry&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File&lt;span style="color:#ff79c6">[]&lt;/span> children &lt;span style="color:#ff79c6">=&lt;/span> fileToZip&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">listFiles&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>File childFile &lt;span style="color:#ff79c6">:&lt;/span> children&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile&lt;span style="color:#ff79c6">(&lt;/span>childFile&lt;span style="color:#ff79c6">,&lt;/span> fileName &lt;span style="color:#ff79c6">+&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span> &lt;span style="color:#ff79c6">+&lt;/span> childFile&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getName&lt;/span>&lt;span style="color:#ff79c6">(),&lt;/span> zipOut&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FileInputStream fis &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> FileInputStream&lt;span style="color:#ff79c6">(&lt;/span>fileToZip&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipEntry zipEntry &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ZipEntry&lt;span style="color:#ff79c6">(&lt;/span>fileName&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">putNextEntry&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>zipEntry&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">byte&lt;/span>&lt;span style="color:#ff79c6">[]&lt;/span> bytes &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> &lt;span style="color:#8be9fd">byte&lt;/span>&lt;span style="color:#ff79c6">[&lt;/span>1024&lt;span style="color:#ff79c6">];&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> length&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span> &lt;span style="color:#ff79c6">((&lt;/span>length &lt;span style="color:#ff79c6">=&lt;/span> fis&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">read&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>bytes&lt;span style="color:#ff79c6">))&lt;/span> &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> 0&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">write&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>bytes&lt;span style="color:#ff79c6">,&lt;/span> 0&lt;span style="color:#ff79c6">,&lt;/span> length&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fis&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">close&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>zipFile&lt;/code>メソッドをみると、引数の&lt;code>fileToZip&lt;/code>にZIPで圧縮したいファイルやディレクトリのパスを指定して、&lt;code>fileName&lt;/code>にはファイルもしくはディレクトリ名、&lt;code>zipOut&lt;/code>には圧縮後のZIPのファイル名を指定するようになっています。&lt;/p>
&lt;p>そして実装としては、指定したファイルやディレクトリに&lt;code>hidden&lt;/code>属性がある場合は圧縮しなく、圧縮元のファイルがディレクトリである場合は中のファイルを全部ZIPに含ませるという処理が含まれてありますね。対象のファイルとディレクトリを全部エントリに追加した後は、圧縮元を読み込んでZipOutputStreamに書き込むという処理となっています。これをKotlinのコードに変えてみましょう。&lt;/p>
&lt;h2 id="kotlinのコードに変えてみる">Kotlinのコードに変えてみる&lt;/h2>
&lt;p>JavaのコードをKotlinのコードに変えるのはそう難しくありません。Intellijの場合、すでにJavaのコードを貼り付けると自動でKotlinのコードの変換してくれる機能を搭載していますので。ただ、それだけでは十分ではないですね。簡単に変換ができるとしても、それが本当に&lt;code>Kotlinらしいコード&lt;/code>になっているとはいえない場合があります。&lt;/p>
&lt;p>そして、処理自体もより単純に、もしくは読みやすいコードにする方法もあるはずですね。上記のJavaコードをまずKotlinに変えて、色々改善したいところを含めて変えていきます。&lt;/p>
&lt;h3 id="kotlinらしいコードに変える">Kotlinらしいコードに変える&lt;/h3>
&lt;p>Intellij 2021.1を基準に、Javaのコードをそのまま貼り付けると以下のようなコードに自動変換されます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Throws(IOException&lt;span style="color:#ff79c6">::&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">zipFile&lt;/span>(fileToZip: File, fileName: String, zipOut: ZipOutputStream) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (fileToZip.isHidden) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (fileToZip.isDirectory) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (fileName.endsWith(&lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(ZipEntry(fileName))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(ZipEntry(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$fileName&lt;/span>&lt;span style="color:#f1fa8c">/&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> children = fileToZip.listFiles()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">for&lt;/span> (childFile &lt;span style="color:#ff79c6">in&lt;/span> children) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipFile(childFile, fileName + &lt;span style="color:#f1fa8c">&amp;#34;/&amp;#34;&lt;/span> + childFile.name, zipOut)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> fis = FileInputStream(fileToZip)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> zipEntry = ZipEntry(fileName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.putNextEntry(zipEntry)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> bytes = ByteArray(&lt;span style="color:#bd93f9">1024&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> length: Int
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">while&lt;/span> (fis.read(bytes).also { length = &lt;span style="color:#ff79c6">it&lt;/span> } &lt;span style="color:#ff79c6">&amp;gt;=&lt;/span> &lt;span style="color:#bd93f9">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zipOut.write(bytes, &lt;span style="color:#bd93f9">0&lt;/span>, length)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fis.close()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでもっとKotlinらしいコードに変えたい部分は、&lt;code>InputStream&lt;/code>や&lt;code>OutputStream&lt;/code>の使い方です。Javaでも&lt;code>try-with-resource&lt;/code>があって、Kotlinには&lt;code>use()&lt;/code>があるのでそちらを使った方が&lt;code>close&lt;/code>よりも良い気がします。&lt;/p>
&lt;p>また、&lt;code>if&lt;/code>は&lt;code>when&lt;/code>に変えたり、&lt;code>for&lt;/code>を&lt;code>forEach()&lt;/code>に変えたりなどでよりやりたいことを明確にすることができるようにも見えます。個人的にはスコープをあえて分けたほうが責任が明確になり、処理を追うときに混乱しないのでなるべくスコープ関数やCollection専用のオペレーションを積極的に使用して処理の単位を分けられるところはきちんと分けたいと思います。Javaのやり方をとっても処理としては全く問題がありませんが、せっかくなのでKotlinならではのコードを描きたいものです。&lt;/p>
&lt;p>あえてIOExceptionを投げるという表示をしておくというのも、ランタイム時の例外の処理を強制してないKotlinには相応しくないのではないかという気もするので、アノテーションは削除することとします。&lt;/p>
&lt;h3 id="ioからnioに変える">IOからNIOに変える&lt;/h3>
&lt;p>NIOに関しては以前のポストで何回か言及したことがありますが、サーバのように頻繁かつ同時実行数が多いケースは積極的に採用した方が良いと思います。また、Java 1.8以降から追加されたメソッドでかなり便利に使える機能が多いので、IOをNIOに変えるだけでコードの量をかなり減らせる可能性もあります。&lt;/p>
&lt;p>特にディレクトリを指定した場合、そのディレクトリの子要素を循環するにはNIOの&lt;code>Files&lt;/code>が提供する機能が強力なので、今回はそれを積極活用することにします。&lt;/p>
&lt;h3 id="シグニチャーを変える">シグニチャーを変える&lt;/h3>
&lt;p>上記のメソッドでは、三つの引数を取っていますが、実際に必要なのは圧縮元のパスと、圧縮先のパスのみですね。ZipOutputStreamを呼び出し元で渡す理由は特になく、むしろこのメソッドを利用する度に定義する必要があるので不便ですね。そして、メソッドの中で単純にエントリを追加していて、呼び出し元とオブジェクトに対する処理の職務を分担するという構造もあまりよくないかと思います。なので、ZipOutputStreamの生成と使用はメソッドの中で完結するように変えることにします。&lt;/p>
&lt;p>こうすることで、メソッドの外側(呼び出し元)での使い方はもっと簡単になりますし、圧縮元のデータを読み込む際に使う&lt;code>InputStream&lt;/code>は中で閉じているのに引数の&lt;code>OutputStream&lt;/code>は外で閉じるという複雑な状況は避けられます。&lt;/p>
&lt;h3 id="再帰を無くす">再帰を無くす&lt;/h3>
&lt;p>圧縮元のパスがディレクトリである場合は、さらにネストされたディレクトリやファイルもまとめて圧縮するために再帰を使うようになっています。再帰はアルゴリズムとしては重要ではあるものの、処理が全部終わるまでメモリに全データと処理を詰めておくので処理の効率という面ではあまりよくない場合もありますね。やりたいのは単純に&lt;code>hidden&lt;/code>属性を持つファイルやディレクトリを除外すること、そしてそれ以外のファイルやディレクトリは全部ZipOutputStreamのエントリに入れたいという単純な事です。&lt;/p>
&lt;p>幸い、NIOを使うことでディレクトリの子要素を全部取得することができますし、取得した子要素は&lt;code>Stream&amp;lt;Path&amp;gt;&lt;/code>として取得できるので、&lt;code>filter()&lt;/code>や&lt;code>forEach()&lt;/code>のようなメソッドが使えます。これで十分、再帰を使わずに目的を達成できそうですね。&lt;/p>
&lt;h2 id="完成したコード">完成したコード&lt;/h2>
&lt;p>以上のことを反映し、修正したコードは以下の通りになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">object&lt;/span> &lt;span style="color:#50fa7b">ZipService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">archive&lt;/span>(source: Path, target: Path): Unit =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ZipOutputStream(Files.newOutputStream(target)).use { zos &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Files.walk(source)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .filter { Files.isHidden(&lt;span style="color:#ff79c6">it&lt;/span>).not() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (Files.isDirectory(&lt;span style="color:#ff79c6">it&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.putNextEntry(ZipEntry(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$it&lt;/span>&lt;span style="color:#f1fa8c">/&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.closeEntry()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zos.putNextEntry(ZipEntry(&lt;span style="color:#ff79c6">it&lt;/span>.toString()))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Files.copy(&lt;span style="color:#ff79c6">it&lt;/span>, zos)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>簡単に説明しますと、&lt;code>object&lt;/code>として宣言したSingletonクラスにおくことでどこでも活用できるユーティリティクラスにして、メソッドのシグニチャはより単純なものにしました。引数の&lt;code>source&lt;/code>には圧縮元のファイルやディレクトリを、&lt;code>target&lt;/code>には圧縮先のZIPファイルを指定する事になっています。ZipOutputStreamはメソッドの中で生成して、&lt;code>use()&lt;/code>を使って自動にクローズされるようにしています。&lt;/p>
&lt;p>まず優先的に&lt;code>Files.walk()&lt;/code>を使って子要素を全部取得するようにしています。取得した子要素は&lt;code>filter()&lt;/code>で&lt;code>hidden&lt;/code>でない場合を選別しているので、分岐は無くなりますね。また、子要素がディレクトリである場合ディレクトリ名であることを表すために&lt;code>/&lt;/code>をつけて&lt;code>ZipEntry&lt;/code>を追加とクローズします。子要素がファイルの場合は&lt;code>ZipEntry&lt;/code>の追加とコンテンツのコピーを行います。これでより短く、単純なコードの出来上がりです。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>&lt;code>Kotlinらしいコード&lt;/code>と述べましたが、上記のコードはあくまで&lt;code>Kotlin/JVM&lt;/code>でのみ有効ですね。なのでもし&lt;code>Kotlin/Native&lt;/code>や&lt;code>Kotlin/JS&lt;/code>などで使うには、別の方法を探す必要があるはずです。また、&lt;code>Files.walk()&lt;/code>はJava 1.8から追加されたメソッドなので、1.7の場合は&lt;code>Files.walkFileTree()&lt;/code>を、その以前なら仕方なくNIOではない別の方法を使う必要があると思います。&lt;/p>
&lt;p>なので、&lt;code>Kotlin/JVM&lt;/code>(Java 1.8以上)ではこれが最善なのかも知れませんが、また色々と研究の余地はありそうですね。こうやってJavaのAPIをKotlinの作法で切り替えていくのも、それなりに価値のあることではないかと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Kotlinで書いてみた〜その一〜</title><link>https://retheviper.github.io/posts/kotlin-code-in-my-style-1/</link><pubDate>Sun, 28 Mar 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-code-in-my-style-1/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Kotlinで書いてみた〜その一〜" />&lt;p>こないだはGoに関するポストを作成しましたが、やはり本業はKotlinなので、Kotlinに関しても何かわかったことや閃いたことなどあれば、順次に書いていこうと思っています。今回はKotlinでAPIを作りながら、業務での要件をどんなコードで満たしたかを簡単に説明させていただきたいと思います。&lt;/p>
&lt;p>サーバサイドエンジニアをやっていると、要求される機能を以下に実現している方法がどんなものあれ(GraphQL、REST API、マイクロサービスみたいな技術やアーキテクチャの観点の以前の話として)、業務としてはある程度パターン化しているように感じることがあります。こういう場合には、コードよりもロジックが大事であるかのように見える場合もありますね。でも逆に、むしろ似たようなロジックが多いので、より良いコードを書くために工夫できる余地もまた多いのではないか、とも思います。&lt;/p>
&lt;p>正直自分はアルゴリズムに強いわけでもないので、効率的なコードを書くとしたら限界はあるだろうなという気はしています。とりあえず動くコードを書いて、それをリファクタリングしながら少しづつ整える感じのことしかできないのかも知れません。&lt;/p>
&lt;p>しかし、そんな自分にも良いコードを書くためにできることが全くないわけでもないと思います。例えば、Javaでコードを書くときは、参照の問題などからなるべく&lt;code>final&lt;/code>をつけてオブジェクトを&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%9F%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB" target="_blank" rel="noopener"
>immutable&lt;/a>にするようにと教わりましたが、実際は&lt;a class="link" href="https://www.baeldung.com/java-final-performance?__s=m4suw1p9x2sbizbhxrew" target="_blank" rel="noopener"
>ベンチマークで比較した結果&lt;/a>でもわかるように、性能の改善にも繋がっています。また、JavaでもKotlinでも色々と便利なAPIを提供していて、バージョンアップの度にまた新しいAPIが追加されるので、それらの用途と使い方をよく理解した上で、積極的に使用するだけでも読みやすく、性能も良いコードを書くことができます。&lt;/p>
&lt;p>ということで、今回はKotlinのAPIを使って書いていたコードを一部紹介したいと思います。&lt;/p>
&lt;h2 id="リストのグループ化">リストのグループ化&lt;/h2>
&lt;p>DBに商品情報テーブルがあって、さらに商品属性テーブル、生産地や販売店テーブルなどがある場合に、業務によっては「販売店ごとにどんな商品が販売されているかを確認したい」とか、「特定の商品属性に当てはまる商品だけみたい」とかのケースがあるはずですね。&lt;/p>
&lt;p>そういった場合、APIとしてはテーブルから取得したデータを、特定のカラムを基準にまとめたもの返す必要があります。これをコードに書くとしたら&lt;code>List&lt;/code>で取得したデータを、中の一つの属性をキーに&lt;code>Map&lt;/code>にまとめて返すということになりますね。Javaだと、以下のような形になるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBのデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>User&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> list &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">new&lt;/span> User&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> 20&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;USA&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Programmer&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">new&lt;/span> User&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;James&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> 30&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Canada&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Sales&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">),&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">new&lt;/span> User&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Jack&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> 35&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;UK&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;Programmer&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// UserのJobを基準にまとめる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Map&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">,&lt;/span> List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>Pair&lt;span style="color:#ff79c6">&amp;gt;&amp;gt;&lt;/span> map &lt;span style="color:#ff79c6">=&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">collect&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">groupingBy&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>User&lt;span style="color:#ff79c6">::&lt;/span>getJob&lt;span style="color:#ff79c6">,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">mapping&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>user &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> Pair&lt;span style="color:#ff79c6">(&lt;/span>user&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getAge&lt;/span>&lt;span style="color:#ff79c6">(),&lt;/span> user&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">getName&lt;/span>&lt;span style="color:#ff79c6">()),&lt;/span> Collectors&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toList&lt;/span>&lt;span style="color:#ff79c6">())));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// {James=[Pair(first=30, second=Sales)], John=[Pair(first=20, second=Programmer), Pair(first=35, second=Writer)]}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@AllArgsConstructor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">User&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> String name&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> age&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> String address&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> String job&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@AllArgsConstructor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">static&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">class&lt;/span> &lt;span style="color:#50fa7b">Pair&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> Object first&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> Object second&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KotlinでもJavaのAPIをそのまま使うことができるので、上記の&lt;code>Stream&lt;/code>と&lt;code>Collector&lt;/code>を使って同じことはできます。ただ、せっかく違う言語と使っているわけなので、できればKotlinが提供するAPIを活用して同じことをしたいものです。&lt;/p>
&lt;p>KotlinはCollectionで提供する機能だけでも&lt;code>Stream&lt;/code>と&lt;code>Collector&lt;/code>を組み合わせたものと似たような処理ができる場合が多いので、JavaのAPIに対応した機能があるかどうかを探すだけで事足りるケースが多いです。ということは、上記の処理でキモになっている&lt;code>Collectors.groupingBy()&lt;/code>と&lt;code>Collectors.mapping()&lt;/code>と似たようなものがあればいいというわけですが、&lt;code>groupBy()&lt;/code>でそれらの処理をまとめることができます。なので、上記のコードをKotlinで変えると、以下のようになります。色々とスッキリしますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">20&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;USA&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Programmer&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;James&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">30&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Canada&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Sales&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;Jack&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">35&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;UK&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Programmer&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Jobを基準にMap&amp;lt;String, List&amp;lt;Pair&amp;lt;Int, String&amp;gt;&amp;gt;&amp;gt;にまとめる
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> map = list.groupBy({ &lt;span style="color:#ff79c6">it&lt;/span>.job }, { &lt;span style="color:#ff79c6">it&lt;/span>.age to &lt;span style="color:#ff79c6">it&lt;/span>.name })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// {Programmer=[(20, John), (35, Jack)], Sales=[(30, James)]}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">User&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> name: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> age: Int,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> address: String,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> job: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="mapのvalueだけを変える">Mapのvalueだけを変える&lt;/h2>
&lt;p>上記の処理に加えて、もっと条件がつく場合もあるかと思います。例えば、金額計算とかの例があるとします。従業員が案件ごとに賃金をもらうということになっていて、案件はコードで管理されている場合、賃金を払う側としては同じ案件に対しては合算した金額のみが知りたいとかのケースもあるでしょう。こういう場合には、従業員ごとにデータをまとめた上で、さらにその人が担当した案件のリスト野中で重複するものがあれば、金額だけを合算するようにする必要がありますね。&lt;/p>
&lt;p>こういう場合は、グルーピングの段階からそういう処理を入れるのがもっとも効率的ではあるとは思いますが、スレッドの問題もあるので(生成中のMapの中を巡回するという)、実際のコードに書くとするとかなり複雑になる可能性もあります。なのでここではまず、&lt;code>List&lt;/code>を&lt;code>Map&lt;/code>にまとめた結果を持ってさらに処理を加えるという形を取ります。&lt;/p>
&lt;p>Kotlinの&lt;code>Map&lt;/code>には、&lt;code>map()&lt;/code>以外にも&lt;code>mapKeys()&lt;/code>や&lt;code>mapValues()&lt;/code>のような関数があって、必要な部分だけをマッピングできます。今回は&lt;code>value&lt;/code>だけを変えたいので、&lt;code>mapValues()&lt;/code>を使った方が無駄がなく、コードを読む側としても意図が明確になって良いと思います。&lt;code>mapValues()&lt;/code>を使ってさらにマッピングを行うコードは、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">User&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> name: String, &lt;span style="color:#ff79c6">val&lt;/span> id: Int, &lt;span style="color:#ff79c6">val&lt;/span> amount: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">1000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">1&lt;/span>, &lt;span style="color:#bd93f9">2000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">2&lt;/span>, &lt;span style="color:#bd93f9">4000&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User(&lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">3&lt;/span>, &lt;span style="color:#bd93f9">5000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// nameでまとめた後、重複するidを一つにまとめる(amountを合算)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> map = list.groupBy({ &lt;span style="color:#ff79c6">it&lt;/span>.name }, { &lt;span style="color:#ff79c6">it&lt;/span>.id to &lt;span style="color:#ff79c6">it&lt;/span>.amount })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .mapValues {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// idでグルーピング
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">it&lt;/span>.&lt;span style="color:#ff79c6">value&lt;/span>.groupBy { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.first }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// keyはそのまま、valueだけを合算する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> .map { map &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> map.key to map.&lt;span style="color:#ff79c6">value&lt;/span>.sumBy { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.second } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// {A=[(1, 3000), (2, 4000)], B=[(3, 5000)]}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>List&lt;/code>を&lt;code>Map&lt;/code>にまとめるもう一つの方法は、&lt;code>groupingBy()&lt;/code>があります。この関数を使うと、Collectionが&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-grouping" target="_blank" rel="noopener"
>Grouping&lt;/a>というオブジェクトに変わって、&lt;code>aggregate()&lt;/code>・&lt;code>reduce()&lt;/code>・&lt;code>fold()&lt;/code>・&lt;code>eachCount()&lt;/code>のような関数を使うことで後続の処理ができます。上記のコードを&lt;code>Grouping&lt;/code>を使ったものに変えるとしたら、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Groupingのaggregateを利用してMapに変えた後から、valueの処理を行う
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> map = list.groupingBy { &lt;span style="color:#ff79c6">it&lt;/span>.name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .aggregate { _, accumulator: MutableList&amp;lt;Pair&amp;lt;Int, Int&amp;gt;&amp;gt;?, element, first &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// 新しいキーなら、MutableListを作る
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (first)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutableListOf(element.id to element.amount)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// そうではない場合は、存在するListに要素を追加する
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accumulator&lt;span style="color:#ff79c6">?.&lt;/span>apply { add(element.id to element.amount) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }.mapValues {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.&lt;span style="color:#ff79c6">value&lt;/span>&lt;span style="color:#ff79c6">?.&lt;/span>groupBy { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.first }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">?.&lt;/span>map { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.key to pair.&lt;span style="color:#ff79c6">value&lt;/span>.sumBy { pair &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> pair.second } }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一見、&lt;code>groupingBy()&lt;/code>の方が複雑にも見えますが、&lt;code>accumulator&lt;/code>を使ってマッピングした値を積み重ねることができるので、場合によっては考慮する価値があるかもですね。&lt;/p>
&lt;h2 id="mapを使ったキャッシュ">Mapを使ったキャッシュ&lt;/h2>
&lt;p>DBの参照が頻繁であり、なお参照されるデータそのものは更新される頻度が高くない場合は、アプリケーション内にキャッシュして置くのが良いケースもたまにありますね。こういう場合には、パラメータをキーとして持つ&lt;code>Map&lt;/code>を宣言しておいて、そのキーがない場合だけDBにアクセスする(そして&lt;code>Map&lt;/code>に追加する)という形にすれば良いでしょう。Javaでは1.8から&lt;code>computeIfAbsent()&lt;/code>というメソッドを提供しているので、簡単に実装ができます。例えば以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> list &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// キャッシュのMap
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Map&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">,&lt;/span> Boolean&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> map &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> ConcurrentHashMap&lt;span style="color:#ff79c6">&amp;lt;&amp;gt;();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// パラメータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>String element &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// キャッシュにパラメータがない場合はDBデータを参照して、追加した後に返す
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Boolean exists &lt;span style="color:#ff79c6">=&lt;/span> map&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">computeIfAbsent&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>element&lt;span style="color:#ff79c6">,&lt;/span> key &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> list&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">contains&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>element&lt;span style="color:#ff79c6">));&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Method Referenceを使った例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>exists &lt;span style="color:#ff79c6">=&lt;/span> map&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">computeIfAbsent&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>element&lt;span style="color:#ff79c6">,&lt;/span> list&lt;span style="color:#ff79c6">::&lt;/span>contains&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaで提供する機能なので、もちろんKotlinでも全く同じ形で実装できます。ただ、Kotlinの仕様上&lt;code>compute&lt;/code>のコードが&lt;a class="link" href="https://kotlinlang.org/docs/lambdas.html#instantiating-a-function-type" target="_blank" rel="noopener"
>LambdaかMethod Referenceかによって書き方が違う&lt;/a>ので、そこだけ注意する必要があります。これはKotlin自体の仕様によるものですが、Javaの書き方に慣れていると最初はなかなかわかりにくいところかも知れません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// DBデータの例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// キャッシュのMap
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> map = ConcurrentHashMap&amp;lt;String, Boolean&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// パラメータ
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> element = &lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Lambdaの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> exists = map.computeIfAbsent(element) { list.contains(element) } &lt;span style="color:#6272a4">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Method Referenceの場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>exists = map.computeIfAbsent(element, list&lt;span style="color:#ff79c6">::&lt;/span>contains)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、似たような機能をするメソッドとして&lt;code>putIfAbsent()&lt;/code>がありますが、&lt;code>computIfAbsent()&lt;/code>の場合&lt;code>Map&lt;/code>にキーがなかった場合にだけ後続の処理が行われるに対して、&lt;code>putIfAbsent()&lt;/code>はキーがあるかないかに関係なく処理が走ってしまうという違いがあるらしいです。なのでキャッシュとして使う場合は、&lt;code>computeIfAbsent()&lt;/code>を使った方が良いでしょう。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>自分が書いたコードをいくつか紹介しましたが、いかがだったでしょうか。まだKotlinに移行したばかりなので色々とわからないことが多く、本当はもっとスマートな方法があるのかも知れませんが、自分的には、こうやって実際の業務の要件に合わせて違う言語とコードを比べながら、APIのソースをみたりで自分なりにどうやって書くかを考えてみるのは意味のあることで、楽しいとも思います。&lt;/p>
&lt;p>というわけで、これからもKotlinでの書き方に対する研究はこれからも続きます。そろそろGoでも簡単なAPIでも作ってみたりで勉強をしないとやばそうな気もしていますが…まぁ、なんとかなるでしょう。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>JavaプログラマーがみたKotlin〜その二〜</title><link>https://retheviper.github.io/posts/kotlin-basics/</link><pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-basics/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post JavaプログラマーがみたKotlin〜その二〜" />&lt;p>この度は、転職することとなり、仕事で使われる言語もJavaからKotlinに変わることになりました。個人的にKotlinで簡単なSpring WebFluxプロジェクトを作ってみたことはあり、もともとJavaプログラマがKotlinへ移行するのは難しいことではないと言われてはいるものの、やはり仕事で使われる言語が変わるというのはかなりのチャレンジではあると思います。なので、今まではJavaに関してのポストを主に載せていたのですが、これからはKotlinに関してのポストを増やしていきたいと思います。&lt;/p>
&lt;p>まず、よく知られているように、KotlinはJavaと完璧な互換性を持つものです。それはJVM言語であり、コンパイルしたらJavaと同じくバイトコードになるからですね。ただ、だからと言って「Javaの感覚で」コードを書くということは、Kotlinという「違う言語」に移行する意味を無くす行為な気がします。なぜなら、Kotlinは触れば触るほどJavaとは根本的に違う考え方で設計されている言語だということが伝わってくるからです。最初はJavaの冗長さ(Verbose)を減らすことが第一の目標ではないかという印象を受けましたが、本格的に勉強を始めるとそれだけではないような気がしているのです。&lt;/p>
&lt;p>今回のポストは、&lt;a class="link" href="https://www.coursera.org" target="_blank" rel="noopener"
>Coursera&lt;/a>の&lt;a class="link" href="https://www.coursera.org/learn/kotlin-for-java-developers" target="_blank" rel="noopener"
>Kotlin for Java Developers&lt;/a>の講義の内容に基づいて作成されました。&lt;/p>
&lt;h2 id="冗長さを減らすということ">冗長さを減らすということ&lt;/h2>
&lt;p>Javaは今でも良い言語であり、多くの言語が発表されエンタープライズレベルで使われるようになった今でも、幅広い分野で使われていますね。Javaが依然としてよく使われる言語であることは、&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE index&lt;/a>やJetBrainsの&lt;a class="link" href="https://www.jetbrains.com/lp/devecosystem-2020" target="_blank" rel="noopener"
>The State of Developer Ecosystem&lt;/a>、Stackoverflowの&lt;a class="link" href="https://insights.stackoverflow.com/survey/2020" target="_blank" rel="noopener"
>Developer Survey&lt;/a>からも読み取れることです。&lt;/p>
&lt;p>ただ、Javaが依然として人気の言語だとしても、それは圧倒的にJavaが他の言語に比べ優秀だとか、使いやすい言語であるという意味ではないでしょう。どの言語でもそうであると思いますが、Javaでよく指摘されている問題の一つは、「冗長すぎる」というところです。数多くのライブラリがあり、MavenやGradleのような優秀なビルドツールを使えながらも、やはり言語の仕様は変わってないですからね。Java 9からはこの問題を解消するため、他の言語から影響を受けたような機能を多く導入していますが(例えば、&lt;a class="link" href="https://blogs.oracle.com/javamagazine/pattern-matching-for-instanceof-in-java-14" target="_blank" rel="noopener"
>instanceofのパターンマッチング&lt;/a>や&lt;a class="link" href="https://blogs.oracle.com/javamagazine/records-come-to-java" target="_blank" rel="noopener"
>record&lt;/a>など)、言語そのものの設計思想が変わるというよりは「違う言語の特徴をJavaに合わせた仕様で導入する」ことに近いので、根本的な変化とは言えないものです。なので今まで書かれている冗長なコードは残るもので、またこれからも使われることになるはずです。&lt;/p>
&lt;h3 id="コードが短くなる">コードが短くなる&lt;/h3>
&lt;p>冗長さを減らすということは、簡単にいうと「より短いコードで、同じ結果を得る」と定義できるでしょう。そういう観点からすると、KotlinはJavaの冗長さを減らすために工夫した痕跡が言語の仕様から感じ取れるようなものです。例えば以下のようなコードがあるとしましょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">public&lt;/span> &lt;span style="color:#8be9fd">void&lt;/span> &lt;span style="color:#50fa7b">updateWeather&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#8be9fd">int&lt;/span> degrees&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String description&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Color color&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>degrees &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> 10&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;cold&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#ff79c6">=&lt;/span> BLUE&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>degrees &lt;span style="color:#ff79c6">&amp;lt;&lt;/span> 25&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;mild&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#ff79c6">=&lt;/span> ORANGE&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;hot&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> color &lt;span style="color:#ff79c6">=&lt;/span> RED&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをKotlinで書き換えると、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> (description, color) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (degrees &amp;lt; &lt;span style="color:#bd93f9">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;cold&amp;#34;&lt;/span>, BLUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> (degrees &amp;lt; &lt;span style="color:#bd93f9">25&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;mild&amp;#34;&lt;/span>, ORANGE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#ff79c6">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;hot&amp;#34;&lt;/span>, RED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まず二つの変数を、戻り値が&lt;code>Pair&lt;/code>のオブジェクトの表現式でより短くできることがわかります。そしてこのコードは、&lt;code>when&lt;/code>句を使ってより短い形で変えることもできます。その結果が以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> (description, color) = &lt;span style="color:#ff79c6">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#bd93f9">10&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;cold&amp;#34;&lt;/span>, BLUE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#bd93f9">25&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;mild&amp;#34;&lt;/span>, ORANGE)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> Pair(&lt;span style="color:#f1fa8c">&amp;#34;hot&amp;#34;&lt;/span>, RED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに&lt;code>Pair&lt;/code>は、&lt;code>to&lt;/code>を使うことでもっと簡単に表現することもできます。そうすると、以下のようなコードになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">updateWeather&lt;/span>(degrees: Int) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">val&lt;/span> (description, color) = &lt;span style="color:#ff79c6">when&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#bd93f9">10&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;cold&amp;#34;&lt;/span> to BLUE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> degrees &amp;lt; &lt;span style="color:#bd93f9">25&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;mild&amp;#34;&lt;/span> to ORANGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;hot&amp;#34;&lt;/span> to RED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最初のJavaのコードと比べ、かなり簡単かつ明瞭なコードになっているのがわかります。他の言語を使っていた人だとしても、一瞬ですぐに何をしているのかがわかって、より短く効率なコードになっているのがわかりますね。こういうところこそ、KotlinがJavaの冗長さ−無駄を減らすことに力を入れている部分ではないかと思います。&lt;/p>
&lt;h3 id="コードを簡単に書ける">コードを簡単に書ける&lt;/h3>
&lt;p>自分は最初、Kotlinの文法を簡単にみながら&lt;code>switch&lt;/code>がここでは&lt;code>when&lt;/code>に変わって、&lt;code>case&lt;/code>を書く必要がないんだな、くらいの印象しか受けてなかったです。しかし、よくよく見ると、他にもJavaと違うところが良く見えます。ここで読み取れるものは、例えばさっきのコードだと以下がありますね。&lt;/p>
&lt;ul>
&lt;li>&lt;code>when&lt;/code>句が表現式として使える&lt;/li>
&lt;li>&lt;code>when&lt;/code>句の条件の対象は条件式の中のみで良い&lt;/li>
&lt;li>表現式の中で複数の値を戻り値として定義し、それを&lt;/li>
&lt;li>&lt;code>to&lt;/code>で二つのオブジェクトを&lt;code>Pair&lt;/code>にまとめることができる&lt;/li>
&lt;/ul>
&lt;p>他にも、Javaの&lt;code>switch&lt;/code>に比べKotlinの&lt;code>when&lt;/code>句は以下のよう活用ができるというところもあります。オブジェクトの比較がより簡単ですね。例えば以下のようなコードで、簡単に二つのオブジェクトに対しても比較が可能になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">mix&lt;/span>(c1: Color, c2: Color) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">when&lt;/span> (setOf(c1, c2)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(RED, YELLOW) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> ORANGE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(YELLOW, BLUE) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> GREEN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setOf(BLUE, VIOLET) &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> INDIGO
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">throw&lt;/span> Exception(&lt;span style="color:#f1fa8c">&amp;#34;Dirty Color&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをあえてJavaのコードで書くとしたら、おそらく以下のようになるでしょう。個人的に、たくさんの&lt;code>else if&lt;/code>はあまり読みやすいコードではなく、書く立場としても綺麗ではないと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#8be9fd;font-style:italic">private&lt;/span> Color &lt;span style="color:#50fa7b">mix&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>Color c1&lt;span style="color:#ff79c6">,&lt;/span> Color c2&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>c1 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">RED&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">YELLOW&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">ORANGE&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>c1 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">YELLOW&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">BLUE&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">GREEN&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">if&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>c1 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">BLUE&lt;/span> &lt;span style="color:#ff79c6">&amp;amp;&amp;amp;&lt;/span> c2 &lt;span style="color:#ff79c6">==&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">VIOLET&lt;/span>&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> Color&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">INDIGO&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span> &lt;span style="color:#ff79c6">else&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">throw&lt;/span> &lt;span style="color:#ff79c6">new&lt;/span> RuntimeException&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;Dirty Color&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでわかるのは、KotlinではJavaと同じことをするとしても、短いだけでなく、より簡単にコードをかけるということですね。もちろん、別のメソッドを作ったり、&lt;code>Comparable&lt;/code>なオブジェクトを作ったり、&lt;code>Comparator&lt;/code>クラスを実装することでJavaでも似たようなことはできるかも知れません。しかし、そこまでしたいかというと微妙ですね。&lt;/p>
&lt;p>もちろん、Java 12からはKotlinの&lt;code>when&lt;/code>に近い感覚でコードを書くこともできるようになっています。表現式としても使えて、複数の条件を指定することができ、&lt;code>Lambda&lt;/code>の感覚で書けるということも良いですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>var result &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#ff79c6">switch&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>month&lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> JANUARY&lt;span style="color:#ff79c6">,&lt;/span> JUNE&lt;span style="color:#ff79c6">,&lt;/span> JULY &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> 3&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> FEBRUARY&lt;span style="color:#ff79c6">,&lt;/span> SEPTEMBER&lt;span style="color:#ff79c6">,&lt;/span> OCTOBER&lt;span style="color:#ff79c6">,&lt;/span> NOVEMBER&lt;span style="color:#ff79c6">,&lt;/span> DECEMBER &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> 1&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">case&lt;/span> MARCH&lt;span style="color:#ff79c6">,&lt;/span> MAY&lt;span style="color:#ff79c6">,&lt;/span> APRIL&lt;span style="color:#ff79c6">,&lt;/span> AUGUST &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#ff79c6">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#8be9fd">int&lt;/span> monthLength &lt;span style="color:#ff79c6">=&lt;/span> month&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">toString&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">length&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> yield monthLength &lt;span style="color:#ff79c6">*&lt;/span> 4&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">default&lt;/span> &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> 0&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような変化を見ると、この「冗長さを減らす」という面では、Javaもまたバージョンアップとともに新機能を次々と導入してきているので、Kotlinの魅力が半減しているように見えるかも知れません。しかし、Kotlinではもっと重要なポイントがまた一つあります。言語自体の拡張性です。&lt;/p>
&lt;h2 id="拡張ができるということ">拡張ができるということ&lt;/h2>
&lt;p>言語自体の拡張性と言いましたが、簡単にいうと、以前にも紹介したことのある拡張関数、つまり&lt;code>extension&lt;/code>のことです。Kotlinの仕様としてもこれは大きい部分として紹介されているものですね。これをよく使うと、ただ「継承しなくてもそのクラスにメソッドを追加できる」だけでなく、&lt;code>infix&lt;/code>と組み合わせることでまるで予約後であるように使うことができます。&lt;/p>
&lt;p>実際、&lt;a class="link" href="https://www.coursera.org/learn/kotlin-for-java-developers" target="_blank" rel="noopener"
>Kotlin for Java Developers&lt;/a>のコーディング問題では、&lt;code>infix&lt;/code>で書かれた以下の拡張関数を持って結果の確認を行っていると言われています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">infix&lt;/span> &lt;span style="color:#ff79c6">fun&lt;/span> &amp;lt;&lt;span style="color:#50fa7b">T&lt;/span>&amp;gt; &lt;span style="color:#50fa7b">T&lt;/span>.eq(other: T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">if&lt;/span> (&lt;span style="color:#ff79c6">this&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> other) println(&lt;span style="color:#f1fa8c">&amp;#34;OK&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">else&lt;/span> println(&lt;span style="color:#f1fa8c">&amp;#34;Error: &lt;/span>&lt;span style="color:#f1fa8c">$this&lt;/span>&lt;span style="color:#f1fa8c"> != &lt;/span>&lt;span style="color:#f1fa8c">$other&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この&lt;code>infix&lt;/code>を使うと、以下のようなコードが書けるようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&amp;#34;ABC&amp;#34;&lt;/span> eq &lt;span style="color:#f1fa8c">&amp;#34;ABC&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このような特徴があるということは、使う側からしても便利ですが、これから言語そのもののバージョンアップにしたがってより便利な機能が追加され安いことにもなっていると思います。例えば先ほどの&lt;code>Pair&lt;/code>オブジェクトを作る&lt;code>to&lt;/code>が、このように&lt;code>infix&lt;/code>関数として作られているものです。これからもこういった便利な機能が追加され、追加しやすくなるのは確かに開発のコストの削減をという面でも良いことですね。&lt;/p>
&lt;h2 id="もう十分便利であること">もう十分便利であること&lt;/h2>
&lt;p>冗長さを減らし、拡張性がある言語だという特徴は、おそらくKotlinを作っているJetBrainsにとっても十分有効な特徴であるかと思います。Kotlinのスタンダードライブラリを見ると、すでに便利な関数が多く存在しています。例えば、簡単なループでは以下のようなことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> list = listOf(&lt;span style="color:#f1fa8c">&amp;#34;A&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;B&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;C&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 一般的なfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">for&lt;/span> (element &lt;span style="color:#ff79c6">in&lt;/span> list) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(element)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデックスを含むfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">for&lt;/span> ((index, element) &lt;span style="color:#ff79c6">in&lt;/span> list.withIndex()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$index&lt;/span>&lt;span style="color:#f1fa8c">: &lt;/span>&lt;span style="color:#f1fa8c">$element&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデックスのみのfor文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">for&lt;/span> (index &lt;span style="color:#ff79c6">in&lt;/span> list.indices) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(index)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以前もJavaのfor文の性能についてのポストで簡単に述べたことがありますが、そこではJavaならインデックスが必要な場合は伝統的なfor文を使い、そうではない場合は一般的に拡張for文を使った方がいいという結論をJMHでのベンチマークで出していました。しかし、こうやってすでに言語から便利な方法を提供していると、性能を気にすることなく便利な方法を取れるという面でも魅力的です。&lt;/p>
&lt;p>そして、forEachでもインデックスが必要であるなら、&lt;code>forEachIndexed&lt;/code>を使えるという良い点もあります。例えば、以下のような書き方ができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// 一般的なforEach文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>list.forEach(&lt;span style="color:#ff79c6">::&lt;/span>println)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// インデックスを含むforEach文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>list.forEachIndexed { index, element &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> println(&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#f1fa8c">$index&lt;/span>&lt;span style="color:#f1fa8c">: &lt;/span>&lt;span style="color:#f1fa8c">$element&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インデックスを簡単に取得できるということは、ループ対象のオブジェクトが持つ全インデックスを取得したい場合に、あえて&lt;code>0&lt;/code>のような、マジックナンバーにありえる数値を指定する必要がないというところでも良いですね。Javaだと毎回、static finalなフィールドとして宣言したり、別の定数として管理したりするケースが多いので…&lt;/p>
&lt;p>他にも、正規表現なしでも文字に関して簡単にチェックできる関数が事前に提供されているとか(&lt;code>Char.isLetter()&lt;/code>や&lt;code>Char.isDigit()&lt;/code>など)、&lt;code>Map&lt;/code>には&lt;code>Pair&lt;/code>で要素を入れることができるとか、iterableなオブジェクトからStream APIのような操作がすぐできるなど、確かにJavaに比べ「悩む必要がない」のが魅力的と思います。まぁ、人によってはこれはデメリットと認識する可能性もあるのでは、といは思いますが…&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>色々とKotlinの特徴・メリットについて述べましたが、こういう自分もまだ実際に業務でKotlinを使っているわけではないので、まだまだ表面的な知識のみに止まっていると思います。しかし、ここで紹介したことだけでも、Kotlinの魅力は感じ取れるのではないかと思います。&lt;/p>
&lt;p>言語自体も魅力的なのですが、他にもKotlinを扱うことで得られるメリットは多いです。例えば、JetBrainsが開発しているので、Intellijとの相性が良いこと。JVM言語でありJavaとの互換性があるので、Javaの発展をそのまま吸収できるということ。NativeやJavaScriptへのコンパイルもできるということ。他の言語も十分魅力的なポイントはありますが、Javaプログラマーであるなら、一度Kotlinに触れてみる価値はあると信じています。皆さんもまだKotlinに触れたことがないのであれば、この度ぜひ軽い気持ちで挑戦してみてください。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Scope Functionはどう使うか</title><link>https://retheviper.github.io/posts/kotlin-scope-function/</link><pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-scope-function/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post Scope Functionはどう使うか" />&lt;p>KotlinがJavaと区別される特徴といえば色々あるとは思いますが、そのうちの一つとしてあげられるものが&lt;code>Scope Function&lt;/code>ではないかと思います。以前のポストでも簡単に触れたことがありますが、これらのビルトイン関数たちは確かに上手く使うと、Javaより簡潔なコードを書くばかりでなく、より作成者の意図が伝わりやすい、強力な武器になり得るのではないかと思います。しかしながら、やはり他の言語と比べて新しい概念のものであるので、どの場面で使った方が良いか、どう使ったらいいかという、いわゆるBest Practiceがどんなものであるか悩ましくもなりますね。&lt;/p>
&lt;p>おそらくこう思っているのは自分だけでなく、ネットから検索してみるとScope Functionに関しての多くの記事を見つけることができますが、大抵が個別の関数の使い方の紹介に過ぎないような気がしています。なので、具体的にこれらの関数はなんのためのものであり、それぞれどう使い分けるか、またどの場面で使うべきかというのが気になっていたところです。調べてみたところ、公式のドキュメントやいくつかのブログの記事などに情報があったので、これらをまとめて整理してみました。&lt;/p>
&lt;h2 id="そもそもscope-functionって">そもそもScope Functionって？&lt;/h2>
&lt;p>最初にScope Functionを言及しましたが、これは一体なんでしょう。まずはなぜこれらの関数にこんな名前がつけられたのかを知る必要がありそうです。&lt;a class="link" href="https://kotlinlang.org/docs/reference/scope-functions.html" target="_blank" rel="noopener"
>公式の説明&lt;/a>だと、以下のように述べています。&lt;/p>
&lt;blockquote>
&lt;p>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions.&lt;/p>
&lt;/blockquote>
&lt;p>要するに、特定のオブジェクトに範囲(Scope)を限定し、Lambdaで書かれた関数を実行させたい場合に使えるもののようです。もちろん、これは全く新しい形の関数ではありません。形(コードの書き方)としては、オブジェクトの関数を呼び出しているだけのように見えるだけですね。しかし、コードをみてみると、コードブロックで警戒を作ることでより&lt;code>特定のオブジェクト&lt;/code>に限った処理であることが視覚的に、明確になります。例えば、以下のようなコードはどれもやっていることは同じですが、コードも読む側からすると処理を適用させる&lt;code>範囲&lt;/code>は後者の方が明確になりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Scope Functionなしのコード
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> john = Person(&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">20&lt;/span>, Gender.Male)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>john.doWarmingUp()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>john.startToRun()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Scope Functionのletを使った場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> john = Person(&lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">20&lt;/span>, Gender.Male).let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.doWarmingUp()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.startToRun()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="どう違う">どう違う？&lt;/h2>
&lt;p>上述した通り、コードの範囲を限定することで、処理の範囲が明確になるのが分かりました。しかし、これでScope Functionを使う準備は整ったかというと、そうでもないです。実はそれ以外でも考えなければならないところがあるのです。なぜなら、Scope Functionには&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" target="_blank" rel="noopener"
>with&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="_blank" rel="noopener"
>let&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="_blank" rel="noopener"
>run&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html" target="_blank" rel="noopener"
>also&lt;/a>の5つの関数が存在するからです。複数の関数が存在していることは、時と場合によって違う関数を選ぶ必要があるということでしょう。&lt;/p>
&lt;p>では、これらの関数は他と何が違うのでしょう。まず、考えられるのは仕様です。Scope Functionは、内部的には渡したLambdaを実行してその結果を返すこととなっています。だとすると、仕様としてはLambdaで扱うオブジェクトと戻り値の差だけとなります。Scope Functionには処理の対象となるオブジェクト(レシーバーと言います)と、Lambdaをまずパラメータとして渡すようになります。ここで渡したレシーバーへのアクセスをどう書くかと、処理後の戻り値がどうなるかがこの5つのScope Functionでそれぞれ違います。これをテーブルとして表すと、以下のようになります。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>関数名&lt;/th>
&lt;th>レシーバーのアクセス&lt;/th>
&lt;th>戻り値&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>with&lt;/td>
&lt;td>this&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>let&lt;/td>
&lt;td>it&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>apply&lt;/td>
&lt;td>this&lt;/td>
&lt;td>T&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>run&lt;/td>
&lt;td>this&lt;/td>
&lt;td>最後の結果&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>also&lt;/td>
&lt;td>it&lt;/td>
&lt;td>T&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>また、withを除いた他の4つの関数たちは、&lt;a class="link" href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener"
>Extension Function&lt;/a>でもあるという特徴があります。 Extension Functionは何か？というと、簡単に、既定のクラスに関数を追加することです。Javaだとクラスの継承やラッパークラスの作成、オーバーライドなどで実現できる機能ですが、Kotlinでは簡単に定義できます。&lt;/p>
&lt;p>「Scope FunctionなのにExtension Functionでもあると？」と思うかも知れませんが、理由は簡単です。クラスの作成時に関数として定義してなくても、もともとそのクラスにあったかのように呼べる関数だから、ということです。どのオブジェクトでも、宣言しなくてもwithを除いたScope Functionをあらかじめ宣言しておいたかのように使うことができます。&lt;/p>
&lt;h3 id="参考itとthis">参考：itとthis&lt;/h3>
&lt;p>&lt;code>it&lt;/code>は、パラメータが一つのみのLambdaで使われるものです。例えばJavaだと、パラメータが一つだとしても、&lt;a class="link" href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener"
>Method Reference&lt;/a>を使わない限り以下のように書く必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> names &lt;span style="color:#ff79c6">=&lt;/span> List&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">of&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;john&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">,&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;jack&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Predicateの引数は一つだけだが、
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>Optional&lt;span style="color:#ff79c6">&amp;lt;&lt;/span>String&lt;span style="color:#ff79c6">&amp;gt;&lt;/span> filtered &lt;span style="color:#ff79c6">=&lt;/span> names&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">stream&lt;/span>&lt;span style="color:#ff79c6">().&lt;/span>&lt;span style="color:#50fa7b">filter&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>name &lt;span style="color:#ff79c6">-&amp;gt;&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;john&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">.&lt;/span>&lt;span style="color:#50fa7b">equals&lt;/span>&lt;span style="color:#ff79c6">(&lt;/span>name&lt;span style="color:#ff79c6">)).&lt;/span>&lt;span style="color:#50fa7b">findFirst&lt;/span>&lt;span style="color:#ff79c6">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Kotlinでは、同じ状況だとパタメータを省略して単純に&lt;code>it&lt;/code>として表現することができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">val&lt;/span> names: List&amp;lt;String&amp;gt; = listOf(&lt;span style="color:#f1fa8c">&amp;#34;john&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;jack&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// itでの省略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">val&lt;/span> filtered = names.first { &lt;span style="color:#ff79c6">it&lt;/span> &lt;span style="color:#ff79c6">==&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;o&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>結局、&lt;code>this&lt;/code>と同じではないか？と思いがちですが、&lt;code>it&lt;/code>はLambdaのぱらめーたにスコープが限定されて、&lt;code>this&lt;/code>のスコープはローカルでもグローバルでもなれるという点が違います。なぜなら、&lt;code>this&lt;/code>はレシーバーそのものを指していて、パラメータがない場合はLambdaのスコープの外を指すことになるからです。つまり、パラメータのないLambdaではitを使えないですが、thisは使えるということになります。&lt;/p>
&lt;h2 id="いつ使う">いつ使う?&lt;/h2>
&lt;p>では、Scope Functionに5つの関数があり、それぞれどう違うかがわかったので、次はそれぞれをどう使い分けるか知りたいですね。さまざまな意見があったので、(自分の)納得の行くもので整理してみました。&lt;/p>
&lt;h3 id="with">with&lt;/h3>
&lt;p>&lt;code>with&lt;/code>はExtension Functionではないので、オブジェクトをパラメータとして受け取る一般的な関数として使えます。このような特徴があるので、複数のオブジェクトで同じような処理を行う必要があるときに使えます。例えばforループの中で、わざとメソッドを分離したくない(命名がめんどくさいとか…)の場合に使えるでしょう。また、やはりScope Functionなので、処理の範囲を明確に区分するためにも使えそうですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">for&lt;/span> (name &lt;span style="color:#ff79c6">in&lt;/span> names) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> with(name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">var&lt;/span> rev = &lt;span style="color:#ff79c6">this&lt;/span>.reversed()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reversedName.add(rev)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="let">let&lt;/h3>
&lt;p>オブジェクトをトリガーにして、そのオブジェクトを持って何かの処理を行いたい場合に使うものです。&lt;code>let&lt;/code>の意味通り、そのオブジェクトを持って何かをするというイメージですね。また、戻り値も最後の結果となるので、それを持ってまた何かができそうです。また、&lt;a class="link" href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls" target="_blank" rel="noopener"
>Safe Call&lt;/a>な使い方ができるため、Nullではない場合のみの動作として指定することも可能です。なのでNullになり得るオブジェクトでは、&lt;code>let&lt;/code>を使った方が良いでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> name: String? = &lt;span style="color:#ff79c6">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#ff79c6">?.&lt;/span>let { println(&lt;span style="color:#f1fa8c">&amp;#34;name is not null&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="apply">apply&lt;/h3>
&lt;p>Lambdaでレシーバーの関数を使わず、レシーバーそのものを返却する場合に使います。つまり、レシーバーのプロパティに新しい値を入れる場合のことです。代表的にはオブジェクトの初期化がありますね。もちろん初期化だけなら、コンストラクタを呼ぶだけで十分ではないかと思われますが、同じオブジェクトの値を入れ替える(例えばConfigurationクラスなど)場合に役立つらしいです。例えば以下のような場合を考えられます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">if&lt;/span> (devMode) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SomeConfig().apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#f1fa8c">&amp;#34;devMode&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="run">run&lt;/h3>
&lt;p>他の4つの関数で事足りるので、なるべくこれは使わないように、という話が多いです。確かに、runはノーマルな関数としても使えるので(&lt;code>run {}&lt;/code>)、&lt;code>with&lt;/code>との違いがいまいちわからない感覚ではありますね。あえて使う場合は、オブジェクトの値をオーバーライドする時だそうです。でも、これも&lt;code>let&lt;/code>でできるので、あえて使う必要はなさそうです。多くのケースで、これは推奨されてませんでした。&lt;/p>
&lt;p>ただ、一部ではオブジェクトの初期化として使うと便利と言ってました。確かに&lt;code>this&lt;/code>を使うので、少しながら&lt;code>it&lt;/code>を使う&lt;code>let&lt;/code>よりコードが短くなり得るというメリットはありますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// runを使うばあい
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> result1 = server.run {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> port = &lt;span style="color:#bd93f9">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;/members:&lt;/span>&lt;span style="color:#f1fa8c">$port&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// letを使う場合
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> result2 = server.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">it&lt;/span>.port = &lt;span style="color:#bd93f9">8081&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;/members:&lt;/span>&lt;span style="color:#f1fa8c">${it.port}&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="also">also&lt;/h3>
&lt;p>オブジェクトがトリガーとなり、そのオブジェクトとは関係のない別の処理を行います。なので、元のオブジェクトがNullであっても、そのオブジェクトが呼ばれた時点でなんらかの処理を行うことができます。これを応用すると、条件分岐(三項演算子)のように使うことも可能です。例えば、こんな感じですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> name: String? = &lt;span style="color:#ff79c6">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name&lt;span style="color:#ff79c6">?.&lt;/span>let { println(&lt;span style="color:#f1fa8c">&amp;#34;name is not null&amp;#34;&lt;/span>) } &lt;span style="color:#ff79c6">?:&lt;/span> also { println(&lt;span style="color:#f1fa8c">&amp;#34;name is null&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="まとめ">まとめ&lt;/h3>
&lt;p>&lt;a class="link" href="https://medium.com/@brijesh1794/kotlin-standard-library-let-run-also-apply-with-bb08473d29fd" target="_blank" rel="noopener"
>Kotlin Standard Library (let, run also, apply, with)&lt;/a>では、5つのScope Functionのどれを使うか判断する基準を、フローチャートとして提示しています。以下は、そのフローチャートを簡単に翻訳したものです。どれを使うか悩ましい時は、こういう基準でコードを書いても良さそうですね。&lt;/p>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 289;
flex-basis: 694px"
>
&lt;a href="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function.png" data-size="3483x1203">
&lt;img src="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function.png"
width="3483"
height="1203"
srcset="https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function_huab2beb07c4d5efa7f99c84d4bdefc40b_237742_480x0_resize_box_3.png 480w, https://retheviper.github.io/posts/kotlin-scope-function/kotlin_select_scope_function_huab2beb07c4d5efa7f99c84d4bdefc40b_237742_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Kotlin Select Scope Function">
&lt;/a>
&lt;figcaption>Kotlin Select Scope Function&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="応用">応用&lt;/h2>
&lt;p>Scope Functionが戻り値としてレシーバーそのものを返すというのは、すなわちBuilderパターンとして使えるという意味でもあります。なので、適切な組み合わせで、Scope Functionによるメソッドチェーンもできます。これをよく活用すると、かなり関数型的な感覚でコードを書くことができるでしょう。以下は、その例の一つです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// letの連鎖
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> three: Int = &lt;span style="color:#f1fa8c">&amp;#34; abc &amp;#34;&lt;/span>.let { &lt;span style="color:#ff79c6">it&lt;/span>.trim() }.let { &lt;span style="color:#ff79c6">it&lt;/span>.length }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// alsoの連鎖
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">var&lt;/span> jack: Person = Person(&lt;span style="color:#f1fa8c">&amp;#34;Jack&amp;#34;&lt;/span>, &lt;span style="color:#bd93f9">30&lt;/span>, Gender.MALE).also { println(&lt;span style="color:#ff79c6">it&lt;/span>.name) }.also { &lt;span style="color:#ff79c6">it&lt;/span>.doWarmingUp() }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>実は、このようなKotlinの機能は、そう新しいものでもありません。なぜなら、同じJVM言語であり、同じく機能する&lt;code>with()&lt;/code>のような関数を提供している&lt;a class="link" href="http://groovy-lang.org" target="_blank" rel="noopener"
>Groovy&lt;/a>があるからです。自分の中では&lt;a class="link" href="http://spockframework.org" target="_blank" rel="noopener"
>Spock&lt;/a>かGradleのイメージしかないのですが…&lt;/p>
&lt;p>ただ、このようにKotlinが提供する機能は「新しくはないけど、快適」という感覚を確かに伝えてくれているような気がします。なのでJavaプログラマーがKotlinに転向していく数も増えているのでしょう。最近は特にPythonやJavaScriptのような言語が人気を得ているところですが(Kotlinは&lt;a class="link" href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener"
>TIOBE&lt;/a>の順位からだと見えもしないし…)、もっと性能と安定性、そして快適な開発のバランスを持ちたいと思う人にはぜひおすすめしたい言語です。なのでもっと、Kotlinの魅力をより多くの人(自分を含め)にわかった欲しいところです。今回のポストで少しはそれが伝わると幸いですね。&lt;/p>
&lt;p>では、また!&lt;/p></description></item><item><title>JavaプログラマーがみたKotlin</title><link>https://retheviper.github.io/posts/kotlin-first-impression/</link><pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/kotlin-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/kotlin.jpg" alt="Featured image of post JavaプログラマーがみたKotlin" />&lt;p>KotlinがAndroidの公式言語になってからもだいぶ長い時間が経ちましたが、まだまだWebアプリケーションの業界ではサーバサイド言語としてはJavaを使う企業も多く(自分の場合がそうです)、モバイル業界でもJavaを使うところが多いようです。Javaも9以降はアジャイル開発でバージョンアップにスピードを出していて、いわゆるモダンな言語の特徴を吸収していってますが、そもそもの言語のデザインが古いし、互換性のために昔ながらの名残を捨てられてないところもあるので根本から違う哲学でデザインされた言語とはかなり違うはずです。また、JVMを利用しない&lt;a class="link" href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener"
>Kotlin Native&lt;/a>も発表されているので、今後Javaよりも活躍できる場面が多いかも知れないなーという気がしたりもします。(&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>は使われることあるのかな…)&lt;/p>
&lt;p>取りまとめ、まだ正式の研修とかを受けたわけでなく、あくまでSpring WebFluxを使って簡単なアプリを作ってみるついでに使ってみただけなので、よくわかってない部分も多いかと思いますが、今まで触れてみた感想をJavaプログラマーの観点から簡単に紹介したいと思います。&lt;/p>
&lt;h2 id="これがよかった">これがよかった&lt;/h2>
&lt;p>まずは使ってみてよかったところから。結論からとなりますが、良いと思ったところはおおよそイメージ通り(期待してた通り)という感覚です。&lt;/p>
&lt;h3 id="やはりモダンな感じ">やはりモダンな感じ&lt;/h3>
&lt;p>Kotlinで書いたコードを見ると、モダンな言語だとやはりこんなものかなという感覚ではあります。モダンな言語が何か、という定義から必要になるのではという気もしますが、例えばSwift、Kotlin、Goみたいなものですね。あまり他の言語に詳しいわけではないのですが、これらの言語はなんとなくPythonに似ているような気がします。例えば&lt;code>var&lt;/code>、&lt;code>fun&lt;/code>のように基本文法で略語をよく使っていたり、型の指定はコロンの後につけたり、セミコロンがなかったり、&lt;code>in&lt;/code>や&lt;code>Range&lt;/code>、&lt;code>is&lt;/code>があるなどの共通点があったりしますので。他には、言語の使用ではないけど、一般的にはGetter/Setterを使わずフィールドに直接アクセスするところですかね。(おかげでLombokを使う必要がないのも便利ではあります)&lt;/p>
&lt;p>ただ、そんなモダンな感覚でありながらも、やはりKotlinはJavaよりな感覚ではあります。厳格なJavaをよりゆるくしただけの感覚といえばいいでしょうか。例えばPythonだと&lt;code>elif&lt;/code>なのですが、Kotlinでは&lt;code>else if&lt;/code>だったりしますので。JVM言語という理由だけでなく、基本文法からしてもJavaプログラマーならすぐに適応できる言語でもあります。例えばforループにラベルをつけることができたりします。&lt;/p>
&lt;p>あえてJavaとの比較をするとしたら、やはり冗長さを省けただけでなく、Javaという言語のデザインを根本的に変えようとしている気もしていました。例えばNullや、Mutableを扱う方式がそうです。Kotlinでは基本的に変数はNullになれなくて、Nullになれるオブジェクトは最初からそうであると宣言する必要があり、Nullになれるオブジェクトを扱う時もSafe Callを強制することでNullに対してはコンパイラレベルではできるだけサポートしている感覚です(おそらくこれはモダンな言語だと全部がそうですが)。そしてCollectionなどを宣言する時も、あえてMutableという宣言をしない限りは基本的にImmutableなオブジェクトが生成されます。これだけでもJavaでもっともよく見つかるNPEをよく避けられる気がしてしまいます。いちいち宣言して、コールもクエスチョンマークをつける必要があるのは面倒臭いことな気もしますが、コンパイルエラーの方がランタイムエラーよりはずっとマシだというのは我々みんなが知っていることではないでしょうか。&lt;/p>
&lt;p>あとは、個人的にPythonで使ってみてよかったなと思った機能がKotlinにもあってよかったです。例えばMultiple Return(複数の戻り値)だったり、Named argument(名前付き引数)があります。前者は特に、Pair/Tripleという型で明確な戻り値を提示できるのが素晴らしいと思います。こういうところはモダンながらも、Javaの持つ安定性もしくは丈夫さを捨ててなかったなという印象を与えてくれました。&lt;/p>
&lt;p>ただ、これらのメリットは最近のJavaもかなり近づいている状態ではあります。(まだ少し遅い感はありますが)&lt;/p>
&lt;h3 id="クラスファイルではない">クラス=ファイルではない&lt;/h3>
&lt;p>Javaの場合は、一つのファイルには一つのクラスというのが常識のようになっています。もちろんInner Classを書く場合もありますが、それだと名前とおりクラスの中に含まれたものになるので、インスタンスを生成するときに複雑だったりしますね。でもKotlinだと、純粋なクラスを一つのファイルに複数書くことができます。&lt;/p>
&lt;p>なので、似たようなクラスを一つのファイルの中に集めておくことができますね。例えばDTO、DAO、Entityなど似たようなクラスが複数損際するパターンでは、一つのファイルの中にそれらを集めておいた方がパッケージの中が複雑にならないような気がします。実際、Kotlinを試しながら好みの領域の話かも知れませんが。&lt;/p>
&lt;p>どちらかを選択できる自由があるというのが、必ずしも良いこととは言い切れませんが、ファイル内にクラスを複数書くかどうかはキメの問題であって実装時のコーディングスタイルに影響を与えるものではないので(今時importを直接書く人もいないだろうし…)、良い点として挙げられるのではないか、と思います。&lt;/p>
&lt;h3 id="拡張関数で自由に関数を追加できる">拡張関数で自由に関数を追加できる&lt;/h3>
&lt;p>Javaのデメリットとしてよく挙げられているのが、冗長すぎる(verbose)ということです。いわゆるBoilerplateなコードを毎回書かなくてはならないというのは、生産性の面からもよくないです。Javaにこういう面があるので、さまざまなデザインパターンが発達したり、IDEでコードを自動生成してくれたり、Lombokのようにコードの量を減らしてくれるライブラリが人気だったりしますね。自分が開発に参加したフレームワークの開発の案件も、結局は冗長化するコードを減らしたいという目的によるものでした。&lt;/p>
&lt;p>とにかく、Kotlinはこういう問題に対する反発ないしは反省から言語がデザインされているようにも見えます。最近のモダンな言語の特徴をコピーしただけでなく、Javaを改善させたいという強い意志が言語のデザインから感じ取れているような感覚でした。&lt;/p>
&lt;h3 id="スタンダードライブラリがとにかく便利">スタンダードライブラリがとにかく便利&lt;/h3>
&lt;p>拡張関数が便利な理由ともつながるようなことですが、Kotlinのスタンダードライブラリに存在する関数たちもまた同じ観点から便利といえます。例えば、すでに有名なのがいわゆる&lt;code>Scope Functions&lt;/code>の&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html" target="_blank" rel="noopener"
>let&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html" target="_blank" rel="noopener"
>with&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html" target="_blank" rel="noopener"
>apply&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html" target="_blank" rel="noopener"
>run&lt;/a>、&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html" target="_blank" rel="noopener"
>also&lt;/a>のような関数です。&lt;/p>
&lt;p>これらはJavaだと別途ユーティリティクラスを作るか、プライペートなメソッドを定義するか、特定のクラスを継承してからオーバライドで関数を新しく定義するなどの方法で対応はできるものの、やはり手間がかかるのでやりたくはないものです。これをKotlinでは、より関数型的な方法で解決してくれます。例えばletの例を見ていきましょう。以下のようなdata classがあるとします。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">Member&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> region: String, &lt;span style="color:#ff79c6">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このdata classのインスタンスを一つ作成します。そうすると以下のようになるでしょう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> john = Member(&lt;span style="color:#f1fa8c">&amp;#34;Tokyo&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとで、同じくMemberのインスタンスとしてjakeという変数を追加するとします。jakeは常にjohnと同じregionである必要があります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> jake = Member(&lt;span style="color:#f1fa8c">&amp;#34;Tokyo&amp;#34;&lt;/span>, &lt;span style="color:#f1fa8c">&amp;#34;Jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをJavaの考え方で、コードを整理するとしたら以下のようになります。regionを同じインスタンスを使うようにすることですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> tokyo = &lt;span style="color:#f1fa8c">&amp;#34;Tokyo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> john = Member(tokyo, &lt;span style="color:#f1fa8c">&amp;#34;John&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> jake = Member(tokyo, &lt;span style="color:#f1fa8c">&amp;#34;Jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これをletを使う場合のコードとして書くと、以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> jake = john.let {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Member(&lt;span style="color:#ff79c6">it&lt;/span>.region, &lt;span style="color:#f1fa8c">&amp;#34;jake&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>共通のregionを別途変数として宣言したくても、jakeのregionはjohnに指定したregionと同じ値となります。そしてある意味、こちらの方が「johnとjakeは同じregionを共有する」という意図がコードの中によく表れているのではないか、という気もします。今は簡単なフィールドを共有しているだけですが、変数の数が増えたり処理すべき項目が多くなった場合はいちいち定数を宣言するよりも、このような書き方の方がより優雅になるのではないか、と思います。そういう意味では、かなり洗練された方法を提供していますね。同じことをJavaでまねるとしたら…あまりやりたくなくなりそうです。&lt;/p>
&lt;h2 id="これはいまいち">これはいまいち&lt;/h2>
&lt;p>KotlinがJavaのさまざまな問題や不便さに注目し、それらの多くを解消してくれたのは事実ですが、果たして&lt;code>全て&lt;/code>Javaより発展しているか、というとそうでもないような気もします。ただし、ここであげているKotlinの問題点ないしデメリットは、メリットと同様、個人的な見解なので参考までに。&lt;/p>
&lt;h3 id="varと型">varと型&lt;/h3>
&lt;p>モダンな言語から接した人なら、変数の宣言が&lt;code>var&lt;/code>だけで集結するのはメリットと言いたくなるかも知れません。実際Kotlinだけでなく、JavaScriptやC#など現代に使われる大体の言語は&lt;code>var&lt;/code>に対応していて、あのJavaすらも10から&lt;code>var&lt;/code>による変数の表記を導入しています。また、Pythonのようにそもそも&lt;code>var&lt;/code>の宣言すらいらない言語があったりもしますね。&lt;code>var&lt;/code>をつけることで変数であることが明確だという考え方から来てるのか、Javaとは違って関数も&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88" target="_blank" rel="noopener"
>First Class Object&lt;/a>として扱う言語としては関数と同様に表記したいからそうしてるのか、よくわかってないのですが、どっちかというと流行りのもののようです。&lt;/p>
&lt;p>こういう傾向だけを見ると、「変数は変数であることが分かればいい」というだけの話になっているようにも思えます。しかし、私はこの&lt;code>var&lt;/code>が果たして良いものであるかという疑問を持っています。Javaに慣れすぎていて、新しいのを受け入れられてない、もしくは&lt;code>var&lt;/code>の良さをわかってないだけかも知れませんが、とにかく「型指定で変数であることも、型もわかるからこっちの方が良くないか」と思ってしまいます。&lt;/p>
&lt;p>こう思うまたの理由は、モダンなプログラミング言語の中でもTypeScriptのように、あえて型指定ができるように既存の言語を変えようとする動きもあるからです。Pythonの場合も3.6から型を宣言できるようになっています。これ自体が、「変数は変数であることが分かればいい」から「変数の型もわかった方がいい」に変わっているように見えます。ただ、問題は最初から型指定で変数を指定する方法がなく、&lt;code>var&lt;/code>しかない言語に型指定(型注釈)が付く場合です。&lt;code>var&lt;/code>のメリットである短くかけるというところが、型指定をすることで台無しになります。&lt;/p>
&lt;p>例えば、Kotlinでの&lt;code>var&lt;/code>だけの宣言だと以下のようになりますね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> a = &lt;span style="color:#f1fa8c">&amp;#34;this is string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして&lt;code>var&lt;/code>に型を指定すると以下のようになります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">var&lt;/span> b: String = &lt;span style="color:#f1fa8c">&amp;#34;this is string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Javaの伝統的な書き方だと以下です。こちらの方が、むしろコードは短くなるし、変数であることも明確ではないでしょうか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String a &lt;span style="color:#ff79c6">=&lt;/span> &lt;span style="color:#f1fa8c">&amp;#34;this is string&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、厳密にいうと変数ではないところでは&lt;code>var&lt;/code>をつけないのは当たり前なのかも知れませんが、Javaだと変数でも戻り値でも引数でも型をつけてしまうのに対して、Kotlinではこれらに&lt;code>var&lt;/code>をつけるか型をつけるか方が省略できるかという場面がそれぞれ区別されてしまうので、これだけはJavaよりも厳格じゃないか？という気になったりもします。例えば以下のような例です。&lt;/p>
&lt;p>関数の引数の場合は、型の指定が必要です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>(request: ServerRequest): Mono&amp;lt;ServerResponse&amp;gt; =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(MediaType.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#ff79c6">it&lt;/span>.username, &lt;span style="color:#ff79c6">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>そして関数の戻り値は、型推論により省略可能です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>(request: ServerRequest) =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(MediaType.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#ff79c6">it&lt;/span>.username, &lt;span style="color:#ff79c6">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし、これはあくまで関数をSingle Expressionで書いた時の話です。明示的にreturnを書く場合は戻り値を省略するとコンパイルエラーになります。例えば以下のような場合がそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// これはコンパイルエラー(戻り値はUnitとなってしまう)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getMember&lt;/span>(request: ServerRequest) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .contentType(MediaType.APPLICATION_JSON)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .body(repository.findById(request.pathVariable(id).toLong()).map { MemberDto(&lt;span style="color:#ff79c6">it&lt;/span>.username, &lt;span style="color:#ff79c6">it&lt;/span>.name) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .switchIfEmpty(notFound().build())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、data classの場合はフィールドに&lt;code>val&lt;/code>か&lt;code>var&lt;/code>をつける必要があります。しかし、一般的なクラスを宣言する場合は要りません。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// data classではvalかvarが必要
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">data&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MemberDto&lt;/span>(&lt;span style="color:#ff79c6">val&lt;/span> username: String, &lt;span style="color:#ff79c6">val&lt;/span> name: String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// classなら必要ない
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">MemberEntity&lt;/span>(username: String, name: String)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通常はコンパイルエラーになるので、慣れるまではKotlinのルールに従ってコードを見直すしかないのですが、Javaからの入門だとかなり混乱する部分です。(自分だけかも知れませんが…)&lt;/p>
&lt;h3 id="依存関係">依存関係&lt;/h3>
&lt;p>プロジェクトにKotlinを使う場合はスタンダードライブラリを追加して使う必要があります。ただ、ここで&lt;code>kotlin-stdlib&lt;/code>だけを追加すると、Java 1.7以降に追加された一部の機能(AutoCloseableなど)を使えなくなります。なので、Java 1.7以降の機能を使いたい場合は&lt;code>kotlin-stdlib-jdk7&lt;/code>か&lt;code>kotlin-stdlib-jdk8&lt;/code>を依存関係に追加する必要があります。&lt;/p>
&lt;p>個人的にはOracleとGoogleの訴訟沙汰のようなことがあって、わざと著作権を避けるための独自のパッケージを作ったりしらからではないかなと思いましたが、実際はJava 9から導入されたModuleシステムに対応するための理由だそうです。なので&lt;code>kotlin-stdlib-jre7&lt;/code>が&lt;code>kotlin-stdlib-jdk7&lt;/code>に、&lt;code>kotlin-stdlib-jre8&lt;/code>が&lt;code>kotlin-stdlib-jdk8&lt;/code>に代替されたらしいですね。&lt;/p>
&lt;p>とにかく、これらのスタンダードライブラリを使うには、MavenやGradleのような依存関係を管理するパッケージマネージャを使って一回だけ登録しておけばよく、そこまでめんどくさくはないことなのかも知れませんが、例えば&lt;code>kotlin-stdlib-jre8&lt;/code>があったりするので、初めはどれを選べば良いか、どれが必要であるかを把握するのにも時間を使ってしまうことになるのでデメリットになるのではないかと思います。例えば&lt;code>kotlin-stdlib-jdk7&lt;/code>がなくても、AutoCloseable以外のJDK 1.7の機能は使えたりするのですが、今から作るプロジェクトや既存のプロジェクトにAutoCloseableが使われるかどうかで依存関係をまた追加するかどうかを調べるのもかなり面倒くさそうです。&lt;/p>
&lt;p>そしてJDK7やJDK8対応のスタンダードライブラリが別途存在するということは、今後JavaがバージョンアップしたらまたJDK 17などの新しいスタンダードライブラリが追加される可能性があるということでもあるでしょう。7(1.7)と17はよく勘違いしそうだし…あと、JDK以外の依存関係のパッケージが色々あるので(&lt;code>kotlin-reflect&lt;/code>など)、プロジェクトの構成によってはKotlinの導入にはかなり慎重になる必要がありそうです。ある意味、KotlinがPost Javaとしてのポテンシャルは十分でありながらも、Androidアプリの作成以外にではあまり導入されてないのはこのような理由もあるのではないかという気もしています。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>簡単にPros・Consに分けて自分が感じたKotlinに対して書いてみました。実はまだ本格的な案件で触れてみたわけでもないので、&lt;a class="link" href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="noopener"
>Type aliases&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/docs/reference/inline-classes.html" target="_blank" rel="noopener"
>inline class&lt;/a>のような良さそうな機能に触れてもないです。でもやはり、使えば使うほど魅力的な言語であるなと感じているところです。なので個人的な意見としては、すでにJavaを使っているところなら本格的にKotlinへの移行を考慮しても良いのでは、と思っています。Javaプログラマーなら慣れやすく、より生産性も高いながら、Javaとの100%の互換性も担保されているので…言語の完成度やJVM対応でありながらNative、JavaScriptとの連動も可能なのを見るとまさにPost Javaとして相応しい言語なのではないかと思うくらいです。(他のJVM言語には悪いですが…)&lt;/p>
&lt;p>そういう意味で皆さん、今からでもKotlinやりませんか！&lt;/p></description></item></channel></rss>