<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>recent on Korean-man in Tokyo</title><link>https://retheviper.github.io/categories/recent/</link><description>Recent content in recent on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 06 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/categories/recent/index.xml" rel="self" type="application/rss+xml"/><item><title>今年のブログの話</title><link>https://retheviper.github.io/posts/renew-blog/</link><pubDate>Sun, 06 Feb 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/renew-blog/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.jpg" alt="Featured image of post 今年のブログの話" />&lt;p>すでに気づいている方もいらっしゃるかと思いますが、2年ぶりにブログのテーマを変えました。正確にはテーマだけでなく、静的ページ生成ツールを&lt;a class="link" href="https://jekyllrb.com/" target="_blank" rel="noopener"
>Jekyll&lt;/a>から&lt;a class="link" href="https://gohugo.io/" target="_blank" rel="noopener"
>Hugo&lt;/a>に変えました。こういうのが気軽にできるので、最初からブログをGithub Pagesで公開したことは本当によかったなと今は思っています。&lt;/p>
&lt;p>サイトの生成ツールを変えたことで各ポストのURLにも変化があり、もしお気に入りなどに設定しておいた方には申し訳ないことをしましたが、それを踏まえても改善できたところが多いと思いますので、ご了承ください。&lt;/p>
&lt;p>さて、今回はそんなブログの刷新に関する話となりますが、大きくわけて「ブログがどう変わったか」と「これからブログでやっていきたいこと」について述べさせていただきたいと思います。&lt;/p>
&lt;h2 id="uxの改善">UXの改善&lt;/h2>
&lt;p>UXの観点で改善されたことは、ブログ刷新での第一順位の目標でもありました。他にも色々とあるかと思いますが、まずは以下のようなものがあります。&lt;/p>
&lt;h3 id="画面遷移の改善">画面遷移の改善&lt;/h3>
&lt;p>以前のブログはメインから個別のポストに遷移するときにアニメーションが含まれていました。（ポスト一覧を表示するところでも同じものが使われていました）画面遷移時にアニメーションを入れるというのはもうトレンドとしては古いものでもあり、何より画面遷移が遅いような感覚があるので改善したかったです。なので、今回は反応が早くしてみました。&lt;/p>
&lt;h3 id="検索機能">検索機能&lt;/h3>
&lt;p>タグとカテゴリ、そしてアーカイブがあれば十分かなと思いましたが、キーワードでポストを探したい時もありますね。以前は検索機能を付けようとしてもうまくいかなかったので、ちゃんと検索のできるテーマを採用しました。&lt;/p>
&lt;h3 id="デザイン">デザイン&lt;/h3>
&lt;p>個人的にはダークモードが好きで、全体的に黒いテーマを選ぼうかなと思いましたが、幸いボタンを押すだけでダークモードへの転換ができるテーマがあったので、こちらを選びました。もっと良いのは、このダークモードはシステムの設定と連動されるということです。なので、ダークモードが好みではない場合は白い画面を見ることができます。一つ残念なのは、コードブロックのスタイルはまたブログとは別ということですが…これはのちに何か方法があったら対応したいと思います。&lt;/p>
&lt;p>他には、モバイル画面でもちゃんと画像が見えたり、メニューやレイアウトなども色々とモダンなデザインになったのが嬉しいところです。&lt;/p>
&lt;h3 id="ポスト表示">ポスト表示&lt;/h3>
&lt;p>以前はポストの一覧から、ポストの画像をクリックするとそのポストの詳細画面に遷移するのではなく、画像が拡大されるという問題があ理ましたがそれを改善できました。そしてポストごとに読みにかかる大まかな時間を表示できるようになったので、記事を読まれる方にもどれを読むか参考するに良い情報を提供できているかと思います。&lt;/p>
&lt;h2 id="内部的な変化">内部的な変化&lt;/h2>
&lt;p>さて、今までは主にUXの観点からの話でしたが、実は上記で挙げた項目は単純にJekyllのテーマを変えるだけでも対応ができるものでした。それをあえてHUGOに変えてまでブログの刷新を追求した理由を今から話したいと思います。&lt;/p>
&lt;h3 id="管理がしやすい">管理がしやすい&lt;/h3>
&lt;p>Jekyllの場合、一つのテーマがRubyで書かれた一つのアプリを扱うようなものだったので、Gemfileの依存関係のアップデートが必要だったり、ローカルでサーバを起動するまで時間がかかったり、テーマを変えるたびに色々と設定や構成をいじる必要がありました。HUGOの場合、そのような問題はほとんどありませんでした。テーマはGithubのリポジトリをサブモジュールとしてインポートすることができて、あとはコンテンツと基本的な設定をいじるだけです。なので、実際に時間がかかったのは添付画像などリソースのパスが変わったための対応などを除くと、1時間ほどだったような気がします。&lt;/p>
&lt;p>また、以前は画像が一つのフォルダに集約されていたため、ポストの添付する画像を管理するのががかなり面倒臭い作業でしたが、今はポストごとに別フォルダを使用していて、そのフォルダに画像を入れるだけなので管理がより簡単になりました。なので、今後は画像の添付も以前よりは積極的にやっていこうと思います。&lt;/p>
&lt;p>HUGOはGoで書かれてあるため、ローカルでサーバを起動するのが早いのも良いところです。&lt;/p>
&lt;h3 id="カスタマイズが楽">カスタマイズが楽&lt;/h3>
&lt;p>以前は自動でRSSフィードを作ってくれる機能があるものの、全体のポストが対象となっていませんでした。テーマやJekyllの設定をいじれば解消できる問題だったとは思いますが、前述した通り、テーマが一つのアプリのようなものなので、カスタマイズが簡単ではありません。それに比べ、HUGOはより単純なものとなっていてテーマや設定のカスタマイズも簡単にできます。今もメニューは元々テーマの設定を変えるだけでカスタマイズできるものもありますが、一部は自分の方で修正したものもあります。どれも時間があまりかからなく、すぐにできるのが魅力的でした。&lt;/p>
&lt;p>&lt;a class="link" href="https://gohugo.io/content-management/shortcodes/" target="_blank" rel="noopener"
>shortcode&lt;/a>でHTMLとJavaScriptの添付をテンプレート化できるのも個人的にはHUGOの魅力ではないかと思います。使い勝手がいいので、色々と活用できそうなところが多いですね。&lt;/p>
&lt;h2 id="これからは">これからは&lt;/h2>
&lt;p>ブログの生成ツールを変えて物理的に良くなったところの話ができたので、次はそのブログで何をしていきたいかを述べたいと思います。&lt;/p>
&lt;p>最初は意欲も溢れていて、さまざまな技術に触れてそこで自分が学んだことや感じたこと、そして試行錯誤など多彩な記事を書いていたと思います。今振り返ってみると「当時の自分はこんなにもわかってないものが多かったのか」と、恥ずかしくなる瞬間もありますが、少なくとも今よりはもっと力を入れていた気がします。&lt;/p>
&lt;p>個人的に、このブログの更新は少なくとも月に2回を目指しているのですが、気持ちだけが先走ってあまり読む価値のないポストもいくつか書いてきたのではないかと反省しています。&lt;/p>
&lt;p>なので、今年はいくつかの技術を実際使ってみるという目標をたて、それらに関する記事を書いていきたいと思います。今のところは以下のようなものを考えています。&lt;/p>
&lt;h3 id="jetpack-compose">Jetpack Compose&lt;/h3>
&lt;p>新年の目標としても挙げていたものですが、実は去年から少しづつ触っている状態で、今年は実際にAndroidとデスクトップアプリケーションを作ってみたいと思っています。ちょうど去年は&lt;a class="link" href="https://www.jetbrains.com/ja-jp/lp/compose-mpp/" target="_blank" rel="noopener"
>Compose Multiplatform&lt;/a>も正式リリースしているので、時期的にちょうどいいかと思います。&lt;/p>
&lt;p>SwiftUIの方も、&lt;a class="link" href="https://developer.apple.com/documentation/Xcode/About-Continuous-Integration-and-Delivery-with-Xcode-Cloud" target="_blank" rel="noopener"
>XCode Cloud&lt;/a>の発表や&lt;a class="link" href="https://developer.apple.com/support/unlisted-app-distribution/" target="_blank" rel="noopener"
>リンクでのアプリ公開が可能になったり&lt;/a>、&lt;a class="link" href="https://www.apple.com/jp/swift/playgrounds/" target="_blank" rel="noopener"
>Swift Playgrounds&lt;/a>でアプリのビルドが可能になったことにより興味を持っている状態ではありますが、まずは自分が仕事でKotlinを使っていて、Composeの方をある程度使いこなせるようになってから挑戦してみた方がいいかなと思っているところです。&lt;/p>
&lt;p>せっかくMacを使っているので、一度はSwiftでアプリを作ってみないとですね。&lt;/p>
&lt;h3 id="svelte">Svelte&lt;/h3>
&lt;p>会社の方では&lt;a class="link" href="https://nuxtjs.org/" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>を使っているので、こちらでも良いかと思いましたが、結局自分が画面を触ることになるのはプライベートでしかチャンスがない気がしたので、興味本意で選んだのが&lt;a class="link" href="https://svelte.dev/" target="_blank" rel="noopener"
>Svelte&lt;/a>です。&lt;/p>
&lt;p>まだ技術としては成熟したものではない気はしますが、そろそろ&lt;a class="link" href="https://kit.svelte.dev/" target="_blank" rel="noopener"
>Sveltekit&lt;/a>のようなものも登場していて、何よりも学習にかかる時間や効率を考えたときに、自分が画面を作るとしたら最も生産性が高くなりそうな技術だなと思いました。まぁ、これは実際触ってみないとわからないものですが…&lt;/p>
&lt;p>他に理由としては、&lt;a class="link" href="https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-web-frameworks" target="_blank" rel="noopener"
>Stackoverflow Survey&lt;/a>で最も愛されたウェブフレームワークに選定されたから、というのもあります。多くのエンジニアが好きという技術は、まずその理由が知りたくなりますので。（同じ理由で、Rustも触ってみたいと思っています）&lt;/p>
&lt;h3 id="quarkus">Quarkus&lt;/h3>
&lt;p>会社で使っているSpring bootのビルドとテスト、デプロイにかかる時間を短くしたいのですが、その対策としてQuarkusへの移行を考慮しています。稼働中のサービスのフレームワークを変えるということはかなりのリスキーなことではありますが、成功した場合は生産性も上がり起動速度やメモリのようなメリットがかなりでかい気がしているので、いつになるかはわかりませんが、ぜひ挑戦してみたいタスクとして設定しています。移行に成功しても失敗しても、色々と勉強になりそうではありますね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>ブログの外見は変わり、十分成功的な移行になったと思いますので、次はその中身を充実にしていくのが課題ですね。今まで通り、一人前のエンジニアになりたいという気持ちを忘れず、少しづつでも前に進むような（そして読まれる方にも役立つような）ポストを書けたらなと思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>個人的な2022年のロードマップ</title><link>https://retheviper.github.io/posts/my-roadmap-in-2022/</link><pubDate>Tue, 11 Jan 2022 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/my-roadmap-in-2022/</guid><description>&lt;img src="https://retheviper.github.io/images/map.jpg" alt="Featured image of post 個人的な2022年のロードマップ" />&lt;p>このブログを書き始めてから、今年で4年目となります。振り返ってみるとブログを書き始めた頃はSEとして主にSIerの基盤チームの仕事をしていたので、インフラやライブラリを含めさまざまな技術に触れることが多かったのですが、去年に転職をして本格的に業務系エンジニアとしてバックエンドを担当することになり触れる技術や興味などにも変化があったかなと思います。なので、今回は振り返りを兼ねて今年のロードマップに関して少し述べたいと思います。&lt;/p>
&lt;p>過去分のポストを振り返ってみると最初は主にJava、Spring、Linux、Jenkinsなどに関するものが多かったのですが、最近はやはりKotlinで使えるさまざまなフレームワークなどに興味が移っている感覚です。基本的にJavaでもKotlinでもJVM言語であることは同じなのでできることや分野は大差なく、転職してからも使っているフレームワークはSpringなのですが、Kotlinの開発元であるJetBrains社がいろいろなフレームワークを開発しているのもあり自然にそれらに興味を持つようになっていますね。&lt;/p>
&lt;h2 id="sophomore-jinxを克服する">Sophomore jinxを克服する&lt;/h2>
&lt;p>Sophomore jinxは日本語で「2年目のジンクス」といわれている言葉です。大学2年目になると新入生だった頃と比べ、成績が下がり熱意が消えるというということを指す言葉らしいです。これの意味を拡張して、1年目に新人王などに選ばれた選手がその次の年からは成績が悪化したり、人気の映画の続編が面白くなかったりする場合など最初より何か劣化した場合を指すことになっているとか。&lt;/p>
&lt;p>自分の場合はエンジニアになってから4年目になるのですが、確かに2年目からは1年目の時と比べ熱意はなくなっている気がします。だからと言って新しい技術に興味がなくなったり、プログラミング自体が飽きたという訳ではありませんが、前はやりたいことがあったらずっとモニタと睨めっこしながら徹夜でコードを書いたりしていたのに、今はとてもそういう気にならないというのが違うところですね。年を取ったためかとも思いますが、&lt;/p>
&lt;p>これについては自己分析とやりたいこと、そしてできることを冷静に整理して少しづつでも何か成果物を出せるようにしないと思っています。去年もそうでしたが、このようなポストを書くのはそのためでもあります。計画しているもの全てを成せるとは思いませんが、多くの目標の一部でも達成した方が最初から少ない数の目標を立てるよりは良いのかなという気がしています。なので、まずは「やるかどうかわからないけどアンテナは張っておく」という感覚でいろいろな技術に目を通しておこうかなと思っています。&lt;/p>
&lt;h2 id="frontend">Frontend&lt;/h2>
&lt;p>私はJavaScriptとTypeScriptの基礎を研修やUdemyの講座で学んだくらいのレベルで、フロントエンドの仕事をあまりやることがなかったです。しかし、昨今のウェブアプリの開発においてのトレンドをみるとやはりフロントエンドの技術を一つは学んでおいた方が良さげな気もしますし、バックエンドの役割を吸収しているような気配すらするなという気がしますね。何より、エンドユーザにとって画面のないアプリは想像できないので、今まで自分が使うためのAPIやライブラリ、コマンドラインアプリだけでなく本格的にGUIを活用した何かを作ってみるべき時が来たかなと思っています。&lt;/p>
&lt;p>何よりフロントエンドの場合、数年前はいろいろなライブラリとフレームワークが存在してどれを使った方がいいか全くわからない状況でしたが、最近は3強だといわれていた中でもAngularを抜いたReactとVueのみが生き残り、さらにそれらを基盤にしたフレームワークが登場するなど、そろそろ技術の成熟期と言ってもいい時代になったのではないかと思いますので、React基盤の&lt;a class="link" href="https://nextjs.org" target="_blank" rel="noopener"
>Next.js&lt;/a>か、Vue基盤の&lt;a class="link" href="https://nuxtjs.org" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>のどちらかを選べばよい時期なのではと思います。私自身も今年はそのうちのどちらかに触れてみたいなと思っています。&lt;/p>
&lt;p>せっかくなので&lt;a class="link" href="https://nestjs.com" target="_blank" rel="noopener"
>NestJS&lt;/a>のようなJavaScript用のサーバサイドフレームワークにも触れてみるのは良いかもしれませんが、サーバサイドというバックグラウンドがある自分にとってはまずはフロントエンドのみでちょうどよいチャレンジかなと思ったりもします。後述しますが、バックエンドではまた別に触ってみたいものもありますのでなおさらですね。&lt;/p>
&lt;h2 id="quarkus">Quarkus&lt;/h2>
&lt;p>個人的にはSpringを長く使っていたので、新しいフレームワークを使ってみたいという願望があります。一つのフレームワークに慣れると、それを使い続けるのも選択肢としては悪くないと思いますが、新しい技術にはメリットもデメリットもあるものなので、少なくとも触れてみる必要はあるかなと思います。なので去年は&lt;a class="link" href="https://quarkus.io" target="_blank" rel="noopener"
>Quarkus&lt;/a>と&lt;a class="link" href="https://ktor.io" target="_blank" rel="noopener"
>Ktor&lt;/a>の二つを触ってみました。&lt;/p>
&lt;p>個人的にはJetBrainsのプロダクトに信用を持っていて、Kotlin向けという点でもKtorは悪くなかったと思ったのですが、機能が不十分であるところや、アーキテクチャで悩ましいところがあるという面で躊躇しています。一方でQuarkusはネイティブにコンパイルでき、Springのライブラリを一部そのまま使えたり、そもそもSpringとあまり変わらない感覚でコードをサクサク書けそうなイメージなので本格的に使用してみたいと思っています。最大の問題はやはり、ネイティブの場合ビルドにかなり時間がかかるということですが、これはCIとの連携をうまくやっていくしかないかもしれませんね。&lt;/p>
&lt;h2 id="fastapi">FastAPI&lt;/h2>
&lt;p>いきなりPythonになりますが、&lt;a class="link" href="https://fastapi.tiangolo.com" target="_blank" rel="noopener"
>FastAPI&lt;/a>にも触れてみたいと思っています。以前から違う分野に転職をするとしてもバックエンドはやり続く可能性が高いと思い、いろいろな言語とフレームワークを触ってみたいと思っていました。その候補としては&lt;a class="link" href="https://expressjs.com/ja" target="_blank" rel="noopener"
>Express&lt;/a>、&lt;a class="link" href="https://rocket.rs" target="_blank" rel="noopener"
>Rocket&lt;/a>、&lt;a class="link" href="https://vapor.codes" target="_blank" rel="noopener"
>Vapor&lt;/a>などがあって、これらを全部触ってみた後、最も自分の好みに合ったものをプライベートで使い続けようと思っていたのです。&lt;/p>
&lt;p>そんな中、Pythonは普段もたまに簡単な自動化のスクリプトを作るなどの目的で使っているので、&lt;a class="link" href="https://www.djangoproject.com" target="_blank" rel="noopener"
>Django&lt;/a>を触ってみようかと思っていたところ、最近はFastAPIで爆速の開発ができるという話を聞いて興味を持つようになりました。今もKotlinとSpringで開発はできますが、シンプルなプロジェクトならこういった軽いオプションが一つあっても悪くなさそうな気がします。インタープリタ言語なので起動も早く、&lt;a class="link" href="https://www.techempower.com/benchmarks" target="_blank" rel="noopener"
>Techempowerのベンチマーク&lt;/a>でも意外と悪くないパフォーマンスを見せてくれているのも魅力的ですが、&lt;a class="link" href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener"
>Swagger&lt;/a>と&lt;a class="link" href="https://github.com/Redocly/redoc" target="_blank" rel="noopener"
>ReDoc&lt;/a>によるドキュメンテーションが自動で行われるというところがかなり良さげです。なんでもサクッと作れそうな感じがしますね。&lt;/p>
&lt;p>また、直接使わないとしてもコードが綺麗で勉強になる噂を聞いているので、少なくとも一度はコードを読んでみたくなります。&lt;/p>
&lt;h2 id="swiftui-and-jetpack-compose">SwiftUI and Jetpack Compose&lt;/h2>
&lt;p>個人的に本当にやりたかった分野は、GUIを持つアプリを作り上げることです。エンジニアという職業を持つ前から作ったのも&lt;a class="link" href="https://openjfx.io" target="_blank" rel="noopener"
>JavaFX&lt;/a>によるデスクトップアプリでしたので。最近はJavaScriptだけでも&lt;a class="link" href="https://www.electronjs.org" target="_blank" rel="noopener"
>Electron&lt;/a>や&lt;a class="link" href="https://reactnative.dev" target="_blank" rel="noopener"
>React Native&lt;/a>などを使ってなんでもできるという時代にはなっていますが、せっかくJavaとKotlinができるようになったので、ネイティブアプリを作ってみた方が良さそうな気がします。&lt;/p>
&lt;p>以前&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>が発表されてまもない時期に、一度React Nativeと一緒にチュートリアルだけ触れてみたことがあるのですが、当時にもFlutterのいわゆる「宣言型GUI」というものに魅力を感じていたのでこれからモバイルをやるとしたらFlutterかなと悩んでいました。最近はモバイルだけでなく、デスクトップアプリやウェブアプリまで作れるようになったのでなおさらでしたね。&lt;/p>
&lt;p>しかし、&lt;a class="link" href="https://developer.apple.com/xcode/swiftui" target="_blank" rel="noopener"
>SwiftUI&lt;/a>と&lt;a class="link" href="https://developer.android.com/jetpack/compose?hl=ja" target="_blank" rel="noopener"
>Jetpack Compose&lt;/a>というものが登場してからは完全にこちらに傾きました。どうしても同時にマルチプラットフォームアプリが開発できるという面ではFlutterが有利だとは思いますが、それと似たような感覚でネイティブのUIが作れられるようになったのでもう悩む必要がないかなという気がします。&lt;/p>
&lt;p>特に、SwiftUIだとMac用のデスクトップアプリを作ることもできますが、Jetpack Composeならデスクトップアプリだけでなくウェブアプリも作ることができて、さらに&lt;a class="link" href="https://kotlinlang.org/docs/kmm-getting-started.html" target="_blank" rel="noopener"
>Kotlin Multiplatform Mobile&lt;/a>を使うとビジネスロジックの共有ができるようになるのでこちらの方が自分の場合にはより合うのではないかという気がしています。自分に合うというのは、私がめんどくさがり屋なので一つの言語で全てを解決したいという願望を持っているというだけの話ですが…とにかく一度使ってみて、よかったらフロントエンドでもJetpack Composeを使ってみるのはありかなと思っています。&lt;a class="link" href="https://kotlinlang.org/docs/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>という選択肢もありますが、こちらはまた次の機会で。&lt;/p>
&lt;p>ただこれらのデメリットは、やはりどれもまだ完成されてない技術ということですね。分野を問わず新しい技術のジレンマでもありますが、新技術がどれだけ良くてもそれだけでは完全ではない（もしくはかなり不便）という場面が出てくる可能性があるので、当面は少し様子を見ながらシンプルなアプリを作ってみることから初めてみようと思います。Flutterという良い先例があるので、良さげな機能はすぐに吸収してくれるという期待もあります。&lt;/p>
&lt;h2 id="oracle-cloud">Oracle Cloud&lt;/h2>
&lt;p>他のクラウドと比べかなり後発したためか、無料プランでもメモリ1GBのVMインスタンスを二つも提供するという破格の政策で知られたOracle Clouですが、2021年からはさらに選べるVMインスタンスにARM（&lt;a class="link" href="https://www.oracle.com/jp/cloud/compute/arm" target="_blank" rel="noopener"
>Ampere A1&lt;/a>というオプションを追加しています。&lt;/p>
&lt;p>Ampereが既存のAMDやIntel製CPUを使うインスタンスと比べて目立つのはやはり性能です。ARMだと互換性の問題がありx86と比べ利用率が下がると思ったためか、無料プランでも4つのOCPU、24GBのメモリという良い性能のインスタンスを提供しています。無料のインスタンスを2つまで作ることができるので、2つのOCPUと12GBのメモリという構成を2つのインスタンスに分けて指定することもできます。&lt;/p>
&lt;p>個人的には既存の無料で使えるインスタンスが1つのOCPU、1GBのメモリというオプションだったので、Javaアプリのビルドなどヘビーな作業には向いてないのが惜しいところでした。なので&lt;a class="link" href="https://mattermost.com" target="_blank" rel="noopener"
>Mattermost&lt;/a>のサーバとして使うなど軽い感じでしか使い道がなかったのですが、Ampereの導入でCI用サーバなどに使える道もできたかなと思います。Oracle Cloudのホームページで紹介していること以外でも、他の&lt;a class="link" href="https://jiuyu.medium.com/oracle-cloud-ampere-a1-cpu-benchmarks-6464ef43593d" target="_blank" rel="noopener"
>ベンチマーク&lt;/a>を参照するとCPU性能は期待しても良さそうな気がします。無料でOracle DBも提供されているのでそちらを使うか、それともVMインスタンスを一つDB用に使うか、GCPやAWSの無料サービスと組み合わせて使うとかでも色々できそうな気がします。&lt;/p>
&lt;p>ただ、やはり互換性が気になっていたのですが、個人的にはApple Silicon搭載Macを使ってみながら「意外と悪くない」という結論に至っています。プログラミング言語などはすでにARM対応済みのものが多く、サーバで使うとしたら&lt;a class="link" href="https://www.ffmpeg.org" target="_blank" rel="noopener"
>FFmpeg&lt;/a>、&lt;a class="link" href="https://imagemagick.org/index.php" target="_blank" rel="noopener"
>ImageMagick&lt;/a>、&lt;a class="link" href="http://www.graphicsmagick.org" target="_blank" rel="noopener"
>GraphicsMagick&lt;/a>などを使うケースもあるかなと思いますが、どれもARMバージョンをインストールもしくはビルドできるので特に問題はなさそうです。&lt;/p>
&lt;p>他に問題なら、今の所VMインスタンスを作ろうとしてもハードウェアが十分ではないのか、2つのOCPU以上のスペックでは作れないというのが問題ですね。時間が解決してくれる問題かもしれませんが、いつになったらインスタンスを自由に作れるかわからないというのは確かに問題と言えるでしょう。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>意欲がないといいつつ、これだけやってみたいものが多いというのはまだ自分がエンジニアとして気持ちが死んでいるわけではないからよかったなと思わせます。本当は意欲がないというより「面倒臭いだけ」と訂正するべきかもですね…&lt;/p>
&lt;p>というわけで、色々とやりたいことだけを並べてみましたが、今年はそろそろ何か実際使えるアプリを作り出すのを第一の目標にしたいと思っています。何か作ってみるだけでも間違いなく良い経験、良い経歴になるはずなので。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>Apple Silicon Macに移行する</title><link>https://retheviper.github.io/posts/move-to-apple-silicon/</link><pubDate>Sun, 19 Dec 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/move-to-apple-silicon/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.jpg" alt="Featured image of post Apple Silicon Macに移行する" />&lt;p>M1 Macが発売されてもう1年以上が経ちます。最初は流石に&lt;a class="link" href="https://ja.wikipedia.org/wiki/Rosetta" target="_blank" rel="noopener"
>Rosetta&lt;/a>があるとはいえ、ネイティブアプリが少なく問題が起こったり性能が低下するケースも少なくなかったので、すぐにApple Silicon Macを購入しようとは思わなかったのです。それが今はネイティブアプリも増え、OSのアップデートもあったので十分移行しても良いタイミングになっている気がしました。そして今年、M1 ProとM1 Maxを搭載した新しいMacが発表され、既存のintelチップ搭載モデルと比べメリットが多いと思ったので購入を決めることになりました。&lt;/p>
&lt;p>新しいMacについてはチップの性能という面でも、改善されたハードウェア（ディスプレイやスピーカ、キーボードなど）という面でもかなり良いものになっている印象はありますが、ここではあえてそれらについては述べません。多くのベンマークやレビューなどで明らかになっていることが多いと思いますので、ここではintel機からの移行経験に関して述べさせてください。&lt;/p>
&lt;h2 id="移行方法">移行方法&lt;/h2>
&lt;p>まず、Apple Silicon Macに移行を決めてから、以下のような基準を立てました。&lt;/p>
&lt;ul>
&lt;li>既存のMacからマイグレーションする&lt;/li>
&lt;li>なるべくネイティブアプリを使う&lt;/li>
&lt;/ul>
&lt;p>マイグレーションをすると決めた理由は、現在利用中のアプリの設定を最初から見直したくないものが多かったからです。アーキテクチャが違うのでマイグレーションを行わない方と比べ何か問題になる可能性もあるかと思いましたが、実際使用中の今までは特に問題はなかったので、最初から全てをやり直すということがめんどくさい場合はマイグレーションをしても良さそうです。&lt;/p>
&lt;p>また、移行には「移行アシスタント」を使いました。この場合、選べる移行の方法は以下の通りです。&lt;/p>
&lt;ul>
&lt;li>TimeMachine&lt;/li>
&lt;li>Macから移行
&lt;ul>
&lt;li>Wi-Fiを使う&lt;/li>
&lt;li>Thunderboltケーブルで接続&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>TimeMachineを使うと最新の状態が反映されないので、使っているMacから移行することにしました。また、データのコピーにかかる時間が最も短いというのでThunderboltで二つのMacを直結して移行を行なっています。移行には時間は思ったよりそう掛からなく、終わった直後の状態は既存のものと変わらなかったです。&lt;/p>
&lt;p>移行後はApple Siliconネイティブアプリを使いたいので、アプリの情報を一つ一つ確認してUniversalではないものからバイナリを切り替えていくことにしました。&lt;/p>
&lt;h2 id="バイナリの確認">バイナリの確認&lt;/h2>
&lt;p>まずマイグレーションが終わった時点で、インストールされているアプリがApple Siliconネイティブであるかどうかを見分ける方法は以下があります。&lt;/p>
&lt;ul>
&lt;li>Finderから「情報を見る」&lt;/li>
&lt;li>アクティビティモニタの「種類」をみる&lt;/li>
&lt;li>「このMacについて」→「システムレポート」→「ソフトウェア」→「アプリケーション」から探す&lt;/li>
&lt;li>&lt;a class="link" href="https://isapplesiliconready.com" target="_blank" rel="noopener"
>Is Apple Silicon ready?&lt;/a>から探してみる&lt;/li>
&lt;/ul>
&lt;p>他にもintell版のアプリの場合は最初実行時にRosettaをインストールするか確認するダイアログが出るのでそれで確認するという方法もあります。主にターミナルで使うプログラミング言語などがそうですね。ただ、一度でもRosettaをインストールしたらintell版のバイナリでもダイアログなしで実行されてしまうので、全体の移行が終わるまではRosettaをインストールしない方が良いかと思います。&lt;/p>
&lt;h2 id="アプリケーションの切り替え">アプリケーションの切り替え&lt;/h2>
&lt;p>以下はUniversal Binary(IntelとApple Siliconの両方に対応)を提供しているので、Intel機から移行した場合でも特に何もしなくて良いです。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.google.com/intl/ja/chrome" target="_blank" rel="noopener"
>Chrome&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.microsoft.com/ja-jp/edge" target="_blank" rel="noopener"
>Edge&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.mozilla.org/ja/firefox/new/" target="_blank" rel="noopener"
>Firefox&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/edgeview-2/id1206246482" target="_blank" rel="noopener"
>EdgeView2&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://movistprime.com/en" target="_blank" rel="noopener"
>Movist Pro&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/amphetamine/id937984704" target="_blank" rel="noopener"
>Amphetamine&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/id1265704574" target="_blank" rel="noopener"
>Bandizip&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://obsidian.md" target="_blank" rel="noopener"
>Obsidian&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/magnet-%E3%83%9E%E3%82%B0%E3%83%8D%E3%83%83%E3%83%88/id441258766" target="_blank" rel="noopener"
>Magnet&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://crystalidea.com/macs-fan-control/download" target="_blank" rel="noopener"
>Macs Fan Control&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/istat-menus/id1319778037" target="_blank" rel="noopener"
>iStat Menus&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/%E3%83%A6%E3%83%8B%E3%82%B3%E3%83%BC%E3%83%B3-%E5%BA%83%E5%91%8A%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%BF%85%E9%A0%88%E3%82%A2%E3%83%97%E3%83%AA/id1231935892" target="_blank" rel="noopener"
>ユニコーン&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-remote-desktop/id1295203466" target="_blank" rel="noopener"
>Microsoft Remote Desktop&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-word/id462054704" target="_blank" rel="noopener"
>Microsoft Word&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-powerpoint/id462062816" target="_blank" rel="noopener"
>Microsoft PowerPoint&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-excel/id462058435" target="_blank" rel="noopener"
>Microsoft Excel&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-onenote/id784801555" target="_blank" rel="noopener"
>Microsoft OneNote&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://apps.apple.com/jp/app/microsoft-outlook/id985367838" target="_blank" rel="noopener"
>Microsoft Outlook&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一つ、Macs Fan Controlの場合、私はメニューバーにCPUの温度を表示するために使っているのですが、温度を表示する項目を選択する際にintell機だと「CPU PECI」を選べる方が一般的かなと思いますが、Apple Siliconだとそのような項目がありません。しばらく全体的な温度をみたところ、「CPU Performance Core」が最も温度が高いように見えたので、温度を確認したい場合はそれを選んでおいた方がいいかなと思います。&lt;/p>
&lt;h3 id="バイナリを切り替える必要があるケース">バイナリを切り替える必要があるケース&lt;/h3>
&lt;p>以下はApple Silicon用のバイナリを別途提供しているので、ホームページからダウンロードして既存のアプリを上書きするだけで対応できました。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.notion.so/desktop" target="_blank" rel="noopener"
>Notion Desktop&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener"
>Docker Desktop&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.postman.com/downloads/" target="_blank" rel="noopener"
>Postman&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://zoom.us/download" target="_blank" rel="noopener"
>Zoom&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.webex.com/ja/downloads.html" target="_blank" rel="noopener"
>Webex&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/jgraph/drawio-desktop/releases" target="_blank" rel="noopener"
>draw.io&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ただ、DockerはデスクトップアプリそのものはApple Siliconネイティブを使うとしても、イメージがamd64のみ対応するというケースも多いので、ここは色々と検証が必要かなと思います。私の環境ではまだMySQL（5.7）がApple Siliconに対応してなかったのですが、特に問題なく動いています。&lt;/p>
&lt;h2 id="homebrew">Homebrew&lt;/h2>
&lt;p>Rosettaを使って既存のintell版バイナリを使うこともできるらしいのですが、Apple Siliconに対応したバージョンはインストールされるパスが違うし（既存は&lt;code>/usr/local&lt;/code>、Apple Silicon版は&lt;code>/opt/homebrew&lt;/code>）、Apple Silicon版だとインストールされるパッケージは基本的にApple Siliconネイティブになるか、intell版でも新しくビルドしてくれるらしいので、使っていたintell版を消して新しくインストールし直すことにしました。&lt;/p>
&lt;p>アンインストールとインストールは、別に何も意識する必要はありませんでした。公式ホームページに出ている通り、以下のコマンドを実行するだけで良いです。自動でintell版を消してくれて、新しくインストールする場合はApple Silicon版になります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># アンインストール&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/bin/bash -c &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh&lt;span style="color:#ff79c6">)&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4"># インストール&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/bin/bash -c &lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>&lt;span style="color:#ff79c6">$(&lt;/span>curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh&lt;span style="color:#ff79c6">)&lt;/span>&lt;span style="color:#f1fa8c">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ただ、homebrewでインストールしたパッケージ関しては自分の場合はとりあえず全部削除しておいて、後で必要になったらそれだけインストールしようという方針でしたが、以下のコマンドで使っていたパッケージのリストがバックアップできるらしいです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>/usr/local/homebrew/bin/brew bundle dump
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="開発環境">開発環境&lt;/h2>
&lt;p>開発環境の構築に関しては色々なケースがあるので、こちらで別途説明します。&lt;/p>
&lt;h3 id="jetbrains-ide">JetBrains IDE&lt;/h3>
&lt;p>JetBrains社の製品（+ Android Studio）なら&lt;a class="link" href="https://www.jetbrains.com/ja-jp/toolbox-app" target="_blank" rel="noopener"
>Toolbox&lt;/a>で簡単に管理ができるのですが、このアプリ自体もApple Silicon対応のバイナリに変える必要があります。&lt;/p>
&lt;p>ToolboxをApple Siliconネイティブに切り替えた後は、メニューからIDEをアンインストール後に再インストールするだけです。もしToolboxを使ってない場合は、使っているIDEのバイナリをダウンロードし直す必要があります。&lt;/p>
&lt;p>ちなみに、ToolboxからインストールされるIDEは&lt;code>~/Applications/JetBrains Toolbox&lt;/code>の配下にLauncherが置かれ、それをシステムレポートなどで確認するとintel版のバイナリになっています。ただ、実行時はちゃんとApple Siliconネイティブになっているので（アクティビティモニタから確認可能）安心してください。&lt;/p>
&lt;h3 id="visual-studio-code">Visual Studio Code&lt;/h3>
&lt;p>&lt;a class="link" href="https://code.visualstudio.com/download" target="_blank" rel="noopener"
>Visual Studio Code&lt;/a>の場合は、Universal/Intel/Apple Silicon用のバイナリを全部提供していました。多分あえてIntelバージョンをインストールしてなかったら、自然にUniversalにアップデートされていたのではないかと思います。&lt;/p>
&lt;p>あえてUniversalを使う必要はなく、サイズが小さいのでApple Siliconバージョンをダウンロードしたほうがいいかなと思います。&lt;/p>
&lt;p>また、最近はモブプロなどでVisual Studio Live Shareを使うケースが多いかなと思いますが、こちらはまだApple Siliconに対応していません。こちらはGitHubのissueで&lt;a class="link" href="https://github.com/MicrosoftDocs/live-share/issues/4527#issuecomment-984823885" target="_blank" rel="noopener"
>今後対応する予定&lt;/a>だというので、当面は待つしかないですね。&lt;/p>
&lt;h3 id="java">Java&lt;/h3>
&lt;p>Javaの場合、intellだとどのベンダのものを選んでも大差ないですが、Apple Siliconだと少し話が変わってきます。なぜかというと、ベンダ別にApple Siliconに対応しているJDKのバージョンが違うからです。Rosettaを使っていない場合、「bad CPU type in executable」というエラーが発生するので、インストールされているバージョンが&lt;/p>
&lt;p>各ベンダ別のApple Silicon対応済みのLTSバージョンのJDKの一覧は以下の通りです。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>JDK&lt;/th>
&lt;th>対応バージョン&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a class="link" href="https://docs.aws.amazon.com/corretto/latest/corretto-17-ug/downloads-list.html" target="_blank" rel="noopener"
>Amazon Corretto&lt;/a>&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://www.azul.com/downloads/?version=java-11-lts&amp;amp;os=macos&amp;amp;architecture=arm-64-bit&amp;amp;package=jdk" target="_blank" rel="noopener"
>Azul Zulu&lt;/a>&lt;/td>
&lt;td>1.8, 11, 17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://bell-sw.com/pages/downloads/#/java-11-lts" target="_blank" rel="noopener"
>Bellsoft Liberica&lt;/a>&lt;/td>
&lt;td>1.8, 11, 17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://adoptium.net" target="_blank" rel="noopener"
>Eclipse Temurin&lt;/a>&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://docs.microsoft.com/ja-jp/java/openjdk/download" target="_blank" rel="noopener"
>Microsoft&lt;/a>&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://www.oracle.com/java/technologies/downloads/#jdk17-mac" target="_blank" rel="noopener"
>Oracle Java SE&lt;/a>&lt;/td>
&lt;td>17&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a class="link" href="https://sap.github.io/SapMachine" target="_blank" rel="noopener"
>SapMachine&lt;/a>&lt;/td>
&lt;td>11, 17&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>上記のJDKのうち、一部はintellijでもダウンロードできるものとなっていて、intellij上ではApple Silicon対応バージョンを&lt;code>aarch64&lt;/code>と表示していますのでインストール時は必ず確認しましょう。&lt;/p>
&lt;p>他にも&lt;a class="link" href="https://developers.redhat.com/products/openjdk/download" target="_blank" rel="noopener"
>Red Hat&lt;/a>や&lt;a class="link" href="https://www.ibm.com/support/pages/java-sdk-downloads-version-110" target="_blank" rel="noopener"
>IBM Semeru&lt;/a>などがありますが、こちらの場合はApple Silicon用のJDKを提供していません。&lt;/p>
&lt;p>最近はどのJDKを選んでも特に問題はないかと思いますので、17を選ぶならOracleのでも良いし、他も好みで選んでも良さそうな気がします。私の場合はずっとAdpotOpenJDKを使っていたので、今回もTemurinを選びました。ただ、Temurinだと11がApple Siliconに対応してないので、そこはZuluを選んでいます。インストールにはhomebrewを使いました。&lt;/p>
&lt;p>Apple Siliconとは直接的な関係はないですが、以下のコマンドで使うJDKのバージョンを簡単に切り替えできるのでさまざまなベンダのJDKを使ってみるのもありかもですね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#8be9fd;font-style:italic">export&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">JAVA_HOME&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">`&lt;/span>/usr/libexec/java_home -v 11&lt;span style="color:#f1fa8c">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ java -version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openjdk version &lt;span style="color:#f1fa8c">&amp;#34;11.0.13&amp;#34;&lt;/span> 2021-10-19 LTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OpenJDK Runtime Environment Zulu11.52+13-CA &lt;span style="color:#ff79c6">(&lt;/span>build 11.0.13+8-LTS&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OpenJDK 64-Bit Server VM Zulu11.52+13-CA &lt;span style="color:#ff79c6">(&lt;/span>build 11.0.13+8-LTS, mixed mode&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#8be9fd;font-style:italic">export&lt;/span> &lt;span style="color:#8be9fd;font-style:italic">JAVA_HOME&lt;/span>&lt;span style="color:#ff79c6">=&lt;/span>&lt;span style="color:#f1fa8c">`&lt;/span>/usr/libexec/java_home -v 17&lt;span style="color:#f1fa8c">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ java -version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>openjdk version &lt;span style="color:#f1fa8c">&amp;#34;17.0.1&amp;#34;&lt;/span> 2021-10-19
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OpenJDK Runtime Environment Temurin-17.0.1+12 &lt;span style="color:#ff79c6">(&lt;/span>build 17.0.1+12&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OpenJDK 64-Bit Server VM Temurin-17.0.1+12 &lt;span style="color:#ff79c6">(&lt;/span>build 17.0.1+12, mixed mode&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>GraalVMの場合は、まだApple Siliconに対応していません。ただ2020年からGithubの&lt;a class="link" href="https://github.com/oracle/graal/issues/2666" target="_blank" rel="noopener"
>issue&lt;/a>がオープンの状態であって、Linux+aarch64に対応したバイナリは提供している状態なので、いずれはリリースされるかと思います。&lt;/p>
&lt;h3 id="kotlin">Kotlin&lt;/h3>
&lt;p>Kotlinは1.5.30から&lt;a class="link" href="https://kotlinlang.org/docs/whatsnew1530.html#apple-silicon-support" target="_blank" rel="noopener"
>Apple Siliconサポート&lt;/a>が発表されていますが、これはKotlin/Nativeに関するものなのでKotlin/JVMの場合だとJavaの方だけ気をつけたらいいと思います。こちらもhomebrewでインストールし、特に問題はありませんでした。&lt;/p>
&lt;h3 id="gradle">Gradle&lt;/h3>
&lt;p>Gradleの場合はv6.8.3を使うプロジェクトがあったので、Javaの設定が終わった後にビルドしてみると以下のようなエラーが出ました。（依存関係やプロジェクトの設定によってエラーの種類は変わる可能性があるかと思います）&lt;/p>
&lt;h4 id="java-17で実行した場合">Java 17で実行した場合&lt;/h4>
&lt;p>Java 17(Temurin)で実行した場合、Gradleそのものが実行時にエラーを吐きます。おそらくrefelction関係でdeprecatedになっていたAPIを使っているのが問題になったのではないかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;gt; java.lang.IllegalAccessError: class org.gradle.internal.compiler.java.ClassNameCollector &lt;span style="color:#ff79c6">(&lt;/span>in unnamed module @0x8f1317&lt;span style="color:#ff79c6">)&lt;/span> cannot access class com.sun.tools.javac.code.Symbol&lt;span style="color:#8be9fd;font-style:italic">$TypeSymbol&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>in module jdk.compiler&lt;span style="color:#ff79c6">)&lt;/span> because module jdk.compiler does not &lt;span style="color:#8be9fd;font-style:italic">export&lt;/span> com.sun.tools.javac.code to unnamed module @0x8f1317
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="java-11で実行した場合">Java 11で実行した場合&lt;/h4>
&lt;p>Java 11で実行するとコンパイルまでは行われるようですが、テスト（junit）の実行で以下のような問題が起こりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>*** java.lang.instrument ASSERTION FAILED ***: &lt;span style="color:#f1fa8c">&amp;#34;result&amp;#34;&lt;/span> with message agent load/premain call failed at src/java.instrument/share/native/libinstrument/JPLISAgent.c line: &lt;span style="color:#bd93f9">422&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FATAL ERROR in native method: processing of -javaagent failed, processJavaStart failed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Process &lt;span style="color:#f1fa8c">&amp;#39;Gradle Test Executor 1679&amp;#39;&lt;/span> finished with non-zero &lt;span style="color:#8be9fd;font-style:italic">exit&lt;/span> value &lt;span style="color:#bd93f9">134&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>調べてみると、Gradleはv6.9からApple Siliconに対応したようだったので、ラッパーを最新にバージョンアップ。&lt;code>gradle/wrapper/gradle-wrapper.properties&lt;/code>のバージョン指定を変えるだけでも対応できますが、以下のコマンドを使っています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./gradlew wrapper --gradle-version&lt;span style="color:#ff79c6">=&lt;/span>7.3.1 --distribution-type&lt;span style="color:#ff79c6">=&lt;/span>bin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>いきなりv6.8.3からv7.3.1にアップデートしたのですが、テストまで正常終了しています。このプロジェクトはKotlin + Spring bootの構成なので、もし同じような構成のプロジェクトがあるとしたらJava/Kotlin/Gradleのバージョンアップをおこなってからアプリのビルドを試してみましょう。&lt;/p>
&lt;h3 id="ruby--python--go">Ruby / Python / Go&lt;/h3>
&lt;p>RubyとPythonに関してはmacOS上ですでにインストール済みの状態ですが、バージョンやプロジェクトの設定などによっては問題が起こる可能性もあるのでhomebrewでインストールしました。このブログで使っている&lt;a class="link" href="https://jekyllrb.com" target="_blank" rel="noopener"
>jekyll&lt;/a>はrubyをインストールし直したので同じくインストールし直す必要がありました。こちらもhomebrewでインストールができ、既存のプロジェクトにおいてはなんの問題もなく実行することができました。&lt;/p>
&lt;p>Pythonの場合、既存のプロジェクトのパッケージを再インストールする必要がありました。でも&lt;code>requirements.txt&lt;/code>があれば特に問題にはならないくらいです。&lt;/p>
&lt;p>Goの場合も1.16からApple Siliconに対応しているので、特にバージョンの指定が必要なケースでなければ、homebrewで最新をインストールしても良いかなと思います。ただ、既存のプロジェクトのGOROOTやGOPATHの問題があるので、ホームページから別途ダウンロードして設定する必要のあるケースもあるかと思います。&lt;/p>
&lt;h2 id="rosettaを使うしかないケース">Rosettaを使うしかないケース&lt;/h2>
&lt;p>多くのアプリがApple Siliconに対応してきましたが、バージョンアップそのものが終わったり、Rosettaを通じて問題なく動く（からApple Silicon対応は後回しにするという政策の）アプリに関してはネイティブのバイナリが存在しない場合もあるので、仕方なくRosettaを使うしかないかなと思います。&lt;/p>
&lt;p>ソースコードをダウンロードして、ローカルでビルドするという方法もあるかと思いますが、使われているSwiftのバージョンが低い場合はXCodeですぐにビルドできない場合もあったりしました。いつかはRosettaのサボートも終わりそうなので、長期的な観点ではこのようなアプリは他のものに代替した方が良いかもしれません。&lt;/p>
&lt;h3 id="mattermost">Mattermost&lt;/h3>
&lt;p>&lt;a class="link" href="https://mattermost.com/download" target="_blank" rel="noopener"
>Mattermost&lt;/a>はSlackと似たようなコミュニケーションツールで、サーバにインストールすることで無料利用ができるしマークダウンのサポートが優秀だったりするのでプライペートでよく使っています。ただ残念なことに、こちらはまだApple Silicon用の正式リリース版がないようです。&lt;/p>
&lt;p>正式リリースの予定はあるようなのでバージョンアップまでintell版を使うという選択肢もありますが、&lt;a class="link" href="https://github.com/mattermost/desktop/releases" target="_blank" rel="noopener"
>GitHubのリポジトリ&lt;/a>を見るとUniversalとApple Silicon用のバイナリのベータ版も存在しているので、どうしてもRosettaを使いたくない場合はこちらを選んでみても良いかもしれません。&lt;/p>
&lt;h3 id="keyboardcleantool">KeyboardCleanTool&lt;/h3>
&lt;p>&lt;a class="link" href="https://folivora.ai/keyboardcleantool" target="_blank" rel="noopener"
>KeyboardCleanTool&lt;/a>は、アプリを実行している間に全てのキー入力を無視するという単純なツールです。キーボードが汚れて拭きたいときによく使っていますね。残念ながらこちらもまだApple Siliconに対応していません。同じ会社で開発している&lt;a class="link" href="https://folivora.ai" target="_blank" rel="noopener"
>BetterTouchTool&lt;/a>はUniversalバイナリで提供されていますが、その対応ができたのも11月のことなので他の製品が全部Apple Siliconに対応するにはかなり時間がかかるかもしれません。&lt;/p>
&lt;p>このようなアプリは特にネイティブにならなくても困らないものなので、Apple Siliconネイティブ対応はかなり優先順位が低い感がありますね。&lt;/p>
&lt;h2 id="onedrive">OneDrive&lt;/h2>
&lt;p>Microsoft社の製品にしてはかなり珍しいケースですが、対応が遅れていますね。ただ、今月&lt;a class="link" href="https://techcommunity.microsoft.com/t5/microsoft-onedrive-blog/onedrive-sync-for-native-arm-devices-now-in-public-preview/ba-p/3031668" target="_blank" rel="noopener"
>PreviewとしてUniversalバージョンが利用できる&lt;/a>ようになったらしいので、もうすぐApple Siliconネイティブ版が出るかもしれません。その際にはApp Storeで自動的にアップデートされるはずなので、待つだけですね。&lt;/p>
&lt;h2 id="flutter">Flutter&lt;/h2>
&lt;p>Dartは&lt;a class="link" href="https://medium.com/dartlang/announcing-dart-2-14-b48b9bb2fb67" target="_blank" rel="noopener"
>v2.14からNative対応&lt;/a>しているのですが、Flutterはまだ未対応らしく、公式を見ても&lt;a class="link" href="https://github.com/flutter/flutter/wiki/%e3%85%85Developing-with-Flutter-on-Apple-Silicon" target="_blank" rel="noopener"
>Rossettaを推奨&lt;/a>しています。なのでRosettaを入れて実行した方が早いですね。&lt;/p>
&lt;p>他に、&lt;code>flutter doctor&lt;/code>を実行していくつか問題が出るケースがあるかと思います。そういう場合は以下の手順で対応できました。&lt;/p>
&lt;ul>
&lt;li>&lt;code>cmdline-tools component is missing&lt;/code>と出る場合
&lt;ul>
&lt;li>Android Studioから&lt;code>Appearance &amp;amp; Behavior&lt;/code> -&amp;gt; &lt;code>System Settings&lt;/code> -&amp;gt; &lt;code>Android SDK&lt;/code> -&amp;gt; &lt;code>SDK Tools&lt;/code> -&amp;gt; &lt;code>Android SDK Command-Line Tools&lt;/code>にチェックを入れる&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>CocoaPods installed but not working&lt;/code>と出る場合
&lt;ul>
&lt;li>&lt;code>brew install cocoapods&lt;/code>でインストール&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>移行が終わって本格的にApple Silicon Macを使ったのはまだ一週間経たないくらいの短い期間ですが、思ったより移行がスムーズで、ネイティブ対応済みのアプリも多かったので、M1が発表された直後の私のように互換性に疑問を持った方がいるとしたら（十分な事前調査を前提として）新しいMacに移行するのもありかも知れないと思います。&lt;/p>
&lt;p>最初はAppleが公式的に全てのMacをApple Siliconに移行するまで2年という計画を立てたという話をしていましたが、ユーザとしてはより時間がかかるのではないかと思っていました。しかし、実際に触ってみると、今でも十分移行ができる状態になっていると思います。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>個人的な2021年のロードマップ</title><link>https://retheviper.github.io/posts/my-roadmap-in-2021/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/my-roadmap-in-2021/</guid><description>&lt;img src="https://retheviper.github.io/images/map.jpg" alt="Featured image of post 個人的な2021年のロードマップ" />&lt;p>エンジニアとして働いていると会社の方針・クライアントの要求・経歴のような、自分の意思以外のところから自分の技術スタックを決まってしまう場合が決して少なくないと思います。会社は利益集団なので、致し方ないのですが、個人としてはどうでしょうか。私は、エンジニアは常にトレンドとともに前に進むべき職種なので、業務としてはあまり機会がないとしても、やはり自分で何かロードマップを立てて、独学でもスキルアップを図るべきたと思っています。&lt;/p>
&lt;p>例えば私は、どんな案件でも主にJavaとSpringのサーバサイドエンジニアか、Jenkins・Shell・Linuxを触るインフラエンジニアとして働いたことが多いのですが、何か一つは自分のアプリやサービスを作ってみたいと思っています。このような目標ないしは願望がある場合、それを成すためには何が必要か、と考えるようになり、そこから適合なプラットフォームは？言語は？フレームワークは？という風に考え始めて、そのうちでもっとも自分にとって合理的な道を選ぶようになります。何が合理的か、という基準は人それぞれですが(主観だけで決められるものでもないし)、会社が自分のエンジニアとしての目標を考えてくれる可能性は低いので、とにかくこういう目標設定は自分でなすべきでしょう。&lt;/p>
&lt;p>そういう意味で、今年の自分のロードマップを、「やりたいこと」と「良さそうなこと」という基準からいくつか立ててみました。まだロードマップとしては何一つ計画を具体化してないので、ただの興味に近いものなのかもしれませんが…とにかく、今の時点で興味を持っているものや考えていることについて、Google Trendを持って語ります。軽く、「こいつは2021年にこういうものに注目するんだな」と思ってください。&lt;/p>
&lt;h2 id="言語">言語&lt;/h2>
&lt;h3 id="typescript">TypeScript&lt;/h3>
&lt;p>いつまでになるかはわかりませんが、少なくともここ数年はJavaScriptの天下が続きそうですね。ただ、なぜそうかというと、Webの標準であるという強力な基盤がある上に、今はNode.jsやElectronのおかげでブラウザ以外でも使える場面が多いから、ということだけでは説明が難しくなりつつあるという側面もある印象です。今はもはやコーディングを学び始めるきっかけや入門の言語としてJavaScriptに触れるケースが多いし、SPAの登場以来からサーバサイドよりもフロントエンドの重要さが増してきたという感覚でもありますね。アプリケーションというのは、結局はユーザのためにデザインされるものであるということを考えると、より画面に密接な言語が持つ権限の方が大きくなるのは当然なのかもしれません。&lt;/p>
&lt;p>そしてバックエンドだけをみるとしても、最近はなるべくサーバサイドの役割を減らしていくか、細かく分けていく感覚ですね。&lt;a class="link" href="https://www.redhat.com/ja/topics/microservices" target="_blank" rel="noopener"
>マイクロサービス&lt;/a>、&lt;a class="link" href="https://www.atmarkit.co.jp/ait/articles/1803/12/news012.html" target="_blank" rel="noopener"
>BFF&lt;/a>、サーバレスのようなキーワードが流行っているのがその証拠だと思います。もちろんJavaScriptという言語そのものの発達によるものもあるとは思いますが、アプリケーションのアーキテクチャやデザインの思想そのものが変わっているので、仕方ないことです。&lt;/p>
&lt;p>そこで、少なくともJavaScriptは基礎だけでもできるようにしないと、と思いました。研修などで簡単な文法については学んだことがありますが、本格的なアプリを書いた経験はあまりなかったので、少なくとも&lt;a class="link" href="https://expressjs.com" target="_blank" rel="noopener"
>Express&lt;/a>で簡単なREST APIを作ってみるとかの経験はかなり役立つかもしれません。また、フロントエンドも少しは触れるようになるとよりいいでしょう。&lt;/p>
&lt;p>このように思ったときに、目に入ってきたのがTypeScriptでした。TypeScriptは以前、Udemyの講座で接したことがあり、気に入っていましたが、最近はかなり人気を得ているらしいですね。実際どうかは、まずGoogle Trendで確認してみました。&lt;/p>
&lt;script type="text/javascript" src="https://ssl.gstatic.com/trends_nrtr/2431_RC04/embed_loader.js">&lt;/script>&lt;script type="text/javascript"> trends.embed.renderExploreWidget("TIMESERIES", {"comparisonItem":[{"keyword":"typescript","geo":"","time":"today 5-y"}],"category":0,"property":""}, {"exploreQuery":"date=today%205-y&amp;q=typescript","guestPath":"https://trends.google.com:443/trends/embed/"}); &lt;/script>
&lt;p>結果をみると、確かにTypeScriptに対する興味は日々増えていっているような気がします。おそらくAngular・React・Vueのような有名フレームワークやライブラリからTypeScriptに公式対応し始めたのも理由と思いますし、やはり静的型付けの方が生産性が上がるというところがわかったきたからなのでしょう。私はJavaから触れた人間なので、静的型付けのできるTypeScriptの方を学んだ方が良いかなと思います。&lt;/p>
&lt;h3 id="go-or-rust">Go or Rust&lt;/h3>
&lt;p>個人的には、JVM言語が好きですが、やはり高水準言語&amp;amp;VMを挟む構造ということもあり、より低水準に近い言語も扱ってみたいと思っています。今すぐに必要なわけではないのですが、やはりハードウェア制御やバイナリデータを扱うなど、低水準言語ならではのことがやってみたいという純粋な好奇心が理由です。最近はIOTなどでC言語の人気も高くなっていたりしますが、組み込み系ならまだしも、いわゆる「応用ソフトウェア」を開発する身としては、CやC++、もしくはそれよりも古い言語よりは、GoやRustのような言語に触れてみた方が良さそうな気もします。&lt;/p>
&lt;p>ただ、悩ましいのは、それでGoとRustのうち、どれを選ぶかということです。性能だけを考えたら、当然Rustなのかもしれません。多くの場合、Rustが性能ではGoより優れていると言われていますね。実際の例として、音声チャットツールで有名な&lt;a class="link" href="https://discord.com/" target="_blank" rel="noopener"
>Discord&lt;/a>はGoからRustに移行しましたが、これが&lt;a class="link" href="https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f" target="_blank" rel="noopener"
>性能のため&lt;/a>だったと言っています。ただ、言語を学ぶこと自体の難易度は、やはりRustの方がGoより高いらしいですね。そして一般的に、生産性の方はGoが優れていると言われています。&lt;/p>
&lt;p>なので、以上のことから、自分は何をやってみたらいいのかなと思ってみた結果、CやC++に近い低水準言語の感覚としてRustを触ってみたらどうかな、と思いました。どちらもマイナーな言語ではありますが、&lt;a class="link" href="https://insights.stackoverflow.com/survey" target="_blank" rel="noopener"
>Stack Overflow survey&lt;/a>にて、数回も「もっともエンジニアから愛された言語」として選ばれたこともあるRustの方が、これからコミュニティの成長も期待できるのではないかなと思ったからでもあります。特に&lt;a class="link" href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved" target="_blank" rel="noopener"
>2020年の結果&lt;/a>は、86.1%というすごい結果になっているくらいですので。&lt;/p>
&lt;p>しかし、まだ実務レベルでよく使われているのはやはりGoの方で、リファレンスの量やエンジニアの興味という面でも(仕事で使うとしたら仕方ないのですが)、Goの方がまだ少し優勢ではないのかという気もします。Rustが最初からCやC++の代替を目標としてデザインされた言語であることに比べ、Goという言語がどこまでそのような役割ができるのかというのはまだあまりわかってないのですが、もし同じようなことできるのであれば、あえてRustにこだわる必要はないのではないかと思ったりもしますね。特に、ある言語の成長性というのは、そのコミュニティの大きさにも関係するので…なので、とりあえずGoogle Trendの方で、二つの言語に対する興味度について調べてみました。&lt;/p>
&lt;p>Goの場合は一般動詞(行く)と区別するため、多くの場合&lt;code>golang&lt;/code>で検索するケースが多いらしいです。しかし、Rustもあまり状況は変わってなくて(しかも、ゲーム名としても使われているようですね)、&lt;code>rustlang&lt;/code>という検索語はあまり使われてないと思うので、直接的な比較が難しいですね。なので、なるべく価値中立的なキーワードとして、&lt;code>go programming&lt;/code>と&lt;code>rust programming&lt;/code>を選んでみました。そしてその結果が、以下です。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "go programming", geo: "", time: "today 5-y" },
{ keyword: "rust programming", geo: "", time: "today 5-y" },
],
category: 0,
property: "",
},
{ exploreQuery: "date=today%205-y&amp;q=go%20programming,rust%20programming", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>結果だけをみると、やはりRustの方がすごい人気を得ているように見えますが、まだGoの方が優位にはありますね。なので、こちらの方が(急ぎでもないので)、もう少し観望しながら、ゆっくり決めようと思っています。&lt;/p>
&lt;h3 id="kotlin">Kotlin&lt;/h3>
&lt;p>今はJavaのいう&lt;code>Write once, run everywhere&lt;/code>が、どの言語でも同じようなことができていて(逆にJavaでできない分野はありますが)、それでもJVM言語は依然として魅力的だと思っています。最初からJVMがヒープを設定するのでメモリ管理という面でも安定的で、パフォーマンスも今流行りの高水準言語に比べても優秀な方ですね。また、10年以上世界でもっとも人気な言語だったので、ライブラリ・フレームワーク・リファレンスも豊富ですね。また、バイトコードだけを生成すればいいので、コンパイルする前の言語はどれでも良いです。なのでJava以外でも&lt;a class="link" href="https://www.scala-lang.org" target="_blank" rel="noopener"
>Scala&lt;/a>、&lt;a class="link" href="https://clojure.org" target="_blank" rel="noopener"
>Clojure&lt;/a>、&lt;a class="link" href="https://groovy-lang.org" target="_blank" rel="noopener"
>Groovy&lt;/a>、&lt;a class="link" href="https://www.jython.org" target="_blank" rel="noopener"
>Jython&lt;/a>、&lt;a class="link" href="https://www.jruby.org" target="_blank" rel="noopener"
>JRuby&lt;/a>、&lt;a class="link" href="https://ceylon-lang.org/" target="_blank" rel="noopener"
>Ceylon&lt;/a>、&lt;a class="link" href="https://github.com/Frege/frege" target="_blank" rel="noopener"
>Frege&lt;/a>、&lt;a class="link" href="https://eta-lang.org" target="_blank" rel="noopener"
>Eta&lt;/a>、&lt;a class="link" href="https://haxe.org" target="_blank" rel="noopener"
>Haxe&lt;/a>のような幾多の言語がJVMを利用できるようになっているわけですね。つまり、JVMこそ死なないが、Javaという言語そのものはこれらの言語のどれかに代替できるというわけです。&lt;/p>
&lt;p>そしていろんな言語の候補があるわけですが、その中でも個人的にはKotlinを選びました。近年のJavaも急激なバージョンアップを重ねながら改善されてはいるものの、実際エンタープライズレベルでそういったバージョンアップの効果を期待できるのはLTSバージョンがでた時だけですね。なので、いますぐ生産性を上げながらもJVMをそのまま利用できるという面では、Kotlinのようなモダンな言語への転換を考えるにはちょうどいい時期なのではないかと思っています。もちろん、私みたいにモバイルアプリの開発を考えているとしたら、尚更ですね。&lt;/p>
&lt;p>他にもGoogle推しの言語であることや、&lt;a class="link" href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener"
>Kotlin/Native&lt;/a>や&lt;a class="link" href="https://kotlinlang.org/docs/reference/js-overview.html" target="_blank" rel="noopener"
>Kotlin/JS&lt;/a>など他の言語でコンパイルできるという点も良いですね(実際Wantedlyでは、&lt;a class="link" href="https://www.wantedly.com/companies/wantedly/post_articles/282562" target="_blank" rel="noopener"
>すでにKotlin Multiplatformを導入&lt;/a>しているらしいです)。そして何より、Kotlinを開発しているのがJetBrainなので、Intellijでは完璧なサポートができるというところも無視できないメリットです。ほんと少しだけですが、使ってみた鑑賞としても、完成度がかなり高い感じの言語だったので(Swiftよりも)、そのようなところからKotlinの未来はかなり明るいと思っています。&lt;/p>
&lt;h2 id="フレームワーク--ライブラリ">フレームワーク &amp;amp; ライブラリ&lt;/h2>
&lt;h3 id="svelte">Svelte&lt;/h3>
&lt;p>先ほど少しJavaScriptの話をしましたが、JavaScriptそのものの需要や重要性については語るまでもないとはいうものの、そのJavaScriptのフレームワーク・ライブラリはどれが良いかという課題だけは、少なくとも数年でこれが正解と言えるような状態ではないかと思います。ここ数年で幾多のフレームワークやライブラリが生まれ、消えていってますね。幸い、いわゆるフロントエンド3強のAngular・React・Vueの中ではReactが勝者になりつつある雰囲気ではあります。Google Trendの結果も、それを見せていますね。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "angular", geo: "", time: "today 12-m" },
{ keyword: "react", geo: "", time: "today 12-m" },
{ keyword: "vue", geo: "", time: "today 12-m" },
],
category: 0,
property: "",
},
{ exploreQuery: "q=angular,react,vue&amp;date=today 12-m,today 12-m,today 12-m", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>しかし、フロントエンド以外の世界はまた話が違います。まだ多くのフレームワークやライブラリが乱立していて、まるで戦国時代のような様子です。こんななかでは、一体どれを選ぶべきか悩ましいし、判断のための調査だけでもかなりの時間と努力が必要となります。このような状況なので、もう数年前から流行っている言葉なのですが、&lt;a class="link" href="https://www.google.com/search?newwindow=1&amp;amp;biw=1680&amp;amp;bih=836&amp;amp;sxsrf=ALeKk03Q7zTnfCMWJbsybKG4qkODOhqViA%3A1611463509708&amp;amp;ei=VfsMYOPbKpvahwO8zpiwCQ&amp;amp;q=javascript&amp;#43;fatigue&amp;amp;oq=javascript&amp;#43;fatigue&amp;amp;gs_lcp=CgZwc3ktYWIQAzIGCAAQBxAeMgIIADIECAAQHjIECAAQHjIECAAQHjIGCAAQBRAeOgQIIxAnOggIABAIEAcQHjoICAAQBRAKEB46CAgAEAgQChAeOgYIABAIEB46BAgAEBM6CAgAEAcQHhATOgoIABAHEAUQHhATUOeYAVjBwAFgnsQBaAFwAHgAgAGyA4gB8BOSAQkwLjcuMy4xLjGYAQCgAQGqAQdnd3Mtd2l6wAEB&amp;amp;sclient=psy-ab&amp;amp;ved=0ahUKEwij2sGw4bPuAhUb7WEKHTwnBpY4ChDh1QMIDQ&amp;amp;uact=5" target="_blank" rel="noopener"
>JavaScript Fatigue&lt;/a>(JavaScript疲労)という言葉があるくらいです。それだけ現代のJavaScriptを学ぶということは大変なことでしょう。&lt;/p>
&lt;p>例えば私みたいに、ほとんどJavaScriptの経験がない人がフロントエンドエンジニアとなって、Reactがもっとも人気があるからそれをやる、と決めたら、まずNode.jsから初めて、パッケージ管理としてはnpmを使うか、yarnを使うか、言語はJavaScriptそのままにするかそれともTypeScriptにするかを決め、次に必要なものとして&lt;a class="link" href="https://webpack.js.org" target="_blank" rel="noopener"
>Webpack&lt;/a>や&lt;a class="link" href="https://babeljs.io" target="_blank" rel="noopener"
>Babel&lt;/a>、&lt;a class="link" href="https://redux.js.org" target="_blank" rel="noopener"
>Redux&lt;/a>を学ぶなどと、知っておくべきものと学ぶべきものが多いです。しかも、それぞれのフレームワークやライブラリがその名前だけでは何が何だかわからなくなります。&lt;a class="link" href="https://ja.nuxtjs.org" target="_blank" rel="noopener"
>Nuxt.js&lt;/a>はVue基盤のフレームワークだけど、&lt;a class="link" href="https://nestjs.com" target="_blank" rel="noopener"
>Nest.js&lt;/a>はNode.js用のフレームワークですね。そして&lt;a class="link" href="https://nextjs.org" target="_blank" rel="noopener"
>Next.js&lt;/a>はまた、React基盤のフレームワークです。この中では、一体どれを学んだらいいか、どれが良いかというのは混乱するだけです。なのでJavaScriptを扱うエンジニアが、疲労を感じるのも当然のことでしょう。&lt;/p>
&lt;p>自分の場合はすでにサーバサイドの実装がある程度はできるので、フロントエンドも触れるようになって、いわゆるフルスタックとして自分一人でアプリが書けたらいいなと思っています。ただ、会社で使われているフロントエンドのフレームワークがあればそれに触れたら良いのですが、個人レベルでは何が良いかはまだ悩ましいものですね。Reactがもっとも人気だから、やはりそれを選ぶべきか？それもいい選択なのかもしれませんが、これからも本格的にフロントエンドの開発に関わるつもりではない限り、本格的にフロントエンドに時間を投資するのはもったいない気もします。そこで考えた代案が、&lt;a class="link" href="https://svelte.dev" target="_blank" rel="noopener"
>Svelte&lt;/a>でした。&lt;/p>
&lt;p>Svleteの特徴(メリット)としては、色々とありますが、私がもっとも注目したところはかなりシンプルであるというところでした。コードが短いので、書き方に慣れるのが圧倒的に早そうな気がします。そのほかは付加的なメリットとしてよく、とにかく「必要な時にサクッとかける」ものとしては、かなり良さげなものではないかなと思ったりもします。もちろん、ちゃんとしたフレームワークなので、本格的なアプリケーションを作る時も良いでしょう。&lt;/p>
&lt;p>ただデメリットとしては、やはりメジャーな3強に比べてそこまで知られても、使われてもないというところです。幸い、Google Trendで確認したところ、少しづつながら注目を得ているのでこれからな気はします。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{ comparisonItem: [{ keyword: "svelte", geo: "", time: "today 5-y" }], category: 0, property: "" },
{ exploreQuery: "date=today%205-y&amp;q=svelte", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;h3 id="flutter">Flutter&lt;/h3>
&lt;p>今はWebアプリケーションばかり書いている私ですが、モバイルの方にも興味があり、どのような言語とフレームワークがあるかだけは把握しておきたいと思っています。そして最近は、モバイルは多くの場合ネイティブよりもハイブリッド・クロースプラットフォームの方が多くなっているような気がします。正確なデータや統計をみたわけではないのであくまで推測に過ぎないのですが、多くの場合ネイティブアプリに投資する時間や予算の余裕のないスタートアップやベンチャー企業の場合は、とりあえずハイブリッド・クロースプラットフォームを好むような印象です。もちろん、複雑な演算やOS特有の機能を使うとしたらやはりネイティブと言われていますが、個人的な経験からだと、意外とハイブリッド・クロースプラットフォームでもできることは多いのでもうOSレベルでもなく、機器固有の機能を活用する必要がなければ大体ハイブリッド・クロースプラットフォームでも事足りるのでは、と思います。&lt;/p>
&lt;p>(ここで個人的な経験というものは、iOS 14から導入されたウィージェット機能を活かした簡単なアプリを作ってみたいなと思い調べたところ、OS固有の機能なので難しいのではないかと思ったものが、意外とReact NativeやFlutterでも十分できるということがわかったことです)&lt;/p>
&lt;p>そして、昔はただのWebViewでできていたアプリも多かったような気がしますが、それならあえてモバイルアプリとして作る必要がないですね(PWAならわかりますが)。でもそのような形のアプリがあったからか、Webの技術から影響され生まれたバイブリッドモバイルアプリのフレームワークもかなり多いような印象です。なのでJavaScriptでコードを書いたり、JavaScriptのフレームワークを基盤にしてアプリを書けるフレームワークがかなり多いですね。例えば&lt;a class="link" href="https://cordova.apache.org" target="_blank" rel="noopener"
>Apache Cordova&lt;/a>、&lt;a class="link" href="https://ionicframework.com" target="_blank" rel="noopener"
>Ionic&lt;/a>、&lt;a class="link" href="https://nativescript.org" target="_blank" rel="noopener"
>NativeScript&lt;/a>、&lt;a class="link" href="https://reactnative.dev" target="_blank" rel="noopener"
>React Native&lt;/a>がそのようなものです。もちろんJavaScript(Web)とは違う系統、つまり伝統的なデスクトップアプリを継承している印象のフレームワークとしてC#基盤の&lt;a class="link" href="https://dotnet.microsoft.com/apps/xamarin" target="_blank" rel="noopener"
>Xamarin&lt;/a>とDart基盤の&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>がありますね。&lt;/p>
&lt;p>これだけ多いハイブリッド・クロースプラットフォームモバイルアプリ用のフレームワークですが、中でもそろそろ淘汰されてそうな技術はあります。またここでGoogle Trendの結果をみてみましょう。5つの項目しか比較ができないので、Flutterは入れてないです。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "cordova", geo: "", time: "today 5-y" },
{ keyword: "ionic", geo: "", time: "today 5-y" },
{ keyword: "xamarin", geo: "", time: "today 5-y" },
{ keyword: "nativescript", geo: "", time: "today 5-y" },
{ keyword: "react native", geo: "", time: "today 5-y" },
],
category: 0,
property: "",
},
{ exploreQuery: "date=today%205-y&amp;q=cordova,ionic,xamarin,nativescript,react%20native", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>少なくとも、NativeScriptにはあまり興味を持っている人がいなく、XamarinやCordovaの場合もだんだん興味が下がっているのを確認できます。そうすると、残りの結果としてはIonicとReact Nativeが残りますね。先ほどフロントエンドの話を少ししましたが、最近のフロントエンド3強の勝者がReactになりそうという現実からして、Web技術に基盤したハイブリッド・クロースプラットフォームモバイルアプリ用のフレームワークは、やはりReact Nativeが適切かなと思います。&lt;/p>
&lt;p>しかし、問題となるのはFlutterです。FlutterはReact Nativeと比べられる場合が多いですね。なので、FlutterともGoogle Trendで比較してみることにします。結果としてはReact nativeと比べFlutterが優勢な気がしています。&lt;/p>
&lt;script type="text/javascript">
trends.embed.renderExploreWidget(
"TIMESERIES",
{
comparisonItem: [
{ keyword: "react native", geo: "", time: "today 5-y" },
{ keyword: "flutter", geo: "", time: "today 5-y" },
],
category: 0,
property: "",
},
{ exploreQuery: "date=today%205-y&amp;q=react%20native,flutter", guestPath: "https://trends.google.com:443/trends/embed/" }
);
&lt;/script>
&lt;p>理由として上げられるのは、どちらもiOSとAndroidアプリを同時開発できるものであるという点を踏まえると、やはりパフォーマンス問題ではなかったのかという気がします。React Nativeでは、JavaScriptからネイティブコードを呼び出すという構造から必然的にボトルネックになるしかないと言われていますので。そして、あくまで推測なのですが、Dartという別の言語を採用していながらも、JavaやC#のような言語とかなり文法が似ていて、HTMLやXMLとは違う宣言型でのUIの実装ができるというところも、Flutterならではのメリットなのではないか、という気もします。&lt;/p>
&lt;p>もし自分がモバイルアプリを作るとしたら、おそらくネイティブになる可能性が高いのではないかとは思いますが(ハイブリッド・クロースプラットフォームが必要であれば、大抵Web基盤のアプリで事足りそうなので)、場合によってはハイブリッド・クロースプラットフォームも良い選択肢になるでしょう。そしてFlutterはモバイルだけでなく、より多くのプラットフォームのためのフレームワークとして成長していく予定なので、もし今から学ぶとしたらFlutterの方が良いかもしれません。もちろん、Reactがすでにできるフロントエンドエンジニアだとしたら、React Nativeの方が良いとは思いますが、それ以外の場合はやはりFlutterの方が良さそうな気がします。なので、当面はFlutterを視野に入れておきたいものです。&lt;/p>
&lt;p>そのほかに、React Nativeに関しては興味深い記事がいくつかあったので、いくつかの事例を以下に記載します。&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c" target="_blank" rel="noopener"
>React Native at Airbnb&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://engineering.udacity.com/react-native-a-retrospective-from-the-mobile-engineering-team-at-udacity-89975d6a8102" target="_blank" rel="noopener"
>React Native: A retrospective from the mobile-engineering team at Udacity&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://qiita.com/taneba/items/9903064aaaffdf041022" target="_blank" rel="noopener"
>React Nativeを採用すべきか〜Shopifyに学ぶ&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="ハードウェア">ハードウェア&lt;/h2>
&lt;h3 id="apple-silicon-mac">Apple silicon Mac&lt;/h3>
&lt;p>私はもともと20年ほどOSはMicrosoftの製品ばかりを使ってきたものです。それがたまたま、iPhoneやiPadから初めてAppleの製品に触れてから思ったよりも自分との相性がよかったので(仕事でLinuxを使っていたので気軽にターミナルを使えるという点が大きいのですが)、今後も引き続きMacを使いたいと思っています。少なくとも、自分の環境ではMacではないと困ることはあっても、Windowsでないと困ることはあまりないですので。&lt;/p>
&lt;p>なので、自然にApple Silicon Macにも興味を持ったわけなのですが、やはりいきなりCPUのアーキテクチャが変わるということは、やはり互換性を担保できない問題があるので、その問題に対してAppleはどのような形で解決策を出すのだろう、という疑問を持っていました。発表直後に&lt;a class="link" href="https://jp.techcrunch.com/2020/07/11/the-real-reason-why-apple-is-putting-apple-slicon-on-the-mac" target="_blank" rel="noopener"
>色々な記事&lt;/a>を読んでみてから予想できたのは、少なくとも「性能(演算・発熱・電力消耗を含め)はIntelより優れている」というところでしたが、それはアーキテクチャがより進んだ工程で作られているからか、それともカスタマイズによるものか、またどれだけ優れているかというのはわからない状態でした。なので「2年で移行する」という話を信じ、まずは様子を見ようとしていました。&lt;/p>
&lt;p>そして今はM1チップのMacが色々とでていて、その性能も検証されていますね。確かなのは性能だけを見ると既存のIntel Macを買う理由はもはやないかのように見えます。さすがに互換性という不安要素があるのに、CPUのアーキテクチャを変えるという宣言をするぐらいのものではあると思います。しかし、やはりエンジニアたる身としては、互換性と安定性にまず目が行くものです。なぜなら、私は最初のメジャーバージョンは必ず、何かわかってない問題を抱えている可能性が高いというのを経験で実感しているからです。実際、Bluetooth問題や初期化が難しい点、スリープモードから起き上がらない問題などが一部で報告されていて、外装ディスプレイも公式的には1台しか対応しないという問題もあります(おそらく、Thunderbolt 3の大域幅の問題なのではないかと思います)。また、続々とUniversalバイナリやM1 Nativeでコンパイルされたアプリも発表されていますが、やはりまだそうではないアプリもたくさんあるので、不安ではありますね。&lt;/p>
&lt;p>しかし、それでもいつかはApple Siliconに全てのMacが転換されるだろうし、いますぐM1チップ搭載モデルを購入しないとしても、十分注目する価値はあるのではないかと思っています。いや、注目だけでなく、今年は16インチMacbook Proのフルチェンジの噂もあるので、もしそれが本当なら自分も乗り換えるのではないかと思っているくらいです。もしそれが出るなら、M1チップ搭載モデルの問題としてあげられたところを改善(少なくとも、外装ディスプレイの件や&lt;a class="link" href="https://9to5mac.com/2021/01/21/macos-big-sur-11-2-rc-now-available" target="_blank" rel="noopener"
>Bluetooth問題&lt;/a>は改善されそうです)されるはずで、今のアプリケーションのM1 Native対応の速度を見ると年内には意外と多くのアプリをNativeに使えるのではないかと思われます。まだまだこれからが注目なのですが、JavaScript中心の開発を行う方にとっては今のM1搭載モデルも十分メリットがあるのではないかと思います(AdoptOpenjdkはまだx64のみなので私は見送りですが…)。また、最近&lt;a class="link" href="https://www.theverge.com/2021/1/21/22242107/linux-apple-m1-mac-port-corellium-ubuntu-details" target="_blank" rel="noopener"
>M1搭載モデルでLinuxを使える&lt;/a>ようになったので、ホームサーバとしてこれらのMacを考慮してみるのも良いチョイスかと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>まだJavaとSpringも全ての機能を使いこなしているとも言えない自分が、今から新しい言語やフレームワークを学ぶという計画を立てるのは無理な話なのかしれません。これはいつも悩ましい主題です。一つの言語に関する知識やスキルを極めていった方が良いか、それとも常にトレンドを追いながら幅広い分野のスキルセットを持つべきか。深い知識も、広い知識も持っていて良いものではありますが、自分がこれから積み上げるキャリアを完成するにはどれがより効率的かという疑問は解消されないものです。&lt;/p>
&lt;p>自分なりの答えを出すとしたら、トレンドを追った方が、より自分の持つスキルセットの深さを増して行く方にも作用するのではないかという気はします。JavaしかできないものなのでJavaのAPIを借りて例え話をすると、Java 1.8では他の言語の持つClosureから影響されてLambdaが導入されましたね。その他にもvarの型推論やテキストブロックなどの改善もまた違う言語から影響されたものです。このような変化は、そもそもJavaの開発者たちが他の言語に注目しなかったら起こらなかったことでしょう。なので、「他と比較することで自分をより深く理解することにもなる」のではないでしょうか。そういう意味からすると、自分がすでに持っているスキルセットのみでなく、業界の動向や流行りを早くキャッチして受け入れることこそ重要ではないかと思ったりもします。&lt;/p>
&lt;p>この度はだいぶ主観的な意見だけ語る場となってしましましたが、どうでしょうか。またこれから自分の考えも、トレンドも変わっていくかもしれませんが、今は私の結論が紹介できただけでよかったかなと思います。そして、こうやって色々と自分の知らない分野について調べたり勉強したりするほど、自分には何もないなと実感でき、良い刺激になります。これからも色々と勉強していかないとですね。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>GETとPOSTの間</title><link>https://retheviper.github.io/posts/get-or-post/</link><pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/get-or-post/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.jpg" alt="Featured image of post GETとPOSTの間" />&lt;p>&lt;a class="link" href="https://developer.mozilla.org/ja/docs/Web/HTTP/Methods" target="_blank" rel="noopener"
>MDNの説明&lt;/a>によると、HTTPメソッドは主に「リソースに対する」ものだと定義しています。なので書くメソッドの説明としても、GETならリソースの表現、POSTならリソースの作成、PUTならリソースの置き換え、DELETEならリソースの削除のような表現をしていますね。これを元に、CRUDの基本を説明するような資料も多く、学習者は自然にAPIのデザインはリソースの作成、参照、置き換え、削除を基準に考えることになります。あとはリクエストに対する処理が&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%86%AA%E7%AD%89" target="_blank" rel="noopener"
>冪等&lt;/a>であるかどうか、というのが重要ですね。&lt;/p>
&lt;h2 id="理論--現実">理論 != 現実&lt;/h2>
&lt;p>しかし、理論的にはそうだと認識していても、実際の業務をアプリケーションとして表現していくと、悩ましい場合があります。今回がそうです。「リソースを単純に返すだけに見えるけど、実際は内部的にリソースの作成や修正が伴う処理の場合はどうするか」という疑問がありました。なぜなら、このような要件があったからです。&lt;/p>
&lt;ul>
&lt;li>クライアントにとあるファイルのダウンロードを提供するAPIがある。&lt;/li>
&lt;li>サーバからのファイルの取得には以下の二つのケースがある。
&lt;ul>
&lt;li>ファイルがすでに作成されていて、サーバはそのファイルをクライアントに返すだけ。&lt;/li>
&lt;li>リクエストに応じて、サーバがDBのレコードをファイルに書き込み(作成し)クライアントに返す。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>クライアントがファイルをダウンロードすると、サーバはDBを更新する。
&lt;ul>
&lt;li>サーバはDBに「ファイル出力済み」というフラグと、「更新ユーザ」としてログインユーザの情報を登録する。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>「ファイルがすでに作成されていて、サーバはそのファイルをクライアントに返すだけ」だと、GETでことは済みます。クライアントの観点からしてもそうであって、サーバもすでにあるリソースを返すだけですね。これは一般的にGETに期待する、「リソースの表現」に合致していて、何の問題もないです。&lt;/p>
&lt;p>しかし、「リクエストに応じて、サーバがDBのレコードをファイルに書き込みクライアントに返す」の場合はどうでしょうか？ファイルを新しく作成するのは、「リソースの作成」に当てはまるのでしょうか？それとも、レコードとしてすでに存在しているので、ただ違う形に加工するだけであって「リソースの表現」に当てはまるのでしょうか。または、ファイルの要請だけでなく、クライアントが提供した情報を持ってDBの更新を行うので、「リソースの作成」に当てはまるのでしょうか。&lt;/p>
&lt;h2 id="誰の観点から見るべきか">誰の観点から見るべきか&lt;/h2>
&lt;p>以上の問題は、自分の観点、つまり、バックエンドエンジニア及びアプリケーションとしての問題でもあります。ならば、クライアント(ユーザ)からしてみるとどうでしょうか。以下のことを考えられます。&lt;/p>
&lt;ul>
&lt;li>クライアントはファイルがすでに作成されているか、作成してくれるかに興味がない。
&lt;ul>
&lt;li>リクエストは「ファイルをくれ」であり、「ファイルを作ってくれ」ではない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>クライアントのリクエストに合わせてファイルを作成するかしないかはサーバ(アプリケーション)の都合である。
&lt;ul>
&lt;li>クライアントはファイルを要請するだけであり、中の処理についてはわからない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>つまり、クライアント側からすると、ファイルをダウンロードするという行為に関しては、あくまで「リソースの表現」を要請することに過ぎなくなります。サーバサイドとはまた都合が違いますね。こういう場合は、どちらの都合に合わせるかは明白ではないでしょうか。優先すべきは、クライアントですね。なぜなら、アプリケーションはそもそもクライアントの要件のために存在するものであるからです。なので、サーバサイドの都合でリクエストをPOSTにする理由はなくなりますね。&lt;/p>
&lt;h2 id="specでは">Specでは&lt;/h2>
&lt;p>ただ、クライアント側の観点枯らして、こういう場合はGETが正しい、と決めつけるにはまた違う根拠がいるのではないでしょうか。例えばHTTPの標準とかです。ちょうど、HTTPのスペックに関する文には、&lt;a class="link" href="https://tools.ietf.org/html/rfc7231#section-4.2.1" target="_blank" rel="noopener"
>以下のような章&lt;/a>があります。&lt;/p>
&lt;blockquote>
&lt;p>4.2.1. Safe Methods&lt;/p>
&lt;blockquote>
&lt;p>Request methods are considered &amp;ldquo;safe&amp;rdquo; if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource. Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server.&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;p>4.2.1 安全なメソッド&lt;/p>
&lt;blockquote>
&lt;p>クライアントがサーバの状態を変えない、変わることを期待しない読み込み専用のリクエストは、「安全」とされる。安全なメソッドを正しく使うことによりサーバにとって害や損となるような事情を発生させなくなる。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;p>これを見ると、クライアントのリクエストによりサーバに何かリソースの変化をもたらすようなことになる場合は、GETではなさそうが気がします。しかし、重要なのはこの次の内容です。&lt;/p>
&lt;blockquote>
&lt;blockquote>
&lt;p>This definition of safe methods does not prevent an implementation from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method. What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it. For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server.&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;blockquote>
&lt;p>安全なメソッドが、完璧な読み込み専用でなかったり、副作用を伴うなどで害を招くような実装を防止するわけではない。大事なのは、その動作はクライアントの要請ではなく、責任もまたクライアントにないということである。例えば、多くのサーバはどんなメソッドに対してもアクセスログを記録するが、ログによってサーバのストレージが足りなくなりサーバに障害が生じることもあり得るが、こういう場合でもリクエストは安全とする。&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;p>つまり、大事なのは実装上の都合はあくまでサーバサイドの責任であって、クライアントからの行為であるということですね。安全なリクエストのためには、クライアントのリクエストがどのようなものであるかを考えるべき、という結論になります。HTTPメソッドはそういう行為の本質を表すものであり、サーバの都合の表現ではない、ということですね。なのであくまでクライアントからして、「リソースの表現」に対する要請であれば、サーバはGETとして応じるベキになるかと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>実際のウェブサイトを観察してみても、純粋な「リソースの表現」としてのGETはあまりないような気もしています。例えば訪問するだけで「訪問者カウンター」が更新されるサイトがあったりしますね。こういう場合でもクライアントはリソースの作成やリソースを要請してなく、サーバ側で勝手に更新を行っていますが、依然としてGETとされまていて、違和感もないです。むしろこのようなリソースの変更全てをPOSTとして扱うようになるとしたら、GETを使う場面自体がなくなるかもしれません。&lt;/p>
&lt;p>ただし、注意しなくてはならないのが、リソースの作成や更新を伴うリクエストを全てGETにするという発想も危険であることです。リソースの扱い方という原則に戻って考えたら、「POSTで作成させた後、GETで取得させる」というやり型もあるのかもしれません。こういう場合は2回のトランザクションが発生するので性能面では劣るかもしれませんが、場合によってはより安全な設計になる可能性もありますね。&lt;/p>
&lt;p>なので「全てのケースに置いて」ではなく、アプリケーション全体の設計や今後の方向性を考慮した設計として適切なHTTPメソッドを選んだ方が良い、というのが結論になるかと思います(原論的な話ですが)。重要なのは、「こういう場合は絶対GETだ」、「こういう場合は絶対POST」だと言わないことですね。&lt;/p></description></item><item><title>静的ウェブページに興味を持つ</title><link>https://retheviper.github.io/posts/static-web-page/</link><pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/static-web-page/</guid><description>&lt;img src="https://retheviper.github.io/images/tools.jpg" alt="Featured image of post 静的ウェブページに興味を持つ" />&lt;p>今更な話ですが、主にバックエンドの仕事をしてきたエンジニアとしては(特に、Springが全てを占拠してしまったJavaがメインな立場からは)、昨今のフロントエンドの世界を見ていると、一瞬よそ見しただけでもすぐに時代遅れな人間になってしまうような気になります。それだけさまざまなライブラリ、フレームワーク、設計思想、プラットフォームが現れ消えていくので、これからどれを学んでおくべきかわからなくなります。&lt;/p>
&lt;p>例えばアプリの設計思想だと、SPA&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>がトレンドになっているものの、&lt;a class="link" href="https://webassembly.org" target="_blank" rel="noopener"
>WASM&lt;/a>の登場でPWA&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>も登場し始めています。JavaScriptのフレームワークでは、「Virtual DOMを使用するので早い」という、&lt;a class="link" href="https://angular.io" target="_blank" rel="noopener"
>Angular&lt;/a>・&lt;a class="link" href="https://reactjs.org" target="_blank" rel="noopener"
>React&lt;/a>・&lt;a class="link" href="https://vuejs.org" target="_blank" rel="noopener"
>Vue.js&lt;/a>が今の通称「3強」となっていますが、「DOMを直接更新するから早い」という&lt;a class="link" href="https://svelte.dev" target="_blank" rel="noopener"
>Svelte&lt;/a>もあります。&lt;a class="link" href="https://nodejs.org" target="_blank" rel="noopener"
>Node.js&lt;/a>は失敗したという&lt;a class="link" href="https://deno.land" target="_blank" rel="noopener"
>Deno&lt;/a>が登場しているし、今の&lt;a class="link" href="https://www.typescriptlang.org" target="_blank" rel="noopener"
>TypeScript&lt;/a>の位置を目指したが失敗したと思われた&lt;a class="link" href="https://dart.dev" target="_blank" rel="noopener"
>Dart&lt;/a>は、&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>や&lt;a class="link" href="https://fuchsia.dev" target="_blank" rel="noopener"
>Fuchsia&lt;/a>で再起できているようにも見えますね。&lt;/p>
&lt;p>このように、フロントエンド系は新しい概念と技術の氾濫で混乱な状況ですが、面白くも、トレンドと逆行するような形のWebアプリ、いや、Webサイトの構築に関する概念もそれなりの割合を示しているように見えます。本日のポストのテーマである、「静的ウェブページ」です。&lt;/p>
&lt;h2 id="静的ウェブページstatic-web-pageとは">静的ウェブページ(Static Web Page)とは&lt;/h2>
&lt;p>「静的」であるということは、「動的」と区分される特徴があるということでしょう。ここでいう動的か静的かというのは、入力によって何かの処理が行われるか、もしくは常にサーバに保存されたデータをそのまま返すかががもっとも重要な基準となっているようです。例えばWikipediaでは以下のように定義しています。&lt;/p>
&lt;blockquote>
&lt;p>A static web page (sometimes called a flat page or a stationary page) is a web page that is delivered to the user&amp;rsquo;s web browser exactly as stored, in contrast to dynamic web pages which are generated by a web application.&lt;/p>
&lt;/blockquote>
&lt;p>言い方を変えると、サイトが「アプリケーション」として作られたものならば動的、もしくはただの固定されたデータを表示するための「ページ」であるなら静的といえますね。&lt;/p>
&lt;h2 id="なぜ今更">なぜ今更？&lt;/h2>
&lt;p>サーバに保存されたデータをそのまま返すという概念は、 Webアプリケーションが登場する前から存在していました。当時のウェブサイトはhtmlとcss、イメージなどのリソースをFTPなどでサーバにアップロードしてホスティングを行っていたのですが、これは今の静的ウェブページにとっても同じ方式です。&lt;/p>
&lt;p>つまり、概念だけを見ると静的ウェブページは昔に流行っていた「ホームページ」や「ブログ」などに近いものです。時代に逆行するような、静的ウェブページが今更注目されるのは、なぜか。&lt;/p>
&lt;p>当たり前ながら、当時とは違って、JavaScriptの発展によりサーバに依存しなくても簡単な処理はブラウザでできるようにもなり、適切なAPIがあればバックエンドを実装する必要がなくなるのもあり、AWS LambdaやAzure Functionsのようなサービスによりサーバレスができる環境ができるなど、バックエンドよりはフロントエンドの目的によって選択できる方法が多くなったという点があるでしょう。&lt;/p>
&lt;p>そして、もっとも根本的な、サイトの目的がありますね。ブログ、ポートフォリオ、イベント案内などそもそも「大した処理が必要ない」サイトに関しては、静的にしたほうがリソース使用、費用、パフォーマンス、セキュリティという面で動的ウェブページより有利です。例えば今このブログみたいにですね。&lt;/p>
&lt;p>最近はMarkdownなどで文書を書くと、それを元に静的ウェブページを作成してくれるツールもたくさんあり、そのようなツールで生成したデータを載せるだけでホスティングする方法も多いです。自分でソースを管理できて、簡単にホスティングできるのである意味ではもっとも静的ウェブページを作り安い時代となったとも言えますね。&lt;/p>
&lt;h2 id="静的ウェブページを作られるツール">静的ウェブページを作られるツール&lt;/h2>
&lt;p>多くの場合、静的ウェブサイトの生成ツールの使用は難しくありません。ベースになっている言語の実行環境を構築して、テンプレートをダウンロードして適用するか、作っていくかなのですが、ツールを実行するための環境の構築はツールのホームページの手順通りでよく、テンプレートも人の作っておいたものを持ってきて少し修正するくらいです。簡単な修正なら、HTML、CSS、JSON、YAMLくらいのファイルをいじるだけなので(プロパティファイルで色々なオプションを選択できる例もあります)、難しくありません。あとはMarkdownなどで記事を書いていくだけですねß。&lt;/p>
&lt;p>ただ、自分の経験からだと、既製のテンプレートを大きく変えるか、最初から作り直す場合は自分が触ることのできる言語をベースにしておいた方が良いということですね。例えばこのブログは&lt;a class="link" href="https://jekyllrb.com" target="_blank" rel="noopener"
>Jekyll&lt;/a>で作られていて、テンプレートも一部修正していますが、そもそも私はRubyに慣れてないので根本的な部分を修正してはいないところです。&lt;/p>
&lt;p>Jekyll以外には、Nodejs基盤のツールが多いようです。例えば&lt;a class="link" href="https://metalsmith.io" target="_blank" rel="noopener"
>Metalsmith&lt;/a>や、&lt;a class="link" href="https://hexo.io" target="_blank" rel="noopener"
>Hexo&lt;/a>のような物があって、React基盤の&lt;a class="link" href="https://www.gatsbyjs.com" target="_blank" rel="noopener"
>Gatsby&lt;/a>、Vue.js基盤の&lt;a class="link" href="https://vuepress.vuejs.org" target="_blank" rel="noopener"
>VuePress&lt;/a>もあります。JavaScriptとそのフレームワークの使用に慣れているなら、こちらがいいかもしれませんね。他には、Go言語基盤の&lt;a class="link" href="https://gohugo.io" target="_blank" rel="noopener"
>Hugo&lt;/a>もありますので、Goに慣れている方ならこちらを選択することもありですね。&lt;/p>
&lt;h2 id="静的ウェブページを載せられるプラットフォーム">静的ウェブページを載せられるプラットフォーム&lt;/h2>
&lt;p>ツールを使って、静的サイトを作ったら、次はホスティングが必要となりますね。静的ウェブページのホスティングの場合、このブログでも使用している&lt;a class="link" href="https://pages.github.com" target="_blank" rel="noopener"
>GitHub Pages&lt;/a>や&lt;a class="link" href="https://www.netlify.com" target="_blank" rel="noopener"
>netlify&lt;/a>のようなサービスがあり、データをGitなどでアップロードすると自動でビルドとデプロイが完了される便利さがあります。&lt;/p>
&lt;p>他にはクラウドを利用する方法があります。AWSやAzure、Google Cloud Platformのようなクラウドサービスには、&lt;a class="link" href="https://aws.amazon.com/s3" target="_blank" rel="noopener"
>S3&lt;/a>や&lt;a class="link" href="https://azure.microsoft.com/ja-jp/services/storage/blobs" target="_blank" rel="noopener"
>Blob&lt;/a>のようにウェブからアクセスできるストレージサービスが必ずありますが、このストレージにツールで作成した静的サイトをアップロードしてホスティングする方法もあります。特にGoogleのサービスの場合、&lt;a class="link" href="https://firebase.google.com" target="_blank" rel="noopener"
>Google Firebase&lt;/a>というアプリ開発に特化したプラットフォームもあるのでAPIとの連携が必要な場合は考慮できる候補ではないかと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>ここでは単にツールとプラットフォームを紹介(というより、言及)しただけですが、静的ウェブページでできることや活用できるものは、他にも多いようです。同じ静的ウェブページだとしても、どのような技術の組み合わせでどのような物が作り上げられるかがかなり変わってくるのですが、実際にどんな物ができるかは&lt;a class="link" href="https://jamstack.org" target="_blank" rel="noopener"
>JAMstack&lt;/a>のExamplesタブから色々発見できますので、参考にしてみてください。&lt;/p>
&lt;p>個人的にはGatsbyに興味があって、Reactの勉強のついでに、いつかポートフォリオのためのサイトをそれで作り上げてみようかなと思っています。Oracleクラウドだと無料のVMやDBも提供されるので、簡単なAPIを作成しておくのも可能になるかもしれませんね。いや、いい時代になったものです。皆さんもぜひ、静的ウェブページで自分だけのサイトを築き上げてみてください。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Single Page Applicationの略で、従来のWebアプリケーションが複数の画面で構成されていたことに対して、画面を一つにして開発の効率やパフォーマンスの向上を図ったWebアプリケーションのこと。画面がサーバサイドと分離されているため、バックエンドとして選択できるものの幅が広いという特徴もあります。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Progressive Web Applicationの略で、Webアプリでありながらもネイティブアプリならではのメリット(パフォーマンスが高い、インストールすることでオフラインでも利用可能)を採用したアプリケーションのことを指します。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>最近注目しているものたち</title><link>https://retheviper.github.io/posts/personal-interests-in-this-time/</link><pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/personal-interests-in-this-time/</guid><description>&lt;img src="https://retheviper.github.io/images/magic.jpg" alt="Featured image of post 最近注目しているものたち" />&lt;p>常に勉強し続けなければならないのがこの業界の定めとは思いますが、変化は日々加速されていて、何に従って何を頼れば良いかわからない時もありますね。新しい言語が続々登場してくるなかでも、昔は性能の問題で注目されてなかった言語がいきなり人気を得たり、当たり前と思っていたパラダイムがひっくり返されたりもします。今はJavaScriptの時代と行っても過言ではない状況に来ていると思いますが、今後はどうなるのでしょうか。いくつか、個人的に興味をもったIT業界の動向についてまとめてみました。&lt;/p>
&lt;h2 id="apple-silicon-mac">Apple Silicon mac&lt;/h2>
&lt;p>こないだ、Appleの開発者向けイベントである&lt;a class="link" href="https://developer.apple.com/videos/play/wwdc2020/101" target="_blank" rel="noopener"
>「WWDC2020」&lt;/a>が開催されました。毎年必ずライブで見ているわけではないのですが(深夜に始まるので…)、最近はテレワークをしていて通勤時間がなくなっているのもあり、最初から最後までライブで見ることができました。&lt;/p>
&lt;p>iOSやiPadOS、macOSの変化ももちろん興味深かったのですが、やはり今回のイベントで最も印象的なものがなんだったかというと、macのメインプロセッサが&lt;a class="link" href="https://www.apple.com/newsroom/2020/06/apple-announces-mac-transition-to-apple-silicon" target="_blank" rel="noopener"
>Apple製のものに変わる&lt;/a>ということでしたね。自分はPowerPC時代のmacは経験したことがありませんが、PPCからIntelへの転換は成功的だったので、今回もそうなると思います。個人的にiPadも使っているのですが、あまりIntelのCPUに比べ性能が劣るという印象は受けたこともありませんでした。&lt;/p>
&lt;p>もちろん、Bootcampを使えなくなることもあり、他にもx86を基盤に作られたサードパーティアプリケーションが使えなくなる可能性もあるので、新しいプロセッサのmacが今年発売したところですぐに使っているmacを買い換えるつもりはありません(高いし…)。でも、以前から&lt;a class="link" href="https://llvm.org" target="_blank" rel="noopener"
>LLVM&lt;/a>や&lt;a class="link" href="https://developer.apple.com/mac-catalyst" target="_blank" rel="noopener"
>Catalyst&lt;/a>のように、違うプラットフォーム(プロセッサ)でも問題なくアプリが起動できるような環境を構築するために何年も投資しているのを見ると、意外と転換は早く、問題なくできるのではと思います。特に自分はWebアプリを書くだけなので、あまりlow levelの技術に触れることもなく、使っている言語のコンパイラが新しいプロセッサに対応してくれれば良いだけですね。実際WWDCの紹介でも、xcodeで作成したプロジェクトは再度ビルドするだけで良いと言ってました。&lt;/p>
&lt;p>ただ気になるのは、自分のIntel製CPUを搭載しているmacに対してのOSのサポートがいつまで続くか、くらいですかね。最近はWindowsの発展もすごいのですが、自分の環境だとあまりWindowsにこだわる必要はないので問題なく転換できそうな気もします。そしてプロセッサのみではなく、SoCなのですでにiPadやiPhoneに適用されているさまざまなセンサーやニューラルエンジンなどを使えるのも大きいメリットと思います。&lt;/p>
&lt;p>ただ、こういう感想はあくまで開発者としての自分の立場から考えた個人レベルの問題で、エンタプライズレベルだといくら&lt;a class="link" href="https://www.apple.com/newsroom/2020/06/apple-announces-mac-transition-to-apple-silicon" target="_blank" rel="noopener"
>Rosetta2&lt;/a>や&lt;a class="link" href="https://developer.apple.com/documentation/xcode/building_a_universal_macos_binary" target="_blank" rel="noopener"
>Universal Binary2&lt;/a>が優秀だとしてもどこかで互換性や性能の問題は起こり得ると思うので要注意とは思います。Officeのデモンストレーションは、今よりもパフォーマンスが優れているように見えたのでよかったのですが、事務職の人があえてmacを使う理由はそもそもないので…&lt;/p>
&lt;p>他、すでに$500でA12Zを搭載したmacを借りることができるようなので、意外とすぐに新プロセッサmacの性能や互換性問題は明らかになるかもしれませんね。まずはそこに注目かな、と思っています。性能のみならず、作業時の温度や電力消費量もどれだけ改善されたか、知りたいところですね。来週あたりでベンチマークを見れるのではないかと思っています。&lt;/p>
&lt;h2 id="deno">Deno&lt;/h2>
&lt;p>JavaScriptはあまり触ってないので、Node.jsにも詳しくないわけですが、やはり昨今のWebアプリだとNode.jsなしでは話にならない時代になっていますね。自分の場合はTypeScriptの方でJavaScriptよりも良い印象を受けたので、NodeでもネイティブなTypeScriptサポートができるといいなと思っていました。それが、Nodeの開発者によって&lt;a class="link" href="https://deno.land" target="_blank" rel="noopener"
>Deno&lt;/a>という新しいランタイムが登場したらしいです。&lt;/p>
&lt;p>基本的にNodeでの反省点(async/awaitのような？)から作っているもののようで、その他にも特徴としてはTypeScriptのコンパイラを内蔵していて、いちいちコンパイルしなくても(JavaScirptにトランスパイルしなくても)使えるというところが自分にとっては最大のメリットのように思われます。&lt;/p>
&lt;p>ただDenoの問題だと、やはり既存のNode.js用モジュールを使えない、というところと、TypeScriptのコンパイルが遅いというところがあげられています。Rustを使って自体のTypeScriptコンパイラを作るという計画があるらしいですが、いつになったら完成できるかわからないのでしばらくDenoを使ったプロジェクトはあまり発券できないかもですね。&lt;/p>
&lt;h2 id="blazor">Blazor&lt;/h2>
&lt;p>5月には&lt;a class="link" href="https://news.microsoft.com/build2020" target="_blank" rel="noopener"
>「Microsoft Build 2020」&lt;/a>にて、&lt;a class="link" href="https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-now-available" target="_blank" rel="noopener"
>Blazor WebAssemblyのリリース発表&lt;/a>がありました。これで.NETとC#による、ブラウザから実行可能なWebアプリケーションを作成できるらしいです。&lt;/p>
&lt;p>Node.jsを使ったWebアプリケーションのメリットとして、よく「一つの言語でサーバサイドとクライアントサイドの両方を開発できる」ことがあげられていますが、このようにJavaScriptを使わなくてもそれが可能になるようなフレームワーク＆ランタイムが登場することもあるのですね。JavaScirptも良い言語ですが、そもそもの限界が明確なので、C#のようなコンパイル言語をブラウザ上で使えるのは逆のパターン(JavaScriptをサーバサイドで使う)に比べ良いところが多いのではないかと思います。&lt;/p>
&lt;p>また、BlazorファミリーとしてPWAの実装ができるBlazor PWA、ElectronとWebViewでのデスクトップアプリが実装できるBlazor Hybrid、HTML要素なしでネイティブアプリが実装できるBlazor Nativeも続々登場する予定だというので、これに刺激を受け他のコンパイル言語でもブラウザで実行できるようになるのではないかと思います。&lt;/p>
&lt;p>WSLやGitHubもありますが、いろいろな意味で最近のMicrosoftの変化と投資はすごいものですね…&lt;/p>
&lt;h2 id="flutter-for-web">Flutter for web&lt;/h2>
&lt;p>iOSとAndroidの二つのプラットフォームのアプリを同時に開発でき、同じく機能するReact Nativeに比べ性能でもネイティブアプリに劣らないことがメリットという&lt;a class="link" href="https://flutter.dev" target="_blank" rel="noopener"
>Flutter&lt;/a>ですが、最近Flutterを利用したWebアプリケーションも続々登場しているようです。そもそもFlutterを書くための言語である&lt;a class="link" href="https://dart.dev" target="_blank" rel="noopener"
>Dart&lt;/a>が、次世代JavaScirptを目標に開発されたものなのでおかしいことではないのですが、こうやって一つの言語でモバイルとWebアプリケーションの両方を開発できるということはBlazorの場合と同じく魅力的です。&lt;/p>
&lt;p>ただ、Googleが開発しているというところから、DartではなくKotlinでよかったのでは？という気持ちはありますね。また、自社のサービスをすぐ見捨てる傾向のあるGoogleなのでいつまでFlutterが生き残ることができるか、ということも疑問として残っています。MicrosoftのXamarinがいまいちになっているので、モバイルだけはFlutterを採用して開発するようなこともあるのではないかと思いますが、Webアプリケーションを開発するとしたらC#を利用できるBlazorの方がより魅力的ではないかと思います。&lt;/p>
&lt;h2 id="rust">Rust&lt;/h2>
&lt;p>ポストC、C++として注目されている&lt;a class="link" href="https://www.rust-lang.org" target="_blank" rel="noopener"
>Rust&lt;/a>ですが、最近はこの言語の人気が恐ろしいほどですね。まだエンタプライズレベルでは、既存に構築しているシステムや熟練されたエンジニアがいないなどの理由でRustが使われているケースはあまりないようですが、CやC++と同等のパフォーマンスを見せながらも安定的という面が最大のメリットと言われているらしいです。&lt;/p>
&lt;p>個人的にはWebアプリケーションレベルであまりシステムと直接関わるようなことをする場合はないのですが、PWAの登場などWebアプリケーションでもデスクトップ並みの性能を求められることがあったり、Javaでは直接扱うことのできないバイナリファイルの扱いなどで限界を感じていたりしているので、Rustのような言語が扱えたらより良いアプリケーションを作れるようになるのでは、と思っています。&lt;/p>
&lt;p>特に、コミュニケーションツールとして有名な&lt;a class="link" href="https://discord.com" target="_blank" rel="noopener"
>Discord&lt;/a>がもともと使っていた&lt;a class="link" href="https://golang.org" target="_blank" rel="noopener"
>Golang&lt;/a>をあえてRustに交替したとの記事もあったので、同じくCとC++の代替言語として開発されたGolangさえも圧倒するメリットとは一体何かという疑問が湧いてきて、ますます気になっているところです。最近人気のKotlinの場合も、おそらくJavaと完全互換できるという特徴がなかったら成功できなかったと思いますが、互換性もない言語に転換するほどRustが持っているメリットとは一体なんなのか、知りたいですね。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>いろいろな技術と変化があり、幸せのような、プレッシャーを感じるような複雑な気持ちではありますが、どれも肯定的な変化をもたらしてくれている、と思っています。特に、各言語の変化に関してはJavaのモットーである&lt;code>Write once, run everywhere&lt;/code>がどの言語でもより発展した形として実現されているところをみているようですね。結局どの言語も似たようなものになりつつあるような感覚もするのですが、逆にいうともうどの言語を使うかはあまり関係ない時代になりつつある気もします。&lt;/p>
&lt;p>なので、いったんはそのような変化についていけられるよう、自分のスキルを磨くことですね。どの言語を使うかがあまり重要ではなくなるということは、つまりその言語で何ができるかがより重要ということになると思うので、今の自分にできる言語を使ってさまざまな経験をしてみるのが優先すべきことではないかという気がします。あまり実装ができない最近ですが、個人的なプロジェクトでも進めながら経験してみたくなりました。&lt;/p>
&lt;p>では、また！&lt;/p></description></item><item><title>ブログ刷新</title><link>https://retheviper.github.io/posts/renew-blog-theme/</link><pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/renew-blog-theme/</guid><description>&lt;img src="https://retheviper.github.io/images/tools.jpg" alt="Featured image of post ブログ刷新" />&lt;p>この度は、ブログのテーマを新しく変えてみました。新しいテーマは&lt;a class="link" href="https://github.com/Simpleyyt/jekyll-theme-next" target="_blank" rel="noopener"
>NexT&lt;/a>です。一年がたってもあまりJekyllに慣れてないので思ったより苦労していますが(特に消えたページなどが気になります…)、それでも前のテーマと比べてかなりすっきりした感じが良いと思います。検索機能もついていたのでとりあえずアクティベートしてみましたが、ローカルでは機能してなかったのでGithub Pagesにあげてからテストですね。なるべく使いたい。(追記：残念ながら何かのバグのようで使えませんでした…)&lt;/p>
&lt;p>このブログを作ってからも1年が立ちます。最初のポストが1年前だったのですね。あの頃は入社したばかりの新人だったのでいろいろとわからない物だらけでした。なので書いていたポストの内容もいまいちな物が多かったと思います。最近はJavaを使っていろいろと開発はしているものの、あまり経歴が長いわけでもないので当時書いたポストをみているとなぜこのような恥ずかしいものを書いたんだろう、とも思います。&lt;/p>
&lt;p>それでもブログの更新を続けているのは、このブログが自分の勉強の記録であって、過去の自分が書いたコードや文面を振り返ってみることで新しい発見ができていたからです。時々過去のポストを振り返ってみることで同じことをしてもより良い方法、より安全な方法を探すことができました。修正したいものもかなり多いのですが、のちにそれを補えるようなポストを書いた方が自分のエンジニアとしての軌跡をちゃんと追える手段となるのではないかと思います。&lt;/p>
&lt;p>誰かに見せるにはかなり恥ずかしいブログですが、それでも訪問してくださる方々も増えました。おそらく私みたいに、何らかの問題と遭遇していたり他の誰かはどんな解決策を見つけたんだろうという好奇心から検索してみたりしている方々ではないかと思います。自分のコードや知識も正解とは言い切れないものなので、このブログを参考にしてくださいとおすすめはできませんが、エンジニアの仲間の一人として、こういう答えを探し出していたのでだなと受け止められれば幸いです。&lt;/p>
&lt;p>では、また何か勉強ができたら、ポストにてお伺いしましょう。これからもよろしくお願いします。&lt;/p></description></item><item><title>はじめに</title><link>https://retheviper.github.io/posts/new-start/</link><pubDate>Sun, 12 May 2019 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/new-start/</guid><description>&lt;img src="https://retheviper.github.io/images/tools.jpg" alt="Featured image of post はじめに" />&lt;p>まだSEになってからの日が浅いので、業界の動向や流行りの言語はおろか、プログラミングの基礎もまだわからないことが多いです。それでも仕事で学び、覚えられるようなことは多いので、それらの知識をただ頭に入れておくということは無理なのではないかと思います。日々新しい言語、フレームワーク、ライブラリーが登場している中、自分は今までの技術もまともに習得していないのです。それならばせめて、どこかに自分が触れたことのある知識をまとめ参考にしたい。そういう考えからブログを始めることにしました。&lt;/p>
&lt;p>人間の文明の発達の歴史は、記録によるものという話がありました。人類の持つ知識の総量が一人の脳内に収められないくらい膨大になってから、人間が考案した方法は外部媒体による記録であるということです。そのおかげで我々は代々受け継がれてきた知識に触れることができ、最初から知識を持ってなくても臨機応変できるようになったと私は思います。例えば、携帯が生まれてからは誰も人の電話番号を覚えなくなりました。それでも連絡できる人の数はむしろ増えましたね。つまり、知識の外部記録できるようになって、個人が持つ知識の総量よりは、時と場合に適合な知識を探し出す能力が大事な時代になったのではないかと思います。&lt;/p>
&lt;p>プログラミングの世界もそうではないかと思います。bash&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>は依然として強力なツールであり、GUIより便利な時もあります。しかし全てのコマンドを覚え、パスを入力することはあまり効率的ではないです。むしろ必要な時に適切なコマンドを入力できるかどうかの方がより重要なのではないでしょうか。そのためにコマンどを集めたスクリプトが現れ、今の時代は簡単にコピペするだけでその時必要な操作ができたらいいのではないかと思います。&lt;/p>
&lt;p>自分がブログに勉強したことをまとめる時もなるべくそのような使い方ができるようなポストになったらいいなと思います。例えばAというサーバからBというサーバにフォルダをコピーしたいというなら、ただSCPやRSYNCのようなコマンドを書くだけでなくssh認証をはじめとしてSCPとRSYNCの違いまで比べるという一連の流れとしての知識を残す。そのような情報が得られるようなブログになったらいいなと思っています。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Linuxだけに限らず、macOSのterminalやWindowsのPowershellなどを含め&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>