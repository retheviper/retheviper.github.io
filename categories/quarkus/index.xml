<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>quarkus on Korean-man in Tokyo</title><link>https://retheviper.github.io/categories/quarkus/</link><description>Recent content in quarkus on Korean-man in Tokyo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://retheviper.github.io/categories/quarkus/index.xml" rel="self" type="application/rss+xml"/><item><title>Quarkusを触ってみた</title><link>https://retheviper.github.io/posts/quarkus-first-impression/</link><pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate><guid>https://retheviper.github.io/posts/quarkus-first-impression/</guid><description>&lt;img src="https://retheviper.github.io/images/quarkus.jpg" alt="Featured image of post Quarkusを触ってみた" />&lt;p>Spring MVCは良いフレームワークではありますが、最近流行りの&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9" target="_blank" rel="noopener"
>マイクロサービス&lt;/a>には向いてないという批判もあります。理由としては、アプリの起動時間が遅い、サイズが大きい、メモリの使用量が多いなどの問題が挙げられていますね。アプリの起動速度が遅い場合は、変更があった場合の素早い反映が期待できません。アプリのサイズが大きいのとメモリ使用量が多いとインスタンスが増えれば増えるほどコストが高くなるということになりますね。また、これはマイクロサービスだけの話でもないです。サーバレスアプリで、あえてJavaScirptやPythonのようなインタプリタ言語を採用しているのも同じ理由があってこそですね。&lt;/p>
&lt;p>では、これらの問題はどうやって回避できるのでしょうか。そもそもの問題から考えると、全てが全てSpringに局限する問題でもないはずです。他のフレームワークに比べてSpringの起動時間が決して早いとは言えなかったり、メモリの使用量が多いという問題があるのは確かですが、JVMをベースにしている言語を使う限り、ある程度は仕方ない問題にも見えます。JVM言語においてはそのアプリの起動時間、サイズ、メモリ使用量のどれにもJVMが占める割合を含めて考える必要があるからですね。&lt;/p>
&lt;p>ただ、これらの問題を解決できる方法が全くないわけでもありません。今回紹介するのが、その答えとして開発されている&lt;a class="link" href="https://quarkus.io" target="_blank" rel="noopener"
>Quarkus&lt;/a>です。&lt;/p>
&lt;h2 id="quarkusとは">Quarkusとは&lt;/h2>
&lt;p>Quarkusは、&lt;a class="link" href="https://www.redhat.com/ja/technologies/linux-platforms/enterprise-linux" target="_blank" rel="noopener"
>RHEL&lt;/a>で有名なRed Hatが作ったJava用のウェブフレームワークです。公式ホームページの説明が何よりも正確だと思いますので、以下の文を確認してください。&lt;/p>
&lt;blockquote>
&lt;p>A Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM, crafted from the best of breed Java libraries and standards.&lt;/p>
&lt;/blockquote>
&lt;p>Javaのアプリを&lt;code>Kubernetes Native&lt;/code>として作成できる、というのがこのフレームワークの正体性です。Javaと説明していますが、もちろんKotlinのような他のJVM言語も使えるので、そのような言語を使っている場合でも導入を考えられます。&lt;/p>
&lt;p>ここで&lt;code>Kubernetes Native&lt;/code>という言葉が気になりますが、これは単純にコンテナを作ることに特化されている、という表現ではないと思います。Spring Boot 2.3から導入された&lt;a class="link" href="https://spring.io/blog/2020/08/14/creating-efficient-docker-images-with-spring-boot-2-3" target="_blank" rel="noopener"
>Docker Image作成機能&lt;/a>があり、Googleが提供している&lt;a class="link" href="https://github.com/GoogleContainerTools/jib" target="_blank" rel="noopener"
>Jib&lt;/a>のようなライブラリでいくらでもJavaアプリケーションをコンテナ化することができますし、そのほかにもコンテナを作る方法はいくらでもあります。なので、ここで&lt;code>Kubernetes Native&lt;/code>という表現をあえて使っているのは、Kubernetesに特化したものとして設計されているということを意味すると思った方が自然でしょう。&lt;/p>
&lt;p>では、一体何を持って&lt;code>Kubernetes Native&lt;/code>と言えるのでしょう。インフラストラクチャの観点でいう&lt;code>Kubernetes Native&lt;/code>は、Kubernetesだけで完結するアーキテクチャを指しているようです。Kubernetesで完結するということは、それに合わせて最適化しているということと同じ意味合いでしょう。アプリケーションの観点からしてもそれは大きく違わないはずです。まず、Quarkusでは以下のような特徴があると紹介されています。&lt;/p>
&lt;ul>
&lt;li>Nativeコンパイルができる&lt;/li>
&lt;li>起動速度が速い&lt;/li>
&lt;li>メモリ使用量が少ない&lt;/li>
&lt;/ul>
&lt;p>Nativeコンパイルができるということは、JVMを使用する必要がなくなるということなので、先に挙げた三つの問題を全部解消できます。だとすると、マイクロサービスやサーバレスのみでなく、コンテナ単位でのデプロイでもかなり有利になりますね。そして、JVMを使った場合でも他のフレームワークに比べて起動速度とメモリ使用量で優位にあると言われているので、これが本当だとNativeコンパイルしない場合でも十分メリットがあると思われます。&lt;/p>
&lt;h2 id="実際触ってみると">実際触ってみると&lt;/h2>
&lt;p>特徴として挙げられているもの全てが魅力的ではありますが、実際そのフレームワークを使ってみないとわからないこともあります。なので、ちょっとしたサンプルを作り触ってみました感想について少し述べたいと思います。&lt;/p>
&lt;h3 id="起動速度">起動速度&lt;/h3>
&lt;h4 id="spring-bootの場合">Spring Bootの場合&lt;/h4>
&lt;p>Springの起動速度は、DIしているクラスによって大きく異なるので、ここでは&lt;a class="link" href="https://start.spring.io" target="_blank" rel="noopener"
>Spring initializr&lt;/a>から以下の項目のみ設定したアプリケーションを使って起動してみました。&lt;/p>
&lt;ul>
&lt;li>Project: Gradle&lt;/li>
&lt;li>Language: Kotlin&lt;/li>
&lt;li>Spring Boot: 2.5.5&lt;/li>
&lt;li>Packaging: War&lt;/li>
&lt;li>Java: 11&lt;/li>
&lt;li>Dependencies: なし&lt;/li>
&lt;/ul>
&lt;p>そしてローカルでは、Oracle JDK 17を使って起動しています。気のせいかも知れませんが、Java 11を使っていた時より起動が早いような気がしますね。とりわけ、上記通りの設定を済ましたアプリを起動してみると、以下のような結果となりました。（ローカルマシンの情報は消しています）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> . ____ _ __ _ _
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /&lt;span style="color:#f1fa8c">\\&lt;/span> / ___&lt;span style="color:#f1fa8c">&amp;#39;_ __ _ _(_)_ __ __ _ \ \ \ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">( ( )\___ | &amp;#39;&lt;/span>_ | &lt;span style="color:#f1fa8c">&amp;#39;_| | &amp;#39;&lt;/span>_ &lt;span style="color:#f1fa8c">\/&lt;/span> _&lt;span style="color:#f1fa8c">`&lt;/span> | &lt;span style="color:#f1fa8c">\ \ \ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">&lt;/span> &lt;span style="color:#f1fa8c">\\&lt;/span>/ ___&lt;span style="color:#ff79c6">)&lt;/span>| |_&lt;span style="color:#ff79c6">)&lt;/span>| | | | | &lt;span style="color:#ff79c6">||&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>_| | &lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">)&lt;/span> &lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f1fa8c">&amp;#39; |____| .__|_| |_|_| |_\__, | / / / /
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> =========|_|==============|___/=/_/_/_/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c"> :: Spring Boot :: (v2.5.5)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:21.472 INFO 48844 --- [ main] com.example.demo.DemoApplicationKt : Starting DemoApplicationKt using Java 17 on Local.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:21.475 INFO 48844 --- [ main] com.example.demo.DemoApplicationKt : No active profile set, falling back to default profiles: default
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.058 INFO 48844 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.067 INFO 48844 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.068 INFO 48844 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.53]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.117 INFO 48844 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.118 INFO 48844 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 607 ms
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f1fa8c">2021-10-17 19:10:22.335 INFO 48844 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path &amp;#39;&lt;/span>&amp;#39;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-17 19:10:22.342 INFO &lt;span style="color:#bd93f9">48844&lt;/span> --- &lt;span style="color:#ff79c6">[&lt;/span> main&lt;span style="color:#ff79c6">]&lt;/span> com.example.demo.DemoApplicationKt : Started DemoApplicationKt in 1.129 seconds &lt;span style="color:#ff79c6">(&lt;/span>JVM running &lt;span style="color:#ff79c6">for&lt;/span> 1.396&lt;span style="color:#ff79c6">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>JVMの起動に1.396秒、アプリの起動に1.129秒がかかっていますね。何も依存関係がないので、おそらくこれが自分のマシンでは最速の起動時間と言えるのではないかと思います。これが実際の業務用のアプリとなると、アプリの起動だけで10秒以上かかることもあリますね。一回の起動では10秒でもあまり問題になることはありませんが、ローカルでのテストではテストごとにアプリが起動するような&lt;/p>
&lt;h4 id="quarkus-nativeの場合">Quarkus Nativeの場合&lt;/h4>
&lt;p>では、Quarkusの場合を見ていきたいと思います。まずNativeコンパイルができるというので、&lt;a class="link" href="https://www.graalvm.org/" target="_blank" rel="noopener"
>GraalVM&lt;/a>を利用してビルドしてみました。実際のビルドはGradleのタスクとして実行できて（固有のパラメータは必要ですが）、簡単です。そしてそれを実行してみた結果が以下です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>__ ____ __ _____ ___ __ ____ ______
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --/ __ &lt;span style="color:#f1fa8c">\/&lt;/span> / / / _ | / _ &lt;span style="color:#f1fa8c">\/&lt;/span> //_/ / / / __/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -/ /_/ / /_/ / __ |/ , _/ ,&amp;lt; / /_/ /&lt;span style="color:#f1fa8c">\ \ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&lt;span style="color:#f1fa8c">\_&lt;/span>__&lt;span style="color:#f1fa8c">\_\_&lt;/span>___/_/ |_/_/|_/_/|_|&lt;span style="color:#f1fa8c">\_&lt;/span>___/___/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,395 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> quarkus-sample 1.0.0-SNAPSHOT native &lt;span style="color:#ff79c6">(&lt;/span>powered by Quarkus 2.3.0.Final&lt;span style="color:#ff79c6">)&lt;/span> started in 0.018s. Listening on: http://0.0.0.0:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,397 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> Profile prod activated.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:24:18,397 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> Installed features: &lt;span style="color:#ff79c6">[&lt;/span>cdi, config-yaml, kotlin, resteasy-reactive, resteasy-reactive-jackson, smallrye-context-propagation, vertx&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>0.018秒がかかっています。ビルドしたプロジェクトの構造が単純であるのもありますが、それでもこの起動速度は確かに速いですね。これなら確かにマイクロサービスだけでなく、リクエストの多いサーバレスアプリケーションでも十分使えると思います。&lt;/p>
&lt;h4 id="quarkus-jvmの場合">Quarkus JVMの場合&lt;/h4>
&lt;p>Springの場合と同じく、Oracle JDK 17を利用して起動してみました。Quarkusには開発モードというものがあり、サーバを起動したまま修正ができるのですが、ここではあえてJarを作って起動しています。余談ですが、Springでは依存関係を全部含む場合はwarになりますが、Quarkusではuber-jarと言っているのが面白いです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>__ ____ __ _____ ___ __ ____ ______
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> --/ __ &lt;span style="color:#f1fa8c">\/&lt;/span> / / / _ | / _ &lt;span style="color:#f1fa8c">\/&lt;/span> //_/ / / / __/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -/ /_/ / /_/ / __ |/ , _/ ,&amp;lt; / /_/ /&lt;span style="color:#f1fa8c">\ \ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>--&lt;span style="color:#f1fa8c">\_&lt;/span>__&lt;span style="color:#f1fa8c">\_\_&lt;/span>___/_/ |_/_/|_/_/|_|&lt;span style="color:#f1fa8c">\_&lt;/span>___/___/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,897 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> quarkus-sample 1.0.0-SNAPSHOT on JVM &lt;span style="color:#ff79c6">(&lt;/span>powered by Quarkus 2.3.0.Final&lt;span style="color:#ff79c6">)&lt;/span> started in 0.761s. Listening on: http://0.0.0.0:8080
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,905 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> Profile prod activated.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 19:20:59,906 INFO &lt;span style="color:#ff79c6">[&lt;/span>io.quarkus&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>main&lt;span style="color:#ff79c6">)&lt;/span> Installed features: &lt;span style="color:#ff79c6">[&lt;/span>cdi, config-yaml, kotlin, resteasy-reactive, resteasy-reactive-jackson, smallrye-context-propagation, vertx&lt;span style="color:#ff79c6">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>今回は0.761秒がかかりました。Nativeと比べると確かに数十倍も遅くなっていますが、それでもSpringと比べ速い方ですね。&lt;/p>
&lt;p>こうやってアプリの起動が速くなると、ローカルで開発するときもユニットテストが早くなるので即座で確認ができるというメリットもあるかと思います。特にSpringで[RestTemplate]や&lt;a class="link" href="https://spring.pleiades.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/reactive/server/WebTestClient.html" target="_blank" rel="noopener"
>WebTestClient&lt;/a>などを使ったテストケースを書くとテストごとにアプリを起動することになるので、テストケースが増えれば増えるほどかかる時間が多いのが辛いものですね。なので、起動が速いと同じようなテストをQuarkusで書いてもかなり時間が節約できそうです。&lt;/p>
&lt;h3 id="springからの移行が簡単">Springからの移行が簡単&lt;/h3>
&lt;p>最初あまり意識してなかった部分ですが、Quarkusの良い点の一つは、Springからの移行が簡単ということです。アプリを新規に開発するときや既存のアプリのフレームワークを変更する場合には、技術選定において色々と考慮すべきものや観点があると思いますが、その中でいくつかを取り上げると「いかに工数を減らせるか」、「エンジニアを募集しやすいか」などがあるのはないかと思います。こういう観点からすると、現在のエンジニアにとって全く新しい技術だったり、業界であまり使われてない技術だったりすると会社としてもエンジニアとしても大変でしょう。こういう問題があるので、企業にとって新しい技術の導入は難しくなっていると思います。&lt;/p>
&lt;p>なので、新しい技術でありながらも業界でよく使われているものと似ているという点は、エンジニアの学習コストを減らせるのでかなりのメリットと言えるでしょう。では、実際のコードを観ながら、SpringのコードをQuarkusに移行するとした場合はどうなるかを見ていきたいと思います。&lt;/p>
&lt;h4 id="springの場合">Springの場合&lt;/h4>
&lt;p>まず、クエリパラメータにIDを渡し、Personというレコードのデータを取得するAPIがあるとしましょう。Springなら、以下のようなコードになるかと思います。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@RestController
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@RequestMapping(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonController&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GetMapping
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#50fa7b">PresonResponse&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@Service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonService&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> repository.findById(id).let { &lt;span style="color:#50fa7b">PersonDto&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="ktorの場合">Ktorの場合&lt;/h4>
&lt;p>Quarkusのコードを見る前に、まず同じコードをこのブログでも紹介したことのある&lt;a class="link" href="https://ktor.io/" target="_blank" rel="noopener"
>Ktor&lt;/a>で書くとどうなるかをまず見ていきたいと思います。これでSpringと全く違うフレームワークを選ぶという場合の比較ができるでしょう。&lt;/p>
&lt;p>Ktorもよいフレームワークではありますが、フレームワークそのものの設計思想はSpringと異なるので、既存のアプリを移行するとしたら色々と考慮すべきものが多いです。例えば、基本的にDIに対応していないのでライブラリを別途導入する必要がありますね。&lt;/p>
&lt;p>以下は、上記のSpringと同じAPIを、DIライブラリとして&lt;a class="link" href="https://insert-koin.io/" target="_blank" rel="noopener"
>Koin&lt;/a>を導入して実装したKtorの例です。かなり違う構造になっているのがわかります。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// DIの設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> personModule = module {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single { PersonService(&lt;span style="color:#ff79c6">get&lt;/span>()) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> single { PersonRepository() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Koinをアプリにインストール
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> install(Koin) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> modules(personModule)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// ルーティングをモジュール化して設定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> configureRouting()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// ルータにControllerを登録
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Application&lt;/span>.configureRouting() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> routing {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> personController()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">Route&lt;/span>.personController() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6272a4">// Serviceのインジェクション
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PersonService &lt;span style="color:#ff79c6">by&lt;/span> inject()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">get&lt;/span>(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/person&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#50fa7b">PresonResponse&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">// Service
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6272a4">&lt;/span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonService&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> repository.findById(id).let { &lt;span style="color:#50fa7b">PersonDto&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="quarkusの場合">Quarkusの場合&lt;/h4>
&lt;p>では、続いてQuarkusでAPIを作成した場合のコードを見ていきましょう。QuarkusでAPIを作成する方法は&lt;a class="link" href="https://resteasy.github.io" target="_blank" rel="noopener"
>RESTEasy&lt;/a>と&lt;a class="link" href="https://quarkus.io/guides/reactive-routes" target="_blank" rel="noopener"
>Reactive Routes&lt;/a>の二つのパターンがありますが、どちらを使った場合でもアプリの作成そのものに大きい違いはないので、ここではRESTEasyを使った実装を紹介したいと思います。まずは以下のコードをご覧ください。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Path(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonController&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GET
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonResponse {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> service.getPerson(id).let { &lt;span style="color:#50fa7b">PresonResponse&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@ApplicationScoped
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonService&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> repository: PersonRepository) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): PersonDto {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> repository.findById(id).let { &lt;span style="color:#50fa7b">PersonDto&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Springのコードど比較して、使っているアノテーションの種類が違うだけで、ほぼ同じ感覚で実装ができるのがわかります。なので、Ktorの場合のようにアーキテクチャを考え直す必要もなく、移行も簡単になるわけですね。また、RESTEasyを使う場合、ReactiveのAPIを作りやすいというメリットもあります。Reactiveだと&lt;a class="link" href="https://smallrye.io/smallrye-mutiny/" target="_blank" rel="noopener"
>Mutiny&lt;/a>を使うことになりますが、Uni/Multiの概念がMono/Fluxと1:1対応していると思って良いので、Spring WebFluxや他のReactive Streamを触ったことのある方ならすぐに適応できそうです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>@Path(&lt;span style="color:#f1fa8c">&amp;#34;/api/v1/person&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">PersonController&lt;/span>(&lt;span style="color:#ff79c6">private&lt;/span> &lt;span style="color:#ff79c6">val&lt;/span> service: PersonService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @GET
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">fun&lt;/span> &lt;span style="color:#50fa7b">getPerson&lt;/span>(id: Int): Uni&amp;lt;PersonResponse&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ff79c6">return&lt;/span> &lt;span style="color:#50fa7b">Uni&lt;/span>.createFrom().item(service.getPerson(id).let { &lt;span style="color:#50fa7b">PresonResponse&lt;/span>.from(&lt;span style="color:#ff79c6">it&lt;/span>) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>KtorやSpring WebFluxのRouter Functionのような書き方もそれなりの良い点はあるかと思いますが、やはりSpring MVCのような書き方に慣れている人も多いだろうし、そのような書き方で特に問題になることもないので、新しいフレームワークだとしてもこのように既存のものと同じような感覚でコードを書けるというのもそのフレームワークを選択しやすくする一つのセールズポイントになるのではないかと思います。例えば&lt;a class="link" href="https://nestjs.com/" target="_blank" rel="noopener"
>NestJS&lt;/a>のように、JavaScript用のフレームワークでもSpring MVCに似たようなコードを書けるのですが、おそらくこれもまたSpringを触った経験のあるエンジニアにアピールするためでしょう。&lt;/p>
&lt;p>こういう面からすると、すでにSpringの経験があるエンジニアならすぐにQuarkusに移行できて、既存のSpringプロジェクトも簡単に移行できそうなので良さそうです。&lt;/p>
&lt;h2 id="懸念">懸念&lt;/h2>
&lt;p>Quarkusを実際触ってみて、最も良いと思われたのは上記の通りですが、Nativeでアプリをビルドしながら、いくつかの懸念もあると感じました。例えば以下のようなものがあります。&lt;/p>
&lt;h3 id="nativeのビルドは遅い">Nativeのビルドは遅い&lt;/h3>
&lt;p>Nativeで起動速度が早くなるのは確かに良いところですが、問題はビルド自体は遅いということです。当然ながら、Nativeとしてビルドするということは、最初から全てのコードをマシンコードとしてコンパイルするということを意味します。JVM用のバイトコードはどの環境でも同じですが、マシンコードはそうではないので、そのプラットフォームに合わせたコードを生成するのに時間がかかるのは当然のことですね。例えば、ローカルでテストに使ったプロジェクトをNativeイメージとしてビルドした場合は以下のような時間がかかりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ./gradlew build -Dquarkus.package.type&lt;span style="color:#ff79c6">=&lt;/span>native
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; Task :quarkusBuild
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>building quarkus jar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> classlist: 2,311.58 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>cap&lt;span style="color:#ff79c6">)&lt;/span>: 3,597.91 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> setup: 5,450.32 ms, 1.19 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>19:22:21,827 INFO &lt;span style="color:#ff79c6">[&lt;/span>org.jbo.threads&lt;span style="color:#ff79c6">]&lt;/span> JBoss Threads version 3.4.2.Final
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>clinit&lt;span style="color:#ff79c6">)&lt;/span>: 779.71 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>typeflow&lt;span style="color:#ff79c6">)&lt;/span>: 14,308.32 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>objects&lt;span style="color:#ff79c6">)&lt;/span>: 16,140.38 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>features&lt;span style="color:#ff79c6">)&lt;/span>: 1,145.40 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> analysis: 33,857.15 ms, 4.33 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> universe: 1,718.32 ms, 5.14 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>parse&lt;span style="color:#ff79c6">)&lt;/span>: 2,635.36 ms, 5.14 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>inline&lt;span style="color:#ff79c6">)&lt;/span>: 7,363.76 ms, 5.99 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>compile&lt;span style="color:#ff79c6">)&lt;/span>: 26,314.40 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> compile: 40,954.87 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> image: 10,493.47 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> write: 2,111.59 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ff79c6">[&lt;/span>quarkus-sample-1.0.0-SNAPSHOT-runner:49336&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">[&lt;/span>total&lt;span style="color:#ff79c6">]&lt;/span>: 97,207.01 ms, 6.15 GB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BUILD SUCCESSFUL in 1m 43s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CIでビルドを行っていたり、頻繁にアプリの修正とデプロイが必要な場合にこれでかなりボトルネックになる可能性もあるかと思います。マシンパワーが十分か、デプロイまでの時間があまり気にならない場合は問題にならないと思いますが、起動速度が大事であるなら、その分ビルドに時間がかかると結局は同等のトレードオフになるだけですね。こういう場合はJarとしてビルドする時間や、他のフレームワークを使ってビルド〜起動までにかかる時間を測定してから判断した方が良いかなと思います。&lt;/p>
&lt;h3 id="ピークパフォーマンス">ピークパフォーマンス&lt;/h3>
&lt;p>一般的にCやC++のような言語と比べ、Java(JVM言語)は性能で劣るという話は常識のように受け入れられています。しかし、全ての状況においてそういうわけでもありません。適切なアルゴリズム、アプリケーションのデザインなど言語そのものとは無関係と言えることが理由な場合もありますが、言語の特性を考えてもそういうケースがあるということです。なぜなら、CやC++のようなネイティブコードを生成する言語と、JVM言語のコンパイラの特性が違うからです。&lt;/p>
&lt;p>仮想マシンを挟み、バイトコードをマシンコードにもう一度変換する必要があるJVM言語と比べ、最初からマシンコードを生成する言語の方が性能が優秀であることは当然です。実際それは数値としても表れていて、Javaが登場した当時には性能問題で色々と批判を受けていたらしいですね。今はJavaが比較的性能が大事であるサーバサイドアプリケーションを作成する場合によく採用されていますが、これも「ハードウェアの発展がある」からと言われるケースも多いです。&lt;/p>
&lt;p>ただ、全ての場合においてJVMを挟むアプリケーションがNativeより遅いわけでもありません。なぜなら、コンパイルには「最初から全てコンパイルしておく」&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E4%BA%8B%E5%89%8D%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9" target="_blank" rel="noopener"
>AOT&lt;/a>だけでなく、「必要に応じてコンパイルする」&lt;a class="link" href="https://ja.wikipedia.org/wiki/%E5%AE%9F%E8%A1%8C%E6%99%82%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9" target="_blank" rel="noopener"
>JIT&lt;/a>の方式もあるからです。&lt;/p>
&lt;p>JVMではJITによりバイトコードの分析と最適化を行い、マシンコードを生成することでより良い性能のコーどを作り出すと言われています。ここで最適化とは、利用頻度の高いメソッドや定数などを含めてオーバヘッドを減らすことを含みます。このような最適化が行われたコードをマシンコードに変換するとしたら、当然性能がより良くなることを期待できますね。ただ、ITは全ての場合に動作してくれるわけでもありません。コンパイルには時間とマシンパワーが必要なので、一度しか利用されないコードをいちいちマシンコードに変換するのは無駄なことですね。なので、JITでコンパイルされるコードは、そのコードの利用頻度により決定されます。よくJavaのマイクロベンチマークで使われている&lt;a class="link" href="https://github.com/openjdk/jmh" target="_blank" rel="noopener"
>JMH&lt;/a>でテストを行うとき、事前にウォーミングアップをおこなっているのも、JITによる最適化でベンチマークの精度を上げるための工夫です。&lt;/p>
&lt;h4 id="検証してみると">検証してみると&lt;/h4>
&lt;p>実際NativeかJVMかによってどれくらいランタイム性能が違うのか気になったので、ループで10万件のデータを作って返すだけのServiceを作成して処理時間を計測してみました。ここでControllerの戻り値に&lt;a class="link" href="https://smallrye.io/smallrye-mutiny/getting-started/creating-multis" target="_blank" rel="noopener"
>Multi&lt;/a>を使ったせいか、APIが呼び出されるたびにレスポンスまでの時間が大きく変化していたので、測定しているのはリクエストからレスポンスまでの時間より「forループによるデータの生成にかかった時間」を計測していると理解してください。&lt;/p>
&lt;p>NativeビルドとJarの実行に使ったのはどれもGraalVM CE 21.3.0(OpenJDK 11)で、処理時間の測定はKotlinの&lt;a class="link" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.system/measure-time-millis.html" target="_blank" rel="noopener"
>measureTimeMillis&lt;/a>で取得した値をログに吐くという方法を使っています。&lt;/p>
&lt;p>まずNativeで起動した場合の結果です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:14,061 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-6&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">89&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:15,630 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-1&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">52&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:17,079 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-15&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">106&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:18,174 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-5&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">49&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:19,523 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-11&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">50&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:20,468 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-4&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">50&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:21,739 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-7&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">124&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:23,113 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-12&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">53&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:24,073 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-13&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">49&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:12:25,308 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-2&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">53&lt;/span> ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また、以下がJVMで起動した場合の結果です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:32,240 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-8&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">163&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:35,057 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-6&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">33&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:39,418 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-11&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">40&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:42,211 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-3&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">25&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:44,149 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-10&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">38&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:46,283 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-2&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">24&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:48,262 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-20&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">22&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:49,854 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-12&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">26&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:51,552 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-23&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">23&lt;/span> ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2021-10-23 17:10:52,967 INFO &lt;span style="color:#ff79c6">[&lt;/span>com.ret.dom.ser.MemberService&lt;span style="color:#ff79c6">]&lt;/span> &lt;span style="color:#ff79c6">(&lt;/span>vert.x-eventloop-thread-7&lt;span style="color:#ff79c6">)&lt;/span> measured &lt;span style="color:#8be9fd;font-style:italic">time&lt;/span> was &lt;span style="color:#bd93f9">51&lt;/span> ms
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>やはりJITが関与しているせいか、JVMでは最初の実行で時間がかかっていて、その次から大幅に処理速度が早くなっているのがわかります。GraalVMのコンパイラのバージョンアップでさらにパフォーマンスが向上する可能性はあると思われますが、それはJVMの場合でも同じなので、どうしてもランタイムのピークパフォーマンスが大事な場合はJVMの利用を考慮しても良いかなと思います。&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>本当はメモリ使用量などをより正確に測る必要があると思いますが、それに関してはすでに&lt;a class="link" href="https://medium.com/swlh/springboot-vs-quarkus-a-real-life-experiment-be70c021634e" target="_blank" rel="noopener"
>記事があったので&lt;/a>、ここでは割愛します。結論から言いますと、確かにメモリ使用量はヒープを含めQuarkusの方が少ないですが、CPU使用量の最大値とLatencyにおいてはSpring Bootの方が優れているのを確認しました。ただ、ここはQuarkusの方が歴史が短いためであるということもありそうですね。&lt;/p>
&lt;p>とりあえず触ってみた感覚では、確かにKubernetes nativeと言えるだけのものではあると思われます。Nativeビルドしてみると、Jarと比べアプリのサイズ自体は大きくなるものの（倍ほど）、JDKがいらなくなるというのも良いですね。JDKのサイズはAdoptOpenJDKを基準におよそ300MBくらいです。インスタンスが一つの場合だとしたらあまり問題になりそうではないですが、もしインスタンスが増えるとしたらJDKだけでも必要なストレージのサイズが乗数で増えることになるので、Nativeにしたくもなるかなと思います。&lt;/p>
&lt;p>そのほかにも、さまざまなライブラリやフレームワークの組み合わせができるし、Spring Securityなどをそのまま用いることができるのも魅力的です。Springの経験のあるエンジニアなら誰でもすぐに慣れそうなので、会社の立場からも他のフレームワークを使う場合に比べ比較的エンジニアの募集に負担がなくなるのでは、と思ったりもします。&lt;/p>
&lt;p>Spring WebFluxやKtorもよかったのですが、また新しい強者が現れてどれを使うか悩ましい時代になりましたね。本当は&lt;a class="link" href="https://rocket.rs/" target="_blank" rel="noopener"
>Rocket&lt;/a>も触ってみたいんですが、果たして今年内にできるかどうか…&lt;/p>
&lt;p>では、また！&lt;/p></description></item></channel></rss>